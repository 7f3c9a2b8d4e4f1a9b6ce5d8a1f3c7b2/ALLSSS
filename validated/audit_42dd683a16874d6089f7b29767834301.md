# Audit Report

## Title
Threshold Validation Bypass via Empty Addresses in Association Organization Member List

## Summary
The Association contract's member management methods (`AddMember`, `ChangeMember`, `CreateOrganization`) do not validate that input addresses contain non-empty values before adding them to the organization member list. Since threshold validation counts all addresses but only valid addresses can vote, attackers can inflate member counts and configure mathematically valid but practically impossible voting thresholds, causing permanent governance deadlock.

## Finding Description

The vulnerability exists at three entry points where addresses are added to the member list without validation:

1. **AddMember** directly adds the input address without checking if it's empty [1](#0-0) 

2. **ChangeMember** adds a new member without validating its value [2](#0-1) 

3. **CreateOrganization** accepts the entire member list without individual address validation [3](#0-2) 

The `Validate()` method checks for empty lists and duplicates but does not validate individual address values [4](#0-3) 

The `Count()` method simply returns the collection size, including any empty addresses [5](#0-4) 

The protobuf `Address` type consists of a single `bytes value` field that can be empty [6](#0-5) 

**Root Cause:** Threshold validation uses `organizationMemberCount` from `Count()` to ensure mathematical constraints like `MaximalRejectionThreshold + MinimalApprovalThreshold <= organizationMemberCount`. However, this assumes all counted members can vote.

**Why Empty Addresses Cannot Vote:** When voting via `Approve`, `Reject`, or `Abstain`, the contract verifies the voter is in the member list using `AssertIsAuthorizedOrganizationMember` [7](#0-6) 

This assertion uses `Contains()` to check if `Context.Sender` exists in the member list [8](#0-7) 

Since `Context.Sender` is always a valid address from the transaction sender (never null or empty) [9](#0-8) , it can never match an empty address in the member list.

This creates a critical mismatch: empty addresses inflate the count used for threshold validation but cannot participate in voting.

## Impact Explanation

**Permanent Governance Deadlock:** An attacker with organizational control can permanently lock the organization by:

1. Adding empty addresses to inflate `Count()`
2. Setting thresholds that appear mathematically valid but are impossible to satisfy

**Example Attack:**
- Organization has 3 real members
- Attacker adds 2 empty addresses (Count becomes 5)
- Attacker sets `MinimalApprovalThreshold=4`, `MaximalRejectionThreshold=1`
- Validation passes: 4+1=5 ≤ 5 ✓
- **Result:** Future proposals need 4 approvals but only 3 real members exist
- Even if all 3 approve with 0 rejections: 3 < 4 → proposal cannot pass

The voting logic confirms this impact - approval counting only includes valid member addresses [10](#0-9) 

**Affected Parties:** 
- All organization members lose governance capability
- Funds controlled by the organization become permanently inaccessible if they require proposals to transfer
- No recovery mechanism exists once thresholds are misconfigured

## Likelihood Explanation

**Entry Points:** `AddMember` and `ChangeOrganizationThreshold` are callable by the organization address itself via the proposal execution mechanism [1](#0-0) 

**Attacker Prerequisites:**
- Must control the organization (ability to create and pass proposals)
- Realistic for: malicious creators during setup, temporarily compromised organizations, or organizations with low member counts where collusion is feasible

**Attack Execution:**
1. Create proposal calling `AddMember` with `new Address()` (empty ByteString value)
2. Vote to approve the proposal
3. Create proposal calling `ChangeOrganizationThreshold` with inflated thresholds
4. Vote to approve the threshold change
5. All future proposals become unpassable

**Technical Feasibility:** Protobuf3 allows Address messages with empty bytes fields. The contract performs no validation to reject such addresses. Valid addresses are 32 bytes [11](#0-10) , but the contract never enforces this for member addresses.

**Detection:** No events or validation errors warn about empty addresses being added. The misconfiguration only becomes apparent when voting unexpectedly fails.

## Recommendation

Add validation to ensure all member addresses have valid, non-empty values:

```csharp
private void ValidateAddress(Address address)
{
    Assert(address != null && !address.Value.IsNullOrEmpty(), "Invalid address.");
    Assert(address.Value.Length == AElfConstants.AddressHashLength, "Address must be 32 bytes.");
}
```

Apply this validation in:
1. `AddMember` - before adding to the member list
2. `ChangeMember` - validate the new member address
3. `CreateOrganization` - validate all addresses in `OrganizationMemberList`

Additionally, add validation in the `Validate()` method to check all existing member addresses, ensuring no invalid addresses persist in the organization state.

## Proof of Concept

```csharp
[Fact]
public async Task AddEmptyAddress_ThresholdBypass_Test()
{
    // Setup: Create organization with 3 real members
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Member1, Member2, Member3 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 2,
            MaximalRejectionThreshold = 1,
            MinimalVoteThreshold = 3,
            MaximalAbstentionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { Member1 } }
    };
    var orgAddress = await AssociationContractStub.CreateOrganization.SendAsync(createInput);
    
    // Attack Step 1: Add empty address via proposal
    var emptyAddress = new Address(); // Empty ByteString
    var addMemberProposal = await CreateProposalAsync(orgAddress.Output, 
        nameof(AssociationContractStub.AddMember), emptyAddress);
    await ApproveWithMinersAsync(addMemberProposal);
    await AssociationContractStub.Release.SendAsync(addMemberProposal);
    
    // Attack Step 2: Set impossible thresholds (need 4 approvals, only 3 real members)
    var newThreshold = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 4,
        MaximalRejectionThreshold = 0,
        MinimalVoteThreshold = 4,
        MaximalAbstentionThreshold = 0
    };
    var changeThresholdProposal = await CreateProposalAsync(orgAddress.Output,
        nameof(AssociationContractStub.ChangeOrganizationThreshold), newThreshold);
    await ApproveWithMinersAsync(changeThresholdProposal);
    await AssociationContractStub.Release.SendAsync(changeThresholdProposal);
    
    // Verify: New proposals cannot pass even with all 3 real members approving
    var testProposal = await CreateProposalAsync(orgAddress.Output, "SomeMethod", new Empty());
    await ApproveWithMinersAsync(testProposal); // All 3 approve
    
    // Should fail - only 3 approvals but needs 4
    var result = await AssociationContractStub.Release.SendWithExceptionAsync(testProposal);
    result.TransactionResult.Error.ShouldContain("Not approved");
}
```

**Notes:**
- The vulnerability is in production scope (Association contract)
- Does not require compromised system keys, only organizational control
- Creates a protocol invariant violation: threshold validation assumes all counted members can vote
- Impact is permanent governance deadlock with no recovery mechanism
- Attack is straightforward and economically feasible (only requires transaction fees)

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L7-10)
```csharp
    public int Count()
    {
        return organizationMembers_.Count;
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** src/AElf.Sdk.CSharp/CSharpSmartContractContext.cs (L59-62)
```csharp
    /// <summary>
    ///     The Sender of the transaction that is executing.
    /// </summary>
    public Address Sender => SmartContractBridgeContextImplementation.Sender;
```

**File:** src/AElf.Types/AElfConstants.cs (L8-8)
```csharp
        public const int AddressHashLength = 32;
```
