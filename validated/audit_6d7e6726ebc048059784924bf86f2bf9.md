# Audit Report

## Title
Last Irreversible Block (LIB) Progression Can Be Prevented Through Insufficient Miner Overlap Between Consecutive Rounds

## Summary
The AEDPoS consensus contract's LIB calculation mechanism can freeze indefinitely when fewer than MinersCountOfConsent (2/3+1) miners who produced blocks in the current round also produced blocks in the previous round. This causes the Last Irreversible Block height to stop advancing while block production continues normally, breaking finality guarantees, cross-chain operations, and eventually degrading blockchain performance.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates the Last Irreversible Block (LIB) height during consensus operations. [1](#0-0) 

The LIB calculation follows this process:

1. **Retrieves miners who produced blocks in the current round** using `GetMinedMiners()`
2. **Fetches their `ImpliedIrreversibleBlockHeight` values from the previous round** using `GetSortedImpliedIrreversibleBlockHeights()`
3. **Applies a filtering mechanism** that only includes miners with `ImpliedIrreversibleBlockHeight > 0`: [2](#0-1) 

4. **Checks if the count meets the consensus threshold** (`MinersCountOfConsent = total_miners * 2/3 + 1`): [3](#0-2) 

5. **Returns libHeight = 0 if insufficient overlap exists**

The critical issue is that when new rounds are generated, `MinerInRound` instances are created without explicitly initializing `ImpliedIrreversibleBlockHeight`, which defaults to 0: [4](#0-3) 

When `libHeight` is calculated as 0, the LIB update check prevents the update from occurring, causing the LIB to freeze at its previous value: [5](#0-4) 

**Trigger Conditions:**

This occurs when fewer than 2/3+1 of the miners producing blocks in round N+1 also produced blocks in round N. This can happen through:

1. **Network Recovery Scenarios**: After network partitions, when >1/3 of miners were offline in round N and recover to produce blocks in round N+1
2. **Byzantine Coordination**: >1/3 of miners deliberately alternate their participation across rounds
3. **Evil Miner Replacements**: When miners are replaced at term boundaries after exceeding the tolerable missed time slots threshold (4320 slots): [6](#0-5) 

## Impact Explanation

This vulnerability has **HIGH severity** due to multiple critical impacts:

**1. Cross-Chain Operations Failure**

The LIB is essential for cross-chain indexing and data validation. When LIB freezes, the `IrreversibleBlockFound` event stops firing, breaking cross-chain synchronization mechanisms that depend on it for safety guarantees. The cross-chain system explicitly relies on LIB progression for safe indexing operations.

**2. Finality Guarantees Compromised**

No new blocks become irreversible while the LIB is frozen. Applications and users relying on the `IrreversibleBlockFound` event for transaction finality will receive no updates, leaving all recent transactions in an unfinalized state indefinitely.

**3. Blockchain Performance Degradation**

The frozen LIB causes the blockchain mining status to degrade over time. The system tracks the gap between the current round and the LIB round: [7](#0-6) 

As the gap increases, the blockchain transitions from Normal → Abnormal → Severe status. In Severe status, the maximum blocks count is reduced to 1, severely crippling block production: [8](#0-7) 

**4. Operational Deception**

The chain continues producing blocks normally, making the LIB freeze difficult to detect until cross-chain operations fail or applications explicitly check finality status.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Legitimate Trigger Scenarios (No Attacker Required):**
- Network disruptions causing >1/3 of miners to miss round N while recovering for round N+1 (common in distributed systems)
- System recovery after outages where miner participation patterns are disrupted
- Term changes involving evil miner replacements where new miners lack overlap with the previous term

**Byzantine Attack Scenario:**
- Requires coordination of >1/3 of miners to alternate participation
- Economic cost includes mining reward loss during skipped rounds
- Miners accumulate `MissedTimeSlots` penalties but can sustain the attack for up to 3 days before being marked as evil [9](#0-8) 

**Detection Difficulty:**
The vulnerability is difficult to detect because block production continues normally. The LIB freeze only becomes apparent when:
- Cross-chain operations begin failing
- Applications explicitly check the LIB height and notice it hasn't advanced
- The blockchain enters Severe mining status after multiple rounds

**Recovery:**
No explicit recovery mechanism or circuit breaker exists. Recovery relies on natural stabilization when miner participation normalizes to restore sufficient overlap between consecutive rounds.

## Recommendation

Implement one or more of the following mitigations:

**1. Fallback LIB Calculation**
When insufficient overlap is detected, use an alternative LIB calculation method based on the current round's consensus rather than requiring overlap with the previous round. For example, calculate LIB based on the current round's miners' `ImpliedIrreversibleBlockHeight` values set during the current round.

**2. Minimum Overlap Enforcement**
Add validation during round transitions to ensure sufficient miner overlap between consecutive rounds. If overlap is insufficient, delay the round transition or use the previous round's LIB with a time-based advancement guarantee.

**3. LIB Progression Circuit Breaker**
Implement a maximum staleness threshold for LIB. If LIB hasn't advanced for N rounds, trigger emergency procedures such as:
- Using a degraded but safe LIB calculation based on current round only
- Emitting warnings to notify operators
- Implementing automatic recovery mechanisms

**4. Carry Forward ImpliedIrreversibleBlockHeight**
During round generation, carry forward miners' `ImpliedIrreversibleBlockHeight` from the previous round instead of resetting to 0:

```csharp
nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
{
    Pubkey = minerInRound.Pubkey,
    Order = order,
    ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
    ProducedBlocks = minerInRound.ProducedBlocks,
    MissedTimeSlots = minerInRound.MissedTimeSlots,
    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight // Carry forward
};
```

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Freezes_With_Insufficient_Miner_Overlap()
{
    // Setup: Initialize consensus with 7 miners (MinersCountOfConsent = 5)
    var miners = GenerateMiners(7);
    await InitializeConsensus(miners);
    
    // Round N: Only miners 0,1,2,3 produce blocks (4 miners)
    await ProduceBlocksForRound(miners.Take(4).ToList());
    var libHeightAfterRoundN = await GetCurrentLIBHeight();
    
    // Round N+1: Different set - miners 4,5,6 plus only miner 0 (4 miners total)
    // Overlap with round N = only 1 miner (miner 0)
    // MinersCountOfConsent = 5, but overlap = 1 < 5
    await ProduceBlocksForRound(new[] { miners[0], miners[4], miners[5], miners[6] });
    
    // Verify: LIB should freeze (not advance from round N)
    var libHeightAfterRoundNPlus1 = await GetCurrentLIBHeight();
    Assert.Equal(libHeightAfterRoundN, libHeightAfterRoundNPlus1); // LIB frozen
    
    // Verify: No IrreversibleBlockFound event was fired
    var events = GetIrreversibleBlockFoundEvents();
    Assert.Empty(events.Where(e => e.IrreversibleBlockHeight > libHeightAfterRoundN));
    
    // Verify: Cross-chain operations would fail due to frozen LIB
    // Verify: Blockchain status degrades over subsequent rounds
    await ProduceMultipleRoundsWithSamePattern(rounds: 10);
    var status = await GetBlockchainMiningStatus();
    Assert.Equal(BlockchainMiningStatus.Severe, status);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L25-39)
```csharp
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
