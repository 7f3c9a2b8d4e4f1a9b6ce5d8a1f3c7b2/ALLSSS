# Audit Report

## Title
NFT Type Removal Breaks Cross-Chain Protocol Creation Without Validation

## Summary
The `RemoveNFTType()` method allows parliament to remove NFT type mappings without validating whether existing NFT protocols depend on those types. When a type is removed, `CrossChainCreate()` fails for all protocols using that type prefix, breaking cross-chain NFT mirroring functionality until governance intervention restores the type mapping.

## Finding Description

The NFT contract initializes NFT type mappings that create bidirectional lookups between short names (e.g., "AR") and full names (e.g., "Art"). [1](#0-0) 

The `RemoveNFTType()` method allows parliament to remove these type mappings from all three state variables (NFTTypeFullNameMap, NFTTypeShortNameMap, and NFTTypes.Value), but only validates that the sender is parliament and the type exists. [2](#0-1) 

**Critical Gap:** This method never checks if existing protocols in `State.NftProtocolMap` use the type being removed. There is no iteration through existing protocols to validate dependencies.

When NFT protocols are created via `Create()`, they store the NFT type and generate symbols with the type's short name prefix. [3](#0-2) 

The symbol generation uses the type's short name as the prefix. [4](#0-3) 

The critical failure occurs in `CrossChainCreate()`, which mirrors NFT protocols from mainchain to sidechains. It extracts the 2-character type prefix from the symbol and looks it up in `State.NFTTypeFullNameMap`. If the type was removed, the lookup returns null and the assertion fails. [5](#0-4) 

**Attack Scenario:**
1. Mainchain: Protocol "AR12345" is created with type "Art" (enforced by mainchain-only creation check)
2. Sidechain: Parliament removes "AR" type mapping via `RemoveNFTType("AR")`
3. Sidechain: Any attempt to call `CrossChainCreate("AR12345")` extracts "AR" prefix and fails at the type lookup with error "Full name of AR not found"
4. All protocols with "AR*" prefix cannot be mirrored to that sidechain

## Impact Explanation

**Cross-Chain Integrity Breakdown:** This vulnerability breaks the cross-chain NFT protocol mirroring mechanism, a critical component of AElf's multi-chain architecture. The `CrossChainCreate()` method is the official way to replicate mainchain NFT protocols to sidechains, enabling cross-chain NFT functionality.

**Operational DoS:** Once a type is removed on a sidechain, ALL protocols with that type prefix become impossible to mirror from mainchain until parliament re-adds the type via `AddNFTType()`. During this period:
- NFT Protocol Creators cannot deploy protocols cross-chain
- NFT Holders cannot use/transfer NFTs on affected sidechains  
- dApp Developers experience application failures

**Severity Assessment:** HIGH - While requiring parliament governance (trusted role), this represents a critical design flaw where a legitimate governance action (type deprecation) inadvertently destroys core protocol functionality without safety checks. The impact affects the entire protocol ecosystem for that NFT type category and requires additional governance action to recover.

## Likelihood Explanation

**Reachable Entry Point:** `RemoveNFTType()` is a public method directly callable by parliament default address. [6](#0-5) 

**Feasible Preconditions:**
- Parliament approval required (high bar but achievable through standard governance)
- Parliament may legitimately want to deprecate unused NFT type categories
- **Critical gap:** No method exists to enumerate protocols by type or check usage before removal [7](#0-6) 
- Parliament members may not realize protocols already depend on the type

**Execution Practicality:** Single transaction after governance approval. The removal succeeds immediately without warnings.

**Detection Difficulty:** The impact is NOT immediately visible on the chain where removal occurs. The breakage only manifests when `CrossChainCreate()` is attempted later, potentially on a different chain, making root cause analysis difficult for end users.

**Probability Assessment:** MEDIUM - Parliament governance requirement creates a barrier, but the complete absence of usage validation combined with legitimate reasons to deprecate types makes accidental removal realistic during normal type management operations.

## Recommendation

Add validation to `RemoveNFTType()` to prevent removal of types that are actively used by existing protocols. While the contract cannot enumerate all protocols on-chain (due to the `MappedState` structure), it should either:

1. **Preventive approach:** Maintain a usage counter for each type that increments on protocol creation and prevents removal if count > 0
2. **Warning approach:** Emit a strong warning event and require explicit acknowledgment parameter
3. **Deprecation approach:** Instead of removing, mark types as "deprecated" to prevent new protocol creation while allowing existing protocols to continue cross-chain operations

Example fix for option 1:

```csharp
// Add to NFTContractState.cs
public MappedState<string, long> NFTTypeUsageCount { get; set; }

// Modify Create() to increment counter
public override StringValue Create(CreateInput input)
{
    // ... existing code ...
    var shortName = State.NFTTypeShortNameMap[input.NftType];
    State.NFTTypeUsageCount[shortName] = State.NFTTypeUsageCount[shortName].Add(1);
    // ... rest of creation ...
}

// Add validation to RemoveNFTType()
public override Empty RemoveNFTType(StringValue input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    Assert(input.Value.Length == 2, "Incorrect short name.");
    Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
    
    // NEW VALIDATION
    var usageCount = State.NFTTypeUsageCount[input.Value];
    Assert(usageCount == 0, $"Cannot remove type {input.Value}: {usageCount} protocols are using this type. Protocols must be migrated first.");
    
    // ... existing removal logic ...
}
```

## Proof of Concept

This proof of concept cannot be provided as a runnable test because it requires a multi-chain test environment with both mainchain and sidechain NFT contract deployments, plus parliament governance setup. However, the vulnerability can be validated by code inspection:

1. Create protocol on mainchain via `Create()` - symbol will have 2-char type prefix
2. On sidechain, parliament calls `RemoveNFTType()` with that prefix - succeeds without checking protocols
3. On sidechain, call `CrossChainCreate()` with the protocol symbol - fails at line 90-93 with "Full name of [prefix] not found"

The code paths are directly traceable in the cited file locations without requiring execution.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L9-12)
```csharp
    public override NFTProtocolInfo GetNFTProtocolInfo(StringValue input)
    {
        return State.NftProtocolMap[input.Value];
    }
```
