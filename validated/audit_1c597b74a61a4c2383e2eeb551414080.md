# Audit Report

## Title
Missing LIB Round Number Validation Allows Consensus State Corruption in NextTerm/NextRound Operations

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockRoundNumber` is less than the current `RoundNumber` when processing `NextTerm` and `NextRound` operations. A malicious miner can inject a round where the Last Irreversible Block (LIB) round number exceeds or equals the current round number, creating a logical impossibility that corrupts consensus state permanently.

## Finding Description

The vulnerability exists in the validation flow for consensus round transitions. When a miner produces a block triggering `NextTerm` or `NextRound`, they provide round information including `ConfirmedIrreversibleBlockRoundNumber` and `RoundNumber`.

**Root Cause:**

The validation logic only applies `LibInformationValidationProvider` to `UpdateValue` behavior, not to `NextRound` or `NextTerm` behaviors. [1](#0-0) 

The `LibInformationValidationProvider` only checks that LIB information doesn't go backwards, but never validates that `ConfirmedIrreversibleBlockRoundNumber < RoundNumber`. [2](#0-1) 

For `NextTerm`, only `RoundTerminateValidationProvider` is used, which validates round number, term number, and inValues, but not LIB constraints. [3](#0-2) 

**Attack Path:**

1. Malicious miner is scheduled to produce a block for `NextTerm` or `NextRound`
2. Miner crafts malicious input with `RoundNumber = currentRound.RoundNumber + 1` (valid) and `ConfirmedIrreversibleBlockRoundNumber >= RoundNumber` (malicious)
3. Validation passes because LIB constraints are not checked for these behaviors
4. The input is converted to a `Round` object that directly copies the LIB values without validation [4](#0-3) 
5. `ProcessNextTerm` stores the corrupted round via `AddRoundInformation` [5](#0-4) 
6. The corrupted state persists because future rounds copy these values directly [6](#0-5) 

## Impact Explanation

**Consensus State Corruption:**
The blockchain's consensus state will contain an impossible condition where the confirmed irreversible block's round number is greater than or equal to the current round number. This violates the fundamental invariant that LIB always lags behind the current round.

**Persistent Corruption:**
Once injected, the corrupted values propagate to all subsequent rounds since `GenerateNextRoundInformation` copies these values without validation. [7](#0-6)  The corruption becomes permanent in the consensus state.

**Mining Status Miscalculation:**
The `BlockchainMiningStatusEvaluator` uses these values to determine mining health status. [8](#0-7)  With corrupted LIB round numbers where `libRoundNumber >= currentRoundNumber`, the status evaluation logic malfunctions. [9](#0-8)  The blockchain would incorrectly report Normal status when it should detect Abnormal or Severe conditions, potentially causing fork issues or failure to apply proper mining restrictions.

**Cross-Chain Impact:**
LIB information is critical for cross-chain operations. Corrupted LIB round numbers could affect side-chain synchronization and cross-chain transaction verification that depend on consensus finality.

**Severity:** HIGH - Corrupts critical consensus invariants with permanent, system-wide effects.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires being an active miner in the current miner list (verified by `PreCheck()`) [10](#0-9) 
- Must wait for their scheduled time slot to produce a `NextTerm` or `NextRound` block
- No additional privileges beyond standard miner permissions required

**Attack Complexity:**
- Low complexity: Simply craft a malicious `NextTermInput` or `NextRoundInput` with invalid LIB values
- The attack is a single transaction during the attacker's mining turn
- No need to coordinate with other miners or exploit timing windows

**Feasibility:**
- Execution is straightforward given miner status
- Miners call `NextTerm` and `NextRound` as public methods [11](#0-10) [12](#0-11) 
- No economic cost beyond normal mining operations
- Attack succeeds immediately upon block acceptance
- Detection is difficult as the corruption doesn't cause immediate failures

**Probability:** MEDIUM-HIGH
While requiring miner status limits the attacker pool, miners regularly produce NextTerm and NextRound blocks, providing frequent opportunities. A compromised or malicious miner can execute this attack with certainty during their turn.

## Recommendation

Add `LibInformationValidationProvider` to the validation providers for both `NextRound` and `NextTerm` behaviors, and enhance `LibInformationValidationProvider` to validate that `ConfirmedIrreversibleBlockRoundNumber < RoundNumber`.

**Fix 1: Update validation logic in AEDPoSContract_Validation.cs**
```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

**Fix 2: Enhance LibInformationValidationProvider.cs**
```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    var pubkey = validationContext.SenderPubkey.ToHex();
    
    // Existing backwards check
    if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
        providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
        (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
         baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
    {
        validationResult.Message = "Incorrect lib information.";
        return validationResult;
    }
    
    // ADD THIS: Validate LIB round is less than current round
    if (providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
        providedRound.ConfirmedIrreversibleBlockRoundNumber >= providedRound.RoundNumber)
    {
        validationResult.Message = "LIB round number must be less than current round number.";
        return validationResult;
    }
    
    // ... rest of existing validation
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextTerm_WithInvalidLibRoundNumber_ShouldCorruptConsensusState()
{
    // Setup: Initialize consensus with valid first round
    await InitializeConsensusAsync();
    
    // Get current round information
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var currentRoundNumber = currentRound.RoundNumber;
    
    // Attacker: Create malicious NextTermInput with LIB round >= current round
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = currentRoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        ConfirmedIrreversibleBlockHeight = 100,
        ConfirmedIrreversibleBlockRoundNumber = currentRoundNumber + 1, // MALICIOUS: LIB round >= current round
        RealTimeMinersInformation = { /* valid miner info */ },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute attack as active miner
    await MinerConsensusStub.NextTerm.SendAsync(maliciousNextTermInput);
    
    // Verify: Consensus state is corrupted
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Assert: LIB round number >= current round number (impossible condition)
    Assert.True(newRound.ConfirmedIrreversibleBlockRoundNumber >= newRound.RoundNumber,
        "Consensus state corrupted: LIB round number should never be >= current round number");
    
    // Verify: Mining status evaluator malfunctions
    var maxBlocksCount = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    Assert.Equal(AEDPoSContractConstants.MaximumTinyBlocksCount, maxBlocksCount.Value);
    // Status incorrectly shows Normal when it should be detecting an anomaly
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-91)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L35-37)
```csharp
        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L123-128)
```csharp
            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
