# Audit Report

## Title
Continuous Blocks Validation Bypasses Severe Status Limit Due to Stale State-Based Threshold

## Summary
The `ContinuousBlocksValidationProvider` validates blocks using a stale `LatestPubkeyToTinyBlocksCount` value from the previous block's execution, allowing miners to produce up to 8 consecutive blocks during Severe blockchain status instead of the intended 1-block limit. This defeats the consensus safety mechanism designed to force frequent miner rotation during critical network conditions.

## Finding Description

The vulnerability exists in a timing mismatch between validation and state updates during block processing.

**Validation Phase (Pre-Execution):**
The validation context retrieves `LatestPubkeyToTinyBlocksCount` from state that was set during the previous block's post-execution phase. [1](#0-0) 

The `ContinuousBlocksValidationProvider` only checks if `BlocksCount < 0`, without considering the current blockchain status or LIB position. [2](#0-1) 

**State Update Phase (Post-Execution):**
After block execution, `GetMaximumBlocksCount()` is called to determine the appropriate limit based on current LIB status. When the blockchain is in Severe status (R >= R_LIB + 8), the limit should be 1 consecutive block per miner. [3](#0-2) 

The blockchain status is determined by comparing current round number with LIB round number using the `BlockchainMiningStatusEvaluator`. [4](#0-3) 

**Critical Flaw:**
When the same miner produces consecutive blocks, `ResetLatestProviderToTinyBlocksCount()` only decrements the existing `BlocksCount` by 1, completely ignoring the `minersCountInTheory` parameter that reflects the current blockchain status limit. [5](#0-4) 

The `minersCountInTheory` value (which equals 1 during Severe status) is only applied when a different miner produces a block. [6](#0-5) 

**Attack Scenario:**
1. Miner A starts producing blocks in Normal status with `BlocksCount = 7` (MaximumTinyBlocksCount - 1) [7](#0-6) 
2. Network conditions cause LIB to lag by 8+ rounds, transitioning to Severe status
3. Validation still uses the stale `BlocksCount = 7`, which passes the check (7 >= 0)
4. Post-execution decrements to 6, then 5, then 4... continuing for 8 total blocks
5. Only when `BlocksCount` becomes -1 does validation finally fail

This allows miners to produce up to 8 consecutive blocks in Severe status, when the protocol explicitly limits them to 1 block.

## Impact Explanation

**Critical Consensus Safety Violation:**
The Severe blockchain status is triggered when LIB falls dangerously behind (8+ rounds). The code comment explicitly states the intent: "If R >= R_LIB + CB1, CB goes to 1". [8](#0-7) 

During this critical period, the consensus protocol is designed to force frequent miner rotation by limiting each miner to producing only 1 consecutive block. The system even fires an `IrreversibleBlockHeightUnacceptable` event to notify miners not to package normal transactions. [9](#0-8) 

This vulnerability defeats that safety mechanism entirely. A miner who began producing blocks before the Severe status transition can continue producing up to 8 consecutive blocks, representing an 8x violation of the intended safety limit.

**Quantified Damage:**
- Instead of 1 block per miner in Severe status, miners can produce up to 8 blocks
- The extra 7 blocks occur during the most critical network conditions
- This prolongs the period where a single miner controls block production
- Increases fork risk and worsens network split conditions when consensus is already struggling
- Defeats the fork-prevention mechanism at precisely the time it's most needed

**Affected Parties:**
All network participants suffer from prolonged consensus instability, increased fork probability, and delayed LIB advancement during critical network conditions.

## Likelihood Explanation

**Attack Complexity: Low**
This vulnerability triggers automatically during normal network operations without requiring any malicious intent. It occurs naturally when:
1. Network stress causes LIB to lag by 8+ rounds (common during partitions or slow propagation)
2. Blockchain status transitions from Normal to Severe
3. A miner happens to be producing consecutive blocks at the time of transition

**Attacker Capabilities: None Required**
No special permissions, collusion, or attack infrastructure needed. Any miner producing consecutive blocks when the status transition occurs will automatically exceed the Severe limit.

**Preconditions: Realistic**
Network conditions causing LIB lag occur regularly in distributed consensus systems. Status transitions are part of normal protocol operation during network stress. Miners naturally produce consecutive blocks during their assigned time slots.

**Detection Difficulty: High**
The extra blocks are validly signed, properly timestamped, and pass all other consensus checks. They appear as legitimate block production, making the violation difficult to detect without specifically monitoring BlocksCount against current blockchain status.

**Probability: High**
Status transitions occur frequently during network stress periods, and miners routinely produce multiple consecutive blocks. The vulnerability triggers deterministically whenever these common conditions align.

## Recommendation

Modify `ResetLatestProviderToTinyBlocksCount()` to respect the current blockchain status limit even when the same miner continues producing blocks. The fix should enforce the new limit immediately upon status transition:

```csharp
private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
{
    LatestPubkeyToTinyBlocksCount currentValue;
    if (State.LatestPubkeyToTinyBlocksCount.Value == null)
    {
        currentValue = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = _processingBlockMinerPubkey,
            BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
        };
        State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
    }
    else
    {
        currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
        if (currentValue.Pubkey == _processingBlockMinerPubkey)
        {
            // FIX: Cap the decremented value by the current limit
            var newCount = currentValue.BlocksCount.Sub(1);
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = Math.Min(newCount, minersCountInTheory.Sub(1))
            };
        }
        else
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = minersCountInTheory.Sub(1)
            };
    }
}
```

This ensures that when the blockchain status changes to Severe (minersCountInTheory = 1), the BlocksCount is immediately capped to 0, preventing any additional consecutive blocks from the same miner.

## Proof of Concept

The vulnerability can be demonstrated by simulating a status transition during consecutive block production:

1. Initialize blockchain in Normal status with miner producing blocks (BlocksCount starts at 7)
2. Cause LIB to lag by 8+ rounds to trigger Severe status
3. Observe that GetMaximumBlocksCount() returns 1
4. Verify that validation still passes with BlocksCount = 7, 6, 5, 4, 3, 2, 1, 0
5. Confirm that 8 blocks are produced before validation fails at BlocksCount = -1

The test would verify that:
- `GetMaximumBlocksCount()` returns 1 during Severe status [10](#0-9) 
- `ResetLatestProviderToTinyBlocksCount()` only decrements for same miner [11](#0-10) 
- `ContinuousBlocksValidationProvider` allows blocks until BlocksCount < 0 [12](#0-11) 

This demonstrates the 8x violation of the Severe status limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L58-58)
```csharp
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L57-67)
```csharp
        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-129)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
