# Audit Report

## Title
Rounding Error Exploitation in TokenConverter Allows Fee Avoidance and Underpayment Through Repeated Small Purchases

## Summary
The TokenConverter contract's Bancor pricing formula and fee calculation both use decimal-to-long truncation, discarding fractional token amounts. When combined with production's equal connector weights configuration, attackers can underpay for tokens by splitting purchases into many small transactions, avoiding fees entirely on small purchases and accumulating rounding losses that benefit the attacker at the protocol's expense.

## Finding Description

The vulnerability exists in the Bancor pricing formula implementation where decimal-to-long casting causes precision loss. [1](#0-0) 

When connector weights are equal, which occurs in production for all resource token pairs, [2](#0-1)  the simplified Bancor formula truncates the mathematically correct payment amount. Each individual purchase loses the fractional cost to rounding down.

The `Buy` function compounds this issue with fee truncation. [3](#0-2) 

When `amountToPay * 0.005 < 1.0` (i.e., when `amountToPay < 200`), the fee truncates to zero and is not charged. [4](#0-3) 

The production configuration uses a fee rate of 0.005 (0.5%). [5](#0-4) 

There is no minimum purchase amount enforcement in the `Buy` function beyond the implicit requirement that the amount must be positive (validated in BancorHelper). [6](#0-5) 

**Attack Execution:**
1. Attacker determines desired total amount to purchase (e.g., 1,000 tokens)
2. Instead of one bulk purchase, splits into many small purchases
3. Each small purchase where `amountToPay < 200` pays zero fees
4. Each transaction benefits from truncation rounding down
5. Total cost is less than one bulk purchase would cost

Balances are updated after each transaction, [7](#0-6)  but this doesn't prevent exploitation because the attacker benefits from accumulated truncation losses and fee avoidance across all transactions.

## Impact Explanation

**Direct Financial Loss:**
- **Rounding Loss:** Each transaction truncates the exact decimal payment amount to a long integer, potentially saving up to 0.999 tokens per transaction for the attacker
- **Fee Avoidance:** When `amountToPay < 200`, fees are completely avoided (100% of the 0.5% fee saved)
- **Protocol Underpayment:** The TokenConverter contract receives less base tokens than mathematically correct according to the Bancor formula

**Affected Parties:**
1. **TokenConverter contract reserves:** Become imbalanced as it receives less payment than the formula dictates
2. **Treasury contract:** Loses 50% of fees that should be donated [8](#0-7) 
3. **All token holders:** Suffer inflationary impact from the 50% of fees that should be burned to reduce supply [9](#0-8) 

The losses scale proportionally with purchase volume and token values. This breaks the protocol's core pricing invariant that users must pay the correct Bancor formula price plus the configured fee percentage.

## Likelihood Explanation

**High Likelihood due to:**

1. **Accessibility:** The `Buy` function is public with no authorization requirements [10](#0-9) 

2. **Preconditions Met in Production:** 
   - Resource token pairs use equal connector weights (0.005 each) [11](#0-10) 
   - Fee rate is 0.005 (0.5%) [12](#0-11) 

3. **No Protections:** 
   - No minimum purchase amount validation
   - No minimum fee requirement
   - No rate limiting or anti-abuse mechanisms

4. **Economic Viability:** Fee avoidance alone (100% savings on fees for small purchases) may justify the attack cost. With low transaction fees or high token values, the combined savings from rounding and fee avoidance become profitable. Bots can automate execution efficiently.

5. **Detection Difficulty:** Appears as normal trading activityâ€”many small legitimate purchases rather than suspicious bulk operations.

## Recommendation

Implement the following protections:

1. **Enforce Minimum Purchase Amount:** Add a minimum purchase threshold that ensures fees cannot be avoided through small transactions:
```csharp
Assert(input.Amount >= MinimumPurchaseAmount, "Purchase amount too small");
```

2. **Enforce Minimum Fee:** Ensure a minimum fee is always charged regardless of purchase size:
```csharp
var calculatedFee = Convert.ToInt64(amountToPay * GetFeeRate());
var fee = Math.Max(calculatedFee, MinimumFee);
```

3. **Use Rounding Instead of Truncation:** Consider rounding to nearest instead of always rounding down, or use a higher precision internal representation:
```csharp
var fee = (long)Math.Round(amountToPay * GetFeeRate(), MidpointRounding.AwayFromZero);
```

4. **Add Rate Limiting:** Consider implementing per-address rate limiting to prevent rapid repeated small purchases.

## Proof of Concept

```csharp
[Fact]
public async Task RoundingErrorExploitation_FeeAvoidanceTest()
{
    // Setup: Initialize TokenConverter with production config
    await CreateWriteToken();
    await InitializeTreasuryContractAsync();
    await InitializeTokenConverterContract();
    await PrepareToBuyAndSell();

    var fromConnectorBalance = ELFConnector.VirtualBalance;
    var toConnectorBalance = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
    
    // Calculate cost for bulk purchase of 1000 tokens
    var bulkAmountToPay = BancorHelper.GetAmountToPayFromReturn(
        fromConnectorBalance, 
        decimal.Parse(ELFConnector.Weight),
        toConnectorBalance, 
        decimal.Parse(WriteConnector.Weight), 
        1000L);
    var bulkFee = Convert.ToInt64(bulkAmountToPay * 5 / 1000); // 0.005 fee rate
    var bulkTotalCost = bulkAmountToPay + bulkFee;
    
    // Execute many small purchases (1 token each)
    long smallPurchasesTotalCost = 0;
    long smallPurchasesTotalFees = 0;
    
    for (int i = 0; i < 1000; i++)
    {
        var currentFromBalance = ELFConnector.VirtualBalance + smallPurchasesTotalCost;
        var currentToBalance = toConnectorBalance - i;
        
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            currentFromBalance, 
            decimal.Parse(ELFConnector.Weight),
            currentToBalance, 
            decimal.Parse(WriteConnector.Weight), 
            1L);
        var fee = Convert.ToInt64(amountToPay * 5 / 1000);
        
        smallPurchasesTotalCost += amountToPay + fee;
        smallPurchasesTotalFees += fee;
        
        await DefaultStub.Buy.SendAsync(new BuyInput
        {
            Symbol = WriteConnector.Symbol,
            Amount = 1L,
            PayLimit = amountToPay + fee + 100L
        });
    }
    
    // Verify exploit: small purchases cost less than bulk
    smallPurchasesTotalCost.ShouldBeLessThan(bulkTotalCost);
    
    // Verify fee avoidance when amountToPay < 200
    smallPurchasesTotalFees.ShouldBeLessThan(bulkFee);
    
    // Verify Treasury received less than it should
    var treasuryDonations = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
    treasuryDonations.Value[NativeSymbol].ShouldBeLessThan(bulkFee.Div(2));
}
```

## Notes

The vulnerability is confirmed through code analysis showing:
1. Production configuration uses equal connector weights (0.005) for resource token pairs
2. Fee rate is 0.005 (0.5%) in production
3. No minimum purchase amount or fee enforcement exists
4. Decimal-to-long truncation occurs in both price calculation and fee calculation
5. The `Buy` function is public and can be called repeatedly without restrictions

The actual savings percentage depends on specific reserve sizes and purchase amounts, but the principle holds: splitting purchases allows fee avoidance and benefits from accumulated rounding errors at the protocol's expense.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L80-84)
```csharp
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L230-249)
```csharp
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L254-259)
```csharp
        State.TokenConverterContract.Initialize.Send(new InitializeInput
        {
            FeeRate = EconomicContractConstants.TokenConverterFeeRate,
            Connectors = { connectors },
            BaseTokenSymbol = Context.Variables.NativeSymbol
        });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-130)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L133-149)
```csharp
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L214-241)
```csharp
    private void HandleFee(long fee)
    {
        var donateFee = fee.Div(2);
        var burnFee = fee.Sub(donateFee);

        // Donate 0.5% fees to Treasury
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = donateFee
            });
        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Spender = State.DividendPoolContract.Value,
            Amount = donateFee
        });
        State.DividendPoolContract.Donate.Send(new DonateInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Amount = donateFee
        });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L243-257)
```csharp
        // Transfer to self contract then burn
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = burnFee
            });
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L7-8)
```csharp
    // Token Converter Contract related.
    public const string TokenConverterFeeRate = "0.005";
```
