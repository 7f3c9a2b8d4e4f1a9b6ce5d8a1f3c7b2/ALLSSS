# Audit Report

## Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

## Summary
When a miner replaces their public key mid-term via `ReplaceCandidatePubkey`, the Election Contract removes the old pubkey's `candidateInformation` while the Consensus Contract only updates the current round, leaving previous rounds with stale pubkey data. At term end, `TakeSnapshot` retrieves miners from stored previous round data containing old pubkeys and attempts to update their `candidateInformation`, but silently fails due to an early return when the data is null. This causes miners to permanently lose credit for terms where they actively participated.

## Finding Description

The vulnerability stems from incomplete synchronization between Election and Consensus contracts during pubkey replacement.

**Root Cause Flow:**

When `ReplaceCandidatePubkey` is executed, the Election Contract transfers the `candidateInformation` from old to new pubkey and **removes the old entry entirely**: [1](#0-0) 

The Consensus Contract is notified via `RecordCandidateReplacement`, which **only updates the current round** in state storage: [2](#0-1) 

**Critical Gap:** Previous rounds stored in `State.Rounds[previousRoundNumbers]` are never updated and still contain the old pubkey.

**Failure Point at Term End:**

When the consensus contract calls `TakeSnapshot` at term end, it retrieves the previous term's miner list: [3](#0-2) 

The `GetPreviousTermMinerPubkeyList` method returns pubkeys **directly from stored round data without applying any replacement mapping**: [4](#0-3) 

The private `UpdateCandidateInformation` method has an **early return when `candidateInformation` is null**, preventing any updates: [5](#0-4) 

Since the old pubkey's `candidateInformation` was removed during `ReplaceCandidatePubkey`, the update silently fails and the miner's `Terms` list and `ContinualAppointmentCount` are never updated for that term.

**Why Existing Protections Fail:**

The codebase has a `GetNewestPubkey` method specifically designed to handle pubkey replacements: [6](#0-5) 

This function is correctly used in other flows such as vote withdrawal: [7](#0-6) 

And in view methods for snapshot retrieval: [8](#0-7) 

However, it is **not used** in the `TakeSnapshot` flow before calling `UpdateCandidateInformation`, causing the vulnerability.

## Impact Explanation

**Direct Impact:**
- Miners who replace their pubkeys lose historical credit for terms where they actively participated and produced blocks
- The `Terms` list becomes incomplete, violating the documented invariant that tracks "The number of terms that the candidate is elected" as defined in the protocol: [9](#0-8) 

- `ContinualAppointmentCount` is incorrectly calculated, breaking continuity tracking for consecutive term participation

**Affected Parties:**
- Any miner using the legitimate pubkey replacement feature for key rotation
- Voters relying on accurate candidate participation history for informed voting decisions
- Off-chain systems or UIs displaying miner participation records

**Severity:** High - This directly compromises the integrity of election system records, which are fundamental to transparency and accountability in the AEDPoS consensus mechanism. While it doesn't cause direct fund loss, it breaks critical protocol invariants that could affect future eligibility or reward calculations if the `Terms` list is used in such logic.

## Likelihood Explanation

**Trigger Conditions:**
- Any registered candidate/miner with admin permission can call `ReplaceCandidatePubkey` (legitimate functionality)
- Can occur at any point during a term
- The term credit loss happens automatically when the term ends and the consensus contract calls `TakeSnapshot`: [10](#0-9) 

**Attack Complexity:** Minimal - simply use the legitimate pubkey replacement feature. No race conditions, no special setup required.

**Probability:** High - This occurs for every miner who replaces their pubkey before a term ends. The feature is specifically designed for key rotation scenarios in production environments, making usage expected and encouraged for security best practices.

## Recommendation

Modify the `TakeSnapshot` method to apply pubkey replacement mapping before updating candidate information:

```csharp
// In ElectionContract_Maintainence.cs, TakeSnapshot method
var previousTermMinerList =
    State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

// Apply GetNewestPubkey mapping before updating
foreach (var oldPubkey in previousTermMinerList)
{
    var newestPubkey = GetNewestPubkey(oldPubkey); // Resolve to current pubkey
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

This ensures that term credit is correctly attributed to the miner's current pubkey identity, preserving historical participation records across key rotations.

## Proof of Concept

```csharp
[Fact]
public async Task MinerLosesTermCreditAfterMidTermPubkeyReplacement()
{
    // Setup: Initialize election and consensus, advance to term 2
    await InitializeElectionAndConsensus();
    
    // Miner announces election and gets elected in term 2
    var minerKeyPair = MinerKeyPairs[0];
    var newKeyPair = MinerKeyPairs[1];
    var adminKeyPair = AdminKeyPairs[0];
    await AnnounceElectionAsync(minerKeyPair);
    await AdvanceToNextTerm(); // Now in term 2, miner is active
    
    // Verify miner is producing blocks in term 2
    await ProduceBlocksInCurrentTerm(minerKeyPair);
    
    // Mid-term: Admin replaces miner's pubkey
    var adminStub = GetElectionStub(adminKeyPair);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair.PublicKey.ToHex(),
        NewPubkey = newKeyPair.PublicKey.ToHex()
    });
    
    // Advance to term 3 (triggers TakeSnapshot for term 2)
    await AdvanceToNextTerm();
    
    // Check new pubkey's candidateInformation
    var candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = newKeyPair.PublicKey.ToHex() });
    
    // BUG: Terms list should contain term 2, but it doesn't
    candidateInfo.Terms.ShouldContain(2L); // This will FAIL - demonstrating the vulnerability
}
```

## Notes

The vulnerability is particularly insidious because:
1. It fails silently without reverts or error messages
2. The affected miner may not notice until reviewing historical records
3. The data loss is permanent once the term ends
4. The `GetNewestPubkey` infrastructure already exists but isn't used consistently across all code paths

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L430-434)
```csharp
        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L484-492)
```csharp
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-472)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L63-63)
```csharp
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L151-151)
```csharp
            var newestPubkey = GetNewestPubkey(bannedCandidate);
```

**File:** protobuf/election_contract.proto (L365-380)
```text
message CandidateInformation {
    // Candidateâ€™s public key.
    string pubkey = 1;
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
    // The number of blocks the candidate has produced.
    int64 produced_blocks = 3;
    // The time slot for which the candidate failed to produce blocks.
    int64 missed_time_slots = 4;
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
    // The transaction id when the candidate announced.
    aelf.Hash announcement_transaction_id = 6;
    // Indicate whether the candidate can be elected in the current term.
    bool is_current_candidate = 7;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```
