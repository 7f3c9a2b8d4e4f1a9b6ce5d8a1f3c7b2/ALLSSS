# Audit Report

## Title
Dictionary Access Vulnerability in Consensus Block Production Causes Chain Halt via Miner Pubkey Replacement Race Condition

## Summary
The AEDPoS consensus contract contains unprotected dictionary accesses to `RealTimeMinersInformation` during block production that trigger `KeyNotFoundException` crashes when a miner's public key is replaced mid-block-production by a candidate admin. This race condition between `GetConsensusCommand` and `GetConsensusExtraData` allows disruption of consensus block production, causing missed time slots and potential chain stall.

## Finding Description

The vulnerability exists in the consensus block production flow where dictionary accesses lack key existence validation before accessing `RealTimeMinersInformation`.

**Primary crash locations:** [1](#0-0) 

These lines directly access the dictionary without checking if the key exists. The only validation is an empty pubkey check on line 18, but no `ContainsKey` check before dictionary access.

**Attack mechanism via pubkey replacement:**

The Election Contract allows candidate admins to replace miner pubkeys at any time: [2](#0-1) 

This triggers `RecordCandidateReplacement` which removes the old pubkey from the current round's `RealTimeMinersInformation`: [3](#0-2) 

**Race condition window:**

Block production flow has a critical time gap between two separate RPC calls:

1. `GetConsensusCommand` validates miner is in list: [4](#0-3) 

2. Later, `GetConsensusExtraData` is called for actual block production: [5](#0-4) 

Between these calls, if `RecordCandidateReplacement` executes and removes the pubkey, subsequent dictionary access crashes with `KeyNotFoundException`.

**Additional vulnerable locations with same pattern:** [6](#0-5) [7](#0-6) [8](#0-7) 

**Evidence of inconsistent protection:**

The `NextRound` and `NextTerm` behaviors have proper existence checks: [9](#0-8) [10](#0-9) 

This inconsistency demonstrates developers were aware of the need for existence checks but didn't apply them to `UpdateValue` and `TinyBlock` behaviors.

## Impact Explanation

**Consensus disruption**: When a miner's block production crashes with `KeyNotFoundException`, that time slot is lost. The miner cannot produce their scheduled block, disrupting the consensus round progression.

**Chain halt risk**: In scenarios with few active miners or during critical consensus transitions, coordinated replacements targeting multiple miners could cause extended block production stalls, potentially halting the chain until manual intervention or recovery mechanisms engage.

**Affected parties**: 
- All blockchain users experience transaction confirmation delays
- Miners lose block rewards for missed slots
- DApps depending on timely block production experience failures

**Severity justification**: This violates the critical invariant "miner schedule integrity and time-slot validation" defined in AEDPoS consensus. The ability for a semi-privileged actor (candidate admin) to disrupt consensus operations through timing-based attacks qualifies as a high-severity availability vulnerability affecting core blockchain functionality.

## Likelihood Explanation

**Attacker capabilities**: The attacker must be a candidate admin, controlled via: [11](#0-10) 

While this is a semi-privileged role, candidate admins are NOT expected to be trusted for consensus integrity - they manage candidate metadata and profit receivers, not consensus operation.

**Attack complexity**: 
1. Monitor when target miner receives mining command (observable from consensus state)
2. Submit `ReplaceCandidatePubkey` transaction with timing to execute between command retrieval and block production
3. The race window is predictable since consensus commands are generated at deterministic times based on mining schedule

**Feasibility conditions**:
- No rate limiting on `ReplaceCandidatePubkey` calls in the code
- Candidate admin can submit transactions that get executed in the same block or between consensus calls
- Multiple candidate admins could coordinate to affect multiple miners simultaneously
- The timing window is several seconds (typical time between getting command and producing block)

**Detection constraints**: The attack leaves evidence in Election Contract events (`CandidatePubkeyReplaced`), but by then the damage is done. Automated monitoring could detect patterns but cannot prevent the crash once the replacement transaction is in the mempool.

**Probability**: MEDIUM-HIGH. Candidate admins have legitimate access, the timing window is predictable from public consensus state, and there are no technical barriers preventing the attack. A determined attacker with admin access can reliably execute this attack.

## Recommendation

Add existence checks before all dictionary accesses to `RealTimeMinersInformation`, consistent with the pattern already used in `NextRound` and `NextTerm` behaviors:

```csharp
// In GetConsensusExtraDataToPublishOutValue
private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
    string pubkey, AElfConsensusTriggerInformation triggerInformation)
{
    // Add existence check
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = currentRound,
            Behaviour = triggerInformation.Behaviour
        };
    
    // Existing code continues...
    currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = ...
```

Apply the same pattern to:
- `GetConsensusExtraDataForTinyBlock`
- `GetUpdateValueRound` in `Round_Simplify.cs`
- `GetTinyBlockRound` in `Round_Simplify.cs`

Additionally, consider:
- Adding a cooldown period for `ReplaceCandidatePubkey` to prevent rapid replacements
- Deferring pubkey removals from `RealTimeMinersInformation` until round transitions rather than immediate removal
- Making replacement operations queued for next round rather than affecting current miners

## Proof of Concept

A test demonstrating the vulnerability would:
1. Set up a miner with candidate admin control
2. Have the miner call `GetConsensusCommand` to retrieve mining command
3. Before the miner produces the block, have the candidate admin call `ReplaceCandidatePubkey`
4. Attempt to call `GetConsensusExtraData` with the old pubkey
5. Observe `KeyNotFoundException` crash preventing block production

The test would confirm that the miner's scheduled time slot is lost, demonstrating the consensus disruption impact.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L158-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L211-212)
```csharp
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-143)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-58)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-13)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-60)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```
