# Audit Report

## Title
Miner List Manipulation via Unvalidated NextTerm Input Allows Consensus Takeover

## Summary
The `NextTerm` method in the AEDPoS consensus contract accepts arbitrary miner list data without validating it against election results from `ElectionContract.GetVictories()`. Any current miner can submit a `NextTerm` transaction with a fraudulent miner list, completely bypassing the election system to maintain indefinite control over consensus.

## Finding Description

The vulnerability exists in the term transition flow where the new miner list is accepted without on-chain validation against election results.

The `ProcessNextTerm` method extracts the miner list directly from the `NextTermInput` parameter and updates the state without any validation: [1](#0-0) 

The intended design uses `GenerateFirstRoundOfNextTerm` to obtain legitimate election results. This method calls `TryToGetVictories` which retrieves the legitimate miner list from the election contract: [2](#0-1) [3](#0-2) 

However, this election validation occurs **only off-chain** during block generation. The on-chain `NextTerm` method accepts any `NextTermInput` submitted by a miner without verifying the miner list matches election results: [4](#0-3) 

The validation system fails to prevent this attack. The `RoundTerminateValidationProvider` only validates that term and round numbers increment by 1, with no miner list validation: [5](#0-4) 

Similarly, `ValidateConsensusAfterExecution` only validates within-term miner replacements via `GetNewestPubkey`, not term transition miner lists against election results: [6](#0-5) 

The `PreCheck` method only validates that the transaction sender is in the current or previous miner list, not that the NEW miner list is legitimate: [7](#0-6) 

## Impact Explanation

**Critical Consensus Integrity Compromise**: This vulnerability completely bypasses the election system, which is the fundamental security mechanism of the AEDPoS consensus. Token holders vote for validators through the election system, but this vulnerability renders those votes meaningless.

**Indefinite Control**: Once an attacker gains control, they can perpetuate it indefinitely by including themselves in every subsequent term's miner list while excluding legitimate elected validators. They can include accomplice nodes to maintain majority control over the 2/3 consensus threshold.

**Protocol-Wide Damage**:
- Mining rewards are misdirected to fraudulent miners instead of legitimately elected validators
- Treasury distributions become corrupted as fraudulent miners control donation and release mechanisms
- Cross-chain security degrades because side chains rely on main chain miner integrity for security guarantees
- On-chain governance becomes captured as attacker-controlled miners can manipulate proposal outcomes

**Affected Parties**: All network participants lose consensus security guarantees, legitimate validators lose mining rewards they should have earned through election, and token holders lose the voting power that is fundamental to the governance model.

## Likelihood Explanation

**Directly Reachable Entry Point**: The `NextTerm` method is public and can be called by any current miner when term transition conditions are met (based on `PeriodSeconds` configuration).

**Feasible Preconditions**: 
1. Attacker must be a current miner (achievable through one legitimate election initially)
2. Network must be at a term transition point (occurs automatically based on configured period)

**Execution Sequence**:
1. Attacker monitors consensus state to detect when term transition time arrives
2. Attacker constructs a modified `NextTermInput` with arbitrary miner list (including themselves and accomplices)
3. Attacker produces a block containing the malicious `NextTerm` transaction during their assigned time slot
4. Block passes all validation checks since no validator verifies miner list against election results
5. State updates with fraudulent miner list via `SetMinerList`
6. Attacker repeats this process at every term transition to maintain perpetual control

**Detection Difficulty**: The attack appears as a normal term transition on-chain. Detection requires external off-chain monitoring to compare the on-chain miner list in `State.MinerListMap` against the expected winners from `ElectionContract.GetVictories()`.

**Economic Rationality**: The attack is highly profitable. The one-time cost of getting elected initially is vastly exceeded by ongoing block production rewards, consensus control, and governance power over protocol parameters and treasury funds.

## Recommendation

Add on-chain validation in `ProcessNextTerm` to verify the submitted miner list matches the election results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // VALIDATION: Verify miner list matches election results (MAIN CHAIN ONLY)
    if (State.IsMainChain.Value)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var submittedMiners = nextRound.RealTimeMinersInformation.Keys
            .OrderBy(k => k).ToList();
        var electedMiners = victories.Value
            .Select(v => v.ToHex())
            .OrderBy(k => k).ToList();
        
        Assert(
            submittedMiners.Count == electedMiners.Count &&
            submittedMiners.SequenceEqual(electedMiners),
            "NextTerm miner list does not match election results."
        );
    }
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of existing logic
}
```

This ensures that every term transition validates the submitted miner list against the authoritative election results, closing the validation gap.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up an AEDPoS test environment with multiple miners
2. Having one miner construct a `NextTermInput` with an arbitrary miner list that differs from `GetVictories()` results
3. Calling `NextTerm` with this crafted input during a term transition
4. Observing that the transaction succeeds and the fraudulent miner list is set in state
5. Verifying that `State.MinerListMap[newTermNumber]` contains the attacker's chosen miners rather than the elected ones

The test would confirm that no validation prevents arbitrary miner list submission during term transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L115-123)
```csharp
                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```
