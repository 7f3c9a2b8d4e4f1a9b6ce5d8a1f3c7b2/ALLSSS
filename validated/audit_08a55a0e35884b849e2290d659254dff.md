# Audit Report

## Title
Retroactive Vote Weight Inequality - Early Voters Maintain Inflated Weights After Interest Rate Changes

## Summary
The `SetVoteWeightInterest()` function modifies interest rates for vote weight calculations, but existing votes permanently retain their original weights. This creates unfair profit distribution where early voters with higher interest rates maintain inflated profit shares indefinitely, while later voters with identical voting parameters receive reduced rewards after rate decreases.

## Finding Description

**Root Cause:**

When governance calls `SetVoteWeightInterest()`, it only updates the global interest rate configuration without recalculating any existing vote weights stored in the profit contract. [1](#0-0) 

**Vote Weight Calculation and Permanent Storage:**

Vote weights are calculated once at vote creation time using `GetVotesWeight()` with the current interest rates, then permanently stored as "shares" in the profit scheme. [2](#0-1) 

The calculated weight is passed to the profit contract as permanent shares: [3](#0-2) 

**Why Weights Are Never Updated:**

Even when votes are extended via `ExtendVoterWelfareProfits()`, the weight is recalculated using current interest rates [4](#0-3) , but the `FixProfitDetail` method in the profit contract only updates period information by cloning the old detail and modifying end periods - it does NOT update the shares field with the newly calculated weight. [5](#0-4) 

**Reward Distribution Impact:**

Profit distribution uses a proportional formula based on shares, where voters with higher shares receive proportionally more rewards regardless of whether interest rate changes should have equalized their weights. [6](#0-5) [7](#0-6) 

## Impact Explanation

**Direct Reward Misallocation:**

This vulnerability creates systematic unfairness in the protocol's profit distribution mechanism:

- Early voters who locked tokens when interest rates were higher maintain permanently inflated profit shares
- Later voters with identical voting parameters (same token amount, same lock duration) receive reduced shares and rewards  
- The disparity persists for the entire lock period (potentially years), as there is no mechanism to update existing vote weights
- Users cannot withdraw early to re-vote with new rates due to lock-time requirements

**Quantified Example:**
1. User A votes 100 tokens for 365 days when interest rate produces weight = 200 shares
2. Governance legitimately lowers interest rates via `SetVoteWeightInterest` for economic reasons
3. User B votes 100 tokens for 365 days with identical parameters, receives weight = 150 shares
4. In profit distribution: User A receives 200/(200+150) = 57.1% of welfare rewards
5. User B receives 150/(200+150) = 42.9% of welfare rewards
6. **User A gets 33% more rewards despite having identical voting parameters as User B**

This violates the fundamental economic fairness principle that identical contributions should yield proportional rewards.

## Likelihood Explanation

**Highly Practical and Inevitable:**

This issue occurs naturally without requiring any malicious behavior:

- **Entry Point**: Public `Vote()` method accessible to all users
- **Trigger**: Governance-controlled `SetVoteWeightInterest()` - a legitimate governance action for adjusting economic incentives
- **Frequency**: Occurs whenever governance adjusts interest rates to respond to changing economic conditions
- **No Special Preconditions**: Requires only normal protocol operation

**Realistic Scenarios:**

1. **Economic Adjustment**: Governance notices over-incentivization of voting and legitimately reduces interest rates. All new voters automatically receive lower weights while existing voters maintain inflated weights for their entire lock period.

2. **Front-Running Opportunity**: Sophisticated voters monitoring governance proposals can vote before rate decreases are executed, locking in higher weights while regular users unknowingly receive worse terms.

3. **Compounding Unfairness**: Over multiple rate adjustments, the protocol accumulates layers of voters with different locked-in rates, creating a complex unfair distribution that cannot be corrected.

## Recommendation

Implement a mechanism to update existing vote weights when interest rates change. Two potential approaches:

**Option 1: Batch Update on Rate Change**
When `SetVoteWeightInterest()` is called, iterate through active votes and recalculate their weights based on new rates. Update the profit contract shares accordingly.

**Option 2: Dynamic Weight Calculation**
Instead of storing permanent shares, store vote parameters (amount, lock time, creation timestamp) and calculate weights dynamically during profit distribution based on current interest rates. This requires coordination with the Profit contract.

**Option 3: Rate Change Notification**
Add a mechanism for the Election contract to notify the Profit contract when rates change, triggering a recalculation of all voter shares in the welfare scheme.

The recommended fix should preserve the principle that identical voting parameters yield proportional rewards, regardless of when votes were created.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task VoteWeightInequality_AfterInterestRateChange()
{
    // Setup: Initial interest rate
    var initialInterestList = new VoteWeightInterestList { /* high rates */ };
    await ElectionContractStub.SetVoteWeightInterest.SendAsync(initialInterestList);
    
    // User A votes with high interest rate
    var userAVoteId = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput {
        Amount = 100_00000000,
        CandidatePubkey = "candidate1", 
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(365)
    });
    
    // Get User A's weight
    var userARecord = await ElectionContractStub.GetElectorVoteWithRecords.CallAsync(userAAddress);
    var userAWeight = userARecord.ActiveVotingRecords[0].Weight; // e.g., 200
    
    // Governance lowers interest rate
    var loweredInterestList = new VoteWeightInterestList { /* lower rates */ };
    await ElectionContractStub.SetVoteWeightInterest.SendAsync(loweredInterestList);
    
    // User B votes with same parameters but receives lower weight
    var userBVoteId = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput {
        Amount = 100_00000000, // Same amount as User A
        CandidatePubkey = "candidate1",
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(365) // Same duration
    });
    
    var userBRecord = await ElectionContractStub.GetElectorVoteWithRecords.CallAsync(userBAddress);
    var userBWeight = userBRecord.ActiveVotingRecords[0].Weight; // e.g., 150
    
    // Verify inequality: User A has higher weight despite identical parameters
    Assert.True(userAWeight > userBWeight); 
    
    // Verify profit distribution disparity
    await TreasuryContractStub.DistributeProfits.SendAsync(/* distribute profits */);
    var userAProfits = await GetUserProfits(userAAddress);
    var userBProfits = await GetUserProfits(userBAddress);
    
    // User A receives ~33% more profits than User B
    Assert.True(userAProfits > userBProfits * 1.3m);
}
```

## Notes

This vulnerability represents a fundamental fairness issue in the protocol's economic design. While it could be argued that "locking in rates at vote time" is intentional (similar to fixed-rate bonds), several factors indicate this is a bug rather than intended behavior:

1. The `FixProfitDetail` method receives newly calculated weights but ignores them, suggesting an implementation oversight
2. No documentation or code comments indicate this behavior is intentional  
3. The protocol provides `SetVoteWeightInterest` for governance to adjust economic incentives, but those changes cannot affect existing participants
4. The unfairness compounds over time as the protocol accumulates voters with different locked-in rates

The issue is particularly concerning because it cannot be detected without comparing historical interest rates to current vote weights, making it unlikely that regular users would notice the unfairness.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L296-305)
```csharp
        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
