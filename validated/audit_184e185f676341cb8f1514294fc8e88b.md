# Audit Report

## Title
Uninitialized TokenHolderContract Reference Causes Side Chain Dividend Pool DoS

## Summary
The `InitialProfitSchemeForSideChain()` function silently returns when TokenHolder contract is not deployed, leaving `State.TokenHolderContract.Value` uninitialized. This causes all subsequent `Donate()` calls to fail when attempting to use the null contract reference, completely disabling the side chain dividend pool functionality.

## Finding Description

When a side chain initializes with `IsSideChain = true`, the consensus contract calls `InitialProfitSchemeForSideChain()` during initialization. [1](#0-0) 

If the TokenHolder contract is not deployed, `GetContractAddressByName` returns null, and the function logs a debug message and returns early without setting `State.TokenHolderContract.Value` or throwing an exception. [2](#0-1) 

The contract reference is only initialized when the address retrieval succeeds. [3](#0-2) 

The public `Donate()` method then uses the uninitialized `State.TokenHolderContract.Value` in two critical places without null checks: as the `Spender` parameter in an Approve call and when calling `ContributeProfits.Send()`. [4](#0-3) 

The contract exhibits inconsistent null handling. While `Donate()` calls `EnsureTokenContractAddressSet()` for lazy initialization of the Token contract reference, no equivalent method exists for TokenHolderContract. [5](#0-4) [6](#0-5) 

Additionally, the `Release()` method properly checks for null before using `State.TokenHolderContract.Value`, demonstrating awareness of the potential null state. [7](#0-6) 

The private `GetSideChainDividendPoolScheme()` method also lacks null checking before calling `State.TokenHolderContract.GetScheme.Call()`, affecting view methods `GetSymbolList()` and `GetUndistributedDividends()`. [8](#0-7) [9](#0-8) 

The AElf SDK's `MethodReference` class passes the contract reference's `Value` property to underlying Call/Send methods, which will fail when null. [10](#0-9) 

## Impact Explanation

This vulnerability causes complete denial-of-service of the side chain dividend pool functionality. All `Donate()` calls will fail when attempting to use the null contract reference. View methods `GetSymbolList()` and `GetUndistributedDividends()` will also fail for the same reason.

The severity is assessed as **MEDIUM** because:
- **No direct fund loss**: Transactions fail and revert before any token transfers are finalized
- **Complete functional DoS**: The entire dividend pool mechanism becomes unusable
- **Configuration-dependent**: Only affects side chains where TokenHolder contract was not deployed during initialization (an acknowledged scenario based on the code comment)
- **Permanent until upgrade**: Cannot be fixed without contract upgrade or proper reinitialization

Affected parties include all side chains in this configuration state, users attempting to donate to the dividend pool, and applications querying dividend pool information.

## Likelihood Explanation

The likelihood is **MEDIUM** based on:

**Attacker Capabilities**: No special privileges required - the `Donate()` method is public and callable by any user.

**Attack Complexity**: Trivial - simply call `Donate()` with valid parameters. No complex transaction sequencing or special conditions required beyond the initial misconfiguration.

**Feasibility Conditions**: The side chain must have been initialized with `IsSideChain = true`, and the TokenHolder contract must not have been deployed or `GetContractAddressByName` returned null during initialization. The code explicitly acknowledges this as a possible scenario.

**Detection**: This would be immediately detected upon the first `Donate()` call attempt, making it more of a deployment/configuration issue than a runtime exploit. However, the likelihood depends entirely on side chain deployment practices - if operators properly deploy all required contracts, this issue won't manifest.

## Recommendation

Add a lazy initialization method for the TokenHolder contract reference, consistent with the pattern used for the Token contract:

```csharp
private void EnsureTokenHolderContractAddressSet()
{
    if (State.TokenHolderContract.Value == null)
        State.TokenHolderContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);
}
```

Then call this method at the beginning of `Donate()`, `GetSideChainDividendPoolScheme()`, and any other methods that use the TokenHolder contract reference:

```csharp
public override Empty Donate(DonateInput input)
{
    EnsureTokenContractAddressSet();
    EnsureTokenHolderContractAddressSet(); // Add this line
    
    // ... rest of the method
}
```

Alternatively, add explicit null checks and appropriate error handling:

```csharp
Assert(State.TokenHolderContract.Value != null, "TokenHolder contract not available.");
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Initialize a side chain with `IsSideChain = true` but without deploying the TokenHolder contract
2. Call `Donate()` with valid parameters
3. The transaction will fail when attempting to use `State.TokenHolderContract.Value` as it is null

The execution will fail at either line 56 (passing null as Spender to Approve) or line 59 (calling Send() on a null contract reference), causing a transaction failure and complete DoS of the dividend pool functionality.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L35-35)
```csharp
        if (input.IsSideChain) InitialProfitSchemeForSideChain(input.PeriodSeconds);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L18-25)
```csharp
        var tokenHolderContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);
        // No need to continue if Token Holder Contract didn't deployed.
        if (tokenHolderContractAddress == null)
        {
            Context.LogDebug(() => "Token Holder Contract not found, so won't initial side chain dividends pool.");
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L27-27)
```csharp
        State.TokenHolderContract.Value = tokenHolderContractAddress;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L39-39)
```csharp
        EnsureTokenContractAddressSet();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L52-64)
```csharp
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L104-104)
```csharp
        if (State.TokenHolderContract.Value == null) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L136-161)
```csharp
    public override SymbolList GetSymbolList(Empty input)
    {
        return new SymbolList
        {
            Value =
            {
                GetSideChainDividendPoolScheme().ReceivedTokenSymbols
            }
        };
    }

    public override Dividends GetUndistributedDividends(Empty input)
    {
        var scheme = GetSideChainDividendPoolScheme();
        return new Dividends
        {
            Value =
            {
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
            }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L163-169)
```csharp
    private Scheme GetSideChainDividendPoolScheme()
    {
        if (State.SideChainDividendPoolSchemeId.Value == null)
        {
            var tokenHolderScheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
            State.SideChainDividendPoolSchemeId.Value = tokenHolderScheme.SchemeId;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L140-145)
```csharp
    private void EnsureTokenContractAddressSet()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    }
```

**File:** src/AElf.Sdk.CSharp/State/MethodReference.cs (L18-26)
```csharp
    public void Send(TInput input)
    {
        _parent.Context.SendInline(_parent.Value, _name, input);
    }

    public TOutput Call(TInput input)
    {
        return _parent.Context.Call<TOutput>(_parent.Value, _name, input);
    }
```
