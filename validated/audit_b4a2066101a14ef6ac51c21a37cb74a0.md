# Audit Report

## Title
Continuous Blocks Limit Bypass via RoundNumber Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
A malicious miner can bypass the continuous blocks limit by manipulating the `RoundNumber` field in consensus extra data to values ≤ 2. This allows unlimited consecutive block production, enabling complete consensus monopolization and breaking the core decentralization guarantee of the AEDPoS consensus mechanism.

## Finding Description

The vulnerability chain consists of three critical gaps:

**Gap 1: Unvalidated RoundNumber Copying**

The `GetUpdateValueRound` and `GetTinyBlockRound` methods copy `RoundNumber` directly from the current round without any validation: [1](#0-0) [2](#0-1) 

When generating consensus extra data for UpdateValue behaviors, the simplified round is included: [3](#0-2) 

For TinyBlock behaviors: [4](#0-3) 

**Gap 2: Missing Validation for UpdateValue/TinyBlock**

For NextRound and NextTerm behaviors, explicit validation ensures the RoundNumber is correct: [5](#0-4) 

However, for UpdateValue and TinyBlock behaviors, the validation provider list does not include any check that validates the RoundNumber: [6](#0-5) 

The `UpdateValueValidationProvider` only validates VRF fields and `PreviousInValue`, not RoundNumber: [7](#0-6) 

**Gap 3: Bypassable Continuous Blocks Check**

The `ContinuousBlocksValidationProvider` uses the unvalidated `ProvidedRound.RoundNumber` to decide whether to enforce the continuous blocks limit: [8](#0-7) 

The `ProvidedRound` property returns the round from block header extra data: [9](#0-8) 

The only validation on block header consensus data is that `SenderPubkey` matches `SignerPubkey`: [10](#0-9) 

**Why After-Execution Validation Doesn't Catch This:**

The `ValidateConsensusAfterExecution` method calls `RecoverFromUpdateValue` or `RecoverFromTinyBlock`, which modify the headerInformation's round: [11](#0-10) 

These recovery methods update the round in-place by copying data from the provided round but do NOT copy or validate RoundNumber: [12](#0-11) [13](#0-12) 

The validation is executed, and the continuous blocks counter is updated during block processing: [14](#0-13) [15](#0-14) 

The limit is defined as: [16](#0-15) 

## Impact Explanation

**Critical Consensus Integrity Compromise:**

This vulnerability completely undermines the fairness guarantees of the AEDPoS consensus mechanism:

1. **Consensus Monopolization**: The attacker can bypass the `MaximumTinyBlocksCount` limit (8 blocks) and produce unlimited consecutive blocks, gaining 100% control of block production instead of their fair share (1/N where N = number of miners)

2. **Miner Starvation**: Other legitimate miners are prevented from producing blocks, as the attacker continuously holds the block production slot

3. **Censorship Power**: With complete control over block production, the attacker can censor transactions, manipulate transaction ordering for MEV extraction, or exclude specific addresses

4. **Decentralization Failure**: The fundamental property of distributed consensus—that no single party can control the chain—is violated

## Likelihood Explanation

**High Likelihood - Trivially Exploitable:**

**Minimal Prerequisites:**
- Attacker must be in the current miner list (standard requirement for any miner through staking/election)
- No special privileges or compromised keys required beyond being a legitimate miner

**Attack Simplicity:**
1. The attack requires only modifying a single integer field (`RoundNumber`) in the consensus extra data before including it in the block header
2. No complex cryptographic manipulation needed
3. No state setup or timing requirements beyond normal mining

**Economic Incentive:**
- Attack cost: Negligible (just a field modification)
- Attack benefit: Complete control of consensus, MEV extraction opportunities, censorship capability
- Risk/reward strongly favors the attacker

**Detection Difficulty:**
- The manipulation is in the block header, not in state
- State round information remains correct, making detection non-trivial
- The attack appears as normal UpdateValue/TinyBlock behavior to observers

## Recommendation

Add explicit RoundNumber validation for UpdateValue and TinyBlock behaviors. Create a new validation provider or extend existing validators to verify that the provided RoundNumber matches the current round from state:

```csharp
// Add to UpdateValueValidationProvider or create new RoundNumberValidationProvider
private bool ValidateRoundNumber(ConsensusValidationContext validationContext)
{
    if (validationContext.ProvidedRound.RoundNumber != validationContext.CurrentRoundNumber)
    {
        return false;
    }
    return true;
}
```

Include this validation in the provider list for UpdateValue and TinyBlock behaviors in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new RoundNumberValidationProvider());
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider());
    break;
case AElfConsensusBehaviour.TinyBlock:
    validationProviders.Add(new RoundNumberValidationProvider());
    break;
```

## Proof of Concept

A test demonstrating the vulnerability would:

1. Set up a consensus scenario with multiple miners
2. Have one miner produce 8 consecutive blocks (reaching the limit)
3. Generate valid consensus extra data for block 9
4. Modify the `RoundNumber` field to 1 or 2 before submitting
5. Verify that block validation passes despite exceeding the continuous blocks limit
6. Confirm the miner can continue producing blocks indefinitely

The core issue is that `ContinuousBlocksValidationProvider` checks `ProvidedRound.RoundNumber > 2`, and since no validator ensures the provided RoundNumber equals the actual current round for UpdateValue/TinyBlock behaviors, an attacker can set it to any value ≤ 2 to bypass the continuous blocks check.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-16)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-63)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L155-170)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForTinyBlock(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = currentRound.GetTinyBlockRound(pubkey),
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-30)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-32)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L68-69)
```csharp
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
