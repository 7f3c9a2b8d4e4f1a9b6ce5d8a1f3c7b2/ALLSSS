# Audit Report

## Title
Side Chain Miner Count Limit Bypass via Cross-Chain Synchronization

## Summary
Side chains can operate with more miners than their governance-configured `MaximumMinersCount` limit because cross-chain synchronization accepts unlimited miner lists from the main chain without validation, rendering the governance parameter ineffective and breaking consensus security assumptions.

## Finding Description

The AEDPoS consensus contract on side chains fails to enforce the `MaximumMinersCount` limit when receiving miner lists from the main chain. The vulnerability spans multiple code paths:

**Root Cause 1: Unvalidated Cross-Chain Update**
The `UpdateInformationFromCrossChain` method extracts all miners from main chain consensus data and stores them without checking against the side chain's configured limit. [1](#0-0) 

**Root Cause 2: Side Chain Election Bypass**
Side chains return false from `TryToGetVictories` because they don't run their own elections, causing fallback to use the unvalidated current round's complete miner list. [2](#0-1) 

When this occurs, the fallback path uses all current miners without count limits: [3](#0-2) 

**Root Cause 3: Unchecked NextTermInput Creation**
The `Create()` method copies all entries from `round.RealTimeMinersInformation` without validation. [4](#0-3) 

**Root Cause 4: Unvalidated Term Processing**
`ProcessNextTerm` creates a `MinerList` from ALL keys in `nextRound.RealTimeMinersInformation` without checking against the count limit. [5](#0-4) 

**Root Cause 5: Insufficient Validation**
The `ValidationForNextTerm` method only validates term and round number increments but does NOT check if the miner count exceeds `MaximumMinersCount`. [6](#0-5) 

**Critical Finding: MaximumMinersCount Only Used for Reporting**
The `GetMinersCount` method enforces `MaximumMinersCount` via `Math.Min`, but this is ONLY used to report to the Election contract, not to limit actual consensus participation. [7](#0-6) 

This limited enforcement is only used for reporting: [8](#0-7) 

**Block Production Uses Unvalidated List**
Mining permission validation only checks if a sender exists in `RealTimeMinersInformation.Keys`, meaning ALL miners in the round (regardless of count) can produce blocks. [9](#0-8) 

**Automatic Trigger Path**
The cross-chain contract automatically calls this during parent chain indexing: [10](#0-9) [11](#0-10) 

**Side Chain Miner List Propagation**
When the main chain miner list changes, side chains adopt it entirely without count validation: [12](#0-11) 

## Impact Explanation

**Consensus Integrity Violation:**
Side chains can operate with arbitrarily many block producers, violating the governance-approved `MaximumMinersCount` safety parameter. If the main chain has 25 miners and the side chain's limit is 17, all 25 miners will participate in consensus on the side chain.

**Concrete Harms:**

1. **Security Degradation:** The miner count affects Byzantine fault tolerance thresholds, block finality assumptions, and fork resolution dynamics. Operating with more miners than intended changes fundamental security properties.

2. **Economic Inconsistency:** The Election contract receives a capped miner count via `UpdateMinersCountToElectionContract`, but the actual consensus round operates with more miners, creating mismatches in reward calculations and economic incentives.

3. **Governance Bypass:** The `MaximumMinersCount` parameter set by Parliament becomes unenforceable on side chains. Governance can configure limits but they are ignored during normal operation, rendering governance decisions ineffective. [13](#0-12) 

**Affected Parties:**
- Side chain validators expecting security guarantees from the configured miner limit
- Side chain governance expecting their `MaximumMinersCount` setting to be enforced  
- Economic contracts receiving inconsistent miner count information

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is not an attack requiring adversarial action but a design flaw that triggers automatically:

1. **Reachable Entry Point:** `UpdateInformationFromCrossChain` is called by the CrossChain contract during routine cross-chain indexing as part of normal side chain operation.

2. **Realistic Preconditions:**
   - Side chain exists with `MaximumMinersCount` configured (standard governance setup)
   - Main chain has more miners than side chain's limit (common scenario as main chains typically support more miners)
   - Cross-chain indexing is active (required for normal side chain operation)

3. **Automatic Trigger:** No attacker action needed - happens during normal cross-chain synchronization whenever the main chain's miner count exceeds the side chain's configured limit.

4. **Reproducible:** This is deterministic behavior that occurs every time the conditions are met, not a race condition or timing issue.

## Recommendation

Add miner count validation in the cross-chain synchronization path:

1. **In `UpdateInformationFromCrossChain`:** Validate that the incoming miner list count does not exceed `State.MaximumMinersCount.Value` before storing it.

2. **In `ProcessNextTerm`:** Enforce the maximum miner count limit before creating and storing the `MinerList`.

3. **In `ValidationForNextTerm`:** Add validation to check that `nextRound.RealTimeMinersInformation.Count` does not exceed the configured maximum.

4. **In `GenerateNextRoundInformation` for side chains:** When using `MainChainCurrentMinerList`, truncate or select miners to respect the side chain's `MaximumMinersCount` limit.

The fix should ensure that side chain governance's `MaximumMinersCount` setting is actually enforced, even when synchronizing from the main chain.

## Proof of Concept

The test demonstrates that `UpdateInformationFromCrossChain` accepts any number of miners without validation: [14](#0-13) 

This test shows the method successfully updates the miner list with 3 miners, but would work with any count, demonstrating that no validation against `MaximumMinersCount` occurs. A complete PoC would:

1. Configure side chain with `MaximumMinersCount = 5`
2. Send cross-chain update with 10 miners from main chain  
3. Verify all 10 miners are stored and can participate in consensus
4. Observe that `GetMinersCount` reports 5 but actual consensus uses all 10

## Notes

The vulnerability is architectural - side chains are designed to mirror main chain miners but lack enforcement of their own governance-configured limits. The `MaximumMinersCount` parameter exists and can be set on side chains, but the cross-chain synchronization path bypasses this limit entirely. This creates a governance control that appears to work but is actually ineffective, which is worse than having no control at all.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L236-242)
```csharp
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L268-272)
```csharp
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L12-12)
```csharp
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs (L35-88)
```csharp
    public async Task UpdateInformationFromCrossChainTest()
    {
        SetToSideChain();
        InitialContracts();
        InitialAcs3Stubs();
        var mockedCrossChain = SampleAccount.Accounts.Last();
        var mockedCrossChainStub =
            GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
                ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
                mockedCrossChain.KeyPair);

        var headerInformation = new AElfConsensusHeaderInformation
        {
            Round = new Round
            {
                RoundNumber = 2,
                RealTimeMinersInformation =
                {
                    { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() }
                }
            }
        };

        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput
        {
            ProposerAuthorityRequired = false,
            PrivilegedProposer = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.First().PublicKey)
        });
        await CreateAndIssueToken("ELF");
        await CreateAndIssueToken("READ");
        await TokenStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "READ",
            Amount = 10_00000000,
            To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
        });

        await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
        {
            Value = headerInformation.ToByteString()
        });

        var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
        minerList.Pubkeys.Select(m => m.ToHex()).ShouldBe(headerInformation.Round.RealTimeMinersInformation.Keys);

        var balance = await TokenStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.Skip(1).First().PublicKey),
            Symbol = "READ"
        });
        balance.Balance.ShouldBe(2_00000000);
    }
```
