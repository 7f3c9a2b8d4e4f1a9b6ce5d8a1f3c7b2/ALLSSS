# Audit Report

## Title
Consensus DoS via Uncaught Exception During Secret Sharing Reconstruction After Miner Replacement

## Summary
When a miner is replaced mid-round via `RecordCandidateReplacement()`, the old miner's public key is removed from the round's miner list, but existing `DecryptedPieces` entries in other miners' data still reference the old key. This causes an uncaught `InvalidOperationException` when `RevealSharedInValues()` attempts to reconstruct shared secrets during the next round transition, completely halting consensus.

## Finding Description

The vulnerability occurs in the secret sharing mechanism used for randomness generation in the AEDPoS consensus protocol. The issue involves a state inconsistency created by the miner replacement process.

**Vulnerable Code Path:**

The `RevealSharedInValues()` method uses LINQ's `First()` method to look up miners by their public key without handling the case where the miner no longer exists: [1](#0-0) 

The `First()` method throws `InvalidOperationException` with the message "Sequence contains no matching element" when no element satisfies the predicate.

**Root Cause:**

When `RecordCandidateReplacement()` is called by the Election Contract to replace a miner, it removes the old miner's entry from `RealTimeMinersInformation` and adds a new entry with the new public key: [2](#0-1) 

However, this method does NOT update or remove entries in other miners' `DecryptedPieces` maps that contain the old public key as a KEY.

**How DecryptedPieces Are Populated:**

The `DecryptedPieces` map is populated when miners submit consensus information. The sender's public key is added as a KEY in another miner's `DecryptedPieces`: [3](#0-2) 

These entries persist even after a miner is replaced.

**Trigger Point:**

During the NextRound transition, the extra block producer calls `GetConsensusExtraDataForNextRound()`, which invokes `RevealSharedInValues()`: [4](#0-3) 

**Attack Scenario:**

1. Round N-1: Miner A submits consensus data with decrypted pieces, causing A's public key to be stored as a KEY in other miners' `DecryptedPieces` maps
2. Still in Round N-1: Election Contract calls `RecordCandidateReplacement("A_old", "A_new")`
   - `RealTimeMinersInformation["A_old"]` is removed
   - `RealTimeMinersInformation["A_new"]` is added
   - Other miners' `DecryptedPieces["A_old"]` entries remain unchanged
3. Round N proceeds normally
4. At end of Round N: Extra block producer attempts NextRound transition
5. `RevealSharedInValues()` tries to look up "A_old" in Round N-1's `RealTimeMinersInformation` using `First()`
6. `First()` throws `InvalidOperationException` because "A_old" no longer exists
7. Transaction fails, preventing NextRound transition
8. Consensus halts - blockchain cannot produce new blocks

## Impact Explanation

This is a **CRITICAL** consensus availability issue with the following impacts:

**Immediate Effects:**
- Complete halt of block production - the blockchain cannot transition to the next round
- All validator nodes are affected as consensus cannot advance
- No transactions can be processed until manual intervention

**Operational Consequences:**
- Requires emergency governance action or hard fork to recover
- Potential loss of user confidence in chain reliability
- Service disruption for all DApps and users on the chain

**Severity Justification:**
While no funds are directly at risk, the complete denial-of-service of the consensus mechanism represents a critical failure of the blockchain's primary function. This violates the fundamental availability guarantee that a blockchain must provide.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Preconditions (All Realistic):**
1. Secret sharing is enabled via the Configuration Contract - this is a standard feature for enhanced randomness
2. A miner replacement occurs during an active round - this is part of normal governance operations
3. The replaced miner previously submitted decrypted pieces - happens in every round with secret sharing enabled
4. A NextRound transition occurs after the replacement - inevitable as rounds progress

**Entry Point:**
The `RecordCandidateReplacement()` method is a legitimate public function that is called by the Election Contract: [5](#0-4) 

**Triggering Scenarios:**
- Normal validator key rotation for security purposes
- Replacement of poorly performing validators through governance
- Automatic replacement of miners who miss too many time slots
- Any legitimate use of the Election Contract's `ReplaceCandidatePubkey` functionality

**No Attacker Required:**
This vulnerability can be triggered through normal, legitimate protocol operations without any malicious intent. Any miner replacement during an active round (when secret sharing is enabled) will create the conditions for consensus failure.

## Recommendation

**Immediate Fix:**

Replace `First()` with `FirstOrDefault()` and add null checking in `RevealSharedInValues()`:

```csharp
var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
{
    var pubkey = anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i];
    var miner = previousRound.RealTimeMinersInformation.Values
        .FirstOrDefault(m => m.Pubkey == pubkey);
    
    // Skip if miner was replaced and no longer exists
    if (miner == null) return -1;
    
    return miner.Order;
})
.Where(order => order >= 0)
.ToList();

// Only proceed if we have enough valid orders
if (orders.Count < minimumCount) continue;
```

**Comprehensive Fix:**

Update `RecordCandidateReplacement()` to clean up stale `DecryptedPieces` references:

```csharp
// After line 143, add:
// Clean up DecryptedPieces entries referencing the old pubkey
foreach (var minerInfo in currentRound.RealTimeMinersInformation.Values)
{
    if (minerInfo.DecryptedPieces.ContainsKey(input.OldPubkey))
    {
        minerInfo.DecryptedPieces.Remove(input.OldPubkey);
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ConsensusDoS_MinerReplacement_During_SecretSharing_Test()
{
    // Setup: Initialize consensus with secret sharing enabled
    await InitializeConsensusWithSecretSharing();
    
    // Step 1: Start Round N with multiple miners (A, B, C)
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerA = InitialCoreDataCenterKeyPairs[0];
    var minerB = InitialCoreDataCenterKeyPairs[1];
    
    // Step 2: Miner A submits UpdateValue with DecryptedPieces
    // This causes A's pubkey to be stored in B's DecryptedPieces
    await SubmitUpdateValueWithDecryptedPieces(minerA);
    
    // Step 3: Election Contract replaces Miner A mid-round
    var electionStub = GetElectionContractTester(BootMinerKeyPair);
    await electionStub.RecordCandidateReplacement.SendAsync(new RecordCandidateReplacementInput
    {
        OldPubkey = minerA.PublicKey.ToHex(),
        NewPubkey = "new_pubkey_for_A"
    });
    
    // Verify: A's old pubkey is removed from RealTimeMinersInformation
    currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation.ContainsKey(minerA.PublicKey.ToHex()).ShouldBeFalse();
    
    // Step 4: Complete current round and attempt NextRound transition
    // This should throw InvalidOperationException and halt consensus
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await AttemptNextRoundTransition();
    });
    
    // Verify: Exception is thrown due to missing miner in First() lookup
    exception.Message.ShouldContain("InvalidOperationException");
    
    // Verify: Blockchain is stuck - cannot produce next round
    var afterFailureRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    afterFailureRound.RoundNumber.ShouldBe(currentRound.RoundNumber); // Round number hasn't increased
}
```

**Notes:**
- This vulnerability requires secret sharing to be enabled, which is a standard configuration for production chains
- The issue can occur through completely legitimate governance operations without any malicious intent
- Recovery requires manual intervention, potentially including emergency governance proposals or hard fork
- The fix is straightforward but critical for consensus stability

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-44)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-134)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-146)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```
