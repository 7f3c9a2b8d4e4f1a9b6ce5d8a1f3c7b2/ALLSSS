# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass via RecoverFromUpdateValue Timing Issue

## Summary
A critical order-of-operations flaw in the AEDPoS consensus validation flow allows any miner to bypass the `LibInformationValidationProvider` validation for `ImpliedIrreversibleBlockHeight`. The vulnerability occurs because `RecoverFromUpdateValue` mutates the `baseRound` reference object before validation runs, causing the validator to compare a value against itself, making the check always pass. This enables miners to inject fraudulently low implied LIB heights into consensus state, compromising blockchain finality guarantees.

## Finding Description

The vulnerability exists in the validation sequence for UpdateValue consensus behavior. The execution flow reveals a fundamental design flaw:

**Location 1 - Premature State Mutation:**
During validation preparation, when the behavior is UpdateValue, the code calls `RecoverFromUpdateValue` on the `baseRound` object before any validation occurs. [1](#0-0) 

**Location 2 - In-Place Mutation:**
The `RecoverFromUpdateValue` method copies the `ImpliedIrreversibleBlockHeight` value from the provided round directly into the base round for the sender, mutating the object in place. [2](#0-1) 

**Location 3 - Corrupted Validation Context:**
The validation context is constructed using the already-modified `baseRound`, which now contains the attacker's injected value. The `ProvidedRound` property references `ExtraData.Round` which is the attacker-controlled input. [3](#0-2) [4](#0-3) 

**Location 4 - Ineffective Validation:**
The `LibInformationValidationProvider` attempts to validate that the implied irreversible block height has not decreased by checking if `baseRound` value is greater than `providedRound` value. However, since both now contain identical values (due to the premature recovery), this check becomes a tautology and always passes. [5](#0-4) 

**Location 5 - Unvalidated State Persistence:**
The fraudulent `ImpliedIrreversibleBlockHeight` from the attacker's input is directly persisted to state without any effective validation preventing regression. [6](#0-5) 

**Attack Vector:**
A malicious miner can modify the `ImpliedIrreversibleBlockHeight` field in their `UpdateValueInput` to any value, including fraudulently low values. The input structure explicitly includes this field. [7](#0-6) 

## Impact Explanation

The `ImpliedIrreversibleBlockHeight` is a critical component of the Last Irreversible Block (LIB) calculation mechanism. The LIB calculation uses these values from all miners to determine blockchain finality.

**LIB Calculation Mechanism:**
The system collects implied irreversible block heights from miners who produced blocks in the current round, sorts them, and selects the value at position `(count-1)/3` to ensure 2/3+ consensus on finality. [8](#0-7) [9](#0-8) 

**Concrete Attack Impact:**
1. **Finality Manipulation**: A malicious miner can inject arbitrarily low implied LIB heights (e.g., height 100 when current height is 1000)
2. **LIB Regression Risk**: These fraudulent values enter the sorted list used for LIB calculation in subsequent rounds
3. **Repeated Exploitation**: Over multiple rounds, an attacker can prevent the LIB from advancing properly, affecting all network participants relying on finality confirmations
4. **Cross-Chain Impact**: LIB heights are used for cross-chain operations and indexing, potentially affecting inter-chain security

**Severity Justification:** HIGH - This bypasses a critical consensus validation explicitly designed to prevent regression of finality markers. It directly compromises blockchain security guarantees by allowing manipulation of the irreversible block height calculation, which is fundamental to the system's finality model.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an elected miner in the current round (realistic in any PoS/DPoS system)
- No special privileges beyond normal mining rights required
- Can execute during their normal time slot

**Attack Complexity:**
- LOW - The exploit requires only modifying a single integer field in the consensus extra data
- The validation bypass is automatic due to the code's execution order
- No race conditions or complex timing requirements

**Feasibility:**
- Occurs during normal UpdateValue behavior (every block production)
- The vulnerability is always present when UpdateValue behavior is triggered
- No operational constraints prevent exploitation

**Detection Difficulty:**
- The malicious value appears valid to the validation logic
- No automatic detection mechanism exists in the current implementation
- Would only be discovered through manual consensus state inspection or observing abnormal LIB progression patterns

**Probability:** HIGH - Any miner can execute this attack at any time during their designated block production without triggering validation failures or alerts in the current system.

## Recommendation

Move the `RecoverFromUpdateValue` call to occur AFTER validation completes, not before. The recovery operation should only be performed on a defensive copy used for validation purposes, while preserving the original `baseRound` state for comparison.

**Recommended Fix:**
1. Create a defensive copy of `baseRound` before validation
2. Call `RecoverFromUpdateValue` on the copy, not the original
3. Use the copy for all validation providers
4. Only apply the recovery to the actual state during the processing phase

This ensures the validation compares the attacker's provided values against the true baseline state, not against itself.

## Proof of Concept

A proof of concept would demonstrate:
1. Setting up a consensus round with a miner having `ImpliedIrreversibleBlockHeight = 1000`
2. The miner submitting `UpdateValueInput` with `implied_irreversible_block_height = 100`
3. Observing that `ValidateBeforeExecution` returns success despite the regression
4. Verifying the state is persisted with the fraudulent value of 100
5. Confirming this value is used in subsequent LIB calculations

The test would verify that a value explicitly designed to be rejected by `LibInformationValidationProvider` (regression from 1000 to 100) is instead accepted due to the premature mutation of `baseRound`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-27)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-249)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** protobuf/aedpos_contract.proto (L217-218)
```text
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
