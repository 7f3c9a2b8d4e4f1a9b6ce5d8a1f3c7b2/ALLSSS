# Audit Report

## Title
NFT Type Removal Breaks Cross-Chain Protocol Synchronization

## Summary
The NFT contract's `RemoveNFTType` method allows Parliament to remove NFT types from the registry. When `CrossChainCreate` attempts to synchronize existing protocols using those removed types to side chains, it fails with an assertion error because `InitialNFTTypeNameMap()` does not restore the mappings. This creates a denial-of-service for cross-chain NFT synchronization until Parliament re-adds the type.

## Finding Description

The NFT contract maintains three state mappings for NFT types defined in `NFTContractState.cs`: [1](#0-0) 

Parliament can remove NFT types through `RemoveNFTType`, which removes entries from all three mappings but crucially leaves `State.NFTTypes.Value` as a non-null dictionary object: [2](#0-1) 

**Root Cause:**

When `CrossChainCreate` is called on a side chain to synchronize an NFT protocol, it invokes `InitialNFTTypeNameMap()` which contains a flawed null check that returns early if `State.NFTTypes.Value != null`: [3](#0-2) 

Since `RemoveNFTType` only removes dictionary entries but not the dictionary object itself, the initialization never runs and removed types are not restored. The initialization logic that would repopulate the mappings is never reached: [4](#0-3) 

The `CrossChainCreate` method then extracts the 2-character short name from the symbol and performs a lookup in `NFTTypeFullNameMap`. If the type was removed, the lookup returns null and an assertion error is thrown: [5](#0-4) 

**Execution Path:**
1. User creates NFT protocol on mainchain with type "Art" → symbol "AR123456" is generated with the nftType stored in protocol info: [6](#0-5) 
2. Parliament calls `RemoveNFTType("AR")` → removes "AR" from all mappings
3. Token is cross-chain created on side chain via MultiToken contract (succeeds)
4. User/system calls `CrossChainCreate("AR123456")` on side chain
5. Method extracts "AR" and looks it up → returns null → assertion fails

## Impact Explanation

**Direct Impact:** NFT protocols created on the mainchain before type removal cannot be synchronized to side chains. The `CrossChainCreate` method will revert with an assertion error, preventing the NFT protocol info from being created on the side chain.

**Protocol Damage:** While the MultiToken contract may successfully create the token on the side chain through standard cross-chain mechanisms, the NFT-specific protocol information (minter lists, metadata, NFT type) will not exist. This breaks NFT-specific operations on side chains including:
- Minting new NFTs (requires minter list validation): [7](#0-6) 
- Querying NFT protocol info (returns null)
- NFT metadata and type information access

**Affected Users:** All users who created NFT protocols using a type that was subsequently removed by Parliament. Side chain users cannot access NFT functionality for these protocols, while mainchain functionality remains unaffected.

**Severity Justification - Medium:**
- Requires Parliament governance action (high barrier but realistic for cleanup)
- Impact is limited to cross-chain synchronization (mainchain protocols continue functioning)
- Breaks a core feature (cross-chain NFT support) for affected protocols
- Recovery requires Parliament to re-add the type via `AddNFTType`
- Permanent denial-of-service until governance intervention

## Likelihood Explanation

**Governance Action Required:** The vulnerability requires Parliament to approve and execute `RemoveNFTType`, which needs authorization through the default Parliament organization: [8](#0-7) 

**Realistic Scenario:** Parliament might legitimately deprecate obsolete or unused NFT types for cleanup purposes without realizing that:
1. Existing protocols on mainchain use those types
2. Cross-chain synchronization will fail for those protocols
3. No validation exists in `RemoveNFTType` to prevent removing types that are in use

**Detection Constraints:** The issue only manifests when attempting cross-chain synchronization after type removal. The error message even suggests adding the type back as a solution, indicating this scenario was not anticipated during design.

**Probability:** Medium-to-High for inadvertent breakage during legitimate governance cleanup operations, especially given the lack of validation to check if a type is actively in use before removal.

## Recommendation

**Fix 1: Add validation in RemoveNFTType**
Before allowing type removal, verify that no existing NFT protocols use that type by checking the `NftProtocolMap` for any protocols with the corresponding type.

**Fix 2: Improve InitialNFTTypeNameMap logic**
Instead of checking `State.NFTTypes.Value != null`, check if the actual mappings (`NFTTypeFullNameMap`, `NFTTypeShortNameMap`) are populated. If they're empty but the singleton is non-null, reinitialize them.

**Fix 3: Add CrossChainCreate resilience**
Allow `CrossChainCreate` to proceed even if the type mapping is missing, by extracting the type from the token's ExternalInfo instead of relying on the NFTTypeFullNameMap lookup.

**Recommended Implementation for Fix 2:**
```csharp
private NFTTypes InitialNFTTypeNameMap()
{
    // Check if mappings are actually populated, not just if singleton exists
    if (State.NFTTypes.Value != null && State.NFTTypeFullNameMap["AR"] != null) 
        return State.NFTTypes.Value;
    
    // Initialize mappings...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveNFTType_BreaksCrossChainSync_Test()
{
    // Step 1: Create NFT protocol on mainchain with Art type
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "TestProtocol",
        TotalSupply = 1000,
        BaseUri = "ipfs://test/"
    });
    var symbol = createResult.Output.Value;
    Assert.StartsWith("AR", symbol); // Verify it uses Art type
    
    // Step 2: Parliament removes the Art type
    await ParliamentContractStub.RemoveNFTType.SendAsync(new StringValue { Value = "AR" });
    
    // Step 3: Attempt CrossChainCreate on side chain
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await SideChainNFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    
    // Verify the error message matches expected
    Assert.Contains("Full name of AR not found", exception.Message);
    Assert.Contains("Use AddNFTType to add this new pair", exception.Message);
}
```

---

**Notes:**

This vulnerability arises from a logical flaw in state management rather than malicious governance action. The improper null check in `InitialNFTTypeNameMap` fails to distinguish between "never initialized" and "initialized but entries removed." This creates an inconsistent state where the singleton object exists but the associated mappings are empty, breaking the cross-chain synchronization invariant. The lack of validation in `RemoveNFTType` to check for active protocol usage exacerbates the issue, allowing governance to inadvertently break cross-chain functionality for existing protocols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-40)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-53)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-42)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L43-63)
```csharp
        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-400)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");
```
