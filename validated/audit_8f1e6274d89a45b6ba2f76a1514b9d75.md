# Audit Report

## Title
Secret Sharing Threshold Mismatch Causes Incorrect InValue Revelation During Miner Set Changes

## Summary
The AEDPoS consensus contract's `RevealSharedInValues` function uses the current round's miner count to calculate the Shamir's Secret Sharing decoding threshold, but the InValues were originally encoded using a different round's miner count. When the miner count changes between rounds (e.g., during term transitions), this threshold mismatch causes mathematically incorrect InValue reconstruction, leading to consensus validation failures and potential network stall.

## Finding Description

The vulnerability exists in how the consensus contract handles secret sharing across round transitions when the miner set size changes.

**Encoding Flow:**
When a new round begins, miners encode their InValues for that round using the **previous round's** miner count to determine the Shamir's Secret Sharing threshold. [1](#0-0) 

**Decoding Flow:**
During round transitions, the `RevealSharedInValues` function attempts to decode InValues from the previous round. However, it calculates the decoding threshold using the **current round's** miner count, not the miner count from when the encoding occurred. [2](#0-1)  The decoding then uses this mismatched threshold. [3](#0-2) 

**Root Cause:**
Consider this timeline:
- Round N-2: 5 miners
- Round N-1: 5 miners (stable) - InValues encoded with threshold = (5 × 2) / 3 = 3
- Round N: 3 miners (term change) - `IsMinerListJustChanged=true`, secret sharing skipped
- Round N+1: 3 miners (stable) - Attempts to decode Round N-1's InValues using threshold = (3 × 2) / 3 = 2

The Shamir's Secret Sharing algorithm constructs a polynomial of degree `threshold-1`. [4](#0-3)  Decoding with a different threshold means attempting to reconstruct a polynomial of the wrong degree using Lagrange interpolation with the wrong number of points, which is mathematically guaranteed to produce incorrect results. [5](#0-4) 

**Why Existing Protections Fail:**
The `IsMinerListJustChanged` flag prevents secret sharing when the miner list has just changed. [6](#0-5)  However, this only prevents **encoding new secrets** in the round where miners changed (Round N). It does NOT prevent **decoding old secrets** (from Round N-1) using the new miner count (from Round N) in subsequent rounds (Round N+1).

The check requiring sufficient decrypted pieces only validates quantity, not whether the threshold parameter matches the original encoding threshold. [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation:**
The incorrectly reconstructed InValues are stored in the round state. [8](#0-7) 

When miners subsequently produce blocks using these incorrect PreviousInValues, the consensus validation fails because the critical check `HashHelper.ComputeFrom(previousInValue) == previousOutValue` will fail - the incorrectly reconstructed InValue does not hash to the expected OutValue. [9](#0-8)  This triggers validation rejection with the message "Incorrect previous in value". [10](#0-9) 

**Concrete Damage:**
- Consensus can stall when miner count changes after stable operation periods
- All continuing miners from the previous round cannot produce valid blocks
- Network liveness is compromised until the miner set stabilizes
- No automatic recovery mechanism exists

**Severity: HIGH** - This breaks the fundamental consensus invariant of correct InValue/OutValue cryptographic chain verification, causing denial-of-service to the consensus mechanism and potentially halting block production network-wide.

## Likelihood Explanation

**Attacker Capabilities:**
No malicious attacker is required. This is a logic bug that triggers automatically during normal protocol operations.

**Attack Complexity:**
Very low. The vulnerability manifests when:
1. Miner set remains stable for 2+ rounds (secret sharing operates normally)
2. Miner count then changes through normal election process (term transition)
3. After the change stabilizes, the next round attempts secret reconstruction

**Feasibility Conditions:**
Validator elections naturally cause miner count changes in proof-of-stake systems. The conditions are realistic and occur regularly:
- Elections happen periodically (term transitions) [11](#0-10) 
- Miner counts fluctuate based on voting results
- The vulnerable code path executes automatically during these transitions [12](#0-11) 

**Detection:**
Would manifest as repeated block validation failures with "Incorrect previous in value" error messages immediately after miner set size changes.

**Probability: HIGH** - This occurs whenever the miner count changes after stable periods, which is a regular occurrence in production networks with dynamic validator sets.

## Recommendation

The fix should ensure that the decoding threshold matches the encoding threshold. There are several approaches:

**Option 1: Use Previous Round's Miner Count for Decoding**
```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // Use the previous round's miner count for threshold calculation
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;
    
    // ... rest of decoding logic ...
}
```

**Option 2: Skip Decoding When Miner Count Changed**
Add a check to skip revelation when the previous round had a different miner count:
```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // Skip if miner count has changed
    if (currentRound.RealTimeMinersInformation.Count != previousRound.RealTimeMinersInformation.Count)
        return;
    
    // ... rest of decoding logic ...
}
```

**Option 3: Store Original Threshold**
Store the encoding threshold with each round's data and use it during decoding.

**Recommended Fix:** Option 1 is the most straightforward and preserves the ability to reveal InValues across miner count changes while using the correct threshold.

## Proof of Concept

```csharp
[Fact]
public async Task SecretSharing_ThresholdMismatch_Test()
{
    // Setup: Initialize with 5 miners
    await InitializeCandidates(5);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    firstRound.RealTimeMinersInformation.Count.ShouldBe(5);
    
    // Round N-1: 5 miners produce blocks with secret sharing (threshold = 3)
    await ProduceNormalRoundWithSecretSharing(firstRound);
    
    // Round N: Term change to 3 miners (IsMinerListJustChanged=true)
    await TransitionToNewTermWithMiners(3);
    var termChangeRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    termChangeRound.IsMinerListJustChanged.ShouldBeTrue();
    termChangeRound.RealTimeMinersInformation.Count.ShouldBe(3);
    
    // Round N+1: Next round after term change (IsMinerListJustChanged=false)
    // This will call RevealSharedInValues which uses threshold = 2 
    // but tries to decode secrets encoded with threshold = 3
    await ProduceNextRound(termChangeRound);
    
    // Attempt to produce block with revealed InValue
    var nextRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var miner = nextRound.RealTimeMinersInformation.Values.First();
    
    // The revealed PreviousInValue is incorrect due to threshold mismatch
    // Validation should fail with "Incorrect previous in value"
    var result = await ProduceBlockWithPreviousInValue(miner.Pubkey, miner.PreviousInValue);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Incorrect previous in value");
}
```

## Notes

This vulnerability affects the core consensus mechanism and can cause network-wide disruption. The mathematical incorrectness is guaranteed by the properties of Shamir's Secret Sharing - a polynomial of degree k-1 requires exactly k points for reconstruction. Using a different number of points will always produce an incorrect result, not merely a potential error.

The fix is straightforward but critical: ensure the decoding threshold matches the encoding threshold by using the original round's miner count when calculating the reconstruction threshold.

### Citations

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L17-17)
```csharp
            var coefficients = new BigInteger[threshold];
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L17-17)
```csharp
            return new ValidationResult { Message = "Incorrect previous in value." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```
