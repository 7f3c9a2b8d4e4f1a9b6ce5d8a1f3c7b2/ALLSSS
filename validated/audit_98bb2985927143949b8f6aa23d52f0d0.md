# Audit Report

## Title
Referendum Proposals Create Unmitigated State Bloat Due to Lack of Cleanup Incentive

## Summary
The Referendum contract allows any user to create unlimited proposals through self-controlled organizations, consuming significant blockchain state with no deposit requirement or cleanup incentive. This enables a practical state bloat attack where proposals remain indefinitely in storage, increasing costs for all node operators.

## Finding Description

The Referendum contract's proposal lifecycle contains a critical design flaw enabling unbounded state growth through three interconnected weaknesses:

**1. Unrestricted Organization Creation with Self-Whitelisting**

The `CreateOrganization` method allows any user to create a referendum organization and specify their own address in the `ProposerWhiteList` without restriction. [1](#0-0) 

The validation logic only checks that the whitelist is non-empty, not who is on it, allowing attackers to grant themselves proposal creation privileges. [2](#0-1) 

**2. Deposit-Free Proposal Creation**

Once whitelisted, the `CreateProposal` method only verifies the proposer is on the organization's whitelist, with no deposit, stake, or economic cost beyond transaction fees. [3](#0-2) 

The authorization check confirms membership but imposes no additional restrictions. [4](#0-3) 

Each proposal stores substantial data including title (up to 255 characters), description (up to 10,200 characters), and URL (up to 255 characters). [5](#0-4) 

Proposals are permanently stored in the state mapping when created. [6](#0-5) 

Attackers can generate unique proposal IDs by varying the `token` parameter. [7](#0-6) 

**3. No Cleanup Incentive**

While `ClearProposal` allows anyone to remove expired proposals, it provides no economic reward, creating a "public good problem" where no rational actor pays gas to clean up spam. [8](#0-7) 

The `Release` method removes proposals from state only when they reach approval thresholds, which spam proposals never will. [9](#0-8) 

**Attack Execution:**

1. Attacker calls `CreateOrganization` with themselves on the `ProposerWhiteList`
2. Repeatedly calls `CreateProposal` with unique `token` values and long expiration times
3. Each proposal consumes ~10KB+ of state storage
4. Proposals accumulate indefinitely as no one has incentive to call `ClearProposal`
5. State database grows unbounded, increasing storage costs for all nodes

## Impact Explanation

**Direct Consequences:**

- **State Bloat:** Each proposal stores approximately 10,700+ bytes (10,200 char description + 255 char title + 255 char URL + addresses + parameters + timestamps)
- **Scalability Impact:** An attacker creating 10,000 proposals generates ~107MB of permanent state bloat
- **Node Operator Burden:** All full nodes must store and maintain this bloated state, increasing storage costs and I/O operations
- **Performance Degradation:** Larger state databases slow down state access, synchronization, and node performance over time
- **Economic Asymmetry:** Attacker pays minimal transaction fees while all node operators bear ongoing storage costs

**Severity Justification - Medium:**

- Does NOT directly steal funds or tokens
- Does NOT compromise consensus mechanisms
- DOES create operational denial-of-service through resource exhaustion
- DOES affect all network participants (not isolated to attacker)
- Impact accumulates progressively but is theoretically reversible (though impractical without cleanup incentives)

## Likelihood Explanation

**Attack Feasibility - High:**

- **Barrier to Entry:** None - any user can execute this attack with minimal technical knowledge
- **Cost:** Only standard transaction fees; no deposits, stakes, or economic deterrents
- **Automation:** Easily scriptable with simple loops to create thousands of proposals
- **Detectability:** Difficult to distinguish malicious spam from legitimate proposals until significant damage occurs

**Preconditions - All Satisfied:**

- Attacker creates organization via public `CreateOrganization` method (no restrictions)
- Whitelist validation only checks non-empty status, not membership legitimacy
- No rate limiting, quotas, or per-proposer restrictions exist
- Cleanup mechanism exists but lacks economic incentive for execution

**Probability Assessment - Medium:**

While the attack path is trivial, likelihood is rated medium rather than high because:
- Requires sustained transaction costs (though minimal)
- May eventually draw community attention requiring coordination
- Could be detected and manually cleaned (though impractical at scale)

## Recommendation

Implement a multi-layered defense approach:

**1. Proposal Creation Deposit**
Require depositing tokens when creating proposals, refunded only if the proposal reaches minimum participation thresholds or is executed. Expired/rejected proposals forfeit deposits to a treasury or cleanup reward pool.

**2. Cleanup Incentive Mechanism**
Reward addresses that call `ClearProposal` by providing a percentage of forfeited proposal deposits or protocol treasury funds. This creates economic incentive for voluntary cleanup.

**3. Rate Limiting**
Implement per-organization or per-proposer rate limits on proposal creation (e.g., maximum 10 active proposals per organization).

**4. Automatic Expiration**
Add a maximum proposal lifetime (e.g., 90 days) after which proposals automatically become invalid and prioritized for cleanup.

**5. Whitelist Governance**
Consider requiring organization whitelists to be managed through governance proposals rather than arbitrary creator assignment, or implement minimum token-holding requirements for whitelist members.

Example implementation for deposit mechanism:

```csharp
// In CreateProposal
public override Hash CreateProposal(CreateProposalInput input)
{
    AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
    
    // Require deposit
    var organization = State.Organizations[input.OrganizationAddress];
    var requiredDeposit = GetProposalDeposit();
    
    State.TokenContract.TransferFrom.Send(new TransferFromInput {
        From = Context.Sender,
        To = Context.Self,
        Symbol = organization.TokenSymbol,
        Amount = requiredDeposit
    });
    
    var proposalId = CreateNewProposal(input);
    State.ProposalDeposits[proposalId] = new DepositInfo {
        Depositor = Context.Sender,
        Amount = requiredDeposit,
        Symbol = organization.TokenSymbol
    };
    
    return proposalId;
}

// In ClearProposal - add reward
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, 
        "Proposal clear failed");
    
    // Reward cleaner with portion of forfeited deposit
    var deposit = State.ProposalDeposits[input];
    if (deposit != null) {
        var cleanupReward = deposit.Amount.Mul(20).Div(100); // 20% reward
        State.TokenContract.Transfer.Send(new TransferInput {
            To = Context.Sender,
            Symbol = deposit.Symbol,
            Amount = cleanupReward
        });
        // Remaining 80% to treasury
    }
    
    State.Proposals.Remove(input);
    State.ProposalDeposits.Remove(input);
    return new Empty();
}
```

## Proof of Concept

```csharp
// Test demonstrating state bloat attack
[Fact]
public async Task StateBloatAttack_UnlimitedProposalCreation()
{
    // Step 1: Attacker creates organization with self-whitelist
    var attacker = SampleAccount.Accounts[0].Address;
    var createOrgInput = new CreateOrganizationInput
    {
        TokenSymbol = "ELF",
        ProposerWhiteList = new ProposerWhiteList { Proposers = { attacker } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1000,
            MinimalVoteThreshold = 1000,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        }
    };
    
    var orgAddress = await ReferendumContractStub.CreateOrganization.SendAsync(createOrgInput);
    
    // Step 2: Spam proposals with unique tokens
    var proposalCount = 100; // In real attack, would be thousands
    var createdProposals = new List<Hash>();
    
    for (int i = 0; i < proposalCount; i++)
    {
        var proposalInput = new CreateProposalInput
        {
            OrganizationAddress = orgAddress.Output,
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractStub.Transfer),
            Params = new TransferInput { To = attacker, Amount = 1, Symbol = "ELF" }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(365), // 1 year expiration
            Token = HashHelper.ComputeFrom($"spam_{i}"), // Unique token for unique ID
            Title = new string('A', 255), // Max length
            Description = new string('B', 10200), // Max length  
            ProposalDescriptionUrl = $"http://spam.com/{i}"
        };
        
        var proposalId = await ReferendumContractStub.CreateProposal.SendAsync(proposalInput);
        createdProposals.Add(proposalId.Output);
    }
    
    // Step 3: Verify all proposals are stored in state
    foreach (var proposalId in createdProposals)
    {
        var proposal = await ReferendumContractStub.GetProposal.CallAsync(proposalId);
        proposal.ProposalId.ShouldBe(proposalId);
        proposal.Description.Length.ShouldBe(10200); // Full bloat data stored
    }
    
    // Step 4: Demonstrate cleanup is impractical without incentive
    // Fast forward past expiration
    BlockTimeProvider.SetBlockTime(TimestampHelper.GetUtcNow().AddDays(366));
    
    // Manual cleanup of ONE proposal (attacker created 100+)
    await ReferendumContractStub.ClearProposal.SendAsync(createdProposals[0]);
    
    // Remaining 99 proposals still bloat state - no incentive to clean
    var stillExists = await ReferendumContractStub.GetProposal.CallAsync(createdProposals[1]);
    stillExists.ProposalId.ShouldBe(createdProposals[1]);
    
    // Attack successful: 99 proposals Ã— ~10KB = ~990KB permanent state bloat
    // Real attack with 10,000 proposals = ~100MB bloat
}
```

**Notes:**

The vulnerability is confirmed through direct code analysis showing all three attack prerequisites are satisfied: unrestricted self-whitelisting via organization creation, deposit-free proposal spam, and zero economic incentive for cleanup. The optional `SetMethodFee` mechanism provides insufficient protection as it only adds minimal transaction costs and requires Parliament governance to configure. [10](#0-9)

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L154-157)
```csharp
    private Hash GenerateProposalId(CreateProposalInput input)
    {
        return Context.GenerateId(Context.Self, input.Token ?? HashHelper.ComputeFrom(input));
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L159-187)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ToAddress = input.ToAddress,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            OrganizationAddress = input.OrganizationAddress,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumConstants.cs (L4-7)
```csharp
{
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```
