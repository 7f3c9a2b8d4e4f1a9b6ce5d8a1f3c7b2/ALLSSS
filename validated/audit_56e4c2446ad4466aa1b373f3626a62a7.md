# Audit Report

## Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

## Summary
When a miner replaces their public key during a term via `ReplaceCandidatePubkey`, the Election Contract removes the old pubkey's `candidateInformation` and transfers it to the new pubkey. However, the Consensus Contract only updates the current round data, leaving previous rounds with the old pubkey. When `TakeSnapshot` is called at term end, it retrieves miners from stored previous round data (containing old pubkeys) and attempts to update `candidateInformation`, but silently fails due to an early return when the old pubkey's data is null. This causes miners to lose credit for terms where they successfully participated.

## Finding Description

The vulnerability stems from incomplete synchronization between the Election and Consensus contracts during pubkey replacement.

**Root Cause Flow:**

When `ReplaceCandidatePubkey` is called, the Election Contract transfers `candidateInformation` from old to new pubkey and removes the old entry: [1](#0-0) 

The Consensus Contract is notified via `RecordCandidateReplacement`, which only updates the **current round**: [2](#0-1) 

**Critical Gap:** Previous rounds stored in `State.Rounds[previousRoundNumbers]` are never updated and still contain the old pubkey.

**Failure Point at Term End:**

When `TakeSnapshot` is called, it retrieves previous term miners: [3](#0-2) 

`GetPreviousTermMinerPubkeyList` returns pubkeys directly from stored round data without applying any replacement mapping: [4](#0-3) 

The private `UpdateCandidateInformation` method has an early return when `candidateInformation` is null: [5](#0-4) 

Since the old pubkey's `candidateInformation` was removed during `ReplaceCandidatePubkey`, the update silently fails. The miner's `Terms` list (line 486) and `ContinualAppointmentCount` (line 488-490) are never updated for that term.

**Why Existing Protections Fail:**

The codebase has `GetNewestPubkey` specifically to handle pubkey replacements: [6](#0-5) 

This function is correctly used in other flows like vote withdrawal: [7](#0-6) 

And in view methods for snapshot retrieval: [8](#0-7) 

However, it is **not used** in the `TakeSnapshot` flow before calling `UpdateCandidateInformation`, causing the vulnerability.

## Impact Explanation

**Direct Impact:**
- Miners who replace their pubkeys lose historical credit for terms where they actively participated and produced blocks
- The `Terms` list in `candidateInformation` becomes incomplete, violating the documented invariant that it indicates "which terms the candidate participated in"
- `ContinualAppointmentCount` is incorrectly calculated, breaking continuity tracking for consecutive term participation

**Affected Parties:**
- Any miner who uses the legitimate pubkey replacement feature for key rotation
- Voters who rely on accurate candidate participation history for informed voting decisions
- Off-chain systems or UIs that display miner participation records

**Severity:** This is a **High** severity issue because it directly compromises the integrity of election system records, which are fundamental to transparency and accountability in the AEDPoS consensus mechanism. While it doesn't cause direct fund loss, it breaks critical protocol invariants and could affect future eligibility or reward calculations if the `Terms` list is used in such logic.

## Likelihood Explanation

**Trigger Conditions:**
- Any registered candidate/miner can call `ReplaceCandidatePubkey` (only requires candidate admin permission, which is legitimate)
- No special timing required - can happen at any point during a term
- The term credit loss occurs automatically when the term ends and `TakeSnapshot` is called by the consensus contract

**Attack Complexity:** Extremely simple - just use the legitimate pubkey replacement feature. No race conditions, no special setup, no suspicious behavior.

**Probability:** **High** - This will occur for every miner who replaces their pubkey before a term ends. The feature is specifically designed for key rotation scenarios in production environments, so usage is expected and encouraged for security best practices.

## Recommendation

Modify the `TakeSnapshot` method to resolve pubkeys to their newest version before calling `UpdateCandidateInformation`:

```csharp
foreach (var pubkey in previousTermMinerList)
{
    // Resolve to newest pubkey before updating
    var newestPubkey = GetNewestPubkey(pubkey);
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

This ensures that candidate information is updated for the correct (newest) pubkey, maintaining the integrity of the `Terms` list and `ContinualAppointmentCount`.

## Proof of Concept

```csharp
[Fact]
public async Task MinerLosesTermCreditAfterPubkeyReplacement_Test()
{
    // Setup: Initialize contracts and become a miner
    InitializeContracts();
    
    var minerKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    
    // Announce election and become a miner in term 1
    await AnnounceElectionAsync(minerKeyPair, candidateAdminAddress);
    await NextTerm(BootMinerKeyPair);
    
    // Verify miner is active and check initial candidate info
    var candidateInfoBefore = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = minerKeyPair.PublicKey.ToHex() });
    var termsBefore = candidateInfoBefore.Terms.Count;
    
    // Mid-term: Replace pubkey
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var candidateAdminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair.PublicKey.ToHex(),
        NewPubkey = newKeyPair.PublicKey.ToHex()
    });
    
    // Advance to next term - this triggers TakeSnapshot
    await NextTerm(BootMinerKeyPair);
    
    // BUG: Check new pubkey's candidate info - Terms list should include previous term
    var candidateInfoAfter = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = newKeyPair.PublicKey.ToHex() });
    
    // VULNERABILITY: The term credit is lost!
    // Expected: termsBefore + 1 (miner participated in the term before replacement)
    // Actual: termsBefore (term credit was not recorded)
    candidateInfoAfter.Terms.Count.ShouldBe(termsBefore); // This passes, proving the bug
    // candidateInfoAfter.Terms.Count.ShouldBe(termsBefore + 1); // This should pass but fails
}
```

## Notes

This vulnerability demonstrates a synchronization gap between contract state updates during pubkey replacement. The `GetNewestPubkey` function exists and is correctly used in other flows, but the critical `TakeSnapshot` method fails to use it when updating candidate information. This results in permanent loss of participation records for miners who legitimately rotate their keys for security purposes.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-243)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L331-357)
```csharp
    public override StringValue GetNewestPubkey(StringValue input)
    {
        return new StringValue { Value = GetNewestPubkey(input.Value) };
    }

    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }

    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L430-434)
```csharp
        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L481-492)
```csharp
    private void UpdateCandidateInformation(string pubkey, long lastTermNumber,
        List<string> previousMiners)
    {
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-473)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L651-651)
```csharp
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L343-343)
```csharp
            Candidate = GetNewestPubkey(votingRecord.Option),
```
