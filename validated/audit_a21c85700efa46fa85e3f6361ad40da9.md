# Audit Report

## Title
Missing Extra Block Producer Validation Allows Consensus DoS via InvalidOperationException

## Summary
The AEDPoS consensus contract fails to validate that Round objects submitted via `NextRound` or `NextTerm` transactions contain at least one miner designated as the extra block producer. A malicious miner can exploit this to store a malformed Round that causes critical consensus methods to throw `InvalidOperationException`, resulting in a complete chain halt.

## Finding Description

The consensus contract accepts externally-provided Round objects without validating a critical invariant: the presence of at least one miner with `IsExtraBlockProducer == true`.

**Vulnerable Code Locations:**

1. **GetNextMinerPubkey()** - When all miners' `ExpectedMiningTime` values have passed, the fallback logic attempts to find the extra block producer using `First(m => m.IsExtraBlockProducer)`, which throws `InvalidOperationException` if no miner has this flag set. [1](#0-0) 

2. **IsCurrentMiner()** - Checks extra block producer time slot using `Single(m => m.Value.IsExtraBlockProducer)`, which throws `InvalidOperationException` if zero or multiple miners have this flag set. [2](#0-1) 

3. **GetExtraBlockProducerInformation()** - Called by `ArrangeAbnormalMiningTime`, uses `First(bp => bp.Value.IsExtraBlockProducer)`, which throws `InvalidOperationException` if no extra block producer exists. [3](#0-2) 

**Missing Validation:**

The entry points `ProcessNextRound` and `ProcessNextTerm` accept user-provided input, convert it to Round via `ToRound()`, and store it without validating the extra block producer invariant. [4](#0-3) [5](#0-4) 

The `ToRound()` conversion method simply copies fields without validation. [6](#0-5) 

The `RoundTerminateValidationProvider` only validates round numbers and `InValue` nullness, not the presence of an extra block producer. [7](#0-6) 

**Attack Path:**

1. Malicious miner crafts a `NextRoundInput` or `NextTermInput` with valid round/term numbers and miner information, but sets all miners' `IsExtraBlockProducer` to `false`
2. Submits transaction via `NextRound` or `NextTerm` public method [8](#0-7) 
3. `PreCheck()` validates only that sender is in current or previous miner list - passes [9](#0-8) 
4. All validation providers check round numbers, but not extra block producer - passes
5. Malformed Round is stored via `AddRoundInformation()` [10](#0-9) 
6. Subsequent calls to consensus methods throw `InvalidOperationException`, halting the chain

**Contrast with Normal Behavior:**

When rounds are generated legitimately via `GenerateNextRoundInformation()`, the code always sets exactly one miner as the extra block producer, demonstrating this is a required invariant. [11](#0-10) 

## Impact Explanation

**HIGH Severity - Complete Consensus Halt**

Once a malformed Round is stored, three critical operations fail with exceptions:

1. **Block Broadcasting Failure**: `GetNextMinerPubkey` is called by the network layer to determine the next miner for prioritized block propagation. An exception here prevents blocks from being broadcast to the correct miner, breaking block propagation.

2. **Mining Permission Validation Failure**: `IsCurrentMiner` is used during block validation to verify mining permissions. [12](#0-11)  An exception prevents all miners from validating their permission to mine, blocking all block production.

3. **Consensus Command Generation Failure**: `ArrangeAbnormalMiningTime` (via `GetExtraBlockProducerInformation`) is used by `TerminateRoundCommandStrategy` to generate consensus commands for round transitions. [13](#0-12) [14](#0-13)  An exception prevents round termination, freezing consensus progression.

All network participants are affected - miners cannot produce blocks, nodes cannot validate blocks, and the chain cannot progress. Recovery requires manual intervention as the malformed Round persists in state.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**

**Attacker Requirements:**
- Must be a current or previous round miner (verified by `PreCheck`)
- No special privileges beyond being an active miner
- Cost is only transaction fees

**Attack Complexity:** LOW
- Simply craft a `NextRoundInput`/`NextTermInput` with correct round/term numbers
- Set all miners' `IsExtraBlockProducer` to `false`
- Submit via `NextRound` or `NextTerm` transaction
- No complex timing or coordination required

**Feasibility:** The attack is highly practical:
- Any malicious miner can execute it
- No existing validation detects the malformed input before storage
- Single transaction causes permanent chain halt
- Attack surface exists on every round/term transition

## Recommendation

Add validation in `ProcessNextRound` and `ProcessNextTerm` to ensure exactly one miner has `IsExtraBlockProducer == true`:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Validate extra block producer existence
    var extraBlockProducerCount = nextRound.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    Assert(extraBlockProducerCount == 1, 
        "Round must contain exactly one extra block producer.");
    
    // ... rest of existing logic
}
```

Apply the same validation in `ProcessNextTerm`. Alternatively, add a validation provider:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextRound && 
            validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
            
        var extraBlockProducerCount = validationContext.ExtraData.Round
            .RealTimeMinersInformation.Values.Count(m => m.IsExtraBlockProducer);
            
        return extraBlockProducerCount == 1
            ? new ValidationResult { Success = true }
            : new ValidationResult { Message = "Round must contain exactly one extra block producer." };
    }
}
```

Then register this provider in `ValidateBeforeExecution` for `NextRound` and `NextTerm` behaviors.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousRound_WithoutExtraBlockProducer_CausesConsensusHalt()
{
    // Setup: Initialize consensus with valid first round
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Attacker crafts malicious NextRoundInput with no extra block producer
    var maliciousRoundInput = new NextRoundInput
    {
        RoundNumber = 2,
        TermNumber = 1,
        RealTimeMinersInformation = 
        {
            { "miner1", new MinerInRound { Pubkey = "miner1", Order = 1, IsExtraBlockProducer = false } },
            { "miner2", new MinerInRound { Pubkey = "miner2", Order = 2, IsExtraBlockProducer = false } },
            { "miner3", new MinerInRound { Pubkey = "miner3", Order = 3, IsExtraBlockProducer = false } }
        }
    };
    
    // Attack: Submit malicious round (should pass all existing validations)
    await ConsensusStub.NextRound.SendAsync(maliciousRoundInput);
    
    // Verify: GetNextMinerPubkey throws InvalidOperationException
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(
        async () => await ConsensusStub.GetNextMinerPubkey.CallAsync(new Empty()));
    Assert.Contains("Sequence contains no matching element", exception.Message);
    
    // Verify: IsCurrentMiner throws InvalidOperationException
    exception = await Assert.ThrowsAsync<InvalidOperationException>(
        async () => await ConsensusStub.IsCurrentMiner.CallAsync(miner1Address));
    Assert.Contains("Sequence contains no matching element", exception.Message);
    
    // Consensus is now halted - chain cannot progress
}
```

## Notes

This vulnerability exploits the gap between the invariant enforced by internal round generation logic (which always sets an extra block producer) and the lack of validation for externally-provided Round objects. While legitimate consensus operations maintain the invariant, malicious miners can bypass it by directly calling `NextRound`/`NextTerm` with crafted inputs. The impact is severe because the malformed state persists and affects all subsequent consensus operations, requiring off-chain intervention to recover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L96-98)
```csharp
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L67-68)
```csharp
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```
