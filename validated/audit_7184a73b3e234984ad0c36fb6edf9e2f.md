# Audit Report

## Title
Incorrect Factorial Indexing in Exponential Function Causes Systematic Token Pricing Errors

## Summary
The `Exp()` function in `BancorHelper.cs` contains an off-by-one indexing error when accessing the precomputed factorial array. This causes each term in the Taylor series expansion to use (k-1)! instead of k!, resulting in systematically incorrect exponential calculations that propagate through all token conversion pricing operations in the TokenConverter contract.

## Finding Description

The vulnerability exists in the implementation of the exponential function used for Bancor pricing calculations.

**The Factorial Array Initialization:** [1](#0-0) 

This creates an array where `Fact[0] = 0!`, `Fact[1] = 1!`, ..., `Fact[19] = 19!`.

**The Loop Configuration:** [2](#0-1) 

**The Buggy Implementation:** [3](#0-2) 

The bug occurs at line 159 where `Fact[iteration - 1]` is accessed. When `iteration` starts at 20 and counts down to 1:
- iteration=20 uses `Fact[19] = 19!` but should use `20!`
- iteration=19 uses `Fact[18] = 18!` but should use `19!`
- iteration=k uses `Fact[k-1] = (k-1)!` but should use `k!`

The documented formula (line 151) shows the correct exponential series: `exp(y) = 1 + y + y^2/2 + y^3/3! + y^4/4! + y^5/5! + ...`

But the implementation computes: `exp(y) = 1 + y^1/0! + y^2/1! + y^3/2! + ... + y^20/19!`

Since `k! = k × (k-1)!`, each term `y^k/(k-1)!` equals `k × (y^k/k!)`, making it k times larger than the mathematically correct value (except when k=1 where 0! = 1! = 1).

**Production Usage in Buy Operations:** [4](#0-3) 

**Production Usage in Sell Operations:** [5](#0-4) 

Both pricing functions use the incorrect `Exp()`: [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability causes systematic economic mispricing across all token conversion operations:

1. **Universal Impact**: Every call to `Buy()` or `Sell()` uses the incorrect exponential calculation, affecting 100% of token swap transactions.

2. **Incorrect Pricing**: Users pay wrong amounts when buying tokens or receive wrong amounts when selling tokens, as the Bancor pricing formula depends critically on accurate exponential calculations.

3. **Mathematical Integrity Violation**: The implementation violates the documented Bancor algorithm's mathematical correctness, which is designed to provide fair automated market-making based on connector weights and reserve balances.

4. **Error Magnitude**: The mispricing increases with:
   - Larger trade sizes (when balance ratios deviate significantly from 1)
   - Higher weight ratios between connectors  
   - Higher-order terms in the series (term k is k times too large)

5. **No Unfair Advantage**: While this is a critical bug, it affects all users equally and deterministically - there's no way for an attacker to exploit this for unfair gain versus other users.

The severity is **Medium** because while it affects core economic functionality and causes value misallocation on every transaction, it doesn't enable direct theft, doesn't give attackers special advantages, and doesn't allow unlimited exploitation.

## Likelihood Explanation

**Probability: 100%** - This bug triggers automatically on every single token conversion transaction.

**Attacker Capabilities**: Any user can trigger this by calling the public `Buy()` or `Sell()` methods with any valid token pair and amount. No special permissions, setup, or knowledge required.

**Attack Complexity**: None - the bug is inherent in the mathematical implementation and executes deterministically on normal contract usage.

**Feasibility Conditions**: Only requires that the TokenConverter contract is initialized with token pairs and users perform normal buy/sell operations.

**Detection Difficulty**: The error is consistent and deterministic, making it affect all transactions equally. Without an external reference implementation, users cannot easily detect the mispricing.

## Recommendation

Fix the factorial indexing in the `Exp()` function. The bug can be corrected by either:

**Option 1**: Extend the factorial array to include `Fact[20] = 20!` and use `Fact[iteration]` instead of `Fact[iteration - 1]`

**Option 2**: Adjust the loop to start from 19 instead of 20

**Option 3**: Change the indexing logic to correctly map iteration values to factorials

The corrected implementation should compute:
```
exp(y) = 1 + y^1/1! + y^2/2! + y^3/3! + ... + y^20/20!
```

Verify the fix with mathematical test cases comparing against known exponential values before deployment.

## Proof of Concept

**Mathematical Demonstration:**

For a concrete example with y = 0.1 (small value to demonstrate the pattern):

**Correct exponential calculation:**
- exp(0.1) = 1 + 0.1/1! + 0.01/2! + 0.001/3! + ...
- = 1 + 0.1 + 0.005 + 0.000167 + ...
- ≈ 1.10517 (mathematical correct value)

**Buggy implementation calculation:**
- exp(0.1) = 1 + 0.1/0! + 0.01/1! + 0.001/2! + ...
- = 1 + 0.1 + 0.01 + 0.0005 + ...
- ≈ 1.1105+ (incorrect inflated value)

**Error analysis for each term:**
- k=1: y/0! = y (same as y/1! since 0!=1!=1) ✓
- k=2: y²/1! = 2×(y²/2!) - **2× too large**
- k=3: y³/2! = 3×(y³/3!) - **3× too large**
- k=20: y²⁰/19! = 20×(y²⁰/20!) - **20× too large**

The incorrect exponential function systematically overestimates values, causing the Bancor pricing formulas in `GetReturnFromPaid()` and `GetAmountToPayFromReturn()` to return incorrect token amounts on every `Buy()` and `Sell()` transaction executed through the TokenConverter contract.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L13-13)
```csharp
        Fact = Array.AsReadOnly(Enumerable.Range(0, 20).Select(x => DynFact(x)).ToArray());
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```
