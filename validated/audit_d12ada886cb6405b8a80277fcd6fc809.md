# Audit Report

## Title
Missing Election Results Validation in NextTerm Allows Current Miners to Bypass Elections and Retain Mining Authority

## Summary
The `NextTerm` method in AEDPoSContract lacks on-chain validation to ensure the miner list matches election results from `GetVictories`. A current miner can call `NextTerm` with an arbitrary miner list (including themselves) even if they lost the election, completely bypassing the voting-based miner selection mechanism and retaining control over block production indefinitely.

## Finding Description

The vulnerability exists in the validation and processing flow of term transitions. The AEDPoS consensus system relies on elections to determine the miner set for each term, but the on-chain validation does not enforce that the provided miner list matches the election winners.

**Execution Path:**

The `NextTerm` method is a public RPC endpoint accessible to any transaction sender [1](#0-0) . When called, it invokes `ProcessConsensusInformation` which performs access control via `PreCheck()`.

The `PreCheck()` method allows ANY miner in the current OR previous round to call consensus methods, including `NextTerm` [2](#0-1) . This means a miner who lost the election can still invoke `NextTerm`.

For `NextTerm` behavior, the validation chain only adds `RoundTerminateValidationProvider` [3](#0-2) . This validator only checks that term and round numbers increment correctly, performing NO validation of the miner list contents [4](#0-3) .

The `ProcessNextTerm` method blindly accepts whatever miner list is provided in `NextTermInput.RealTimeMinersInformation` and sets it as the new miner list without comparing it against election results [5](#0-4) .

**Off-chain vs On-chain:**

While the protocol has mechanisms to retrieve election results via `TryToGetVictories` [6](#0-5)  and `GenerateFirstRoundOfNextTerm` [7](#0-6) , these are only used for off-chain consensus extra data generation [8](#0-7) , not for on-chain validation in `ProcessNextTerm`.

**Attack Scenario:**

1. A current miner observes they are losing the election
2. They create a malicious `NextTermInput` with arbitrary miner list including themselves
3. As block producer, they include this malicious `NextTerm` transaction in their block
4. The transaction passes `PreCheck()` (they're a current miner)
5. The transaction passes validation (only term/round numbers checked)
6. `ProcessNextTerm` sets the malicious miner list permanently
7. The attacker retains mining authority for the next term
8. Process repeats indefinitely

## Impact Explanation

This is a **critical consensus integrity violation** with the following impacts:

**Consensus Breakdown:**
- Attackers completely bypass the election system that is fundamental to AEDPoS consensus
- Enables permanent control over block production regardless of voting outcomes
- Violates the core democratic governance model where token holders vote for validators

**Economic Damage:**
- Miners who lost elections retain full block production authority and continue receiving block rewards [9](#0-8) 
- Legitimate election winners are excluded from mining and lose expected rewards
- Block rewards continue flowing to unelected miners indefinitely
- The economic incentive model based on staking and voting becomes meaningless

**Governance Capture:**
- Community loses ability to remove malicious or underperforming miners through elections
- Small cartel of miners can self-perpetuate control indefinitely
- Voting system becomes ineffective - votes cannot change the miner set
- Protocol credibility is severely damaged

## Likelihood Explanation

This vulnerability has **high likelihood** of exploitation:

**Reachable Entry Point:**
The `NextTerm` method is publicly accessible as it's a public override method in the consensus contract [10](#0-9) .

**Attacker Prerequisites:**
- Must be a current miner (has mining authority in current term)
- Can construct `NextTermInput` with arbitrary miner list including themselves
- Can observe election results on-chain to know they're losing

**Execution Simplicity:**
- Attack requires single transaction calling `NextTerm` with malicious input
- No complex state manipulation needed
- No timing constraints beyond normal term transition
- Passes all existing validation checks

**Economic Incentive:**
- Cost: Standard transaction fee
- Benefit: Retain mining rewards worth potentially millions in tokens over time
- Extremely profitable for miners facing election loss
- Risk-free since appears as legitimate term transition

## Recommendation

Add on-chain validation in `ProcessNextTerm` to verify the provided miner list matches election results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();
    CountMissedTimeSlots();
    Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");
    
    // SECURITY FIX: Validate miner list against election results
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = victoriesPublicKeys.Value.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        var providedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        Assert(expectedMiners.Count == providedMiners.Count, "Miner count mismatch with election results.");
        Assert(expectedMiners.SequenceEqual(providedMiners), "Miner list does not match election results.");
    }
    
    // Continue with existing logic...
    Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
    // ... rest of the method
}
```

Alternatively, add a `MinerListValidationProvider` to the validation chain for `NextTerm` behavior in `ValidateBeforeExecution`.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithArbitraryMinerList_BypassesElection()
{
    // Setup: Initialize consensus with initial miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Setup: Miner1 is current miner but will lose election
    var currentMiner = initialMiners[0];
    
    // Setup: Election results show miner1 lost (new winners are miner4, miner5, miner6)
    var electionWinners = new[] { "miner4", "miner5", "miner6" };
    await SetupElectionWinners(electionWinners);
    
    // Attack: Miner1 creates malicious NextTermInput with themselves included
    var maliciousMinerList = new[] { currentMiner, "attacker_controlled1", "attacker_controlled2" };
    var maliciousInput = CreateNextTermInput(
        termNumber: 2,
        roundNumber: 1,
        minerList: maliciousMinerList
    );
    
    // Execute: Current miner calls NextTerm with malicious list
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    
    // Verify: Transaction succeeds (should fail but doesn't)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Malicious miner list is set (bypassing election)
    var actualMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    actualMinerList.Pubkeys.Select(p => p.ToHex()).ShouldBe(maliciousMinerList);
    
    // Verify: Legitimate election winners are NOT in miner list
    foreach (var winner in electionWinners)
    {
        actualMinerList.Pubkeys.Select(p => p.ToHex()).ShouldNotContain(winner);
    }
    
    // Result: Election bypassed - attacker retains control
}
```

**Notes:**

This vulnerability fundamentally breaks the election-based consensus model. The off-chain consensus command generation correctly uses `TryToGetVictories` to get election results, but the on-chain execution trusts the caller's input without verification. Any current miner can exploit this to retain control indefinitely, making the entire voting and election system ineffective.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
