# Audit Report

## Title
FinalOrderOfNextRound Manipulation Allows Mining Order Centralization

## Summary
The AEDPoS consensus mechanism fails to validate that `FinalOrderOfNextRound` and `SupposedOrderOfNextRound` values are correctly calculated from miners' signatures. A malicious miner can modify these values in block headers to guarantee favorable mining positions in subsequent rounds, centralizing block production without detection.

## Finding Description

The vulnerability exists in the consensus validation and state update flow. While `SupposedOrderOfNextRound` should be deterministically calculated from a miner's signature using `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, the system never validates this calculation was performed correctly. [1](#0-0) 

The validation gap occurs in `UpdateValueValidationProvider`, which only checks that `OutValue` and `Signature` fields are non-empty, without verifying the order calculation: [2](#0-1) 

When processing consensus updates, `ProcessUpdateValue` blindly applies the values from the input without recalculation: [3](#0-2) [4](#0-3) 

These manipulated values directly determine mining positions when the next round is generated: [5](#0-4) 

The after-execution validation also fails because `RecoverFromUpdateValue` copies the order values without recalculation: [6](#0-5) 

This allows `ValidateConsensusAfterExecution` to pass since both header and state contain the same manipulated values: [7](#0-6) 

## Impact Explanation

This vulnerability breaks the core consensus invariant of fair miner rotation. A malicious miner can:

1. **Centralize Block Production**: Consistently secure position 1 in each round, mining first and gaining disproportionate block rewards
2. **Unfair Advantage**: Control significantly more blocks than their fair share over time
3. **Consensus Subversion**: Bypass the VRF-based randomization designed to ensure unpredictable, fair miner ordering
4. **Network Decentralization Violation**: Single miner can dominate consensus without majority collusion

The manipulated `FinalOrderOfNextRound` directly controls `Order` and `ExpectedMiningTime` in subsequent rounds, giving the attacker priority time slots repeatedly. Honest miners lose their fair share of block production opportunities and rewards.

## Likelihood Explanation

**Attacker Requirements:**
- Active miner in consensus set (realistic)
- Ability to modify node software (feasible for sophisticated miners)

**Attack Complexity:** LOW
- Requires only modifying integer values in the Round object before block header serialization
- No cryptographic capabilities needed beyond normal mining operations
- No coordination with other miners required
- Can be executed every time the attacker produces a block

**Detection:** Very difficult
- No on-chain evidence of manipulation
- Values appear valid to all validators
- Would require off-chain statistical monitoring

The attack is highly feasible because miners control their own node software and the validation gap allows manipulated blocks to pass all checks.

## Recommendation

Add validation to verify that `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` were correctly calculated from the signature:

```csharp
// In UpdateValueValidationProvider or a new validator
private bool ValidateOrderCalculation(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    
    // Recalculate what the order should be
    var sigNum = minerInRound.Signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    
    // Verify it matches the provided value
    if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
    {
        return false;
    }
    
    return true;
}
```

Additionally, validate `TuneOrderInformation` entries to ensure order adjustments are legitimate conflict resolutions, not arbitrary manipulations.

## Proof of Concept

A proof of concept would require:
1. Modifying a test miner node to intercept the Round object after `ApplyNormalConsensusData`
2. Setting `SupposedOrderOfNextRound = 1` and `FinalOrderOfNextRound = 1` for the attacker
3. Producing a block with this manipulated Round
4. Observing that validation passes and the manipulated order is applied to state
5. Verifying the attacker mines first in the subsequent round

The vulnerability is confirmed through code analysis showing the missing validation and blind state update, combined with direct impact on next round generation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-32)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
