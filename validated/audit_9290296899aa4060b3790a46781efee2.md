# Audit Report

## Title
Referendum Organizations Can Be Permanently Bricked With Invalid Proposer Addresses

## Summary
The Referendum contract's organization validation fails to verify that addresses in the ProposerWhiteList contain valid (non-empty) ByteString values. An attacker can create organizations with whitelists containing only addresses with empty ByteString values, which pass validation but are permanently unusable since no valid proposer can create proposals and the whitelist cannot be modified without executing a proposal.

## Finding Description

The vulnerability exists in the organization validation logic during creation. When `CreateOrganization` is called [1](#0-0) , it validates the organization using the `Validate()` method [2](#0-1) , which checks whether the ProposerWhiteList is empty but never validates individual address validity [3](#0-2) .

The `Empty()` extension method only checks if the count is zero [4](#0-3) . This allows an attacker to add Address objects with `Value = ByteString.Empty` (protobuf3 default) to satisfy the non-empty requirement.

The ProposerWhiteList is defined as a repeated Address field with no inherent validation [5](#0-4) , and Address itself is just a bytes wrapper [6](#0-5) .

When users attempt to create proposals, authorization is enforced via `AssertIsAuthorizedProposer` [7](#0-6) , which checks if the proposer exists in the whitelist using `Contains()` [8](#0-7) . This check uses protobuf equality comparison [9](#0-8) , where addresses with valid ByteString values will never equal addresses with empty ByteString values.

The recovery mechanism is blocked because `ChangeOrganizationProposerWhiteList` requires `Context.Sender` to be the organization address itself [10](#0-9) , which can only occur through virtual inline calls during proposal execution. Since no proposals can be created, the whitelist cannot be updated, permanently bricking the organization.

Notably, other contracts in the codebase implement proper address validation. The MultiToken contract validates addresses with `AssertValidInputAddress` that checks for null and empty values [11](#0-10) , but the Referendum contract lacks this validation for whitelist addresses.

## Impact Explanation

**Operational Impact - Permanent DoS:**
- Any user can create permanently unusable Referendum organizations at minimal gas cost
- Organization addresses are deterministic based on input parameters [12](#0-11) , allowing attackers to pre-occupy addresses that legitimate users intend to create
- Once created, organizations cannot be deleted or recovered (no deletion mechanism exists in the contract)
- State bloat from accumulation of unusable organizations

**Governance Impact:**
- Complete DoS of Referendum governance functionality for affected organizations
- No admin override or recovery mechanism exists
- Violates the fundamental governance invariant that organizations with non-empty whitelists must allow authorized proposers to create proposals

The severity is **HIGH** because it enables permanent, unrecoverable DoS of critical governance infrastructure with minimal attack cost and no privileged access required.

## Likelihood Explanation

**Entry Point:** The `CreateOrganization` method is publicly accessible [13](#0-12) .

**Attack Feasibility:**
- In protobuf3 C#, creating an Address with empty ByteString is trivial: `new Address()` defaults to `Value = ByteString.Empty`
- The attacker constructs a `CreateOrganizationInput` with valid parameters except the ProposerWhiteList contains only invalid addresses
- Single transaction execution with standard gas cost
- No special permissions required

**Economic Rationality:**
- Attack cost: Only transaction gas fees (same as normal organization creation)
- Impact: Permanent bricking of organization functionality
- High impact-to-cost ratio makes this economically viable for griefing attacks

The likelihood is **HIGH** due to public accessibility, trivial execution, and minimal cost.

## Recommendation

Add address validation in the `Validate` method to check that all addresses in the ProposerWhiteList contain non-empty ByteString values:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for each address in the whitelist
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

This ensures that only organizations with valid proposer addresses can be created.

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithInvalidAddresses_ShouldBrickOrganization()
{
    // Create organization with invalid (empty) addresses in whitelist
    var invalidAddress = new Address(); // Value = ByteString.Empty by default
    var createInput = new CreateOrganizationInput
    {
        TokenSymbol = "ELF",
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalRejectionThreshold = 0,
            MaximalAbstentionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { invalidAddress } // Empty ByteString address
        }
    };

    // Organization creation succeeds (validation only checks count > 0)
    var organizationAddress = await ReferendumContractStub.CreateOrganization.SendAsync(createInput);
    organizationAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Verify organization exists
    var organization = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress.Output);
    organization.OrganizationAddress.ShouldBe(organizationAddress.Output);

    // Attempt to create a proposal with a valid proposer address
    var validProposer = DefaultSender; // Has non-empty Value
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        Params = new TransferInput { To = User1Address, Symbol = "ELF", Amount = 100 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };

    // Proposal creation fails - proposer not in whitelist
    var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(proposalInput);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose");

    // Organization is permanently bricked - no way to update whitelist
    // ChangeOrganizationProposerWhiteList requires Context.Sender == organizationAddress
    // which can only happen during proposal execution, but no proposals can be created
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L207-219)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress = Context.ConvertVirtualAddressToContractAddressWithContractHashName(
            CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));

        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** protobuf/acs3.proto (L139-142)
```text
message ProposerWhiteList{
    // The address of the proposers
    repeated aelf.Address proposers = 1;
}
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```
