# Audit Report

## Title
Missing Signature and Mining Order Validation Allows Manipulation of Consensus Schedule

## Summary
The AEDPoS consensus contract accepts arbitrary `Signature` and `SupposedOrderOfNextRound` values from miners without validating their correctness. This allows malicious miners to manipulate their mining position in subsequent rounds, breaking the fairness guarantees of the consensus schedule.

## Finding Description

The AEDPoS consensus mechanism is designed to use cryptographic signatures to determine mining order for the next round. The expected honest flow calculates the signature as an XOR operation with previous round signatures [1](#0-0) , then derives the supposed order using modulo arithmetic [2](#0-1)  and [3](#0-2) .

However, the `ProcessUpdateValue` method directly assigns these values from the `UpdateValueInput` without any validation that they were correctly calculated [4](#0-3) . Additionally, the `TuneOrderInformation` field allows arbitrary modification of other miners' orders [5](#0-4) .

The validation system fails to catch this manipulation. The `UpdateValueValidationProvider` only checks that the signature field is non-empty, not that it was correctly calculated [6](#0-5) . The `NextRoundMiningOrderValidationProvider` only validates during `NextRound` behavior, not `UpdateValue` [7](#0-6) .

When the next round is generated, miners are ordered directly by their `FinalOrderOfNextRound` values [8](#0-7) , meaning the manipulated values control the actual mining schedule.

## Impact Explanation

This vulnerability critically undermines consensus integrity:

1. **Mining Position Manipulation**: A malicious miner can choose to always mine first or select any favorable position, enabling MEV extraction and transaction ordering advantages.

2. **Schedule Disruption**: Through `TuneOrderInformation`, attackers can manipulate other miners' positions, potentially creating denial-of-service conditions.

3. **Consensus Fairness Failure**: The randomness and fairness that signature-based ordering provides becomes meaningless when miners can choose arbitrary values.

4. **Reward Misallocation**: Mining position affects block production opportunities and associated rewards, so position manipulation directly impacts economic fairness.

This breaks fundamental consensus guarantees about unpredictable and fair miner scheduling.

## Likelihood Explanation

**High Likelihood** - The attack is practical and economically rational:

- **Entry Point**: `UpdateValue` is a public method callable by any miner [9](#0-8) 
- **Preconditions**: The attacker only needs to be a valid miner in the current miner list
- **Execution**: A malicious miner modifies their node to provide arbitrary signature and order values in the block extra data generation [10](#0-9)  instead of using the correct `ApplyNormalConsensusData` calculation
- **Cost**: Minimal (only transaction fees), while benefits include favorable mining positions and MEV opportunities

## Recommendation

Add validation to `UpdateValueValidationProvider` or `ProcessUpdateValue` to verify that:

1. `Signature` matches `previousRound.CalculateSignature(previousInValue)`
2. `SupposedOrderOfNextRound` equals `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. `TuneOrderInformation` modifications are legitimate (match conflict resolution logic in `ApplyNormalConsensusData`)

The validation should recalculate these values from the provided inputs and compare them to the claimed values, rejecting transactions where they don't match.

## Proof of Concept

A malicious miner would:

1. Modify their node's `GetConsensusExtraDataToPublishOutValue` method to skip calling `ApplyNormalConsensusData`
2. Manually set `minerInRound.Signature` to any non-empty hash value
3. Manually set `minerInRound.SupposedOrderOfNextRound` to 1 (to always mine first) or any desired position
4. Return this manipulated round data as block extra data
5. The generated `UpdateValue` transaction contains these manipulated values
6. `ProcessUpdateValue` accepts them without validation
7. The values are stored in state and used to generate the next round's mining order

The manipulation succeeds because no validation checks that `SupposedOrderOfNextRound` was correctly derived from `Signature`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-87)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
