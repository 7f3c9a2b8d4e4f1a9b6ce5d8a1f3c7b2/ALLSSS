# Audit Report

## Title
Duplicate FinalOrderOfNextRound Assignment Causes Consensus Failure Due to Incomplete Conflict Resolution

## Summary
The `ApplyNormalConsensusData` function's conflict resolution mechanism fails when all mining order positions are occupied, allowing duplicate `FinalOrderOfNextRound` values to be assigned to different miners. Combined with a validation bug that checks for duplicate miner objects instead of duplicate order values, this creates a critical consensus vulnerability causing non-deterministic next-round generation and blockchain halt.

## Finding Description

The vulnerability exists in the conflict resolution logic within `ApplyNormalConsensusData`. When a miner produces a block, their `supposedOrderOfNextRound` is calculated from the signature hash modulo the miner count. [1](#0-0) 

If this calculated value conflicts with another miner's existing `FinalOrderOfNextRound`, the system detects conflicts [2](#0-1)  and attempts to reassign the conflicted miner to a free position. [3](#0-2) 

**Critical Flaw:** The reassignment loop checks if any miner currently occupies each candidate position [4](#0-3) . When all positions (1 through `minersCount`) are occupied by distinct miners, the loop exhausts all candidates without finding a free position. The conflicted miner retains their original `FinalOrderOfNextRound` value, and then the current miner is unconditionally assigned the same value [5](#0-4) , creating duplicates.

**Why Existing Protections Fail:** The `NextRoundMiningOrderValidationProvider` has a critical bug. It calls `.Distinct()` on `MinerInRound` objects rather than on their `FinalOrderOfNextRound` values [6](#0-5) , effectively checking for duplicate miner objects (which is impossible) instead of duplicate order values. The validation always passes even when duplicates exist.

## Impact Explanation

**Consensus Integrity Breach:** When generating the next round, miners are ordered by their `FinalOrderOfNextRound` values. [7](#0-6) 

With duplicate values, the ordering becomes non-deterministic because `RealTimeMinersInformation` is a dictionary whose iteration order is not guaranteed across different nodes. When two miners share the same `FinalOrderOfNextRound`, different nodes may iterate them in different orders, causing `OrderBy` to produce inconsistent results based on the underlying dictionary's internal state.

Additionally, the logic for assigning orders to miners who missed their time slots depends on calculating available positions by excluding occupied `FinalOrderOfNextRound` values. [8](#0-7)  When duplicates exist, `ableOrders` will have fewer elements than expected, and certain positions will be entirely missing from the next round. Subsequent logic that searches for specific order positions will throw exceptions. [9](#0-8) 

**Concrete Harm:**
- **Blockchain Fork Risk**: Different nodes generate different next rounds due to non-deterministic ordering
- **Missing Position Exceptions**: Code attempting to find miner at position 1 or N throws when those positions don't exist
- **Network Partition**: Nodes cannot reach consensus on block production schedule
- **Complete System Halt**: Blockchain cannot proceed to next round

## Likelihood Explanation

**Trigger Path:** This vulnerability is triggered during normal block production when a miner produces an `UpdateValue` block. The function `GetConsensusExtraDataToPublishOutValue` calls `ApplyNormalConsensusData` as part of preparing consensus data. [10](#0-9) 

**Preconditions:**
1. All `minersCount` positions (1 through N) are occupied by distinct miners with set `FinalOrderOfNextRound` values
2. A miner produces a block whose signature hash modulo `minersCount` conflicts with an existing position
3. Occurs naturally after all miners have produced at least one block in a round

**Probability:** With N miners and uniformly distributed signature hashes, the collision probability is approximately 1/N per block. For N=21 miners (typical AElf configuration), this represents a ~4.8% probability per block. Due to the birthday paradox, such collisions become highly likely within a few rounds of normal operation. No malicious action is requiredâ€”this happens during routine consensus operations.

## Recommendation

**Fix 1: Complete the conflict resolution**
Modify the conflict resolution loop to ensure it always finds a position, even if it means using wrapped positions or maintaining a separate available positions list:

```csharp
var availableOrders = Enumerable.Range(1, minersCount)
    .Where(i => !RealTimeMinersInformation.Values.Any(m => m.FinalOrderOfNextRound == i))
    .ToList();

foreach (var orderConflictedMiner in conflicts)
{
    if (availableOrders.Any())
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = 
            availableOrders.First();
        availableOrders.RemoveAt(0);
    }
}
```

**Fix 2: Correct the validation**
Fix `NextRoundMiningOrderValidationProvider` to check for duplicate `FinalOrderOfNextRound` values, not duplicate objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract the value first
    .Distinct()
    .Count();
```

## Proof of Concept

```csharp
[Fact]
public void Test_DuplicateFinalOrderOfNextRound_CausesConsensuFailure()
{
    // Setup: Create round with 3 miners, all positions occupied
    var round = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation =
        {
            ["MinerA"] = new MinerInRound 
            { 
                Pubkey = "MinerA", 
                FinalOrderOfNextRound = 1,
                OutValue = Hash.FromString("A")
            },
            ["MinerB"] = new MinerInRound 
            { 
                Pubkey = "MinerB", 
                FinalOrderOfNextRound = 2,
                OutValue = Hash.FromString("B")
            },
            ["MinerC"] = new MinerInRound 
            { 
                Pubkey = "MinerC", 
                FinalOrderOfNextRound = 3,
                OutValue = Hash.FromString("C")
            }
        }
    };
    
    // MinerA produces another block with signature that collides with position 2
    var collisionSignature = Hash.FromRawBytes(new byte[] { 0, 0, 0, 2 }); // Hash % 3 = 2
    
    // Apply consensus data - this creates duplicate
    var updatedRound = round.ApplyNormalConsensusData(
        "MinerA", 
        Hash.FromString("prevIn"), 
        Hash.FromString("out"),
        collisionSignature
    );
    
    // Verify: MinerA now has FinalOrderOfNextRound = 2 (same as MinerB)
    Assert.Equal(2, updatedRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound);
    Assert.Equal(2, updatedRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound);
    
    // Verify: Validation incorrectly passes
    var validator = new NextRoundMiningOrderValidationProvider();
    var context = new ConsensusValidationContext { ProvidedRound = updatedRound };
    var result = validator.ValidateHeaderInformation(context);
    Assert.True(result.Success); // BUG: Should fail but passes
    
    // Verify: Next round generation becomes non-deterministic
    updatedRound.GenerateNextRoundInformation(
        TimestampHelper.GetUtcNow(),
        TimestampHelper.GetUtcNow(),
        out var nextRound
    );
    
    // Multiple executions may produce different orderings for MinerA and MinerB
    // Position 1 is missing entirely - accessing it throws exception
    Assert.Throws<InvalidOperationException>(() => 
        nextRound.RealTimeMinersInformation.Values.First(m => m.Order == 1)
    );
}
```

## Notes

The vulnerability affects the core consensus mechanism during normal operations. The combination of incomplete conflict resolution and broken validation creates a deterministic path to consensus failure. The issue is particularly severe because:

1. It requires no malicious behavior - happens during routine block production
2. The probability increases rapidly with more miners (birthday paradox)
3. Both the detection (validation) and prevention (conflict resolution) mechanisms are broken
4. The impact is catastrophic - complete blockchain halt

The fix requires addressing both the conflict resolution logic and the validation provider to maintain the critical invariant that each miner must have a unique `FinalOrderOfNextRound` value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L44-44)
```csharp
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-26)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-44)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
