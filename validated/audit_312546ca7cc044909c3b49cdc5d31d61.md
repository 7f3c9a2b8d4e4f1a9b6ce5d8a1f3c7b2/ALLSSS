# Audit Report

## Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
When a manager calls `CreateScheme` multiple times, the new scheme overwrites the previous one in the TokenHolder contract state, but existing user lock records persist with the old scheme's token symbol. Users cannot withdraw their locked tokens because the `Withdraw` function queries locked amounts using the new scheme's symbol with the old lock ID, returning zero balance and leaving original tokens permanently locked.

## Finding Description

The `CreateScheme` method directly overwrites the scheme stored without any validation to prevent duplicate calls or check for existing registrations. [1](#0-0) 

Each call to `CreateScheme` creates a new scheme in the underlying Profit contract because the scheme ID generation uses `createdSchemeCount` as the seed when no token is specified. [2](#0-1)  This means the Profit contract's "Already exists" check does not prevent multiple scheme creation since each call generates a different schemeId. [3](#0-2) 

The lock ID is generated deterministically based only on the manager address and user address, making it identical across different schemes with the same manager. [4](#0-3) 

During registration, tokens are locked with the scheme's symbol at that time. [5](#0-4)  The lock operation transfers tokens to a virtual address computed from the TokenHolder contract, user address, and lockId. [6](#0-5)  The lock ID mapping persists at state storage. [7](#0-6) 

When `Withdraw` is called, it retrieves the current scheme (which may have different parameters including a different symbol), then attempts to get the locked amount using the current scheme's symbol with the old lock ID. [8](#0-7) 

The `GetLockedAmount` method queries the balance for a specific symbol at the virtual address derived from the lock ID. [9](#0-8)  Since the tokens were locked under a different symbol (e.g., "ELF"), but the query uses the new symbol (e.g., "USDT"), it returns zero.

The unlock operation then unlocks zero tokens with the new symbol, leaving the original tokens locked forever at the virtual address. [10](#0-9)  The lock ID is removed from state, [11](#0-10)  but this does not help recover the original tokens.

Users cannot directly call `Unlock` on the MultiToken contract to recover funds because the virtual address computation requires Context.Sender to be the TokenHolder contract. [12](#0-11) 

## Impact Explanation

**HIGH Severity** - This vulnerability results in permanent, unrecoverable loss of user funds through normal contract operations:

1. **Direct Fund Loss**: Users lose access to all their locked tokens permanently. The tokens remain locked at a virtual address but cannot be accessed through any TokenHolder contract method.

2. **Multiple Victims**: All users who registered for the original scheme before it was overwritten are affected simultaneously.

3. **No Recovery Path**: While the lock ID is removed from state after calling `Withdraw`, the original tokens remain at the virtual address with the old symbol. There is no emergency unlock mechanism in the TokenHolder contract to recover these funds. Users cannot directly interact with the MultiToken contract to unlock because the virtual address derivation requires Context.Sender to be the TokenHolder contract itself.

4. **Large Amounts at Risk**: Token holder schemes are typically used for staking and profit distribution, meaning substantial amounts can be locked.

## Likelihood Explanation

**MEDIUM Likelihood** - The vulnerability can be triggered through straightforward operations:

1. **Reachable Entry Point**: The `CreateScheme` method is publicly accessible to any address without special authorization. [13](#0-12) 

2. **Simple Preconditions**: The manager only needs to call `CreateScheme` twice - no complex state manipulation required.

3. **Realistic Scenarios**:
   - **Accidental**: A manager might call `CreateScheme` again thinking it will update scheme parameters rather than understanding it overwrites the entire scheme
   - **Malicious**: A manager could intentionally lock user funds to prevent withdrawals, gaining time advantage in profit distribution

4. **Low Complexity**: Requires only two standard contract calls with no special privileges beyond being the scheme creator.

## Recommendation

Add validation to prevent scheme overwriting when users have already registered:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(existingScheme == null || existingScheme.SchemeId == null, 
        "Scheme already exists. Cannot create new scheme while users are registered.");
    
    // Rest of existing logic...
}
```

Alternatively, store the original token symbol with each lock record to ensure correct unlocking even if the scheme is modified.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwritingCausesPermanentTokenLock()
{
    // Step 1: Manager creates scheme with ELF symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // Step 2: User registers and locks 10,000 ELF tokens
    var lockAmount = 10000;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = lockAmount
    });
    
    var balanceBeforeOverwrite = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = Starter,
        Symbol = "ELF"
    })).Balance;
    
    // Step 3: Manager overwrites scheme with different symbol (USDT)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 1
    });
    
    // Advance time to satisfy minimum lock period
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(10));
    
    // Step 4: User attempts to withdraw
    await TokenHolderContractStub.Withdraw.SendAsync(Starter);
    
    // Step 5: Verify tokens are permanently locked - user balance unchanged
    var balanceAfterWithdraw = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = Starter,
        Symbol = "ELF"
    })).Balance;
    
    // User's ELF balance should have increased by lockAmount, but it doesn't
    balanceAfterWithdraw.ShouldBe(balanceBeforeOverwrite); // Still locked!
    
    // The locked tokens remain at the virtual address, permanently inaccessible
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L166-166)
```csharp
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-225)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L230-236)
```csharp
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L238-238)
```csharp
        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-60)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-235)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```
