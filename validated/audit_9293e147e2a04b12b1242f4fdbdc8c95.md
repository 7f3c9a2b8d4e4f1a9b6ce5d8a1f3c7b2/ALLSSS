# Audit Report

## Title
Missing Validation of Decrypted Secret Shares Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract accepts decrypted secret shares from miners without cryptographic validation, allowing malicious miners to submit arbitrary fake shares. These fake shares corrupt the reconstruction of `PreviousInValue` entries, which subsequently corrupt signature calculations and mining order determination, breaking consensus integrity.

## Finding Description

The vulnerability exists in the secret sharing mechanism used for InValue recovery when miners fail to self-reveal. The system has two distinct validation paths:

**Path 1 (Self-Revelation - Protected):** When a miner provides their own `PreviousInValue` directly, it is validated via `UpdateValueValidationProvider.ValidatePreviousInValue()` which checks that `HashHelper.ComputeFrom(previousInValue) == previousOutValue`. [1](#0-0) 

**Path 2 (Secret Sharing Reconstruction - Unprotected):** When other miners submit decrypted shares to reconstruct a miner's `PreviousInValue`, no validation occurs:

1. **Entry Point 1:** `UpdateLatestSecretPieces()` accepts and stores decrypted pieces without any validation of their cryptographic correctness. [2](#0-1) 

2. **Entry Point 2:** `PerformSecretSharing()` also stores decrypted pieces without validation, only checking that the target miner exists in the round. [3](#0-2) 

3. **Reconstruction:** `RevealSharedInValues()` uses `SecretSharingHelper.DecodeSecret()` to reconstruct the InValue from decrypted pieces and directly stores it as `PreviousInValue` without checking if the reconstructed value hashes to the miner's previous `OutValue`. [4](#0-3) 

The `SecretSharingHelper.DecodeSecret()` function performs pure Lagrange interpolation and will always produce output regardless of whether the input shares are valid or fake. [5](#0-4) 

**Critical Impact Path:** The fake `PreviousInValue` is subsequently used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks. [6](#0-5)  These signatures directly determine mining order in future rounds through `ApplyNormalConsensusData`, which calculates `supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1`. [7](#0-6) 

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability breaks the core security guarantee of the consensus mechanism:

1. **Signature Corruption:** Fake `PreviousInValue` entries result in incorrect signature calculations for miners who fail to produce blocks. These corrupted signatures are stored in the consensus state and directly affect mining order calculations.

2. **Mining Order Manipulation:** Since mining order is derived from `signature mod minersCount`, attackers can influence which miners produce blocks when, potentially enabling coordinated attacks, denial of service against specific honest miners, and manipulation of consensus timing.

3. **Single Attacker Sufficient:** Because Shamir's Secret Sharing reconstruction requires all decrypted pieces, a single malicious miner providing one fake decrypted piece will corrupt the entire reconstruction, producing an invalid `PreviousInValue`.

4. **Asymmetric Validation:** The system validates self-revealed `PreviousInValue` but not reconstructed ones, creating an exploitable gap in the security model.

## Likelihood Explanation

**HIGH Likelihood**

**Attacker Requirements:**
- Must be an active miner in the current round (checked by `PreCheck()` in `ProcessConsensusInformation`) [8](#0-7) 
- No special cryptographic capabilities needed beyond normal mining operations

**Attack Execution:**
1. During block production or via `UpdateValue` transaction, attacker submits fake `decrypted_pieces` for target miners
2. The contract stores these fake pieces without validation
3. When `RevealSharedInValues()` executes during the next round transition, it reconstructs fake `PreviousInValue` entries
4. These fake values corrupt signature calculations in `SupplyCurrentRoundInformation()`

**No Barriers:**
- No validation checks exist to prevent the attack
- Detection is difficult since fake shares appear as valid byte arrays on-chain
- Cost is only normal transaction fees

## Recommendation

Add validation in `RevealSharedInValues()` to verify that the reconstructed InValue hashes to the miner's previous OutValue:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate reconstructed InValue against previous OutValue
if (previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue != null)
{
    var expectedOutValue = previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
    if (HashHelper.ComputeFrom(revealedInValue.Value.ToByteArray()) != expectedOutValue)
    {
        Context.LogDebug(() => $"Invalid reconstructed InValue for {publicKeyOfAnotherMiner}");
        continue; // Skip this miner if reconstruction is invalid
    }
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures parity between Path 1 (self-revelation) and Path 2 (reconstruction) validation.

## Proof of Concept

A proof of concept would involve:
1. Setting up a test environment with multiple miners
2. Having one miner submit fake `DecryptedPieces` for another miner via `UpdateValue` or block production
3. Observing that `RevealSharedInValues` accepts the fake pieces and reconstructs an invalid `PreviousInValue`
4. Verifying that this corrupted value is used in signature calculation, affecting mining order

The test would demonstrate that the hash of the reconstructed value does not equal the previous `OutValue`, yet the contract accepts it anyway.

**Notes**

This vulnerability is particularly severe because it undermines the entire purpose of the secret sharing mechanism, which is to provide fault-tolerant recovery of InValues. The asymmetry in validation between self-revelation and reconstruction creates an exploitable weakness that allows any single malicious miner to corrupt the consensus state for other miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L189-199)
```csharp
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
