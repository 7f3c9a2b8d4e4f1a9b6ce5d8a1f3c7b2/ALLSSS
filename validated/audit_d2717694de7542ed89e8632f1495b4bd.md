# Audit Report

## Title
Missing FinalOrderOfNextRound Validation Enables Consensus DoS via UpdateValue Manipulation

## Summary
A critical vulnerability exists in the AEDPoS consensus validation flow where `FinalOrderOfNextRound` values are not validated during UpdateValue block processing. A malicious miner can inject invalid order values (e.g., 0) for other miners, corrupting the consensus state and causing a permanent deadlock when the blockchain attempts to transition to the next round.

## Finding Description

The vulnerability stems from missing validation of `FinalOrderOfNextRound` values at two critical points in the UpdateValue execution path:

**1. During Validation - Unvalidated Recovery:**
The `RecoverFromUpdateValue` method blindly copies `FinalOrderOfNextRound` values from the attacker-controlled consensus header without any validation. [1](#0-0) 

**2. During Execution - Unvalidated Application:**
The `ProcessUpdateValue` method applies `TuneOrderInformation` values directly to the round state without validation. [2](#0-1) 

**Why Existing Protections Fail:**

The UpdateValue validation flow uses multiple validators, but crucially, NONE check `FinalOrderOfNextRound` values: [3](#0-2) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` that DOES check order validity is only applied for NextRound behavior, NOT for UpdateValue: [5](#0-4) 

**Attack Execution Path:**

1. Malicious miner modifies node software to inject `FinalOrderOfNextRound=0` for other miners in the consensus header Round
2. During validation (line 47 of AEDPoSContract_Validation.cs), `RecoverFromUpdateValue` copies these invalid values to baseRound
3. No validator detects that 0 is invalid (valid range is 1 to minersCount)
4. During execution, `ProcessUpdateValue` applies the corrupted values via `TuneOrderInformation`
5. Corrupted state is persisted with miners having `FinalOrderOfNextRound=0`
6. When `GenerateNextRoundInformation` is called for the next round, miners are ordered by their corrupted `FinalOrderOfNextRound` values: [6](#0-5) 

7. All miners with `FinalOrderOfNextRound=0` are assigned `Order=0` in the next round
8. The `BreakContinuousMining` method then calls `.First(i => i.Order == 1)` which throws an `InvalidOperationException` because no miner has Order=1: [7](#0-6) 

9. NextRound transaction fails, blockchain cannot progress

**Why the Attack Works:**

Miners construct consensus headers containing Round information. A malicious miner can include arbitrary `FinalOrderOfNextRound` values in the simplified Round that gets included in their block header. The consensus header construction is controlled by the block producer: [8](#0-7) 

Valid `FinalOrderOfNextRound` values are calculated during honest execution via `ApplyNormalConsensusData`: [9](#0-8) 

However, a malicious miner can bypass this calculation and inject arbitrary values directly into the consensus header, which are then blindly accepted during recovery and execution.

## Impact Explanation

**Critical Severity - Complete Consensus Failure:**

- **Consensus Deadlock:** The blockchain becomes permanently unable to transition to the next round, halting all block production
- **Network-Wide DoS:** All consensus operations are blocked; no new transactions can be confirmed
- **Permanent State Corruption:** The round state is corrupted with invalid order assignments that persist across the network
- **No Automatic Recovery:** There is no built-in mechanism to recover from this state; manual intervention or a hard fork would be required
- **Total Network Impact:** All users, dApps, contracts, and miners are affected; the entire blockchain becomes non-operational

This breaks the fundamental consensus guarantee that the network can continuously produce blocks and process transactions.

## Likelihood Explanation

**High Likelihood:**

- **Attacker Requirements:** Must be a legitimate elected miner (achievable through election/staking)
- **Technical Complexity:** Medium - requires modifying node software to inject malicious consensus data, but the modification itself is straightforward
- **Cost:** Moderate - requires obtaining miner status through election/staking, but the impact (complete network DoS) far exceeds the cost
- **Detection:** Attack is detectable on-chain (corrupted `FinalOrderOfNextRound` values are visible in state), but damage occurs before detection is actionable
- **Execution:** A single malicious UpdateValue block is sufficient to corrupt the state
- **Barriers:** No cryptographic or protocol-level barriers prevent the attack once miner status is obtained

For a motivated attacker seeking to DoS the entire network, this vulnerability provides a guaranteed, high-impact attack vector with moderate entry cost.

## Recommendation

Add validation for `FinalOrderOfNextRound` values in both the recovery and execution paths:

**1. Add validation in `RecoverFromUpdateValue`:**
```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    var minersCount = RealTimeMinersInformation.Count;
    // Validate FinalOrderOfNextRound is in valid range [1, minersCount]
    if (information.Value.FinalOrderOfNextRound != 0 && 
        (information.Value.FinalOrderOfNextRound < 1 || 
         information.Value.FinalOrderOfNextRound > minersCount))
    {
        // Skip invalid values or reject the block
        continue;
    }
    
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

**2. Add validation in `ProcessUpdateValue`:**
```csharp
var minersCount = currentRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate tuneOrder.Value is in valid range [1, minersCount]
    if (tuneOrder.Value < 1 || tuneOrder.Value > minersCount)
    {
        Assert(false, $"Invalid FinalOrderOfNextRound: {tuneOrder.Value}");
    }
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**3. Consider adding a dedicated validator:**
Create an `UpdateValueOrderValidationProvider` that validates `FinalOrderOfNextRound` values in the provided round are within valid bounds before allowing recovery/execution.

## Proof of Concept

```csharp
// This test demonstrates the vulnerability by simulating a malicious UpdateValue
[Fact]
public async Task MaliciousUpdateValue_CorruptsConsensusState_CausesNextRoundFailure()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensusAsync(miners);
    
    // Step 1: Malicious miner creates UpdateValue with FinalOrderOfNextRound=0 for all other miners
    var maliciousMiner = miners[0];
    var maliciousUpdateValue = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("signature"),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            // Inject FinalOrderOfNextRound=0 for all other miners
            { miners[1].PublicKey.ToHex(), 0 },
            { miners[2].PublicKey.ToHex(), 0 },
            { miners[3].PublicKey.ToHex(), 0 },
            { miners[4].PublicKey.ToHex(), 0 }
        },
        // ... other required fields
    };
    
    // Step 2: Execute malicious UpdateValue - should pass validation (no FinalOrderOfNextRound check)
    var updateResult = await ConsensusContract.UpdateValue.SendAsync(maliciousUpdateValue);
    updateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Verify state is corrupted
    var corruptedRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.RealTimeMinersInformation[miners[1].PublicKey.ToHex()].FinalOrderOfNextRound.ShouldBe(0);
    corruptedRound.RealTimeMinersInformation[miners[2].PublicKey.ToHex()].FinalOrderOfNextRound.ShouldBe(0);
    
    // Step 4: Attempt NextRound - should fail due to invalid Order assignments
    var nextRoundInput = GenerateNextRoundInput(corruptedRound);
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusContract.NextRound.SendAsync(nextRoundInput);
    });
    
    // Verify failure: InvalidOperationException from .First(i => i.Order == 1) when no miner has Order=1
    exception.Message.ShouldContain("Sequence contains no matching element");
    
    // Step 5: Verify consensus is deadlocked - no further rounds can be produced
    var finalRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    finalRound.RoundNumber.ShouldBe(corruptedRound.RoundNumber); // Stuck at corrupted round
}
```

## Notes

This vulnerability fundamentally breaks the consensus safety guarantee by allowing a single malicious miner to permanently halt the blockchain. The attack is particularly severe because:

1. **No recovery mechanism exists** - the corrupted state persists indefinitely
2. **Single point of failure** - one malicious UpdateValue block is sufficient
3. **Wide attack surface** - any miner can execute the attack during their time slot
4. **Guaranteed impact** - the attack deterministically causes consensus failure

The fix requires adding range validation for `FinalOrderOfNextRound` values at both the recovery and execution stages to ensure only valid orders (1 to minersCount) can be persisted to consensus state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-27)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
