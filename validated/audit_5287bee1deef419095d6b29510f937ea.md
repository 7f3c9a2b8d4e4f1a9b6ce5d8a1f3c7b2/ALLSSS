# Audit Report

## Title
Case-Insensitive Token Uniqueness Bypass via CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function implements only case-sensitive token existence checking, while normal token creation enforces case-insensitive uniqueness. This inconsistency allows attackers to create duplicate tokens with different casing (e.g., "ABC-0" and "abc-0") through cross-chain operations, violating the protocol's fundamental token uniqueness invariant.

## Finding Description

The MultiToken contract establishes case-insensitive token uniqueness through the `State.InsensitiveTokenExisting` mapping, which stores symbols in uppercase. [1](#0-0) 

Normal token creation via `Create` properly enforces this invariant by calling `CheckTokenExists`, which validates both case-sensitive and case-insensitive uniqueness. [2](#0-1) 

The `CheckTokenExists` function performs dual validation by checking both `GetTokenInfo(symbol)` for exact matches and `State.InsensitiveTokenExisting[symbol.ToUpper()]` for case-insensitive conflicts. [3](#0-2) 

However, `CrossChainCreateToken` bypasses this protection by using only a case-sensitive check that verifies `State.TokenInfos[tokenInfo.Symbol] == null` without checking the case-insensitive mapping. [4](#0-3) 

When the check passes, `RegisterTokenInfo` is called, which creates entries in both `State.TokenInfos` (with exact casing) and `State.InsensitiveTokenExisting` (uppercase). [5](#0-4) 

This results in two distinct tokens ("ABC-0" and "abc-0") with separate balance mappings, as `State.Balances[address][symbol]` uses the symbol string as the case-sensitive key. [6](#0-5) 

Since `GetTokenInfo` performs case-sensitive lookups, users querying for "ABC-0" will not find "abc-0" and vice versa. [7](#0-6) 

## Impact Explanation

**Protocol Invariant Violation**: The fundamental guarantee that token symbols are case-insensitively unique is broken. This is a core protocol invariant that all token operations depend on.

**State Fragmentation**: If token "ABC-0" exists, an attacker can create "abc-0" as a completely separate token with independent:
- Token information (issuer, owner, supply, decimals)
- Balance mappings for all addresses (since balances use exact symbol as key)
- Allowance mappings between addresses
- Lock whitelist configurations

**User Confusion**: Users and dApps expecting case-insensitive token identification will interact with the wrong token, as token lookups use exact case matching.

**NFT Collection Fragmentation**: For NFT collections, this creates parallel namespaces where "ABC-0" and "abc-0" can each issue their own items (ABC-1, ABC-2 vs abc-1, abc-2), fragmenting what should be a unified collection.

**Cross-Chain Consistency**: Multi-chain deployments will face inconsistencies when case variants exist on different chains, breaking cross-chain transfer assumptions and potentially leading to fund loss.

## Likelihood Explanation

**Entry Point**: `CrossChainCreateToken` is a public method accessible to any caller with valid cross-chain proof. [8](#0-7) 

**Prerequisites**:
1. Token contract must be registered in `State.CrossChainTransferWhiteList` for the source chain - this is standard in multi-chain setups [9](#0-8) 
2. Valid merkle proof and cross-chain verification required [10](#0-9) 
3. Attacker must be able to create token on source chain

**Feasibility**: In legitimate multi-chain environments where parent/side chains are properly registered (normal operation), the attack is straightforward once prerequisites are met. The attacker creates a case-variant token on Chain A, then submits `CrossChainCreateToken` on Chain B with valid proof.

**Assessment**: MEDIUM likelihood - feasible in multi-chain deployments where chains are legitimately connected and source chain allows token creation.

## Recommendation

Add case-insensitive validation to `CrossChainCreateToken` before registering the token. Replace the case-sensitive check with a call to `CheckTokenExists`:

```csharp
// In CrossChainCreateToken, replace line 506-508:
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    RegisterTokenInfo(tokenInfo);
    // ... event firing
}

// With:
CheckTokenExists(tokenInfo.Symbol);  // This performs both case-sensitive and case-insensitive checks
RegisterTokenInfo(tokenInfo);
// ... event firing
```

This ensures cross-chain token creation follows the same validation rules as normal token creation.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitiveBypass_Test()
{
    var sideChainId = await GenerateSideChainAsync();
    await RegisterMainChainTokenContractAddressOnSideChainAsync(sideChainId);
    
    // Create token "ELFTEST" on side chain first
    var createTransaction = await CreateTransactionForTokenCreation(
        SideChainTokenContractStub, 
        SideChainTestKit.DefaultAccount.Address, 
        "ELFTEST",  // Uppercase
        SideTokenContractAddress);
    var executedSet = await SideChainTestKit.MineAsync(new List<Transaction> { createTransaction });
    executedSet.TransactionResultMap[createTransaction.GetHash()].Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Now create "elftest" (lowercase) on main chain
    await BootMinerChangeRoundAsync(AEDPoSContractStub, true);
    var mainChainCreateTx = await CreateTransactionForTokenCreation(
        TokenContractStub, 
        DefaultAccount.Address, 
        "elftest",  // Lowercase - different casing
        TokenContractAddress);
    var mainExecutedSet = await MineAsync(new List<Transaction> { mainChainCreateTx });
    mainExecutedSet.TransactionResultMap[mainChainCreateTx.GetHash()].Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Validate and prepare cross-chain creation
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "elftest" });
    var validationTx = CreateTokenInfoValidationTransaction(tokenInfo, TokenContractStub);
    var validationSet = await MineAsync(new List<Transaction> { validationTx });
    var merklePath = GetTransactionMerklePathAndRoot(validationTx, out var blockRoot);
    await IndexMainChainTransactionAsync(validationSet.Height, blockRoot, blockRoot);
    
    // Cross-chain create "elftest" on side chain - should succeed (BUG!)
    var crossChainInput = new CrossChainCreateTokenInput
    {
        FromChainId = MainChainId,
        ParentChainHeight = validationSet.Height,
        TransactionBytes = validationTx.ToByteString(),
        MerklePath = merklePath
    };
    
    var result = await SideChainTokenContractStub.CrossChainCreateToken.SendAsync(crossChainInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify both "ELFTEST" and "elftest" exist on side chain
    var upperToken = await SideChainTokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ELFTEST" });
    var lowerToken = await SideChainTokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "elftest" });
    
    upperToken.ShouldNotBeNull();
    lowerToken.ShouldNotBeNull();
    upperToken.Symbol.ShouldBe("ELFTEST");
    lowerToken.Symbol.ShouldBe("elftest");
    // Both tokens exist with different casings - VULNERABILITY CONFIRMED!
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L19-19)
```csharp
    public MappedState<Address, string, long> Balances { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-87)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-478)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L488-488)
```csharp
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```
