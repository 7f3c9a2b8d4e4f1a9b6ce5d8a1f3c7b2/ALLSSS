# Audit Report

## Title
NextRound Validation Checks Wrong Round Allowing Consensus Manipulation

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method incorrectly validates the provided next round instead of the current round from state, causing validation to always pass and allowing any miner acting as extra block producer to manipulate the mining order for unfair advantage.

## Finding Description

**Root Cause - Validator Checks Wrong Round:**

The validation logic checks `providedRound` (the proposed next round from block header) instead of `baseRound` (the current round from state). The validator's comment states "Miners that have determined the order of the next round should be equal to miners that mined blocks during current round", but the code checks the provided next round: [1](#0-0) 

**Why baseRound is Not Modified for NextRound Behavior:**

In the validation setup, `RecoverFromUpdateValue` is only called for UpdateValue and TinyBlock behaviors, NOT for NextRound behavior. This means `baseRound` remains the unmodified current round from state: [2](#0-1) 

**Next Round Generation Leaves Critical Fields Unset:**

When `GenerateNextRoundInformation` creates a new round, it only sets specific fields (`Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, `MissedTimeSlots`). The `FinalOrderOfNextRound` and `OutValue` fields remain at their default values (0 and null): [3](#0-2) 

**Result - Validation Always Passes:**

For any newly generated next round (legitimate or malicious), both counts equal 0, so the check `0 != 0` evaluates to false and validation passes.

**Malicious Round Stored Directly:**

The provided round is converted via `ToRound()` which performs no validation of Order values: [4](#0-3) 

And stored directly to state: [5](#0-4) [6](#0-5) 

**Attack Execution:**

During normal mining, UpdateValue operations set FinalOrderOfNextRound based on cryptographic signatures: [7](#0-6) 

However, when transitioning rounds via NextRound, an attacker can provide arbitrary Order values that bypass validation and get stored directly to blockchain state, violating the cryptographic mining order determination that should use these FinalOrderOfNextRound values from the current round.

## Impact Explanation

**Severity: Critical - Consensus Integrity Compromise**

An attacker can manipulate mining order to:
1. Position themselves as first miner for maximum block production rewards
2. Assign unfavorable positions to competitors
3. Manipulate timing through arbitrary ExpectedMiningTime values
4. Bypass the signature-based randomness mechanism

This breaks the fundamental AEDPoS guarantee that mining order is determined cryptographically, resulting in unfair reward distribution and compromised consensus integrity affecting all network participants.

## Likelihood Explanation

**Probability: High**

**Attacker Requirements:**
- Must be in current miner set (standard for any block producer)
- Must be selected as extra block producer (happens routinely through round-robin)

**Attack Complexity: Low**

The attacker crafts a NextRoundInput with manipulated Order values and calls the public NextRound method: [8](#0-7) 

Every miner eventually becomes extra block producer, providing repeated attack opportunities. The malicious round passes validation and appears valid to all validators.

## Recommendation

Change the validator to check `baseRound` (current round from state) instead of `providedRound`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;  // Change from ProvidedRound to BaseRound
    var distinctCount = baseRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

This ensures the validator checks that all miners who mined during the current round (OutValue != null) also determined their next round position (FinalOrderOfNextRound > 0), preventing arbitrary order manipulation.

## Proof of Concept

A malicious miner acting as extra block producer can:
1. Generate a NextRoundInput with arbitrary Order values (e.g., setting their own Order = 1)
2. Call NextRound(maliciousInput)
3. Validation passes because providedRound has all FinalOrderOfNextRound = 0 and OutValue = null (0 != 0 is false)
4. Malicious round is stored to State.Rounds via AddRoundInformation
5. Next round proceeds with manipulated mining order favoring the attacker

The vulnerability is demonstrable by examining that the validator checks providedRound while the comment indicates it should check the current round (baseRound) to validate proper order determination during the current round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L11-21)
```csharp
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-36)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-248)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
