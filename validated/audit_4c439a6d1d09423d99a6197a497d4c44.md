# Audit Report

## Title
Period Boundary Validation Bypass Causes Permanent Share Dilution in Profit Distribution

## Summary
The `AddBeneficiary` and `FixProfitDetail` methods in the Profit contract fail to validate that `EndPeriod >= StartPeriod`, allowing profit details with inverted period boundaries to be created. When schemes use delayed distribution (`DelayDistributePeriodCount > 0`), these malformed details have their shares permanently added to `TotalShares` but are filtered out during profit claims, causing irreversible dilution of all legitimate beneficiaries' profits. The Treasury's CitizenWelfare scheme uses delayed distribution and is directly affected.

## Finding Description

The vulnerability exists in the period boundary validation logic of the Profit contract. The `AddBeneficiary` method validates that the user-provided `EndPeriod` is at least the current period [1](#0-0) , but then calculates `StartPeriod` by adding `DelayDistributePeriodCount` to the current period [2](#0-1) . There is no validation that the resulting `StartPeriod` is less than or equal to `EndPeriod`.

**Attack Scenario:**
1. A scheme has `CurrentPeriod = 100` and `DelayDistributePeriodCount = 50`
2. Manager calls `AddBeneficiary` with `EndPeriod = 120`
3. Validation passes: `120 >= 100` ✓
4. System calculates: `StartPeriod = 100 + 50 = 150`
5. Result: `StartPeriod (150) > EndPeriod (120)` - invalid state created

The shares from this malformed detail are immediately added to the scheme's `TotalShares` [3](#0-2) .

When `ClaimProfits` is called, malformed details are filtered out by the `availableDetails` check that requires `EndPeriod >= StartPeriod` when `LastProfitPeriod == 0` [4](#0-3) . Since these details never make it into `availableDetails`, they are never added to `profitableDetails` [5](#0-4) , and consequently never make it into `profitDetailsToRemove` [6](#0-5) . Only shares from `profitDetailsToRemove` are subtracted from `TotalShares` [7](#0-6) , leaving the malformed detail's shares permanently inflating the denominator.

The `FixProfitDetail` method has the same issue - it allows independent modification of `StartPeriod` and `EndPeriod` without validating their relationship [8](#0-7) .

## Impact Explanation

**Direct Economic Impact:**
When orphaned shares remain in `TotalShares`, all profit distributions use an inflated denominator [9](#0-8) . For example:
- Legitimate beneficiary Alice: 1,000 shares
- Malformed beneficiary Bob: 9,000 shares (StartPeriod > EndPeriod)
- `TotalShares = 10,000`, but only Alice can claim
- Distribution of 100,000 tokens: Alice receives `(1,000 / 10,000) × 100,000 = 10,000`
- Alice gets 10% instead of 100%, losing 90,000 tokens
- The 90,000 unclaimed tokens remain locked in period-specific virtual addresses indefinitely

**Affected Systems:**
The Treasury's CitizenWelfare scheme uses `DelayDistributePeriodCount = 1` [10](#0-9) , making it directly vulnerable. This affects citizen welfare distributions, a core economic mechanism of the AElf chain.

**Severity: HIGH**
- Causes permanent, irreversible fund lockup
- Affects core Treasury/Welfare economic distributions
- Impact compounds with each distribution period
- No recovery mechanism exists for locked funds

## Likelihood Explanation

**Unintentional Trigger:**
Scheme managers may not understand that `DelayDistributePeriodCount` affects the `StartPeriod` calculation. When adding beneficiaries with reasonable-looking end periods, they can inadvertently create invalid states. For a scheme with `DelayDistributePeriodCount = 50`, any `EndPeriod` less than `CurrentPeriod + 50` creates the vulnerability.

**Intentional Exploitation:**
A malicious or compromised scheme manager can deliberately:
1. Use `AddBeneficiary` to add beneficiaries with strategically chosen `EndPeriod` values to dilute legitimate beneficiaries
2. Use `FixProfitDetail` to modify existing valid profit details into invalid ones

**Feasibility: HIGH**
- Entry points are public methods callable by scheme managers [11](#0-10) 
- Precondition met: Treasury's Welfare scheme has `DelayDistributePeriodCount = 1`
- Single transaction execution
- Difficult to detect without deep state inspection
- No warning or error returned to indicate the invalid state creation

## Recommendation

Add validation to ensure `StartPeriod <= EndPeriod` in both `AddBeneficiary` and `FixProfitDetail` methods:

**For AddBeneficiary** (after line 188):
```csharp
var startPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
Assert(input.EndPeriod >= startPeriod, 
    $"Invalid end period. EndPeriod must be >= StartPeriod ({startPeriod})");
```

**For FixProfitDetail** (after line 301):
```csharp
Assert(newDetail.EndPeriod >= newDetail.StartPeriod,
    $"Invalid period boundaries. EndPeriod must be >= StartPeriod");
```

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_WithDelayedDistribution_CreatesInvalidPeriodBoundaries()
{
    // Setup: Create scheme with DelayDistributePeriodCount = 50, CurrentPeriod = 100
    var schemeId = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        DelayDistributePeriodCount = 50
    });
    
    // Advance to period 100
    for (int i = 0; i < 99; i++)
    {
        await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId.Output,
            Period = i + 1
        });
    }
    
    // Attack: Add beneficiary with EndPeriod = 120
    // This passes validation (120 >= 100) but creates StartPeriod = 150
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId.Output,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = UserAddress,
            Shares = 9000
        },
        EndPeriod = 120  // Less than CurrentPeriod + DelayDistributePeriodCount (150)
    });
    
    // Verify: TotalShares includes malformed detail's shares
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId.Output);
    Assert.Equal(9000, scheme.TotalShares);
    
    // Verify: ClaimProfits filters out the malformed detail
    // The shares remain in TotalShares but are never claimable
    await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId.Output,
        Beneficiary = UserAddress
    });
    
    // TotalShares still 9000, but detail was filtered out - permanent dilution
    scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId.Output);
    Assert.Equal(9000, scheme.TotalShares);  // Shares never removed
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L188-188)
```csharp
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L299-301)
```csharp
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L767-767)
```csharp
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L790-792)
```csharp
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```
