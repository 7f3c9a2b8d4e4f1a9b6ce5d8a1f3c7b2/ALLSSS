# Audit Report

## Title
Consensus Takeover via Unauthorized Miner Injection During NextTerm Transition

## Summary
The `NextTerm` method in the AEDPoS consensus contract fails to validate that the proposed miner list matches the Election contract's `GetVictories` result. A malicious current miner can construct a `NextTermInput` with arbitrary miners during term transitions, completely bypassing the election mechanism and taking over consensus.

## Finding Description

The vulnerability exists in the term transition validation flow where miner list legitimacy is never verified against election results.

**Root Cause:**

The `NextTermInput.Create()` method directly copies the `RealTimeMinersInformation` from any provided `Round` object without validation [1](#0-0) , allowing arbitrary miner lists to be injected.

**Validation Failures:**

1. **Before Execution:** The `ValidateBeforeExecution` method only adds `RoundTerminateValidationProvider` for NextTerm behavior [2](#0-1) , which only validates round and term number increments [3](#0-2)  but never checks miner list legitimacy.

2. **During Execution:** The `ProcessNextTerm` method directly updates the miner list from the input without any validation against `GetVictories` [4](#0-3) . The only authorization check is `PreCheck()`, which only verifies the sender is in the current OR previous round's miner list [5](#0-4) , not that the NEW miner list is valid.

3. **After Execution:** The `ValidateConsensusAfterExecution` compares the block header with the current state [6](#0-5) . However, by this point, the state has already been updated with the malicious miner list by `ProcessNextTerm`, so the validation passes as both contain the same malicious data.

**Why Existing Protections Fail:**

The Election contract's `GetVictories` method is only called in the honest code path during `GenerateFirstRoundOfNextTerm` [7](#0-6) , which is used by `GetConsensusExtraDataForNextTerm` [8](#0-7) . However, a malicious miner can bypass this entire flow by constructing their own `NextTermInput` and calling `NextTerm` directly [9](#0-8) , as the method is public and only requires basic authorization.

The `MiningPermissionValidationProvider` only validates that the sender is in the BaseRound (current round BEFORE execution) [10](#0-9) , not that the proposed new miner list is legitimate.

## Impact Explanation

**Critical Consensus Integrity Violation:**

This vulnerability completely breaks the core security guarantee of the blockchain: that miners are elected through voting and cannot unilaterally control consensus.

**Concrete Harms:**

1. **Complete Consensus Takeover:** A malicious miner can inject themselves and accomplices into the next term's miner list while excluding all legitimately elected miners, gaining total control over block production.

2. **Perpetual Control:** Once in control, malicious miners can repeat this attack indefinitely in subsequent term transitions, maintaining permanent control of the blockchain.

3. **Election Bypass:** The entire Election contract and voting mechanism becomes meaningless, as election results are never enforced during term transitions.

4. **Economic Exploitation:** 
   - Legitimate miners lose all block rewards and transaction fees
   - Attackers capture 100% of mining rewards
   - Control over treasury release enables fund theft [11](#0-10) 

5. **Transaction Censorship:** Malicious miners can censor any transactions, enabling double-spending attacks and targeted exclusion of users.

6. **Chain Reorganization Risk:** Complete control over consensus enables deep reorganizations and reversal of finalized transactions.

**Affected Parties:**
- All legitimately elected miners (excluded and lose rewards)
- All token holders (votes become meaningless)
- All blockchain users (subject to censorship and potential theft)
- Protocol integrity and trustworthiness

## Likelihood Explanation

**High Likelihood for Current Miners:**

**Attacker Prerequisites:**
- Must be a current miner (required to pass `PreCheck` authorization check)
- Must produce blocks during their scheduled time slot
- No additional privileges required beyond being in the current miner set

**Attack Complexity: Low**

The attack requires only:
1. Constructing a `Round` object with arbitrary miner public keys in `RealTimeMinersInformation`
2. Properly incrementing `TermNumber` and `RoundNumber` from current values
3. Creating `NextTermInput` via `NextTermInput.Create(maliciousRound, randomNumber)`
4. Submitting a `NextTerm` transaction during the term transition block
5. Including matching consensus extra data in the block header

**Feasibility:**
- **Timing:** Term transitions occur predictably at regular intervals (every `PeriodSeconds`)
- **Opportunity:** Each current miner has a 1/N chance of producing the term transition block (where N = current miner count)
- **Repeatability:** Attack can be attempted at every term transition until successful
- **Detection:** No automated detection exists; other nodes accept the malicious block as it passes all validation checks

**Success Rate:** 100% when the attacker is scheduled to produce the term transition block and properly constructs the input with correct round/term number increments.

**Practical Considerations:**
- Any determined malicious actor who gains miner status (through legitimate election or compromising a single miner) can execute this attack
- Once successful, maintaining control becomes trivial by repeating the attack
- Recovery requires manual intervention, potentially necessitating a hard fork

## Recommendation

Add explicit validation in the `NextTerm` execution flow to verify the proposed miner list matches the Election contract's `GetVictories` result:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL FIX: Validate miner list against election results
    if (State.IsMainChain.Value && TryToGetVictories(out var legitimateVictories))
    {
        var proposedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var electedMiners = legitimateVictories.Pubkeys.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        
        Assert(
            proposedMiners.Count == electedMiners.Count && 
            proposedMiners.SequenceEqual(electedMiners),
            "Proposed miner list does not match election results from GetVictories."
        );
    }
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of existing logic
}
```

Alternatively, validate in `ValidateBeforeExecution` before state is modified:

```csharp
// In RoundTerminateValidationProvider.ValidationForNextTerm
// Add miner list validation by calling Election contract
```

## Proof of Concept

**Attack Scenario:**

1. Attacker is currently a miner in term T
2. At the term transition point from term T to T+1, attacker is scheduled to produce the block
3. Instead of using honest consensus extra data generation, attacker:
   - Creates a `Round` with `RealTimeMinersInformation` containing only their own public keys (or colluding miners)
   - Sets `TermNumber = T + 1` and `RoundNumber = current + 1`
   - Creates `NextTermInput` from this malicious round
   - Generates transaction calling `NextTerm(maliciousInput)`
   - Includes this in their block with matching header extra data

**Validation Flow:**
- `ValidateBeforeExecution`: ✓ Passes (only checks round/term numbers)
- `PreCheck`: ✓ Passes (attacker is in current miner list)  
- `ProcessNextTerm`: ✓ Executes (updates state with malicious miners)
- `ValidateAfterExecution`: ✓ Passes (compares header with already-poisoned state)

**Result:** Attacker successfully replaces all legitimately elected miners with their chosen set, gaining complete control of consensus for term T+1 and all subsequent terms.

The absence of `GetVictories` validation at any point in the flow allows this attack to succeed despite the Election contract having the correct list of elected miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-210)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-242)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
