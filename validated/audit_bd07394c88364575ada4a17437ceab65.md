# Audit Report

## Title
Missing Authorization Check in ContributeProfits Allows Unauthorized Profit Contributions and Forced Auto-Distributions

## Summary
The `ContributeProfits()` function in both TokenHolderContract and ProfitContract lacks authorization validation, allowing any user to contribute profits to any scheme without the scheme manager's permission. When combined with the `AutoDistributeThreshold` mechanism, this enables attackers to force premature profit distributions, disrupting the scheme manager's intended distribution schedule.

## Finding Description

The vulnerability exists at two layers with an authorization pattern inconsistency:

**TokenHolderContract Authorization Bypass:**

In `ContributeProfits()`, the method accepts `input.SchemeManager` as a parameter and validates the scheme using this arbitrary input rather than verifying the caller's authorization. [1](#0-0) 

This contrasts sharply with `AddBeneficiary()`, which properly enforces authorization by calling `GetValidScheme(Context.Sender)`, ensuring only the scheme manager can modify beneficiary lists. [2](#0-1) 

The `GetValidScheme()` helper method only validates scheme existence without any authorization verification. [3](#0-2) 

**ProfitContract Layer:**

The underlying `ProfitContract.ContributeProfits()` similarly lacks authorization checks, only validating that the scheme exists. [4](#0-3) 

Meanwhile, `DistributeProfits()` has proper authorization requiring either the scheme manager or TokenHolder contract as the sender. [5](#0-4) 

**Auto-Distribution Authorization Bypass:**

When a scheme has `AutoDistributeThreshold` configured, the `RegisterForProfits()` function checks if the virtual address balance exceeds the threshold and automatically triggers distribution. [6](#0-5) 

The auto-distribution uses `State.ProfitContract.DistributeProfits.Send()`, making the TokenHolder contract the `Context.Sender` in the Profit contract. Since the authorization check explicitly allows the TokenHolder contract address, this bypasses the scheme manager authorization requirement, allowing any user to trigger distributions by:
1. Contributing profits via unauthorized `ContributeProfits()` calls
2. Calling `RegisterForProfits()` to trigger threshold-based auto-distribution
3. Circumventing the scheme manager's control over distribution timing

## Impact Explanation

**Authorization Invariant Violation**: The security model assumes only scheme managers control when profits are contributed and distributed. This vulnerability violates that core invariant by allowing unauthorized profit contributions and forced distributions.

**Loss of Scheme Manager Control**: The scheme manager loses control over:
- When profits are contributed to their scheme (any user can contribute at any time)
- When distributions occur if AutoDistributeThreshold is configured (can be forced by reaching threshold)
- Operational scheduling and coordination of profit management

**Operational Disruption**: Although attackers must spend their own tokens to contribute profits, they can disrupt scheme operations at relatively low cost (just enough to exceed the threshold). This affects schemes relying on AutoDistributeThreshold for coordinated automated management and time-sensitive distribution schedules.

**Severity Assessment**: Medium severity - while this doesn't directly steal funds or corrupt beneficiary shares (the actual profit distribution math remains correct), it represents a significant authorization bypass that undermines the scheme manager's operational control and allows unauthorized manipulation of distribution timing.

## Likelihood Explanation

**Highly Accessible Entry Point**: `ContributeProfits()` is a public method without access restrictions, callable by any address on the network.

**Minimal Attack Prerequisites**:
- Tokens of the target scheme's symbol (widely available)
- Standard token approval for the TokenHolder contract
- Knowledge of the scheme manager address (publicly queryable on-chain)
- No special privileges or compromised keys required

**Straightforward Attack Execution**:
1. Query on-chain to identify schemes with AutoDistributeThreshold configured
2. Calculate contribution amount needed to reach or exceed threshold
3. Approve TokenHolder contract for token transfer
4. Call `ContributeProfits()` with the target scheme manager's address
5. Call `RegisterForProfits()` to trigger automatic distribution

**Confirmed Test Coverage Gap**: The test suite validates authorization for `DistributeProfits_Without_Authority_Test` [7](#0-6)  but contains no corresponding authorization validation test for `ContributeProfits()`. The existing `ContributeProfitsTest` only verifies functional success without testing unauthorized access scenarios. [8](#0-7) 

This test gap confirms the authorization control was not validated during development, making the vulnerability highly likely to be exploitable in production.

## Recommendation

Implement consistent authorization validation in `ContributeProfits()` to match the pattern used in other scheme management methods:

**TokenHolderContract.ContributeProfits()** should verify that `Context.Sender` matches the scheme manager:
```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    // Validate caller is the scheme manager
    var scheme = GetValidScheme(Context.Sender);
    Assert(scheme.SchemeId == GetValidScheme(input.SchemeManager).SchemeId, 
        "Only scheme manager can contribute profits.");
    
    // ... rest of implementation
}
```

**ProfitContract.ContributeProfits()** should add explicit authorization:
```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    
    // Add authorization check
    Assert(Context.Sender == scheme.Manager || Context.Sender ==
        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
        "Only manager or token holder contract can contribute profits.");
    
    // ... rest of implementation
}
```

**Add comprehensive test coverage** for unauthorized contribution attempts to prevent regression.

## Proof of Concept

```csharp
[Fact]
public async Task ContributeProfits_Without_Authorization_Should_Fail()
{
    // Scheme creator (Starter) creates a scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = { { "ELF", 10000 } }
    });

    // Unauthorized user attempts to contribute profits to Starter's scheme
    var unauthorizedUser = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, 
        UserKeyPairs.First());
    
    // This should fail but currently succeeds - demonstrating the vulnerability
    var result = await unauthorizedUser.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter, // Unauthorized user contributing to someone else's scheme
        Symbol = "ELF",
        Amount = 5000
    });
    
    // VULNERABILITY: This transaction succeeds when it should fail
    // The unauthorized user successfully contributed profits to Starter's scheme
    // Expected: Transaction should revert with "Only manager can contribute profits"
    // Actual: Transaction succeeds, allowing unauthorized profit contribution
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Only manager can contribute profits");
}
```

This test demonstrates that any user can contribute profits to any scheme, regardless of whether they are the scheme manager, violating the expected authorization model.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-39)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-102)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L179-206)
```csharp
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-428)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-666)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L62-87)
```csharp
    public async Task ContributeProfitsTest()
    {
        await CreateTokenHolderProfitSchemeTest();

        var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);

        {
            var originScheme = await ProfitContractStub.GetScheme.CallAsync(tokenHolderProfitScheme.SchemeId);
            originScheme.Manager.ShouldBe(Starter);
            originScheme.CurrentPeriod.ShouldBe(1);
            originScheme.TotalShares.ShouldBe(0);

            var generalLedgerBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = originScheme.VirtualAddress,
                Symbol = "ELF"
            })).Balance;
            generalLedgerBalance.ShouldBe(1);
        }

        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 9999
        });
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L288-288)
```csharp
    public async Task DistributeProfits_Without_Authority_Test()
```
