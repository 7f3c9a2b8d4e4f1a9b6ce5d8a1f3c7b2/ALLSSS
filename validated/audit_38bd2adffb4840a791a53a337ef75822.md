# Audit Report

## Title
Missing LIB Height Validation in NextTerm Allows Consensus State Corruption

## Summary
The `NextTerm` transaction validation omits `LibInformationValidationProvider`, allowing a malicious miner to inject negative or decreasing `ConfirmedIrreversibleBlockHeight` values that permanently corrupt consensus state and propagate through all future rounds.

## Finding Description

The AEDPoS consensus contract applies different validation providers based on consensus behavior type. A critical inconsistency exists where `LibInformationValidationProvider` is applied to `UpdateValue` behavior but completely omitted for `NextTerm` behavior.

**Validation Inconsistency:**

For `UpdateValue` behavior, the validation correctly includes LIB height checks: [1](#0-0) 

However, for `NextTerm` behavior, only round/term number validation is applied: [2](#0-1) 

The `RoundTerminateValidationProvider` validates only round and term number increments, ignoring LIB height fields entirely: [3](#0-2) 

The missing `LibInformationValidationProvider` would prevent LIB height from decreasing: [4](#0-3) 

**Attack Execution:**

1. A malicious miner crafts a `NextTermInput` with `ConfirmedIrreversibleBlockHeight = -1` (protobuf int64 allows negative values) [5](#0-4) 

2. During term transition, they submit this via the public `NextTerm` method: [6](#0-5) 

3. The malicious input converts directly to a `Round` object with all fields preserved: [7](#0-6) 

4. `ProcessNextTerm` stores this corrupted Round directly to state without sanitization: [8](#0-7) 

5. Storage occurs with no validation: [9](#0-8) 

**Propagation Mechanism:**

The corrupted value propagates indefinitely because `GenerateFirstRoundOfNextTerm` unconditionally copies the LIB height: [10](#0-9) 

And also via the `MinerList.GenerateFirstRoundOfNewTerm` overload: [11](#0-10) 

## Impact Explanation

**Critical Consensus Invariant Violation:**

The `ConfirmedIrreversibleBlockHeight` represents the Last Irreversible Block (LIB) - the highest block height guaranteed to never be reverted. A negative value violates this fundamental blockchain invariant with cascading effects:

1. **Broken Finality Guarantees**: Systems relying on LIB for finality (cross-chain bridges, block explorers, light clients) receive invalid data that could cause integer underflows, validation bypasses, or complete service failure.

2. **Permanent State Corruption**: Once stored in `State.Rounds`, the corrupted value persists indefinitely and propagates to every subsequent round and term through the copy operations in round generation logic.

3. **No Automatic Recovery**: Unlike transient errors that self-correct, this requires manual intervention (hard fork, state migration, or chain rollback) to remediate.

4. **Cross-Chain Bridge Failure**: Cross-chain contracts depend on `ConfirmedIrreversibleBlockHeight` to determine which blocks are safe to index. Negative values could completely halt cross-chain operations or enable double-spend attacks.

## Likelihood Explanation

**High Feasibility:**

- **Attack Prerequisites**: Attacker must be an active miner (one of ~20+ elected validators) and wait for their term transition slot (occurs every few days based on `PeriodSeconds` configuration)
- **Execution Complexity**: Single transaction with predictable validation bypass - no race conditions or timing dependencies required
- **Technical Barrier**: Requires running modified node software to craft malicious `NextTermInput`, but miners already run custom node configurations
- **Detection**: Attack is immediately visible in consensus state but damage is irreversible once executed

**Permission Model:**

The validation framework's existence proves the system does NOT blindly trust miners - `UpdateValue` transactions are validated for LIB monotonicity. The inconsistent application of this same validation to `NextTerm` creates an exploitable gap where the same fundamental invariant (LIB height cannot decrease) is unprotected.

## Recommendation

Add `LibInformationValidationProvider` to the `NextTerm` validation path:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

This ensures consistent LIB height validation across all consensus behaviors that modify the `ConfirmedIrreversibleBlockHeight` field.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextTerm_WithNegativeLIB_ShouldFailValidation()
{
    // Setup: Advance to term transition point
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.True(currentRound.ConfirmedIrreversibleBlockHeight > 0);
    
    // Create malicious NextTermInput with negative LIB height
    var maliciousInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        ConfirmedIrreversibleBlockHeight = -1, // MALICIOUS VALUE
        ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber,
        RealTimeMinersInformation = { currentRound.RealTimeMinersInformation },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Create consensus header information for validation
    var headerInfo = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(MinerKeyPair.PublicKey.ToHex()),
        Round = maliciousInput.ToRound(),
        Behaviour = AElfConsensusBehaviour.NextTerm
    };
    
    // Validate: Should fail but currently passes
    var validationResult = await ConsensusContract.ValidateConsensusBeforeExecution.CallAsync(
        headerInfo.ToBytesValue());
    
    // BUG: This assertion FAILS - validation incorrectly succeeds
    Assert.False(validationResult.Success); 
    Assert.Contains("lib", validationResult.Message.ToLower());
}
```

**Notes**

The vulnerability is confirmed through code analysis of the validation framework. The system explicitly validates LIB height for `UpdateValue` behavior, proving it recognizes this as a critical invariant. The omission of the same validation for `NextTerm` behavior creates a security gap that allows permanent consensus state corruption by any active miner during term transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-20)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
```

**File:** protobuf/aedpos_contract.proto (L497-498)
```text
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L47-53)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval, Timestamp currentBlockTime, Round currentRound)
    {
        var round = GenerateFirstRoundOfNewTerm(miningInterval, currentBlockTime, currentRound.RoundNumber,
            currentRound.TermNumber);
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        return round;
```
