# Audit Report

## Title
Unbounded Iteration Over AutoDistributeThreshold Causes DoS in RegisterForProfits

## Summary
An attacker can create a TokenHolder scheme with thousands of AutoDistributeThreshold entries, causing any subsequent RegisterForProfits call to exceed AElf's ExecutionCallThreshold of 15,000 and fail permanently with RuntimeCallThresholdExceededException.

## Finding Description

The vulnerability exists because CreateScheme accepts an unbounded AutoDistributeThreshold map without validation, and RegisterForProfits performs unbounded iteration over all entries, making multiple method calls per entry.

**CreateScheme has no size validation**: The function directly accepts and stores the AutoDistributeThreshold map from user input without checking the number of entries. [1](#0-0) 

**Protobuf defines unbounded map**: The AutoDistributeThreshold field is defined as an unbounded map<string, int64> in the protocol specification. [2](#0-1) 

**RegisterForProfits performs unbounded iteration**: During profit registration, a foreach loop iterates over all AutoDistributeThreshold entries without any size check, pagination, or circuit breaker. [3](#0-2) 

**Each iteration triggers cross-contract call**: Within the loop, each iteration performs a cross-contract call to TokenContract.GetBalance. [4](#0-3) 

**GetBalance invokes multiple internal methods**: The GetBalance public method calls GetActualTokenSymbol and then the private GetBalance helper. [5](#0-4) 

**Private GetBalance makes additional calls**: The helper method calls AssertValidInputAddress and GetActualTokenSymbol, adding more method invocations. [6](#0-5) 

**ExecutionObserver counts all method calls**: AElf's ExecutionObserver automatically injects CallCount() at the beginning of every method (including private methods) and throws RuntimeCallThresholdExceededException when the threshold is exceeded. [7](#0-6) 

**Attack is feasible within constraints**: With approximately 5-6 method calls per iteration, 3,000 entries would generate ~15,000-18,000 total calls (including pre-loop operations), exceeding the 15,000 threshold. The 128KB state size limit allows for 3,000-5,000 map entries (approximately 20-25 bytes per entry), making the attack completely feasible.

## Impact Explanation

This is a **Medium severity** DoS vulnerability with the following impacts:

**Permanent operational DoS**: Any scheme created with thousands of AutoDistributeThreshold entries becomes permanently unusable for new user registrations. The RegisterForProfits function will always fail with RuntimeCallThresholdExceededException, preventing users from joining the profit-sharing scheme.

**Limited scope**: The vulnerability only affects specific schemes created by attackers. It does not impact existing schemes with reasonable AutoDistributeThreshold sizes or other protocol functionality. Users can still interact with legitimate schemes.

**No direct fund loss**: This vulnerability does not result in theft or loss of funds. It only breaks the availability of the auto-distribute feature for affected schemes. Existing beneficiaries can still claim profits.

**Recovery requires new scheme**: The poisoned scheme cannot be fixed or migrated easily. Recovery requires creating an entirely new scheme, losing the existing configuration and potentially requiring coordination to migrate users.

The severity is Medium rather than High because it affects availability of specific schemes rather than causing fund loss or compromising the entire protocol's security.

## Likelihood Explanation

The likelihood of exploitation is **High**:

**No authorization required**: CreateScheme is a public function with no authorization checks - any address can create a scheme with malicious parameters. [8](#0-7) 

**Low attack cost**: The attack requires only a single CreateScheme transaction with standard gas fees. The attacker constructs a CreateTokenHolderProfitSchemeInput with a large AutoDistributeThreshold map containing 3,000+ entries.

**Guaranteed success**: The attack is deterministic and mathematically certain:
- 3,000 entries × ~23 bytes = ~69KB (well within 128KB state limit)
- 3,000 entries × 5 method calls = ~15,000 calls (exceeds threshold)
- Plus pre-loop overhead ensures threshold is exceeded

**No detection or prevention**: There are no runtime checks, validation logic, or monitoring systems that would detect or prevent creation of schemes with excessively large AutoDistributeThreshold maps.

**Permanent effect**: Once created, the malicious scheme persists in blockchain state indefinitely and remains permanently unusable for new registrations.

## Recommendation

Add validation in CreateScheme to limit the size of AutoDistributeThreshold:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add size validation
    Assert(input.AutoDistributeThreshold == null || 
           input.AutoDistributeThreshold.Count <= 100, 
           "AutoDistributeThreshold cannot exceed 100 entries.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    
    // ... rest of implementation
}
```

Additionally, consider implementing pagination or an early exit mechanism in RegisterForProfits to limit the number of iterations even if a large map exists in state.

## Proof of Concept

```csharp
[Fact]
public async Task RegisterForProfits_DoS_With_Large_AutoDistributeThreshold()
{
    // Attacker creates scheme with 3,000 AutoDistributeThreshold entries
    var maliciousThreshold = new Dictionary<string, long>();
    for (int i = 0; i < 3000; i++)
    {
        maliciousThreshold[$"TOKEN{i}"] = 1000000; // High threshold to prevent early break
    }
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = { maliciousThreshold }
    });
    
    // Victim attempts to register for profits
    var result = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            Amount = 100,
            SchemeManager = AttackerAddress
        });
    
    // Transaction fails with RuntimeCallThresholdExceededException
    result.TransactionResult.Error.ShouldContain("Contract call threshold");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-200)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }
```

**File:** protobuf/token_holder_contract.proto (L69-69)
```text
    map<string, int64> auto_distribute_threshold = 3;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L39-46)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var symbol = GetActualTokenSymbol(input.Symbol);
        return new GetBalanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Balance = GetBalance(input.Owner, symbol)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-27)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
    }
```
