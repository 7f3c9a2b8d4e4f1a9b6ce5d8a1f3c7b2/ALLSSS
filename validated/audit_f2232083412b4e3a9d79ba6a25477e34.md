# Audit Report

## Title
Quadratic Voting Cost Progression Broken for Locked Token Voting

## Summary
The quadratic voting implementation in the Vote contract fails to enforce quadratic cost progression when both `IsQuadratic` and `IsLockToken` flags are true. Each vote transaction generates a unique `VoteId` based on the cumulative `VotesAmount`, causing the `QuadraticVotesCountMap` to reset to zero for every vote. This results in a constant cost of `TicketCost * 1` per vote instead of the intended quadratically increasing cost (`TicketCost * 1, 2, 3...`), completely defeating the vote-buying resistance mechanism of quadratic voting.

## Finding Description

The vulnerability exists in the interaction between `VoteId` generation and quadratic vote counting when processing locked token votes.

**Root Cause:**

When `IsLockToken` is true, the `VoteId` is generated dynamically using the current cumulative `VotesAmount` as input to the hash function. [1](#0-0) 

After each vote, the `VotesAmount` increases by the vote amount. [2](#0-1) 

The quadratic cost calculation retrieves and increments a counter from `QuadraticVotesCountMap` using the `VoteId` as the key. [3](#0-2) 

Since each vote generates a different `VoteId` (due to changing `VotesAmount`), the map lookup always returns zero, resulting in `currentVotesCount = 1` for every vote.

**Execution Flow for a Voter Making 3 Votes:**

1. **First Vote**: `VotesAmount = 0` → `VoteId` = GenerateId(Self, 0) → `QuadraticVotesCountMap[VoteId₁] = 1` → Cost = `TicketCost * 1`
2. **Second Vote**: `VotesAmount = TicketCost` → `VoteId` = GenerateId(Self, TicketCost) → `QuadraticVotesCountMap[VoteId₂] = 1` → Cost = `TicketCost * 1` ⚠️
3. **Third Vote**: `VotesAmount = 2*TicketCost` → `VoteId` = GenerateId(Self, 2*TicketCost) → `QuadraticVotesCountMap[VoteId₃] = 1` → Cost = `TicketCost * 1` ⚠️

**Why Protections Fail:**

The `Register` method accepts both `IsQuadratic` and `IsLockToken` flags from user input without any validation preventing their combination. [4](#0-3) 

The validation method `AssertValidNewVotingItem` performs no checks on flag compatibility. [5](#0-4) 

The protocol definition allows both flags to be set simultaneously. [6](#0-5) 

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks the fundamental security guarantee of quadratic voting: preventing wealthy actors from cheaply dominating votes.

1. **Token Economics Manipulation**: Voters pay O(N) cost instead of O(N²) for N votes. For 100 votes with `TicketCost=1000`:
   - **Intended cost**: 1000 × (1+2+...+100) = **5,050,000 tokens**
   - **Actual cost**: 1000 × 100 = **100,000 tokens**
   - **Attacker savings**: 4,950,000 tokens (98% discount)

2. **Governance Integrity Compromise**: Any voting item created with both flags becomes vulnerable to cheap vote buying, completely nullifying the democratic properties quadratic voting is designed to provide. Wealthy actors can acquire disproportionate voting power at linear cost.

3. **Protocol Design Violation**: The feature is explicitly labeled as "quadratic" in the contract state and protobuf definitions [7](#0-6)  but provides no quadratic cost progression, misleading users and sponsors about the security properties.

**Affected Parties:**
- Honest voters who vote conservatively pay proportionally fair costs while attackers exploit the flaw
- Vote sponsors who create voting items expecting quadratic cost enforcement
- The overall governance system's integrity and fairness

## Likelihood Explanation

**Probability: VERY HIGH**

The vulnerability is immediately exploitable with no barriers:

1. **Public Access**: The `Register` method [8](#0-7)  and `Vote` method [9](#0-8)  are public. Any address can create vulnerable voting items and exploit them.

2. **Trivial Attack Complexity**: 
   - Step 1: Call `Register` with `IsQuadratic=true`, `IsLockToken=true`, and a low `TicketCost`
   - Step 2: Call `Vote` multiple times to acquire votes at constant cost
   
3. **No Preconditions**: The vulnerability works immediately with no special contract state, timing requirements, or prior setup needed.

4. **Low Detection Risk**: The exploit appears as normal voting activity. Without manually analyzing the `QuadraticVotesCountMap` entries for each unique `VoteId`, the constant costs are not apparent from on-chain events.

5. **Economic Incentive**: The cost savings are massive (up to 98% for large vote counts), providing extremely strong motivation for exploitation in any governance scenario with meaningful stakes.

## Recommendation

Add validation in the `Register` method to prevent the combination of `IsQuadratic` and `IsLockToken`:

```csharp
Assert(!(input.IsQuadratic && input.IsLockToken), 
    "Quadratic voting cannot be combined with token locking due to VoteId generation constraints.");
```

Alternatively, redesign the quadratic voting mechanism to track vote counts per voter address rather than per VoteId when `IsLockToken` is true:

```csharp
if (votingItem.IsQuadratic)
{
    var countKey = votingItem.IsLockToken 
        ? HashHelper.ConcatAndCompute(input.VotingItemId, HashHelper.ComputeFrom(Context.Sender))
        : input.VoteId;
    var currentVotesCount = State.QuadraticVotesCountMap[countKey].Add(1);
    State.QuadraticVotesCountMap[countKey] = currentVotesCount;
    amount = votingItem.TicketCost.Mul(currentVotesCount);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVotingBrokenWithLockedTokens()
{
    const long ticketCost = 1000;
    
    // Register voting item with both IsQuadratic and IsLockToken
    var registerResult = await VoteContractStub.Register.SendAsync(new VotingRegisterInput
    {
        IsQuadratic = true,
        IsLockToken = true,
        TicketCost = ticketCost,
        AcceptedCurrency = "ELF",
        TotalSnapshotNumber = 1,
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(1),
        Options = { "OptionA", "OptionB" }
    });
    
    var votingItemId = registerResult.Output;
    
    // Cast three votes - each should cost progressively more (1000, 2000, 3000)
    // but actually costs constant 1000 each due to the bug
    var vote1 = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0 // ignored in quadratic mode
    });
    
    var vote2 = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0
    });
    
    var vote3 = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0
    });
    
    // Check actual costs from events
    var cost1 = vote1.TransactionResult.Logs.First(l => l.Name == "Voted").Indexed[0]; // Should be 1000
    var cost2 = vote2.TransactionResult.Logs.First(l => l.Name == "Voted").Indexed[0]; // Should be 2000, but is 1000
    var cost3 = vote3.TransactionResult.Logs.First(l => l.Name == "Voted").Indexed[0]; // Should be 3000, but is 1000
    
    // Total should be 6000 (1000+2000+3000) but is actually 3000 (1000+1000+1000)
    var totalCost = cost1 + cost2 + cost3;
    Assert.Equal(3000, totalCost); // Bug: should be 6000
    Assert.NotEqual(6000, totalCost); // Proof of vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L42-51)
```csharp
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-102)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L179-179)
```csharp
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** protobuf/vote_contract.proto (L20-21)
```text
    rpc Register (VotingRegisterInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/vote_contract.proto (L24-25)
```text
    rpc Vote (VoteInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/vote_contract.proto (L94-103)
```text
    // Whether the vote will lock token.
    bool is_lock_token = 4;
    // The total number of snapshots of the vote.
    int64 total_snapshot_number = 5;
    // The list of options.
    repeated string options = 6;
    // Is quadratic voting.
    bool is_quadratic = 7;
    // Quadratic voting item ticket cost.
    int64 ticket_cost = 8;
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```
