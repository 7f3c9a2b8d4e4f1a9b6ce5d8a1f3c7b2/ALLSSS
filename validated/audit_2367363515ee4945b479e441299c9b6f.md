# Audit Report

## Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Allows Miners to Manipulate LIB Calculation

## Summary
The AEDPoS consensus contract fails to validate that `ImpliedIrreversibleBlockHeight` values provided in `UpdateValue` transactions equal `Context.CurrentHeight`. This allows authorized miners to submit arbitrary values that violate protocol invariants and affect Last Irreversible Block (LIB) finality calculations. The validation logic inadvertently masks this issue by overwriting transaction values with header values before comparison.

## Finding Description

The protocol specifies that `ImpliedIrreversibleBlockHeight` must equal the current block height when miners produce blocks. During honest consensus data generation, this is correctly enforced [1](#0-0) 

However, when `ProcessUpdateValue` processes miner-provided consensus information, it directly accepts whatever value the miner includes without validating it against `Context.CurrentHeight` [2](#0-1) 

The only validation performed is a monotonicity check in `LibInformationValidationProvider` that ensures values don't decrease from the miner's previous value [3](#0-2) 

This validation lacks any upper bound or equality check to ensure the value equals `Context.CurrentHeight`. A malicious miner can exploit the public `UpdateValue` method [4](#0-3)  to craft an `UpdateValueInput` with an arbitrary `ImpliedIrreversibleBlockHeight` value.

The validation gap exists because the after-execution validation uses `RecoverFromUpdateValue` [5](#0-4)  which overwrites the state round's values with header values [6](#0-5)  before comparing hashes. This effectively compares the header against itself rather than validating what was actually written to state.

These manipulated values are then used in LIB calculations [7](#0-6)  which retrieves sorted implied irreversible heights from miners and selects the element at position `(count-1)/3`.

## Impact Explanation

**Consensus Integrity Violation**: This vulnerability breaks a fundamental protocol invariant that `ImpliedIrreversibleBlockHeight` must equal `Context.CurrentHeight`. This represents a consensus integrity compromise because:

1. **Finality Manipulation**: While the Byzantine-tolerant design (selecting at position `(count-1)/3`) limits single-miner impact, multiple colluding miners below the 1/3 threshold can force incorrect LIB values that don't accurately reflect block irreversibility.

2. **Protocol Deviation**: Any deviation from protocol-specified behavior undermines the security guarantees and assumptions upon which the blockchain's finality mechanism depends. The LIB calculation reads from `State.Rounds` which contains the manipulated values [8](#0-7) 

3. **State Corruption**: The malicious value is persisted to state via `TryToUpdateRoundInformation` [9](#0-8)  and affects all subsequent LIB calculations.

## Likelihood Explanation

**High Likelihood**:
- **Direct Access**: Any authorized miner can call the public `UpdateValue` method with custom parameters
- **Low Barrier**: Requires only modifying node software to bypass honest consensus data generation and craft malicious `UpdateValueInput` with arbitrary values
- **No Economic Cost**: No additional cost beyond being an authorized miner (which requires staking, but that's a prerequisite, not an attack cost)
- **Weak Authorization**: The `PreCheck` only verifies the caller is in the current or previous miner list [10](#0-9)  but doesn't validate the input values
- **Validation Bypass**: The monotonicity check is easily bypassed by using any value ≥ previous value, and the after-execution validation fails to detect the discrepancy due to the `RecoverFromUpdateValue` overwrite pattern

## Recommendation

Add explicit validation in `ProcessUpdateValue` to ensure `ImpliedIrreversibleBlockHeight` equals `Context.CurrentHeight`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // Add validation for ImpliedIrreversibleBlockHeight
    Assert(updateValueInput.ImpliedIrreversibleBlockHeight == Context.CurrentHeight,
        "ImpliedIrreversibleBlockHeight must equal current block height.");
    
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

Alternatively, fix the after-execution validation to compare the actual state values against the header values without overwriting them first, or remove the reliance on transaction-provided values and always derive `ImpliedIrreversibleBlockHeight` from `Context.CurrentHeight` within the contract.

## Proof of Concept

A malicious miner can:
1. Generate normal block header with `ImpliedIrreversibleBlockHeight = Context.CurrentHeight` (to pass before-execution validation)
2. Craft a custom `UpdateValue` transaction with `ImpliedIrreversibleBlockHeight = Context.CurrentHeight + 1000` (arbitrary value ≥ previous)
3. Include both in the block
4. The transaction executes successfully and writes the arbitrary value to `State.Rounds[currentRoundNumber]`
5. Subsequent LIB calculations use this manipulated value, affecting chain finality

The vulnerability is confirmed by tracing that:
- The transaction value is written to state without validation [11](#0-10) 
- The validation logic overwrites before comparing [12](#0-11) 
- No check exists that the transaction input matches the header value

## Notes

This vulnerability specifically exploits the architectural separation between block header consensus data (validated) and transaction parameters (not validated against header). The `RecoverFromUpdateValue` pattern was likely intended to normalize data for comparison but inadvertently creates a blind spot where transaction inputs can differ from header values without detection. The fix should ensure transaction inputs are validated against `Context.CurrentHeight` directly, not just against previous values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```
