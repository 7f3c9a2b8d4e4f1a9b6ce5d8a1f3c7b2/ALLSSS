# Audit Report

## Title
Secret Sharing Information Permanently Stored On-Chain Enabling Retrospective InValue Recovery

## Summary
The AEDPoS consensus contract stores encrypted and decrypted secret sharing pieces in persistent blockchain storage but only removes them from block headers. This allows anyone to query historical round information via the public `GetRoundInformation` view method and recover miners' secret InValues using the stored decrypted pieces, completely undermining the secret sharing security mechanism designed to protect consensus randomness.

## Finding Description

The vulnerability exists due to a critical disconnect between what data is stored persistently versus what data is cleaned up:

**Storage Path:** When miners produce blocks, the `ProcessUpdateValue` method processes consensus updates. When secret sharing is enabled, it calls `PerformSecretSharing` [1](#0-0)  which adds encrypted_pieces and decrypted_pieces to the Round object's miner information [2](#0-1) . This Round object (containing all secret pieces) is then persisted to blockchain state via `TryToUpdateRoundInformation` [3](#0-2)  which stores it to `State.Rounds[round.RoundNumber]` [4](#0-3) .

**Deletion Path:** The `DeleteSecretSharingInformation()` method clears encrypted and decrypted pieces from Round objects [5](#0-4) . However, this method is ONLY called when generating consensus block extra data for headers with the condition `if (!isGeneratingTransactions)` [6](#0-5) , and it operates on a copy of the Round object being returned in the header - not the already-persisted state in `State.Rounds`.

**Exposure Path:** The public view method `GetRoundInformation` is marked with `option (aelf.is_view) = true` [7](#0-6)  and directly returns Round objects from `State.Rounds` [8](#0-7)  by accessing `State.Rounds[roundNumber]` [9](#0-8)  without any filtering of secret sharing information.

**Recovery Mechanism:** The contract itself demonstrates how to recover InValues from decrypted pieces using `SecretSharingHelper.DecodeSecret`, requiring only 2/3 threshold of miners' decrypted pieces [10](#0-9) . The protobuf definition confirms that `encrypted_pieces` and `decrypted_pieces` are stored as part of `MinerInRound` within the Round structure [11](#0-10) .

## Impact Explanation

This vulnerability has **HIGH severity** impact on consensus integrity:

1. **Secret Sharing Security Broken**: The entire purpose of the secret sharing mechanism is defeated. InValues are meant to remain secret until explicitly revealed by the protocol, but all decrypted pieces (which can reconstruct the InValue) are permanently stored on-chain in accessible storage.

2. **Retrospective Analysis**: Any party can reconstruct past InValues by querying historical rounds and using the publicly available recovery algorithm with the stored decrypted pieces. This enables analysis of all consensus randomness since deployment.

3. **Consensus Randomness Exposure**: InValues are used for random number generation in consensus through VRF mechanisms. The confidentiality property that secret sharing is designed to provide is completely bypassed, as anyone can recover InValues immediately rather than waiting for the protocol to reveal them.

4. **Protocol-Wide Exposure**: This affects all consensus rounds where secret sharing is enabled. Historical round data persists for 40,960 rounds [12](#0-11) , meaning the exposure window is very significant.

## Likelihood Explanation

The likelihood of exploitation is **VERY HIGH**:

1. **Zero Barrier Entry**: `GetRoundInformation` is a public view method with no authentication or permission checks. Any user or observer can call it.

2. **Trivial Execution**: Exploitation requires only three simple steps:
   - Query `GetRoundInformation(roundNumber)` for any past round
   - Extract `DecryptedPieces` from the returned Round object's miner information  
   - Apply the publicly available `SecretSharingHelper.DecodeSecret` algorithm with 2/3 threshold

3. **No Detection**: Querying view methods is a read-only operation that leaves no transaction trace on the blockchain, making exploitation completely undetectable.

4. **Zero Cost**: View methods are free to call and require no transaction fees or gas payments.

5. **Always Available**: The data persists in `State.Rounds` for 40,960 rounds before cleanup, providing an extremely wide window of exposure for recent consensus rounds.

## Recommendation

The fix requires cleaning up secret sharing information from persistent state, not just from header copies:

1. **Option 1 - Clean on Storage:** After persisting the Round to `State.Rounds` in `TryToUpdateRoundInformation`, immediately call a method to strip secret sharing information from the persistent copy.

2. **Option 2 - Never Store:** Modify `PerformSecretSharing` to avoid adding decrypted pieces to the Round object that gets persisted. Instead, store them in temporary memory or a separate state structure that is explicitly cleared after the round completes.

3. **Option 3 - Filter on Retrieval:** Modify `GetRoundInformation` to return a filtered copy of the Round object with secret sharing information removed before returning to callers.

The most secure approach is Option 1, ensuring persistent state never contains sensitive cryptographic material that should remain confidential.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task SecretSharingInformationExposedViaGetRoundInformation()
{
    // Setup: Enable secret sharing and advance through multiple rounds with secret sharing enabled
    await EnableSecretSharing();
    await AdvanceRoundsWithSecretSharing(5);
    
    // Attack: Query historical round information
    var roundNumber = await GetCurrentRoundNumber() - 2; // Query 2 rounds ago
    var roundInfo = await ConsensusStub.GetRoundInformation.CallAsync(new Int64Value { Value = roundNumber });
    
    // Verify: DecryptedPieces are exposed in the response
    var minerWithDecryptedPieces = roundInfo.RealTimeMinersInformation.Values.FirstOrDefault(m => m.DecryptedPieces.Count > 0);
    Assert.NotNull(minerWithDecryptedPieces);
    Assert.True(minerWithDecryptedPieces.DecryptedPieces.Count > 0);
    
    // Recover InValue using the exposed decrypted pieces
    var minersCount = roundInfo.RealTimeMinersInformation.Count;
    var minimumCount = minersCount * 2 / 3;
    
    var orders = minerWithDecryptedPieces.DecryptedPieces.Select((piece, index) => 
        roundInfo.RealTimeMinersInformation.Values.First(m => m.Pubkey == minerWithDecryptedPieces.DecryptedPieces.Keys.ToList()[index]).Order
    ).ToList();
    
    var sharedParts = minerWithDecryptedPieces.DecryptedPieces.Values.Select(p => p.ToByteArray()).ToList();
    
    // This would successfully recover the InValue, proving the vulnerability
    var recoveredSecret = SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount);
    var recoveredInValue = HashHelper.ComputeFrom(recoveredSecret);
    
    // The InValue has been recovered from publicly accessible data
    Assert.NotNull(recoveredInValue);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-256)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L66-70)
```csharp
    private bool TryToGetRoundInformation(long roundNumber, out Round round)
    {
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** protobuf/aedpos_contract.proto (L78-80)
```text
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/aedpos_contract.proto (L294-296)
```text
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L26-29)
```csharp
    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
