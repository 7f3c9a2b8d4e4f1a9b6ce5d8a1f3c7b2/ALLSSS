# Audit Report

## Title
Incorrect Threshold Check in Secret Sharing Reconstruction Defeats Byzantine Fault Tolerance

## Summary
The AEDPoS consensus contract's secret sharing reconstruction logic incorrectly requires 100% of miners to provide decrypted pieces before attempting reconstruction, instead of the mathematically sufficient 2/3 threshold defined by Shamir's Secret Sharing algorithm. This allows any single malicious validator to prevent forced revelation of their InValue by providing incomplete encrypted pieces, breaking the commit-reveal scheme's security guarantees and enabling manipulation of consensus randomness and mining order.

## Finding Description

The vulnerability exists in the `RevealSharedInValues` method where secret reconstruction is performed. The system correctly calculates a 2/3 threshold (`minimumCount`) [1](#0-0)  but then incorrectly validates that ALL miners (100%) have provided decrypted pieces before attempting reconstruction [2](#0-1) .

The secret reconstruction algorithm itself correctly uses the `minimumCount` threshold parameter [3](#0-2)  but this code is never reached when DecryptedPieces.Count < minersCount.

**Attack Execution Path:**

1. **Round N**: Malicious validator provides incomplete EncryptedPieces in their `UpdateValue` transaction (e.g., only encrypting for 14 out of 21 validators)
2. **Round N+1**: Only the 14 validators with encrypted pieces can decrypt and add to DecryptedPieces
3. **Round N+1**: When `RevealSharedInValues` executes [4](#0-3) , it checks if DecryptedPieces.Count (14) < minersCount (21) and skips reconstruction
4. **Result**: The malicious validator's PreviousInValue is never forcibly revealed through secret reconstruction

**Why Existing Protections Fail:**

1. **No EncryptedPieces completeness validation**: The `UpdateValueValidationProvider` does not validate that miners provide complete encrypted pieces [5](#0-4) 

2. **Hash.Empty explicitly allowed**: PreviousInValue is permitted to be Hash.Empty, bypassing forced revelation requirements [6](#0-5) 

3. **Storage without validation**: EncryptedPieces are stored directly without completeness checks [7](#0-6) 

4. **Evil miner detection insufficient**: The system only detects evil miners based on missed time slots (OutValue == null), not secret sharing non-participation [8](#0-7) 

5. **Optional revelation**: The code explicitly states "It is permissible for miners not publish their in values" [9](#0-8) , which is why secret sharing exists to force revelation.

## Impact Explanation

This vulnerability breaks critical consensus security guarantees with HIGH severity:

**1. Mining Order Manipulation**: The signature value (computed from InValue) determines mining order for the next round [10](#0-9) . The signature is calculated from InValue using XOR operations [11](#0-10)  and [12](#0-11) . Without forced revelation, a malicious validator can avoid verification of their signature computation, allowing them to manipulate their mining position.

**2. Randomness Manipulation**: The commit-reveal scheme requires miners to commit to an InValue (via OutValue hash) and later reveal it. The secret sharing mechanism exists specifically to force revelation even if a miner refuses to cooperate. By defeating this mechanism, miners can selectively choose whether to reveal based on whether the outcome benefits them.

**3. Byzantine Fault Tolerance Defeated**: Shamir's Secret Sharing is mathematically designed to tolerate up to 1/3 Byzantine (malicious) participants. The incorrect threshold check requiring 100% participation effectively reduces this tolerance to 0%, as a single malicious validator can prevent reconstruction.

**4. Consensus Fairness Compromised**: All network participants suffer from compromised consensus fairness, while the malicious validator gains unfair advantages in block production scheduling and associated rewards.

## Likelihood Explanation

The likelihood is **HIGH** due to the following factors:

**Attacker Capabilities**: Any validator in the active miner set can execute this attack. No special privileges beyond being an elected validator are required.

**Attack Complexity**: LOW
- The attacker simply provides incomplete EncryptedPieces in their UpdateValue transaction
- No complex cryptographic manipulation required
- No timing dependencies or race conditions
- The attack is undetectable at validation time since EncryptedPieces completeness is never checked

**Feasibility**: The attack is immediately executable when:
1. Attacker is an active validator (realistic for any elected miner)
2. Secret sharing is enabled (standard operational configuration)

**Detection Difficulty**: The attack is extremely difficult to detect because:
- Off-chain observers cannot distinguish between network-delayed pieces and deliberately withheld pieces
- No on-chain slashing mechanism exists for incomplete secret sharing participation
- Evil miner detection only tracks missed time slots, not secret sharing compliance

## Recommendation

Change line 36 in `AEDPoSContract_SecretSharing.cs` from:
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

To:
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This ensures the reconstruction attempts when the mathematically sufficient 2/3 threshold is met, restoring the Byzantine fault tolerance guarantees of Shamir's Secret Sharing.

Additionally, consider adding validation in `UpdateValueValidationProvider` to verify that `EncryptedPieces.Count >= minimumCount` at transaction submission time, preventing the attack proactively rather than relying solely on reconstruction.

## Proof of Concept

The vulnerability can be demonstrated by examining the code flow:

1. A miner calls `UpdateValue` with incomplete `EncryptedPieces` (e.g., 14 out of 21 entries)
2. The transaction passes validation because `UpdateValueValidationProvider` does not check `EncryptedPieces` completeness
3. `PerformSecretSharing` stores the incomplete pieces without validation
4. In the next round, only 14 miners can provide `DecryptedPieces`
5. When `RevealSharedInValues` is called, the check at line 36 evaluates `14 < 21` as true
6. The `continue` statement skips reconstruction, and the miner's `PreviousInValue` remains unrevealed
7. The miner successfully avoids forced revelation despite the secret sharing mechanism

The bug is objectively present in the code at the cited line, and the exploit path requires only standard validator operations with intentionally incomplete data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L290-290)
```csharp
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
