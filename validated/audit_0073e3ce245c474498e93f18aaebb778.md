# Audit Report

## Title
Unhandled KeyNotFoundException in IsCurrentMiner During Term Transitions Causes DoS of Critical Authorization Checks

## Summary
The `IsCurrentMiner` function contains a logic error that causes unhandled exceptions during term transitions. When `IsMinerListJustChanged = true`, the function skips key existence validation but then directly accesses the dictionary with pubkeys that may only exist in the previous round, throwing `KeyNotFoundException` and causing transaction failures for fee claims, cross-chain indexing, and other miner-authenticated operations.

## Finding Description

The vulnerability exists in the interaction between `ConvertAddressToPubkey` and `IsCurrentMiner` functions in the AEDPoS consensus contract.

**Root Cause:** The `ConvertAddressToPubkey` function combines miners from both current and previous rounds, meaning it can return a pubkey that exists only in the previous round's miner list. [1](#0-0) 

The `IsCurrentMiner(string pubkey)` function has a critical flaw: when `IsMinerListJustChanged = true` (set during term transitions), it skips the `ContainsKey` check. [2](#0-1) 

However, the function then directly accesses the dictionary without any guard, causing a `KeyNotFoundException` if the pubkey doesn't exist in the current round. [3](#0-2) 

During term transitions, `GenerateFirstRoundOfNewTerm` sets `IsMinerListJustChanged = true`. [4](#0-3) 

**Flawed Protection:** The special case check only handles `ExtraBlockProducerOfPreviousRound`, but doesn't protect against other removed miners attempting to access the system. [5](#0-4) 

**Attack Scenario:**
1. Term N has miners [A, B, C, D, E]
2. Term N+1 transitions with miners [A, B, C, F, G] (D and E removed)
3. `GenerateFirstRoundOfNewTerm` sets `IsMinerListJustChanged = true`
4. Removed miner D attempts to call `ClaimTransactionFees`
5. `ConvertAddressToPubkey(D's address)` returns D's pubkey (found in previous round)
6. `IsCurrentMiner` skips the `ContainsKey` check
7. Line 158 attempts to access `currentRound.RealTimeMinersInformation[D's pubkey]`
8. `KeyNotFoundException` thrown, transaction reverts

## Impact Explanation

This vulnerability causes **Denial of Service** during term transitions affecting multiple critical operations:

1. **Token Fee Claims**: The `ClaimTransactionFees` method uses `AssertSenderIsCurrentMiner()` which calls `IsCurrentMiner` to verify authorization. [6](#0-5) [7](#0-6) 

2. **Cross-Chain Indexing**: The `CheckCrossChainIndexingPermission` method directly calls `IsCurrentMiner`, blocking cross-chain operations. [8](#0-7) [9](#0-8) 

3. **Any authorization check** using `IsCurrentMiner` during the vulnerable window fails with unhandled exceptions.

**Quantified Impact**: All removed miners and anyone querying their status during the first round of each new term will trigger unhandled exceptions, disrupting protocol operations. While not causing fund loss, this creates operational disruption during each term transition, affecting fee distribution and cross-chain communication.

**Severity**: Medium - DoS of critical protocol operations during periodic term transitions.

## Likelihood Explanation

**Attacker Capabilities**: 
- Any user can trigger this by calling `IsCurrentMiner` with a removed miner's address during term transitions
- Removed miners legitimately attempting to claim fees will automatically trigger this

**Attack Complexity**: Low
- Requires only knowing an address from the previous miner list
- No special permissions needed
- Occurs naturally when removed miners attempt normal operations

**Feasibility Conditions**:
- Term transition must have occurred (happens periodically in AEDPoS)
- `IsMinerListJustChanged = true` (first round of new term)
- Address belongs to a miner removed in the transition (not the extra block producer)

**Probability**: Moderate to High - Term transitions with miner list changes happen regularly. The vulnerable state persists for the entire first round of each new term, and removed miners may legitimately attempt to claim fees or perform operations during this window.

## Recommendation

Add a `ContainsKey` check before dictionary access, regardless of `IsMinerListJustChanged` status:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

    // Always check if pubkey exists in current round
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // Only allow ExtraBlockProducerOfPreviousRound during transition window
        if (currentRound.IsMinerListJustChanged && 
            Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            return true;
        }
        return false;
    }

    // Rest of the existing logic...
    var miningInterval = currentRound.GetMiningInterval();
    var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
    // ... continue with time slot validation
}
```

Alternatively, modify `ConvertAddressToPubkey` to only return pubkeys that exist in the current round when called during term transitions.

## Proof of Concept

```csharp
[Fact]
public async Task IsCurrentMiner_ThrowsKeyNotFoundException_DuringTermTransition()
{
    // Setup: Create initial term with 5 miners
    var initialMiners = new[] { "minerA", "minerB", "minerC", "minerD", "minerE" };
    var initialAddresses = initialMiners.Select(m => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(m))).ToArray();
    
    // Transition to new term with only 3 miners (D and E removed)
    var newMiners = new[] { "minerA", "minerB", "minerC" };
    await GenerateNewTerm(newMiners);
    
    // Verify IsMinerListJustChanged is true
    var currentRound = await GetCurrentRound();
    Assert.True(currentRound.IsMinerListJustChanged);
    
    // Attempt to check if removed miner D is current miner
    // This should throw KeyNotFoundException instead of returning false
    var removedMinerAddress = initialAddresses[3]; // minerD
    
    // This call will throw unhandled KeyNotFoundException
    await Assert.ThrowsAsync<KeyNotFoundException>(async () => 
    {
        await AEDPoSContractStub.IsCurrentMiner.CallAsync(removedMinerAddress);
    });
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-158)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L869-869)
```csharp
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L905-905)
```csharp
        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```
