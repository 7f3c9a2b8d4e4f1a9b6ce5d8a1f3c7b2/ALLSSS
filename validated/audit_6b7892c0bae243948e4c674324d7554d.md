# Audit Report

## Title
Hex Case Mismatch in Pubkey Replacement Causes Miner Denial of Service

## Summary
The `RecordCandidateReplacement` method in the consensus contract accepts pubkey strings without normalizing hex case before storing them as dictionary keys. When a miner requests consensus commands, the system converts their pubkey bytes to lowercase hex, causing a lookup failure if the replacement was stored with non-lowercase characters. This prevents the affected miner from producing blocks.

## Finding Description

The vulnerability exists in the pubkey replacement flow where case-insensitive input validation combines with case-sensitive dictionary storage and lowercase lookup, creating a critical mismatch.

**Root Cause**: The consensus contract stores the new pubkey string directly without case normalization. [1](#0-0) 

**Entry Point**: Candidate admins call `ReplaceCandidatePubkey` which validates hex convertibility but not case format. [2](#0-1)  The validation uses `ByteArrayHelper.HexStringToByteArray()` which accepts both uppercase and lowercase hex characters via `Convert.ToByte()`. [3](#0-2) 

**Propagation**: The unchecked pubkey strings flow unchanged from the election contract to the consensus contract. [4](#0-3) 

**Failure Point**: When miners request consensus commands, their pubkey bytes are converted to lowercase hex using `ToHex()`. [5](#0-4)  The system then performs a case-sensitive dictionary lookup. [6](#0-5) 

**Case-Sensitive Lookup**: The `IsInMinerList` method uses case-sensitive string comparison. [7](#0-6) 

**Lowercase Conversion**: The `ToHex()` methods produce lowercase hex by adding 0x20 to convert 'A'-'F' to 'a'-'f'. [8](#0-7) 

**Initial Miners Convention**: All initial miners are stored with lowercase hex keys via `.ToHex()` conversion. [9](#0-8) 

## Impact Explanation

**Direct Harm:**
- The affected miner cannot retrieve valid consensus commands, completely blocking their block production capability
- Network consensus capacity is reduced by one miner per affected replacement
- The miner loses all block rewards during the outage period until remediation
- If multiple miners are affected simultaneously, network liveness and block production speed are degraded

**Affected Parties:**
- The miner whose pubkey was replaced with incorrect hex case loses consensus participation rights
- The blockchain network experiences reduced security from decreased active miner count
- All network users may experience slower block times and reduced throughput

**Severity Assessment:**
This is a **Medium severity** operational vulnerability because:
- No direct fund theft or permanent loss occurs
- Causes significant disruption to the consensus mechanism
- Can be remediated by calling `ReplaceCandidatePubkey` again with correct lowercase format
- Requires privileged candidate admin action, reducing attack surface
- Impact scales linearly with number of affected miners

## Likelihood Explanation

**Required Capabilities:**
- Must be a candidate admin with authorization to call `ReplaceCandidatePubkey`
- Must provide new pubkey in non-lowercase format (uppercase or mixed case)
- No sophisticated technical knowledge required beyond basic hex string manipulation

**Attack Complexity:**
- Very low: Single transaction with uppercase/mixed case hex string
- No timing windows, race conditions, or complex setup needed
- Deterministic outcome - always causes miner DoS when case mismatches occur

**Feasibility:**
- All test cases use `.ToHex()` producing lowercase, but this is a coding convention, not enforced validation [10](#0-9) 
- No contract-level enforcement of lowercase format exists
- Manual API calls, custom UI implementations, or programmatic interfaces could easily provide uppercase strings
- The validation accepts any valid hex string regardless of case

**Probability Assessment:**
- **Moderate probability**: Deviation from standard coding patterns but no validation prevents it
- More likely to be accidental (admin copy-paste error from external sources) than malicious
- Detection occurs immediately when affected miner fails to produce blocks
- Recovery requires another privileged admin transaction with correct format

## Recommendation

Add case normalization before storing pubkey strings in the consensus contract:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // Normalize to lowercase to match ToHex() behavior
    var normalizedNewPubkey = input.NewPubkey.ToLower();
    
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = normalizedNewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(normalizedNewPubkey, realTimeMinerInformation);
    
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = normalizedNewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = normalizedNewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Alternatively, add validation in the election contract to enforce lowercase format before sending to consensus contract.

## Proof of Concept

```csharp
[Fact]
public async Task HexCaseMismatch_Causes_MinerDoS_Test()
{
    // Setup: Create initial miner with lowercase pubkey
    var minerKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    
    await AnnounceElectionAsync(minerKeyPair, candidateAdminAddress);
    await InitializeElectionAsync();
    
    // Miner becomes active miner in current round
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var lowercasePubkey = minerKeyPair.PublicKey.ToHex(); // lowercase
    currentRound.RealTimeMinersInformation.Keys.ShouldContain(lowercasePubkey);
    
    // Admin replaces with UPPERCASE pubkey
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var uppercasePubkey = newKeyPair.PublicKey.ToHex().ToUpper(); // UPPERCASE
    
    var candidateAdminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = lowercasePubkey,
        NewPubkey = uppercasePubkey
    });
    
    // Verify dictionary has UPPERCASE key
    currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation.Keys.ShouldContain(uppercasePubkey);
    currentRound.RealTimeMinersInformation.Keys.ShouldNotContain(lowercasePubkey);
    
    // Miner tries to get consensus command with their actual pubkey bytes
    var minerStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ConsensusContractAddress, newKeyPair);
    var command = await minerStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(newKeyPair.PublicKey) });
    
    // Assertion: Miner receives InvalidConsensusCommand due to case mismatch
    command.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
    command.Hint.ShouldBe(ByteString.Empty); // No valid mining command
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-187)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L15-16)
```csharp
            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L19-19)
```csharp
        _processingBlockMinerPubkey = input.Value.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L24-28)
```csharp
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L16-17)
```csharp
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L40-41)
```csharp
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
```
