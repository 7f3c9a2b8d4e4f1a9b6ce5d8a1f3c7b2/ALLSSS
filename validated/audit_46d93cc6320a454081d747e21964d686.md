# Audit Report

## Title
Inconsistent Vote Counting Allows MinimalVoteThreshold Bypass via Member Removal

## Summary
The Association contract's vote threshold validation contains a critical inconsistency where individual vote type checks (approvals, rejections, abstentions) filter by current membership, but the total vote count for `MinimalVoteThreshold` includes votes from removed members. This allows proposals to satisfy participation requirements with fewer current-member votes than intended, undermining governance integrity.

## Finding Description

The vote counting logic in the Association contract has a fundamental inconsistency that violates governance threshold semantics. The `CheckEnoughVoteAndApprovals()` function filters approval votes by current membership but fails to filter the total vote count used for the `MinimalVoteThreshold` check. [1](#0-0) 

Specifically, line 49 correctly filters approvals using `.Count(organization.OrganizationMemberList.Contains)`, but lines 55-57 concatenate and count ALL votes without membership filtering. This inconsistency is also present in the rejection and abstention checks: [2](#0-1) 

The root cause is that members can be removed from an organization after they vote: [3](#0-2) 

When `RemoveMember()` is called, the member's address is removed from `OrganizationMemberList`, but their votes remain in the proposal's `Approvals`, `Rejections`, or `Abstentions` lists. There is no mechanism to invalidate or recount votes when membership changes occur.

The organization validation establishes that thresholds are semantically bound to current membership: [4](#0-3) 

Line 72 enforces `MinimalVoteThreshold <= organizationMemberCount`, establishing that vote thresholds must be achievable with current members. However, the unfiltered counting in `CheckEnoughVoteAndApprovals()` violates this semantic, allowing vote counts that effectively exceed the intended participation requirements.

**Exploit Scenario:**
1. Organization has 10 members with `MinimalVoteThreshold=8`
2. Target proposal receives 6 approval votes from current members + 2 approval votes from members who will be removed
3. Organization passes a separate proposal to remove the 2 members
4. Target proposal now has only 6 current-member votes, but the `MinimalVoteThreshold` check counts all 8 votes
5. If 6 approvals satisfy `MinimalApprovalThreshold`, the proposal can be released despite having insufficient current-member participation

The voting methods properly validate membership before accepting votes: [5](#0-4) 

But this front-end validation is bypassed by the temporal aspect of member removal occurring after votes are cast.

## Impact Explanation

**Severity: Medium**

The vulnerability has concrete impact on governance integrity:

1. **Participation Threshold Bypass**: Proposals can satisfy `MinimalVoteThreshold` requirements with fewer current-member votes than the threshold specifies. An organization configured to require 80% participation (8 out of 10 members) could have proposals pass with only 60% current-member participation if removed members' votes are counted.

2. **Strategic Manipulation**: Organizations can strategically remove dissenting voters after they vote. Since rejection/abstention checks filter by current membership, removed members' dissenting votes won't count toward `MaximalRejectionThreshold` or `MaximalAbstentionThreshold`, but their votes will still satisfy the `MinimalVoteThreshold` participation requirement.

3. **Semantic Violation**: The validation logic explicitly enforces that `MinimalVoteThreshold <= organizationMemberCount`, establishing that thresholds represent a count of current members. The unfiltered counting breaks this invariant, allowing total vote counts that can exceed the current membership size.

This affects all Association organizations using vote thresholds, impacting critical governance decisions for contract deployments, parameter changes, and treasury operations throughout the AElf ecosystem.

The severity is Medium (not High) because exploitation requires organization authority to execute `RemoveMember()`, which is a privileged operation. However, member changes are legitimate operations that organizations perform, making this vulnerability realistic and exploitable without requiring malicious intent.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is triggerable through standard contract operations without requiring special privileges beyond normal organization participation:

**Feasibility:**
- Organizations legitimately add and remove members as part of normal governance operations
- Multiple concurrent proposals are common in active organizations
- The timing window is large (between voting and proposal release)
- No detection mechanisms exist - the inconsistency occurs through normal contract operations

**Attack Complexity:** Moderate
1. Attacker needs ability to pass proposals in the organization (either as majority member or by compromising enough voting members)
2. Create target proposal that benefits the attacker
3. Collect votes on target proposal
4. Pass a separate proposal to remove specific voters (e.g., those who rejected or abstained)
5. Release target proposal with manipulated vote counts

**Realistic Preconditions:**
- Organizations must have the standard `RemoveMember()` functionality (always available)
- Multiple active proposals must exist simultaneously (common in active DAOs)
- Timing coordination needed but achievable given proposal lifetimes

**Detection Constraints:**
The view method `GetProposal()` returns raw vote counts without filtering, masking the actual current-member participation: [6](#0-5) 

Lines 36-38 show unfiltered counts, making it difficult for users to detect that a proposal passed with insufficient current-member participation.

The probability is Medium because while member removal is infrequent, it's a legitimate operation that organizations perform. The vulnerability manifests whenever removal occurs while proposals have outstanding votes, which is a realistic scenario in active governance organizations.

## Recommendation

Fix the inconsistency by filtering the total vote count by current membership to match the behavior of the individual vote type checks. Modify `CheckEnoughVoteAndApprovals()` in `Association_Helper.cs`:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total vote count by current membership
    var totalCurrentMemberVotes = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached = 
        totalCurrentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures all threshold checks consistently count only current members' votes, maintaining the semantic that thresholds represent current-member participation levels.

## Proof of Concept

```csharp
[Fact]
public async Task MinimalVoteThreshold_Bypass_Via_Member_Removal_Test()
{
    // Setup: Create organization with 10 members, MinimalVoteThreshold=8
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, User1Address, User2Address, 
                         User3Address, User4Address, User5Address, User6Address, User7Address };
    
    var organizationAddress = await CreateOrganizationAsync(new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 6,
            MinimalVoteThreshold = 8,  // Requires 8 out of 10 members
            MaximalAbstentionThreshold = 10,
            MaximalRejectionThreshold = 10
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { Reviewer1 } }
    });

    // Create target proposal
    var proposalId = await CreateProposalAsync(organizationAddress, Reviewer1);
    
    // 8 members vote (6 approve, 2 abstain)
    await ApproveAsync(proposalId, Reviewer1);
    await ApproveAsync(proposalId, Reviewer2);
    await ApproveAsync(proposalId, Reviewer3);
    await ApproveAsync(proposalId, User1Address);
    await ApproveAsync(proposalId, User2Address);
    await ApproveAsync(proposalId, User3Address);
    await AbstainAsync(proposalId, User4Address);
    await AbstainAsync(proposalId, User5Address);
    
    // Remove 2 members who voted (the abstainers)
    await RemoveMemberAsync(organizationAddress, User4Address);
    await RemoveMemberAsync(organizationAddress, User5Address);
    
    // Now organization has 8 members, but proposal still has 8 votes
    // Only 6 current members voted (all approvals)
    // MinimalVoteThreshold=8 should fail since only 6/8 current members voted
    // But due to bug, it counts the 2 removed members' votes
    
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue();  // BUG: Should be false
    
    // Release should succeed when it should fail
    var result = await ReleaseProposalAsync(proposalId, Reviewer1);
    result.Status.ShouldBe(TransactionResultStatus.Mined);  // BUG: Should fail
}
```

This test demonstrates that a proposal passes with only 6 current-member votes when `MinimalVoteThreshold=8` requires participation from 8 members, exploiting the inconsistent vote counting when 2 members are removed after voting.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
