# Audit Report

## Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Allows Miners to Manipulate LIB Calculation

## Summary
The AEDPoS consensus contract fails to validate that `ImpliedIrreversibleBlockHeight` values provided in `UpdateValue` transactions equal `Context.CurrentHeight`, allowing authorized miners to submit arbitrary values that violate protocol expectations and affect Last Irreversible Block (LIB) finality calculations.

## Finding Description

The AEDPoS protocol specifies that `ImpliedIrreversibleBlockHeight` should equal the current block height when miners produce blocks. This is enforced in the honest code path during consensus data generation: [1](#0-0) 

However, when the `UpdateValue` method processes miner-provided consensus information, it directly accepts whatever value the miner includes without validating it against `Context.CurrentHeight`: [2](#0-1) 

The only validation performed is a monotonicity check that ensures values don't decrease from the miner's previous value: [3](#0-2) 

This validation lacks any upper bound check or reasonableness validation to ensure the value equals `Context.CurrentHeight`. A malicious miner can craft an `UpdateValueInput` with an arbitrary `ImpliedIrreversibleBlockHeight` value and submit it via the public `UpdateValue` method: [4](#0-3) 

These manipulated values are then used in LIB calculations. The system retrieves sorted implied irreversible heights from miners and selects the element at position `(count-1)/3`: [5](#0-4) 

## Impact Explanation

**Consensus Integrity Violation**: This vulnerability breaks a fundamental protocol invariant - that `ImpliedIrreversibleBlockHeight` must equal `Context.CurrentHeight`. This represents a consensus integrity compromise because:

1. **Finality Manipulation**: While the Byzantine-tolerant design (selecting at position `(count-1)/3`) limits single-miner impact, multiple colluding miners below the 1/3 threshold can force incorrect LIB values that don't accurately reflect block irreversibility.

2. **Protocol Deviation**: Any deviation from protocol-specified behavior undermines the security guarantees and assumptions upon which the blockchain's finality mechanism depends.

3. **Validation Gap**: The after-execution validation uses recovery mechanisms that don't catch this issue because it overwrites the transaction value with header values before comparison, masking the state corruption.

## Likelihood Explanation

**High Likelihood**:
- **Direct Access**: Any authorized miner can call the public `UpdateValue` method with custom parameters
- **Low Barrier**: Requires only modifying node software to bypass honest consensus data generation and craft malicious `UpdateValueInput` 
- **No Economic Cost**: No additional cost beyond being an authorized miner (which requires staking, but that's a prerequisite, not an attack cost)
- **Persistent Effect**: The malicious value is stored in contract state and affects subsequent LIB calculations
- **Validation Bypass**: The monotonicity check is the only defense, easily bypassed by using any value â‰¥ previous value

## Recommendation

Add explicit validation in `ProcessUpdateValue` to ensure `ImpliedIrreversibleBlockHeight` equals `Context.CurrentHeight`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // Add validation
    Assert(updateValueInput.ImpliedIrreversibleBlockHeight == Context.CurrentHeight,
        "ImpliedIrreversibleBlockHeight must equal Context.CurrentHeight");
    
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of processing
}
```

Alternatively, enhance `LibInformationValidationProvider` to validate against a reasonable range based on current block height.

## Proof of Concept

A proof of concept would demonstrate:
1. Authorized miner creates `UpdateValueInput` with `ImpliedIrreversibleBlockHeight = 1`
2. Calls `UpdateValue` method with this input
3. `LibInformationValidationProvider` validation passes (value doesn't decrease from previous)
4. Value is stored in state despite being far below `Context.CurrentHeight`
5. This incorrect value affects LIB calculation in subsequent rounds

The test would verify that no assertion fails when a miner submits an `ImpliedIrreversibleBlockHeight` value significantly different from `Context.CurrentHeight`, confirming the missing validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
