# Audit Report

## Title
Missing ActualMiningTimes Validation in Next Round Allows Consensus Manipulation

## Summary
The AEDPoS consensus contract's `ValidationForNextRound()` method fails to validate the `ActualMiningTimes` field during round transitions, allowing malicious miners producing the extra block to inject arbitrary timestamps that manipulate term change logic and deny tiny block production permissions to targeted miners.

## Finding Description

The AEDPoS consensus contract validates next round information through `ValidationForNextRound()`, which explicitly checks only round number increment and InValue nullability, as documented in the code comments. [1](#0-0) 

When legitimate next round information is generated, `GenerateNextRoundInformation()` creates fresh `MinerInRound` objects that initialize only specific fields (Pubkey, Order, ExpectedMiningTime, ProducedBlocks, MissedTimeSlots) without setting `ActualMiningTimes`. [2](#0-1) 

Only the extra block producer legitimately adds their timestamp to `ActualMiningTimes` when producing the round transition block. [3](#0-2) 

However, the `NextRound()` transaction processes input by converting it via `ToRound()`, which copies ALL fields from the protobuf structure including any pre-filled `ActualMiningTimes`. [4](#0-3)  The manipulated round is then directly stored without additional validation. [5](#0-4) [6](#0-5) 

**Attack Scenario**: A malicious miner producing the extra block generates legitimate next round information, then modifies the `NextRoundInput.RealTimeMinersInformation` map before submission to add fake timestamps to `ActualMiningTimes` for arbitrary miners. The validation passes because it only checks round number and InValue, and the manipulated data is stored in contract state.

## Impact Explanation

Pre-filled `ActualMiningTimes` directly corrupts critical consensus mechanisms:

**1. Term Change Manipulation**: The `NeedToChangeTerm()` method uses the last `ActualMiningTime` of each miner to determine if term transitions should occur. [7](#0-6)  By injecting future timestamps, an attacker can force premature term changes, disrupting the election cycle and miner rotation. Conversely, past timestamps can prevent legitimate term changes, keeping a specific miner set in power longer than intended.

**2. Tiny Block Production Denial**: The consensus behavior logic determines if miners can produce tiny blocks by checking if `ActualMiningTimes.Count < maximumBlocksCount`. [8](#0-7)  By inflating the count to equal or exceed the limit, an attacker prevents targeted miners from producing tiny blocks, reducing network throughput and potentially causing consensus delays.

**3. First Round Timing Manipulation**: Time slot validation for the first round uses `ActualMiningTimes.First()` to establish timing baselines. [9](#0-8)  Manipulated initial timestamps can disrupt the entire round's timing calculations.

The vulnerability affects consensus integrity by allowing unauthorized manipulation of term lifecycles, block production schedules, and timing mechanisms.

## Likelihood Explanation

**High Likelihood** - This attack is practical and easily executable:

**Attacker Capabilities**: Any miner producing the extra block (the last block of a round) can execute this attack. The extra block producer role rotates through the miner set, giving each miner periodic opportunities.

**Attack Complexity**: Low - The attacker only needs to:
1. Generate legitimate next round information via the normal consensus flow
2. Modify the `NextRoundInput` structure locally before block production
3. Submit the modified `NextRound` transaction

**Feasibility Factors**:
- The `NextRound()` method is a standard public consensus entry point [10](#0-9) 
- No authorization beyond being the current extra block producer is required
- The validation explicitly omits `ActualMiningTimes` checks (as documented in code comments)
- The protobuf definition allows the `actual_mining_times` repeated field to be arbitrarily populated [11](#0-10) 

**Detection**: The attack may initially go undetected since the manipulated `ActualMiningTimes` is stored in contract state and treated as legitimate by all subsequent consensus logic.

## Recommendation

Add validation in `ValidationForNextRound()` to ensure `ActualMiningTimes` is empty for all miners except the extra block producer:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };

    // NEW: Validate ActualMiningTimes
    var extraBlockProducer = validationContext.BaseRound.GetExtraBlockProducerInformation()?.Pubkey;
    foreach (var miner in extraData.Round.RealTimeMinersInformation)
    {
        if (miner.Key == extraBlockProducer)
        {
            // Extra block producer should have exactly one ActualMiningTime
            if (miner.Value.ActualMiningTimes.Count != 1)
                return new ValidationResult { Message = "Incorrect ActualMiningTimes for extra block producer." };
        }
        else
        {
            // All other miners should have empty ActualMiningTimes
            if (miner.Value.ActualMiningTimes.Count > 0)
                return new ValidationResult { Message = "Invalid ActualMiningTimes in next round." };
        }
    }

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ActualMiningTimes_Manipulation_Test()
{
    // Initialize consensus with initial miners
    await InitializeCandidates(EconomicContractsTestConstants.InitialCoreDataCenterCount);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());

    // Mine through first round normally
    foreach (var minerInRound in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        var currentKeyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == minerInRound.Pubkey);
        KeyPairProvider.SetKeyPair(currentKeyPair);
        BlockTimeProvider.SetBlockTime(minerInRound.ExpectedMiningTime);
        
        var tester = GetAEDPoSContractStub(currentKeyPair);
        var randomNumber = await GenerateRandomProofAsync(currentKeyPair);
        await tester.UpdateValue.SendAsync(new UpdateValueInput { RandomNumber = ByteString.CopyFrom(randomNumber) });
    }

    // Extra block producer generates next round
    var extraBlockProducer = firstRound.GetExtraBlockProducerInformation();
    var extraBlockProducerKeyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == extraBlockProducer.Pubkey);
    KeyPairProvider.SetKeyPair(extraBlockProducerKeyPair);
    
    var nextRoundInfo = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
        new AElfConsensusTriggerInformation { Behaviour = AElfConsensusBehaviour.NextRound }.ToBytesValue());
    var nextRoundInput = NextRoundInput.Parser.ParseFrom(nextRoundInfo.ToConsensusHeaderInformation().Round.ToByteArray());

    // ATTACK: Inject fake ActualMiningTimes for a target miner
    var targetMiner = nextRoundInput.RealTimeMinersInformation.Keys.First(k => k != extraBlockProducer.Pubkey);
    for (int i = 0; i < 8; i++) // Inject maximum blocks count
    {
        nextRoundInput.RealTimeMinersInformation[targetMiner].ActualMiningTimes.Add(Context.CurrentBlockTime.AddSeconds(i));
    }

    var randomNumber = await GenerateRandomProofAsync(extraBlockProducerKeyPair);
    nextRoundInput.RandomNumber = ByteString.CopyFrom(randomNumber);
    
    // Submit manipulated NextRound - should pass validation
    var result = await GetAEDPoSContractStub(extraBlockProducerKeyPair).NextRound.SendAsync(nextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Verify the attack succeeded
    var secondRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    secondRound.RealTimeMinersInformation[targetMiner].ActualMiningTimes.Count.ShouldBe(8);

    // Target miner is now prevented from producing tiny blocks
    var behaviour = GetConsensusBehaviour(secondRound, targetMiner);
    behaviour.ShouldNotBe(AElfConsensusBehaviour.TinyBlock); // Tiny blocks blocked due to fake count
}
```

## Notes

This vulnerability demonstrates a critical gap in the validation logic where the AEDPoS consensus contract trusts input data from miners without verifying invariants about mining timestamps. The attack is particularly severe because it can be executed by any miner in rotation and affects core consensus mechanisms including term transitions and block production scheduling.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-56)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L195-196)
```csharp
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** protobuf/aedpos_contract.proto (L291-292)
```text
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
```
