# Audit Report

## Title
Vote Count Inconsistency Allows Governance Manipulation Through Member Removal

## Summary
The Association contract's `CheckEnoughVoteAndApprovals()` function contains a critical counting inconsistency where votes from removed members still count toward the MinimalVoteThreshold (quorum) but are excluded from approval/rejection/abstention threshold checks. This allows organizations to manipulate proposal outcomes by removing dissenting members after they vote, causing rejected proposals to become approved.

## Finding Description

The vulnerability exists in the vote counting logic where different filtering rules are applied to different threshold checks.

**Inconsistent Vote Filtering:**

The `CheckEnoughVoteAndApprovals()` function filters approval counts to only include current organization members [1](#0-0) , while the quorum check counts all votes regardless of current membership [2](#0-1) .

Similarly, `IsProposalRejected()` filters rejections to current members only [3](#0-2) , and `IsProposalAbstained()` filters abstentions to current members only [4](#0-3) .

**How the Attack Works:**

When members vote, their addresses are added to the proposal's vote lists (Approvals, Rejections, or Abstentions) [5](#0-4) [6](#0-5) [7](#0-6) .

If members are subsequently removed via the `RemoveMember` function [8](#0-7) , their votes remain in the proposal's vote lists, but they are no longer in the organization member list.

The existing `AssertProposalNotYetVotedBySender` protection only prevents duplicate votes during voting [9](#0-8) , but cannot prevent the counting inconsistency that occurs when members are removed after voting.

**Concrete Attack Scenario:**
- Organization with 10 members: MinimalVoteThreshold=6, MinimalApprovalThreshold=4, MaximalRejectionThreshold=3
- Proposal A receives 4 approvals and 4 rejections (8 total votes)
- Currently: Proposal would be REJECTED (4 rejections > 3 MaximalRejectionThreshold)
- Organization creates and passes Proposal B to remove the 4 rejecting members
- After removal, Proposal A is evaluated:
  - `approvedMemberCount = 4` (current members only) ≥ 4 ✓
  - `rejectionMemberCount = 0` (removed members filtered out) ≤ 3 ✓
  - `totalVotes = 8` (all votes including removed members) ≥ 6 ✓
- Proposal A now PASSES despite having equal approvals and rejections

## Impact Explanation

**HIGH SEVERITY** - This breaks the fundamental governance invariant that vote outcomes should reflect member preferences at the time of voting.

Organizations can retroactively nullify dissenting votes by removing those members from the organization. This completely undermines governance integrity and democratic decision-making within Association contracts.

All Association contract users are affected. Any organization with sufficient control to pass member removal proposals can manipulate pending proposals by strategically removing dissenters, effectively censoring opposition votes.

While this does not result in direct fund loss, it represents a severe governance manipulation vulnerability that can be used to force through any proposal by eliminating opposition.

## Likelihood Explanation

**HIGH LIKELIHOOD** - This vulnerability has multiple factors that make it highly likely to occur:

**Attack Complexity: LOW** - The attack requires only standard contract operations available to any organization: creating a proposal to call `RemoveMember`, getting it approved, releasing it, then releasing the target proposal.

**Preconditions: REALISTIC** - Organizations legitimately remove members for various reasons (inactivity, policy violations, restructuring). This creates natural opportunities to exploit pending proposals, even without malicious intent.

**Attacker Capabilities: STANDARD** - Any organization that can pass a member removal proposal (by controlling enough votes) can execute this attack. No special privileges or compromised keys required.

**Detection: DIFFICULT** - The manipulation appears as normal member management operations. There is no on-chain mechanism to distinguish legitimate member removal from vote manipulation.

**Economic Cost: MINIMAL** - Only gas fees for the member removal proposal and release transactions.

## Recommendation

Apply consistent filtering logic across all vote counting operations. The quorum check should also filter votes to only include current organization members, matching the behavior of approval/rejection/abstention checks.

**Recommended Fix** in `CheckEnoughVoteAndApprovals()`:

Change the quorum calculation to filter by current membership:
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures all threshold checks operate on the same filtered set of current member votes, preventing the manipulation vector.

## Proof of Concept

```csharp
[Fact]
public async Task VoteManipulation_ThroughMemberRemoval_Test()
{
    // Setup: Organization with 10 members, thresholds allow manipulation
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 4,
        minimalVoteThreshold: 6,
        maximalAbstentionThreshold: 10,
        maximalRejectionThreshold: 3,
        proposer: Reviewer1);

    // Create proposal that will be manipulated
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // 4 members approve
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Member1KeyPair, proposalId);
    await ApproveAsync(Member2KeyPair, proposalId);
    
    // 4 members reject (would normally block the proposal)
    await RejectAsync(Member3KeyPair, proposalId);
    await RejectAsync(Member4KeyPair, proposalId);
    await RejectAsync(Member5KeyPair, proposalId);
    await RejectAsync(Member6KeyPair, proposalId);
    
    // Verify proposal is currently rejected (4 rejections > 3 threshold)
    var proposalBeforeRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalBeforeRemoval.ToBeReleased.ShouldBeFalse();
    
    // Create and pass proposal to remove the 4 rejecting members
    var removeMember3Proposal = await CreateRemoveMemberProposal(organizationAddress, Member3);
    await ApproveAndRelease(removeMember3Proposal);
    var removeMember4Proposal = await CreateRemoveMemberProposal(organizationAddress, Member4);
    await ApproveAndRelease(removeMember4Proposal);
    var removeMember5Proposal = await CreateRemoveMemberProposal(organizationAddress, Member5);
    await ApproveAndRelease(removeMember5Proposal);
    var removeMember6Proposal = await CreateRemoveMemberProposal(organizationAddress, Member6);
    await ApproveAndRelease(removeMember6Proposal);
    
    // Now check the original proposal - it should pass due to the bug
    var proposalAfterRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalAfterRemoval.ToBeReleased.ShouldBeTrue(); // BUG: Proposal now passes!
    
    // Release should succeed (demonstrating the vulnerability)
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L42-44)
```csharp
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L132-138)
```csharp
    private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
    {
        var isAlreadyVoted = proposal.Approvals.Contains(sender) || proposal.Rejections.Contains(sender) ||
                             proposal.Abstentions.Contains(sender);

        Assert(!isAlreadyVoted, "Sender already voted.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L150-150)
```csharp
        proposal.Rejections.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L170-170)
```csharp
        proposal.Abstentions.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
