# Audit Report

## Title
LIB Calculation Failure During Miner List Expansion Due to Mismatched Threshold Basis

## Summary
The Last Irreversible Block (LIB) calculation uses the current round's total miner count to calculate the Byzantine fault-tolerant threshold (2/3+1), but validates this threshold against implied irreversible heights retrieved from the previous round. When the miner list increases at term change, new miners have no data in the previous round, making the threshold mathematically impossible to meet and causing LIB advancement to halt until sufficient original miners participate.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates the Last Irreversible Block height using a Byzantine fault-tolerant consensus algorithm. [1](#0-0) 

The threshold calculation uses the current round's miner count via `MinersCountOfConsent`, which is calculated as `(currentRound.RealTimeMinersInformation.Count * 2 / 3) + 1`. [2](#0-1) 

The root cause is a three-phase mismatch:

**Phase 1 - Threshold Calculation**: The consensus threshold is based on the NEW miner count after term change.

**Phase 2 - Data Retrieval**: The method retrieves `impliedIrreversibleHeights` from the PREVIOUS round, filtered by miners who have mined in the CURRENT round. [3](#0-2) 

**Phase 3 - Validation Failure**: The comparison check fails when insufficient data exists. [4](#0-3) 

**Concrete Failure Scenario:**

When `GenerateFirstRoundOfNewTerm` creates a new term with increased miners (e.g., 10 → 13), it sets the `IsMinerListJustChanged` flag. [5](#0-4) 

The network automatically increases miner count by 2 every term interval as part of normal protocol operation. [6](#0-5) 

The calculation fails because:
- `MinersCountOfConsent = (13 * 2 / 3) + 1 = 9` (based on NEW count)
- Maximum available data from previous round: 10 entries (only old miners exist there)
- If only 8 of the 10 original miners mine in the current round: `impliedIrreversibleHeights.Count = 8`
- Check fails: `8 < 9` → LIB calculation returns 0, preventing advancement

The LIB calculator is invoked during every `UpdateValue` call. [7](#0-6) 

**Why Existing Protections Fail**: The `IsMinerListJustChanged` flag is set during term changes but is NOT checked in the LIB calculation logic. It is only used to skip certain tiny block behavior. [8](#0-7) 

No similar protection exists for LIB threshold adjustment during miner list expansion.

## Impact Explanation

**Severity: HIGH - Denial of Service to Critical Consensus Invariant**

This vulnerability causes deterministic failure of LIB advancement, which is a critical consensus property providing finality guarantees. The impacts include:

1. **Broken Finality Guarantees**: Blocks remain unconfirmed as irreversible, undermining the core purpose of LIB
2. **Cross-Chain Operation Failure**: Cross-chain bridges and indexing depend on LIB verification and will stall
3. **User Experience Degradation**: Applications relying on `ConfirmedIrreversibleBlockHeight` for transaction finality lose this guarantee
4. **Network-Wide Scope**: All participants are affected simultaneously

**Quantified Damage:**
- **Frequency**: Occurs at every term change that increases miner count (expected during network growth)
- **Duration**: Multiple rounds (potentially dozens of blocks) until enough original miners participate
- **Scope**: 100% of network participants relying on finality

While this is not a funds-at-risk vulnerability, it constitutes a HIGH severity DoS against a critical protocol invariant that provides security guarantees to the entire ecosystem.

## Likelihood Explanation

**Likelihood: HIGH - Deterministic Protocol-Level Bug**

**No Attacker Required**: This is a logic error in the consensus implementation that triggers automatically during normal network operations.

**Zero Attack Complexity**: Term changes with miner list expansion are regular protocol operations. When they occur, the bug manifests deterministically.

**Guaranteed Trigger Conditions**:
- Term changes occur at configured intervals (typically yearly)
- Network growth naturally increases miner count by 2 every term
- The test suite confirms this pattern with miner count increases validated in tests [9](#0-8) 

However, tests do not validate LIB calculation correctness during these transitions.

**Mathematical Certainty**: When miner count increases from M to N (where N > M), and fewer than `(N * 2/3) + 1` of the original M miners participate in the first round, LIB calculation MUST fail due to insufficient historical data.

## Recommendation

Add a check for the `IsMinerListJustChanged` flag in the LIB calculation logic. When the miner list has just changed, adjust the threshold calculation to use the minimum of the current and previous round's miner counts, or skip LIB advancement for the first round of a new term.

Proposed fix in `LastIrreversibleBlockHeightCalculator.Deconstruct()`:
- Before line 26, add: `if (_currentRound.IsMinerListJustChanged && impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent) { /* use previous round's threshold or skip */ }`
- Alternative: Use `_previousRound.MinersCountOfConsent` when `IsMinerListJustChanged` is true

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Calculation_Fails_During_Miner_List_Expansion()
{
    // Setup: Initialize with 10 miners
    await InitializeConsensusWithMiners(10);
    
    // Mine several rounds to establish LIB
    await MineMultipleRounds(5);
    var libBeforeTermChange = await GetCurrentLIBHeight();
    
    // Trigger term change with miner expansion to 13
    await AdvanceTimeToNextTerm();
    await ExecuteNextTerm(13); // Expands from 10 to 13 miners
    
    // Only 8 of original 10 miners participate in first round of new term
    await MineBlocksWithSubsetOfMiners(8);
    
    // Assert: LIB should advance but doesn't
    var libAfterTermChange = await GetCurrentLIBHeight();
    
    // BUG: LIB remains stuck at previous value
    Assert.Equal(libBeforeTermChange, libAfterTermChange);
    
    // Expected: LIB should have advanced but it didn't due to
    // threshold mismatch (need 9 but only have 8)
}
```

This test demonstrates that during miner list expansion, LIB calculation returns 0 when the threshold based on new miner count exceeds the available data from the previous round, causing LIB advancement to halt.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L118-118)
```csharp
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);
```
