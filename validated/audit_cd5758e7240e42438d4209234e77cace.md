# Audit Report

## Title
Bidirectional RelatedSymbol Invariant Violation in TokenConverter Causes Inconsistent View Function Results

## Summary
The `MigrateConnectorTokens` function lacks access control and fails to maintain the bidirectional `RelatedSymbol` invariant by leaving orphaned old deposit connectors in state after migration. This causes `GetPairConnector` to return inconsistent connector pairs and allows any user to trigger unauthorized state changes.

## Finding Description

The `MigrateConnectorTokens` function violates critical security guarantees by breaking the bidirectional connector relationship invariant without proper authorization controls. [1](#0-0) 

**Root Cause Analysis:**

The function updates resource connectors to point to new deposit connector symbols and copies old deposit connectors to new locations, but critically fails to:
1. Remove or disable the old connector from `State.Connectors[oldConnectorTokenSymbol]`
2. Validate bidirectional relationship integrity after migration
3. Implement any access control checks

After migration, three connectors exist with broken relationships:
- Resource connector (CPU) → New deposit connector ((NT)CPU) ✓
- New deposit connector ((NT)CPU) → Resource connector (CPU) ✓
- **Orphaned old deposit connector (ntCPU) → Resource connector (CPU)** ✗ (CPU no longer points back)

**Missing Access Control:**

Unlike all other state-modifying connector methods, `MigrateConnectorTokens` has NO authorization check: [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

All these methods call `AssertPerformedByConnectorController()` to enforce governance, but `MigrateConnectorTokens` does not. [6](#0-5) 

**Impact on View Functions:** [7](#0-6) 

The `GetPairConnector` function assumes bidirectional relationships when retrieving related connectors. With orphaned connectors, querying different symbols returns inconsistent pairs:
- Query "CPU" or "(NT)CPU" → Returns correct pair {CPU, (NT)CPU}
- Query "ntCPU" → Returns orphaned pair {CPU, ntCPU} where CPU doesn't recognize ntCPU [8](#0-7) 

The `IsSymbolAbleToSell` function returns misleading results for orphaned connectors, indicating they are tradeable when they should be deprecated.

## Impact Explanation

**Severity: Medium**

This vulnerability has multiple impact dimensions:

1. **State Integrity Violation**: The core bidirectional invariant that `Connector[A].RelatedSymbol = B ⟺ Connector[B].RelatedSymbol = A` is permanently broken after migration, corrupting contract state.

2. **Authorization Bypass**: Any user can trigger system-level migration operations that should require governance approval, as evidenced by all other connector management functions requiring `AssertPerformedByConnectorController()`.

3. **Ecosystem Integration Impact**: Off-chain systems (price oracles, DEX aggregators, blockchain indexers) querying `GetPairConnector` receive different connector pair information depending on which symbol they query, leading to:
   - Incorrect pricing data propagation
   - Failed trade routing
   - Inconsistent market data feeds

4. **User Experience Degradation**: `IsSymbolAbleToSell` returns true for deprecated orphaned connectors, misleading users about tradeable symbols.

While this does not enable direct fund theft (transactions with orphaned symbols would fail at token transfer validation), the permanent state corruption and missing access control represent a significant protocol integrity issue.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be triggered due to:

1. **No Access Control**: The function is publicly callable with no authorization requirements, unlike all other connector management functions.

2. **Trivial Exploitation**: Requires only a single function call with empty input - no complex setup or preconditions beyond normal system state.

3. **Realistic Preconditions**: 
   - Connectors must exist (normal operational state)
   - Connectors not previously migrated (one-time operation per connector)
   - No special privileges required

4. **Permanent Effect**: The migration is a one-time operation that permanently breaks the invariant with no recovery mechanism, as confirmed by existing tests. [9](#0-8) 

The test verifies migration cannot be repeated but does not validate orphaned connector cleanup or bidirectionality maintenance.

## Recommendation

Implement the following fixes:

1. **Add Access Control**: Call `AssertPerformedByConnectorController()` at the beginning of `MigrateConnectorTokens` to enforce governance authorization.

2. **Clean Up Orphaned Connectors**: After copying the old connector to the new location, delete or disable the old connector entry to prevent orphaned state.

3. **Validate Bidirectionality**: Add assertions to verify that after migration, all connector pairs maintain the bidirectional relationship invariant.

Fixed code structure:
```csharp
public override Empty MigrateConnectorTokens(Empty input)
{
    AssertPerformedByConnectorController(); // ADD THIS
    
    foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
                 .Union(Context.Variables.GetStringArray(PayRentalSymbolListName)))
    {
        // ... existing migration logic ...
        
        // ADD: Clean up orphaned connector
        if (State.Connectors[oldConnectorTokenSymbol] != null)
        {
            State.Connectors.Remove(oldConnectorTokenSymbol);
            State.DepositBalance.Remove(oldConnectorTokenSymbol);
        }
        
        // ADD: Validate bidirectionality
        Assert(State.Connectors[newConnectorTokenSymbol].RelatedSymbol == resourceTokenSymbol,
            "Bidirectional relationship violated");
        Assert(State.Connectors[resourceTokenSymbol].RelatedSymbol == newConnectorTokenSymbol,
            "Bidirectional relationship violated");
    }
    
    return new Empty();
}
```

## Proof of Concept

The existing test demonstrates that any user can call this function without authorization: [10](#0-9) 

The test shows `DefaultStub` (representing any user) can successfully call `MigrateConnectorTokens` and perform migration, with no authorization check preventing the operation. The subsequent buy/sell operations work with the new connectors, but the old orphaned connectors remain in state, causing `GetPairConnector` to return inconsistent results depending on which symbol is queried.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-267)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
        var feeRate = AssertedDecimal(input.Value);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L311-342)
```csharp
    public override Empty MigrateConnectorTokens(Empty input)
    {
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(PayRentalSymbolListName)))
        {
            var newConnectorTokenSymbol = NewNtTokenPrefix.Append(resourceTokenSymbol);

            if (State.Connectors[resourceTokenSymbol] == null)
            {
                continue;
            }

            var oldConnectorTokenSymbol = State.Connectors[resourceTokenSymbol].RelatedSymbol;

            Assert(!oldConnectorTokenSymbol.StartsWith(NewNtTokenPrefix), "Already migrated.");

            // Migrate

            State.Connectors[resourceTokenSymbol].RelatedSymbol = newConnectorTokenSymbol;

            if (State.Connectors[oldConnectorTokenSymbol] != null)
            {
                var connector = State.Connectors[oldConnectorTokenSymbol];
                connector.Symbol = newConnectorTokenSymbol;
                State.Connectors[newConnectorTokenSymbol] = connector;
            }

            State.DepositBalance[newConnectorTokenSymbol] = State.DepositBalance[oldConnectorTokenSymbol];
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L37-54)
```csharp
    public override PairConnector GetPairConnector(TokenSymbol input)
    {
        var targetConnector = State.Connectors[input.Symbol];
        Connector relatedConnector = null;
        if (targetConnector != null)
            relatedConnector = State.Connectors[targetConnector.RelatedSymbol];
        if (targetConnector != null && targetConnector.IsDepositAccount)
            return new PairConnector
            {
                ResourceConnector = relatedConnector,
                DepositConnector = targetConnector
            };
        return new PairConnector
        {
            ResourceConnector = targetConnector,
            DepositConnector = relatedConnector
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L104-108)
```csharp
    public override BoolValue IsSymbolAbleToSell(StringValue input)
    {
        var depositConnector = GetPairConnector(new TokenSymbol { Symbol = input.Value }).DepositConnector;
        return new BoolValue { Value = depositConnector != null && depositConnector.IsPurchaseEnabled };
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L14-71)
```csharp
    public async Task CanBuyResourceTokenAfterMigration()
    {
        await CreateWriteToken();
        await InitializeTreasuryContractAsync();
        await InitializeTokenConverterContract();
        await PrepareToBuyAndSell();

        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());

        //check the price and fee
        var fromConnectorBalance = ELFConnector.VirtualBalance;
        var fromConnectorWeight = decimal.Parse(ELFConnector.Weight);
        var toConnectorBalance = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
        var toConnectorWeight = decimal.Parse(WriteConnector.Weight);

        var amountToPay = BancorHelper.GetAmountToPayFromReturn(fromConnectorBalance, fromConnectorWeight,
            toConnectorBalance, toConnectorWeight, 1000L);
        var depositAmountBeforeBuy = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        var fee = Convert.ToInt64(amountToPay * 5 / 1000);

        var buyResult = (await DefaultStub.Buy.SendAsync(
            new BuyInput
            {
                Symbol = WriteConnector.Symbol,
                Amount = 1000L,
                PayLimit = amountToPay + fee + 10L
            })).TransactionResult;
        buyResult.Status.ShouldBe(TransactionResultStatus.Mined);

        //Verify the outcome of the transaction
        var depositAmountAfterBuy = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        depositAmountAfterBuy.Value.Sub(depositAmountBeforeBuy.Value).ShouldBe(amountToPay);
        var balanceOfTesterWrite = await GetBalanceAsync(WriteSymbol, DefaultSender);
        balanceOfTesterWrite.ShouldBe(1000L);

        var elfBalanceLoggedInTokenConvert = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        elfBalanceLoggedInTokenConvert.Value.ShouldBe(ELFConnector.VirtualBalance + amountToPay);
        var balanceOfElfToken = await GetBalanceAsync(NativeSymbol, TokenConverterContractAddress);
        balanceOfElfToken.ShouldBe(amountToPay);

        var donatedFee = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
        donatedFee.Value[NativeSymbol].ShouldBe(fee.Div(2));

        var balanceOfRamToken = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
        balanceOfRamToken.ShouldBe(100_0000L - 1000L);

        var balanceOfTesterToken = await GetBalanceAsync(NativeSymbol, DefaultSender);
        balanceOfTesterToken.ShouldBe(100_0000L - amountToPay - fee);
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L143-153)
```csharp
    public async Task MigrateTwiceTest()
    {
        await CreateWriteToken();
        await InitializeTreasuryContractAsync();
        await InitializeTokenConverterContract();
        await PrepareToBuyAndSell();

        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());
        var result = await DefaultStub.MigrateConnectorTokens.SendWithExceptionAsync(new Empty());
        result.TransactionResult.Error.ShouldContain("Already migrated.");
    }
```
