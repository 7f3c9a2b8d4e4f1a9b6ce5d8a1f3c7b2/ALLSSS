# Audit Report

## Title
Unvalidated LIB Height/Round Correspondence in NextRound and NextTerm Transitions Enables State Corruption

## Summary
The AEDPoS consensus contract only validates Last Irreversible Block (LIB) information for `UpdateValue` behavior, not for `NextRound` or `NextTerm` behaviors. A malicious extra block producer can inject mismatched `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` pairs during round/term transitions, corrupting consensus state and triggering false Abnormal/Severe blockchain status that severely restricts block production.

## Finding Description

The vulnerability stems from inconsistent validation of LIB values across different consensus behaviors. The `LibInformationValidationProvider` checks that LIB values do not regress [1](#0-0) , but this validator is only applied to `UpdateValue` behavior [2](#0-1) .

For `NextRound` and `NextTerm` behaviors, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied [3](#0-2) . These validators only check mining order correctness [4](#0-3)  and round/term number increments [5](#0-4) . Critically, there is no validation that `ConfirmedIrreversibleBlockRoundNumber` corresponds to the actual round at `ConfirmedIrreversibleBlockHeight`.

For `UpdateValue`, LIB values are recalculated using `LastIrreversibleBlockHeightCalculator` and the round number is set to the previous round [6](#0-5) . However, for `NextRound` and `NextTerm`, the provided LIB values from the input are preserved in the `ToRound()` conversion [7](#0-6)  and [8](#0-7) , then stored directly to state via `AddRoundInformation` [9](#0-8)  and [10](#0-9) .

The attack path requires the attacker to be the extra block producer for a round (which rotates among all miners). The attacker can construct a `NextRoundInput` or `NextTermInput` with artificially low `ConfirmedIrreversibleBlockRoundNumber` values while keeping `ConfirmedIrreversibleBlockHeight` correct, submit it through the public `NextRound` [11](#0-10)  or `NextTerm` [12](#0-11)  methods, and the corrupted values will pass validation and be stored.

## Impact Explanation

**Operational DoS Impact**: The corrupted LIB round number directly affects `GetMaximumBlocksCount`, which reads `ConfirmedIrreversibleBlockRoundNumber` from the current round [13](#0-12)  and uses it to evaluate blockchain mining status [14](#0-13) .

By providing an artificially low round number (e.g., 1 instead of 50), the system calculates a large difference between `currentRoundNumber` and `libRoundNumber`. When this difference exceeds the severe status threshold, the blockchain enters Severe status [15](#0-14) , which limits all miners to producing only 1 block each and fires the `IrreversibleBlockHeightUnacceptable` event [16](#0-15) . This severely restricts blockchain throughput and can trigger emergency chain rollback procedures.

**Persistence**: The corrupted LIB values propagate to all subsequent rounds because `GenerateNextRoundInformation` copies both `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` from the current round to the next round [17](#0-16) . The corruption persists until manually corrected through governance intervention or a properly constructed NextRound block with correct values.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be a legitimate miner who becomes the extra block producer for a round. Extra block producer selection rotates among all miners, so with N miners, the probability is 1/N per round. In typical AELf configurations with 17-21 miners, a malicious miner becomes extra block producer approximately every 17-21 rounds.

**Attack Complexity**: Low. The attacker can call the consensus contract's helper methods to obtain legitimate round information, then manually construct a `NextRoundInput` or `NextTermInput` with modified LIB values, and submit it through the public entry points. The validation logic does not prevent this attack vector.

**Detection**: The attack manifests when the blockchain enters false Abnormal/Severe status, miners notice incorrect LIB values, or operations dependent on accurate LIB information (such as cross-chain indexing) begin to fail. However, by the time detection occurs, the corruption has already been stored to state and requires corrective action.

## Recommendation

Add `LibInformationValidationProvider` to the validation chain for both `NextRound` and `NextTerm` behaviors in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add LIB validation
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add LIB validation
    break;
```

Additionally, consider implementing a stronger validation that verifies the correspondence between `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` by checking historical round information at the claimed height.

## Proof of Concept

```csharp
// Test demonstrating the attack
[Fact]
public async Task MaliciousExtraBlockProducer_CanCorruptLIBRoundNumber()
{
    // Setup: Initialize consensus with legitimate miners
    await InitializeConsensusContract();
    
    // Advance to round 50 with legitimate blocks
    for (int i = 1; i < 50; i++)
    {
        await ProduceLegitimateRound();
    }
    
    // Get current round - should have LIB around round 48
    var currentRound = await GetCurrentRoundInformation();
    Assert.True(currentRound.ConfirmedIrreversibleBlockRoundNumber >= 45);
    
    // Attacker is extra block producer for round 50
    var attackerKeyPair = GetExtraBlockProducerKeyPair();
    
    // Attacker constructs malicious NextRoundInput with corrupted LIB
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 51,
        ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight,
        ConfirmedIrreversibleBlockRoundNumber = 1, // Artificially low - should be ~48
        // ... other legitimate fields
    };
    
    // Attack: Submit malicious NextRound transaction
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Verify: Corrupted LIB values are stored
    var newRound = await GetCurrentRoundInformation();
    Assert.Equal(1, newRound.ConfirmedIrreversibleBlockRoundNumber); // Corruption confirmed
    
    // Verify: System enters false Severe status
    var maxBlocksCount = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    Assert.Equal(1, maxBlocksCount.Value); // Severe status: only 1 block per miner
    
    // Impact: Blockchain throughput severely restricted until manual correction
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L11-21)
```csharp
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-46)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-28)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L35-37)
```csharp
        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L123-128)
```csharp
            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
