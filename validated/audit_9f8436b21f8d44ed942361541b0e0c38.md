# Audit Report

## Title
Authorization Bypass: Any Miner Can Arbitrarily Set Other Miners' PreviousInValue Without Secret Sharing Validation

## Summary
The `PerformSecretSharing` function in the AEDPoS consensus contract allows any miner to set arbitrary `PreviousInValue` for other miners without validating that these values were correctly reconstructed through the secret sharing mechanism. This bypasses the threshold-based reveal mechanism and corrupts the blockchain's secret sharing integrity.

## Finding Description

The vulnerability exists in the state-modifying execution path when processing `UpdateValue` consensus transactions. [1](#0-0) 

The `PerformSecretSharing` function unconditionally sets `PreviousInValue` for any miner specified in the input's `MinersPreviousInValues` map without any authorization check or validation that these values were properly derived from secret sharing. [2](#0-1) 

The `UpdateValueInput` protobuf message structure includes a `miners_previous_in_values` field that maps miner public keys to hash values. [3](#0-2) 

When a miner produces a block, they control the consensus extra data and can craft a Round object with arbitrary `PreviousInValue` fields. The `UpdateValueInput` is then extracted from this Round object via `ExtractInformationToUpdateConsensus`, which copies ALL existing `PreviousInValue` fields. [4](#0-3) 

The `UpdateValue` method is accessible to any miner and only validates the sender is in the miner list via `PreCheck`. [5](#0-4) 

The `UpdateValueValidationProvider` only validates the sender's OWN `PreviousInValue`, not the values for OTHER miners in the `MinersPreviousInValues` map. [6](#0-5) 

**Contrast with Intended Implementation**: The `RevealSharedInValues` function demonstrates the PROPER approach, requiring threshold validation of encrypted/decrypted pieces and using `SecretSharingHelper.DecodeSecret` to reconstruct values. [7](#0-6) 

**Critical Design Flaw**: The off-chain view function `UpdateLatestSecretPieces` HAS a protective check that only sets `PreviousInValue` if it's currently Empty or null. [8](#0-7) 

However, the on-chain state-modifying function `PerformSecretSharing` LACKS this critical protection, allowing unconditional overwrites of any miner's `PreviousInValue`.

## Impact Explanation

**Consensus Integrity Breach**: The secret sharing mechanism is designed to prevent miners from withholding their InValues to manipulate consensus randomness. By allowing arbitrary `PreviousInValue` setting, this security mechanism is completely bypassed.

**State Corruption**: Malicious values are written to persistent blockchain state via `TryToUpdateRoundInformation`. [9](#0-8) 

**Propagation of Corruption**: The corrupted values are subsequently extracted by honest miners via `ExtractInformationToUpdateConsensus` in future rounds, spreading the corruption throughout the consensus network. [4](#0-3) 

**Affected Parties**: All miners in the consensus round can have their `PreviousInValue` arbitrarily modified, affecting the integrity of the commit-reveal scheme that underpins the secret sharing randomness mechanism.

## Likelihood Explanation

**Attacker Capabilities**: Attacker must be an elected miner, which is feasible for any malicious validator or compromised miner node. This does not require exceptional privilege beyond normal miner status.

**Attack Complexity**: Low - when producing a block, the attacker can craft a Round object in the consensus extra data with malicious `PreviousInValue` entries for other miners. The corresponding UpdateValue transaction will apply these values without validation.

**Execution Practicality**: The attack is executable in every round where the attacker produces blocks. The block header Round object is under miner control, and the validation only checks consistency between header and execution result, not the legitimacy of the values themselves.

**Detection Constraints**: No validation or event logging exists to detect when a miner sets another miner's `PreviousInValue`. The attack is silent and can persist across multiple rounds as the corrupted values propagate via `ExtractInformationToUpdateConsensus`.

**Economic Rationality**: Attack cost is negligible (normal block production cost), while the ability to manipulate consensus state could provide strategic advantages in block production ordering or randomness manipulation.

## Recommendation

Add the same protective check from `UpdateLatestSecretPieces` to the `PerformSecretSharing` function:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    // Add protective check: only set if Empty or null
    foreach (var previousInValue in input.MinersPreviousInValues)
        if (round.RealTimeMinersInformation.ContainsKey(previousInValue.Key) &&
            (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty ||
             round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null))
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

Additionally, consider adding validation that `PreviousInValue` entries in `MinersPreviousInValues` can only be set for miners where the sender has contributed valid decrypted pieces and threshold requirements are met, similar to `RevealSharedInValues`.

## Proof of Concept

The vulnerability can be demonstrated by a test where:
1. A malicious miner creates an `UpdateValueInput` with arbitrary `PreviousInValue` entries for other miners in the `MinersPreviousInValues` map
2. The malicious miner produces a block with a Round object containing these arbitrary values in the consensus extra data
3. The `UpdateValue` transaction executes successfully without validation failure
4. The arbitrary `PreviousInValue` values are persisted to state
5. Subsequent calls to `GetCurrentRoundInformation` show the corrupted values
6. Honest miners extract these corrupted values via `ExtractInformationToUpdateConsensus` in the next round

The test would verify that `PerformSecretSharing` writes arbitrary values without the protective check present in `UpdateLatestSecretPieces`, demonstrating the inconsistency between off-chain generation and on-chain execution validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```
