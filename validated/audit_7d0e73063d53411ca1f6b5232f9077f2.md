# Audit Report

## Title
Permanent Authority Lockout via MethodFeeController Change to Inaccessible Organization

## Summary
The `ChangeMethodFeeController()` function in all ACS1-implementing system contracts allows changing the method fee controller to a Parliament organization with mathematically impossible voting thresholds (100% unanimous approval). Once set, the controller becomes permanently inaccessible due to a circular dependency: changing it again requires executing a proposal through the same organization, which requires 100% miner consensus. No recovery mechanism exists.

## Finding Description

The vulnerability stems from insufficient validation in the `ChangeMethodFeeController()` implementation pattern used across all ACS1 system contracts. The function enforces that only the current controller can authorize changes by verifying `Context.Sender` matches the controller's `OwnerAddress`. [1](#0-0) 

However, the function only validates that the new organization exists via `CheckOrganizationExist()`, without verifying whether its voting thresholds are achievable. [2](#0-1) 

The Parliament contract's validation logic explicitly permits creating organizations with `MinimalApprovalThreshold = 10000`, where `AbstractVoteTotal = 10000` represents 100%. [3](#0-2) [4](#0-3) 

Test cases explicitly confirm that organizations with 100% approval thresholds are successfully created with `TransactionResultStatus.Mined`. [5](#0-4) 

The approval threshold calculation requires unanimous approval when set to 100%: `approvedMemberCount * AbstractVoteTotal >= MinimalApprovalThreshold * parliamentMembers.Count` becomes `approvedMemberCount >= parliamentMembers.Count`, requiring ALL current miners to approve. [6](#0-5) 

When a proposal is released, it executes using the organization's virtual address as `Context.Sender` via `SendVirtualInlineBySystemContract`. [7](#0-6) 

The initialization logic provides no recovery mechanism - it only sets the controller if null, with no admin override or emergency reset capability. [8](#0-7) 

**Attack Execution Path:**
1. Attacker (miner or whitelisted proposer) creates Parliament organization with `MinimalApprovalThreshold = 10000` 
2. Creates proposal calling `ChangeMethodFeeController` with malicious organization address
3. Obtains 2/3+ miner approval (default Parliament threshold of 6667)
4. Releases proposal, permanently changing the controller
5. Future controller changes require 100% miner approval - impossible if any single miner is offline, compromised, or refuses

## Impact Explanation

**Critical Governance Failure - Severity: High**

This vulnerability enables permanent denial of service on method fee governance across all ACS1-implementing system contracts, including Token, Treasury, Consensus, Election, Parliament, Profit, and all other critical infrastructure contracts.

Once the controller is set to an organization with 100% threshold:
- **Permanent loss of economic flexibility**: Method fees cannot be adjusted to adapt to changing network conditions, token prices, or congestion
- **Irreversible state**: No code path exists to reset or recover the controller once locked
- **System-wide impact**: All contracts using this organization as controller are simultaneously affected
- **No emergency override**: The EmergencyResponseOrganization has no special bypass powers for this scenario

This violates the fundamental governance invariant that administrative authorities must remain accessible for protocol adaptation and emergency response.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Prerequisites:**
- Must be a current miner OR whitelisted proposer (standard governance participant roles)
- Must obtain 2/3+ approval from Parliament (the default governance threshold is 6667/10000)

**Attack Complexity: Low**
- Create organization with 100% threshold: 1 transaction
- Create controller change proposal: 1 transaction  
- Obtain governance approval: requires social engineering or appearing legitimate
- Release proposal: 1 transaction

**Realistic Attack Scenarios:**

1. **Accidental misconfiguration**: Well-intentioned governance participants create organizations with extreme thresholds without understanding the irreversibility, believing they can change it later

2. **Social engineering attack**: Malicious actor proposes what appears to be a "security enhancement" (e.g., "increase controller security to require unanimous approval"), obscuring the permanent lockout consequence

3. **Compromised miner griefing**: Single compromised or malicious miner with low attack cost (only transaction fees) permanently damages the protocol

**No Technical Barriers**: The system has zero validation, circuit breakers, or warning mechanisms to detect or prevent dangerous threshold configurations before they lock governance permanently.

## Recommendation

Implement threshold reachability validation in `ChangeMethodFeeController()`:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate threshold reachability for Parliament organizations
    if (input.ContractAddress == State.ParliamentContract.Value)
    {
        var organization = State.ParliamentContract.GetOrganization.Call(input.OwnerAddress);
        var currentMinerCount = State.ParliamentContract.GetCurrentMinerList.Call(new Empty()).Pubkeys.Count;
        var minApprovalRequired = (organization.ProposalReleaseThreshold.MinimalApprovalThreshold * currentMinerCount) / 10000;
        
        Assert(minApprovalRequired < currentMinerCount, 
            "Organization threshold requires unanimous approval - this would create permanent lockout.");
    }
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

Additionally, consider:
- Maximum threshold caps (e.g., 95%) for organizations used as controllers
- Time-locked controller changes with cancellation periods
- Emergency override mechanism through a separate high-threshold organization
- Warning events when dangerous thresholds are configured

## Proof of Concept

```csharp
[Fact]
public async Task ChangeMethodFeeController_PermanentLockout_Test()
{
    // Step 1: Create Parliament organization with 100% approval threshold
    var createOrganizationResult = await ParliamentContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 10000, // 100% threshold
                MinimalVoteThreshold = 10000,
                MaximalAbstentionThreshold = 0,
                MaximalRejectionThreshold = 0
            }
        });
    createOrganizationResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var maliciousOrgAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);
    
    // Step 2: Get current controller (default Parliament organization)
    var currentController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
    
    // Step 3: Create proposal to change controller to malicious organization
    var proposalId = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        ContractMethodName = nameof(TokenContractStub.ChangeMethodFeeController),
        ToAddress = TokenContractAddress,
        Params = new AuthorityInfo
        {
            OwnerAddress = maliciousOrgAddress,
            ContractAddress = ParliamentContractAddress
        }.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        OrganizationAddress = currentController.OwnerAddress
    });
    
    // Step 4: Approve with 2/3+ miners (default threshold)
    await ApproveWithMinersAsync(proposalId.Output);
    
    // Step 5: Release proposal - controller is now permanently locked
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 6: Verify controller has changed
    var newController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
    newController.OwnerAddress.ShouldBe(maliciousOrgAddress);
    
    // Step 7: Attempt to change controller back - requires 100% approval (IMPOSSIBLE)
    var recoveryProposalId = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        ContractMethodName = nameof(TokenContractStub.ChangeMethodFeeController),
        ToAddress = TokenContractAddress,
        Params = new AuthorityInfo
        {
            OwnerAddress = currentController.OwnerAddress,
            ContractAddress = ParliamentContractAddress
        }.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        OrganizationAddress = maliciousOrgAddress
    });
    
    // Approve with all miners EXCEPT one
    await ApproveWithMinersAsync(recoveryProposalId.Output, skipLast: 1);
    
    // Release will FAIL - threshold not reached (requires ALL miners)
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(recoveryProposalId.Output);
    proposal.ToBeReleased.ShouldBe(false); // Permanently locked - cannot recover
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L189-195)
```csharp
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
