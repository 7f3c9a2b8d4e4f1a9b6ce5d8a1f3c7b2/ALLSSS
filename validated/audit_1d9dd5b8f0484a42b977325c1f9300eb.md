# Audit Report

## Title
Missing Authorization Check for Extra Block Slot Tiny Block Production

## Summary
The `TimeSlotValidationProvider.CheckMinerTimeSlot()` method fails to verify that miners producing tiny blocks before their expected mining time are actually authorized as the `ExtraBlockProducerOfPreviousRound`. This allows any miner in the current validator set to bypass consensus time slot restrictions and produce blocks during the previous round's extra block slot, violating a critical consensus invariant and enabling block reward theft.

## Finding Description

The AEDPoS consensus system designates a specific miner as `ExtraBlockProducerOfPreviousRound` who is authorized to produce tiny blocks during the transition period between rounds. This authorization check is properly enforced in command generation: [1](#0-0) 

And in the view method that validates current miners: [2](#0-1) 

However, during block validation, the authorization check is missing. When `TinyBlock` behavior is validated, only basic validators are applied: [3](#0-2) 

Note that for `TinyBlock` behavior, no additional authorization validators are added (lines 77-92 handle other behaviors only).

The critical gap exists in `TimeSlotValidationProvider.CheckMinerTimeSlot()`, which checks timing but not authorization: [4](#0-3) 

The comment indicates this is for extra block slot production, but there's no check that `SenderPubkey == ExtraBlockProducerOfPreviousRound`.

`MiningPermissionValidationProvider` only checks miner list membership, not specific extra block authorization: [5](#0-4) 

`PreCheck()` similarly only validates miner list membership: [6](#0-5) 

Finally, `ProcessTinyBlock()` processes the block without authorization verification: [7](#0-6) 

**Attack Flow:**
1. Malicious miner (MinerB) is in the validator set but NOT the `ExtraBlockProducerOfPreviousRound`
2. MinerB calls the public method `UpdateTinyBlockInformation` with crafted `TinyBlockInput`
3. Validation passes because no validator checks `ExtraBlockProducerOfPreviousRound` authorization
4. `ProcessTinyBlock()` increments MinerB's `ProducedBlocks` counter
5. At term end, `DonateMiningReward()` calculates rewards based on total produced blocks: [8](#0-7) 

Where `GetMinedBlocks()` sums all miners' `ProducedBlocks`: [9](#0-8) 

6. MinerB receives unauthorized block rewards

## Impact Explanation

This vulnerability has **HIGH** impact:

1. **Consensus Invariant Violation**: The fundamental rule that only the designated `ExtraBlockProducerOfPreviousRound` can mine during the extra block slot is broken, undermining consensus predictability and fairness.

2. **Block Reward Theft**: Unauthorized miners steal block production rewards from the protocol. Each unauthorized tiny block increments their `ProducedBlocks` counter, directly increasing their reward share at term transitions.

3. **Consensus Disruption**: Multiple miners exploiting this simultaneously could create competing blocks in the extra block slot, potentially causing forks, delayed finalization, or LIB calculation errors.

4. **Mining Schedule Corruption**: The round-robin mining schedule becomes unreliable, which could cascade into cross-chain operation issues that depend on predictable block timing.

## Likelihood Explanation

The likelihood of exploitation is **HIGH**:

**Attacker Prerequisites:**
- Must be an active miner in the validator set (realistic for consensus-level attacks)
- Requires no additional privileges beyond normal mining capabilities
- Public method `UpdateTinyBlockInformation` is the entry point [10](#0-9) 

**Attack Complexity: LOW**
1. Monitor round state to identify timing windows
2. Craft `TinyBlockInput` with appropriate timing before round start
3. Submit via `UpdateTinyBlockInformation`
4. All validators pass due to missing authorization check

**Economic Incentive**: Block production rewards make this economically rational. Cost is minimal (standard block resources) while benefit is additional block rewards.

**Detection Difficulty**: Unauthorized blocks appear legitimate since they come from valid miners with proper signatures.

## Recommendation

Add an authorization validator specifically for `TinyBlock` behavior that checks `ExtraBlockProducerOfPreviousRound`:

```csharp
// In TimeSlotValidationProvider.CheckMinerTimeSlot()
if (latestActualMiningTime < expectedMiningTime)
{
    // Check authorization for extra block slot
    if (validationContext.BaseRound.ExtraBlockProducerOfPreviousRound != validationContext.SenderPubkey)
    {
        return false; // Unauthorized for extra block slot
    }
    return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();
}
```

Alternatively, add a dedicated `ExtraBlockSlotValidationProvider` in the validation pipeline for `TinyBlock` behavior.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanProduceTinyBlockInExtraSlot_WithoutAuthorization()
{
    // Setup: Initialize consensus with multiple miners
    var miners = new[] { "Miner1", "Miner2", "Miner3" };
    await InitializeConsensus(miners);
    
    // Round ends, Miner1 is designated as ExtraBlockProducerOfPreviousRound
    var currentRound = await GetCurrentRound();
    Assert.Equal("Miner1", currentRound.ExtraBlockProducerOfPreviousRound);
    
    // Malicious Miner2 (NOT authorized) crafts TinyBlockInput before round starts
    var tinyBlockInput = new TinyBlockInput
    {
        RoundId = currentRound.RoundNumber,
        ActualMiningTime = currentRound.GetRoundStartTime().AddMilliseconds(-100),
        RandomNumber = GenerateRandomNumber()
    };
    
    // Miner2 calls UpdateTinyBlockInformation
    var result = await AEDPoSContractStub2.UpdateTinyBlockInformation.SendAsync(tinyBlockInput);
    
    // Vulnerability: Transaction succeeds despite Miner2 not being authorized
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Miner2's ProducedBlocks counter is incremented
    var updatedRound = await GetCurrentRound();
    Assert.True(updatedRound.RealTimeMinersInformation["Miner2"].ProducedBlocks > 0);
    
    // This violates the invariant that only ExtraBlockProducerOfPreviousRound can produce blocks in extra slot
}
```

## Notes

The vulnerability exists because authorization logic is implemented in command generation (client-side) and view methods but not in the validation pipeline (server-side enforcement). This defense-in-depth gap allows malicious miners to bypass consensus rules by directly calling the public contract method with crafted inputs.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L46-48)
```csharp
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L119-120)
```csharp
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
