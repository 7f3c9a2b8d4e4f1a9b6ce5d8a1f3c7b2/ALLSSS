# Audit Report

## Title
Banned Miners Can Be Re-Selected As Block Producers Through Backup Selection Logic

## Summary
The Election contract's `GetVictories` method contains a critical logic flaw in its backup miner selection mechanism. When insufficient valid candidates exist to fill all block producer positions, the function selects from current miners without verifying their banned status in `State.BannedPubkeyMap`. This allows previously banned/evil miners who remain in the consensus contract's current round to be automatically re-elected as block producers for the next term, completely bypassing the evil miner detection and banning mechanism.

## Finding Description

The vulnerability exists in the backup selection logic of the `GetVictories` method. When the consensus contract calls this method during term transitions to determine next term's block producers, the function first attempts to select valid candidates with sufficient votes. [1](#0-0) 

When there are insufficient valid candidates to fill all required miner positions (`diff > 0`), the function employs a backup selection mechanism that retrieves current miners from the consensus contract. [2](#0-1) 

The critical vulnerability is at line 66, which creates a backup list from current miners who are not in the valid candidates list. **This line completely omits checking `State.BannedPubkeyMap[k]` to filter out banned miners.**

When a miner is marked as evil through `UpdateCandidateInformation` with `IsEvilNode=true`, the Election contract sets the ban flag and removes them from the candidate list. [3](#0-2) 

However, this does NOT immediately remove the banned miner from the consensus contract's current round. The current miner list reflects the active round's participants. [4](#0-3) 

Therefore, banned miners remain in `currentMiners` until term transitions occur. Since they are no longer in `validCandidates` (removed from candidate list), they pass the filter at line 66 and get added to the victories list for the next term.

**Evidence of Code Inconsistency:**

The codebase demonstrates clear awareness of this requirement in `GetMinerReplacementInformation`, which explicitly filters out banned initial miners. [5](#0-4) 

The `GetEvilMinersPubkeys` function confirms that current miners can indeed be banned. [6](#0-5) 

This proves the codebase IS aware that banned status checks are necessary, but the `GetVictories` backup selection logic omits this critical validation.

## Impact Explanation

**Direct Consensus Integrity Violation:**
- Banned/evil miners who were explicitly detected and marked as malicious can be automatically re-selected as block producers for the next term
- This completely undermines the evil miner detection mechanism implemented throughout the AEDPoS consensus system
- Banned miners continue producing blocks, earning mining rewards and subsidies, and potentially causing further harm to network security

**Reward Misallocation:**
- Evil miners continue receiving block production rewards, mining subsidies from the Treasury contract, and profit distributions despite being explicitly banned
- Honest alternative candidates are systematically denied their rightful block production slots
- The Profit and Treasury distribution schemes continue rewarding malicious actors who should have been excluded

**Security Compromise:**
- The consensus system's security model assumes banned miners are permanently excluded from future rounds, but this assumption is violated
- Networks with low candidate participation become vulnerable to persistent control by previously-identified malicious miners
- The evil miner replacement mechanism becomes ineffective if banned miners are immediately re-elected through the backup selection path

## Likelihood Explanation

**Feasible Preconditions:**
- Requires `State.MinersCount.Value > validCandidates.Count` (insufficient candidates with active votes)
- This scenario is highly realistic in networks with low candidate participation, during initial network stages, or following mass candidate withdrawals
- At least one current miner must be banned via `UpdateCandidateInformation(IsEvilNode=true)` or through the emergency response organization

**Execution Path:**
1. Consensus contract detects evil miner behavior (missed blocks, incorrect consensus data, etc.)
2. Consensus contract calls `UpdateCandidateInformation(IsEvilNode=true)` to ban the miner [7](#0-6) 
3. Banned miner is marked in `BannedPubkeyMap` and removed from candidate list, but remains in current consensus round
4. At next term transition, consensus contract calls `GetVictories` via `TryToGetVictories` [8](#0-7) 
5. If insufficient valid candidates exist (`diff > 0`), backup selection logic executes without banned status check
6. Banned miner is automatically re-selected and included in the next term's miner list

**Probability Assessment:**
- **High** in networks with low candidate participation (common in early-stage blockchain networks and during bear markets)
- **Automatic** - no explicit attacker action needed; the vulnerability triggers during normal term transitions
- **Repeatable** - can occur at every subsequent term transition until the candidate pool increases sufficiently
- **Realistic** - the conditions are easily achievable in real-world deployments, particularly during network stress or low participation periods

## Recommendation

Add a banned status check to the backup selection logic in `GetVictories` method. The fix should filter out banned miners when creating the backups list:

```csharp
var backups = currentMiners
    .Where(k => !validCandidates.Contains(k))
    .Where(k => !State.BannedPubkeyMap[k])  // Add this check
    .ToList();
```

This aligns the backup selection logic with the existing pattern already implemented in `GetMinerReplacementInformation` and ensures consistency across the codebase.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task BannedMiner_CanBeReelectedThroughBackupLogic_Test()
{
    // Setup: Initialize election with miners
    await InitializeElectionAsync();
    
    // Step 1: Announce candidates and vote (insufficient to fill all slots)
    var validCandidates = 3; // Less than required miners count (e.g., 5)
    var bannedMinerPubkey = InitialMiners[0].PublicKey.ToHex();
    
    // Step 2: Ban one current miner
    await ConsensusStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = bannedMinerPubkey,
            IsEvilNode = true
        });
    
    // Verify miner is banned
    var isBanned = await ElectionStub.GetBannedPubkeyMap.CallAsync(
        new StringValue { Value = bannedMinerPubkey });
    isBanned.Value.ShouldBeTrue();
    
    // Step 3: Trigger term transition with insufficient valid candidates
    await BlockMiningService.MineBlockToNextTermAsync();
    
    // Step 4: Get victories (next term's miners)
    var victories = await ElectionStub.GetVictories.CallAsync(new Empty());
    
    // VULNERABILITY: Banned miner should NOT be in victories,
    // but it will be included due to missing banned status check
    victories.Value
        .Select(v => v.ToHex())
        .ShouldContain(bannedMinerPubkey); // This assertion proves the vulnerability
}
```

This test demonstrates that when there are insufficient valid candidates and a current miner is banned, the banned miner is still selected for the next term through the backup selection logic, violating the security invariant that banned miners should never produce blocks.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-49)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L60-66)
```csharp
        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-392)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L316-320)
```csharp
                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

```
