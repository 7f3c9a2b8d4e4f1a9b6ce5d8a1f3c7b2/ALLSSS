# Audit Report

## Title
Unbounded Loop in GetAllProfitsMap() Enables DoS of Profit Query View Methods

## Summary
The `GetAllProfitsMap()` private method contains an unbounded loop that processes all profit details without any upper limit. A malicious scheme manager can repeatedly call `AddBeneficiary` to inflate a victim's profit details to thousands of entries. When anyone queries the victim's profits, the contract performs millions of state reads causing timeout and operational DoS.

## Finding Description

The vulnerability exists in the profit query mechanism where view methods fail to limit computational complexity, breaking the security guarantee that users should always be able to query their profit information.

**Attack Setup:**
Any user can call `CreateScheme()` to become a scheme manager [1](#0-0) , then repeatedly call `AddBeneficiary()` targeting any victim address [2](#0-1) . Each call adds a new `ProfitDetail` to the beneficiary's details list without any limit [3](#0-2) .

When `input.EndPeriod == 0`, it is set to `long.MaxValue` [4](#0-3) , and the cleanup mechanism never removes these details [5](#0-4)  because the condition `d.EndPeriod != long.MaxValue` is never satisfied.

**DoS Trigger:**
When anyone calls view methods like `GetAllProfitsMap()` [6](#0-5) , `GetProfitAmount()` [7](#0-6) , or `GetAllProfitAmount()` [8](#0-7) , they all invoke the private `GetAllProfitsMap()` method.

**The Critical Flaw:**
The main loop iterates over ALL available details without any cap [9](#0-8) . For EVERY detail, the expensive `ProfitAllPeriods()` method is called with a potentially huge period count [10](#0-9) .

The existing `ProfitReceivingLimitForEachTime` constant (value 10) [11](#0-10)  is used to calculate `profitableDetailCount` [12](#0-11) , but this limit is only checked AFTER the expensive calculation at line 130 executes [13](#0-12) . This means the protection only prevents the second `ProfitAllPeriods()` call for claimable profits, NOT the first call for total profits.

The `ProfitAllPeriods()` method contains nested loops that iterate through periods and perform state reads for each period and token symbol [14](#0-13) , resulting in millions of operations when details are inflated.

## Impact Explanation

**Severity: HIGH**

**Operational DoS:**
- When a victim has 10,000+ profit details (each spanning hundreds of periods), querying profits results in millions of state reads (10,000 details × ~100 periods × multiple token symbols)
- View methods timeout or fail, completely disabling profit query functionality
- Nodes processing these queries experience CPU and memory exhaustion

**Affected Parties:**
- **Primary victims**: Any address added as a beneficiary by malicious scheme managers cannot query their profits
- **Secondary victims**: Applications and users attempting to query profit information on behalf of others
- **Node operators**: Experience resource exhaustion when processing malicious queries

**No Recovery Mechanism:**
- Details with `EndPeriod = long.MaxValue` are never automatically cleaned up
- DoS persists permanently until manual state intervention
- Victims have no way to remove malicious entries themselves

**Security Guarantee Broken:**
Users should always be able to query their profit amounts through view methods. This vulnerability completely breaks that guarantee for targeted addresses.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities:**
- Any user can execute the attack without special permissions
- Only requires calling two public methods: `CreateScheme` followed by repeated `AddBeneficiary` calls
- Attack setup cost is minimal (estimated 1-2 ELF for 10,000 transactions)

**Attack Complexity:**
- Straightforward two-step attack: (1) Create scheme, (2) Call AddBeneficiary 10,000 times
- No sophisticated exploit logic required
- Can be fully automated with simple scripts
- No timing dependencies or race conditions

**Feasibility:**
- Works under normal blockchain operation
- No victim interaction required - attacker unilaterally chooses victims
- Attack succeeds regardless of profit distribution state
- All preconditions are trivially achievable

**Economic Rationality:**
- High impact-to-cost ratio makes griefing attacks economically attractive
- Permanent damage with minimal one-time investment
- No detection mechanisms exist to prevent detail accumulation

## Recommendation

Implement a hard cap on the total number of profit details processed in view methods:

1. **Add a constant for maximum processable details:**
```csharp
public const int MaximumProfitDetailsForView = 100;
```

2. **Limit the loop in GetAllProfitsMap():**
```csharp
var maxDetailsToProcess = Math.Min(MaximumProfitDetailsForView, availableDetails.Count);
for (var i = 0; i < maxDetailsToProcess; i++)
{
    // existing logic
}
```

3. **Add a maximum detail count per beneficiary in AddBeneficiary():**
```csharp
var maxDetailsPerBeneficiary = 1000; // reasonable limit
Assert(currentProfitDetails.Details.Count < maxDetailsPerBeneficiary, 
    "Maximum profit details per beneficiary exceeded.");
```

4. **Implement pagination for view methods** to allow querying profits in chunks rather than all at once.

## Proof of Concept

```csharp
// PoC: DoS Attack on Profit Query View Methods

[Fact]
public async Task ProfitQueryDoS_UnboundedLoop()
{
    // 1. Attacker creates their own profit scheme
    var attackerSchemeId = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        Manager = AttackerAddress
    });
    
    // 2. Attacker inflates victim's profit details to 10,000 entries
    for (int i = 0; i < 10000; i++)
    {
        await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
        {
            SchemeId = attackerSchemeId.Output,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = VictimAddress,
                Shares = 1
            },
            EndPeriod = 0, // Becomes long.MaxValue, never cleaned up
            ProfitDetailId = HashHelper.ComputeFrom(i) // Different ID for each entry
        });
    }
    
    // 3. Anyone attempting to query victim's profits experiences timeout/DoS
    // This call will iterate 10,000 times through the unbounded loop
    // Each iteration calls ProfitAllPeriods() which performs nested loops
    // Result: Millions of state reads, causing timeout
    var startTime = DateTime.UtcNow;
    try
    {
        var result = await ProfitContractStub.GetAllProfitsMap.CallAsync(new GetAllProfitsMapInput
        {
            SchemeId = attackerSchemeId.Output,
            Beneficiary = VictimAddress
        });
        // If this completes, measure execution time
        var duration = DateTime.UtcNow - startTime;
        Assert.True(duration.TotalSeconds > 30, "Query should timeout or take excessive time");
    }
    catch (Exception)
    {
        // Expected: Timeout or resource exhaustion
        Assert.True(true, "View method failed due to DoS");
    }
}
```

**Notes:**
- The vulnerability is confirmed by code analysis showing the unbounded loop at line 125 processes ALL details without limit
- The `ProfitReceivingLimitForEachTime` protection only applies to the claimable profits calculation, not the total profits calculation that executes first
- Details with `EndPeriod = long.MaxValue` are never removed by the cleanup mechanism
- This breaks the fundamental availability guarantee of profit query functionality

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-174)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L62-64)
```csharp
    public override Int64Value GetProfitAmount(GetProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L72-74)
```csharp
    public override GetAllProfitAmountOutput GetAllProfitAmount(GetAllProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L98-101)
```csharp
    public override GetAllProfitsMapOutput GetAllProfitsMap(GetAllProfitsMapInput input)
    {
        return GetAllProfitsMap(input.SchemeId, input.Beneficiary);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L119-120)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-125)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L130-130)
```csharp
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L132-132)
```csharp
            if(i >= profitableDetailCount) continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```
