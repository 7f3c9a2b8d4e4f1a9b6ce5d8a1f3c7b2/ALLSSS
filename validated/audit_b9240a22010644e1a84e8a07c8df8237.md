# Audit Report

## Title
Missing Validation of Decrypted Secret Shares Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract accepts decrypted secret shares from miners without cryptographic validation, allowing malicious miners to submit arbitrary fake shares that corrupt signature calculations and manipulate mining order determination, breaking consensus integrity.

## Finding Description

The vulnerability exists in the secret sharing mechanism used for InValue recovery when miners fail to self-reveal. The system has two distinct validation paths:

**Path 1 (Self-Revelation - Protected):** When a miner provides their own `PreviousInValue` directly, it is validated against their previous `OutValue` to ensure correctness. [1](#0-0) 

**Path 2 (Secret Sharing Reconstruction - Unprotected):** When other miners submit decrypted shares to reconstruct a miner's `PreviousInValue`, no validation occurs:

1. **Entry Point 1:** `UpdateLatestSecretPieces()` accepts and stores decrypted pieces without validation. [2](#0-1) 

2. **Entry Point 2:** `PerformSecretSharing()` also stores decrypted pieces without validation. [3](#0-2) 

3. **Reconstruction:** `RevealSharedInValues()` uses `SecretSharingHelper.DecodeSecret()` to reconstruct the InValue and directly stores it as `PreviousInValue` without checking if the hash of the revealed value matches the `OutValue` from the previous round. [4](#0-3) 

The `SecretSharingHelper.DecodeSecret()` function performs pure Lagrange interpolation and will always produce output regardless of whether input shares are valid or fabricated. [5](#0-4) 

**Critical Impact Path:** The fake `PreviousInValue` is subsequently used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks. [6](#0-5)  These corrupted signatures directly determine mining order in future rounds through the `ApplyNormalConsensusData` logic. [7](#0-6) 

**Validation Gap:** The `UpdateValueValidationProvider` validates self-provided `PreviousInValue` but is only applied during `UpdateValue` behavior, not during `NextRound` behavior when `RevealSharedInValues` executes. [8](#0-7) [9](#0-8) 

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability breaks the core security guarantee of the consensus mechanism:

1. **Signature Corruption:** Fake `PreviousInValue` entries result in incorrect signature calculations for miners who fail to produce blocks. These corrupted signatures are stored in consensus state and used to determine mining order for subsequent rounds.

2. **Mining Order Manipulation:** Since mining order is derived from signatures via modulo arithmetic, attackers can influence which miners produce blocks and when, potentially enabling coordinated attacks by controlling miner scheduling, denial of service against specific honest miners, and manipulation of consensus timing.

3. **Secret Sharing Mechanism Failure:** The entire purpose of Shamir's Secret Sharing is to enable trustless recovery of InValues. With unvalidated decrypted shares, the recovery mechanism becomes unreliable, forcing the system to depend solely on self-revelation and eliminating the fault-tolerance benefit.

4. **Persistent State Corruption:** Fake decrypted pieces are stored in contract state and persist across rounds, causing ongoing damage to consensus integrity.

## Likelihood Explanation

**HIGH Likelihood**

**Attacker Requirements:**
- Must be an active miner in the current round (checked via `PreCheck()`) [10](#0-9) 
- No special cryptographic capabilities needed beyond normal mining operations

**Attack Execution:**
1. During block production, attacker submits `UpdateValueInput` or produces a block with `triggerInformation` containing fake `decrypted_pieces` for target miners
2. The contract stores these fake pieces without validation
3. When `RevealSharedInValues()` executes during the next round transition (called at line 189 of GetConsensusExtraDataForNextRound), it reconstructs fake `PreviousInValue` entries [11](#0-10) 
4. These fake values corrupt signature calculations in `SupplyCurrentRoundInformation()`

**No Barriers:**
- No validation checks exist to prevent the attack
- The attack triggers whenever secret sharing is enabled [12](#0-11) 
- Detection is difficult since fake shares appear as valid byte arrays on-chain
- Cost is only normal transaction fees

## Recommendation

Add validation in `RevealSharedInValues()` to verify that the reconstructed InValue hashes to the expected OutValue:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... existing checks ...
        
        var revealedInValue =
            HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
        
        // ADD VALIDATION HERE
        var expectedOutValue = previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
        if (expectedOutValue != null && HashHelper.ComputeFrom(revealedInValue) != expectedOutValue)
        {
            Context.LogDebug(() => $"Invalid revealed in value for {publicKeyOfAnotherMiner}");
            continue; // Skip invalid reconstruction
        }
        
        currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
    }
}
```

This ensures that reconstructed InValues are cryptographically valid before being used in signature calculations.

## Proof of Concept

A malicious miner can execute this attack by:

1. Calling `UpdateValue()` with crafted `DecryptedPieces` containing arbitrary byte arrays instead of legitimate decrypted secret shares
2. These fake shares are stored without validation in the target miners' `DecryptedPieces` dictionaries
3. When the next round begins, `RevealSharedInValues()` blindly reconstructs a fake `PreviousInValue` using Lagrange interpolation on the fake shares
4. This fake `PreviousInValue` is used to calculate an incorrect signature in `SupplyCurrentRoundInformation()`
5. The incorrect signature manipulates the mining order calculation, allowing the attacker to influence which miners produce blocks in subsequent rounds

The vulnerability is confirmed by the absence of any validation comparing `Hash(revealedInValue)` with the expected `OutValue` in the secret sharing reconstruction path, while such validation exists in the self-revelation path.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-86)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-327)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-80)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```
