# Audit Report

## Title
Two-Miner Consensus Deadlock: Malicious Miner Can Permanently Block Term Transitions

## Summary
In a two-miner network, a single malicious miner can permanently block term transitions by refusing to mine, creating an unrecoverable deadlock. The `NeedToChangeTerm` method requires both miners to have mined blocks with timestamps in the new period before allowing term transition, but a non-mining attacker prevents this threshold from ever being met. This permanently freezes the miner list, blocks treasury distributions, and renders governance ineffective.

## Finding Description

**Root Cause:**

The vulnerability exists in the term transition logic. When a round needs to be terminated, `GetConsensusBehaviourToTerminateCurrentRound()` checks if a term change is needed. [1](#0-0) 

This method calls `NeedToChangeTerm`, which implements a two-thirds consensus requirement by counting miners who have mined in the new period. [2](#0-1) 

The critical flaw is in `MinersCountOfConsent` calculation. For a two-miner network: `2 * 2 / 3 + 1 = 2` (integer division), requiring BOTH miners to agree. [3](#0-2) 

**Why Protections Fail:**

The `NeedToChangeTerm` method filters miners using `.Where(m => m.ActualMiningTimes.Any())`, excluding miners who haven't mined in the current round. If the malicious miner refuses to mine:
- Only the honest miner has `ActualMiningTimes` with timestamps crossing the period boundary
- Count = 1, but `MinersCountOfConsent` = 2
- Since 1 < 2, `NeedToChangeTerm` returns false
- System returns `NextRound` instead of `NextTerm`

**Deadlock Mechanism:**

When rounds continue via `NextRound`, miners who don't mine get their `MissedTimeSlots` incremented. [4](#0-3) 

The tolerable threshold is 4320 slots (3 days). [5](#0-4) 

After exceeding this threshold, evil miners are detected and marked in the Election contract. [6](#0-5) [7](#0-6) 

However, marking as evil only updates the Election contract - it does NOT remove the miner from the current consensus miner list. The active miner list is ONLY updated during term transitions via `ProcessNextTerm`. [8](#0-7) 

**Circular Dependency:**
- To remove evil miner from active list → need `ProcessNextTerm`
- To trigger `ProcessNextTerm` → need `NextTerm` behavior
- To get `NextTerm` behavior → need `NeedToChangeTerm` = true
- To satisfy `NeedToChangeTerm` → need both miners to mine in new period
- Malicious miner refuses → **permanent deadlock**

Even the governance `RemoveEvilNode` method cannot break this deadlock, as it only updates the Election contract, not the consensus miner list. [9](#0-8) 

## Impact Explanation

**Critical Protocol-Level Impacts:**

1. **Term Transitions Permanently Blocked**: The system cannot transition to new terms, freezing at the current term indefinitely.

2. **Miner List Frozen**: Election results cannot be applied. The consensus contract's miner list is only updated in `ProcessNextTerm`, which never executes.

3. **Treasury Distribution Halted**: Mining rewards and treasury profit distributions only occur during term transitions. [10](#0-9) 

4. **Mining Rewards Not Distributed**: The `DonateMiningReward` method only executes during term transitions. [11](#0-10) 

5. **Governance Paralysis**: The protocol cannot adapt to changing conditions or recover from this state without external hard fork intervention.

**Severity Justification:**
This is CRITICAL because:
- Creates permanent, unrecoverable protocol failure
- Requires only 50% miner compromise (1 of 2)
- No timeout, fallback, or recovery mechanism exists
- Protocol cannot self-heal

## Likelihood Explanation

**High Likelihood in Two-Miner Scenarios:**

1. **Attacker Capabilities**: Requires control of 1 out of 2 miners (50% threshold). No special technical capabilities needed - simply refusing to mine is sufficient.

2. **Attack Complexity**: Trivial to execute. Attacker just stops mining when period boundary approaches. No complex transaction sequencing required.

3. **Feasibility**: Two-miner networks are realistic for:
   - Early-stage sidechains
   - Test networks
   - Small private chains
   - Networks during bootstrap phase

4. **Economic Rationality**: Malicious miner maintains their position and rewards indefinitely, prevents competitors from joining via elections, zero cost to execute.

5. **Detection Constraints**: Attack appears as normal network issues initially. By the time deadlock is recognized (after 3+ days), recovery requires hard fork.

## Recommendation

**Immediate Fix:**

Modify the term transition logic to add a fallback mechanism for two-miner networks or when consensus cannot be reached:

1. **Add Timeout-Based Term Transition**: If a term has exceeded its period by a significant threshold (e.g., 2x the normal period), allow term transition with a lower threshold or force term transition.

2. **Dynamic Threshold Adjustment**: For networks with ≤ 3 miners, adjust `MinersCountOfConsent` to allow term transitions with a simple majority rather than two-thirds, or implement special handling.

3. **Emergency Recovery Mechanism**: Add a governance-controlled emergency method that can force a term transition when deadlock is detected, callable by the emergency response organization.

4. **Active Miner List Update**: Allow the consensus contract to directly update the active miner list when a miner is marked as evil, rather than waiting for term transitions.

**Suggested Code Fix for NeedToChangeTerm:**

Add special handling for small miner counts before the main logic. For example, modify the calculation to ensure that with 2 miners, only 1 miner with the correct timestamp is needed if the other has excessive `MissedTimeSlots`.

## Proof of Concept

A valid test demonstrating this vulnerability would:

1. Initialize a two-miner network (Miner A and Miner B)
2. Advance time to approach the period boundary (7 days)
3. Have Miner A mine blocks with timestamps in the new period
4. Have Miner B refuse to mine (simulate offline)
5. Verify that `NeedToChangeTerm` returns false
6. Verify that `GetConsensusBehaviourToTerminateCurrentRound` returns `NextRound` instead of `NextTerm`
7. Verify that after multiple rounds, Miner B accumulates `MissedTimeSlots` beyond 4320
8. Verify that Miner B is marked as evil in the Election contract
9. Verify that the consensus miner list still contains Miner B
10. Verify that term transitions never occur
11. Verify that Treasury distributions never execute

The test would demonstrate that the system enters an unrecoverable deadlock state where term transitions are permanently blocked.

---

**Notes:**

This vulnerability represents a fundamental design flaw in the two-thirds consensus requirement when applied to very small miner sets. The requirement was designed for Byzantine fault tolerance in larger networks but creates a deadlock condition in two-miner scenarios. The lack of fallback mechanisms or timeout-based recovery makes this a permanent, unrecoverable failure state requiring hard fork intervention.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
