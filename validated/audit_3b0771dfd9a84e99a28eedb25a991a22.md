# Audit Report

## Title
Missing Election Result Validation Allows Arbitrary Miner List Installation During Term Transitions

## Summary
The consensus term transition validation fails to verify that the miner list in `NextTermInput` matches election results from the Election contract. Any current or previous miner can submit a maliciously crafted `NextTerm` transaction with an arbitrary miner list, completely bypassing the blockchain's election mechanism and hijacking consensus for an entire term.

## Finding Description

The vulnerability exists in the term transition validation and execution logic of the AEDPoS consensus contract.

**Missing Validation:** The `ValidationForNextTerm()` function only validates term/round number increments but never checks the miner list against election results. [1](#0-0) 

**Legitimate Flow:** When generating consensus data for a new term, `GenerateFirstRoundOfNextTerm()` retrieves elected miners from the Election contract via `TryToGetVictories()`: [2](#0-1) 

The `TryToGetVictories()` method calls the Election Contract's `GetVictories` to retrieve legitimately elected miners: [3](#0-2) 

When using victories, `GenerateFirstRoundOfNewTerm()` sets `IsMinerListJustChanged = true`: [4](#0-3) 

**Vulnerable Execution:** However, during `NextTerm` transaction execution, `ProcessNextTerm()` extracts the miner list **directly from user input** without any verification: [5](#0-4) 

The `SetMinerList()` function only checks if a miner list already exists for that term, not whether it matches election results: [6](#0-5) 

**Weak Access Control:** The only authorization check is in `PreCheck()`, which merely verifies the sender is a current or previous miner: [7](#0-6) 

**Attack Sequence:**
1. Attacker (a current or previous miner) monitors for term transition timing
2. Constructs `NextTermInput` with correct term number (currentTerm + 1) and round number (currentRound + 1)
3. Includes arbitrary miner list in `RealTimeMinersInformation` field (attacker-controlled addresses)
4. Submits transaction via public `NextTerm()` method
5. Validation passes (only checks term/round number increments, not miner list validity)
6. Arbitrary miner list is installed for the entire next term via `SetMinerList()`

The `NextTerm` method is publicly accessible: [8](#0-7) 

## Impact Explanation

This is a **HIGH severity** vulnerability with catastrophic impact on the blockchain's core consensus mechanism:

**Consensus Integrity Violation:** The fundamental invariant "miners must be elected through voting" is completely broken. The election mechanism becomes meaningless as any current miner can unilaterally decide the next term's block producers.

**Authority Hijacking:** The attacker gains complete control over who produces blocks for an entire term (potentially days or weeks based on `PeriodSeconds` configuration). They can:
- Install only attacker-controlled miners
- Exclude legitimate elected miners entirely
- Create a cartel of colluding miners

**Reward Theft:** All mining rewards for the compromised term flow to attacker-controlled addresses instead of legitimately elected miners, potentially representing significant economic value.

**Network-Wide Impact:** All blockchain participants are affected as the legitimacy of consensus is compromised. Smart contracts, users, and applications interact with a blockchain controlled by unauthorized block producers.

**Persistent Effect:** The malicious miner set remains active for the full term duration with no built-in mechanism to recover mid-term.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements:**
- Must be a current or previous miner (verified by `PreCheck()`)
- This is a realistic precondition as any elected miner can become malicious or be compromised

**Attack Complexity: LOW**
- Term transition timing is predictable based on `PeriodSeconds` configuration and blockchain age
- Only requires constructing `NextTermInput` with correct term/round numbers and desired miner list
- No cryptographic challenges or complex state manipulation required
- Single transaction execution

**Feasibility:**
- The `NextTerm()` method is public and directly callable by any address
- No additional authorization beyond being a current/previous miner
- Race condition exists (first transaction to execute wins), but attacker can employ strategies to win:
  - Monitor mempool and front-run honest miners
  - Leverage network position as an existing miner
  - Attempt at each term transition until successful

**Detection Difficulty:**
- No built-in detection mechanisms exist
- Would only be discovered when unexpected miners start producing blocks
- By that time, the malicious miner set is already installed and active

The combination of low attack complexity, realistic preconditions, and high impact makes this a critical vulnerability.

## Recommendation

Add validation in `ValidationForNextTerm()` to verify the miner list against election results:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate miner list matches election results
    if (State.IsMainChain.Value)
    {
        var expectedVictories = State.ElectionContract.GetVictories.Call(new Empty());
        var inputMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var expectedMiners = expectedVictories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        
        if (!inputMiners.SequenceEqual(expectedMiners))
            return new ValidationResult { Message = "Miner list does not match election results." };
    }
    
    return new ValidationResult { Success = true };
}
```

Additionally, consider adding a check for the `IsMinerListJustChanged` flag to ensure the round was generated through the legitimate `GenerateFirstRoundOfNextTerm()` flow.

## Proof of Concept

```csharp
[Fact]
public async Task ArbitraryMinerList_CanBeInstalled_DuringTermTransition()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Advance to term transition point
    await AdvanceToTermTransition();
    
    // Attacker (current miner) constructs malicious NextTermInput
    var currentRound = await GetCurrentRound();
    var maliciousMinerList = new[] { "attacker1", "attacker2", "attacker3" };
    
    var maliciousInput = new NextTermInput
    {
        TermNumber = currentRound.TermNumber + 1,
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = CreateMinerInfo(maliciousMinerList),
        // ... other required fields
    };
    
    // Execute attack: Submit NextTerm with arbitrary miner list
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Arbitrary miner list was installed
    var installedMiners = await GetMinerListForTerm(currentRound.TermNumber + 1);
    installedMiners.Pubkeys.Select(p => p.ToHex()).ShouldBe(maliciousMinerList);
    
    // Verify: Election results were bypassed
    var electionVictories = await ElectionStub.GetVictories.CallAsync(new Empty());
    var electedMiners = electionVictories.Value.Select(v => v.ToHex()).ToArray();
    electedMiners.ShouldNotBe(maliciousMinerList); // Election results ignored!
}
```

## Notes

- The vulnerability affects **main chain only**, as side chains don't use election results (confirmed in `TryToGetVictories` which returns false for non-main chains)
- The race condition with honest miners attempting the same term transition makes the attack window narrow but still feasible with network positioning advantages
- Once a malicious miner list is installed, there is no built-in recovery mechanism until the next term transition
- The `IsMinerListJustChanged` flag is set correctly when using the legitimate flow but is never validated during execution, making it ineffective as a security control

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-45)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```
