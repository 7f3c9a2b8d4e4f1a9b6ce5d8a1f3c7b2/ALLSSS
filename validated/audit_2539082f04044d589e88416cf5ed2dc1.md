# Audit Report

## Title
Missing Minimum Participation Threshold Validation for Consensus Round Termination

## Summary
The AEDPoS consensus mechanism allows rounds to be terminated without validating that the minimum Byzantine Fault Tolerance threshold (MinersCountOfConsent = 2/3 + 1 of total miners) has been reached. This fundamental flaw enables consensus state transitions with insufficient validator participation, violating core BFT security guarantees and creating severe network partition risks.

## Finding Description

The AEDPoS consensus protocol defines `MinersCountOfConsent` as the Byzantine Fault Tolerance threshold, calculated as `(totalMiners * 2 / 3) + 1`. [1](#0-0)  This threshold is correctly enforced for Last Irreversible Block (LIB) height calculation [2](#0-1)  and secret sharing quorum requirements. [3](#0-2) 

However, round termination via `NextRound` or `NextTerm` behaviors proceeds **without any participation threshold validation**:

1. The `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` method generates round termination commands without checking participation. [4](#0-3) 

2. The `RoundTerminateValidationProvider` only validates that round/term numbers increment correctly and in-values are null, but never checks if sufficient miners participated. [5](#0-4) 

3. The `ProcessNextRound` method records mined miners via `RecordMinedMinerListOfCurrentRound()` but never validates that `GetMinedMiners().Count >= MinersCountOfConsent` before allowing the round to proceed. [6](#0-5) 

4. Similarly, `ProcessNextTerm` lacks any participation threshold check. [7](#0-6) 

5. The validation service for consensus behaviors includes multiple validation providers (`MiningPermissionValidationProvider`, `TimeSlotValidationProvider`, `ContinuousBlocksValidationProvider`, `RoundTerminateValidationProvider`) but none check participation thresholds. [8](#0-7) 

The `GetMinedMiners()` method identifies miners who participated (where `SupposedOrderOfNextRound != 0`), [9](#0-8)  but this count is never compared against `MinersCountOfConsent` in any validation or processing path.

While `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` uses `NeedToChangeTerm()` to decide between NextRound vs NextTerm behaviors, [10](#0-9)  and `NeedToChangeTerm()` does check if MinersCountOfConsent miners agree on term timing, [11](#0-10)  this **only determines the behavior type, not whether termination is allowed at all**. A round can still be terminated with fewer than MinersCountOfConsent participating miners.

## Impact Explanation

**Consensus Integrity Violation (HIGH)**: The system fundamentally violates Byzantine Fault Tolerance guarantees by allowing consensus state transitions (round/term changes) with fewer than 2/3 + 1 miner participation. This breaks the core security assumption that honest majority consensus is required for state transitions.

**Network Partition Catastrophe (HIGH)**: During network partitions, each isolated segment can independently terminate rounds and produce blocks with minimal participation. For example, in a 21-miner network requiring 15 participants (MinersCountOfConsent), a partition with only 7 miners could continue progressing rounds indefinitely, as could the other partition with 14 miners. Both partitions create divergent chain histories that are extremely difficult to reconcile.

**Finality Uncertainty (MEDIUM)**: While LIB calculation correctly requires MinersCountOfConsent and prevents finalization of insufficiently-confirmed blocks, users and applications still observe new blocks and transactions being produced. This creates dangerous uncertainty about transaction finality, as blocks may be produced but never finalize, leading to potential transaction reversals when the network heals or reorganizes.

**Trust Erosion (MEDIUM)**: The violation of advertised BFT guarantees undermines user and validator trust in the protocol's security model. Stakeholders relying on 2/3 + 1 safety guarantees face unexpected risks.

## Likelihood Explanation

**Exploitability: HIGH** - This vulnerability has multiple triggering scenarios:

1. **Natural Occurrence**: Network instability, infrastructure failures, maintenance windows, or connectivity issues commonly cause temporary participation drops below threshold. This requires no attacker action.

2. **Malicious Exploitation**: Attackers can deliberately induce the condition through:
   - Targeted DoS attacks against a subset of miners to reduce participation below MinersCountOfConsent
   - Network partitioning attacks (BGP hijacking, routing manipulation at ISP level)
   - Collusion among minority miners to withhold participation while one miner as extra block producer continues terminating rounds

**Attack Complexity: LOW** - Once participation drops below threshold (naturally or induced), the extra block producer automatically gains the ability to terminate rounds. The extra block producer is deterministically selected via `CalculateNextExtraBlockProducerOrder()` based on the first miner's signature, [12](#0-11)  so any miner can eventually become the terminator.

**Preconditions**: Only requires participation to drop below MinersCountOfConsent threshold and one of the participating miners to be selected as extra block producer (probability 1/participating_miners per round).

**Probability: MEDIUM to HIGH** - Production blockchain networks routinely experience participation fluctuations. The likelihood scales with network size, geographic distribution, and infrastructure diversity. Large, distributed networks are more vulnerable to temporary participation drops.

## Recommendation

Implement strict participation threshold validation before allowing round termination. Add a new validation provider:

```csharp
public class ParticipationThresholdValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        
        // Get miners who participated in the current round
        var minedMiners = baseRound.GetMinedMiners();
        var participationCount = minedMiners.Count;
        var requiredCount = baseRound.MinersCountOfConsent;
        
        if (participationCount < requiredCount)
        {
            validationResult.Message = 
                $"Insufficient participation for round termination. " +
                $"Required: {requiredCount}, Actual: {participationCount}";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this provider to the validation pipeline in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new ParticipationThresholdValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new ParticipationThresholdValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

This ensures Byzantine Fault Tolerance guarantees are enforced for all consensus state transitions, not just for finality.

## Proof of Concept

A complete test demonstrating this vulnerability would require a full AElf test harness with multiple miners. The test would:

1. Initialize a network with N miners (e.g., 21 miners, MinersCountOfConsent = 15)
2. Have only M miners participate in a round where M < MinersCountOfConsent (e.g., 10 miners)
3. Designate one participating miner as extra block producer
4. Call `NextRound` or `NextTerm` from that extra block producer
5. Verify the call succeeds without any participation threshold validation error
6. Observe that the round transitions despite insufficient participation

The vulnerability is confirmed by code inspection showing no `GetMinedMiners().Count >= MinersCountOfConsent` check exists in any validation or processing path for round termination.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```
