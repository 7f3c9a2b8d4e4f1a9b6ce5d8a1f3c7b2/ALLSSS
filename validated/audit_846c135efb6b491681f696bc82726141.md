# Audit Report

## Title
DOS Attack via Empty Period Creation Permanently Blocks Profit Claiming for Early Beneficiaries

## Summary
A malicious TokenHolder scheme manager can create empty distribution periods by repeatedly calling `DistributeProfits` with null or empty `AmountsMap`. This causes beneficiaries to become permanently unable to claim profits because the claiming logic skips empty periods without advancing their `LastProfitPeriod` marker, creating an insurmountable barrier that prevents access to both past and future profit distributions.

## Finding Description

The vulnerability stems from a critical logic flaw in how the profit claiming mechanism handles empty distribution periods.

**Attack Vector:**

Any user can create a TokenHolder scheme without authorization and become the scheme manager. [1](#0-0) 

The scheme manager is explicitly authorized to call `DistributeProfits`, and when `AmountsMap` is null or empty, no amounts are conditionally added but the function always proceeds to call the Profit contract and increment the period counter. [2](#0-1) 

**Empty Period Creation:**

In `ProfitContract.DistributeProfits`, when the input has an empty `AmountsMap` and the scheme has no `ReceivedTokenSymbols` yet (no prior contributions), the `profitsMap` dictionary remains empty. [3](#0-2) 

Despite the empty `profitsMap`, `UpdateDistributedProfits` is called and creates a `DistributedProfitsInfo` record with `IsReleased = true`, empty `AmountsMap`, but non-zero `TotalShares`. [4](#0-3) 

The scheme's period counter is always incremented regardless of whether any profits were distributed. [5](#0-4) 

**DOS Mechanism:**

When beneficiaries attempt to claim profits, the `ProfitAllPeriods` function initializes `lastProfitPeriod` to the beneficiary's current `LastProfitPeriod`, then loops through periods. [6](#0-5) 

The critical flaw occurs when the loop encounters an empty period (where `AmountsMap.Any()` returns false): the `continue` statement executes, skipping the remainder of the loop body. [7](#0-6) 

The line that updates `lastProfitPeriod = period + 1` appears AFTER the `continue` statement, meaning it never executes for empty periods. [8](#0-7) 

After the loop completes processing up to `maxProfitReceivingPeriodCount` periods (default 100), the beneficiary's `LastProfitPeriod` is set to the unchanged `lastProfitPeriod` value, making zero progress. [9](#0-8) [10](#0-9) 

**Attack Execution:**
1. Attacker creates a TokenHolder scheme (becomes scheme manager)
2. Adds beneficiaries to establish non-zero `TotalShares`
3. Before any contributions, calls `DistributeProfits` 1000 times with null `AmountsMap`
4. Each call creates one empty period (periods 1-1000 are now empty)
5. Later legitimate distributions at period 1001+ become unreachable
6. Beneficiaries attempting to claim process 100 empty periods per transaction without progress
7. Their `LastProfitPeriod` remains stuck at period 1 permanently

## Impact Explanation

This vulnerability creates a **permanent denial of service** for profit claiming with the following consequences:

**Permanent Loss of Rewards:**
- Beneficiaries with `StartPeriod` values within or before the empty period range cannot advance their claiming position
- Each claim transaction processes up to 100 periods but makes zero progress through empty periods
- Even if legitimate distributions occur in future periods, beneficiaries can never reach them

**No Recovery Mechanism:**
- No function exists to "skip" empty periods or reset `LastProfitPeriod`
- Beneficiaries are permanently locked out of the reward system
- Tokens locked by users for profit-sharing become worthless as rewards are inaccessible

**Complete Scheme Dysfunction:**
- The TokenHolder scheme becomes completely non-functional for early participants
- The attack affects the core functionality of the staking/reward mechanism

The severity is **HIGH** because it results in permanent, irreversible denial of earned rewards for all early beneficiaries, with no recovery path.

## Likelihood Explanation

The likelihood of this attack is **HIGH** due to:

**Low Barrier to Entry:**
- Any user can create a TokenHolder scheme and become the scheme manager without special permissions
- Creation and management of schemes is a standard protocol feature

**Trivial Attack Execution:**
- The attack requires only repeated calls to `DistributeProfits` with empty input
- No complex transaction sequences or timing requirements
- Each call costs minimal gas (just the transaction fee)
- Can create thousands of empty periods for negligible cost

**Lack of Protective Measures:**
- No validation prevents `DistributeProfits` calls with empty `AmountsMap`
- No rate limiting on distribution frequency
- No maximum empty period detection or prevention

**Realistic Attack Scenarios:**
- Malicious actors creating schemes, attracting users, then DOS'ing the claiming
- Griefing attacks to permanently disable profit distribution
- Compromised manager keys leading to immediate DOS of all beneficiaries

## Recommendation

Add validation in `TokenHolderContract.DistributeProfits` to prevent empty distributions:

```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // ADD THIS VALIDATION
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), "Cannot distribute with empty amounts.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

Additionally, modify `ProfitAllPeriods` to update `lastProfitPeriod` even when skipping empty periods:

```csharp
if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
    !distributedProfitsInformation.AmountsMap.Any() ||
    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
{
    lastProfitPeriod = period + 1;  // ADD THIS LINE
    continue;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPeriod_DOS_Attack_Test()
{
    // Setup: Create scheme and add beneficiary
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Shares = 100
    });
    
    // Attack: Create 200 empty periods (more than the 100 period limit)
    for (int i = 0; i < 200; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = Starter,
            AmountsMap = { }  // Empty map creates empty period
        });
    }
    
    // Now add legitimate distribution at period 201
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 10000
    });
    
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = Starter,
        AmountsMap = { { "ELF", 0L } }
    });
    
    // Attempt to claim: beneficiary should get profits but will fail
    var userTokenHolderStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    
    // First claim will process 100 empty periods (periods 1-100) and make zero progress
    await userTokenHolderStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = Starter
    });
    
    var tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = tokenHolderScheme.SchemeId,
        Beneficiary = UserAddresses.First()
    });
    
    // Verify: LastProfitPeriod is still at the start, not progressed
    profitDetails.Details.First().LastProfitPeriod.ShouldBeLessThan(100);
    
    // Second claim will process periods 1-100 again, still stuck
    await userTokenHolderStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = Starter
    });
    
    // Beneficiary can never reach period 201 where the real profits are
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses.First(),
        Symbol = "ELF"
    });
    
    // Balance should have increased by 10000 but will be unchanged (DOS attack successful)
    balance.Balance.ShouldBe((long)(TokenHolderContractTestConstants.NativeTokenTotalSupply * 0.1));
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L432-460)
```csharp
        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-850)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L868-871)
```csharp
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
