# Audit Report

## Title
Specific Delegation Permanently Shadows General Delegation After Delegatee Removal

## Summary
The transaction fee delegation system fails to properly fall back from specific delegation to general delegation when all delegatees are removed. An empty `TransactionFeeDelegatees` object (not null) is stored in state after removal, preventing the null coalescing operator from triggering the fallback to general delegation. This causes permanent DoS of transaction fee delegation for specific contract methods even when valid general delegations exist.

## Finding Description

The vulnerability exists in the delegation state management and fallback logic within the MultiToken contract's transaction fee delegation system.

**Root Cause - Unconditional Storage of Empty Objects:**

In `SetTransactionFeeDelegateInfos`, when a delegatee is removed due to empty delegations, the code removes the delegatee from the `Delegatees` dictionary but then unconditionally stores the parent `existDelegateeInfoList` object back to state. If this was the last delegatee, an empty `TransactionFeeDelegatees` object with an empty `Delegatees` dictionary is persisted. [1](#0-0) 

The same issue occurs in the removal helper method where the empty `delegateeInfo` is stored back to state after removing the last delegatee: [2](#0-1) 

**Broken Fallback Logic:**

The fee charging logic uses the null coalescing operator to fall back from specific to general delegation. In `TryToChargeTransactionFee`, the code attempts to retrieve specific delegation info first, then falls back to general delegation: [3](#0-2) 

The critical flaw: When `TransactionFeeDelegateInfoMap` returns an empty `TransactionFeeDelegatees` object, it is not null. The `??` operator only checks for null, so it returns the empty object instead of falling back to the general delegation map. The subsequent code attempts to iterate over empty delegatees and fails.

The same broken pattern exists in `ChargeFromDelegations` where it tries to access the `Delegatees` property: [4](#0-3) 

When an empty `TransactionFeeDelegatees` object exists, `?.Delegatees` returns an empty dictionary (not null), so the `??` operator doesn't trigger the fallback to general delegation.

**Execution Flow:**

1. User establishes general delegation via `SetTransactionFeeDelegations`
2. User creates specific delegation for a contract method via `SetTransactionFeeDelegateInfos`
3. User removes all delegatees from specific delegation (via `SetTransactionFeeDelegateInfos` with negative amounts or `RemoveTransactionFeeDelegateeInfos`)
4. Empty `TransactionFeeDelegatees` object stored in `TransactionFeeDelegateInfoMap[delegator][contract][method]`
5. Future transactions fail to charge from delegation because:
   - Specific delegation returns empty object (not null)
   - `?.Delegatees` returns empty dictionary (not null)
   - `??` operator doesn't trigger fallback
   - General delegation never consulted
   - Transaction fee charging fails

## Impact Explanation

**Severity: Medium/High - Permanent DoS of Transaction Fee Delegation**

This vulnerability creates a permanent denial-of-service condition for the transaction fee delegation feature:

1. **Transaction Failure:** Users who rely on delegation to pay transaction fees will be unable to execute transactions for specific contract methods, even when they have valid general delegations with sufficient funds.

2. **Permanent State Corruption:** Once an empty `TransactionFeeDelegatees` object is stored for a specific contract/method combination, that path is permanently "poisoned." The empty object persists in state and blocks all future fallback attempts to general delegation.

3. **No Recovery Path:** Users cannot recover from this state without a contract upgrade. Simply setting up new general or specific delegations won't fix the issue because the empty object will continue to shadow the general delegation.

4. **Protocol Reliability Impact:** This breaks the expected delegation hierarchy where specific delegations should only override general delegations when they contain valid delegatees. Empty specific delegations should allow fallback to general delegation.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can be triggered through normal, legitimate delegation management operations without any malicious intent:

**Accessible Entry Points:**
- `SetTransactionFeeDelegateInfos` - Public method for creating/updating specific delegations
- `RemoveTransactionFeeDelegateeInfos` - Public method for removing specific delegations
- `RemoveTransactionFeeDelegatorInfos` - Public method for delegatees to remove themselves

**Realistic Scenarios:**
1. A user tests specific delegations for a new dApp and later removes them, expecting fallback to general delegation
2. A delegatee becomes unavailable and the user removes them, intending to rely on general delegation temporarily
3. Users clean up old specific delegations thinking they're optimizing their delegation setup
4. Multiple delegatees are removed one by one until none remain

**No Special Requirements:**
- No privileged access required
- No attack cost
- No complex preconditions
- Purely a consequence of normal state management

**High Probability:** Users naturally create and remove delegations as they test different delegation configurations, manage their delegatee relationships, respond to delegatee availability changes, and clean up unused delegations.

## Recommendation

**Option 1: Check before storing (Preferred)**

Before storing the delegation info back to state, check if the `Delegatees` dictionary is empty. If it is empty, remove the entry from state entirely instead of storing an empty object:

```csharp
// In SetTransactionFeeDelegateInfos, after line 236:
if (existDelegateeInfoList.Delegatees.Count == 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = null;
}
else
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = existDelegateeInfoList;
}
```

Apply similar logic in `RemoveTransactionFeeDelegateInfo`.

**Option 2: Check for empty dictionary in fallback logic**

Modify the fallback logic to also check if the dictionary is empty:

```csharp
var delegationInfo =
    State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees;

if (delegationInfo == null || delegationInfo.Count == 0)
{
    delegationInfo = State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;
}
```

**Option 1 is preferred** as it prevents storing unnecessary empty objects in state and addresses the root cause.

## Proof of Concept

```csharp
[Fact]
public async Task SpecificDelegation_BlocksGeneralDelegation_AfterRemoval_Test()
{
    await Initialize();
    
    // Step 1: Set up general delegation
    var generalDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 1000,
        [BasicFeeSymbol] = 1000
    };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = User1Address,
            Delegations = { generalDelegations }
        });
    
    // Step 2: Set up specific delegation for a contract method
    var specificDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 500
    };
    var delegateInfo = new DelegateInfo
    {
        ContractAddress = BasicFunctionContractAddress,
        MethodName = "TestMethod",
        Delegations = { specificDelegations },
        IsUnlimitedDelegate = false
    };
    await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(
        new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = { delegateInfo }
        });
    
    // Step 3: Remove all delegatees from specific delegation
    var removeDelegations = new Dictionary<string, long>
    {
        [NativeToken] = -1  // Remove all
    };
    var removeDelegateInfo = new DelegateInfo
    {
        ContractAddress = BasicFunctionContractAddress,
        MethodName = "TestMethod",
        Delegations = { removeDelegations },
        IsUnlimitedDelegate = false
    };
    await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(
        new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = { removeDelegateInfo }
        });
    
    // Step 4: Verify that the specific delegation is empty
    var delegateeList = await TokenContractStub.GetTransactionFeeDelegateeList.CallAsync(
        new GetTransactionFeeDelegateeListInput
        {
            ContractAddress = BasicFunctionContractAddress,
            DelegatorAddress = User1Address,
            MethodName = "TestMethod"
        });
    delegateeList.DelegateeAddresses.Count.ShouldBe(0);  // Empty specific delegation
    
    // Step 5: Verify that general delegation still exists
    var generalDelegatees = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput
        {
            DelegatorAddress = User1Address
        });
    generalDelegatees.DelegateeAddresses.Count.ShouldBe(1);  // General delegation exists
    
    // Step 6: Attempt to charge transaction fee for the specific method
    // This should fall back to general delegation but will fail due to the bug
    var chargeResult = await TokenContractStub.ChargeTransactionFees.CallAsync(
        new ChargeTransactionFeesInput
        {
            ContractAddress = BasicFunctionContractAddress,
            MethodName = "TestMethod",
            TransactionSizeFee = 100
        });
    
    // BUG: This will return false even though general delegation has sufficient funds
    chargeResult.Success.ShouldBeFalse();  // Demonstrates the vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-245)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L379-386)
```csharp
            var delegateeInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                    delegateTransaction.MethodName];
            if (delegateeInfo == null || !delegateeInfo.Delegatees.ContainsKey(delegateeAddress)) continue;
            delegateeInfo.Delegatees.Remove(delegateeAddress);
            toCancelTransactionList.Value.Add(delegateTransaction);
            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                delegateTransaction.MethodName] = delegateeInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L100-102)
```csharp
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L174-176)
```csharp
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;
```
