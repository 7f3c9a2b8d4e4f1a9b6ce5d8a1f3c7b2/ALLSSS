# Audit Report

## Title
Referendum Contract Allows Setting Unbounded MinimalVoteThreshold Leading to Permanent Governance Lockout

## Summary
The Referendum contract's `ChangeOrganizationThreshold` function lacks upper bound validation for `MinimalVoteThreshold`, allowing an organization to set this value to `Int64.MaxValue` or any unreachably high number. This makes all future proposals impossible to release, permanently locking the organization's governance functionality. Unlike Parliament and Association contracts which enforce maximum threshold limits, Referendum has no such protection.

## Finding Description

The vulnerability exists in the threshold validation logic of the Referendum contract. When `ChangeOrganizationThreshold` is called, it updates the organization's `ProposalReleaseThreshold` and validates it using the `Validate` method. [1](#0-0) 

The `Validate` method only checks relative relationships between threshold values but imposes **no upper bound** on `MinimalVoteThreshold`: [2](#0-1) 

The validation only requires:
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- `MaximalAbstentionThreshold >= 0`
- `MaximalRejectionThreshold >= 0`

There is no check preventing `MinimalVoteThreshold` from being set to `Int64.MaxValue` (9,223,372,036,854,775,807).

When proposals attempt to release, the `IsReleaseThresholdReached` method checks if total votes meet the threshold: [3](#0-2) 

If `MinimalVoteThreshold` is set to `Int64.MaxValue`, the check will never be satisfied since the total token supply in any realistic scenario is far less than `Int64.MaxValue`.

**Contrast with Other Governance Contracts:**

The Parliament contract enforces an upper bound where `MinimalVoteThreshold` must be less than or equal to `AbstractVoteTotal`: [4](#0-3) 

The constant `AbstractVoteTotal` is defined as 10000: [5](#0-4) 

The Association contract enforces that `MinimalVoteThreshold` cannot exceed the organization member count: [6](#0-5) 

**Referendum contract is the only governance contract missing this critical validation.**

## Impact Explanation

**Severity: HIGH - Permanent Governance DoS**

Once an organization's `MinimalVoteThreshold` is set to an unreachable value, the organization's governance becomes **permanently non-functional**:

1. **Complete Governance Lockout**: All existing and future proposals can never be released because the vote threshold check in `IsReleaseThresholdReached` can never be satisfied.

2. **No Recovery Mechanism**: The `ChangeOrganizationThreshold` method requires `Context.Sender` to be the organization address itself, meaning it can ONLY be called through a proposal release via the virtual inline system contract call mechanism. [7](#0-6)  Since proposals cannot be released when the threshold is unreachable, the organization cannot fix its own thresholds. This creates an unrecoverable state.

3. **Affected Parties**: All members of the affected Referendum organization lose their governance rights permanently. Any critical operations that require governance approval (upgrades, parameter changes, fund releases) become impossible.

4. **Protocol Impact**: If critical protocol operations are controlled by Referendum organizations, this could impact the entire protocol's ability to adapt or upgrade.

The attack is **irreversible** and causes **total loss of governance functionality** for the affected organization.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH - Single Malicious Proposal Attack**

**Attacker Capabilities Required:**
- Must be in the organization's proposer whitelist (standard requirement for creating proposals)
- Must successfully pass one malicious proposal through the organization's current approval process

**Attack Complexity: LOW**
1. Attacker creates a proposal calling `ChangeOrganizationThreshold` with `MinimalVoteThreshold = Int64.MaxValue` and `MinimalApprovalThreshold = Int64.MaxValue`
2. The proposal needs to pass current voting thresholds (one-time requirement)
3. Attacker or any authorized party releases the proposal
4. Organization is permanently locked

**Feasibility Conditions:**
- **Social Engineering**: The attack could be disguised as a "security improvement" to increase voting requirements
- **Compromised Proposer**: A single compromised or malicious whitelisted proposer can initiate this attack
- **Majority Collusion**: If enough organization members collude, they can deliberately lock the organization

**Economic Cost: MINIMAL**
- Only requires gas fees to create and release one proposal
- No financial stake or capital requirements beyond normal proposal creation

**Detection Difficulty:**
- The malicious threshold change may not be immediately obvious
- Organizations may not realize they're locked until attempting to release the next proposal
- No automatic alerts or warnings exist for extreme threshold values

## Recommendation

Add upper bound validation to the Referendum contract's `Validate` method similar to Parliament and Association contracts. The fix should enforce a maximum reasonable value for `MinimalVoteThreshold`.

**Option 1 - Token Supply Based Cap (Recommended):**
```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), "Token not exists.");
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Add upper bound check based on token supply
    return proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.Supply &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

**Option 2 - Fixed Maximum Cap:**
Define a reasonable maximum threshold constant (e.g., similar to Parliament's approach) and enforce it in validation.

## Proof of Concept

```csharp
[Fact]
public async Task Referendum_UnboundedThreshold_PermanentLockout_Test()
{
    // Setup: Create a referendum organization
    const long minimalApproveThreshold = 5000;
    var organizationAddress = await CreateReferendumOrganizationAsync(minimalApproveThreshold);
    
    // Attack: Create proposal to set threshold to Int64.MaxValue
    var maliciousThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = long.MaxValue,
        MinimalApprovalThreshold = long.MaxValue,
        MaximalRejectionThreshold = 0,
        MaximalAbstentionThreshold = 0
    };
    
    var maliciousProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        maliciousThreshold,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress
    );
    
    // Approve and release the malicious proposal
    await ApproveAllowanceAsync(DefaultSenderKeyPair, minimalApproveThreshold, maliciousProposalId);
    await ApproveAsync(Accounts[0].KeyPair, maliciousProposalId);
    
    var releaseResult = await ReferendumContractStub.Release.SendAsync(maliciousProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Organization is now permanently locked
    // Any new proposal can never reach the threshold
    var recoveryProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        new ProposalReleaseThreshold { MinimalVoteThreshold = 1000, MinimalApprovalThreshold = 1000 },
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress
    );
    
    // Even with maximum approval, proposal cannot be released
    await ApproveAllowanceAsync(DefaultSenderKeyPair, long.MaxValue / 2, recoveryProposalId);
    await ApproveAsync(Accounts[0].KeyPair, recoveryProposalId);
    
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(recoveryProposalId);
    proposal.ToBeReleased.ShouldBeFalse(); // Permanently locked - cannot release any proposal
}
```

## Notes

This vulnerability is particularly severe because:
1. It affects the **availability** of governance operations, not just authorization
2. The lockout is **permanent and irreversible** with no recovery mechanism
3. Unlike Parliament and Association which have similar architecture but proper validation, Referendum uniquely lacks this protection
4. The test suite at lines 718-760 of `ReferendumContractTest.cs` tests changing thresholds but does not include boundary validation tests for extremely high values

The vulnerability demonstrates a critical oversight where Referendum diverged from the secure patterns established in Parliament and Association contracts without implementing equivalent safeguards.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
