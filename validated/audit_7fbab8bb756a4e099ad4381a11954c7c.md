# Audit Report

## Title
Incorrect Threshold Validation in Secret Sharing Reconstruction Causes Consensus Corruption During Miner List Transitions

## Summary
The `RevealSharedInValues()` function in the AEDPoS consensus contract uses the current round's miner count to calculate the decoding threshold for Shamir's secret sharing, but the secrets were encoded using the previous round's miner count. When the miner list shrinks between rounds, this threshold mismatch causes secret reconstruction to produce mathematically incorrect in-values, corrupting consensus state across the entire network. [1](#0-0) 

## Finding Description

The vulnerability exists in the `RevealSharedInValues()` function where threshold calculation uses the wrong round's miner count. The function receives `currentRound` as a parameter and retrieves `previousRound` from state, but then incorrectly uses the current round's miner count to calculate the decoding threshold. [2](#0-1) 

**Root Cause Analysis:**

During secret encoding in the previous round, the off-chain `SecretSharingService` correctly uses the previous round's miner count: [3](#0-2) 

This encoding creates a Shamir Secret Sharing polynomial of degree `threshold - 1`, requiring at least `threshold` pieces to reconstruct the original secret: [4](#0-3) 

The decoding uses Lagrange interpolation with exactly `threshold` points: [5](#0-4) 

**Execution Path:**

The vulnerable function is called during NextRound consensus behavior: [6](#0-5) 

**Miner List Changes:**

Miner list changes occur through multiple mechanisms:

1. **Side Chain Main Chain Synchronization:** [7](#0-6) 

2. **Evil Miner Replacement:** [8](#0-7) 

3. **Term Transitions:** [9](#0-8) 

**Attack Scenario:**

When the miner list shrinks (e.g., from 10 to 7 miners):
1. Round N-1: 10 miners encode secrets with threshold = `10 * 2 / 3 = 6` pieces
2. Round N: Miner list changes to 7 miners
3. During Round N+1 creation, `RevealSharedInValues` is called:
   - Uses `currentRound` (Round N with 7 miners) to calculate threshold = `7 * 2 / 3 = 4`
   - Attempts to decode Round N-1 secrets (requiring 6 pieces) with only 4 pieces
4. The validation check on line 36 fails to detect this: `DecryptedPieces.Count (10) < minersCount (7)` â†’ False, proceeds
5. `DecodeSecret` executes Lagrange interpolation with 4 points instead of required 6 points
6. Produces a mathematically incorrect value (deterministic but wrong)

## Impact Explanation

**HIGH Severity** - This vulnerability corrupts core consensus data during normal protocol operations:

1. **Consensus Data Corruption**: In Shamir's Secret Sharing, using fewer pieces than the encoding threshold cannot reconstruct the original secret. The Lagrange interpolation will produce a completely different value. The reconstructed `PreviousInValue` values will be mathematically incorrect.

2. **Deterministic Network-Wide Failure**: All nodes execute identical (but incorrect) reconstruction logic, leading to network-wide consensus state corruption. The network reaches consensus on wrong values rather than detecting the error through disagreement.

3. **Critical Consensus Components Affected**: The `PreviousInValue` field is fundamental to:
   - Signature validation in the consensus mechanism
   - Random number generation for block production scheduling
   - Consensus integrity verification and audit trails

4. **Protocol Invariant Violation**: The core invariant that "decoded secrets must equal encoded secrets" is violated, breaking the security foundation of the verifiable random function (VRF) system.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability triggers automatically during normal protocol operations:

1. **No Attacker Required**: Miner list changes occur naturally through governance and election mechanisms. The bug triggers during standard consensus operations without malicious intervention.

2. **Common Triggering Conditions**:
   - Term transitions occur regularly (typically every 7 days)
   - Evil miner replacement happens when miners miss time slots
   - Side chain main chain miner list synchronization occurs continuously
   - Miner list reductions are expected in election dynamics

3. **Direct Execution Path**: The vulnerable code path is directly reachable through standard NextRound consensus block production behavior, which occurs every round.

4. **No Privilege Required**: The vulnerability triggers during normal miner block production operations without requiring any special privileges or permissions.

## Recommendation

Fix the threshold calculation in `RevealSharedInValues()` to use the previous round's miner count instead of the current round's:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");

    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

    // FIX: Use previousRound miner count for threshold calculation
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;

    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // Skip himself.
        if (pair.Key == publicKey) continue;

        if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

        var publicKeyOfAnotherMiner = pair.Key;
        var anotherMinerInPreviousRound = pair.Value;

        if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
        if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

        // Reveal another miner's in value for target round:
        var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                previousRound.RealTimeMinersInformation.Values
                    .First(m => m.Pubkey ==
                                anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
            .ToList();

        var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
            .Select(s => s.ToByteArray()).ToList();

        var revealedInValue =
            HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

        currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
    }
}
```

This ensures the decoding threshold matches the encoding threshold used in the previous round.

## Proof of Concept

```csharp
[Fact]
public void ThresholdMismatch_ProducesIncorrectSecretReconstruction()
{
    // Simulate Round N-1 with 10 miners encoding secrets
    var originalSecret = HashHelper.ComputeFrom("test_secret").ToByteArray();
    var encodingMinersCount = 10;
    var encodingThreshold = encodingMinersCount.Mul(2).Div(3); // = 6
    
    var secretShares = SecretSharingHelper.EncodeSecret(
        originalSecret, 
        encodingThreshold, 
        encodingMinersCount
    );
    
    // Simulate Round N with 7 miners (miner list shrunk)
    var decodingMinersCount = 7;
    var decodingThreshold = decodingMinersCount.Mul(2).Div(3); // = 4 (WRONG!)
    
    // Attempt to decode with wrong threshold
    var orders = Enumerable.Range(1, decodingThreshold).ToList();
    var incorrectResult = SecretSharingHelper.DecodeSecret(
        secretShares.Take(decodingThreshold).ToList(),
        orders,
        decodingThreshold
    );
    
    // Verify the decoded value is INCORRECT
    incorrectResult.ShouldNotBe(originalSecret);
    
    // Verify correct decoding with proper threshold works
    var correctOrders = Enumerable.Range(1, encodingThreshold).ToList();
    var correctResult = SecretSharingHelper.DecodeSecret(
        secretShares.Take(encodingThreshold).ToList(),
        correctOrders,
        encodingThreshold
    );
    
    correctResult.ShouldBe(originalSecret);
}
```

## Notes

The off-chain `SecretSharingService.RevealPreviousInValues` correctly uses the previous round's miner count for threshold calculation: [10](#0-9) 

However, the on-chain contract implementation has the opposite logic, creating an inconsistency that leads to consensus corruption when miner lists change. This discrepancy between off-chain and on-chain logic is a critical design flaw.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-149)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L14-41)
```csharp
        public static List<byte[]> EncodeSecret(byte[] secretMessage, int threshold, int totalParts)
        {
            // Polynomial construction.
            var coefficients = new BigInteger[threshold];
            // Set p(0) = secret message.
            coefficients[0] = secretMessage.ToBigInteger();
            for (var i = 1; i < threshold; i++)
            {
                var foo = new byte[32];
                Array.Copy(HashHelper.ComputeFrom(Guid.NewGuid().ToByteArray()).ToArray(), foo, 32);
                coefficients[i] = BigInteger.Abs(new BigInteger(foo));
            }

            var result = new List<byte[]>();
            for (var i = 1; i < totalParts + 1; i++)
            {
                var secretBigInteger = coefficients[0];
                for (var j = 1; j < threshold; j++)
                {
                    secretBigInteger += coefficients[j] * BigInteger.Pow(new BigInteger(i), j);
                    secretBigInteger %= SecretSharingConsts.FieldPrime;
                }

                result.Add(secretBigInteger.ToByteArray());
            }

            return result;
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-189)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-342)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```
