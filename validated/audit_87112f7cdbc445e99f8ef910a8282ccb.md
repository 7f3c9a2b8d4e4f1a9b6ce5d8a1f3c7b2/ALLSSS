# Audit Report

## Title
Association Governance Bypass via Post-Vote Membership Manipulation

## Summary
The Association contract contains a critical inconsistency in vote counting logic within the `CheckEnoughVoteAndApprovals` helper function. While rejection, abstention, and approval counts are filtered by current organization membership, the total vote threshold check counts ALL historical votes regardless of membership status. This allows organizations to bypass `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` constraints by removing members after they vote.

## Finding Description

The vulnerability exists in the threshold validation logic used by the `Release()` function to determine if a proposal can be executed. The root cause is inconsistent membership filtering across different vote counting operations. [1](#0-0) 

The rejection count correctly filters by current membership using `.Count(organization.OrganizationMemberList.Contains)`. [2](#0-1) 

The abstention count correctly filters by current membership using the same pattern. [3](#0-2) 

However, in `CheckEnoughVoteAndApprovals`, while the approval count is correctly filtered at line 49, the total vote count at lines 55-57 does NOT filter by membership - it simply concatenates all vote lists and counts them without checking if voters are still organization members.

**Attack Sequence:**

1. A proposal (Proposal A) is created with votes: 2 approvals (M1, M2), 2 rejections (M3, M4), 1 abstention (M5)
2. With `MaximalRejectionThreshold = 1`, the proposal is blocked (2 rejections > 1 threshold)
3. Organization passes a `RemoveMember` proposal to remove M3 and M4 [4](#0-3) 

4. When `Release()` is called on Proposal A: [5](#0-4) 

5. The validation checks against the current membership list:
   - `IsProposalRejected`: 0 rejections (M3, M4 removed) → passes
   - `IsProposalAbstained`: 1 abstention (M5 still member) → passes  
   - `CheckEnoughVoteAndApprovals`: 2 approvals from current members → passes, AND total votes = 5 (still counts removed members) → passes `MinimalVoteThreshold`
6. Proposal A is now released despite originally being blocked [6](#0-5) 

The `Validate()` function only checks threshold consistency at organization creation time and does not prevent retroactive manipulation. [7](#0-6) 

## Impact Explanation

This vulnerability has **HIGH severity** impact because:

1. **Direct Governance Bypass**: Organizations can execute proposals that were legitimately blocked by `MaximalAbstentionThreshold` or `MaximalRejectionThreshold` protections. These thresholds are fundamental governance safeguards.

2. **Violation of Governance Invariants**: The contract explicitly provides threshold mechanisms to protect against contentious proposals. This bug completely undermines this protection, allowing minority factions to force through proposals that the broader membership rejected or abstained from.

3. **Widespread Applicability**: Any Association-based organization using abstention or rejection thresholds is vulnerable. This affects all downstream contracts and systems governed by these organizations.

4. **Trust Model Breach**: Members who voted to block a proposal lose their governance power retroactively, fundamentally breaking the multi-signature governance model.

While this does not directly result in fund loss, it enables **unauthorized proposal execution** that could lead to arbitrary state changes, configuration modifications, or other governance-controlled actions.

## Likelihood Explanation

This vulnerability has **MEDIUM-to-HIGH likelihood** of exploitation:

**Attacker Capabilities Required:**
- Control sufficient organization members to pass a `RemoveMember` proposal (achievable if the attacker faction has near-majority support)
- Ability to coordinate timing between member removal and target proposal release
- Only uses standard contract methods available to any organization member

**Attack Complexity:**
- **LOW**: Requires only two standard governance operations (target proposal + member removal proposal)
- No special permissions beyond normal member voting rights
- No strict timing constraints beyond standard proposal expiration periods
- Uses legitimate governance mechanisms, making it difficult to detect

**Feasibility Conditions:**
- Organizations must have configured `MaximalAbstentionThreshold` or `MaximalRejectionThreshold` (common for security-conscious setups)
- Target proposal must be blocked by exceeding these thresholds
- Attacker faction must have sufficient votes to pass a removal proposal

## Recommendation

The total vote count in `CheckEnoughVoteAndApprovals` should filter by current membership to maintain consistency with all other vote counting operations. 

**Fixed code:**
```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership
    var totalVoteCount = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    var isVoteThresholdReached =
        totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task GovernanceBypass_RemoveMembersAfterVoting()
{
    // Setup: 5 members, thresholds configured
    var minimalApproveThreshold = 2;
    var minimalVoteThreshold = 4;
    var maximalAbstentionThreshold = 1;
    var maximalRejectionThreshold = 1;
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold, minimalVoteThreshold,
        maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
    
    // Create target proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Vote: 2 approvals, 2 rejections, 1 abstention
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await RejectAsync(Reviewer3KeyPair, proposalId);
    // Additional member needed - assume Reviewer4 rejects and Reviewer5 abstains
    
    // Proposal should be blocked due to 2 rejections > maximalRejectionThreshold (1)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeFalse();
    
    // Create and pass RemoveMember proposals for Reviewer3 and Reviewer4
    var removeMemberProposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, Reviewer3, nameof(AssociationContractStub.RemoveMember), organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, removeMemberProposal);
    await ApproveAsync(Reviewer2KeyPair, removeMemberProposal);
    await AssociationContractStub.Release.SendAsync(removeMemberProposal);
    
    // Check original proposal again - should now pass due to vulnerability
    proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: Proposal bypasses rejection threshold
}
```

## Notes

This vulnerability fundamentally breaks the governance security model by allowing retroactive manipulation of vote thresholds through member removal. The inconsistency between filtered vote type counts and unfiltered total vote counts creates an exploitable bypass that undermines the purpose of `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` safeguards.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
