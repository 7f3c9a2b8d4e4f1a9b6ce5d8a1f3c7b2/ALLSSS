# Audit Report

## Title
Inconsistent Time Slot Validation Allows Consensus Disruption via Non-Uniform Mining Intervals

## Summary
The AEDPoS consensus contract contains a critical validation flaw where `CheckRoundTimeSlots` permits mining intervals up to 2x the base interval due to an off-by-one tolerance check, while `GetMiningInterval` only examines the first two miners. This mismatch allows any miner to inject non-uniform round data that passes validation but causes consensus disruption by creating time windows where miners are incorrectly blocked from producing blocks.

## Finding Description

The vulnerability stems from three interconnected flaws in the consensus round validation and consumption logic:

**Root Cause 1: Off-by-One Error in Tolerance Validation**

The `CheckRoundTimeSlots` method uses an overly permissive tolerance check. [1](#0-0) 

The condition `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval` only fails when the absolute difference **exceeds** the base interval. When the difference **equals** the base interval (i.e., interval is exactly 2x the base), validation passes. For example, with baseMiningInterval = 4000ms, an interval of 8000ms passes because |8000 - 4000| = 4000, and 4000 > 4000 is false.

**Root Cause 2: Incomplete Interval Calculation**

The `GetMiningInterval` method only examines miners with Order 1 and 2 to determine the mining interval. [2](#0-1) 

This creates a fundamental mismatch: validation checks all consecutive miner pairs, but the returned interval only reflects the first two miners' spacing, ignoring potentially different intervals for subsequent miners.

**Root Cause 3: Missing Canonical Round Verification**

The `PreCheck` method only verifies that the transaction sender is in the current or previous round's miner list. [3](#0-2) 

No verification exists that the submitted `NextRoundInput` matches the canonical output of `GenerateNextRoundInformation`, which always produces uniform intervals. [4](#0-3) 

The validation providers for NextRound behavior do not verify canonical generation. [5](#0-4) 

**Exploitation Mechanism:**

A malicious miner crafts a `NextRoundInput` with non-uniform intervals (e.g., Orders at T+4000, T+8000, T+16000). The `TimeSlotValidationProvider` calls `CheckRoundTimeSlots` during validation. [6](#0-5) 

With intervals [4000ms, 8000ms], validation passes because both |4000-4000|=0 ≤ 4000 and |8000-4000|=4000 ≤ 4000. The malicious round is stored via `ProcessNextRound`. [7](#0-6) 

**Downstream Impact:**

Multiple critical functions break with non-uniform data:

1. **IsCurrentMiner Time Window Calculation**: Uses `GetMiningInterval()` to determine if a miner's time slot is active. [8](#0-7) 

   For Miner Order 3 with actual 8000ms interval but `GetMiningInterval()` returning 4000ms, the valid window is calculated as [T+16000, T+20000] instead of [T+16000, T+24000], creating a 4000ms gap where the miner cannot produce blocks.

2. **CheckMinerTimeSlot Validation**: Uses the incorrect mining interval to validate time slots. [9](#0-8) 

   This prematurely marks slots as passed, blocking legitimate mining attempts.

3. **IsTimeSlotPassed**: Incorrectly determines if a miner's slot has expired. [10](#0-9) 

4. **ArrangeAbnormalMiningTime**: Calculates incorrect future mining times for recovery. [11](#0-10) 

## Impact Explanation

**Severity: High - Consensus Integrity Violation and Partial DoS**

The vulnerability enables a malicious miner to violate the fundamental consensus invariant that all miners have equal, uniform time slots. This creates time windows where legitimate miners are incorrectly blocked from producing blocks, causing:

- **Consensus disruption**: Breaks the uniform time slot guarantee, a core consensus invariant
- **Block production failures**: Affected miners cannot mine during gap periods due to validation failures
- **Network-wide impact**: All nodes enforce the malicious round data, affecting the entire network simultaneously
- **Repeatable attack**: Can be executed every round with deterministic results
- **No automatic recovery**: Requires manual intervention or honest miner's NextRound to fix

While not a complete network halt (other miners in different slots can still produce blocks), it significantly degrades consensus reliability and can cause extended periods where specific miners are unable to fulfill their block production duties, potentially leading to missed blocks and reduced network throughput.

## Likelihood Explanation

**Likelihood: High**

**Attacker Prerequisites:**
- Must be a valid miner in the current or previous round (common condition - multiple miners exist)
- Ability to submit transactions to the consensus contract (standard miner capability)

**Attack Complexity: Low**
- Deterministic exploitation at the 2x tolerance boundary
- No timing dependencies or race conditions
- Single transaction execution
- No coordination with other parties required

**Feasibility: High**
- Miners can craft custom consensus extra data via `GetConsensusExtraDataForNextRound` [12](#0-11) 
- Validation occurs via `ValidateConsensusBeforeExecution` but doesn't verify canonical generation [13](#0-12) 
- No additional authorization beyond miner status required
- Validation providers check order and round number but not time slot uniformity correctness [14](#0-13) 

**Detection Difficulty:**
- Appears as valid round data during validation
- Only manifests as failures when affected miners attempt to mine
- No proactive detection in validation logic

## Recommendation

**Fix 1: Correct the Tolerance Check**
Change the tolerance condition to use `>=` instead of `>`:
```csharp
if (Math.Abs(miningInterval - baseMiningInterval) >= baseMiningInterval)
    return new ValidationResult { Message = "Time slots are so different." };
```

**Fix 2: Enhance GetMiningInterval Validation**
Add verification that ALL consecutive intervals match the base interval, not just the first pair.

**Fix 3: Add Canonical Round Verification**
Implement a validation provider that verifies the submitted `NextRoundInput` matches the output of `GenerateNextRoundInformation` for the given current round state. This ensures miners cannot inject arbitrary round data.

**Fix 4: Strengthen TimeSlotValidationProvider**
Add explicit checks that all miner time slots follow the pattern: `ExpectedMiningTime[i] = RoundStartTime + (Order[i] * MiningInterval)` where MiningInterval is constant for all miners.

## Proof of Concept

```csharp
// POC: Demonstrate malicious round acceptance
public void TestMaliciousNonUniformRoundAcceptance()
{
    // Setup: 3 miners in current round
    var currentRound = CreateRoundWithUniformIntervals(3, 4000); // 4000ms intervals
    
    // Attack: Craft NextRoundInput with non-uniform intervals
    var maliciousNextRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    var baseTime = Timestamp.FromDateTime(DateTime.UtcNow);
    maliciousNextRound.RealTimeMinersInformation.Add("Miner1", new MinerInRound 
    { 
        Pubkey = "Miner1", 
        Order = 1, 
        ExpectedMiningTime = baseTime.AddMilliseconds(4000) // T+4000
    });
    maliciousNextRound.RealTimeMinersInformation.Add("Miner2", new MinerInRound 
    { 
        Pubkey = "Miner2", 
        Order = 2, 
        ExpectedMiningTime = baseTime.AddMilliseconds(8000) // T+8000 (4000ms gap)
    });
    maliciousNextRound.RealTimeMinersInformation.Add("Miner3", new MinerInRound 
    { 
        Pubkey = "Miner3", 
        Order = 3, 
        ExpectedMiningTime = baseTime.AddMilliseconds(16000) // T+16000 (8000ms gap!)
    });
    
    // Verify: CheckRoundTimeSlots INCORRECTLY passes
    var validationResult = maliciousNextRound.CheckRoundTimeSlots();
    Assert.True(validationResult.Success); // Should fail but passes!
    
    // Verify: GetMiningInterval returns wrong value
    var miningInterval = maliciousNextRound.GetMiningInterval();
    Assert.Equal(4000, miningInterval); // Returns 4000ms (from Order 1-2)
    
    // Impact: Miner3's actual slot is 8000ms but GetMiningInterval says 4000ms
    // At T+20000, Miner3 is blocked from mining even though actual slot is until T+24000
    var miner3ExpectedTime = maliciousNextRound.RealTimeMinersInformation["Miner3"].ExpectedMiningTime;
    var miner3EndTime = miner3ExpectedTime.AddMilliseconds(miningInterval); // T+20000
    // Actual end should be: T+24000 (ExpectedMiningTime + 8000ms actual interval)
    // Gap from T+20000 to T+24000 where Miner3 cannot mine!
}
```

## Notes

This vulnerability represents a critical consensus invariant violation. The off-by-one error in the tolerance check, combined with the limited scope of `GetMiningInterval`, creates an exploitable inconsistency that allows miners to inject malicious round data. The impact on consensus integrity and block production reliability is significant, warranting immediate remediation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L49-55)
```csharp
        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L44-50)
```csharp
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-167)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
