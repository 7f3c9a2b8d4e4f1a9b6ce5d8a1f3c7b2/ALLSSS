# Audit Report

## Title
Missing LIB Validation in NextRound/NextTerm Allows Manipulation of Consensus Irreversible Block Height

## Summary
The `LibInformationValidationProvider` is only applied to `UpdateValue` consensus behavior, leaving `NextRound` and `NextTerm` behaviors without validation of Last Irreversible Block (LIB) height fields. A malicious miner can artificially inflate `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` when producing NextRound or NextTerm blocks, causing the consensus contract to store manipulated LIB values that suppress legitimate LIB updates until real consensus catches up, delaying blockchain finality.

## Finding Description

**Validation Gap in Consensus Behaviors**

The validation logic selectively applies LIB validation only to `UpdateValue` behavior. The `LibInformationValidationProvider` is conditionally added to the validation chain based on consensus behavior: [1](#0-0) 

For `UpdateValue` behavior, `LibInformationValidationProvider` validates that LIB values don't regress: [2](#0-1) 

However, for `NextRound` and `NextTerm` behaviors, only `RoundTerminateValidationProvider` is used, which validates round/term number increments but NOT LIB fields: [3](#0-2) 

**NextRound/NextTerm Include Full LIB Data**

Both `NextRoundInput` and `NextTermInput` include and preserve LIB fields through their conversion methods: [4](#0-3) [5](#0-4) 

The same pattern exists for `NextTermInput`: [6](#0-5) 

**Direct Storage Without Validation**

When processing NextRound, the input is directly converted to a Round object and stored without validating LIB fields: [7](#0-6) [8](#0-7) 

The `AddRoundInformation` method stores the round directly to state: [9](#0-8) 

**Legitimate LIB Update Suppression**

The LIB calculation and update logic in `ProcessUpdateValue` only advances LIB if the calculated value exceeds the stored value: [10](#0-9) 

The check at line 272 prevents LIB updates when an inflated stored value exceeds the legitimately calculated LIB. The `IrreversibleBlockFound` event is only fired when this condition passes.

**UpdateValue Validation is Ineffective**

The simplified Round used for UpdateValue behavior omits LIB fields entirely: [11](#0-10) 

Since `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` are not copied, they default to 0, causing the validation to short-circuit at the first condition check.

**Attack Execution Path**

1. Miner becomes extra block producer (rotates among miners)
2. System generates NextRound data with legitimate LIB values via `GenerateNextRoundInformation`: [12](#0-11) 

3. Attacker modifies the Round object before creating `NextRoundInput`, inflating LIB values
4. Block passes validation (no `LibInformationValidationProvider` for NextRound)
5. `ProcessNextRound` stores manipulated values
6. Subsequent `ProcessUpdateValue` calls cannot advance LIB due to the suppression check

## Impact Explanation

**HIGH SEVERITY - Consensus Integrity Violation**

1. **Delayed Finality**: The Last Irreversible Block height is a critical consensus parameter that determines when blocks become irreversible. By artificially inflating this value, legitimate LIB updates calculated from miner consensus are suppressed for an extended period, creating a finality gap where blocks that should become irreversible remain in a reversible state.

2. **Event Suppression**: No `IrreversibleBlockFound` events are fired during the suppression period. This event is consumed by the blockchain service to update the chain's system-wide LIB marker, so the entire network's finality tracking is affected.

3. **Mining Parameter Manipulation**: The inflated LIB directly affects `GetMaximumBlocksCount`, which uses stored LIB values to evaluate blockchain mining status: [13](#0-12) 

This can cause incorrect throttling or allowance of block production based on falsified consensus state.

4. **Cross-Chain Impact**: Cross-chain operations depend on accurate LIB heights for parent/side chain indexing and merkle proof verification. An artificially inflated LIB could cause cross-chain message verification to incorrectly accept or reject proofs.

## Likelihood Explanation

**MEDIUM-HIGH - Feasible for Any Miner**

1. **Accessible Entry Point**: Any valid miner in the current round can execute this attack when they become the extra block producer. The extra block producer role rotates through miners, providing regular opportunities.

2. **Low Attack Requirements**: 
   - Attacker only needs to be a valid miner (standard participation requirement)
   - No special privileges required beyond normal miner capabilities
   - Attack is a simple data modification before transaction creation

3. **No Technical Barriers**: The miner controls the Round object passed to `NextRoundInput.Create()` during transaction generation: [14](#0-13) 

4. **Difficult Detection**: Without comparing the consensus contract's LIB against the blockchain service's LIB or analyzing event logs for gaps in `IrreversibleBlockFound` events, the manipulation is difficult to detect.

5. **Economic Rationality**: Low cost (just modification of header data) with high impact (delays finality for all network participants, potentially enabling double-spend windows or disrupting cross-chain operations).

## Recommendation

**Immediate Fix**: Apply `LibInformationValidationProvider` to NextRound and NextTerm behaviors in addition to UpdateValue.

Modify the validation logic in `AEDPoSContract_Validation.cs`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

**Additional Hardening**: Consider recalculating LIB fields in `ProcessNextRound` and `ProcessNextTerm` rather than trusting the input values, similar to how UpdateValue blocks calculate LIB from actual miner consensus.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploying a test consensus contract with multiple miners
2. Advancing to a round where the test miner becomes extra block producer
3. Creating a NextRound transaction with inflated `ConfirmedIrreversibleBlockHeight` (e.g., current LIB + 500)
4. Submitting the block and observing it passes validation
5. Attempting subsequent UpdateValue blocks and observing that legitimate LIB updates are suppressed
6. Verifying no `IrreversibleBlockFound` events are fired despite blocks being produced
7. Confirming `GetMaximumBlocksCount` returns incorrect values based on the inflated LIB

The key test assertion would verify that after a malicious NextRound block, the stored `ConfirmedIrreversibleBlockHeight` equals the inflated value rather than the legitimate calculated value, and that subsequent blocks cannot advance the LIB until real consensus catches up to the inflated value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-111)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-34)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-26)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```
