# Audit Report

## Title
Last Irreversible Block Height Calculation Fails When Miner Set Changes Due to Mismatched Consensus Threshold

## Summary
The `LastIrreversibleBlockHeightCalculator` uses the current round's miner count to calculate the consensus threshold (`MinersCountOfConsent`), but queries implied irreversible block heights from the previous round. When the miner set changes significantly at term transitions, new miners have no entries in the previous round, making it impossible to meet the threshold and causing LIB to remain at zero.

## Finding Description

The vulnerability exists due to a logical inconsistency in how the LIB calculator determines consensus thresholds versus the data source it queries.

The `LastIrreversibleBlockHeightCalculator` constructor accepts both current and previous rounds, but the threshold calculation uses the current round's miner count while the data source is the previous round's miner information. [1](#0-0) 

The `MinersCountOfConsent` property calculates the Byzantine fault tolerance threshold as `(count * 2 / 3) + 1` based on `RealTimeMinersInformation.Count` of the round it's called on. [2](#0-1) 

The critical flaw occurs in the `Deconstruct` method where it checks if the count of heights collected from the previous round meets the threshold calculated from the current round. [3](#0-2) 

The `GetSortedImpliedIrreversibleBlockHeights` method filters by miners that exist in the round's `RealTimeMinersInformation` - meaning it can only return heights for miners present in the previous round. [4](#0-3) 

When a term changes, the first round of the new term is generated with a potentially different miner set and `IsMinerListJustChanged = true`. [5](#0-4) 

During block production in the new term, `ProcessUpdateValue` invokes the LIB calculator. [6](#0-5) 

The `IsMinerListJustChanged` flag is set during term transitions but is never checked by the LIB calculator, meaning the threshold calculation does not adjust for miner set changes. [7](#0-6) 

**Concrete Scenario:**
- Previous round (Term N): 5 miners {A, B, C, D, E}
- Current round (Term N+1): 7 miners {A, B, C, F, G, H, I} (overlap: 3 miners)
- MinersCountOfConsent = 7 * 2/3 + 1 = 5
- Maximum heights retrievable from previous round = 3 (only {A, B, C} exist in both)
- Check: 3 < 5 → fails → `libHeight = 0`

The LIB cannot advance because the threshold of 5 can never be met with only 3 overlapping miners.

## Impact Explanation

**Consensus Integrity:** The Last Irreversible Block (LIB) is a critical consensus property that marks blocks as finalized and immutable. When LIB fails to advance, the fundamental guarantee of transaction finality is broken.

**Cross-Chain Operations:** Cross-chain indexing and verification explicitly depend on LIB confirmation. When LIB remains at zero, cross-chain data cannot be indexed and parent-side chain communication is blocked. The `IrreversibleBlockFound` event that triggers cross-chain cache updates is not fired when LIB calculation returns zero. [8](#0-7) 

**Operational Availability:** The issue creates a denial-of-service condition affecting:
- All cross-chain transfers and merkle proof verification
- Side chain synchronization with parent chain consensus
- Transaction finality confirmations for external systems

**Severity Justification:** This is HIGH severity because:
1. It breaks a core consensus invariant (LIB must continuously advance)
2. Cross-chain functionality is completely blocked during affected rounds
3. The issue affects the entire network, not individual users
4. It occurs naturally without attacker intervention at every significant miner set change

## Likelihood Explanation

**Trigger Conditions:** The issue is triggered automatically during normal protocol operations when:
- A term change occurs via `ProcessNextTerm`
- The new miner set has insufficient overlap with the previous set
- Specifically when: `new_miners - overlap_miners > old_miners / 3`

**Feasibility:** The election system allows arbitrary miner set composition based on voting results. [9](#0-8) 

**Frequency:** Term changes occur periodically according to the term interval configuration. Tests demonstrate that miner counts can change significantly between terms. [10](#0-9) 

**Probability Assessment:**
- Guaranteed when miner count increases and turnover exceeds 1/3
- More likely when maximum miner count changes upward
- Higher probability with competitive elections where top candidates vary
- No circuit breakers or detection mechanisms prevent the condition

## Recommendation

The fix should detect when `IsMinerListJustChanged = true` and adjust the consensus threshold accordingly. When the miner list changes, use the smaller of the two sets for threshold calculation:

```csharp
public void Deconstruct(out long libHeight)
{
    if (_currentRound.IsEmpty || _previousRound.IsEmpty) 
    {
        libHeight = 0;
        return;
    }

    var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
    
    // Adjust threshold when miner list changes
    int requiredConsent = _currentRound.IsMinerListJustChanged 
        ? Math.Min(_currentRound.MinersCountOfConsent, _previousRound.MinersCountOfConsent)
        : _currentRound.MinersCountOfConsent;
    
    if (impliedIrreversibleHeights.Count < requiredConsent)
    {
        libHeight = 0;
        return;
    }

    libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
}
```

This ensures that during term transitions, the threshold adapts to the actual miners available in the previous round.

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Fails_When_Miner_Set_Changes()
{
    // Setup: Initialize with 5 miners for Term 1
    var initialMiners = InitialCoreDataCenterKeyPairs.Take(5).ToList();
    await InitializeCandidates(5);
    
    // Mine a complete round with 5 miners
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    await ProduceBlocksForFullRound(firstRound, initialMiners);
    
    // Vote for 7 different miners (only 3 overlap with initial 5)
    var newMiners = ValidationDataCenterKeyPairs.Take(7).ToList();
    var voter = GetElectionContractTester(VoterKeyPairs[0]);
    foreach (var candidate in newMiners)
    {
        await voter.Vote.SendAsync(new VoteMinerInput
        {
            CandidatePubkey = candidate.PublicKey.ToHex(),
            Amount = 100,
            EndTimestamp = TimestampHelper.GetUtcNow().AddDays(100)
        });
    }
    
    // Trigger term change - new term with 7 miners
    BlockTimeProvider.SetBlockTime(BlockchainStartTimestamp.AddYears(1));
    var nextTermInformation = await GetConsensusExtraData(AElfConsensusBehaviour.NextTerm);
    var nextTermInput = NextTermInput.Parser.ParseFrom(nextTermInformation.Round.ToByteArray());
    await AEDPoSContractStub.NextTerm.SendAsync(nextTermInput);
    
    var newRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Verify: IsMinerListJustChanged is true and miner count increased
    newRound.IsMinerListJustChanged.ShouldBeTrue();
    newRound.RealTimeMinersInformation.Count.ShouldBe(7);
    
    // Produce blocks with new miners in the new round
    var newMiner = newMiners.First(m => newRound.RealTimeMinersInformation.ContainsKey(m.PublicKey.ToHex()));
    await ProduceSingleBlock(newRound, newMiner);
    
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // BUG: LIB remains at 0 because only 3 miners overlap between terms
    // MinersCountOfConsent = 7 * 2/3 + 1 = 5, but max available from previous round = 3
    updatedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(0); // Demonstrates the bug
}
```

## Notes

This vulnerability demonstrates a fundamental design flaw in the LIB calculation mechanism that fails to account for dynamic miner set changes. The issue is particularly severe because:

1. **No Mitigation Exists:** The `IsMinerListJustChanged` flag is properly set but completely ignored by the LIB calculator, indicating this scenario was not considered during implementation.

2. **Cross-Chain Dependency:** The AElf architecture heavily relies on LIB for cross-chain security. When LIB fails to advance, the entire cross-chain ecosystem is affected, not just individual chains.

3. **Election-Driven Likelihood:** The election system intentionally allows voters to completely change the miner set, making this scenario not just possible but expected during competitive elections or governance changes.

4. **Byzantine Tolerance Trade-off:** The 2/3 threshold is essential for Byzantine fault tolerance, but applying it across miner set changes creates an impossible condition when overlap is insufficient.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L14-18)
```csharp
        public LastIrreversibleBlockHeightCalculator(Round currentRound, Round previousRound)
        {
            _currentRound = currentRound;
            _previousRound = previousRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-44)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L110-136)
```csharp
        while (minerCount < maxCount)
        {
            var currentRound = await newMinerStub.GetCurrentRoundInformation.CallAsync(new Empty());
            var firstPubKey = currentRound.RealTimeMinersInformation.Keys.First();
            var keypair = ValidationDataCenterKeyPairs.First(o => o.PublicKey.ToHex() == firstPubKey);
            newMinerStub = GetAEDPoSContractStub(keypair);

            minerCount = currentRound.RealTimeMinersInformation.Count;
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);

            changeTermTime = BlockchainStartTimestamp.ToDateTime()
                .AddMinutes((termCount + 2).Mul(termIntervalMin)).AddSeconds(10);
            BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());
            var nextRoundInformation = (await newMinerStub.GetConsensusExtraData.CallAsync(
                new AElfConsensusTriggerInformation
                {
                    Behaviour = AElfConsensusBehaviour.NextTerm,
                    Pubkey = ByteStringHelper.FromHexString(currentRound.RealTimeMinersInformation.ElementAt(0).Value
                        .Pubkey)
                }.ToBytesValue())).ToConsensusHeaderInformation();
            nextTermInput = NextTermInput.Parser.ParseFrom(nextRoundInformation.Round.ToByteArray());
            randomNumber = await GenerateRandomProofAsync(keypair);
            nextTermInput.RandomNumber = ByteString.CopyFrom(randomNumber);
            await newMinerStub.NextTerm.SendAsync(nextTermInput);
            termCount++;
        }
    }
```
