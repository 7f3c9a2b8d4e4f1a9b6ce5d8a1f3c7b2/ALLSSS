# Audit Report

## Title
Signature Forgery Enables Mining Order Manipulation in AEDPoS Consensus

## Summary
The AEDPoS consensus validation flow fails to cryptographically verify that miner-provided signature values are correctly calculated. Since mining order for the next round is derived directly from signature values through modulo arithmetic, malicious miners can forge arbitrary signatures to manipulate their position in the block production schedule, breaking consensus randomness guarantees.

## Finding Description

The AEDPoS consensus mechanism is designed to randomly determine mining order through cryptographic signatures. The signature should be calculated as the XOR of the previous in-value with all signatures from the previous round [1](#0-0) , and mining order should be deterministically derived from this signature value [2](#0-1) .

However, the validation flow contains a critical gap: when processing UpdateValue transactions, the signature and order values are directly assigned from user-provided input without any cryptographic verification [3](#0-2) .

The UpdateValueValidationProvider only checks that signature and outValue fields are non-null and non-empty, but does NOT verify cryptographic correctness [4](#0-3) . While it validates that PreviousInValue hashes correctly to PreviousOutValue [5](#0-4) , it never verifies that the signature itself was calculated correctly using the CalculateSignature method.

During after-execution validation, the RecoverFromUpdateValue function copies the provided signature and order values directly into the base round without verification [6](#0-5) . The subsequent hash comparison passes because both sides of the comparison now contain the forged values [7](#0-6) .

**Attack Scenario:**
1. Malicious miner determines desired mining order (e.g., order = 1 to mine first)
2. Works backwards to find a signature value where `signature.ToInt64() % minersCount == 0`
3. Constructs UpdateValueInput with the forged signature and corresponding SupposedOrderOfNextRound
4. Submits this via the public UpdateValue method during block production [8](#0-7) 
5. All validation passes since no code verifies the signature was calculated correctly using CalculateSignature

## Impact Explanation

This vulnerability breaks a foundational security property of the AEDPoS consensus mechanism. The mining order is supposed to be unpredictably randomized through cryptographic means, but miners can now deterministically choose their position in subsequent rounds.

**Consensus Integrity Breach:** A malicious miner can consistently position themselves to mine first by crafting signature values that produce SupposedOrderOfNextRound = 1. This directly violates the randomness guarantee that is essential to consensus fairness and was the design intent of the signature-based ordering system.

**MEV and Economic Impact:** Mining first in each round provides maximum Miner Extractable Value (MEV) opportunities. The attacker can reorder transactions within their block production window, engage in front-running, and selectively censor transactions. This creates systematic unfair economic advantage that accumulates across multiple rounds.

**Protocol-Wide Trust Erosion:** Since any authorized miner can exploit this vulnerability independently and repeatedly without detection through on-chain validation mechanisms, it undermines the fundamental fairness assumptions of the consensus protocol. Users and other miners cannot trust that block production order follows the intended randomized schedule.

## Likelihood Explanation

**High likelihood** because:

- **Low Privilege Requirement:** The attacker only needs to be an authorized miner, which is a normal operating condition verified by the MiningPermissionValidationProvider. No additional special privileges are required.

- **Low Attack Complexity:** Finding a suitable forged signature requires simple modulo arithmetic: `signature.ToInt64() % minersCount == desiredOrder - 1`. This is computationally trivial.

- **Standard Entry Point:** The attack uses the standard UpdateValue() public method that miners call during normal block production. No unusual or suspicious transaction patterns are required.

- **No Additional Preconditions:** The attack works in any round after the first, requires no complex state manipulation, and doesn't depend on timing or coordination with other miners.

- **Validation Bypass:** All existing validation checks pass with forged values because none verify cryptographic correctness of the signature.

- **Undetectable On-Chain:** There is no on-chain mechanism to detect that a signature was forged rather than correctly calculated, making the attack sustainable over many rounds.

## Recommendation

Add signature verification to the UpdateValueValidationProvider:

```csharp
private bool ValidateSignatureCalculation(ConsensusValidationContext validationContext)
{
    var providedSignature = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].Signature;
    var previousInValue = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // Cannot validate without previous in value
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    
    if (providedSignature != expectedSignature)
        return false;
    
    // Also verify order matches signature
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    var expectedOrder = GetAbsModulus(expectedSignature.ToInt64(), minersCount) + 1;
    var providedOrder = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].SupposedOrderOfNextRound;
    
    return expectedOrder == providedOrder;
}
```

Add this validation check to the ValidateHeaderInformation method in UpdateValueValidationProvider after the existing checks.

## Proof of Concept

Due to the complexity of the consensus system, a full PoC would require:
1. Setting up a test blockchain with multiple miners
2. Creating a malicious miner that generates UpdateValueInput with forged signature
3. Demonstrating the forged signature passes validation
4. Showing the miner successfully mines in their chosen position in the next round

The vulnerability is confirmed through code analysis showing that no validation path calls CalculateSignature() to verify the correctness of user-provided signatures.

**Notes**

The vulnerability exists because the validation logic assumes that signature values provided by miners through UpdateValueInput are trustworthy. While the normal flow (via GetConsensusExtraDataToPublishOutValue) correctly calculates signatures using CalculateSignature [9](#0-8) , nothing prevents a malicious miner from bypassing this flow and directly calling UpdateValue with crafted values.

The VRF verification that exists in the code [10](#0-9)  validates the randomNumber field (used for random hash generation), but is completely separate from the Signature field used for mining order determination. These are two different cryptographic values serving different purposes in the consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-79)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-30)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L68-92)
```csharp
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
        var previousInValue = Hash.Empty; // Just initial previous in value.

        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```
