# Audit Report

## Title
Missing Miner List Validation in NextRound Allows Consensus Takeover

## Summary
The AEDPoS consensus contract fails to validate that the miner list remains unchanged during round transitions. The `NextRound` validation pipeline only checks round number increments and null `InValue` fields, allowing any current miner to inject arbitrary miners and completely take over the consensus mechanism.

## Finding Description

The vulnerability exists in the consensus validation pipeline for `NextRound` behavior. When a miner transitions to the next round, the system validates the input but critically fails to verify miner list consistency.

**Validation Gap Analysis:**

The `ValidateBeforeExecution` method adds two validators for NextRound behavior: [1](#0-0) 

**RoundTerminateValidationProvider** only verifies:
- Round number increments by exactly 1
- All `InValue` fields in next round are null [2](#0-1) 

**NextRoundMiningOrderValidationProvider** checks counts but can be bypassed by setting all values to 0/null, making the check 0 == 0: [3](#0-2) 

**Critical Gap:** Neither validator checks that the miner list keys (public keys in `RealTimeMinersInformation`) in the next round match the current round's miner list.

**Legitimate Round Generation Preserves Miners:**

The legitimate `GenerateNextRoundInformation` method preserves the current round's miners, only reordering them: [4](#0-3) 

However, validation does not enforce this invariant.

**Processing Without Validation:**

After validation passes, `ProcessNextRound` converts input to Round via `ToRound()`: [5](#0-4) 

The `ToRound()` method copies all fields including the arbitrary miner list: [6](#0-5) 

`AddRoundInformation` stores it directly without validation: [7](#0-6) 

**Post-Execution Validation Fails:**

The `ValidateConsensusAfterExecution` retrieves the current round from state (now the malicious round) and compares with the header (also malicious), so hashes match: [8](#0-7) 

**PreCheck Insufficient:**

The `PreCheck` only verifies sender is in current/previous miner list, not that they're maintaining the correct miner list: [9](#0-8) 

**Correct Behavior (NextTerm):**

In contrast, `NextTerm` explicitly updates the miner list through proper channels: [10](#0-9) 

## Impact Explanation

**CRITICAL** - This represents a complete breakdown of consensus security:

1. **Consensus Takeover:** An attacker can replace all legitimate miners with arbitrary public keys they control, gaining monopoly over block production
2. **Miner Disenfranchisement:** All legitimately elected miners lose their mining rights and block rewards
3. **Election Bypass:** Democratic validator election becomes meaningless as results can be overridden by any current miner
4. **Chain Halt Risk:** Attacker can set invalid mining orders to potentially halt the chain
5. **Governance Compromise:** Proposals and cross-chain operations requiring miner consensus become compromised
6. **Persistence:** Future rounds would be generated from the malicious miner list, perpetuating the attack

This violates the fundamental invariant that miner lists should only change during term transitions (via Election contract), not during regular round transitions.

## Likelihood Explanation

**HIGH** - The attack is trivially executable:

**Attacker Requirements:**
- Must be a current miner in the round (typical configurations have 5-17 miners)
- No special privileges beyond normal mining rights
- Must wait for their time slot to produce a block

**Attack Complexity:** LOW
1. Monitor for approaching round completion
2. Craft `NextRoundInput` with arbitrary miner list (attacker's controlled keys)
3. Set `RoundNumber = current + 1`, all `InValue = null`, `OutValue = null`, `FinalOrderOfNextRound = 0`
4. Submit transaction calling `NextRound` during attacker's time slot

**Feasibility Factors:**
- No economic cost (attacker earns block rewards)
- No complex cryptography required
- Occurs naturally during round transitions (every ~8 minutes with typical configurations)
- All validation checks pass with crafted input
- No post-execution detection

## Recommendation

Add miner list consistency validation in the `NextRound` validation pipeline. Specifically:

1. **Add a new validator** `MinerListConsistencyValidationProvider` that checks:
   - The set of public keys in `providedRound.RealTimeMinersInformation.Keys` exactly matches `baseRound.RealTimeMinersInformation.Keys`
   - No additions, removals, or replacements of miners

2. **Register the validator** in `ValidateBeforeExecution` for `NextRound` behavior alongside existing validators

3. **Example implementation:**
```csharp
public class MinerListConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var baseRoundMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.ToHashSet();
        var providedRoundMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys.ToHashSet();
        
        if (!baseRoundMiners.SetEquals(providedRoundMiners))
        {
            return new ValidationResult 
            { 
                Message = "Miner list must remain unchanged during regular round transitions." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

4. **Register in validation:**
Add to the `validationProviders` list for `NextRound` case in `ValidateBeforeExecution`.

This ensures the fundamental invariant that miner lists only change during term transitions is enforced.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MinerListManipulation_ConsensustTakeover()
{
    // Setup: Initialize consensus with legitimate miners {A, B, C}
    var legitimateMiners = new[] { "MinerA", "MinerB", "MinerC" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker: MinerA creates malicious NextRoundInput
    var maliciousMiners = new[] { "AttackerX", "AttackerY", "AttackerZ" };
    var maliciousInput = CreateNextRoundInput(
        roundNumber: currentRound + 1,
        miners: maliciousMiners,
        allInValueNull: true,
        allOutValueNull: true,
        allFinalOrderZero: true
    );
    
    // Execute attack
    var result = await ConsensusContract.NextRound(maliciousInput);
    
    // Verify: Malicious miners now control consensus
    var newRound = await ConsensusContract.GetCurrentRoundInformation();
    Assert.Equal(3, newRound.RealTimeMinersInformation.Count);
    Assert.True(newRound.RealTimeMinersInformation.ContainsKey("AttackerX"));
    Assert.True(newRound.RealTimeMinersInformation.ContainsKey("AttackerY"));
    Assert.True(newRound.RealTimeMinersInformation.ContainsKey("AttackerZ"));
    
    // Legitimate miners are gone
    Assert.False(newRound.RealTimeMinersInformation.ContainsKey("MinerA"));
    Assert.False(newRound.RealTimeMinersInformation.ContainsKey("MinerB"));
    Assert.False(newRound.RealTimeMinersInformation.ContainsKey("MinerC"));
}
```

**Notes:**
- The vulnerability exploits the absence of miner list validation during `NextRound` processing
- Miner list changes are only supposed to occur via `NextTerm` which calls `SetMinerList` after retrieving miners from the Election contract
- The attack bypasses this by directly providing arbitrary miners in `NextRoundInput`
- Post-execution validation fails because it compares the malicious stored state with the malicious header (both identical)
- This breaks the fundamental consensus security assumption that miner set is determined by election results

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L186-190)
```csharp

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
