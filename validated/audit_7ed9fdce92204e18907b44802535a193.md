# Audit Report

## Title
Critical Consensus DoS via Integer Division Precision Loss in Mining Interval Validation

## Summary
The AEDPoS consensus contract contains a critical validation gap allowing any active miner to permanently brick the blockchain by injecting rounds with sub-8ms mining intervals. The integer division in `TinyBlockSlotInterval` calculation produces 0ms for intervals below 8ms, cascading to 0ms mining execution timeouts. The validation only enforces `MiningInterval > 0` rather than `>= 8`, enabling this attack during any `NextRound` transition.

## Finding Description

The vulnerability originates in the `TinyBlockSlotInterval` property calculation that divides `MiningInterval` by 8 using integer division: [1](#0-0) 

When `MiningInterval` is 1-7ms, this produces 0ms, which cascades to all mining time limits: [2](#0-1) [3](#0-2) 

**Validation Failure**: The `CheckRoundTimeSlots()` method only validates that the mining interval is greater than 0, not greater than or equal to 8: [4](#0-3) 

**Attack Path**:

1. A malicious miner calls the public `NextRound` method with a crafted `NextRoundInput` containing `ExpectedMiningTime` values only 5ms apart: [5](#0-4) 

2. The only permission check verifies the sender is in the current or previous miner list: [6](#0-5) 

3. Round validation uses `TimeSlotValidationProvider` which calls the insufficient `CheckRoundTimeSlots()`: [7](#0-6) 

4. The malicious round with 5ms intervals passes validation and is stored via `ProcessNextRound`: [8](#0-7) 

5. Future rounds inherit the broken interval via `GetMiningInterval()` which calculates from stored `ExpectedMiningTime` values: [9](#0-8) 

The next round generation perpetuates this interval: [10](#0-9) 

The 0ms mining limits are used in consensus command strategies: [11](#0-10) [12](#0-11) 

## Impact Explanation

**Complete Chain Denial of Service**: When mining limits reach 0ms, the `LimitMillisecondsOfMiningBlock` field with value 0 is passed to the mining service. In `MiningService.MineAsync()`, the block execution timeout calculation causes immediate cancellation: [13](#0-12) 

When `BlockExecutionTime` is 0, `expirationTime = blockTime + 0` is always less than current time, immediately canceling the token and aborting block execution.

**Concrete Damage**:
- All miners receive 0ms execution time, causing immediate cancellation
- Blocks cannot contain user transactions
- Network throughput drops to zero - chain becomes completely unusable
- **Permanent damage**: No self-recovery mechanism exists; future rounds perpetually inherit the broken interval through `GetMiningInterval()`
- Requires emergency intervention: hard fork or chain restart
- All staked assets, locked tokens, and in-flight transactions become frozen

**Affected Parties**: All network participants - miners cannot produce valid blocks, users cannot submit transactions, dApps cease functioning.

## Likelihood Explanation

**Attack Complexity: LOW**
- Requires only being an active miner (one of 17-21 elected block producers)
- Can execute during any `NextRound` transition
- Simple execution: manually construct `NextRoundInput` with `ExpectedMiningTime` values 5ms apart
- No special cryptographic operations needed

**Feasibility: HIGH**
- Entry point is the public `NextRound` method accessible to all miners
- Precondition is realistic: attacker only needs election as miner
- No economic barriers - minimal transaction gas cost
- Attack succeeds immediately upon execution

**Probability: HIGH** - Any of the typically 17-21 mainchain miners can execute this attack at any time during their NextRound turn.

## Recommendation

Add a minimum interval validation in `CheckRoundTimeSlots()`:

```csharp
private const int MinimumMiningInterval = 8; // Minimum to prevent integer division precision loss

public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    // Fix: Check minimum interval to prevent precision loss
    if (baseMiningInterval < MinimumMiningInterval)
        return new ValidationResult { 
            Message = $"Mining interval must be at least {MinimumMiningInterval}ms to prevent precision loss.\n{this}" 
        };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanBrickChain_WithSubEightMsInterval()
{
    // Setup: Initialize consensus with normal parameters
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusAsync(initialMiners);
    
    // Attack: Malicious miner crafts NextRoundInput with 5ms intervals
    var maliciousRound = new NextRoundInput
    {
        RoundNumber = 2,
        TermNumber = 1,
        RealTimeMinersInformation =
        {
            ["miner1"] = new MinerInRound
            {
                Pubkey = "miner1",
                Order = 1,
                ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow)
            },
            ["miner2"] = new MinerInRound
            {
                Pubkey = "miner2",
                Order = 2,
                ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMilliseconds(5)) // Only 5ms apart!
            },
            ["miner3"] = new MinerInRound
            {
                Pubkey = "miner3",
                Order = 3,
                ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMilliseconds(10)) // Only 5ms apart!
            }
        }
    };
    
    // Execute attack as miner1
    var result = await AEDPoSContractStub.NextRound.SendAsync(maliciousRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Attack succeeds!
    
    // Verify: Chain is now bricked
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var miningInterval = currentRound.GetMiningInterval();
    miningInterval.ShouldBe(5); // Broken 5ms interval stored
    
    // Verify: Mining limits are now 0ms
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(new BytesValue());
    consensusCommand.LimitMillisecondsOfMiningBlock.ShouldBe(0); // DoS: 0ms execution time!
    
    // Verify: Future rounds inherit the broken interval
    await ProduceNormalBlockAsync();
    var nextRoundInfo = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    nextRoundInfo.GetMiningInterval().ShouldBe(5); // Still 5ms - permanent damage!
}
```

## Notes

This vulnerability breaks the fundamental consensus invariant that miners must have sufficient time to execute transactions and produce blocks. The attack is trivial for any elected miner and causes permanent, irrecoverable chain halt requiring emergency intervention.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-42)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L54-54)
```csharp
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-36)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L39-39)
```csharp
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L48-50)
```csharp
                    LimitMillisecondsOfMiningBlock = IsLastTinyBlockOfCurrentSlot()
                        ? LastTinyBlockMiningLimit
                        : DefaultBlockMiningLimit
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L50-62)
```csharp
            using var cts = new CancellationTokenSource();
            var expirationTime = blockTime + requestMiningDto.BlockExecutionTime;
            if (expirationTime < TimestampHelper.GetUtcNow())
            {
                cts.Cancel();
            }
            else
            {
                var ts = (expirationTime - TimestampHelper.GetUtcNow()).ToTimeSpan();
                if (ts.TotalMilliseconds > int.MaxValue) ts = TimeSpan.FromMilliseconds(int.MaxValue);

                cts.CancelAfter(ts);
            }
```
