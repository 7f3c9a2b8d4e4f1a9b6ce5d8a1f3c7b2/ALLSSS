# Audit Report

## Title
Round Number Manipulation Bypasses Continuous Block Production Limits in AEDPoS Consensus

## Summary
The `ContinuousBlocksValidationProvider` skips validation when the miner-provided round number is ≤2, but for `UpdateValue` and `TinyBlock` behaviors, no validator verifies that the provided round number matches the actual current round. A malicious miner can set the round number to 1 or 2 in their block header to bypass continuous block limits and produce unlimited blocks, breaking fair block production distribution.

## Finding Description

The vulnerability exists in the consensus block validation flow where the round number check in `ContinuousBlocksValidationProvider` can be bypassed through header manipulation.

**Root Cause**: The continuous blocks validation uses `ProvidedRound.RoundNumber` from the miner-supplied block header to determine whether to perform the check. When this value is ≤2, the entire validation is skipped. [1](#0-0) 

The `ProvidedRound` comes directly from the miner's consensus extra data: [2](#0-1) 

**Missing Validation**: For `UpdateValue` and `TinyBlock` behaviors, the validation pipeline does not include any validator that checks if the provided round number matches the actual current round: [3](#0-2) 

The `RoundTerminateValidationProvider`, which validates round numbers, is only added for `NextRound` and `NextTerm` behaviors (lines 87, 90), not for `UpdateValue` or `TinyBlock`.

**Why Protections Fail**: The `UpdateValueValidationProvider` only checks cryptographic values (OutValue, Signature, PreviousInValue), not round numbers: [4](#0-3) 

The continuous block limit mechanism normally rejects blocks when `LatestPubkeyToTinyBlocksCount.BlocksCount` becomes negative, but this check is entirely bypassed when the round number condition is false.

**Attack Execution**:
1. Miner produces 8+ continuous blocks, exceeding the limit defined in `AEDPoSContractConstants.MaximumTinyBlocksCount = 8`
2. `BlocksCount` becomes negative, which would normally trigger rejection
3. Miner modifies their node software to set `Round.RoundNumber = 1` in the consensus extra data before block submission
4. Block validation runs via `ValidateBeforeExecution`
5. `ContinuousBlocksValidationProvider` sees `ProvidedRound.RoundNumber ≤ 2` and returns success immediately without checking `BlocksCount`
6. Block is accepted and processed using the real `BaseRound` from state (not the manipulated `ProvidedRound`)
7. Miner repeats indefinitely to monopolize block production [5](#0-4) 

## Impact Explanation

**HIGH Severity** - This vulnerability breaks a core consensus invariant that is critical to network security and decentralization.

**Consensus Integrity Impact**: The continuous block limit exists to prevent any single miner from dominating block production and ensure fair distribution among all miners. This vulnerability completely bypasses that protection.

**Concrete Harm**:
- **Block Production Centralization**: A malicious miner can produce 100% of blocks instead of their fair share (~1/N where N is the number of miners, typically ~6% for 17 miners)
- **Reward Theft**: The attacker receives disproportionate mining rewards, stealing economic value from honest miners
- **Time Slot Starvation**: Other miners are denied their allocated time slots
- **Transaction Censorship**: Controlling all blocks allows selective transaction inclusion/exclusion
- **Network Decentralization Compromise**: Defeats the multi-miner consensus model that ensures network security

**Affected Parties**:
- All honest miners lose expected block production opportunities and rewards
- Network users face potential transaction censorship
- Overall blockchain security and decentralization are compromised

## Likelihood Explanation

**HIGH Likelihood** - The attack is straightforward to execute, requires only standard miner privileges, and provides immediate economic benefit.

**Attacker Capabilities**:
- Must be an authorized miner in the consensus set (achievable through normal election process)
- Must run modified node software to manipulate consensus extra data (simple code modification)
- No additional permissions or special conditions required

**Attack Complexity**: LOW
- Simple modification of a single field (`RoundNumber`) in the block header
- The miner controls the consensus extra data generation: [6](#0-5) [7](#0-6) 

**Feasibility**:
- Exploitable in any round > 2 (always, after initial network bootstrap)
- No race conditions or timing requirements
- Deterministic and repeatable
- Works for both `UpdateValue` and `TinyBlock` behaviors (the primary block production modes)

**Detection Constraints**:
- The manipulated block passes all validation checks and appears valid to other nodes
- Difficult to attribute malicious intent vs. software bug
- Detection requires explicit comparison of `ProvidedRound.RoundNumber` with `BaseRound.RoundNumber`, which is not currently performed

**Economic Rationality**:
- High reward: Monopolize block production and maximize mining rewards
- Low cost: No staking penalty, no special resources required beyond being a miner
- Strongly rational for any miner seeking to maximize revenue

## Recommendation

Add round number validation for `UpdateValue` and `TinyBlock` behaviors by including the `RoundTerminateValidationProvider` or creating a dedicated validator that ensures `ProvidedRound.RoundNumber` matches `BaseRound.RoundNumber`.

**Option 1**: Extend `RoundTerminateValidationProvider` to validate for all behaviors:
- Add a method to check that provided round number equals base round number (not just +1)
- Include this validator in the pipeline for `UpdateValue` and `TinyBlock`

**Option 2**: Remove the `RoundNumber > 2` condition and always perform continuous blocks validation:
- Change the condition in `ContinuousBlocksValidationProvider` to always check `BlocksCount`
- The `> 2` condition was meant to skip initial rounds, but this can be handled differently (e.g., by checking `BaseRound.RoundNumber` instead of `ProvidedRound.RoundNumber`)

**Option 3**: Add explicit validation in `ValidateBeforeExecution`:
- Before creating the validation context, verify that `extraData.Round.RoundNumber == baseRound.RoundNumber` for non-transitional behaviors
- Reject blocks where the provided round number doesn't match the current round

## Proof of Concept

The vulnerability can be demonstrated by examining the validation flow:

1. Grep search confirms `ProvidedRound.RoundNumber` is only used in the skip condition: [8](#0-7) 

2. Validation pipeline for UpdateValue/TinyBlock lacks round number validation: [9](#0-8) 

3. A test scenario would:
   - Set up a miner who has produced 8 continuous blocks
   - Verify `LatestPubkeyToTinyBlocksCount.BlocksCount` is negative
   - Create a block with `UpdateValue` behavior where `Round.RoundNumber = 1`
   - Observe that `ValidateBeforeExecution` returns success
   - Confirm the miner can continue producing blocks indefinitely

The vulnerability is confirmed by code analysis showing that the round number from the block header controls the validation logic without being validated itself for the most common block production behaviors.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-33)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L16-16)
```csharp
            RoundNumber = RoundNumber,
```
