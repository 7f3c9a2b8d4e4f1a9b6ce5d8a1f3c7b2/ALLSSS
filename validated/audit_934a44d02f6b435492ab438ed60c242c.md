# Audit Report

## Title
Quorum Bypass Vulnerability in NextRound/NextTerm LIB Validation Allows Single Miner to Set Arbitrary Last Irreversible Block Heights

## Summary
The AEDPoS consensus contract fails to validate that Last Irreversible Block (LIB) values in `NextRound` and `NextTerm` transactions were calculated using the required 2/3+1 quorum mechanism. Unlike `UpdateValue` which recalculates LIB server-side with Byzantine fault-tolerant quorum checks, `NextRound` and `NextTerm` directly accept and permanently store miner-provided LIB values without validation, allowing a single malicious miner to bypass consensus finality guarantees and disable fork protection mechanisms.

## Finding Description

The vulnerability stems from an inconsistency in how different consensus behaviors validate Last Irreversible Block (LIB) information. The validation pipeline correctly adds `LibInformationValidationProvider` for `UpdateValue` behavior, but critically omits this validator for `NextRound` and `NextTerm` behaviors. [1](#0-0) 

The `RoundTerminateValidationProvider` used by `NextRound` and `NextTerm` only validates round and term number increments, completely ignoring LIB values: [2](#0-1) 

When `ProcessNextRound` executes, it converts the input to a Round object via `ToRound()` which preserves the attacker-provided LIB fields: [3](#0-2) [4](#0-3) 

The `AddRoundInformation` method performs no LIB validation, simply persisting the malicious values to state: [5](#0-4) 

In stark contrast, `UpdateValue` properly calculates LIB using `LastIrreversibleBlockHeightCalculator` which enforces the 2/3+1 quorum: [6](#0-5) 

The calculator explicitly checks that at least `MinersCountOfConsent` (which is 2/3+1 of total miners) have contributed values: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Consensus Integrity Breach**: The 2/3+1 Byzantine fault-tolerant quorum is the foundational guarantee of consensus finality. By accepting arbitrary LIB values from a single miner, this vulnerability completely nullifies the security model, allowing one malicious actor to unilaterally declare blocks as irreversible without the required consensus.

**Blockchain Health Monitoring Bypass**: The `GetMaximumBlocksCount` method reads the malicious LIB values to determine if the blockchain is in Normal, Abnormal, or Severe status: [9](#0-8) 

By inflating the `ConfirmedIrreversibleBlockRoundNumber`, an attacker prevents the blockchain from entering Abnormal or Severe status (lines 42-67). This disables the fork protection mechanism that reduces block production rates when the actual LIB is lagging, potentially enabling fork attacks.

**Persistence and Propagation**: Once injected, malicious LIB values persist as `GenerateNextRoundInformation` blindly copies them to future rounds: [10](#0-9) 

**Cross-Chain Impact**: External systems querying `GetCurrentRoundInformation` receive the malicious LIB values, affecting cross-chain finality verification and any off-chain integrations relying on block irreversibility guarantees.

## Likelihood Explanation

**Attack Feasibility**: The attack is highly feasible with minimal barriers:

- **Entry Points**: Both `NextRound` and `NextTerm` are public methods accessible to any miner: [11](#0-10) [12](#0-11) 

- **Access Control**: The only check is miner list membership, not LIB calculation authority: [13](#0-12) 

- **Execution Complexity**: Low - the attacker simply modifies the `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields in the input when their node generates the `NextRoundInput` or `NextTermInput`.

- **Preconditions**: Any miner in the current or previous round can execute the attack when producing their extra block (the role rotates among all miners).

- **Detection Difficulty**: Unlike `UpdateValue` which fires an `IrreversibleBlockFound` event (line 275 in ProcessConsensusInformation.cs), `NextRound` and `NextTerm` produce no LIB-related events, making the attack difficult to detect through event monitoring.

## Recommendation

Add server-side LIB recalculation to `ProcessNextRound` and `ProcessNextTerm` methods, similar to the approach used in `ProcessUpdateValue`. The methods should:

1. Recalculate LIB using `LastIrreversibleBlockHeightCalculator` with the 2/3+1 quorum check
2. Overwrite the miner-provided LIB values with the calculated values before storing
3. Only update LIB if the calculated value is higher than the current value

Additionally, add `LibInformationValidationProvider` to the validation pipeline for `NextRound` and `NextTerm` to prevent backwards movement as a defense-in-depth measure (though this alone is insufficient as it doesn't validate correctness).

## Proof of Concept

```csharp
// Test demonstrating arbitrary LIB injection via NextRound
[Fact]
public async Task NextRound_AcceptsArbitraryLIB_Test()
{
    // Setup: Initialize consensus with legitimate miners
    await InitializeConsensus();
    await BootMiner();
    
    // Advance to round 2 legitimately
    await ProduceNormalBlocksAndAdvanceRound();
    
    var currentRound = await GetCurrentRoundInformation();
    var legitimateLIB = currentRound.ConfirmedIrreversibleBlockHeight;
    
    // Attack: Malicious miner produces NextRound with inflated LIB
    var maliciousNextRound = await GenerateNextRoundInformation();
    maliciousNextRound.ConfirmedIrreversibleBlockHeight = legitimateLIB + 10000; // Arbitrary inflation
    maliciousNextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber + 10; // Skip rounds
    
    var nextRoundInput = NextRoundInput.Create(maliciousNextRound, Hash.Empty.ToByteString());
    
    // Execute attack - should fail but doesn't
    var result = await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Transaction succeeds
    
    // Verify: Malicious LIB values are stored
    var updatedRound = await GetCurrentRoundInformation();
    updatedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(legitimateLIB + 10000); // Arbitrary value accepted!
    updatedRound.ConfirmedIrreversibleBlockRoundNumber.ShouldBe(currentRound.RoundNumber + 10);
    
    // Impact: GetMaximumBlocksCount now uses malicious values
    var maxBlocks = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    // Blockchain status incorrectly calculated as Normal despite LIB lag
}
```

## Notes

This vulnerability breaks a fundamental consensus invariant: that Last Irreversible Block heights can only be determined by 2/3+1 miner agreement. While `LibInformationValidationProvider` exists, it only prevents LIB from going backwards - it does not validate that the LIB was correctly calculated using the Byzantine fault-tolerant quorum mechanism. The proper fix requires server-side LIB recalculation in `NextRound` and `NextTerm`, not just adding the existing validator to their pipeline.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
