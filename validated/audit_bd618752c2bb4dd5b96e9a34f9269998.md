# Audit Report

## Title
Scheme Manager Can DOS Profit Claiming Through Unlimited Empty Period Creation

## Summary
A malicious scheme manager can repeatedly call `DistributeProfits` with an empty `AmountsMap`, causing period counters to increment indefinitely without distributing any actual profits. This forces beneficiaries to iterate through potentially millions of empty periods when claiming their legitimate profits, making the claiming process economically infeasible due to excessive gas costs, effectively creating a permanent denial-of-service condition.

## Finding Description

The vulnerability exists in the TokenHolder contract's `DistributeProfits` function, which unconditionally increments the period counter regardless of whether any profits were actually distributed. [1](#0-0) 

The critical flaw occurs where `scheme.Period` is incremented unconditionally after calling the Profit contract. The only check is the conditional addition of `AmountsMap`, which simply doesn't add anything if the input is null or empty - but the period still increments.

The authorization check confirms that the scheme manager is explicitly authorized to call this function: [2](#0-1) 

In the underlying Profit contract's `DistributeProfits` function, the only protection is a check that burns profits if the period is negative OR totalShares is zero or less: [3](#0-2) 

However, in the normal case where a scheme has beneficiaries (totalShares > 0), this check passes and the CurrentPeriod is unconditionally incremented even when no actual profits were distributed: [4](#0-3) 

When beneficiaries attempt to claim profits, they must iterate through all periods from their `LastProfitPeriod` to the scheme's current period. While empty periods are skipped via `continue`, they still consume gas during iteration: [5](#0-4) 

The maximum number of periods that can be processed per claim transaction is limited: [6](#0-5) 

With the default maximum of 100 periods total (divided by the number of profitable details, capped at 10), if a malicious manager creates 1,000,000 empty periods, beneficiaries would need approximately 10,000 separate `ClaimProfits` transactions to traverse all empty periods.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables a complete economic denial-of-service attack on the profit claiming mechanism:

1. **All scheme beneficiaries are affected**: Every participant who has registered for profits in the scheme becomes a victim
2. **Profits become economically inaccessible**: The gas cost of making 10,000+ transactions would far exceed the value of small profit amounts, making them permanently inaccessible
3. **No recovery mechanism**: There is no way to skip empty periods or reset the period counter - the damage is permanent once periods are created
4. **Minimal attack cost**: The attacker only pays normal transaction fees for calling `DistributeProfits`, while victims must pay orders of magnitude more to claim
5. **Protocol reputation damage**: Users losing access to legitimate profits severely damages trust in the entire economic system

## Likelihood Explanation

**Likelihood: HIGH**

The attack has extremely high feasibility:

1. **Attacker capability**: Anyone can create a scheme and become its manager by calling `CreateScheme`: [7](#0-6) 

2. **Attack complexity**: Trivially low - the attacker simply calls `DistributeProfits` repeatedly with an empty `AmountsMap`. No complex conditions or timing requirements exist.

3. **Preconditions**: The only requirement is that the scheme has at least one beneficiary (totalShares > 0), which is the normal operational state for any active profit scheme.

4. **Detection**: While the attack is visible on-chain (period increments without corresponding profit distribution events), detection doesn't prevent the damage - once empty periods are created, they cannot be removed.

5. **No protections**: There are no rate limits, cooldown periods, or validation checks to prevent empty period creation.

## Recommendation

Add a validation check to prevent distributing profits when no actual amounts are being distributed:

```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // Add validation: require at least one non-zero amount
    Assert(input.AmountsMap != null && input.AmountsMap.Any() && input.AmountsMap.Any(a => a.Value > 0),
           "Cannot distribute profits without actual amounts.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

Similarly, add validation in the Profit contract to require non-empty `AmountsMap` or actual balance to be distributed.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousManager_CanDOS_ProfitClaiming()
{
    // Setup: Create scheme with manager
    var manager = Accounts[0].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // Add a beneficiary
    var beneficiary = Accounts[1].Address;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 100
    });
    
    // Attack: Manager creates 1000 empty periods
    for (int i = 0; i < 1000; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = manager,
            AmountsMap = { } // Empty map
        });
    }
    
    // Verify: Beneficiary needs multiple transactions to claim
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(manager);
    scheme.Period.ShouldBe(1001); // 1000 empty periods created
    
    // Claiming will require ~10 transactions due to period limits
    // Each claim can only process ~100 periods maximum
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-25)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L141-144)
```csharp
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-9)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
