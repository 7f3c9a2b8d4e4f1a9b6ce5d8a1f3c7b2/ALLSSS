# Audit Report

## Title
Association Contract Threshold Validation Allows Governance Deadlock

## Summary
The `Validate(Organization)` function in the Association contract contains insufficient threshold validation that allows creation of organizations where proposals can enter permanent deadlock states. The validation checks two separate sum constraints but fails to verify that `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold` does not exceed the organization member count plus one, enabling proposals that can neither be approved, rejected, nor abstained even after all members vote.

## Finding Description

The root cause lies in the threshold validation logic which performs two independent checks without ensuring the combined constraint is satisfied: [1](#0-0) 

These constraints check:
1. `MaximalAbstentionThreshold + MinimalApprovalThreshold <= organizationMemberCount`
2. `MaximalRejectionThreshold + MinimalApprovalThreshold <= organizationMemberCount`

However, the proposal release logic uses asymmetric inequality operators that create a deadlock vulnerability: [2](#0-1) 

The release determination uses:
- **Rejected** if rejections > MaximalRejectionThreshold (strict inequality)
- **Abstained** if abstentions > MaximalAbstentionThreshold (strict inequality)
- **Approved** if approvals >= MinimalApprovalThreshold (non-strict inequality) [3](#0-2) 

Due to the strict inequalities for rejection/abstention versus non-strict for approval, a deadlock occurs when all N members vote with the distribution:
- Approvals = MinimalApprovalThreshold - 1
- Rejections = MaximalRejectionThreshold
- Abstentions = MaximalAbstentionThreshold
- Sum = N (all members voted)

This satisfies the current validation when `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = N + 1`.

**Concrete Example:**
- N = 10 members
- MinimalApprovalThreshold = 6
- MaximalRejectionThreshold = 2
- MaximalAbstentionThreshold = 3

Validation passes (3+6=9≤10, 2+6=8≤10), but sum is 11 = N+1.

When all 10 members vote (5 approvals, 2 rejections, 3 abstentions):
- Not rejected: 2 > 2? NO
- Not abstained: 3 > 3? NO
- Not approved: 5 >= 6? NO
- **Result: DEADLOCK**

## Impact Explanation

**HIGH Severity - Governance DoS**

Organizations with deadlock-prone threshold configurations experience critical governance failure:

1. **Governance Paralysis**: Proposals requiring urgent action cannot be executed or rejected, leaving the organization unable to respond to time-sensitive situations.

2. **Resource Lock**: Proposals remain permanently stuck as the `Release` method will fail the threshold check: [4](#0-3) 

3. **No Recovery Path**: The `ChangeOrganizationThreshold` method requires execution through a proposal: [5](#0-4) 

If a threshold-change proposal deadlocks, the organization cannot fix its own broken configuration.

4. **Limited Mitigation**: Only recovery is waiting for proposal expiration via `ClearProposal`: [6](#0-5) 

This violates the governance invariant that organization thresholds must ensure deterministic proposal outcomes when members vote.

## Likelihood Explanation

**HIGH Likelihood - Easily Exploitable**

The vulnerability has high exploitability:

1. **Public Entry Point**: Any user can create an Association organization through the unrestricted `CreateOrganization` method: [7](#0-6) 

2. **No Economic Barrier**: Organization creation requires no staking, approval, or special privileges.

3. **Simple Attack Vector**: Calculate threshold values satisfying `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = organizationMemberCount + 1` that pass the current validation.

4. **Accidental Creation**: Legitimate organizations attempting balanced thresholds (e.g., 60% approval requirement, 20% rejection tolerance, 30% abstention tolerance) can inadvertently create deadlock configurations.

5. **Delayed Detection**: Validation passes during creation; deadlock only manifests during voting, making it difficult to detect beforehand.

## Recommendation

Add an additional validation constraint to ensure the sum of all thresholds does not exceed the organization member count:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           // NEW CONSTRAINT: Prevent deadlock by ensuring sum doesn't exceed member count
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_Deadlock_Vulnerability_Test()
{
    // Create organization with deadlock-prone thresholds
    // N = 10, MinimalApprovalThreshold = 6, MaximalRejectionThreshold = 2, MaximalAbstentionThreshold = 3
    // Sum = 11 = N + 1 (causes deadlock)
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { 
                Accounts[1].Address, Accounts[2].Address, Accounts[3].Address,
                Accounts[4].Address, Accounts[5].Address, Accounts[6].Address,
                Accounts[7].Address, Accounts[8].Address, Accounts[9].Address,
                Accounts[10].Address
            }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 6,
            MinimalVoteThreshold = 10,
            MaximalAbstentionThreshold = 3,
            MaximalRejectionThreshold = 2
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Accounts[1].Address }
        }
    };
    
    // Organization creation should pass current validation
    var createResult = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var organizationAddress = createResult.Output;
    
    // Create a proposal
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        ToAddress = TokenContractAddress,
        Params = new TransferInput { Symbol = "ELF", Amount = 100, To = Accounts[1].Address }.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1)
    };
    
    var proposalStub = GetAssociationContractTester(Accounts[1].KeyPair);
    var proposalResult = await proposalStub.CreateProposal.SendAsync(proposalInput);
    var proposalId = proposalResult.Output;
    
    // Vote: 5 approvals, 2 rejections, 3 abstentions (all 10 members vote)
    for (int i = 1; i <= 5; i++)
    {
        var stub = GetAssociationContractTester(Accounts[i].KeyPair);
        await stub.Approve.SendAsync(proposalId);
    }
    
    for (int i = 6; i <= 7; i++)
    {
        var stub = GetAssociationContractTester(Accounts[i].KeyPair);
        await stub.Reject.SendAsync(proposalId);
    }
    
    for (int i = 8; i <= 10; i++)
    {
        var stub = GetAssociationContractTester(Accounts[i].KeyPair);
        await stub.Abstain.SendAsync(proposalId);
    }
    
    // Try to release - should fail due to deadlock
    var releaseResult = await proposalStub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Verify proposal is deadlocked (ToBeReleased = false despite all members voting)
    var proposalInfo = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalInfo.ToBeReleased.ShouldBe(false);
    proposalInfo.ApprovalCount.ShouldBe(5);
    proposalInfo.RejectionCount.ShouldBe(2);
    proposalInfo.AbstentionCount.ShouldBe(3);
}
```

## Notes

This vulnerability demonstrates a critical flaw in the threshold validation logic where the asymmetric inequality operators (strict `>` for rejection/abstention vs non-strict `>=` for approval) combined with insufficient validation constraints create a mathematical deadlock condition. The issue is particularly severe because it can occur accidentally when organizations attempt to configure "balanced" governance thresholds, and once an organization is created with such thresholds, there is no recovery mechanism other than waiting for proposals to expire.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-51)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L77-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-83)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-188)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-209)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-288)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
```
