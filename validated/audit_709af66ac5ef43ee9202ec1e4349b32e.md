# Audit Report

## Title
Secret Sharing Reveal Blocked by Incorrect Threshold Check - Byzantine Fault Tolerance Broken

## Summary
The `RevealSharedInValues()` function in the AEDPoS consensus contract requires 100% of miners to provide decrypted pieces before revealing InValues, but Shamir's Secret Sharing algorithm only needs a 2/3 threshold. This allows a single malicious miner to block all InValue reveals by refusing to submit decrypted pieces, completely defeating the Byzantine fault tolerance that the secret sharing mechanism was designed to provide.

## Finding Description

The vulnerability exists in the `RevealSharedInValues()` method where the threshold check for decrypted pieces is incorrect.

**Root Cause:**

The function correctly calculates `minimumCount` as 2/3 of total miners [1](#0-0) , and correctly checks that `EncryptedPieces.Count >= minimumCount` [2](#0-1) . However, it then incorrectly checks `DecryptedPieces.Count >= minersCount` (100% of all miners) [3](#0-2) , even though the actual secret decoding operation only requires `minimumCount` pieces [4](#0-3) .

**Why This Breaks Byzantine Fault Tolerance:**

A miner's `DecryptedPieces` collection is populated by OTHER miners through the `PerformSecretSharing` method [5](#0-4) . When miners call `UpdateValue`, they provide a `decrypted_pieces` map [6](#0-5) , and each entry is added to the corresponding miner's `DecryptedPieces` collection.

The 100% requirement means that ALL miners must cooperate to include decrypted pieces for a target miner. This contradicts the fundamental property of Shamir's Secret Sharing, which mathematically only requires the threshold number of pieces.

**Execution Path:**

1. Round N: MinerA provides encrypted pieces via `UpdateValue` (stored in MinerA.EncryptedPieces) [7](#0-6) 
2. Round N+1: Other miners should decrypt and submit via `UpdateValueInput.decrypted_pieces`
3. These decrypted pieces get added to MinerA.DecryptedPieces by `PerformSecretSharing`
4. When generating next round consensus data, `RevealSharedInValues` is called [8](#0-7) 
5. If MinerA's `DecryptedPieces.Count < minersCount`, the reveal is blocked
6. A single malicious miner can withhold their decryption by omitting entries from their `decrypted_pieces` map, preventing MinerA's InValue from ever being revealed

The cryptographic library confirms that `DecodeSecret` only iterates over `threshold` pieces, not all pieces [9](#0-8) .

## Impact Explanation

**Consensus Integrity Impact:**
- **Byzantine Fault Tolerance Broken**: The entire purpose of using Shamir's Secret Sharing with a 2/3 threshold is to tolerate up to 1/3 malicious or offline nodes. This bug completely defeats that security property.
- **Single Point of Failure**: Even ONE miner refusing to provide decrypted pieces blocks ALL InValue reveals. In a 10-miner network, the system should only need 7 pieces but currently requires all 10.
- **Selective Censorship**: Malicious miners can strategically block specific miners' InValue reveals, potentially manipulating consensus randomness.

**Who is Affected:**
All miners relying on the secret sharing mechanism to reveal their PreviousInValue. While miners can voluntarily provide their PreviousInValue directly [10](#0-9) , the comment indicates this is permissible (not required), meaning the secret sharing should serve as an automatic fallback. With this bug, that fallback is broken.

**Severity: Medium**
While the system has fallback mechanisms (direct reveals), the core security property of Byzantine fault-tolerant secret recovery is completely defeated. This enables potential manipulation of consensus randomness through selective blocking of reveals.

## Likelihood Explanation

**Attacker Capabilities:**
Any active miner can execute this attack by simply omitting entries from the `decrypted_pieces` map in their `UpdateValueInput` when calling the `UpdateValue` method [11](#0-10) .

**Attack Complexity:**
Trivial - requires no special capabilities beyond being a miner. The attacker merely excludes specific public keys from their submission.

**Feasibility Conditions:**
- Attacker is an active miner (realistic - probability 1/N where N is the number of miners)
- Secret sharing is enabled via configuration [12](#0-11) 
- No cost or penalty for not providing decrypted pieces
- Can be executed selectively against specific targets

**Detection/Operational Constraints:**
Difficult to distinguish malicious withholding from legitimate node failures or network issues. The behavior appears identical to a miner simply not participating.

**Probability: High**
Given the ease of execution, lack of penalties, and the trivial nature of the attack, any malicious miner can disrupt the entire reveal mechanism.

## Recommendation

Change the threshold check on line 36 from `minersCount` to `minimumCount` to match the cryptographic requirements of Shamir's Secret Sharing:

```csharp
// Before (incorrect):
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// After (correct):
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This change ensures that the reveal mechanism respects the Byzantine fault tolerance property of the secret sharing algorithm, allowing InValue reveals to succeed as long as at least 2/3 of miners provide decrypted pieces.

## Proof of Concept

The vulnerability can be demonstrated by examining the threshold logic:

1. In a network with 10 miners, `minimumCount = 10 * 2 / 3 = 6` (rounded down)
2. Shamir's Secret Sharing can reconstruct the secret with any 6 pieces
3. However, line 36 requires `DecryptedPieces.Count >= 10` (all miners)
4. If even 1 miner withholds their decrypted piece, the count is 9, which fails the check
5. The `DecodeSecret` call on line 50 would succeed with just 6 pieces, but is never reached due to the incorrect guard

This can be verified by:
- Creating a test scenario with 10 miners
- Having 9 miners provide decrypted pieces (more than the 6 required by `minimumCount`)
- Observing that `RevealSharedInValues` still skips the reveal due to line 36's check
- Confirming that `SecretSharingHelper.DecodeSecret` would mathematically succeed with those 9 pieces (or even just 6)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-35)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L290-290)
```csharp
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** protobuf/aedpos_contract.proto (L30-31)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L212-212)
```text
    map<string, bytes> decrypted_pieces = 9;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-50)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
```
