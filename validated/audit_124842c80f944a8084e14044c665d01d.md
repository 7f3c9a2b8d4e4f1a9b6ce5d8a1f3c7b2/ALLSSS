# Audit Report

## Title
Missing Order Field Validation in NextRound Transition Allows Block Production Sequence Manipulation

## Summary
The AEDPoS consensus contract fails to validate that the `Order` field in the next round's miner information matches the `FinalOrderOfNextRound` values from the current round. A malicious miner triggering the NextRound transition can arbitrarily reorder the block production sequence, breaking consensus fairness and enabling systematic advantages in rewards, MEV extraction, and governance.

## Finding Description

When a miner triggers `NextRound`, they provide a `NextRoundInput` structure containing the next round's miner information including `Order` values that determine block production sequence. The input is directly converted to a Round object via `ToRound()` which performs a simple field copy without validation. [1](#0-0) 

The converted round is then processed and saved to state via `AddRoundInformation(nextRound)`. [2](#0-1) 

The validation pipeline for NextRound behavior only adds two validators: `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`. [3](#0-2) 

However, `NextRoundMiningOrderValidationProvider` checks `FinalOrderOfNextRound` values in the **provided round** (which is the next round for NextRound behavior), not comparing Order against the current round's FinalOrderOfNextRound. [4](#0-3) 

For NextRound behavior, the provided round is the **next** round where `FinalOrderOfNextRound` should be 0 (not yet set) and `OutValue` should be null (not yet mined), making this validation meaningless (0 == 0 always passes).

The `RoundTerminateValidationProvider` only validates that the round number increments by 1 and that InValues are null. [5](#0-4) 

**Critical Missing Validation**: No validator checks that `Order` values in the next round match the `FinalOrderOfNextRound` values from the current round (BaseRound).

The correct Order assignment logic is implemented in `GenerateNextRoundInformation`, which sets each miner's Order based on their `FinalOrderOfNextRound` from the current round. [6](#0-5) 

**Attack Path**:
1. Attacker is a miner scheduled to produce the extra block triggering NextRound
2. They call `GetConsensusBlockExtraData` which correctly generates next round with Order based on FinalOrderOfNextRound [7](#0-6) 
3. They modify the Order values in the returned round structure
4. They submit the modified `NextRoundInput` via NextRound
5. Validation passes because no validator compares Order with FinalOrderOfNextRound
6. Modified Order values are saved to state via `AddRoundInformation` [8](#0-7) 

## Impact Explanation

**HIGH SEVERITY** - This vulnerability directly breaks the fundamental fairness guarantee of AEDPoS consensus:

1. **Consensus Integrity Compromise**: Block production order is a core consensus mechanism property that should be determined fairly based on cryptographic calculations (`FinalOrderOfNextRound`). Arbitrary manipulation violates this invariant.

2. **Reward Misallocation**: Earlier block producers in a round typically receive more favorable reward treatment. An attacker can consistently position themselves or colluding miners earlier in the sequence.

3. **MEV Extraction**: Control over block production order enables systematic MEV (Miner Extractable Value) advantages through transaction ordering and front-running.

4. **Governance Manipulation**: If governance decisions or vote weights depend on block production timing or order, this manipulation can influence governance outcomes.

5. **Network-Wide Impact**: All network participants are affected as the consensus mechanism's fairness is fundamentally violated.

## Likelihood Explanation

**HIGH LIKELIHOOD**:

1. **Attacker Capabilities**: Any active miner can exploit this when they're the extra block producer triggering NextRound. This role rotates among all miners regularly.

2. **Low Complexity**: The attack is straightforward - simply modify integer Order values in the NextRoundInput structure before submission.

3. **No Detection**: The attack is completely undetectable as no validation fails or error is thrown. The existing validators check the wrong properties.

4. **Regular Opportunity**: Every miner gets periodic opportunities as the NextRound trigger role rotates each round.

5. **Strong Economic Incentive**: High benefit (systematic advantages in rewards, MEV, governance) with low cost (only requires being an active miner).

## Recommendation

Add a new validation provider that checks Order values in the next round against FinalOrderOfNextRound from the current round:

```csharp
public class NextRoundOrderValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var nextRound = validationContext.ProvidedRound;
        
        // For each miner in the current round who mined (has FinalOrderOfNextRound > 0),
        // verify their Order in the next round matches their FinalOrderOfNextRound
        foreach (var miner in baseRound.RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound > 0))
        {
            if (!nextRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                validationResult.Message = $"Miner {miner.Pubkey} missing in next round";
                return validationResult;
            }
            
            if (nextRound.RealTimeMinersInformation[miner.Pubkey].Order != miner.FinalOrderOfNextRound)
            {
                validationResult.Message = $"Invalid Order for miner {miner.Pubkey}";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Register this validator in the NextRound validation pipeline in `AEDPoSContract_Validation.cs`.

## Proof of Concept

A test would demonstrate:
1. Setup a consensus round with multiple miners who have set their FinalOrderOfNextRound values
2. The extra block producer calls GetConsensusBlockExtraData to get correct next round data
3. Modify the Order values in the NextRoundInput (e.g., swap Order 1 and Order 5)
4. Submit the modified NextRoundInput via NextRound method
5. Verify the transaction succeeds and the modified Order values are saved to state
6. Confirm block production follows the modified order in the subsequent round

This proves that arbitrary Order manipulation bypasses all validation and directly affects block production sequence.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-115)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```
