# Audit Report

## Title
Consensus Miner List Manipulation via Unvalidated NextTermInput Conversion

## Summary
The AEDPoS consensus contract accepts arbitrary miner lists during term transitions without validating them against election results. A malicious block producer can inject custom miners into the next term by manipulating consensus extra data, completely bypassing the election-based consensus mechanism.

## Finding Description

**Root Cause - Unvalidated Conversion:**

The `ToRound()` method performs direct field copying without any validation of the miner list: [1](#0-0) 

This method blindly copies `RealTimeMinersInformation` (the miner list) without checking if it matches the authoritative election results.

**Validation Gap - No Miner List Verification:**

For NextTerm behavior, only `RoundTerminateValidationProvider` is added to the validation pipeline: [2](#0-1) 

This provider only validates structural properties (term and round number increments), NOT the miner list composition: [3](#0-2) 

The basic validation providers check the CURRENT block producer's permissions, but none verify that the NEXT TERM's miner list matches election winners: [4](#0-3) 

**Processing Without Validation:**

`ProcessNextTerm` directly converts and uses the unvalidated input: [5](#0-4) 

The miner list is extracted from the unvalidated `nextRound` and set as the official list for the new term without any election validation.

**SetMinerList Has No Election Validation:**

The method that finalizes the miner list only checks if it was already set: [6](#0-5) 

There is no call to `GetVictories()` or any verification that the provided list matches election results.

**Honest Path (Bypassed):**

The intended flow calls `GenerateFirstRoundOfNextTerm` which retrieves election winners: [7](#0-6) 

Specifically, `TryToGetVictories` queries the Election Contract: [8](#0-7) 

However, there is NO enforcement that this honest path was actually followed. The consensus extra data generation happens in honest nodes at: [9](#0-8) 

A malicious block producer can run modified node software that generates custom consensus extra data bypassing `TryToGetVictories()`, and the validation layer will accept it.

**Transaction Generation from Malicious Header:**

The consensus extra data from the block header is converted to a transaction: [10](#0-9) 

The `NextTerm` transaction is generated with `NextTermInput.Create(round, randomNumber)` where `round` comes directly from the potentially malicious consensus extra data, with no election validation occurring.

## Impact Explanation

**Consensus Integrity Compromise:**
This vulnerability completely breaks the fundamental security assumption of the AEDPoS consensus protocol - that block producers are elected through voting by token holders. An attacker can:

- **Exclude Legitimate Winners**: Remove election winners from the miner list, nullifying token holder votes
- **Include Arbitrary Miners**: Add attacker-controlled addresses that never participated in elections
- **Perpetuate Control**: Once established, attacker maintains control indefinitely by always including themselves in subsequent terms
- **Centralize Network**: Replace distributed consensus with attacker monopoly

**Affected Parties:**
- Legitimate election winners lose block production rights
- Token holders' votes are completely nullified
- Network decentralization guarantee is broken
- All users subject to censorship and potential attacks

**Quantified Damage:**
- 100% control over block production for entire terms (typically 7 days)
- Complete transaction censorship capability
- All mining rewards redirected to attacker
- Election-based governance completely nullified

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a legitimate miner in the current term (achievable - elections are open)
- Must control timing to produce the term transition block (deterministic - extra block slots are assigned)
- Can run modified node software (trivial - open source)

**Attack Complexity: MEDIUM**
1. Fork AElf node repository
2. Modify consensus extra data generation to return custom miner list
3. Participate in elections to become a miner
4. Wait for term-ending extra block slot assignment
5. Produce block with malicious consensus data

**Feasibility: HIGH**
- Any current miner can execute this attack
- No special economic cost required
- Attack is deterministic with no race conditions
- Success guaranteed if attacker produces the term-ending block

**Detection: LOW**
- Malicious miner list appears structurally valid
- Off-chain monitoring cannot detect without comparing to `GetVictories()` results
- Honest nodes accept the block because validation passes

## Recommendation

Add a validation provider that verifies the miner list in `NextTermInput` matches the Election Contract's `GetVictories()` results:

```csharp
public class ElectionResultValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
            
        // Get expected miners from Election Contract
        var expectedVictories = validationContext.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = expectedVictories.Value.Select(v => v.ToHex()).OrderBy(m => m).ToList();
        
        // Get actual miners from consensus data
        var actualMiners = validationContext.ExtraData.Round.RealTimeMinersInformation.Keys.OrderBy(m => m).ToList();
        
        // Verify they match
        if (expectedMiners.Count != actualMiners.Count || !expectedMiners.SequenceEqual(actualMiners))
        {
            return new ValidationResult 
            { 
                Message = "Miner list does not match election results"
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the validation pipeline in `AEDPoSContract_Validation.cs` for NextTerm behavior:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ElectionResultValidationProvider()); // Add election validation
    break;
```

## Proof of Concept

A test demonstrating this vulnerability would require:
1. Setting up a test chain with election system
2. Becoming a miner through normal elections
3. Modifying the consensus extra data generation to inject arbitrary miners
4. Producing a term-ending block with the malicious data
5. Verifying that the malicious miner list is accepted and becomes official

The core issue is that `ProcessNextTerm` accepts any miner list without cross-validating against `GetVictories()`, allowing complete bypass of the election mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```
