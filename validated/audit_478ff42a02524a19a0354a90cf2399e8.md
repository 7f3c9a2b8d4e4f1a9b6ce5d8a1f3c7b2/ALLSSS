# Audit Report

## Title
Dictionary Access Vulnerability in Consensus Block Production Causes Chain Halt via Miner Pubkey Replacement Race Condition

## Summary
The AEDPoS consensus contract contains unprotected dictionary accesses to `RealTimeMinersInformation` during block production that trigger `KeyNotFoundException` crashes when a miner's public key is replaced mid-block-production by a candidate admin. This race condition between `GetConsensusCommand` and `GetConsensusExtraData` allows disruption of consensus block production, causing missed time slots and potential chain stall.

## Finding Description

The vulnerability exists in the consensus block production flow where dictionary accesses lack key existence validation before accessing `RealTimeMinersInformation`.

**Primary crash locations:**

The `GetConsensusExtraDataToPublishOutValue` method directly accesses the dictionary without checking if the key exists: [1](#0-0) 

The `GetConsensusExtraDataForTinyBlock` method has the same vulnerability: [2](#0-1) 

The only validation is an empty pubkey check, but no `ContainsKey` check before dictionary access: [3](#0-2) 

**Attack mechanism via pubkey replacement:**

The Election Contract allows candidate admins to replace miner pubkeys at any time. Permission check shows this is controlled by candidate admin, not a trusted role: [4](#0-3) 

This triggers `RecordCandidateReplacement` which removes the old pubkey from the current round's `RealTimeMinersInformation`: [5](#0-4) 

**Race condition window:**

Block production flow has a critical time gap between two separate RPC calls executed by the consensus service:

1. `TriggerConsensusAsync` calls `GetConsensusCommand` which validates miner is in list: [6](#0-5) 

The validation checks if pubkey is in the miner list: [7](#0-6) 

Which uses the `IsInMinerList` method: [8](#0-7) 

2. Later, `GetConsensusExtraDataAsync` is called for actual block production: [9](#0-8) 

Between these calls, if `RecordCandidateReplacement` executes and removes the pubkey, subsequent dictionary access crashes with `KeyNotFoundException`.

**Additional vulnerable locations with same pattern:**

The `GetUpdateValueRound` method also lacks protection: [10](#0-9) 

The `GetTinyBlockRound` method has the same issue: [11](#0-10) 

**Evidence of inconsistent protection:**

The `NextRound` behavior has proper existence checks before accessing the dictionary: [12](#0-11) 

The `NextTerm` behavior also has proper existence checks: [13](#0-12) 

This inconsistency demonstrates developers were aware of the need for existence checks but didn't apply them to `UpdateValue` and `TinyBlock` behaviors.

**Candidate admin permission structure:**

The candidate admin is retrieved from state and is not a trusted consensus role: [14](#0-13) 

## Impact Explanation

**Consensus disruption**: When a miner's block production crashes with `KeyNotFoundException`, that time slot is lost. The miner cannot produce their scheduled block, disrupting the consensus round progression.

**Chain halt risk**: In scenarios with few active miners or during critical consensus transitions, coordinated replacements targeting multiple miners could cause extended block production stalls, potentially halting the chain until manual intervention or recovery mechanisms engage.

**Affected parties**: 
- All blockchain users experience transaction confirmation delays
- Miners lose block rewards for missed slots
- DApps depending on timely block production experience failures

**Severity justification**: This violates the critical invariant "miner schedule integrity and time-slot validation" defined in AEDPoS consensus. The ability for a semi-privileged actor (candidate admin) to disrupt consensus operations through timing-based attacks qualifies as a high-severity availability vulnerability affecting core blockchain functionality.

## Likelihood Explanation

**Attacker capabilities**: The attacker must be a candidate admin. While this is a semi-privileged role, candidate admins are NOT expected to be trusted for consensus integrity - they manage candidate metadata and profit receivers, not consensus operation.

**Attack complexity**: 
1. Monitor when target miner receives mining command (observable from consensus state)
2. Submit `ReplaceCandidatePubkey` transaction with timing to execute between command retrieval and block production
3. The race window is predictable since consensus commands are generated at deterministic times based on mining schedule

**Feasibility conditions**:
- No rate limiting on `ReplaceCandidatePubkey` calls in the code
- Candidate admin can submit transactions that get executed in the same block or between consensus calls
- Multiple candidate admins could coordinate to affect multiple miners simultaneously
- The timing window is several seconds (typical time between getting command and producing block)

**Detection constraints**: The attack leaves evidence in Election Contract events (`CandidatePubkeyReplaced`), but by then the damage is done. Automated monitoring could detect patterns but cannot prevent the crash once the replacement transaction is in the mempool.

**Probability**: MEDIUM-HIGH. Candidate admins have legitimate access, the timing window is predictable from public consensus state, and there are no technical barriers preventing the attack. A determined attacker with admin access can reliably execute this attack.

## Recommendation

Add `ContainsKey` checks before all dictionary accesses to `RealTimeMinersInformation` in the vulnerable methods, following the pattern already used in `NextRound` and `NextTerm` behaviors:

1. In `GetConsensusExtraDataToPublishOutValue`, add a check at the beginning:
```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    // Return early or handle miner replacement case
    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = currentRound,
        Behaviour = triggerInformation.Behaviour
    };
}
```

2. Apply the same pattern to `GetConsensusExtraDataForTinyBlock`, `GetUpdateValueRound`, and `GetTinyBlockRound`.

3. Consider adding a mutex or lock mechanism during the critical window between `GetConsensusCommand` and `GetConsensusExtraData` to prevent state mutations, or implement a version check to detect if the round state has changed.

4. Optionally add rate limiting or time-based restrictions on `ReplaceCandidatePubkey` to prevent it from executing during active mining windows.

## Proof of Concept

A valid test would need to:
1. Set up a test environment with an active consensus round
2. Have a miner obtain a `GetConsensusCommand` for block production
3. Execute `ReplaceCandidatePubkey` to remove the miner's pubkey from `RealTimeMinersInformation`
4. Attempt to call `GetConsensusExtraData` with the original pubkey
5. Observe the `KeyNotFoundException` being thrown, causing block production failure

The test would demonstrate that the unprotected dictionary access causes a crash when the miner's key is removed between the two consensus calls.

## Notes

The vulnerability is confirmed by the inconsistent application of defensive programming patterns - `NextRound` and `NextTerm` behaviors correctly check for key existence, while `UpdateValue` and `TinyBlock` behaviors do not. This proves the developers were aware of the potential issue but failed to apply the protection universally across all consensus behaviors.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L18-18)
```csharp
        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L158-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L211-212)
```csharp
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L59-76)
```csharp
    public async Task TriggerConsensusAsync(ChainContext chainContext)
    {
        var now = TimestampHelper.GetUtcNow();
        _blockTimeProvider.SetBlockTime(now, chainContext.BlockHash);

        Logger.LogDebug($"Block time of triggering consensus: {now.ToDateTime():hh:mm:ss.ffffff}.");

        var triggerInformation =
            _triggerInformationProvider.GetTriggerInformationForConsensusCommand(new BytesValue());

        Logger.LogDebug($"Mining triggered, chain context: {chainContext.BlockHeight} - {chainContext.BlockHash}");

        // Upload the consensus command.
        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        _consensusCommand = await _contractReaderFactory
            .Create(contractReaderContext).GetConsensusCommand
            .CallAsync(triggerInformation);
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L195-209)
```csharp
    public async Task<byte[]> GetConsensusExtraDataAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus extra data: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var input = _triggerInformationProvider.GetTriggerInformationForBlockHeaderExtraData(
            _consensusCommand.ToBytesValue());
        var consensusContractStub = _contractReaderFactory.Create(contractReaderContext);
        var output = await consensusContractStub.GetConsensusExtraData.CallAsync(input);
        return output.Value.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-13)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-60)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```
