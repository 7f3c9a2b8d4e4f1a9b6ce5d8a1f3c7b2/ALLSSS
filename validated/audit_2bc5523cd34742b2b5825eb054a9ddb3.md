# Audit Report

## Title
Hash.Empty Bypass in Consensus Behavior Determination Allows Miners to Manipulate Block Production Logic

## Summary
The AEDPoS consensus contract fails to validate that `OutValue` contains cryptographically valid non-zero hash bytes, allowing miners to submit `Hash.Empty` (32 bytes of zeros). The validation only checks byte count using `.Any()`, not byte values, enabling malicious miners to bypass proper consensus behavior assignment and avoid cryptographic commitments required for randomness generation.

## Finding Description

The vulnerability exists in the consensus validation logic where miners submit `OutValue` during block production. The AEDPoS protocol requires `OutValue = Hash(InValue)` as a cryptographic commitment, but the validation incorrectly accepts `Hash.Empty`.

**Validation Weakness:**

The `NewConsensusInformationFilled` method validates OutValue by checking if it contains any bytes, not if those bytes are non-zero: [1](#0-0) 

This check passes for `Hash.Empty` because `.Value.Any()` returns true for any collection with elements, including 32 zero bytes.

**Hash.Empty Definition:** [2](#0-1) 

Hash.Empty is a valid Hash object containing 32 zero bytes, making it non-null but cryptographically meaningless.

**Behavior Determination Bypass:**

The consensus behavior logic checks if a miner has produced blocks by testing if OutValue is null: [3](#0-2) 

When `OutValue == Hash.Empty`, this condition evaluates to false (Hash.Empty is not null), causing `HandleMinerInNewRound` to be skipped. The miner is incorrectly treated as having already produced blocks in the current round.

**PreviousInValue Escape Hatch:** [4](#0-3) 

This line explicitly allows `previousInValue == Hash.Empty` without validating that `Hash(previousInValue) == previousOutValue`, enabling miners to perpetually use Hash.Empty across rounds.

**State Storage Without Validation:** [5](#0-4) 

The OutValue from input is stored directly into state without checking if it equals Hash.Empty.

**Expected Behavior:**

The consensus block extra data generation shows OutValue should always be the hash of InValue: [6](#0-5) 

OutValue should always be computed from InValue, never Hash.Empty.

**Attack Path:**
1. Malicious miner calls UpdateValue with `OutValue = Hash.Empty` and `Signature = Hash.Empty`
2. Validation passes because Hash.Empty.Value.Any() returns true (32 bytes exist)
3. Behavior check treats miner as having already mined (skips HandleMinerInNewRound)
4. State stores Hash.Empty as OutValue
5. Next round, miner provides `previousInValue = Hash.Empty` (explicitly allowed at line 46)
6. Cycle repeats indefinitely, miner never provides valid cryptographic commitments

## Impact Explanation

**Consensus Integrity Violation:**

The AEDPoS protocol relies on miners making cryptographic commitments through OutValue/InValue pairs. By accepting Hash.Empty, miners can avoid proper cryptographic commitments required for verifiable randomness and secret sharing.

**Behavior Manipulation:**

The `HandleMinerInNewRound` method determines critical consensus behaviors (UPDATE_VALUE, TINY_BLOCK, NEXT_ROUND): [7](#0-6) 

Bypassing this logic allows miners to produce blocks outside proper behavior assignments and disrupt round transition timing.

**Randomness Weakness:**

The signature calculation aggregates all miners' signatures using XOR operations: [8](#0-7) 

Miners using Hash.Empty contribute zero entropy (XOR with zeros has no effect), weakening randomness used for next round order determination and cross-chain verification.

**Next Round Order Manipulation:** [9](#0-8) 

The signature is converted to Int64 to calculate mining order. Hash.Empty results in sigNum = 0, allowing predictable order manipulation.

**Affected Parties:**
- All network participants depending on consensus integrity
- Smart contracts using consensus randomness  
- Cross-chain operations requiring secure random values
- Block reward distribution mechanisms

## Likelihood Explanation

**Entry Point Accessibility:**

The UpdateValue method is a public RPC method accessible to any registered miner: [10](#0-9) 

Authorization is validated through mining permission checks: [11](#0-10) 

Any registered miner can exploit this vulnerability. Becoming a miner is achievable through standard election/staking mechanisms without requiring privileged access.

**No On-Chain Protection:**

There is no validation preventing Hash.Empty submission. The codebase contains no defensive checks for `OutValue != Hash.Empty` or validation that bytes are non-zero.

**Attack Simplicity:**

Exploitation requires only modifying the consensus client to submit Hash.Empty instead of computing proper hashes. No cryptographic attacks, timing manipulation, or complex state setup needed.

**Economic Incentive:**

Costs are minimal (standard mining operation) while potential benefits include:
- Influencing randomness outcomes for favorable mining order
- Disrupting competitor block production through behavior manipulation
- Avoiding proper InValue revelation in secret sharing

## Recommendation

Add explicit validation to reject Hash.Empty in OutValue and Signature fields:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Check that OutValue and Signature are not null and contain data
    if (minerInRound.OutValue == null || minerInRound.Signature == null ||
        !minerInRound.OutValue.Value.Any() || !minerInRound.Signature.Value.Any())
        return false;
    
    // NEW: Explicitly reject Hash.Empty
    if (minerInRound.OutValue == Hash.Empty || minerInRound.Signature == Hash.Empty)
        return false;
        
    // NEW: Validate that OutValue contains at least one non-zero byte
    if (minerInRound.OutValue.Value.All(b => b == 0))
        return false;
    
    return true;
}
```

Also update ValidatePreviousInValue to validate the hash relationship even when previousInValue is Hash.Empty:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;

    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) 
        return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    // REMOVE the Hash.Empty escape hatch
    // if (previousInValue == Hash.Empty) return true;
    
    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanSubmitHashEmptyOutValue()
{
    // Setup: Initialize consensus with registered miner
    await InitializeConsensusContract();
    var minerKeyPair = SampleKeyPairs.KeyPairs[0];
    var minerAddress = Address.FromPublicKey(minerKeyPair.PublicKey);
    
    // Register miner and advance to round where miner can produce blocks
    await RegisterMinerAndAdvanceRound(minerKeyPair);
    
    // Get current round information
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Construct malicious UpdateValueInput with Hash.Empty
    var maliciousInput = new UpdateValueInput
    {
        OutValue = Hash.Empty,  // Malicious: should be Hash(InValue)
        Signature = Hash.Empty,  // Malicious: should be computed signature
        RoundId = currentRound.RoundId,
        PreviousInValue = Hash.Empty,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        ProducedBlocks = 1,
        ImpliedIrreversibleBlockHeight = 1
    };
    
    // Execute: Submit UpdateValue with Hash.Empty
    var result = await ConsensusStub.UpdateValue.SendAsync(maliciousInput);
    
    // Verify: Transaction succeeds (vulnerability confirmed)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Hash.Empty is stored in state
    var updatedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfo = updatedRound.RealTimeMinersInformation[minerKeyPair.PublicKey.ToHex()];
    
    minerInfo.OutValue.ShouldBe(Hash.Empty);  // Vulnerability: Hash.Empty accepted
    minerInfo.Signature.ShouldBe(Hash.Empty);
    
    // Verify: Next round behavior is affected
    var consensusCommand = await ConsensusStub.GetConsensusCommand.CallAsync(
        BytesValue.Parser.ParseFrom(minerKeyPair.PublicKey));
    
    // Miner is incorrectly treated as having already mined because OutValue != null
    // HandleMinerInNewRound is bypassed
    consensusCommand.ArrangedMiningTime.ShouldNotBeNull();
}
```

## Notes

The vulnerability stems from the validation logic using `.Any()` which only checks collection size, not byte values. In C#, `ByteString.Any()` returns true if the collection contains any elements, regardless of their values. Since Hash.Empty contains 32 bytes (all zeros), it passes this check despite being cryptographically invalid.

The explicit escape hatch at line 46 of UpdateValueValidationProvider compounds the issue by allowing miners to perpetually use Hash.Empty across rounds without ever providing valid cryptographic commitments.

This breaks the fundamental security model of AEDPoS consensus where miners must commit to random InValues via OutValue hashes to ensure unpredictable and verifiable randomness generation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** src/AElf.Types/Types/Hash.cs (L13-14)
```csharp
        public static readonly Hash Empty = LoadFromByteArray(Enumerable.Range(0, AElfConstants.HashByteArrayLength)
            .Select(x => byte.MinValue).ToArray());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-51)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L92-114)
```csharp
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L245-245)
```csharp
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-67)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
