# Audit Report

## Title
Missing Extra Block Producer Validation Causes Denial of Service in Consensus and Cross-Chain Operations

## Summary
The AEDPoS consensus contract fails to validate that exactly one miner has the `IsExtraBlockProducer` flag set when processing `NextRound` transactions. A malicious miner can submit a malformed round with no extra block producer, causing permanent denial of service for critical operations including cross-chain indexing and transaction fee claiming. The vulnerability stems from unsafe use of `.First()` and `.Single()` LINQ operators without existence validation, combined with insufficient input validation.

## Finding Description

**Root Cause:**

The `GetNextMinerPubkey()` view method contains a critical flaw where it attempts to retrieve the extra block producer without validating existence: [1](#0-0) 

When no miners have future expected mining times, the null-coalescing operator evaluates the fallback expression which calls `.First(m => m.IsExtraBlockProducer)`. If no miner has this flag set to true, `InvalidOperationException` is thrown.

Similarly, `IsCurrentMiner()` uses `.Single()` which throws if zero or multiple extra block producers exist: [2](#0-1) 

**Validation Gap:**

The `RoundTerminateValidationProvider` only validates round number increments and null InValues, but never checks the extra block producer invariant: [3](#0-2) 

**Attack Vector:**

The `NextRound` method is a public RPC endpoint that accepts arbitrary `NextRoundInput` data: [4](#0-3) 

The `ToRound()` conversion directly copies all miner information including `IsExtraBlockProducer` flags without validation: [5](#0-4) 

The only permission check verifies the sender is a miner, but does not validate round data integrity: [6](#0-5) 

**Attack Execution:**

1. Malicious miner creates `NextRoundInput` with all miners' `IsExtraBlockProducer` set to false
2. Submits transaction via public `NextRound` method during their time slot
3. Validation passes (only checks round number and null InValues)
4. Malformed round is stored in contract state
5. All subsequent calls to `IsCurrentMiner()` or `GetNextMinerPubkey()` throw exceptions

## Impact Explanation

**Critical Operations Permanently Disabled:**

**1. Cross-Chain Indexing DoS:**

Both `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` call `AssertAddressIsCurrentMiner()` which will throw: [7](#0-6) [8](#0-7) 

The assertion chain goes through `CheckCrossChainIndexingPermission` to `IsCurrentMiner`: [9](#0-8) [10](#0-9) 

This completely halts parent-sidechain synchronization, breaking the multi-chain ecosystem.

**2. Transaction Fee Claiming DoS:**

Both `ClaimTransactionFees` and `DonateResourceToken` require current miner validation: [11](#0-10) [12](#0-11) 

The assertion calls `IsCurrentMiner` which will throw: [13](#0-12) 

Miners cannot claim accumulated fees, causing severe economic disruption and potential miner exodus.

**3. View Method Failures:**

External systems calling `GetNextMinerPubkey()` receive unhandled exceptions, disrupting consensus monitoring infrastructure.

**Severity:** HIGH - Permanent DoS of consensus-critical operations, cross-chain infrastructure collapse, complete halt of fee distribution, single transaction attack vector.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attacker Requirements:** Any active miner (≈1/17 miners in typical configuration)
2. **Simple Attack:** Client-side modification of round generation to set all `IsExtraBlockProducer = false`
3. **No Cost:** Standard transaction fee only
4. **No Penalty:** No slashing or detection mechanism for malformed rounds
5. **Guaranteed Access:** Every miner gets regular opportunities (≈1/N per round)
6. **Silent Success:** Validation passes, impact only visible when operations fail

**Feasibility:** The normal round generation code always sets exactly one extra block producer: [14](#0-13) 

However, this is client-side generation logic. Miners can craft custom `NextRoundInput` messages with any values. The contract validation does not enforce this invariant.

## Recommendation

Add validation to `RoundTerminateValidationProvider` to enforce the extra block producer invariant:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing validation
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate extra block producer invariant
    var extraBlockProducers = extraData.Round.RealTimeMinersInformation.Values
        .Where(m => m.IsExtraBlockProducer).ToList();
    
    if (extraBlockProducers.Count != 1)
        return new ValidationResult { Message = "Exactly one extra block producer required." };
    
    return new ValidationResult { Success = true };
}
```

Additionally, add defensive checks in `GetNextMinerPubkey()` and `IsCurrentMiner()`:

```csharp
public override StringValue GetNextMinerPubkey(Empty input)
{
    if (TryToGetCurrentRoundInformation(out var round))
    {
        var nextMiner = round.RealTimeMinersInformation.Values
            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime);
        
        if (nextMiner != null)
            return new StringValue { Value = nextMiner.Pubkey };
        
        // Defensive check before using .First()
        var extraBlockProducer = round.RealTimeMinersInformation.Values
            .FirstOrDefault(m => m.IsExtraBlockProducer);
        
        Assert(extraBlockProducer != null, "No extra block producer found in round.");
        return new StringValue { Value = extraBlockProducer.Pubkey };
    }
    
    return new StringValue();
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test that creates a malformed round and shows the resulting exceptions:

```csharp
[Fact]
public async Task MaliciousNextRound_WithoutExtraBlockProducer_CausesDoS()
{
    // Setup: Initialize consensus with valid first round
    await InitializeConsensusAsync();
    
    // Attacker: Current miner crafts malicious NextRoundInput
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = { }
    };
    
    // Set all miners with IsExtraBlockProducer = false (malicious)
    foreach (var miner in currentRound.RealTimeMinersInformation)
    {
        maliciousRound.RealTimeMinersInformation[miner.Key] = new MinerInRound
        {
            Pubkey = miner.Value.Pubkey,
            Order = miner.Value.Order,
            IsExtraBlockProducer = false, // MALICIOUS: No extra block producer
            ExpectedMiningTime = TimestampHelper.GetUtcNow().AddMilliseconds(4000 * miner.Value.Order)
        };
    }
    
    var maliciousInput = NextRoundInput.Create(maliciousRound, GenerateRandomProof());
    
    // Execute: Submit malicious round
    var result = await BootMinerStub.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes validation!
    
    // Verify: DoS conditions
    // 1. GetNextMinerPubkey throws InvalidOperationException
    await Assert.ThrowsAsync<InvalidOperationException>(async () =>
        await AEDPoSContractStub.GetNextMinerPubkey.CallAsync(new Empty()));
    
    // 2. Cross-chain indexing fails
    await Assert.ThrowsAsync<Exception>(async () =>
        await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(new CrossChainBlockData()));
    
    // 3. Fee claiming fails
    await Assert.ThrowsAsync<Exception>(async () =>
        await TokenContractStub.ClaimTransactionFees.SendAsync(new TotalTransactionFeesMap()));
}
```

This test proves that:
1. Malformed rounds pass validation
2. `GetNextMinerPubkey()` throws exceptions
3. Cross-chain and fee operations become permanently unavailable
4. Single malicious transaction causes system-wide DoS

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L91-102)
```csharp
    public override StringValue GetNextMinerPubkey(Empty input)
    {
        if (TryToGetCurrentRoundInformation(out var round))
            return new StringValue
            {
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
            };

        return new StringValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-301)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-895)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-930)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
