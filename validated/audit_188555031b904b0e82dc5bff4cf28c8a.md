# Audit Report

## Title
Authorization Bypass in CreateScheme Allows Attacker to Pollute Victim's Manager Scheme List Causing Bounded DoS

## Summary
The `CreateScheme` function in the Profit contract lacks authorization checks when setting an arbitrary address as the scheme manager. Any attacker can create schemes designating a victim as the manager without consent, polluting the victim's managing scheme list up to the state size limit of approximately 4000 schemes (128KB). This causes bounded DoS when querying `GetManagingSchemeIds`, degrading performance for victims and clients processing their scheme data.

## Finding Description
The vulnerability exists in the `CreateScheme` function where it accepts an arbitrary `input.Manager` parameter and assigns it as the scheme manager without verifying that the caller has authorization to do so. [1](#0-0) 

The function uses `input.Manager ?? Context.Sender`, accepting any address provided by the caller. There is no authorization assertion like `Assert(manager == Context.Sender, ...)` to verify the caller has permission to assign this manager role.

The scheme ID is then added to the manager's list without any permission check: [2](#0-1) 

**Attack Execution Path:**
1. Attacker calls `CreateScheme` with `input.Manager` set to victim's address
2. The scheme is created with victim as manager without consent verification
3. The scheme ID is added to `State.ManagingSchemeIds[victim]`
4. Attacker repeats this up to the state size limit

**Why Existing Protections Fail:**
The function only validates `ProfitReceivingDuePeriodCount` and scheme uniqueness: [3](#0-2) 

No authorization check exists on the manager field assignment, unlike other manager-controlled operations such as `AddSubScheme` [4](#0-3)  and `RemoveSubScheme` [5](#0-4)  which properly verify `Context.Sender == scheme.Manager`.

**State Size Bound:**
The attack is bounded by AElf's state size limit of 128KB: [6](#0-5) 

Each Hash is 32 bytes, allowing approximately 4096 schemes maximum per manager address before state writes fail.

**Unbounded View Method:**
The `GetManagingSchemeIds` view method returns the entire list without pagination: [7](#0-6) 

This forces clients to process up to 128KB of data when querying a victim's schemes.

## Impact Explanation
**Operational DoS Impact:**
- Victim's `GetManagingSchemeIds` query returns up to ~4000 unwanted scheme IDs (128KB of data)
- Clients/nodes processing this data experience degraded performance with memory and CPU overhead
- The victim's legitimate scheme management interface becomes polluted with attacker-created schemes
- Applications displaying scheme lists must process and render thousands of malicious entries

**Authorization Violation:**
- Victims become managers of schemes they never created or authorized
- This violates the expected security invariant that users control their own manager role assignments
- The pattern used in `ResetManager` demonstrates the contract expects managers to have control [8](#0-7) 

**Affected Parties:**
- Targeted manager addresses (victims)
- Clients/applications querying victim's schemes
- Blockchain nodes serving large responses

**Severity: Medium** due to:
1. Clear authorization bypass requiring no victim consent
2. Bounded but significant DoS (128KB, ~4000 schemes)
3. Practical exploitability with reasonable cost
4. Operational degradation rather than direct fund loss

## Likelihood Explanation
**Attacker Capabilities:**
- Any address with sufficient ELF tokens for transaction fees
- No special permissions or trusted role required

**Attack Complexity:**
Simple attack requiring only repeated calls to a public method. The transaction fee is 10 ELF per CreateScheme call: [9](#0-8) 

**Feasibility:**
- Maximum attack cost: ~40,000 ELF to create 4000 schemes
- Smaller-scale attacks (100-500 schemes) cost 1,000-5,000 ELF and still cause noticeable degradation
- No rate limiting or scheme creation caps per manager exist
- Economically feasible for motivated attackers (competitors, griefers)

**Detection/Mitigation:**
- Attack is publicly visible on-chain
- Victim cannot easily remove unwanted schemes from their list (would require calling `ResetManager` [10](#0-9)  up to 4000 times at their own gas cost)
- No built-in protection or reversal mechanism

## Recommendation
Add an authorization check in the `CreateScheme` function to ensure the caller can only set themselves as the manager:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    // Add authorization check
    if (input.Manager != null)
    {
        Assert(input.Manager == Context.Sender, 
            "Cannot set another address as manager without their consent.");
    }
    
    var manager = input.Manager ?? Context.Sender;
    // ... rest of the function
}
```

Alternatively, remove the ability to specify a custom manager entirely, always defaulting to `Context.Sender`:

```csharp
var manager = Context.Sender;
```

Additionally, consider implementing pagination for `GetManagingSchemeIds` to mitigate the DoS impact of large scheme lists.

## Proof of Concept
```csharp
[Fact]
public async Task CreateScheme_AuthorizationBypass_PollutesVictimList()
{
    // Setup: Attacker and victim addresses
    var attacker = Accounts[0].Address;
    var victim = Accounts[1].Address;
    
    // Execute: Attacker creates scheme with victim as manager
    var result = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        Manager = victim, // Setting victim as manager without their consent
        ProfitReceivingDuePeriodCount = 10
    });
    
    // Verify: Scheme was created successfully
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    var schemeId = result.Output;
    
    // Verify: Victim's managing scheme list is polluted
    var victimSchemes = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = victim });
    
    Assert.Contains(schemeId, victimSchemes.SchemeIds);
    
    // Verify: Victim did not create this scheme (sender was attacker)
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    Assert.Equal(victim, scheme.Manager); // Victim is manager
    // But attacker created it without victim's consent
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L48-59)
```csharp
        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L99-99)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only manager can add sub-scheme.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L139-139)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L723-743)
```csharp
    public override Empty ResetManager(ResetManagerInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");

        // Transfer managing scheme id.
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;

        scheme.Manager = input.NewManager;
        State.SchemeInfos[input.SchemeId] = scheme;
        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
