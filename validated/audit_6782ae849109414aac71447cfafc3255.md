# Audit Report

## Title
Missing NeedToChangeTerm Validation Allows Premature Term Termination in AEDPoS Consensus

## Summary
The AEDPoS consensus contract's `NextTerm` method lacks time-based validation during block execution, allowing any active miner to prematurely terminate a consensus term by producing a block with `NextTerm` behavior even when the protocol's time threshold requirements are not met. This bypasses the intended `NeedToChangeTerm` check that should enforce two-thirds miner consensus on term changes based on elapsed blockchain time.

## Finding Description

The vulnerability exists in the separation between consensus behavior selection and transaction execution validation.

**Normal Flow**: During block production, `MainChainConsensusBehaviourProvider` determines whether to use `NextRound` or `NextTerm` by calling `NeedToChangeTerm`, which verifies that at least two-thirds of miners' latest mining times indicate the time threshold has been reached. [1](#0-0) 

The `NeedToChangeTerm` method checks if sufficient miners agree based on blockchain age using a two-thirds threshold: [2](#0-1) 

**Vulnerability**: The `NextTerm` method is publicly accessible and can be included in a block by any miner: [3](#0-2) 

During execution, `ProcessConsensusInformation` only performs basic checks: [4](#0-3) 

The `PreCheck` method only verifies the caller is in the current or previous miner list: [5](#0-4) 

For `NextTerm` behavior, validation only adds `RoundTerminateValidationProvider`: [6](#0-5) 

`RoundTerminateValidationProvider` only validates structural correctness (round +1, term +1, InValues null): [7](#0-6) 

**Critically**, there is NO re-validation of the `NeedToChangeTerm` condition during block validation or transaction execution. The `TryToUpdateTermNumber` method only checks that term number increments by 1: [8](#0-7) 

A malicious miner producing a block can construct a valid `NextTermInput` with `term number = current + 1` and `round number = current + 1`, and produce a block with `NextTerm` behavior instead of following `GetConsensusCommand`. The block will pass all validations and execute `ProcessNextTerm`, which performs critical state changes: [9](#0-8) 

## Impact Explanation

This vulnerability has **HIGH** severity impact across multiple protocol subsystems:

1. **Consensus Integrity Breach**: The fundamental invariant that terms change only when time thresholds are met and two-thirds of miners agree is violated, undermining the protocol's time-based consensus security model.

2. **Economic Disruption**: Mining rewards are donated and treasury releases are triggered at incorrect times (lines 203-210), causing fund distributions to occur out of sync with the intended economic schedule.

3. **Governance Manipulation**: Election snapshots are captured prematurely (lines 213-218), potentially affecting validator selection and voting power calculations for subsequent terms.

4. **Miner Schedule Disruption**: The miner list is updated before the intended rotation time (lines 187-190), disrupting block production schedules and potentially enabling colluding miners to extend their control.

5. **Statistical Manipulation**: Performance metrics (missed time slots, produced blocks) are reset early (lines 179-183), potentially masking poor miner performance or manipulating reputation-based mechanisms.

## Likelihood Explanation

The vulnerability has **HIGH** likelihood of exploitation:

**Attacker Profile**: Any miner in the current or previous miner list can execute this attack during their scheduled block production time, representing a significant portion of network participants.

**Technical Complexity**: **LOW** - The attacker only needs to modify their node software to choose `NextTerm` behavior instead of following `GetConsensusCommand`, construct a valid `NextTermInput` with incremented term/round numbers, and produce the block.

**Preconditions**: Minimal - The attacker must be an active or recently active miner with a scheduled block production slot, which is realistic in any functional consensus network.

**Economic Incentives**: Strong motivation exists for attackers to gain extended mining time, disrupt competitors, manipulate treasury release timing, or influence governance outcomes through premature election snapshots.

**Detection vs Prevention**: While premature term changes are visible on-chain, the attack may not be immediately reversible, causing lasting damage to consensus integrity.

## Recommendation

Add time-based validation in the `ValidateBeforeExecution` method or create a dedicated validation provider that checks `NeedToChangeTerm` for `NextTerm` behavior:

```csharp
// In AEDPoSContract_Validation.cs, add for NextTerm case:
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new TermChangeTimeValidationProvider()); // NEW
    break;

// Create new validation provider:
public class TermChangeTimeValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var periodSeconds = State.PeriodSeconds.Value;
        
        if (!validationContext.BaseRound.NeedToChangeTerm(blockchainStartTimestamp, 
            validationContext.CurrentTermNumber, periodSeconds))
        {
            return new ValidationResult 
            { 
                Message = "Time threshold for term change not met with 2/3 miner consensus." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

## Proof of Concept

Due to the complexity of setting up a full AElf consensus test environment with multiple miners and time-based conditions, a complete executable PoC would require significant test infrastructure. However, the vulnerability can be validated by:

1. Examining that `NeedToChangeTerm` is only called in `MainChainConsensusBehaviourProvider.cs` (line 31) and never in validation logic
2. Verifying that `RoundTerminateValidationProvider` performs no time-based checks
3. Confirming that a miner can produce a block with any consensus behavior during their time slot
4. Observing that `ProcessNextTerm` executes all state changes without time validation

The code paths clearly show the missing validation, making this a logic vulnerability rather than requiring runtime demonstration.

---

**Notes**

The key issue is architectural: consensus command generation uses `NeedToChangeTerm` to determine behavior, but block validation assumes miners will follow this recommendation. The validation layer only checks structural correctness, creating a trust assumption on miner behavior that can be violated. The fix requires adding time-based consensus validation to the block validation layer, not just the command generation layer.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-43)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```
