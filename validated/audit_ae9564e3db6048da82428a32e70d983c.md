# Audit Report

## Title
Duplicate Miner Public Keys in Election Victories Cause Consensus Term Transition Failure

## Summary

The Election contract's `GetVictories` method contains a critical logic flaw that produces duplicate public keys when an initial miner is also a valid candidate and there are insufficient valid candidates. This duplicate list causes the consensus contract's `GenerateFirstRoundOfNewTerm` method to throw an `ArgumentException`, resulting in complete consensus term transition failure and blockchain DoS.

## Finding Description

The vulnerability exists in the interaction between the Election and Consensus contracts during term transitions.

**Root Cause - Election Contract:**

When there are insufficient valid candidates (candidates with votes > 0), the `GetVictories` method attempts to fill the miner list with backup miners. [1](#0-0) 

The critical flaw is at lines 68-69. When adding initial miners to the `backups` list, the code only checks `!backups.Contains(k)` but does NOT check if the initial miner is already in `validCandidates`. Since `backups` is created by excluding valid candidates [2](#0-1) , an initial miner who is also a valid candidate will:

1. Already be in `victories` (added from validCandidates at line 65)
2. NOT be in `backups` (excluded at line 66 because they're in validCandidates)
3. Pass the check `!backups.Contains(k)` at line 69
4. Get added to `backups` at lines 68-69
5. Get added to `victories` AGAIN when backups are added [3](#0-2) 

**Failure Point - Consensus Contract:**

When the consensus contract generates a new term round with the duplicated miner list [4](#0-3) , the `ToDictionary` call attempts to create a dictionary using `miner.ToHex()` as the key. When the same hex string appears twice in `Pubkeys`, this throws `ArgumentException: "An item with the same key has already been added"` (standard .NET Dictionary behavior).

**Execution Path:**

The vulnerability is triggered during normal consensus term transitions:
- [5](#0-4)  calls `GenerateFirstRoundOfNextTerm`
- [6](#0-5)  calls `TryToGetVictories`
- [7](#0-6)  retrieves victories from Election contract
- [8](#0-7)  calls `GenerateFirstRoundOfNewTerm` with duplicates
- Exception thrown, term transition fails

## Impact Explanation

This is a **HIGH severity** vulnerability because:

1. **Complete Consensus Failure**: The exception prevents any term transition from completing, effectively halting the blockchain's ability to rotate miners and progress to new consensus terms.

2. **Network-Wide Impact**: All nodes are affected as the blockchain cannot advance past the failed term transition. This freezes the election and governance system's core functionality.

3. **No Attack Required**: This occurs automatically during normal blockchain operation when the preconditions are met - no malicious actor is needed.

4. **Critical Timing**: Most likely to occur during the blockchain's early stages when transitioning from initial miners to elected miners, which is a critical period for network stability.

5. **Difficult Recovery**: Requires contract upgrade or manual intervention to resolve, as every subsequent term transition attempt will fail with the same exception.

## Likelihood Explanation

The likelihood is **HIGH** for the following reasons:

**Preconditions (All Realistic):**
1. Number of valid candidates < MinersCount (common in early blockchain stages)
2. One or more initial miners announce as candidates (expected behavior for continuity)
3. Term transition is triggered (normal periodic operation)

**Probability Factors:**
- Initial miners naturally want to continue participating and will announce as candidates
- During blockchain launch, the election system starts with few candidates
- The first term transition from initial miners to elected miners is highly vulnerable
- No validation or deduplication logic exists to prevent this scenario

**Detection:**
The failure is immediate and deterministic. Once conditions are met, every term transition will fail until the bug is fixed.

## Recommendation

Fix the duplicate check in the Election contract's `GetVictories` method by also checking if initial miners are in the `validCandidates` list:

```csharp
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k) && !validCandidates.Contains(k)));
```

Alternatively, add deduplication before returning:
```csharp
return victories.Distinct().ToList();
```

## Proof of Concept

```csharp
[Fact]
public async Task ElectionContract_GetVictories_DuplicateMinerPublicKeys_Test()
{
    // Setup: Ensure we're in a state with initial miners
    await NextRound(BootMinerKeyPair);
    
    // Make one initial miner announce as candidate and get votes
    var initialMiner = InitialCoreDataCenterKeyPairs.First();
    await AnnounceElectionAsync(initialMiner);
    await VoteToCandidateAsync(VoterKeyPairs[0], initialMiner.PublicKey.ToHex(), 100 * 86400, 100);
    
    // Ensure insufficient valid candidates (less than MinersCount)
    var minersCount = (await ElectionContractStub.GetMinersCount.CallAsync(new Empty())).Value;
    var validCandidatesCount = 1; // Only the initial miner we just voted for
    validCandidatesCount.ShouldBeLessThan(minersCount);
    
    // Get victories - this should contain duplicate entries
    var victories = (await ElectionContractStub.GetVictories.CallAsync(new Empty())).Value
        .Select(p => p.ToHex()).ToList();
    
    // Verify duplicate exists
    var initialMinerHex = initialMiner.PublicKey.ToHex();
    var duplicateCount = victories.Count(v => v == initialMinerHex);
    duplicateCount.ShouldBeGreaterThan(1, "Initial miner should appear multiple times in victories");
    
    // This duplicate list would cause ToDictionary to throw ArgumentException
    // when used in GenerateFirstRoundOfNewTerm
    var minerList = new MinerList { Pubkeys = { victories.Select(ByteStringHelper.FromHexString) } };
    Should.Throw<ArgumentException>(() => 
        minerList.GenerateFirstRoundOfNewTerm(4000, Context.CurrentBlockTime));
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L64-69)
```csharp
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L71-74)
```csharp
            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-18)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L209-209)
```csharp
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-228)
```csharp
        if (TryToGetVictories(out var victories))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L231-231)
```csharp
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-274)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
```
