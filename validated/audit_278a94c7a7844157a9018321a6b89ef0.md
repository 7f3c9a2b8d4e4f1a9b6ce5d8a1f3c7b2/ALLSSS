# Audit Report

## Title
Race Condition in Consensus Order Assignment Leads to Duplicate Mining Orders and Broken Round Schedule

## Summary
The AEDPoS consensus contract contains a race condition that allows multiple miners to be assigned identical `FinalOrderOfNextRound` values when producing blocks concurrently. This violates the critical consensus invariant requiring unique mining orders and causes schedule corruption in subsequent rounds.

## Finding Description

The vulnerability stems from a combination of off-chain order calculation, missing on-chain validation, and insufficient uniqueness checks:

**Off-chain Conflict Resolution:**
Each miner independently calculates their `supposedOrderOfNextRound` using modulo arithmetic on their block signature. When conflicts are detected with existing `FinalOrderOfNextRound` values, the miner resolves them by reassigning conflicting miners to available slots in their local view. [1](#0-0) 

**On-chain Processing Without Re-validation:**
When `UpdateValue` transactions are processed on-chain, the contract directly applies the miner's calculated `FinalOrderOfNextRound` and `TuneOrderInformation` mappings without re-checking for conflicts against the current state after other blocks have been added. [2](#0-1) [3](#0-2) 

**Missing Validation for UpdateValue Behavior:**
The validation framework only applies `NextRoundMiningOrderValidationProvider` to `NextRound` behavior, not to `UpdateValue` behavior where miners set their orders. [4](#0-3) 

**Insufficient Uniqueness Check:**
The `NextRoundMiningOrderValidationProvider` (which only applies to NextRound, not UpdateValue) checks if `MinerInRound` objects are distinct rather than checking if `FinalOrderOfNextRound` values are distinct. Since different miners have different pubkeys and signatures, they are considered distinct objects even when they share the same order value. [5](#0-4) 

**Race Condition Scenario:**
1. Miner A has `FinalOrderOfNextRound = 2` in current on-chain state
2. Miners B and C both read this state concurrently
3. Both calculate `supposedOrderOfNextRound = 2` (signature collision via modulo)
4. Both detect conflict with A and create `TuneOrderInformation = {A: 3}`
5. Both assign themselves `FinalOrderOfNextRound = 2`
6. B's block is processed: A→3, B→2
7. C's block is then processed: A→3 (no-op), C→2
8. Final state: A=3, B=2, C=2 (duplicate)

**Impact on Next Round Generation:**
When the next round is generated, miners are ordered by their `FinalOrderOfNextRound`. Both miners with order=2 are assigned `Order=2` and identical `ExpectedMiningTime` values in the next round, causing them to compete for the same time slot. [6](#0-5) 

## Impact Explanation

This vulnerability breaks fundamental consensus guarantees:

**Consensus Schedule Corruption:**
- Two miners receive identical `Order` values and `ExpectedMiningTime` in the next round
- Both attempt block production at the same time slot, creating conflicting blocks
- One valid order position (e.g., order=1) remains unassigned, creating gaps in the mining schedule
- The invariant that orders 1 through N are uniquely assigned to N miners is violated

**Consensus Reliability Degradation:**
- Deterministic time-slot allocation becomes unpredictable
- Extra block producer calculation may select incorrect miners
- Continuous mining prevention logic may fail with duplicate orders
- Chain progress can be compromised when duplicate-order miners create competing valid blocks

The impact severity is HIGH because it directly compromises consensus integrity and block production determinism.

## Likelihood Explanation

**Triggering Conditions:**
- No special privileges required - occurs during normal mining operations
- Triggered when multiple miners' signatures hash to the same modulo value (probability ≈ 1/N per pair)
- Requires concurrent block production before miners observe each other's state updates
- Probability increases with network latency and decreases with miner count

**Attack Complexity: LOW**
- Can occur naturally without malicious intent as a race condition
- No coordination or timing manipulation required
- With 3 miners and typical network latency (100-500ms), signature collisions combined with concurrent block production could occur multiple times per day

**Reproducibility:**
The vulnerability is reproducible whenever:
1. Two or more miners calculate the same `supposedOrderOfNextRound` 
2. They produce blocks before observing each other's UpdateValue transactions
3. Sequential on-chain processing applies their orders without detecting the conflict

Likelihood is MEDIUM to HIGH on active chains with multiple miners and normal network conditions.

## Recommendation

**Primary Fix - Add Uniqueness Validation for UpdateValue:**

1. Apply order uniqueness validation to UpdateValue behavior:
```csharp
// In AEDPoSContract_Validation.cs, add validator for UpdateValue
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider()); // ADD THIS
    break;
```

2. Fix the validation logic to check order value distinctness:
```csharp
// In NextRoundMiningOrderValidationProvider.cs
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
var distinctCount = finalOrders.Distinct().Count();
if (distinctCount != finalOrders.Count)
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound detected.";
    return validationResult;
}
```

**Secondary Fix - On-chain Duplicate Check:**

Add validation in `ProcessUpdateValue` to verify no duplicate `FinalOrderOfNextRound` exists after applying `TuneOrderInformation`:
```csharp
// After line 260 in ProcessUpdateValue
var ordersAfterTune = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
Assert(ordersAfterTune.Count == ordersAfterTune.Distinct().Count(), 
    "Duplicate mining orders detected after tune.");
```

## Proof of Concept

```csharp
// Test demonstrating the race condition
[Fact]
public async Task RaceCondition_DuplicateOrderAssignment_Test()
{
    // Setup: 3 miners in round, Miner A has FinalOrderOfNextRound = 2
    var currentRound = GenerateRoundWithMiners(3);
    currentRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound = 2;
    
    // Simulate: Both MinerB and MinerC calculate order=2 (signature collision)
    // Both read same state and resolve conflict identically
    var roundForB = currentRound.Clone();
    var roundForC = currentRound.Clone();
    
    // Both apply normal consensus data with colliding signature
    var sigB = GenerateSignatureWithModulo(2, 3);
    var sigC = GenerateSignatureWithModulo(2, 3);
    
    roundForB.ApplyNormalConsensusData("MinerB", Hash.Empty, Hash.Empty, sigB);
    roundForC.ApplyNormalConsensusData("MinerC", Hash.Empty, Hash.Empty, sigC);
    
    // Verify: Both assigned order=2, both tuned A to order=3
    Assert.Equal(2, roundForB.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound);
    Assert.Equal(3, roundForB.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound);
    Assert.Equal(2, roundForC.RealTimeMinersInformation["MinerC"].FinalOrderOfNextRound);
    Assert.Equal(3, roundForC.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound);
    
    // Process: B's block applied first
    await ProcessUpdateValueBlock("MinerB", roundForB);
    
    // Process: C's block applied second
    await ProcessUpdateValueBlock("MinerC", roundForC);
    
    // Result: Both B and C have FinalOrderOfNextRound = 2 (DUPLICATE)
    var finalRound = await GetCurrentRound();
    Assert.Equal(2, finalRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound);
    Assert.Equal(2, finalRound.RealTimeMinersInformation["MinerC"].FinalOrderOfNextRound);
    
    // Impact: Next round has duplicate orders
    finalRound.GenerateNextRoundInformation(Timestamp.Now, Timestamp.Now, out var nextRound);
    var ordersInNextRound = nextRound.RealTimeMinersInformation.Values
        .Select(m => m.Order).ToList();
    
    // Verify schedule corruption: duplicate order 2, missing order (likely 1)
    Assert.True(ordersInNextRound.GroupBy(o => o).Any(g => g.Count() > 1),
        "Duplicate orders exist in next round");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L247-247)
```csharp
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
