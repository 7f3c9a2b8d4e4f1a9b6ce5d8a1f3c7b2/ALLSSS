# Audit Report

## Title
VoteId Collision Enables Vote Overwriting and Permanent Token Lock DoS in Delegated Voting

## Summary
The VoteContract contains a critical vulnerability where VoteIds can be overwritten across different voting items due to lack of uniqueness validation. Attackers can register delegated voting items (IsLockToken=false), compute victim VoteIds from public blockchain data, and overwrite VotingRecords, causing permanent token lock DoS for victims who can no longer withdraw their locked funds.

## Finding Description

**Root Cause - Missing Uniqueness Check:**

The Vote function directly overwrites VotingRecords without checking if a VoteId already exists: [1](#0-0) 

**Delegated Voting Allows Arbitrary VoteIds:**

For delegated voting (IsLockToken=false), sponsors explicitly provide VoteIds with no validation against existing records: [2](#0-1) 

**VoteId Generation is Deterministic and Public:**

For locked voting (IsLockToken=true), VoteIds are generated deterministically from publicly observable transaction data: [3](#0-2) 

The GenerateId implementation uses OriginTransactionId which becomes public after transaction execution: [4](#0-3) 

**No Access Control on Register:**

Anyone can register a voting item and become its sponsor: [5](#0-4) 

**Attack Path:**
1. Attacker registers voting item with IsLockToken=false, becomes sponsor
2. Victim votes on legitimate voting item with IsLockToken=true, tokens get locked
3. Attacker observes victim's transaction and computes VoteId from public data (OriginTransactionId + ContractAddress + VotesAmount)
4. Attacker calls Vote on their voting item with victim's VoteId, overwriting the VotingRecord
5. VotingRecord.VotingItemId now points to attacker's voting item instead of victim's

**Withdrawal Fails Due to Permission Check:**

When victim attempts withdrawal, the permission check reads the overwritten VotingRecord: [6](#0-5) 

Since the overwritten VotingRecord references the attacker's voting item (IsLockToken=false), the check at line 200 fails because the victim is not the sponsor of the attacker's item.

**Tokens Remain Permanently Locked:**

Victims cannot bypass VoteContract and unlock directly because the virtual address computation requires Context.Sender to be the original locker (VoteContract): [7](#0-6) 

The Lock function computed the same virtual address using Context.Sender: [8](#0-7) 

## Impact Explanation

**Permanent Token Lock DoS:**
- Victim's tokens remain locked in TokenContract with VoteId as LockId
- Withdrawal through VoteContract fails due to permission check against attacker's voting item
- Direct unlock from TokenContract impossible due to virtual address computation requirements
- Funds are permanently inaccessible to the victim

**Data Corruption:**
- VotedItemsMap references VoteIds that now point to different voters/voting items
- Vote count inflation: Original vote contribution remains while new vote contribution is added
- Voting integrity compromised: Legitimate votes effectively deleted

**Severity Assessment:**
HIGH severity due to:
- Permanent fund loss for victims
- No recovery mechanism available
- Affects core voting and token lock functionality

## Likelihood Explanation

**Attack Requirements:**
1. Register voting item with IsLockToken=false (unrestricted public method)
2. Observe victim's vote transaction on public blockchain
3. Compute VoteId from public data (OriginTransactionId + ContractAddress + VotesAmount)
4. Call Vote with computed VoteId

**Attack Complexity:** LOW
- Only 2 transactions needed (Register + Vote)
- All required data is publicly observable on-chain
- VoteId computation is deterministic and reproducible
- No special permissions or roles required

**Feasibility:** HIGH
- Minimal gas fees required
- No rate limiting or detection mechanisms
- Attack is undetectable until victim attempts withdrawal
- Works against any user voting on IsLockToken=true items

**Probability:** HIGH
Given the low cost, public data availability, no access controls, and lack of detection mechanisms, this attack is highly likely to occur in production.

## Recommendation

**Primary Fix - Add Uniqueness Check:**
Add validation in the Vote function to prevent overwriting existing VotingRecords:

```csharp
public override Empty Vote(VoteInput input)
{
    var votingItem = AssertValidVoteInput(input);
    
    // Add uniqueness check
    var existingRecord = State.VotingRecords[input.VoteId];
    Assert(existingRecord == null || existingRecord.IsWithdrawn, 
        "Vote ID already exists and is active.");
    
    // Rest of implementation...
}
```

**Secondary Fix - Scope VoteIds:**
Alternatively, scope VotingRecords by both VotingItemId and VoteId to prevent cross-voting-item collisions:

```csharp
// Change state structure
public MappedState<Hash, Hash, VotingRecord> VotingRecords { get; set; }
// Usage: State.VotingRecords[votingItemId][voteId]
```

**Additional Hardening:**
- For delegated voting, validate that provided VoteIds don't conflict with the deterministic generation pattern used for locked voting
- Add event logging for VoteId conflicts to enable monitoring

## Proof of Concept

```csharp
[Fact]
public async Task VoteIdCollision_CausesPermanentTokenLock()
{
    // Setup: Victim creates legitimate voting item with IsLockToken=true
    var victimVotingItemId = await RegisterVotingItem(victim, isLockToken: true);
    
    // Victim votes and locks tokens
    var victimVoteId = await VoteAndGetVoteId(victim, victimVotingItemId, amount: 1000);
    
    // Attacker registers delegated voting item with IsLockToken=false
    var attackerVotingItemId = await RegisterVotingItem(attacker, isLockToken: false);
    
    // Attacker computes victim's VoteId from public transaction data
    // (In real scenario, this would be read from blockchain)
    var computedVoteId = victimVoteId;
    
    // Attacker overwrites victim's VotingRecord by voting with same VoteId
    await Vote(attacker, attackerVotingItemId, computedVoteId, voter: attackerAddress);
    
    // Verify: Victim cannot withdraw - permission check fails
    var withdrawResult = await ExecuteContractWithMiningAsync(
        VoteContractAddress, 
        nameof(VoteContract.Withdraw),
        new WithdrawInput { VoteId = victimVoteId }
    );
    
    // Assert withdrawal fails with "No permission to withdraw votes of others"
    withdrawResult.Status.ShouldBe(TransactionResultStatus.Failed);
    withdrawResult.Error.ShouldContain("No permission to withdraw votes of others");
    
    // Verify: Tokens remain locked permanently
    var tokenBalance = await GetBalance(victim, tokenSymbol);
    var lockedBalance = await GetLockedBalance(victim, tokenSymbol, victimVoteId);
    lockedBalance.ShouldBe(1000); // Tokens still locked
}
```

**Notes:**
- This vulnerability affects all users who vote on voting items with IsLockToken=true
- The attack is undetectable until victims attempt withdrawal
- Tokens can be locked for extended periods (months/years) before victims discover the issue
- No recovery mechanism exists once the attack succeeds

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-39)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-200)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-388)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-146)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-210)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-235)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```
