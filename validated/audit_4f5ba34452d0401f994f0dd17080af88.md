# Audit Report

## Title
Missing Organization Address Validation in Cross-Chain Indexing Proposal Release Allows Bypass of Controller Authority

## Summary
The `HandleIndexingProposal()` function fails to validate that a proposal's organization address matches the current controller's owner address before releasing it. This allows proposals approved under a previous controller to be released after the controller has been changed, completely bypassing the new controller's authority and enabling the indexing of potentially malicious cross-chain data.

## Finding Description
The vulnerability exists due to an inconsistency between the view function `GetIndexingProposalStatus()` and the execution function `HandleIndexingProposal()` in handling proposal validation.

**Correct Validation (View Function):**
The `GetIndexingProposalStatus()` function correctly validates that a proposal's organization address matches the current controller's owner address before marking it as ready for release. [1](#0-0) 

This dual validation ensures only proposals from the currently authorized organization can be released.

**Missing Validation (Execution Function):**
The `HandleIndexingProposal()` function only checks if the proposal has `ToBeReleased` set to true, without verifying the organization address. [2](#0-1) 

**Root Cause:**
When proposals are created via `ProposeCrossChainBlockData()`, they capture the organization address from the controller at creation time. [3](#0-2) 

When the controller is subsequently changed via `ChangeCrossChainIndexingController()`, the method only updates the controller state and does NOT invalidate or clear existing pending proposals. [4](#0-3) 

**Execution Path:**
Miners call `ReleaseCrossChainIndexingProposal()` [5](#0-4)  which calls `ReleaseIndexingProposal()` [6](#0-5)  which retrieves the proposal from the Parliament contract and calls `HandleIndexingProposal()`, failing to validate that the proposal's organization address matches the current controller.

The Parliament contract's `Release` method only verifies that the caller is the proposer (the CrossChain contract) and that the release threshold is reached, but does not check organization address consistency. [7](#0-6) 

## Impact Explanation
**Authorization Bypass:** Proposals approved by a previous controller organization can be released after governance has legitimately changed the controller to a different organization. This completely bypasses the new controller's authority and violates the fundamental governance invariant that only the current authorized controller should approve cross-chain indexing.

**Governance Integrity Violation:** If the controller is changed to upgrade security (e.g., from a compromised or outdated organization to a secure one), old proposals approved under the previous organization can still be released, defeating the entire purpose of the controller change.

**Cross-Chain Data Integrity:** Malicious or outdated cross-chain block data from the old organization can be indexed into the chain, potentially enabling invalid merkle proof verification paths through `VerifyTransaction()`, incorrect parent/side-chain height synchronization affecting all cross-chain operations, and acceptance of fraudulent cross-chain transactions.

**Severity:** Critical - This breaks the core security model of governance-controlled cross-chain indexing. All participants relying on cross-chain data integrity, including users of side chains and cross-chain assets, are affected.

## Likelihood Explanation
**Attack Requirements:**
1. A proposal must be approved under a controller that will later be changed
2. The controller must be changed via legitimate governance process
3. A miner must call `ReleaseCrossChainIndexingProposal()` after the controller change

**Feasibility:** The vulnerability is highly realistic because:
- Controller changes are legitimate governance operations that occur for security upgrades or organizational restructuring
- Proposals can remain pending for multiple blocks between approval and release
- The Parliament contract stores proposals independently of the CrossChain contract's controller state
- No automatic cleanup mechanism exists when controllers are changed
- The inconsistency between the view function (which includes the check) and execution function (which doesn't) strongly suggests this was an oversight rather than intentional design

**Probability:** Medium to High - While controller changes are uncommon, when they do occur (especially for security reasons), this vulnerability creates a critical window where old proposals can bypass the new controller's authority.

## Recommendation
Add the organization address validation check in the `HandleIndexingProposal()` function to match the validation present in `GetIndexingProposalStatus()`:

```csharp
private void HandleIndexingProposal(Hash proposalId)
{
    var crossChainIndexingController = GetCrossChainIndexingController();
    var proposal = GetCrossChainProposal(crossChainIndexingController, proposalId);
    Assert(proposal.ToBeReleased, "Not approved cross chain indexing proposal.");
    // Add this validation:
    Assert(proposal.OrganizationAddress == crossChainIndexingController.OwnerAddress,
        "Proposal organization does not match current controller.");
    Context.SendInline(crossChainIndexingController.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
        proposal.ProposalId);
}
```

Additionally, consider clearing or invalidating pending proposals in `ChangeCrossChainIndexingController()` to prevent any confusion or potential exploitation during controller transitions.

## Proof of Concept
A proof of concept would involve:
1. Setting up an initial cross-chain indexing controller with organization A
2. Creating and approving a cross-chain indexing proposal under controller A
3. Changing the controller to organization B using `ChangeCrossChainIndexingController()`
4. Calling `ReleaseCrossChainIndexingProposal()` with the proposal from controller A
5. Observing that the proposal is successfully released despite controller B never approving it

The test would demonstrate that the proposal's organization address (A) does not match the current controller's organization address (B), yet the proposal is still executed, proving the authorization bypass.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L177-179)
```csharp
            pendingChainIndexingProposalStatus.ToBeReleased =
                proposalInfo.ToBeReleased &&
                proposalInfo.OrganizationAddress == crossChainIndexingController.OwnerAddress;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L297-307)
```csharp
    private void ReleaseIndexingProposal(IEnumerable<int> chainIdList)
    {
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");
            HandleIndexingProposal(pendingCrossChainIndexingProposal.ProposalId);
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L409-409)
```csharp
                    OrganizationAddress = crossChainIndexingController.OwnerAddress,
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L455-463)
```csharp
    private void HandleIndexingProposal(Hash proposalId)
    {
        var crossChainIndexingController = GetCrossChainIndexingController();
        var proposal = GetCrossChainProposal(crossChainIndexingController, proposalId);
        Assert(proposal.ToBeReleased, "Not approved cross chain indexing proposal.");
        Context.SendInline(crossChainIndexingController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            proposal.ProposalId); // release if ready
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
