# Audit Report

## Title
Scheme Metadata Overwrite Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
The TokenHolder contract allows managers to create multiple schemes but stores only one scheme's metadata per manager address. When a manager creates a second scheme, it overwrites the first scheme's metadata including the token symbol. Users who locked tokens under the first scheme become unable to withdraw because the withdrawal mechanism queries for the wrong token symbol, permanently trapping their funds.

## Finding Description

The vulnerability stems from an architectural mismatch between the TokenHolder and Profit contracts that causes permanent fund loss through symbol confusion.

**Root Cause: Single-Slot Metadata Storage**

The TokenHolder contract stores scheme metadata in a single-address mapping that gets overwritten when the same manager creates multiple schemes. [1](#0-0) 

The CreateScheme method has no duplicate prevention check and unconditionally overwrites the metadata at the manager's address. [2](#0-1) 

**Conflict: Multi-Scheme Support in Profit Contract**

In contrast, the Profit contract explicitly supports multiple schemes per manager by appending new schemes to a list. [3](#0-2) 

**Critical Flow: LockId Without Scheme Identifier**

When users register for profits, the lockId is generated using only the manager and user addresses, without any scheme-specific identifier. [4](#0-3) 

Tokens are locked using the scheme's symbol from the current metadata. [5](#0-4) 

**Virtual Address Computation Without Symbol**

The MultiToken Lock operation computes the virtual address from sender, user address, and lockId - but NOT the symbol. [6](#0-5) 

The Unlock operation uses the same address computation. [7](#0-6) 

**Symbol Mismatch During Withdrawal**

When withdrawing, GetValidScheme retrieves the overwritten metadata with the new symbol. [8](#0-7) 

The UpdateTokenHolderProfitScheme method fetches the first scheme ID from the Profit contract but keeps the overwritten symbol from the TokenHolder metadata. [9](#0-8) 

The withdrawal queries locked amount using the incorrect symbol. [10](#0-9) 

**Symbol-Specific Balance Query**

GetLockedAmount computes the virtual address and queries the balance for the specified symbol. [11](#0-10) 

Since tokens locked with symbol "ELF" exist at the virtual address but the query asks for "USDT", the balance returned is 0, causing the unlock to execute with amount=0.

**Attack Scenario:**
1. Manager creates Scheme A with Symbol="ELF"
2. User locks 1000 ELF tokens via RegisterForProfits
3. Manager creates Scheme B with Symbol="USDT" (overwrites metadata)
4. User calls Withdraw → queries for "USDT" instead of "ELF" → receives 0 tokens
5. User's 1000 ELF tokens remain permanently locked at the virtual address

## Impact Explanation

**HIGH Severity - Permanent Fund Loss:**
- Users who registered for profits before a scheme overwrite lose 100% of their locked tokens permanently
- The GetLockedAmount call returns 0 due to the symbol mismatch between locked tokens and queried symbol
- The Unlock operation executes with amount=0, leaving original tokens inaccessible
- No recovery mechanism exists in the contract - even the manager cannot reverse this
- Violates the critical invariant: "users can unlock tokens they previously locked"

**Scope:**
- Affects ALL users who registered under a manager before that manager creates a new scheme
- No time-based expiration or admin override
- The locked tokens become permanently inaccessible through any contract operation

## Likelihood Explanation

**MEDIUM-HIGH Likelihood:**
- Any address can call CreateScheme (public entry point with no access restrictions)
- No validation prevents a manager from creating multiple schemes
- The Profit contract explicitly supports this pattern, encouraging managers to create multiple schemes
- Can be triggered accidentally by a legitimate manager attempting to "update" their scheme configuration
- No warnings or documentation exist to prevent this behavior
- Deterministic outcome with no timing constraints or race conditions required

## Recommendation

**Fix 1: Use Composite Key for Scheme Storage**

Change the TokenHolderProfitSchemes mapping to use a composite key that includes the scheme ID:
```
MappedState<Address, Hash, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

Store using both manager address and scheme ID to prevent overwrites.

**Fix 2: Add Duplicate Prevention**

Add an assertion in CreateScheme to prevent creating multiple schemes:
```csharp
Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, "Scheme already exists for this manager.");
```

**Fix 3: Include Scheme ID in LockId**

Modify RegisterForProfits to include the scheme ID in the lockId generation:
```csharp
var lockId = Context.GenerateId(Context.Self,
    ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), 
                                  Context.Sender.ToByteArray(),
                                  scheme.SchemeId.ToByteArray()));
```

This ensures each scheme has unique lock identifiers even for the same user.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwriteCausesPermanentTokenLock()
{
    // Setup: Manager creates first scheme for ELF
    var manager = Accounts[0].Address;
    var user = Accounts[1].Address;
    
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // User locks 1000 ELF tokens
    await TokenStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await TokenHolderStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 1000
    });
    
    // Verify tokens are locked
    var lockedBefore = await TokenStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = GenerateLockId(manager, user)
    });
    Assert.Equal(1000, lockedBefore.Amount);
    
    // Manager creates second scheme for USDT - OVERWRITES metadata
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 1
    });
    
    // User attempts withdrawal after lock period
    await TokenHolderStub.Withdraw.SendAsync(manager);
    
    // VULNERABILITY: User receives 0 tokens due to symbol mismatch
    var userBalance = await TokenStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user,
        Symbol = "ELF"
    });
    
    // Tokens remain locked permanently
    var lockedAfter = await TokenStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = GenerateLockId(manager, user)
    });
    
    Assert.Equal(0, userBalance.Balance); // User got nothing back
    Assert.Equal(1000, lockedAfter.Amount); // Tokens still locked
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-298)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-242)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L104-115)
```csharp
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
