# Audit Report

## Title
TermNumber Increment Bypass via NextRound Behavior Validation Gap

## Summary
A malicious miner can craft a consensus block with NextRound behavior but an incremented TermNumber, bypassing validation to skip critical term transition logic including mining reward distribution, election snapshots, miner list updates, and missed time slot penalties, while causing persistent state inconsistency between `State.CurrentTermNumber` and stored round data.

## Finding Description

The AEDPoS consensus contract contains a critical validation gap in the round termination validation logic. When a block header specifies `AElfConsensusBehaviour.NextRound`, the `RoundTerminateValidationProvider` immediately returns `ValidationForNextRound()` results without verifying TermNumber consistency. [1](#0-0) 

The `ValidationForNextRound()` method only validates that the round number increments by exactly 1 and that InValues are null - it completely omits TermNumber validation. [2](#0-1) 

In contrast, `ValidationForNextTerm()` explicitly checks TermNumber consistency by verifying the term number increments by exactly 1, demonstrating this is a critical protocol invariant. [3](#0-2) 

When legitimate NextRound data is generated via `GenerateNextRoundInformation()`, it explicitly preserves the current TermNumber, confirming that NextRound transitions should NOT change terms. [4](#0-3) 

However, the `NextRoundInput.ToRound()` conversion method blindly copies the TermNumber from input without any validation. [5](#0-4) 

During execution, `ProcessNextRound()` updates only `State.CurrentRoundNumber` through `TryToUpdateRoundNumber()` but never calls `TryToUpdateTermNumber()`, creating state desynchronization. [6](#0-5) 

The malicious round with incremented TermNumber is stored directly via `AddRoundInformation()` without any additional validation. [7](#0-6) 

**Attack Execution Flow**:
1. Attacker (an elected miner serving as extra block producer) obtains legitimate NextRound consensus data from `GetConsensusBlockExtraData` [8](#0-7) 
2. Attacker modifies `extraData.Round.TermNumber` to increment it by 1
3. Attacker submits the block with modified header
4. Validation passes because `ValidationForNextRound()` doesn't check TermNumber
5. `ProcessNextRound()` executes, storing the malicious TermNumber but not updating `State.CurrentTermNumber`

**Result**: `State.CurrentTermNumber` remains at the old value while `State.Rounds[roundNumber].TermNumber` is incremented, creating persistent state inconsistency.

## Impact Explanation

**Critical State Inconsistency**: The desynchronization between `State.CurrentTermNumber` (the authoritative term tracker) and the stored round's TermNumber corrupts term-based lookups throughout the consensus system. This affects election snapshots, miner list mappings, reward calculations, and term transition detection.

**Bypassed Critical Term Logic**: The attacker completely bypasses all term transition operations that occur in `ProcessNextTerm()`:

1. **Mining Reward Theft**: `DonateMiningReward()` and `TreasuryContract.Release()` are not executed, preventing proper mining reward distribution to the dividends pool and treasury fund releases for the skipped term. [9](#0-8) 

2. **Election System Corruption**: `ElectionContract.TakeSnapshot()` is skipped, breaking the election snapshot mechanism that records mined blocks and establishes voting power for the term. [10](#0-9) 

3. **Miner List Desynchronization**: `SetMinerList()` and `State.FirstRoundNumberOfEachTerm` updates are skipped, preventing proper miner list tracking for the new term. [11](#0-10) 

4. **Accountability Bypass**: `CountMissedTimeSlots()` is not called, allowing miners to evade penalties for missed time slots in the previous round. [12](#0-11) 

This breaks the economic model (reward distribution), governance integrity (election records), and miner accountability mechanisms (penalty tracking) - three fundamental pillars of the AEDPoS consensus protocol.

## Likelihood Explanation

**Attacker Profile**: The attacker must be an elected miner selected as the extra block producer for a round. Both conditions are readily achievable:
- Miners are elected through the normal election process (realistic for any participant with sufficient stake/votes)
- Extra block producer selection is deterministic based on the first miner's signature [13](#0-12) 

**Technical Feasibility**: The attack requires no special economic cost beyond normal block production. Miners have full control over block header creation and can modify consensus data before submitting blocks. The validation gap guarantees success - there is no code path that would detect this attack.

**Detection Difficulty**: The modified TermNumber appears in stored round data (`State.Rounds[roundNumber]`) but `State.CurrentTermNumber` remains unchanged. This creates subtle inconsistencies that may not immediately trigger monitoring alerts, allowing the attack to persist across multiple rounds until manual investigation.

The validation logic explicitly confirms no TermNumber check exists for NextRound behavior. [14](#0-13) 

## Recommendation

Add TermNumber consistency validation to `ValidationForNextRound()` to ensure NextRound transitions preserve the current term:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // ADD THIS: Validate TermNumber remains unchanged for NextRound
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "TermNumber must not change during NextRound transition." };
    
    // Validate InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

This ensures NextRound transitions cannot modify TermNumber, aligning validation with the protocol invariant demonstrated by `GenerateNextRoundInformation()` and `ProcessNextRound()`.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system and the need for a full blockchain environment with proper miner election state, a complete PoC would require:

1. Setting up a test chain with elected miners
2. Configuring a test miner to be the extra block producer
3. Modifying block header generation to increment TermNumber
4. Observing successful validation despite the malicious modification
5. Verifying state inconsistency: `State.CurrentTermNumber` unchanged while `State.Rounds[roundNumber].TermNumber` incremented

The vulnerability is confirmed through code analysis showing:
- No TermNumber validation in `ValidationForNextRound()` [2](#0-1) 
- `ProcessNextRound()` never updates `State.CurrentTermNumber` [6](#0-5) 
- `ProcessNextTerm()` contains all bypassed logic [15](#0-14)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L14-14)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L21-22)
```csharp
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
