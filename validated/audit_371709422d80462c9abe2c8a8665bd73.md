# Audit Report

## Title
Authorization Bypass: Unauthorized Miners Can Gain Extra Block Production Rights Through Premature NextRound Execution

## Summary
The AEDPoS consensus mechanism fails to validate which miner is authorized to terminate the current round. Any miner whose time slot has passed can mine a NextRound block and automatically receive `ExtraBlockProducerOfPreviousRound` status, granting them extended block production privileges in the subsequent round that should only go to the legitimately designated extra block producer.

## Finding Description

The vulnerability stems from a critical authorization gap in the round termination logic. The system deterministically selects one extra block producer per round using `CalculateNextExtraBlockProducerOrder()` and marks them with `IsExtraBlockProducer = true`. [1](#0-0) 

However, any miner whose time slot has passed can obtain NextRound consensus behavior. The `GetConsensusBehaviour()` method returns `GetConsensusBehaviourToTerminateCurrentRound()` without verifying if the miner is the designated extra block producer. [2](#0-1) 

When processing a NextRound block, the system unconditionally assigns the terminating miner's pubkey to `ExtraBlockProducerOfPreviousRound` without any authorization check. [3](#0-2) 

This grants unauthorized extended privileges. Miners whose pubkey matches `ExtraBlockProducerOfPreviousRound` receive the right to produce additional tiny blocks beyond the normal limit, as documented in the code comments and logic. [4](#0-3) 

**Why Existing Validations Fail:**

The `PreCheck()` method only verifies the miner is in the current or previous miner list, not whether they are the designated extra block producer. [5](#0-4) 

The `RoundTerminateValidationProvider` only validates round number increment and that InValues are null, without checking authorization. [6](#0-5) 

The `TimeSlotValidationProvider` for NextRound (new round ID) only validates the NEW round's time slot structure via `CheckRoundTimeSlots()`, not who can call it. [7](#0-6) 

The `NextRoundMiningOrderValidationProvider` only checks that mining orders are consistent, not sender authorization. [8](#0-7) 

## Impact Explanation

This vulnerability breaks the fundamental fairness invariant of AEDPoS where block production opportunities should be deterministically distributed. The attacker gains `(_maximumBlocksCount + blocksBeforeCurrentRound)` block production rights instead of the standard `_maximumBlocksCount`, while the legitimate extra block producer loses their rightful privileges.

With typical configuration (_maximumBlocksCount = 8), the attacker gains 8 extra tiny blocks per successful exploit. Repeated exploitation across rounds accumulates unfair advantage. Additional block production translates to:
- Disproportionate mining rewards
- Extra transaction fee revenue
- Potential transaction censorship through control of extra blocks
- MEV extraction opportunities

This violates the consensus invariant of miner schedule integrity by allowing unauthorized privilege escalation in the mining schedule.

## Likelihood Explanation

**Prerequisites:** The attacker must be in the current miner list (standard requirement for consensus participation) and run modified node software to bypass client-side timing constraints.

**Attack Execution:**
1. Monitor for when own time slot passes
2. Immediately mine and broadcast NextRound block before the designated extra block producer
3. Win the propagation race

**Feasibility:** The attack window opens when any miner's time slot passes. There are no cryptographic or economic barriers preventing execution. Success depends on network latency and block propagation timing. The attack is difficult to distinguish from legitimate fallback scenarios (e.g., offline extra block producer).

Any miner can attempt this attack with reasonable success probability. The modified node software is straightforward to implement, and the attack can be repeated across rounds. The absence of on-chain authorization validation makes prevention challenging.

**Assessment: HIGH**

## Recommendation

Add authorization validation to ensure only the designated extra block producer can execute NextRound:

```csharp
// In RoundTerminateValidationProvider.ValidationForNextRound() or PreCheck()
var extraBlockProducerOfCurrentRound = validationContext.BaseRound
    .RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.IsExtraBlockProducer);
    
if (extraBlockProducerOfCurrentRound == null || 
    extraBlockProducerOfCurrentRound.Pubkey != validationContext.SenderPubkey)
{
    return new ValidationResult 
    { 
        Message = "Only the designated extra block producer can terminate the round." 
    };
}
```

Alternatively, validate in `GetConsensusBehaviourToTerminateCurrentRound()` before returning NextRound behavior.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Deploying a consensus contract test with multiple miners
2. Having a non-designated miner call NextRound after their time slot passes
3. Observing that the transaction succeeds and they receive `ExtraBlockProducerOfPreviousRound` status
4. Verifying they can produce `(_maximumBlocksCount + blocksBeforeCurrentRound)` blocks in the next round

The key validation gap exists because none of the validation providers check the `IsExtraBlockProducer` flag of the sender against the current round's designated extra block producer when processing NextRound transactions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L67-79)
```csharp
                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```
