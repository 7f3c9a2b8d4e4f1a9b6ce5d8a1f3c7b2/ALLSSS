# Audit Report

## Title
Multi-Identity Continuous Block Limit Bypass via Controlled Miner Rotation

## Summary

An entity controlling multiple elected miner positions can bypass the 8-block continuous production limit by rotating between different public keys. The counter reset mechanism tracks limits per-pubkey rather than per-entity, allowing coordinated attackers to produce N×8 continuous blocks instead of the intended maximum of 8, directly violating the fork prevention design goal.

## Finding Description

The AEDPoS consensus implements a continuous block limit to prevent excessive fork creation. However, this protection operates solely at the individual public key level without detecting coordinated control across multiple miner identities.

The vulnerability exists in the interaction between three critical components:

**1. Validation Logic (Per-Pubkey Only):**

The continuous block validator only rejects blocks when the SAME pubkey exceeds the limit. [1](#0-0)  When a different pubkey produces a block, validation passes unconditionally regardless of how many continuous blocks have been produced by potentially related entities.

**2. Counter Reset Mechanism (Exploitable):**

The counter reset logic treats different pubkeys as independent producers. [2](#0-1)  When a different pubkey produces a block, the counter resets to `minersCountInTheory - 1` (typically 7), rather than tracking cumulative continuous blocks across potentially related entities.

**3. No Multi-Identity Prevention:**

The election system allows a single admin to control multiple candidate pubkeys without restrictions. [3](#0-2)  The admin management mechanism explicitly supports multiple pubkeys per admin. [4](#0-3) 

The election victory selection is purely vote-based with no same-controller detection. [5](#0-4) 

The `BreakContinuousMining` scheduling mechanism only prevents the SAME pubkey from mining consecutively across rounds, not different pubkeys controlled by the same entity. [6](#0-5) 

**Attack Execution:**

1. Entity X registers N candidates using `AnnounceElectionFor` with different pubkeys (requires N × 100,000 ELF). [7](#0-6) 
2. Gets them elected through voting
3. If scheduled consecutively or nearby:
   - Miner A produces 8 blocks (counter: 7→6→5→4→3→2→1→0)
   - Miner B produces next 8 blocks (counter resets to 7 because different pubkey)
   - Miner C continues for another 8 blocks (counter resets again)
   - Total: 24 continuous blocks instead of intended 8

The maximum blocks constant is explicitly defined as 8. [8](#0-7) 

## Impact Explanation

**Severity: MEDIUM-HIGH**

The continuous block limit's explicit purpose is documented in code as "to avoid too many forks". [9](#0-8)  This bypass constitutes a direct consensus integrity violation.

**Concrete Harms:**
- **Fork Probability Multiplication:** With N controlled miners, fork risk increases by factor of N (3 miners = 3× risk with 24 blocks vs 8)
- **LIB Delay:** Excessive continuous blocks delay round progression, which is required for Last Irreversible Block height advancement
- **Consensus Dominance:** Coordinated miners can dominate block production within their collective time slots
- **Design Invariant Violation:** Breaks the fundamental assumption that no entity can produce more than 8 continuous blocks

**Affected Parties:** All network participants depending on timely finality and fair consensus operation.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Required Capabilities:**
- Economic: N × 100,000 ELF deposit (e.g., 300,000 ELF for 3 miners)
- Governance: Maintain sufficient votes for multiple candidates to be elected
- Coordination: Time block production during respective time slots

**Feasibility Assessment:**
- Entry points are public and unrestricted (`AnnounceElectionFor`, consensus commands)
- No technical or cryptographic barriers
- High capital requirement limits casual exploitation
- However, achievable for well-funded entities, whale voters, or validator cartels
- No detection mechanism exists to identify related miner identities or admins

**Existing Mitigation (Insufficient):**

Dynamic adjustment during severe blockchain status reduces the limit to 1 block, [10](#0-9)  but this is reactive (triggers after damage) rather than preventive.

## Recommendation

Implement entity-level continuous block tracking through one or more of the following approaches:

1. **Admin-Based Tracking:** Track continuous blocks by candidate admin address rather than individual pubkey, preventing coordinated rotation attacks.

2. **Temporal Gap Requirement:** Enforce a minimum number of different-admin miners between consecutive time slots for miners sharing the same admin.

3. **Cross-Miner Counter:** Maintain a global continuous block counter that only resets when a miner from a different admin produces a block.

Example fix for `ResetLatestProviderToTinyBlocksCount`:

```csharp
private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
{
    var currentAdmin = State.CandidateAdmins[_processingBlockMinerPubkey];
    LatestPubkeyToTinyBlocksCount currentValue;
    
    if (State.LatestPubkeyToTinyBlocksCount.Value == null)
    {
        currentValue = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = _processingBlockMinerPubkey,
            BlocksCount = minersCountInTheory.Sub(1)
        };
        State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
    }
    else
    {
        currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
        var previousAdmin = State.CandidateAdmins[currentValue.Pubkey];
        
        // Only reset counter if different admin (not just different pubkey)
        if (currentAdmin == previousAdmin)
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = currentValue.BlocksCount.Sub(1)
            };
        else
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = minersCountInTheory.Sub(1)
            };
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MultiIdentity_ContinuousBlock_Bypass_Test()
{
    // Setup: Register 3 candidates under same admin
    var attackerAdmin = Accounts[10].Address;
    var miner1KeyPair = CryptoHelper.GenerateKeyPair();
    var miner2KeyPair = CryptoHelper.GenerateKeyPair();
    var miner3KeyPair = CryptoHelper.GenerateKeyPair();
    
    // Register all 3 miners with same admin
    await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = miner1KeyPair.PublicKey.ToHex(),
        Admin = attackerAdmin
    });
    await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = miner2KeyPair.PublicKey.ToHex(),
        Admin = attackerAdmin
    });
    await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = miner3KeyPair.PublicKey.ToHex(),
        Admin = attackerAdmin
    });
    
    // Get them elected and transition to new term
    await VoteAndTransitionToNewTerm(new[] { miner1KeyPair, miner2KeyPair, miner3KeyPair });
    
    var totalContinuousBlocks = 0;
    
    // Miner 1 produces 8 blocks
    for (int i = 0; i < 8; i++)
    {
        await ProduceBlock(miner1KeyPair);
        totalContinuousBlocks++;
    }
    
    // Verify counter for Miner 1 is exhausted
    var latestCount1 = await AEDPoSContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    latestCount1.BlocksCount.ShouldBe(0);
    
    // Miner 2 produces 8 blocks (counter should reset due to different pubkey)
    for (int i = 0; i < 8; i++)
    {
        await ProduceBlock(miner2KeyPair);
        totalContinuousBlocks++;
    }
    
    // Verify counter reset for Miner 2
    var latestCount2 = await AEDPoSContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    latestCount2.Pubkey.ShouldBe(miner2KeyPair.PublicKey.ToHex());
    latestCount2.BlocksCount.ShouldBe(0); // Exhausted after 8 blocks
    
    // Miner 3 produces 8 blocks (counter resets again)
    for (int i = 0; i < 8; i++)
    {
        await ProduceBlock(miner3KeyPair);
        totalContinuousBlocks++;
    }
    
    // VULNERABILITY: 24 continuous blocks produced instead of maximum 8
    totalContinuousBlocks.ShouldBe(24);
    
    // All 3 miners share same admin, violating fork prevention design
    var admin1 = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue 
        { Value = miner1KeyPair.PublicKey.ToHex() });
    var admin2 = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue 
        { Value = miner2KeyPair.PublicKey.ToHex() });
    var admin3 = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue 
        { Value = miner3KeyPair.PublicKey.ToHex() });
    
    admin1.ShouldBe(attackerAdmin);
    admin2.ShouldBe(attackerAdmin);
    admin3.ShouldBe(attackerAdmin);
}
```

This test demonstrates that an entity controlling 3 miners with different pubkeys but the same admin can produce 24 continuous blocks, tripling the fork risk beyond the intended 8-block limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L17-23)
```csharp
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-363)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L19-19)
```csharp
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```
