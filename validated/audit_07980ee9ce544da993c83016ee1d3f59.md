# Audit Report

## Title
Conflict Resolution Failure Due to TOCTOU Race and Insufficient Validation Enabling Duplicate Mining Order Assignments

## Summary
A TOCTOU (Time-of-Check to Time-of-Use) race condition in the AEDPoS consensus mechanism allows multiple miners to be assigned identical `FinalOrderOfNextRound` values when their signatures collide. Combined with buggy validation logic that uses reference equality instead of value equality, this enables duplicate mining order assignments that violate consensus schedule integrity, causing multiple miners to compete for the same time slot in subsequent rounds.

## Finding Description

The vulnerability consists of three compounding failures in the mining order assignment and validation system:

**Stage 1: Stale State During Conflict Detection**

When miners produce blocks, `GetConsensusExtraData` calls `ApplyNormalConsensusData` on an in-memory copy of the current round to calculate `FinalOrderOfNextRound` values. [1](#0-0) 

This view-like operation reads state at time T1, performs conflict resolution on the copy, but doesn't immediately update persistent state. The conflict detection checks which miners already have the calculated order: [2](#0-1) 

If Miner A and Miner B's signatures both modulo to the same order (calculated deterministically as `GetAbsModulus(signature.ToInt64(), minersCount) + 1`), and both call `GetConsensusExtraData` before either's transaction is executed, both see an empty conflicts list in their respective in-memory copies. [3](#0-2) 

**Stage 2: Defective Conflict Resolution Logic**

The conflict resolution loop attempts to reassign conflicted miners to available slots: [4](#0-3) 

However, when all mining slots (1 to minersCount) are occupied, the availability check `RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder)` never succeeds. The loop completes without reassigning the conflicted miner, who retains their original order. Then the current miner is also assigned to that same order: [5](#0-4) 

**Stage 3: State Update with Race Condition**

During transaction execution, `ProcessUpdateValue` applies the pre-calculated values to persistent state: [6](#0-5) 

The `TuneOrderInformation` from the view call is also applied: [7](#0-6) 

Because the conflict resolution happened on stale state, both miners' transactions successfully commit duplicate orders.

**Stage 4: Insufficient Validation**

The `NextRoundMiningOrderValidationProvider` is designed to detect invalid order assignments during NextRound behavior: [8](#0-7) 

However, its validation logic is buggy. It uses `.Distinct()` on `MinerInRound` objects: [9](#0-8) 

Since `MinerInRound` is a protobuf-generated class without custom equality implementation, `.Distinct()` uses reference equality, not value equality on `FinalOrderOfNextRound`. All dictionary values are distinct object references, so this check never detects duplicate order values.

**Stage 5: Consensus Disruption**

When the next round is generated, miners are ordered by their `FinalOrderOfNextRound`: [10](#0-9) 

Miners with duplicate `FinalOrderOfNextRound` values are both assigned the same `Order` in the next round and identical `ExpectedMiningTime` values. This creates a time slot collision where multiple miners attempt to produce blocks simultaneously.

## Impact Explanation

This vulnerability directly violates the fundamental consensus invariant that each miner must have a unique time slot within a round. The consequences are severe:

**Consensus Schedule Breakdown**: When multiple miners are assigned to the same time slot, the deterministic mining schedule breaks down. Both miners will attempt to produce blocks at the identical timestamp, creating ambiguity about which block is valid.

**Block Production Conflicts**: The protocol cannot deterministically choose between competing blocks from different miners at the same time slot. This may cause:
- Nodes to accept different blocks, leading to temporary chain forks
- Miners to wait for each other, causing block production delays
- Validation failures if strict time slot checks are enforced

**Network Disruption**: The consensus mechanism may stall as nodes fail to reach agreement on which block to accept. Transaction finality is delayed, and in severe cases, the network may require manual intervention to recover.

The affected parties include all network participants who experience consensus disruption, and the miners themselves who may lose block rewards due to invalid scheduling.

## Likelihood Explanation

**Natural Occurrence Without Malicious Intent**: This vulnerability triggers through natural hash collisions. With N miners, two miners' signatures have approximately 1/N probability of producing the same modulo value. For a network with 17 miners (typical AEDPoS configuration), this represents a ~5.9% collision probability per miner pair.

**TOCTOU Race Window**: The race condition occurs when:
1. Miner A calls `GetConsensusExtraData` at time T1, reads state
2. Miner B calls `GetConsensusExtraData` at time T2 (before A's transaction commits), reads same state  
3. Both calculate the same `FinalOrderOfNextRound` seeing no conflicts
4. Both transactions execute successfully, writing duplicate values

This window exists during normal block production throughout each round as miners produce their UpdateValue blocks.

**Validation Bypass**: The buggy validation using reference equality means duplicate assignments go undetected until the next round transition, when time slot collisions manifest. By then, the invalid state is already committed.

**Exploitation Complexity**: LOW - Requires no special privileges or malicious behavior. Natural hash collisions during concurrent block production will trigger this regularly in active networks.

**Probability Assessment**: In a network with frequent block production (4-second intervals) and multiple miners, hash collisions are inevitable. Combined with the TOCTOU window and ineffective validation, duplicate assignments will occur with medium to high frequency during normal operation.

## Recommendation

Implement three layers of defense:

**Fix 1: Validate Distinct Order Values**
```csharp
// In NextRoundMiningOrderValidationProvider.cs
var minersWithOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0).ToList();
var distinctOrderCount = minersWithOrders
    .Select(m => m.FinalOrderOfNextRound).Distinct().Count();
if (distinctOrderCount != minersWithOrders.Count)
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}
```

**Fix 2: Add State-Level Duplicate Check**
```csharp
// In ProcessUpdateValue, after line 247
var duplicateOrder = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.Pubkey != _processingBlockMinerPubkey && 
                m.FinalOrderOfNextRound == updateValueInput.SupposedOrderOfNextRound)
    .Any();
Assert(!duplicateOrder, "Duplicate FinalOrderOfNextRound detected during state update.");
```

**Fix 3: Improve Conflict Resolution**
```csharp
// In ApplyNormalConsensusData, ensure conflicted miners are always reassigned
// by excluding the conflicted miner from availability checks:
foreach (var orderConflictedMiner in conflicts)
{
    for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
    {
        var maybeNewOrder = i > minersCount ? i % minersCount : i;
        if (RealTimeMinersInformation.Values
            .Where(m => m.Pubkey != orderConflictedMiner.Pubkey)
            .All(m => m.FinalOrderOfNextRound != maybeNewOrder))
        {
            RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
            break;
        }
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task TOCTOU_DuplicateMiningOrder_CausesConsensusDisruption()
{
    // Setup: Create a round with miners whose signatures will collide
    var round = new Round { RoundNumber = 1, RealTimeMinersInformation = {} };
    var minerCount = 5;
    
    // Add miners to round
    for (int i = 1; i <= minerCount; i++)
    {
        var pubkey = $"miner{i}";
        round.RealTimeMinersInformation[pubkey] = new MinerInRound 
        { 
            Pubkey = pubkey, 
            Order = i 
        };
    }
    
    // Simulate hash collision: two miners with signatures that modulo to same value
    var collisionOrder = 3;
    var minerA = "minerA";
    var minerB = "minerB";
    
    // MinerA signature mods to order 3
    var signatureA = Hash.FromRawBytes(BitConverter.GetBytes((long)(collisionOrder - 1 + minerCount * 5)));
    // MinerB signature also mods to order 3
    var signatureB = Hash.FromRawBytes(BitConverter.GetBytes((long)(collisionOrder - 1 + minerCount * 7)));
    
    round.RealTimeMinersInformation[minerA] = new MinerInRound { Pubkey = minerA };
    round.RealTimeMinersInformation[minerB] = new MinerInRound { Pubkey = minerB };
    
    // Simulate TOCTOU: Both miners read same state and apply consensus data
    var roundCopyA = round.Clone();
    var roundCopyB = round.Clone();
    
    roundCopyA.ApplyNormalConsensusData(minerA, Hash.Empty, Hash.Empty, signatureA);
    roundCopyB.ApplyNormalConsensusData(minerB, Hash.Empty, Hash.Empty, signatureB);
    
    // Both should have order 3
    Assert.Equal(collisionOrder, roundCopyA.RealTimeMinersInformation[minerA].FinalOrderOfNextRound);
    Assert.Equal(collisionOrder, roundCopyB.RealTimeMinersInformation[minerB].FinalOrderOfNextRound);
    
    // Simulate state updates (both transactions succeed)
    round.RealTimeMinersInformation[minerA].FinalOrderOfNextRound = 
        roundCopyA.RealTimeMinersInformation[minerA].FinalOrderOfNextRound;
    round.RealTimeMinersInformation[minerB].FinalOrderOfNextRound = 
        roundCopyB.RealTimeMinersInformation[minerB].FinalOrderOfNextRound;
    
    // Verify: Buggy validation passes (uses reference equality)
    var validation = new NextRoundMiningOrderValidationProvider();
    var result = validation.ValidateHeaderInformation(new ConsensusValidationContext 
    { 
        ProvidedRound = round 
    });
    // This should fail but passes due to bug
    Assert.True(result.Success); // BUG: Validation doesn't catch duplicates
    
    // Generate next round - this will assign both miners to same time slot
    round.GenerateNextRoundInformation(TimestampHelper.GetUtcNow(), 
        TimestampHelper.GetUtcNow(), out var nextRound);
    
    var minerAInNext = nextRound.RealTimeMinersInformation[minerA];
    var minerBInNext = nextRound.RealTimeMinersInformation[minerB];
    
    // VULNERABILITY: Both miners have same Order and ExpectedMiningTime
    Assert.Equal(minerAInNext.Order, minerBInNext.Order);
    Assert.Equal(minerAInNext.ExpectedMiningTime, minerBInNext.ExpectedMiningTime);
    
    // This violates consensus integrity - two miners assigned to same time slot
}
```

## Notes

This vulnerability affects the core consensus scheduling mechanism and can occur naturally without malicious actors. The combination of race conditions, buggy conflict resolution, and ineffective validation creates multiple failure points. The issue is particularly concerning because it bypasses the intended safety mechanisms and remains undetected until consensus disruption occurs. Priority remediation is recommended given the critical nature of consensus integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L85-86)
```csharp
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```
