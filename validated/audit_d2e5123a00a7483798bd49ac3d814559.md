# Audit Report

## Title
Malicious Block Producer Can Skip Term Changes by Using NextRound Instead of NextTerm Behavior

## Summary
The AEDPoS consensus validation logic fails to enforce mandatory term transitions on-chain. A malicious block producer can bypass term changes by submitting `NextRound` behavior when `NextTerm` is required, skipping critical operations including miner list updates, treasury releases, and election snapshots.

## Finding Description

The vulnerability exists because term change requirements are determined off-chain but not validated on-chain.

**Root Cause:** The `ValidationForNextRound` method only validates structural constraints (round number increment and null InValues) without verifying whether a term change should have occurred. [1](#0-0) 

The validation explicitly checks only two aspects as documented in the code comments: round number and null InValues. The term number is completely unchecked for `NextRound` behavior.

**Behavior Determination:** The system determines whether to use `NextRound` or `NextTerm` via the `NeedToChangeTerm` method, which checks if 2/3+ miners have timestamps indicating the term period elapsed. [2](#0-1) 

However, this logic only executes in the off-chain `MainChainConsensusBehaviourProvider` to suggest the appropriate behavior. [3](#0-2) 

**Attack Execution:** A malicious miner modifies their node software to always return `NextRound` behavior. The on-chain contract receives this as `NextRoundInput` with the same term number and validates it successfully because `ValidationForNextRound` doesn't check term requirements. The validation providers registered for `NextRound` behavior do not include any term-related validation. [4](#0-3) 

**Impact Difference:** When `ProcessNextRound` executes, it only updates the round number and detects evil miners. [5](#0-4) 

In contrast, `ProcessNextTerm` performs critical term transition operations that get skipped: updates term number, updates miner list from election contract, releases treasury funds for the period, takes election snapshot, and updates miner information. [6](#0-5) 

## Impact Explanation

**High Severity** due to multiple critical protocol failures:

1. **Consensus Integrity Violation**: Term transitions are fundamental to the AEDPoS protocol. Skipping them breaks the consensus state machine, causing persistent term/round desynchronization.

2. **Economic Disruption**: Treasury releases are period-based and occur during term changes. Skipping the `Release.Send` call prevents scheduled token distributions to profit schemes, freezing the economic distribution model for that period.

3. **Governance Failure**: The miner list doesn't update from election results (lines 188-190 skipped), preventing validator rotation. This fundamentally breaks the democratic governance model where token holders vote for block producers.

4. **Election State Corruption**: Election snapshots track voting weights and blocks mined per term (lines 213-218 skipped). Without these snapshots, historical voting records become corrupted and reward calculations break.

5. **Reward Misallocation**: Mining rewards that should be donated to treasury during term changes don't get processed, affecting the entire reward distribution mechanism downstream.

## Likelihood Explanation

**Medium-High Likelihood** with low attack barriers:

**Attacker Requirements**: Only requires being an active block producer, achievable through the normal election process without special privileges.

**Attack Complexity**: Very low. The attacker modifies their node's behavior provider to always return `NextRound` behavior. No cryptographic attacks, complex state manipulation, or privilege escalation required.

**Detection Gap**: No on-chain detection mechanism exists. The validation logic accepts `NextRound` as valid even when `NextTerm` is required, so other honest nodes will accept and propagate these blocks as legitimate.

**Opportunity Window**: The attacker must be producing the block that terminates a round when a term change is needed. Given rotating schedules, any malicious miner will periodically have this opportunity.

**Confirmation**: The `NeedToChangeTerm` method appears only in off-chain code (behavior provider) and the `Round` type definition - never in contract validation logic, confirming no on-chain enforcement exists.

## Recommendation

Add on-chain validation to enforce term change requirements. Modify `ValidationForNextRound` to check whether a term change should occur based on the current state:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Check if term change is required
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    var periodSeconds = State.PeriodSeconds.Value;
    var currentTermNumber = validationContext.CurrentTermNumber;
    
    if (validationContext.BaseRound.NeedToChangeTerm(
        blockchainStartTimestamp, currentTermNumber, periodSeconds))
    {
        return new ValidationResult { 
            Message = "Term change is required but NextRound behavior provided instead of NextTerm." 
        };
    }
    
    // Verify term number hasn't changed for NextRound
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Term number must not change for NextRound behavior." };
    
    return new ValidationResult { Success = true };
}
```

This ensures that when `NeedToChangeTerm` returns true, only `NextTerm` behavior is accepted, enforcing term transitions at the protocol level.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanSkipTermChange_ByUsingNextRound()
{
    // Setup: Create initial miners and advance to point where term change is needed
    await InitialAElfConsensusContract();
    var miners = await GetCurrentMiners();
    
    // Advance time to exceed term period (7 days)
    await AdvanceTimeByDays(8);
    
    // Ensure 2/3+ miners have mined with timestamps indicating term elapsed
    await ProduceBlocksUntilTermChangeRequired(miners);
    
    var currentRound = await GetCurrentRound();
    var currentTerm = await GetCurrentTermNumber();
    
    // Verify NeedToChangeTerm returns true (off-chain check)
    Assert.True(currentRound.NeedToChangeTerm(
        await GetBlockchainStartTimestamp(),
        currentTerm,
        await GetPeriodSeconds()));
    
    // ATTACK: Malicious miner submits NextRound instead of NextTerm
    var maliciousMiner = miners[0];
    var nextRoundInput = new NextRoundInput {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentTerm, // Keep same term!
        // ... other fields
    };
    
    // Submit NextRound transaction (should fail but doesn't)
    var result = await ExecuteConsensusTransaction(maliciousMiner, "NextRound", nextRoundInput);
    
    // VULNERABILITY: Transaction succeeds when it should have failed
    Assert.True(result.Status == TransactionResultStatus.Mined);
    
    // Verify term didn't change (should have changed to currentTerm + 1)
    var newTerm = await GetCurrentTermNumber();
    Assert.Equal(currentTerm, newTerm); // Term incorrectly stayed the same
    
    // Verify critical operations were skipped
    var treasuryReleaseEvents = result.Logs.Where(l => l.Name == "Released").ToList();
    Assert.Empty(treasuryReleaseEvents); // Treasury release skipped
    
    var snapshotEvents = result.Logs.Where(l => l.Name == "SnapshotTaken").ToList();
    Assert.Empty(snapshotEvents); // Election snapshot skipped
    
    // Miner list wasn't updated from election results
    var newMiners = await GetCurrentMiners();
    Assert.Equal(miners, newMiners); // Same miners, no rotation occurred
}
```

## Notes

This vulnerability represents a fundamental gap between off-chain behavior determination and on-chain validation enforcement. The protocol assumes miners will follow the suggested behavior from `NeedToChangeTerm`, but this assumption is not enforced by smart contract logic. The impact compounds over time as term changes continue to be skipped, progressively breaking governance rotation, economic distributions, and election tracking. The attack is particularly concerning because it generates valid blocks that honest nodes accept, making it difficult to detect without external monitoring of term transition timing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
