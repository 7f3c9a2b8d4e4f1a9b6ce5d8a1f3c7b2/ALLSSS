# Audit Report

## Title
Duplicate Mining Order Validation Bypass Allows Consensus Schedule Corruption

## Summary
The `NextRoundMiningOrderValidationProvider` incorrectly validates mining order uniqueness by applying `.Distinct()` to `MinerInRound` objects rather than their `FinalOrderOfNextRound` integer values. This allows any consensus miner to inject next-round data where multiple miners share identical mining orders, violating the fundamental "unique order per miner" consensus invariant and corrupting critical mining schedule logic.

## Finding Description

The validation provider performs a flawed uniqueness check that operates on entire `MinerInRound` objects instead of their `FinalOrderOfNextRound` values. [1](#0-0) 

Since `MinerInRound` is a protobuf-generated class [2](#0-1) , its auto-generated `Equals` method compares ALL fields (pubkey, order, timestamps, signatures, etc.). Two miners with different pubkeys but identical `FinalOrderOfNextRound` values are treated as distinct objects, allowing duplicate order values to pass validation.

**Execution Path:**

1. Any consensus miner calls the public `NextRound` method [3](#0-2) 

2. The permission check only verifies the sender is in current or previous miner list [4](#0-3) 

3. For NextRound behavior, the validation pipeline includes the flawed `NextRoundMiningOrderValidationProvider` [5](#0-4) 

4. The malicious `NextRoundInput` with duplicate `FinalOrderOfNextRound` values passes validation because `.Distinct()` counts distinct objects, not distinct order values

5. Invalid round data is stored directly as authoritative consensus state [6](#0-5)  via the `ProcessNextRound` call [7](#0-6) 

**Attack Vector:**

A malicious miner crafts a `NextRoundInput` where multiple entries in `RealTimeMinersInformation` have identical `FinalOrderOfNextRound` values (e.g., Miner A and Miner B both have `FinalOrderOfNextRound = 1`). The validation passes because it counts 2 distinct `MinerInRound` objects despite them having duplicate order values.

## Impact Explanation

**Critical Consensus Functions Break:**

1. **BreakContinuousMining Logic Failure:** The anti-continuous-mining logic uses `.First(i => i.Order == 1)` and `.First(i => i.Order == 2)` to locate specific miners for swapping. [8](#0-7)  With duplicate orders, these calls return arbitrary miners from those sharing the order, causing incorrect swaps and allowing continuous mining that should be prevented.

2. **Extra Block Producer Selection Corruption:** The critical extra block producer role is selected using `.FirstOrDefault(m => m.Order == extraBlockProducerOrder)`. [9](#0-8)  Duplicate orders cause selection of the wrong miner for this consensus-critical role.

3. **Mining Interval Calculation Corruption:** The mining interval calculation filters for miners with `Order == 1 || Order == 2` and computes time differences. [10](#0-9)  If multiple miners have Order=1, the resulting list may contain two Order=1 miners instead of one Order=1 and one Order=2, producing incorrect intervals (potentially 0ms).

4. **Order Assignment Gap Creation:** The next-round generation logic determines available orders by excluding occupied ones. [11](#0-10)  If `occupiedOrders` contains `[1, 1, 3, 4]`, then `ableOrders` becomes `[2, 5, 6, ...]`, creating gaps in the mining sequence.

**Severity Assessment:**
- **Critical Consensus Invariant Violation:** Breaks the fundamental "unique mining order per miner" guarantee
- **Network-Wide Impact:** All nodes experience consensus disruption from the corrupted schedule
- **Liveness Risk:** Unpredictable mining behavior can degrade or halt chain progress
- **Persistent Invalid State:** Corruption remains until consensus anomalies become apparent

## Likelihood Explanation

**Attacker Profile:** Any active consensus miner can execute this attack with their normal operational privileges.

**Attack Complexity:** Low - The attacker simply crafts a `NextRoundInput` message with duplicate `FinalOrderOfNextRound` values while maintaining correct counts and valid structure to pass other validation checks.

**Execution Feasibility:**
- **Permission:** Any miner in current/previous round (normal operational requirement)
- **Cost:** Standard NextRound transaction gas
- **Repeatability:** Can be executed in any round when the malicious miner produces the round-terminating block
- **Detection:** No immediate detection mechanism exists in the validation logic

**Economic Rationality:** A malicious miner gains strategic advantages by disrupting competitor schedules, creating beneficial time slot conflicts, or forcing consensus anomalies.

**Probability:** High - Simple exploit, accessible to all miners, low technical barrier.

## Recommendation

Fix the validation logic to check uniqueness of the `FinalOrderOfNextRound` **values** rather than the `MinerInRound` **objects**:

```csharp
// In NextRoundMiningOrderValidationProvider.cs
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Project to order values
    .Distinct()
    .Count();
```

This ensures the validation checks for duplicate order integers, not duplicate miner objects.

## Proof of Concept

```csharp
// Test demonstrating the validation bypass
[Fact]
public void DuplicateOrderValidationBypass_Test()
{
    // Setup: Create a round with 5 miners where two miners have the same FinalOrderOfNextRound
    var nextRoundInput = new NextRoundInput
    {
        RoundNumber = 2,
        TermNumber = 1,
        RealTimeMinersInformation =
        {
            // Miner A and Miner B both have FinalOrderOfNextRound = 1 (DUPLICATE)
            ["MinerA"] = new MinerInRound 
            { 
                Pubkey = "MinerA", 
                Order = 1, 
                FinalOrderOfNextRound = 1,
                OutValue = Hash.FromString("valueA")  // Has produced block
            },
            ["MinerB"] = new MinerInRound 
            { 
                Pubkey = "MinerB", 
                Order = 2, 
                FinalOrderOfNextRound = 1,  // DUPLICATE ORDER
                OutValue = Hash.FromString("valueB")  // Has produced block
            },
            ["MinerC"] = new MinerInRound 
            { 
                Pubkey = "MinerC", 
                Order = 3, 
                FinalOrderOfNextRound = 3,
                OutValue = Hash.FromString("valueC")
            }
        }
    };
    
    // The validation provider incorrectly passes this input
    var provider = new NextRoundMiningOrderValidationProvider();
    var context = new ConsensusValidationContext
    {
        ProvidedRound = nextRoundInput.ToRound()
    };
    
    var result = provider.ValidateHeaderInformation(context);
    
    // BUG: Validation passes despite duplicate FinalOrderOfNextRound values
    Assert.True(result.Success);  // This should FAIL but PASSES due to the bug
    
    // Demonstration: distinctCount = 3 (3 distinct MinerInRound objects)
    // even though there are only 2 distinct FinalOrderOfNextRound values (1, 3)
    // and 3 miners who produced blocks (OutValue != null)
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-56)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```
