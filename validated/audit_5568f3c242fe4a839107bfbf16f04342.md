# Audit Report

## Title
Side Chain Disposal with Outstanding Debt Allows Indexing Fee Theft

## Summary
The `DisposeSideChain` function permits disposal of side chains in `IndexingFeeDebt` status without settling outstanding debts recorded in `ArrearsInfo`. When a chain with accumulated indexing fee debts is disposed, the `UnlockTokenAndResource` helper returns only the remaining balance to the chain proposer, causing indexers who performed legitimate work to permanently lose their rightful fees.

## Finding Description

The vulnerability exists in the disposal flow for side chains with outstanding indexing fee debts:

**Insufficient Status Validation:**
The `DisposeSideChain` function only checks that the chain status is not `Terminated`, explicitly allowing disposal of chains in `IndexingFeeDebt` status. [1](#0-0) 

**Debt Tracking Mechanism:**
When side chains exhaust their indexing fee balance during the `IndexSideChainBlockData` operation, the system transitions them to `IndexingFeeDebt` status and records unpaid amounts in the `ArrearsInfo` mapping. [2](#0-1) 

**Missing Debt Settlement:**
The `UnlockTokenAndResource` helper only returns the remaining deposit balance to the chain proposer without checking or settling debts recorded in `ArrearsInfo`. [3](#0-2) 

**Correct Debt Settlement Pattern:**
The `Recharge` function demonstrates the proper approach - when handling chains in `IndexingFeeDebt` status, it iterates through `ArrearsInfo` entries, transfers owed amounts to each creditor, and only then clears the debt records. [4](#0-3) 

**Status Definitions:**
The `SideChainStatus` enum defines `INDEXING_FEE_DEBT = 2` as a valid intermediate state between `ACTIVE` and `TERMINATED`. [5](#0-4) 

**Debt Storage:**
The `ArrearsInfo` field stores indexing fee debt as a map of creditor addresses to amounts. [6](#0-5) 

## Impact Explanation

**Direct Financial Loss:**
- Indexers (miners who proposed side chain block data) permanently lose unpaid indexing fees recorded in `ArrearsInfo`
- Each indexing operation performed after balance depletion creates unpaid debt that becomes unrecoverable post-disposal
- The remaining deposit balance is incorrectly returned to the chain proposer instead of first settling creditor claims

**Economic Model Breakdown:**
- Violates the fundamental protocol guarantee that indexers receive compensation for cross-chain block indexing work
- Creates perverse incentives where chain proposers can deliberately underfund chains and dispose them to avoid accumulated debts
- Undermines trust in the cross-chain indexing payment system

**Protocol Integrity:**
- The `ArrearsInfo` debt tracking mechanism becomes meaningless if debts can be written off through disposal
- Contradicts the explicit debt settlement logic implemented in the `Recharge` function
- Loss amount equals the sum of all values in `ArrearsInfo` at disposal time

## Likelihood Explanation

**Natural Occurrence:**
This vulnerability triggers in common operational scenarios without requiring malicious intent:
1. A side chain is created with limited initial funding
2. The chain operates normally until the indexing fee balance depletes
3. Additional indexing operations occur, creating debt entries in `ArrearsInfo`
4. Governance legitimately decides to dispose the chain rather than recharge it

**Reachable Execution Path:**
- `DisposeSideChain` is callable through the side chain lifetime controller (typically Parliament governance) [7](#0-6) 
- No special privileges beyond standard governance participation are required
- The existing test suite demonstrates chains entering `IndexingFeeDebt` status through normal indexing operations [8](#0-7) 

**Economic Feasibility:**
- Cost to create a side chain is minimal (just the initial locked amount)
- Standard Parliament governance proposal fees apply
- Net benefit to malicious proposer: avoid paying accumulated indexing fees exceeding initial deposit plus governance costs

**High Probability:**
The vulnerability is triggered whenever governance disposes an underfunded side chain - a legitimate operational decision that has unintended consequences of automatic debt forgiveness.

## Recommendation

Add debt settlement logic to `DisposeSideChain` before unlocking tokens. The function should check for outstanding debts in `ArrearsInfo` and either:

1. **Option A (Strict):** Prevent disposal of chains with outstanding debts:
```csharp
Assert(info.ArrearsInfo.Count == 0, "Cannot dispose chain with outstanding debts. Recharge first.");
```

2. **Option B (Settle debts):** Settle all outstanding debts before unlocking remaining balance:
```csharp
// Before calling UnlockTokenAndResource
if (info.SideChainStatus == SideChainStatus.IndexingFeeDebt)
{
    foreach (var arrears in info.ArrearsInfo)
    {
        TransferDepositToken(new TransferInput
        {
            To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = arrears.Value,
            Memo = "Settling arrears during disposal."
        }, chainId);
    }
    info.ArrearsInfo.Clear();
}
```

Option B is preferred as it ensures indexers are always compensated for their work, even when chains are disposed.

## Proof of Concept

```csharp
[Fact]
public async Task DisposeSideChain_WithOutstandingDebt_StealsFees()
{
    // Setup: Create side chain with limited funding
    var parentChainId = 123;
    long lockedToken = 2; // Only enough for 2 blocks
    long indexingPrice = 1;
    long parentChainHeightOfCreation = 10;
    
    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, parentChainId, lockedToken, indexingPrice);
    
    // Index 3 blocks - will create debt for 1 block
    var crossChainBlockData = new CrossChainBlockData
    {
        SideChainBlockDataList = {
            CreateSideChainBlockData(HashHelper.ComputeFrom("hash1"), 1, sideChainId, HashHelper.ComputeFrom("root")),
            CreateSideChainBlockData(HashHelper.ComputeFrom("hash2"), 2, sideChainId, HashHelper.ComputeFrom("root")),
            CreateSideChainBlockData(HashHelper.ComputeFrom("hash3"), 3, sideChainId, HashHelper.ComputeFrom("root"))
        }
    };
    
    await DoIndexAsync(crossChainBlockData, new[] { sideChainId });
    
    // Verify chain is in debt
    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(
        new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(1); // 1 token owed to indexer
    
    // Get indexer balance before disposal
    var indexerBalanceBefore = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = DefaultSender, Symbol = "ELF" });
    
    // Dispose the chain (vulnerability execution)
    var disposalProposalId = await DisposeSideChainProposalAsync(new Int32Value { Value = sideChainId });
    await ApproveWithMinersAsync(disposalProposalId);
    await ReleaseProposalAsync(disposalProposalId);
    
    // Verify chain is terminated
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.Terminated);
    
    // Indexer balance should NOT have increased (debt not settled)
    var indexerBalanceAfter = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = DefaultSender, Symbol = "ELF" });
    indexerBalanceAfter.Balance.ShouldBe(indexerBalanceBefore.Balance); // VULNERABILITY: No payment received
    
    // Debt is permanently lost - chain is terminated so Recharge won't work
    var rechargeAttempt = await CrossChainContractStub.Recharge.SendWithExceptionAsync(
        new RechargeInput { ChainId = sideChainId, Amount = 10 });
    rechargeAttempt.TransactionResult.Error.ShouldContain("Side chain not found or incorrect side chain status");
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L191-214)
```csharp
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L224-224)
```csharp
        AssertSideChainLifetimeControllerAuthority(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L229-229)
```csharp
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L73-86)
```csharp
    private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
    {
        // unlock token
        var chainId = sideChainInfo.SideChainId;
        var balance = GetSideChainIndexingFeeDeposit(chainId);
        if (balance <= 0)
            return;
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = balance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L846-876)
```csharp
                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }
```

**File:** protobuf/cross_chain_contract.proto (L196-196)
```text
    INDEXING_FEE_DEBT = 2;
```

**File:** protobuf/cross_chain_contract.proto (L216-217)
```text
    // creditor and amounts for the chain indexing fee debt 
    map<string, int64> arrears_info = 8;
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs (L1195-1200)
```csharp
            var chainStatus = await CrossChainContractStub.GetChainStatus.CallAsync(new Int32Value
            {
                Value = sideChainId
            });
            chainStatus.Status.ShouldBe(SideChainStatus.IndexingFeeDebt);
        }
```
