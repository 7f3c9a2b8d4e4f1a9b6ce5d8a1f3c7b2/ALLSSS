# Audit Report

## Title
Vote Count Inconsistency Allows Governance Manipulation Through Member Removal

## Summary
The Association contract contains a critical vote counting inconsistency where votes from removed members still count toward the quorum threshold but are excluded from approval/rejection/abstention checks, allowing organizations to manipulate proposal outcomes by removing dissenting voters after they vote.

## Finding Description

The vulnerability exists in the vote threshold evaluation logic that applies inconsistent filtering rules when checking different thresholds.

**The Inconsistency:**

When evaluating whether a proposal can be released, the `CheckEnoughVoteAndApprovals()` function filters approval counts to only include current organization members [1](#0-0) , but the quorum check counts all votes regardless of current membership status [2](#0-1) .

Similarly, `IsProposalRejected()` only counts rejections from current members [3](#0-2) , and `IsProposalAbstained()` only counts abstentions from current members [4](#0-3) .

**Attack Mechanism:**

When members vote, their addresses are permanently added to the proposal's vote lists [5](#0-4) [6](#0-5) [7](#0-6) .

If members are subsequently removed via `RemoveMember()` [8](#0-7) , their votes remain in the proposal's lists, but they are no longer in the organization member list used for threshold filtering.

The `AssertProposalNotYetVotedBySender()` protection only prevents duplicate voting during the voting phase [9](#0-8) , and cannot prevent the counting inconsistency that occurs when members are removed after casting their votes.

**Concrete Attack Scenario:**
- Organization with 10 members: MinimalVoteThreshold=6, MinimalApprovalThreshold=4, MaximalRejectionThreshold=3
- Proposal A receives 4 approvals and 4 rejections (8 total votes)
- Current evaluation: Proposal would be REJECTED (4 rejections > 3 MaximalRejectionThreshold)
- Organization creates and passes Proposal B to remove the 4 rejecting members
- When Proposal A is released, `IsReleaseThresholdReached()` [10](#0-9)  evaluates:
  - `approvedMemberCount = 4` (current members only) ≥ 4 ✓
  - `rejectionMemberCount = 0` (removed members filtered out) ≤ 3 ✓
  - `totalVotes = 8` (all votes including removed members) ≥ 6 ✓
- Proposal A now PASSES despite having had equal support and opposition

## Impact Explanation

**HIGH SEVERITY** - This breaks the fundamental governance invariant that vote outcomes should be immutable once cast and reflect member preferences at voting time.

Organizations can retroactively nullify dissenting votes by strategically removing those members from the organization. This completely undermines governance integrity and democratic decision-making within Association contracts. Any organization with sufficient control to pass member removal proposals can manipulate pending proposals by eliminating opposition, effectively censoring dissenting votes.

All Association contract users are affected. While this does not result in direct fund loss, it represents a severe governance manipulation vulnerability that can be used to force through any proposal by removing opposition, including proposals that could have downstream effects on funds, configurations, or system parameters.

## Likelihood Explanation

**HIGH LIKELIHOOD** - Multiple factors make this vulnerability highly exploitable:

**Attack Complexity: LOW** - Requires only standard contract operations: creating a member removal proposal, getting it approved through normal voting, releasing it, then releasing the target proposal.

**Preconditions: REALISTIC** - Organizations legitimately remove members for various reasons (inactivity, policy violations, restructuring), creating natural opportunities to exploit pending proposals even without explicitly malicious intent.

**Attacker Capabilities: STANDARD** - Any organization that can pass a member removal proposal (by controlling enough votes) can execute this attack. No special privileges or compromised keys required.

**Detection: DIFFICULT** - The manipulation appears as normal member management operations with no on-chain mechanism to distinguish legitimate member removal from vote manipulation.

**Economic Cost: MINIMAL** - Only requires gas fees for member removal and release transactions.

## Recommendation

Apply consistent filtering logic across all threshold checks. The quorum check should either:

1. **Filter to current members** (recommended): Count only votes from current members for the quorum threshold, matching the approval/rejection/abstention logic.

2. **Remove all filtering**: Count all votes including removed members for all thresholds (less recommended as it allows removed members to affect outcomes).

**Recommended fix** for `CheckEnoughVoteAndApprovals()`:
```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter quorum check to only count current members
    var currentMemberVotes = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        currentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteManipulation_ThroughMemberRemoval_Test()
{
    // Setup: Create organization with 10 members
    // MinimalVoteThreshold=6, MinimalApprovalThreshold=4, MaximalRejectionThreshold=3
    var members = GenerateTenMemberAddresses();
    var organization = await CreateOrganizationWithThresholds(members, 6, 4, 3);
    
    // Create Proposal A
    var proposalId = await CreateProposal(organization);
    
    // 4 members approve
    for (int i = 0; i < 4; i++)
        await ApproveAsAddress(proposalId, members[i]);
    
    // 4 members reject
    for (int i = 4; i < 8; i++)
        await RejectAsAddress(proposalId, members[i]);
    
    // Verify proposal is currently rejected (4 rejections > 3 threshold)
    var canReleaseBefore = await CanReleaseProposal(proposalId);
    Assert.False(canReleaseBefore); // Should be rejected
    
    // Create and pass proposal to remove the 4 rejecting members
    for (int i = 4; i < 8; i++)
        await RemoveMemberThroughProposal(organization, members[i]);
    
    // Now check if Proposal A can be released
    var canReleaseAfter = await CanReleaseProposal(proposalId);
    Assert.True(canReleaseAfter); // VULNERABILITY: Now passes!
    
    // Proposal can now be released despite having equal votes when cast
    await Release(proposalId);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L132-138)
```csharp
    private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
    {
        var isAlreadyVoted = proposal.Approvals.Contains(sender) || proposal.Rejections.Contains(sender) ||
                             proposal.Abstentions.Contains(sender);

        Assert(!isAlreadyVoted, "Sender already voted.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L150-150)
```csharp
        proposal.Rejections.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L170-170)
```csharp
        proposal.Abstentions.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
