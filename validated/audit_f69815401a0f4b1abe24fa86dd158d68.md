# Audit Report

## Title
Incomplete Evil Miner Replacement Due to Incorrect Initial Miner Count Calculation

## Summary
The `GetMinerReplacementInformation()` function in the Election Contract calculates the number of initial miners to select (`takeAmount`) before applying filters for banned and current miners. This causes a count mismatch where fewer alternative candidates are returned than evil miners detected. The Consensus Contract's replacement loop only processes alternatives that exist, leaving unprocessed evil miners active in consensus rounds, directly violating the security invariant that all banned miners must be replaced.

## Finding Description

The vulnerability exists in two interconnected components:

**Root Cause in Election Contract:**

The `GetMinerReplacementInformation()` method calculates `takeAmount` as the minimum of the deficit and the total count of initial miners. [1](#0-0) 

This calculation happens BEFORE the filtering operations that remove:
1. Banned miners (checked against `BannedPubkeyMap`)
2. Miners already in the current miner list

The LINQ `.Take(takeAmount)` operation returns only the available items after filtering. If the filtered collection has fewer items than `takeAmount`, the actual count of `alternativeCandidates` will be less than `evilMinersPubKeys.Count`.

**Consequence in Consensus Contract:**

The consensus contract consumes this data and iterates only `AlternativeCandidatePubkeys.Count` times, accessing both lists by the same index. [2](#0-1) 

Evil miners are only removed from `currentRound.RealTimeMinersInformation` inside this loop. When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, the remaining evil miners at higher indices in the `EvilMinerPubkeys` list are never processed and remain in the consensus round.

**How Evil Miners Are Detected:**

Miners become "evil" when they miss too many time slots (â‰¥4320, representing 3 days). [3](#0-2) 

The consensus contract detects them and marks them by calling `UpdateCandidateInformation` with `IsEvilNode = true`. [4](#0-3) 

**Banning Mechanism:**

When a miner is marked as evil, the Election Contract sets `BannedPubkeyMap[pubkey] = true`, removes them from the candidate list, and fires an `EvilMinerDetected` event. [5](#0-4) 

The banned status is stored persistently. [6](#0-5) 

## Impact Explanation

This vulnerability has **HIGH** impact because it directly compromises consensus integrity:

1. **Banned Miners Continue Participating**: Evil miners that should be removed remain in `RealTimeMinersInformation` and continue producing blocks, earning rewards, and influencing consensus decisions.

2. **Security Invariant Violation**: The protocol's security model depends on immediate removal of compromised nodes. Miners are marked as evil for missing too many time slots (a critical security signal), yet the replacement mechanism fails to remove all of them.

3. **Cumulative Risk**: As the network operates over time, more miners get banned and the initial miner pool depletes. Each incomplete replacement leaves additional evil miners active, compounding the security degradation.

4. **Network-Wide Impact**: All network participants suffer from reduced consensus security. Honest miners lose expected block production opportunities to unreplaced evil miners, and token holders face increased risk from malicious consensus participants.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood because:

1. **No Attacker Required**: The vulnerability triggers automatically during normal protocol operation through the standard consensus round generation flow. [7](#0-6) 

2. **Realistic Trigger Conditions**: 
   - Multiple miners naturally get banned over time through the detection mechanism
   - Initial miners can themselves become banned or be replaced
   - The initial miner pool is fixed at genesis and depletes over the network's lifetime

3. **Concrete Scenario Example**:
   - Network has 21 active miners
   - 5 total initial miners configured at genesis
   - 3 current miners are detected as evil and banned
   - Of the 5 initial miners: 2 are already banned, 2 are in the current miner list
   - Only 1 initial miner is available for replacement
   - Election snapshot provides 1 alternative candidate
   - Result: Need 3 replacements, get only 2 (1 from snapshot + 1 from initial miners)
   - **1 evil miner remains active in consensus**

4. **Increasing Probability**: The likelihood increases over the network's lifetime as more miners are banned and the initial miner pool becomes exhausted. This is not a rare edge case but an inevitable outcome of normal network operation.

## Recommendation

Calculate `takeAmount` AFTER applying the filters to reflect the actual available count of unbanned, non-current initial miners:

```csharp
var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
if (diff > 0)
{
    var availableInitialMiners = State.InitialMiners.Value.Value
        .Select(k => k.ToHex())
        .Where(k => !State.BannedPubkeyMap[k])
        .Where(k => !input.CurrentMinerList.Contains(k))
        .ToList();
    
    var takeAmount = Math.Min(diff, availableInitialMiners.Count);
    alternativeCandidates.AddRange(availableInitialMiners.Take(takeAmount));
}
```

Additionally, add validation in the consensus contract to ensure all evil miners can be replaced:

```csharp
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count < 
    minerReplacementInformation.EvilMinerPubkeys.Count)
{
    Context.LogDebug(() => 
        $"Insufficient alternatives: need {minerReplacementInformation.EvilMinerPubkeys.Count}, " +
        $"got {minerReplacementInformation.AlternativeCandidatePubkeys.Count}");
    // Handle the shortfall - could revert, emit warning event, or use fallback logic
}
```

## Proof of Concept

This vulnerability can be demonstrated with the following test scenario:

```csharp
[Fact]
public async Task IncompleteEvilMinerReplacement_Test()
{
    // Setup: Initialize network with 5 initial miners
    // Ban 2 initial miners and add 2 to current miner list
    // Detect 3 evil miners in current round
    // Election snapshot provides only 1 alternative
    
    // Expected: All 3 evil miners should be replaced
    // Actual: Only 2 are replaced (1 from snapshot + 1 from initial miners)
    // Result: 1 evil miner remains in currentRound.RealTimeMinersInformation
    
    var minerReplacementInfo = await ElectionContractStub.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput 
        { 
            CurrentMinerList = { currentMinerPubkeys } 
        });
    
    // Verify the count mismatch
    Assert.Equal(3, minerReplacementInfo.EvilMinerPubkeys.Count);
    Assert.Equal(2, minerReplacementInfo.AlternativeCandidatePubkeys.Count); // Bug: should be 3
    
    // After round generation, verify 1 evil miner still in round
    var nextRound = await ConsensusContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var evilMinerStillPresent = nextRound.RealTimeMinersInformation
        .Keys
        .Any(k => minerReplacementInfo.EvilMinerPubkeys.Contains(k));
    
    Assert.True(evilMinerStillPresent); // Bug: evil miner not removed
}
```

The test demonstrates that when insufficient alternatives are available, the mismatch in list sizes causes incomplete evil miner replacement, violating the critical security invariant.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L382-392)
```csharp
        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L33-33)
```csharp
    public MappedState<string, bool> BannedPubkeyMap { get; set; }
```
