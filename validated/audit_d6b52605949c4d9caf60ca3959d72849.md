# Audit Report

## Title
Evil Miner Detection Bypass via Unvalidated MissedTimeSlots Manipulation in NextRound Transaction

## Summary
The AEDPoS consensus contract accepts user-provided `NextRoundInput` containing `MissedTimeSlots` values without validation, storing manipulated data directly to state. This allows malicious miners acting as extra block producers to reduce their missed time slot counter, bypassing the evil miner detection threshold and avoiding removal from the consensus.

## Finding Description

The vulnerability exists in the round transition flow where `ProcessNextRound()` stores user-provided round data before detecting evil miners.

**Root Cause:** [1](#0-0) 

The `ProcessNextRound()` function converts the user-provided `NextRoundInput` to a `Round` object at line 110, retrieves the current round from state at line 114, performs evil miner detection on the current round at line 140, then stores the next round (containing user-provided data) to state at line 156. The evil detection checks whether `MissedTimeSlots >= TolerableMissedTimeSlotsCount` (4320): [2](#0-1) [3](#0-2) 

**Why Validation Fails:**

The before-execution validation adds providers for NextRound behavior: [4](#0-3) 

However, `NextRoundMiningOrderValidationProvider` only validates `FinalOrderOfNextRound`: [5](#0-4) 

And `RoundTerminateValidationProvider` only validates round number and InValue fields: [6](#0-5) 

Neither validates `MissedTimeSlots` correctness.

The after-execution validation compares round hashes: [7](#0-6) 

However, since `ProcessNextRound` already stored the manipulated round to state at line 156, both the header round and state round contain the same manipulated data at validation time (line 87 retrieves the newly stored round), causing the hashes to match.

**Data Flow:**

The `NextRoundInput` includes full `RealTimeMinersInformation` containing all `MissedTimeSlots`: [8](#0-7) [9](#0-8) 

When generating next round information correctly (off-chain), `MissedTimeSlots` is incremented for miners who didn't mine: [10](#0-9) 

**Attack Sequence:**

1. Malicious miner with high `MissedTimeSlots` (e.g., 4300, approaching threshold of 4320) is selected as extra block producer
2. Miner calls `GenerateConsensusTransactions` off-chain to obtain correct `NextRoundInput`
3. Miner manually modifies `NextRoundInput.RealTimeMinersInformation[their_pubkey].MissedTimeSlots` to a lower value (e.g., 100)
4. Miner submits modified transaction
5. Transaction passes validation (no `MissedTimeSlots` validation)
6. `ProcessNextRound` executes, detecting evil miners in current round (old data), then storing manipulated next round
7. In subsequent round transition, evil detection checks the manipulated round, failing to detect the attacker

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks a critical consensus integrity invariant. The evil miner detection mechanism is designed to remove underperforming miners who miss their assigned time slots. The 3-day tolerance window (4320 time slots at 1 minute per slot) is completely bypassed.

**Concrete Impact:**
- Evil miners can avoid being flagged as evil nodes by resetting their `MissedTimeSlots` counter
- The Election Contract update is bypassed: [11](#0-10) [12](#0-11) 

- Malicious miners continue participating in consensus despite poor performance
- Network reliability degrades as unreliable miners remain active
- Honest miners bear increased burden when evil miners fail to produce blocks
- The consensus mechanism's self-healing property is undermined

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Prerequisites:**
- Must be a current miner in the consensus set
- Must accumulate high `MissedTimeSlots` (indicating poor performance)
- Must be selected as extra block producer to trigger NextRound behavior

The extra block producer selection is determined by signature-based randomness, not by `MissedTimeSlots` values. Over time, any miner will eventually be selected as extra block producer with sufficient probability.

**Attack Complexity: LOW**
- Attacker simply modifies a single field in transaction data before submission
- No complex timing requirements or race conditions
- No need to compromise other system components

**Detection Difficulty: HIGH**
- Manipulation occurs in transaction data without on-chain validation
- No audit trail to reveal discrepancy between expected and actual values
- Once stored to state, manipulated data becomes canonical truth

**Repeatability:**
- Attack can be executed each time attacker is selected as extra block producer
- No economic disincentive (only normal transaction fees)

## Recommendation

Add validation of `MissedTimeSlots` values in the `NextRoundInput` before storing to state. The validation should verify that `MissedTimeSlots` values match the expected increments based on the current round's miner participation.

**Suggested Fix:**

In `ProcessNextRound()`, add validation after line 114 to verify `MissedTimeSlots` correctness:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();

    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Validate MissedTimeSlots increments
    foreach (var minerInNextRound in nextRound.RealTimeMinersInformation)
    {
        if (currentRound.RealTimeMinersInformation.ContainsKey(minerInNextRound.Key))
        {
            var currentMiner = currentRound.RealTimeMinersInformation[minerInNextRound.Key];
            var nextMiner = minerInNextRound.Value;
            
            // If miner didn't mine in current round, MissedTimeSlots should increment by 1
            var expectedMissedSlots = currentMiner.OutValue == null 
                ? currentMiner.MissedTimeSlots.Add(1) 
                : currentMiner.MissedTimeSlots;
                
            Assert(nextMiner.MissedTimeSlots == expectedMissedSlots, 
                $"Invalid MissedTimeSlots for {minerInNextRound.Key}");
        }
    }

    // Rest of the method...
}
```

Alternatively, implement a dedicated validation provider that checks `MissedTimeSlots` correctness in `ValidateBeforeExecution`.

## Proof of Concept

```csharp
[Fact]
public async Task EvilMinerDetectionBypass_MissedTimeSlotsManipulation()
{
    // Setup: Initialize consensus with a miner who has high MissedTimeSlots
    var maliciousMiner = SampleAccount.Accounts[0].KeyPair;
    var maliciousMinerPubkey = maliciousMiner.PublicKey.ToHex();
    
    // Initialize first round with malicious miner
    await InitializeConsensus();
    
    // Simulate multiple rounds where malicious miner misses time slots
    // to accumulate MissedTimeSlots close to threshold (4320)
    for (int i = 0; i < 4310; i++)
    {
        // Advance rounds with malicious miner missing slots
        await ProduceNormalBlock(otherMinerKeyPair);
    }
    
    // Get current round and verify malicious miner has high MissedTimeSlots
    var currentRound = await GetCurrentRoundInformation();
    var maliciousMinerInfo = currentRound.RealTimeMinersInformation[maliciousMinerPubkey];
    Assert.True(maliciousMinerInfo.MissedTimeSlots >= 4310);
    Assert.True(maliciousMinerInfo.MissedTimeSlots < 4320); // Not yet flagged
    
    // Malicious miner is selected as extra block producer
    // Generate correct NextRoundInput off-chain
    var correctNextRoundInput = GenerateNextRoundInput(currentRound, maliciousMinerPubkey);
    
    // Verify correct input has incremented MissedTimeSlots
    var correctMinerInfo = correctNextRoundInput.RealTimeMinersInformation[maliciousMinerPubkey];
    Assert.Equal(maliciousMinerInfo.MissedTimeSlots.Add(1), correctMinerInfo.MissedTimeSlots);
    
    // ATTACK: Malicious miner manipulates MissedTimeSlots before submission
    var manipulatedInput = correctNextRoundInput.Clone();
    manipulatedInput.RealTimeMinersInformation[maliciousMinerPubkey].MissedTimeSlots = 100; // Reset counter
    
    // Submit manipulated transaction
    var result = await ExecuteConsensusTransaction(nameof(NextRound), manipulatedInput, maliciousMiner);
    Assert.True(result.Status == TransactionResultStatus.Mined); // Transaction succeeds
    
    // Verify manipulated data was stored to state
    var newRound = await GetCurrentRoundInformation();
    var storedMinerInfo = newRound.RealTimeMinersInformation[maliciousMinerPubkey];
    Assert.Equal(100, storedMinerInfo.MissedTimeSlots); // Manipulated value stored!
    
    // Continue for more rounds - malicious miner should be detected but isn't
    for (int i = 0; i < 100; i++)
    {
        await ProduceNormalBlock(otherMinerKeyPair);
        
        // Check if malicious miner was flagged as evil
        var candidateInfo = await GetCandidateInformation(maliciousMinerPubkey);
        Assert.False(candidateInfo.IsEvilNode); // Still not flagged!
    }
    
    // Vulnerability confirmed: Malicious miner bypassed evil detection despite
    // having exceeded threshold by manipulating MissedTimeSlots in NextRoundInput
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L100-120)
```csharp
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
        }

        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
        return new Empty();
    }
```
