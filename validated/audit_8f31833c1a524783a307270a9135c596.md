# Audit Report

## Title
Period Boundary Validation Bypass Causes Permanent Share Dilution in Profit Distribution

## Summary
The `AddBeneficiary` method in the Profit contract fails to validate that `EndPeriod >= StartPeriod`, allowing profit details with inverted period boundaries to be created. When schemes have non-zero `DelayDistributePeriodCount`, beneficiaries can be added where `StartPeriod > EndPeriod`. These malformed details have their shares permanently added to `TotalShares` but are filtered out during profit claims, causing irreversible dilution of all legitimate beneficiaries' profits.

## Finding Description

The vulnerability exists in the `AddBeneficiary` method where period boundaries are validated and set. The method only validates that `EndPeriod >= CurrentPeriod` [1](#0-0)  but does not validate the relationship between `EndPeriod` and `StartPeriod`.

The `StartPeriod` is calculated by adding `DelayDistributePeriodCount` to `CurrentPeriod` [2](#0-1) , while `EndPeriod` comes from user input [3](#0-2) . This allows scenarios where `StartPeriod > EndPeriod`.

**Example Scenario:**
- Scheme has `CurrentPeriod = 100` and `DelayDistributePeriodCount = 50`
- User provides `EndPeriod = 120` (passes validation: 120 >= 100)
- Result: `StartPeriod = 150`, `EndPeriod = 120` â†’ `StartPeriod > EndPeriod`

The shares are immediately added to `TotalShares` [4](#0-3) .

When beneficiaries attempt to claim profits, malformed details are filtered out. The `ClaimProfits` method checks if `EndPeriod >= StartPeriod` when `LastProfitPeriod == 0` [5](#0-4) , excluding these details from `availableDetails`.

Share cleanup only occurs for details in `profitDetailsToRemove`, which are derived from `profitableDetails`, which come from `availableDetails` [6](#0-5) . Since malformed details never enter `availableDetails`, their shares remain in `TotalShares` permanently.

The `FixProfitDetail` method has the same vulnerability, allowing existing profit details to be modified to have `StartPeriod > EndPeriod` [7](#0-6)  without validation.

**Real-World Impact:** The Treasury contract's Welfare scheme is initialized with `DelayDistributePeriodCount = 1` [8](#0-7) , making it vulnerable to this issue. The Election contract adds beneficiaries to this Welfare scheme [9](#0-8) .

## Impact Explanation

**Direct Fund Impact - Permanent Profit Dilution:**

When orphaned shares remain in `TotalShares`, all profit distributions use an inflated denominator. The profit calculation divides each beneficiary's shares by total shares [10](#0-9) .

**Concrete Example:**
- Legitimate beneficiary Alice has 1,000 shares
- Malicious/misconfigured entry adds 9,000 unclaimed shares
- `TotalShares = 10,000`, but only 1,000 are claimable
- Distribution of 100,000 tokens: Alice receives `(1,000 / 10,000) * 100,000 = 10,000`
- Alice loses 90% of intended profits (90,000 tokens)
- Lost funds remain locked in period virtual addresses indefinitely

**Affected Parties:**
- All legitimate beneficiaries in schemes with `DelayDistributePeriodCount > 0`
- Treasury Welfare scheme (core citizen welfare mechanism)
- Subsidy schemes for candidates

**Severity: HIGH** - This causes permanent, irreversible dilution affecting core economic mechanisms. The impact compounds over time as each distribution period suffers the same dilution.

## Likelihood Explanation

**Attack Vectors:**

1. **Unintentional Misconfiguration:** Scheme managers adding beneficiaries without understanding the `DelayDistributePeriodCount` constraint. With `CurrentPeriod = 100`, `DelayDistributePeriodCount = 50`, and `EndPeriod = 120`, the manager inadvertently creates `StartPeriod = 150 > EndPeriod = 120`.

2. **Deliberate Exploitation via AddBeneficiary:** Malicious scheme managers intentionally adding beneficiaries with invalid periods to dilute shares.

3. **Deliberate Exploitation via FixProfitDetail:** Malicious managers modifying existing valid profit details to have inverted periods.

**Feasibility:**
- Entry points are public methods callable by scheme managers
- Precondition: `DelayDistributePeriodCount > 0` (common in Treasury/Welfare)
- Execution: Single transaction
- Detection: Extremely difficult without analyzing `ProfitDetailsMap` storage before claiming

**Probability:** High for unintentional misconfiguration, as the interaction between `DelayDistributePeriodCount` and `EndPeriod` is non-obvious. Medium for deliberate exploitation by compromised/malicious managers.

## Recommendation

Add validation in both `AddBeneficiary` and `FixProfitDetail` methods to ensure `EndPeriod >= StartPeriod` after calculating the start period:

```csharp
// In AddBeneficiary, after line 188:
var profitDetail = new ProfitDetail
{
    StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
    EndPeriod = input.EndPeriod,
    Shares = input.BeneficiaryShare.Shares,
    Id = input.ProfitDetailId
};

// Add validation:
Assert(profitDetail.EndPeriod >= profitDetail.StartPeriod, 
    $"Invalid period boundaries. EndPeriod ({profitDetail.EndPeriod}) must be >= StartPeriod ({profitDetail.StartPeriod})");
```

```csharp
// In FixProfitDetail, after line 301:
Assert(newDetail.EndPeriod >= newDetail.StartPeriod,
    $"Invalid period boundaries. EndPeriod ({newDetail.EndPeriod}) must be >= StartPeriod ({newDetail.StartPeriod})");
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a profit scheme with `DelayDistributePeriodCount = 10`
2. Add a beneficiary with `EndPeriod = CurrentPeriod + 5` (less than `StartPeriod = CurrentPeriod + 10`)
3. Verify shares are added to `TotalShares`
4. Distribute profits and verify the malformed beneficiary cannot claim
5. Verify shares remain in `TotalShares` permanently, diluting all subsequent distributions

The test would confirm that legitimate beneficiaries receive proportionally reduced profits based on the inflated `TotalShares` denominator.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L188-188)
```csharp
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L189-189)
```csharp
            EndPeriod = input.EndPeriod,
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L299-301)
```csharp
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-792)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-382)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
```
