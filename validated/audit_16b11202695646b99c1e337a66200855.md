# Audit Report

## Title
Removed Proposers Can Still Release Approved Proposals Due to Missing Whitelist Validation in Release Function

## Summary
All three AElf governance contracts (Referendum, Association, and Parliament) enforce proposer whitelist validation during proposal creation but fail to re-validate whitelist membership during proposal release. This Time-of-Check-Time-of-Use (TOCTOU) vulnerability allows proposers removed from the whitelist to execute their previously approved proposals, bypassing the organization's intent to revoke governance privileges.

## Finding Description

The vulnerability stems from inconsistent authorization enforcement across the proposal lifecycle. When a proposer creates a proposal, their whitelist membership is validated. However, when they later release an approved proposal, only their stored proposer address is checked—not their current whitelist status.

**Referendum Contract:**

During proposal creation, `CreateProposal` calls `AssertIsAuthorizedProposer` to enforce whitelist validation: [1](#0-0) 

The whitelist validation checks if the proposer is in the organization's current whitelist: [2](#0-1) 

However, the `Release` function only verifies that the caller matches the stored proposer address, without re-validating current whitelist membership: [3](#0-2) 

Organizations can modify their proposer whitelist at any time: [4](#0-3) 

**Association Contract has identical vulnerability:**

Whitelist checked during creation: [5](#0-4) 

Whitelist validation in helper: [6](#0-5) 

Release function missing whitelist re-validation: [7](#0-6) 

Whitelist can be modified: [8](#0-7) 

**Parliament Contract has identical vulnerability:**

Whitelist checked during creation: [9](#0-8) 

Whitelist validation logic (allows whitelist or parliament members): [10](#0-9) 

Release function missing whitelist re-validation: [11](#0-10) 

**Attack Flow:**
1. Attacker is legitimately in the proposer whitelist
2. Attacker creates proposal via `CreateProposal` (passes whitelist check)
3. Organization members approve the proposal (reaches approval threshold)
4. Organization removes attacker from whitelist via `ChangeOrganizationProposerWhiteList` due to detected suspicious behavior
5. Attacker calls `Release` on their approved proposal
6. Release succeeds because it only checks `Context.Sender.Equals(proposal.Proposer)`, not current whitelist status
7. Arbitrary contract method executes with full organization authority via `SendVirtualInlineBySystemContract`

## Impact Explanation

This vulnerability has severe authorization and governance implications:

**Authorization Bypass**: When an organization removes a proposer from the whitelist, they explicitly signal revocation of governance privileges. However, the removed proposer retains execution rights for all previously approved proposals, defeating the purpose of whitelist removal.

**Unauthorized Operations with Organization Authority**: The released proposal executes arbitrary contract methods with the organization's virtual address authority, enabling:
- Token transfers from organization treasury
- Contract upgrades and configuration changes  
- Authority modifications
- Any privileged operations the organization can perform

**No Effective Mitigation**: Organizations cannot directly prevent removed proposers from executing approved proposals. The only removal mechanism (`ClearProposal`) only works on expired proposals, not active approved ones. Organizations must either wait for natural expiration or coordinate mass rejection—both impractical in time-sensitive scenarios.

**Malicious Insider Exploitation**: An insider can create multiple benign-looking proposals while authorized, wait for approval, and execute them all after removal when malicious intent is revealed.

This violates the fundamental security invariant that authorization checks must be enforced consistently throughout the governance lifecycle, not just at creation time.

## Likelihood Explanation

The likelihood is **MEDIUM-to-HIGH** for the following reasons:

**Public and Accessible**: All involved methods (`CreateProposal`, `Release`, `ChangeOrganizationProposerWhiteList`) are public entry points with no special permissions beyond the documented checks.

**Realistic Preconditions**: 
- Initial whitelist access is a legitimate starting point (not a compromised state)
- Proposal creation and approval are normal governance operations
- Whitelist removal due to loss of trust is a realistic governance scenario

**Low Attack Cost**: Exploitation requires only standard transaction fees to call the `Release` method.

**Exploitation Window**: The time gap between proposal approval and potential whitelist removal creates a realistic exploitation opportunity, especially in organizations with active governance.

**No Detection Until Execution**: The vulnerability is invisible until the removed proposer actually calls `Release`, at which point the unauthorized operation completes atomically.

## Recommendation

Add whitelist re-validation in all three `Release` functions before executing the proposal:

**For Referendum Contract:**
```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    
    // ADD THIS CHECK:
    AssertIsAuthorizedProposer(proposal.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposal.ToAddress, proposal.ContractMethodName, proposal.Params);
    
    Context.Fire(new ProposalReleased { ProposalId = input });
    State.Proposals.Remove(input);
    return new Empty();
}
```

Apply the same fix to `Association.cs` and `Parliament.cs` by adding `AssertIsAuthorizedProposer` call before executing the proposal.

This ensures that authorization is validated at both proposal creation and execution time, eliminating the TOCTOU vulnerability.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task RemovedProposer_CanStillReleaseApprovedProposal()
{
    // 1. Add attacker to whitelist
    var attacker = Accounts[1].Address;
    await AddProposerToWhitelist(organizationAddress, attacker);
    
    // 2. Attacker creates proposal while authorized
    var proposalId = await CreateProposal(attacker, organizationAddress, 
        targetContract, "TransferTokens", transferParams);
    
    // 3. Proposal gets approved by members
    await ApproveProposal(proposalId, requiredApprovers);
    
    // 4. Organization removes attacker from whitelist
    await RemoveProposerFromWhitelist(organizationAddress, attacker);
    
    // 5. Verify attacker is no longer in whitelist
    var isInWhitelist = await ValidateProposerInWhiteList(organizationAddress, attacker);
    Assert.False(isInWhitelist);
    
    // 6. VULNERABILITY: Attacker can still release the approved proposal
    var releaseResult = await ReleaseProposal(attacker, proposalId);
    
    // 7. Verify unauthorized execution succeeded
    Assert.True(releaseResult.Success);
    Assert.True(await VerifyProposalExecuted(proposalId));
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```
