# Audit Report

## Title
Scheme Manager Can Steal Profit Shares from Locked Token Holders via RemoveBeneficiary

## Summary
The TokenHolder contract's `RemoveBeneficiary` function allows scheme managers to remove or reduce profit shares from users who locked tokens via `RegisterForProfits`, while their tokens remain locked for the minimum lock period. This breaks the core economic guarantee that locking tokens entitles users to proportional profit distributions for the duration of the lock.

## Finding Description

The vulnerability exists in the `RemoveBeneficiary` function which fails to distinguish between two types of beneficiaries:

1. **Manager-added beneficiaries** (via `AddBeneficiary`): No tokens locked, freely removable
2. **Self-registered beneficiaries** (via `RegisterForProfits`): Tokens locked with minimum duration, should be protected

When a scheme is created, it sets `CanRemoveBeneficiaryDirectly = true` [1](#0-0) , allowing the manager to remove any beneficiary.

When users register for profits, they lock their tokens and the lock ID is stored [2](#0-1) , then they're added as beneficiaries to the Profit contract with shares equal to their locked amount [3](#0-2) .

However, the `RemoveBeneficiary` function only validates the caller is the scheme manager [4](#0-3)  and proceeds to remove the beneficiary from the Profit contract [5](#0-4)  without:
- Checking if the beneficiary has locked tokens
- Unlocking the tokens
- Removing the lock ID from state

In the Profit contract, when `CanRemoveBeneficiaryDirectly` is true, the removal sets the beneficiary's `EndPeriod` to `CurrentPeriod - 1` [6](#0-5) , effectively terminating all future profit claims.

The user can still eventually call `Withdraw` to unlock their tokens, but only after the minimum lock period expires [7](#0-6) . During this forced lock period with zero profit shares, the manager (or other beneficiaries) receive the redistributed profit allocations that should have gone to the victim.

## Impact Explanation

This vulnerability enables direct theft of profit distributions:

**Financial Impact:**
- Users lock capital expecting proportional profits for the lock duration
- Manager removes their shares while tokens remain locked
- During the lock period, users receive zero profits despite locked capital
- The "stolen" profit share is redistributed to remaining beneficiaries (potentially including the manager)

**Quantified Example:**
A user locks 10,000 tokens for a 30-day minimum lock period. If the manager removes 9,999 of their 10,000 shares:
- User expected: 50% of profits if manager has equal shares (5,000 tokens from 10,000 distributed)
- User receives: ~0.01% of profits (1 token from 10,000 distributed)
- Manager receives: ~99.99% of profits (9,999 tokens)
- Net theft: ~4,999 tokens of profit while user's capital remains locked

**Severity:**
Critical - This violates the fundamental economic invariant that locked tokens guarantee proportional profit share. It's a direct authorization bypass where the manager gains unauthorized control over profit distributions that should be protected by the lock mechanism.

## Likelihood Explanation

**High Likelihood due to:**

1. **Low Attacker Requirements:**
   - Any user can become a scheme manager by calling `CreateScheme` (permissionless) [8](#0-7) 
   - No special privileges required beyond scheme creation
   - Single function call to execute the attack

2. **No Technical Barriers:**
   - Attack is a simple `RemoveBeneficiary` transaction
   - No timing constraints or race conditions
   - No complex state manipulation needed
   - Works immediately after users lock tokens

3. **Expected User Behavior:**
   - Users locking tokens via `RegisterForProfits` is normal, expected usage
   - No way for users to detect malicious intent before locking
   - Once locked, users cannot escape until minimum period expires

4. **Economic Incentives:**
   - Zero cost attack (just transaction fee)
   - Direct profit for attacker (receives redistributed shares)
   - Rational for any malicious manager
   - Appears as "legitimate" scheme management on-chain

## Recommendation

Add a check in `RemoveBeneficiary` to verify whether the beneficiary has locked tokens. If they do, either:

1. **Prevent removal entirely** for beneficiaries with active locks:
```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    if (lockId != null)
    {
        var lockTimestamp = State.LockTimestamp[lockId];
        var unlockTime = lockTimestamp.AddMinutes(scheme.MinimumLockMinutes);
        Assert(Context.CurrentBlockTime >= unlockTime, 
            "Cannot remove beneficiary with locked tokens before minimum lock period expires.");
    }
    
    // ... rest of existing logic
}
```

2. **Automatically unlock tokens** before removing the beneficiary, allowing users to reclaim their capital immediately.

The first approach is simpler and maintains the lock commitment, while the second provides better UX but requires additional unlock logic.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_ShouldNotRemoveUserWithLockedTokens()
{
    // 1. Manager creates scheme with 30-day minimum lock
    var schemeManager = Accounts[0];
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 30 * 24 * 60 // 30 days
    });
    
    // 2. User locks 10,000 tokens
    var user = Accounts[1];
    await TokenStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 10000
    });
    
    await TokenHolderStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager.Address,
        Amount = 10000
    });
    
    // 3. Manager removes user's profit share (VULNERABILITY)
    await TokenHolderStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = user.Address,
        Amount = 0 // Remove completely
    });
    
    // 4. Verify user has no profit shares
    var profitDetails = await ProfitStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = user.Address
    });
    
    // User's EndPeriod is set to past, meaning no future profits
    Assert.True(profitDetails.Details[0].EndPeriod < currentPeriod);
    
    // 5. Verify user's tokens are STILL LOCKED
    var lockedAmount = await TokenStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user.Address,
        Symbol = "ELF",
        LockId = lockId
    });
    
    Assert.Equal(10000, lockedAmount.Amount); // Tokens still locked!
    
    // 6. Verify user CANNOT withdraw yet (before 30 days)
    var withdrawResult = await TokenHolderStub.Withdraw.SendWithExceptionAsync(schemeManager.Address);
    Assert.Contains("Cannot withdraw", withdrawResult.TransactionResult.Error);
    
    // Result: User has 10,000 tokens locked with zero profit share for 30 days
}
```

## Notes

The root cause is that `RemoveBeneficiary` in TokenHolderContract treats all beneficiaries identically, regardless of whether they locked tokens (self-registered via `RegisterForProfits`) or were simply added by the manager (via `AddBeneficiary`). The lock state stored in `State.LockIds` and `State.LockTimestamp` [9](#0-8)  is never consulted during removal, creating a critical gap where users' economic guarantees can be violated while their capital remains at risk.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L72-72)
```csharp
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L80-84)
```csharp
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-167)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L351-355)
```csharp
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-17)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }

    public MappedState<Hash, Timestamp> LockTimestamp { get; set; }
```
