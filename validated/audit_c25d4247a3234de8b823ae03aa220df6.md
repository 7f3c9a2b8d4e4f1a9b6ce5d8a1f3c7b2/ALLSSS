# Audit Report

## Title
Time-Of-Check-Time-Of-Use Vulnerability in EnableConnector Due to External Callback Reentrancy

## Summary
The `EnableConnector` function in the TokenConverter contract violates the Checks-Effects-Interactions (CEI) pattern by calculating deposit requirements, executing external token transfers with callback support, then writing the potentially stale calculation to state. This enables TOCTOU attacks where token callbacks can modify supply/balances or trigger recursive calls, causing incorrect reserve tracking and subsequent mispricing in Buy/Sell operations.

## Finding Description

The vulnerability exists in `EnableConnector`'s execution sequence which reads state, makes external calls with callbacks, then writes stale data: [1](#0-0) 

The function first calls `GetNeededDeposit()` which reads current token supply and balances to calculate required deposits: [2](#0-1) 

After calculating `needDeposit`, `EnableConnector` executes two `TransferFrom` operations. These calls invoke the MultiToken contract's `DoTransferFrom` method which crucially calls `DealWithExternalInfoDuringTransfer` AFTER modifying balances: [3](#0-2) 

The callback mechanism uses `Context.SendInline` to execute arbitrary contract code if the token has `TransferCallbackExternalInfoKey` configured: [4](#0-3) 

**Security Guarantees Broken:**

1. **CEI Pattern Violation**: State is read (line 276), external calls are made (lines 278-295), then stale values are written (line 297)
2. **No Reentrancy Guard**: Unlike `UpdateConnector` which checks `IsPurchaseEnabled` status, `EnableConnector` has no such protection
3. **No Authority Check**: Unlike other connector management functions, `EnableConnector` lacks `AssertPerformedByConnectorController()`, allowing anyone to enable governance-approved connectors

**Attack Vector:**

During the callback execution between lines 278-295, an attacker can:
- Mint/burn tokens to change `TotalSupply` (requires issuer authority)
- Transfer tokens to change balances
- Recursively call `EnableConnector` (inner call sets correct value, outer call overwrites with stale value)

The stale `needDeposit.NeedAmount` is then written to `State.DepositBalance`, which directly affects all subsequent pricing calculations.

## Impact Explanation

The incorrect `State.DepositBalance` value is used by `GetSelfBalance` for Bancor pricing: [5](#0-4) 

This incorrect balance feeds into Buy and Sell operations: [6](#0-5) [7](#0-6) 

The Bancor formula calculations use these incorrect balances, resulting in:

**If DepositBalance too low:**
- Buy operations: Users pay less than fair price → protocol economic loss
- Sell operations: Users receive more than fair price → reserve drainage

**If DepositBalance too high:**
- Buy operations: Users overpay → unfair pricing disadvantages users
- Sell operations: Users receive less → unfair pricing disadvantages users

This affects all users trading through the connector pair and compromises the protocol's reserve backing integrity.

## Likelihood Explanation

**Required Preconditions:**
1. Governance must approve adding a connector via `AddPairConnector` (requires controller authority)
2. Token must have `TransferCallbackExternalInfoKey` configured in ExternalInfo (legitimate AElf feature)
3. Callback must modify state affecting deposit calculations OR trigger reentrancy

**Facilitating Factors:**
- **No authority check on EnableConnector**: Anyone can call it on governance-approved connectors
- **Transfer callbacks are legitimate**: Governance may approve tokens with callbacks without realizing TOCTOU implications
- **Unintentional triggers**: Rebase tokens, fee-on-transfer tokens, or tokens with dividend distributions could inadvertently trigger this without malicious intent

**Attack Complexity:** Low once preconditions met - attacker simply calls `EnableConnector` with appropriate parameters.

**Detection Difficulty:** High - requires thorough audit of token callback behavior, which governance may not perform in detail.

**Probability Assessment:** MEDIUM - While governance approval creates a barrier, the vulnerability stems from an architectural flaw (CEI violation) that could be triggered by any token with transfer side effects, not just overtly malicious ones. The lack of authority check on `EnableConnector` increases exploitability.

## Recommendation

Implement the following fixes:

1. **Enforce CEI Pattern**: Move state writes before external calls
2. **Add Reentrancy Guard**: Implement a reentrancy mutex or check `IsPurchaseEnabled` status
3. **Add Authority Check**: Require `AssertPerformedByConnectorController()` for `EnableConnector`
4. **Validate State After Transfers**: Recalculate or validate deposit amount after transfers complete

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController(); // Add authority check
    
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled"); // Add reentrancy protection
    
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
    
    var needDeposit = GetNeededDeposit(input);
    
    // Effects: Set state BEFORE interactions
    State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
    toConnector.IsPurchaseEnabled = true;
    fromConnector.IsPurchaseEnabled = true;
    State.Connectors[input.TokenSymbol] = fromConnector;
    State.Connectors[toConnector.Symbol] = toConnector;
    
    // Interactions: External calls AFTER state changes
    if (needDeposit.NeedAmount > 0)
        State.TokenContract.TransferFrom.Send(...);
    
    if (input.AmountToTokenConvert > 0)
        State.TokenContract.TransferFrom.Send(...);
    
    return new Empty();
}
```

## Proof of Concept

The POC would demonstrate:
1. Governance adds connector pair with token that has callback configured
2. Attacker deploys callback contract that mints tokens during transfer
3. Attacker calls `EnableConnector`
4. During `TransferFrom` callback, tokens are minted
5. Stale `needDeposit` value is written to `State.DepositBalance`
6. Subsequent Buy/Sell operations use incorrect deposit balance, resulting in mispricing

A concrete test would require setting up a token with ExternalInfo containing `TransferCallbackExternalInfoKey`, configuring a callback that modifies token supply, then demonstrating that `State.DepositBalance` is set to an incorrect value that causes Buy/Sell operations to compute wrong prices using the Bancor formula.

## Notes

An additional issue was observed: lines 298-299 in `EnableConnector` set `IsPurchaseEnabled = true` on local connector variables without explicit re-assignment to `State.Connectors[...]`, which other methods in the contract consistently do. This may indicate a separate persistence bug where the enabled status is not properly saved to state, though this requires verification of AElf's state management semantics for mapped state objects.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```
