# Audit Report

## Title
Scheme Manager Can Remove Self-Registered Token Holders Without Unlocking Tokens, Causing Loss of Expected Dividends

## Summary
Users who lock tokens via `RegisterForProfits` to earn profit distributions can be unilaterally removed by the scheme manager using `RemoveBeneficiary`. This removes their beneficiary status but leaves tokens locked in the MultiToken contract, creating an inconsistent state where users lose all future dividends while capital remains frozen until the minimum lock period expires.

## Finding Description

The TokenHolder contract implements two distinct beneficiary management flows that fail to coordinate properly:

**Flow 1: Manager-Controlled Beneficiaries**
The scheme manager can add/remove beneficiaries via `AddBeneficiary` and `RemoveBeneficiary` without any token locking. [1](#0-0) [2](#0-1) 

**Flow 2: User Self-Registration**
Users lock tokens via `RegisterForProfits`, which generates a lock ID, locks tokens in the MultiToken contract, stores the lock ID in `State.LockIds`, and adds them as beneficiaries to the Profit contract. [3](#0-2) 

**Root Cause:**
The `RemoveBeneficiary` function only validates scheme manager authority but does NOT check whether the beneficiary has locked tokens via `State.LockIds`. It removes the beneficiary from the Profit contract but never unlocks tokens or removes the lock ID. [2](#0-1) 

When `RemoveBeneficiary` is called on the Profit contract with `CanRemoveBeneficiaryDirectly = true` (explicitly set during TokenHolder scheme creation), it removes or shortens profit details, terminating all future profit distributions. [4](#0-3) [5](#0-4) 

**Execution Flow:**
1. User calls `RegisterForProfits` → tokens locked via `State.TokenContract.Lock`, lock ID stored in `State.LockIds`
2. Manager calls `RemoveBeneficiary` → beneficiary removed from Profit contract, tokens remain locked
3. User must wait until `MinimumLockMinutes` expires to call `Withdraw` [6](#0-5) 

During this period, the user receives ZERO profit distributions despite having capital locked.

## Impact Explanation

Users suffer direct and quantifiable financial losses:

**Loss of Expected Returns:** Locked tokens that previously earned profit distributions now generate ZERO returns after removal. All dividends distributed during the remaining lock period are permanently lost.

**Capital Freezing:** Users cannot withdraw or redeploy their capital until the `MinimumLockMinutes` period expires, despite earning nothing during this time.

**Quantified Scenario:**
- User locks 10,000 tokens for 30-day minimum period expecting dividends
- Manager removes them after 5 days
- User loses 25 days of dividend distributions (potentially significant value)
- Capital remains frozen for 25 additional days with zero returns

**Protocol Invariant Violation:** The fundamental economic agreement is that "locked capital → profit distributions." The manager can unilaterally convert this to "locked capital → no profits" without unlocking funds, breaking the core lock-for-profit mechanism.

## Likelihood Explanation

**High Likelihood** - This can occur during normal operations:

1. **Attacker Capabilities:** The scheme manager has legitimate authority to call `RemoveBeneficiary` by design. This is not a privilege escalation but rather a mis-scoped privilege.

2. **Simple Execution:** Manager simply calls `RemoveBeneficiary(userAddress)` with no complex conditions or attack sophistication required.

3. **No Technical Barriers:**
   - `CanRemoveBeneficiaryDirectly = true` is hardcoded [7](#0-6) 
   - No validation prevents removal of self-registered users
   - No checks for locked tokens in `State.LockIds`

4. **Realistic Scenario:** A manager might legitimately want to rebalance beneficiaries without realizing some users have locked tokens. They may assume all beneficiaries were added via `AddBeneficiary` (Flow 1) when some used `RegisterForProfits` (Flow 2).

5. **No Test Coverage:** The test suite contains no tests combining `RegisterForProfits` followed by `RemoveBeneficiary`. All `RemoveBeneficiary` tests only cover manager-added beneficiaries. [8](#0-7) [9](#0-8) 

## Recommendation

Modify `RemoveBeneficiary` to check if the beneficiary has locked tokens via `RegisterForProfits` and prevent removal or automatically unlock tokens:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens (self-registered)
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary with locked tokens. User must withdraw first.");
    
    // Existing removal logic...
    var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details.Single();
    
    // Continue with removal...
}
```

Alternatively, automatically unlock tokens when removing self-registered users, or provide a separate method for managers that explicitly handles the locked token scenario.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_After_RegisterForProfits_Leaves_Tokens_Locked()
{
    // Setup: Create scheme with 30-day minimum lock period
    var minimumLockMinutes = 30 * 24 * 60; // 30 days
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = minimumLockMinutes
    });
    
    // User registers for profits with locked tokens
    var userAmount = 10000L;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = userAmount,
        SchemeManager = Starter
    });
    
    // Verify user is beneficiary and tokens are locked
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        Beneficiary = Starter,
        SchemeId = schemeIds.SchemeIds[0]
    });
    profitDetails.Details.Count.ShouldBe(1);
    
    // Manager removes beneficiary
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Amount = 0  // Complete removal
    });
    
    // VULNERABILITY: User is no longer a beneficiary (won't receive profits)
    var afterRemovalDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        Beneficiary = Starter,
        SchemeId = schemeIds.SchemeIds[0]
    });
    afterRemovalDetails.Details.Count.ShouldBe(0); // No longer beneficiary
    
    // But tokens remain locked - withdrawal fails before minimum lock period
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    withdrawResult.TransactionResult.Error.ShouldContain("Cannot withdraw");
    
    // User loses all dividends during remaining lock period while capital is frozen
}
```

**Notes:**

This vulnerability represents a design coordination failure between two legitimate operational flows. The scheme manager is NOT in the trusted roles list (genesis method-fee provider, organization controllers, consensus system contracts), making this a case of mis-scoped privileges rather than trusted role abuse.

The core issue is that `RemoveBeneficiary` was designed for Flow 1 (manager-controlled beneficiaries with no locks) but can also be applied to Flow 2 (user self-registration with locks), creating an inconsistent state that violates the fundamental economic contract of "locked capital earns dividends."

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-356)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        //id == null
        if (scheme.CanRemoveBeneficiaryDirectly && profitDetailId != null)
        {
            detailsCanBeRemoved = detailsCanBeRemoved.All(d => d.Id != profitDetailId)
                ? detailsCanBeRemoved.Where(d => d.Id == null).ToList()
                : detailsCanBeRemoved.Where(d => d.Id == profitDetailId).ToList();
        }

        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }

        if (detailsCanBeRemoved.Any())
        {
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L138-153)
```csharp
    public async Task RemoveBeneficiaryTest()
    {
        await AddBeneficiaryTest();

        var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);

        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First()
        });

        {
            var originScheme = await ProfitContractStub.GetScheme.CallAsync(tokenHolderProfitScheme.SchemeId);
            originScheme.TotalShares.ShouldBe(0);
        }
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L156-196)
```csharp
    public async Task RemoveBeneficiary_With_Amount_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF"
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 9999
        });
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Shares = 1000
        });
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds[0];
        var beforeRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var amount = 10;
        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Amount = amount
        });
        var afterRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeIds.SchemeIds[0]);
        afterRemoveScheme.TotalShares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
