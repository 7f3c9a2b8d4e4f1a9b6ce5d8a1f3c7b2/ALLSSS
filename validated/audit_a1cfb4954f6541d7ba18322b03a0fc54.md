# Audit Report

## Title
Retroactive Miner Count Calculation Causes Sudden Jumps When MinerIncreaseInterval is Modified

## Summary
The `SetMinerIncreaseInterval()` function allows governance to decrease the miner increase interval, but the miner count calculation retroactively applies the new interval to the entire blockchain history. This causes an immediate jump in the calculated miner count, violating the intended gradual increase mechanism and disrupting consensus by suddenly selecting more miners than should be eligible.

## Finding Description

The vulnerability exists in the miner count calculation logic. When `SetMinerIncreaseInterval()` updates the interval value [1](#0-0) , this new value is immediately used by `GetAutoIncreasedMinersCount()` to calculate the miner count [2](#0-1) .

The calculation formula divides the **entire elapsed time since blockchain start** by the **current interval value**, then multiplies by 2. When the interval decreases (e.g., from 1 year to 6 months), the division produces a larger quotient, as if the shorter interval had always been in effect throughout the blockchain's history.

This retroactive calculation is also used in `GetMinersCount()` [3](#0-2) , which is called during term transitions [4](#0-3)  and when setting the maximum miners count [5](#0-4) .

The jumped value is propagated to the Election Contract via `UpdateMinersCountToElectionContract()` [6](#0-5) , where it's stored [7](#0-6)  and used by `GetVictories()` to determine how many candidates should become miners [8](#0-7) .

## Impact Explanation

**Concrete Example:**
- Initial: 2 years elapsed (63,072,000 seconds), interval = 31,536,000 seconds → count = 17 + (2 intervals × 2) = 21 miners
- After decreasing to 6 months (15,768,000 seconds) → count = 17 + (4 intervals × 2) = 25 miners  
- Result: Sudden jump of 4 miners

**Protocol Damage:**

1. **Consensus Disruption**: The sudden addition of 4+ miners changes the consensus participant set abruptly, violating the intended gradual decentralization where only 2 miners should be added per interval [9](#0-8) 

2. **Reward Dilution**: Mining rewards are distributed among all active miners, so existing miners suddenly receive proportionally less reward per block

3. **Security Model Violation**: AEDPoS consensus uses Byzantine fault tolerance where the number of miners affects security thresholds. An unexpected jump in miner count alters these assumptions

4. **Candidate Selection Error**: Less-qualified candidates who weren't supposed to be eligible yet become miners immediately, potentially affecting network quality

**Severity: MEDIUM** - While this doesn't directly steal funds or break authorization, it violates critical consensus invariants and causes operational disruption with reward misallocation.

## Likelihood Explanation

This requires governance authorization through `MaximumMinersCountController` (Parliament by default), which is a trusted role. However, the vulnerability is a **logic bug**, not governance abuse.

**Key Point**: Even when governance acts legitimately and honestly to accelerate decentralization, the bug triggers automatically. The governance's intent is to change the **future rate** of miner additions, but the implementation retroactively recalculates **all historical additions** as if the new interval had always been in effect.

**Triggering Conditions:**
- Governance approves an interval decrease through the validation check [10](#0-9) 
- Next term transition or `SetMaximumMinersCount` call propagates the jumped value
- The retroactive calculation is deterministic and automatic

**Probability: HIGH** - If governance ever adjusts the interval for legitimate policy reasons (e.g., accelerating decentralization), the bug triggers with certainty. Governance may not realize the retroactive effect until after approval.

## Recommendation

Track the history of interval changes and calculate miner count incrementally based on when each interval was in effect, rather than applying the current interval retroactively to all historical time. Implement a state variable that stores when each interval change occurred and calculate the miner count as a sum of contributions from each period.

Alternative: Add a separate state variable to track the base miner count at the time of interval change, then only apply the new interval to time elapsed after the change.

## Proof of Concept

```csharp
[Fact]
public async Task RetroactiveMinerCountJumpTest()
{
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    // Get initial state
    var initialInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    var initialMinersCount = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    
    // Simulate 2 years of blockchain operation by advancing time
    _blockTimeProvider.SetBlockTime(TimestampHelper.GetUtcNow().AddSeconds(63072000)); // 2 years
    
    // Check miners count before interval change
    var minersCountBefore = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    
    // Decrease interval to half (simulating from 1 year to 6 months)
    var newInterval = initialInterval.Value / 2;
    var defaultOrg = await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = newInterval }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrg
    });
    
    // Check miners count after interval change - should show retroactive jump
    var minersCountAfter = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    
    // Expected: minersCountBefore = 17 + (2 intervals × 2) = 21
    // Actual after change: minersCountAfter = 17 + (4 intervals × 2) = 25
    // This demonstrates the sudden jump of 4 miners
    minersCountAfter.Value.ShouldBeGreaterThan(minersCountBefore.Value);
    var jump = minersCountAfter.Value - minersCountBefore.Value;
    jump.ShouldBeGreaterThan(2); // More than the intended 2 miners per interval
}
```

## Notes

This vulnerability demonstrates a fundamental flaw in the auto-increase mechanism's temporal logic. The system assumes the current interval has always been in effect, rather than tracking when governance decisions were made. This creates a discontinuity in the consensus parameter that violates the protocol's gradual decentralization guarantees. While governance authorization is required, the bug manifests as an unintended side effect of legitimate governance actions, making it distinct from governance abuse scenarios.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
