# Audit Report

## Title
NFT Collection ExternalInfo Poisoning Enables Permanent Symbol Squatting and DoS

## Summary
An attacker can create NFT collections with malicious `__nft_create_chain_id` values in the ExternalInfo field, permanently blocking NFT item creation for those collections. Since collection symbols are unique and ExternalInfo cannot be updated post-creation, this enables irrevocable symbol squatting attacks on valuable NFT collection names.

## Finding Description

The vulnerability exists in the NFT collection creation flow where ExternalInfo is accepted without validation during collection creation, then later enforced during NFT item creation.

**Unvalidated Collection Creation:**

During NFT collection creation via `TokenContract.Create`, the input ExternalInfo is directly assigned to the TokenInfo without validation of its keys or values. [1](#0-0) 

The validation method `AssertValidCreateInput` only checks token name length, symbol length, and decimals, but does not validate ExternalInfo contents at all. [2](#0-1) 

The constant `NftCreateChainIdExternalInfoKey` is defined as `"__nft_create_chain_id"` and is used to restrict NFT item creation to specific chains. [3](#0-2) 

Critically, this key is NOT included in the reserved external info key list that would prevent users from setting it. The `GetReservedExternalInfoKeyList` method only returns callback-related keys. [4](#0-3) 

**Enforced Chain ID Check:**

When creating NFT items via `CreateNFTInfo`, the system retrieves and enforces the `__nft_create_chain_id` value from the collection's ExternalInfo. If an attacker set this to a non-existent chain ID (e.g., 999999), the assertion permanently fails with "NFT create ChainId must be collection's NFT create chainId". [5](#0-4) 

**No Recovery Mechanism:**

The only method that can update ExternalInfo post-creation is `ExtendSeedExpirationTime`, which is explicitly restricted to updating only the `__seed_exp_time` key for Seed NFTs and cannot modify other ExternalInfo fields. [6](#0-5) 

**Symbol Uniqueness:**

Collection symbols must be unique and cannot be recreated once they exist. The `CheckTokenExists` method enforces this by checking both the TokenInfos registry and the case-insensitive InsensitiveTokenExisting map. [7](#0-6) 

**Attack Feasibility:**

Regular users can create NFT collections if they possess the corresponding SEED NFT. The SEED NFT is consumed during collection creation but the ExternalInfo is not validated. [8](#0-7) 

## Impact Explanation

**Direct Operational Impact:**
- Permanent DoS of NFT item creation for poisoned collections - once a collection is created with an invalid `__nft_create_chain_id`, no NFT items can ever be created under that collection
- Valuable collection symbols (obtainable via SEED NFTs) can be permanently blocked through this attack vector
- Legitimate projects lose access to their intended collection names with no recovery path
- The poisoning is irreversible - there is no method to update or correct the malicious ExternalInfo value

**Ecosystem Harm:**
- Symbol squatting enables extortion scenarios where attackers can demand payment to avoid blocking specific collection names
- Griefing attacks can target competitors by blocking their brand-related collection symbols
- Erodes trust in the NFT ecosystem as desirable symbols become permanently unavailable through malicious actions rather than legitimate use
- Creates artificial scarcity through malicious blocking rather than organic adoption

**Severity: HIGH** - This vulnerability enables permanent, unrecoverable DoS attacks on critical NFT protocol functionality with widespread ecosystem impact.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must acquire a SEED NFT for the target symbol (publicly available through the existing SEED NFT mechanism)
- Requires only basic knowledge of the ExternalInfo structure and the `__nft_create_chain_id` key
- No special privileges, insider access, or system contract authorization needed

**Attack Simplicity:**
- Single transaction: Call `TokenContract.Create` with a symbol ending in "-0" (collection suffix) and crafted ExternalInfo containing an invalid chain ID
- No timing requirements, race conditions, or complex state manipulation needed
- Deterministic and repeatable attack

**Economic Feasibility:**
- Cost: One SEED NFT per collection symbol (limited resource but achievable)
- Benefit: Permanent control/blocking of valuable collection names
- Strategic value: Ability to block competitors from using desirable brand-related collection symbols
- For high-value collection names, the cost-benefit ratio strongly favors the attacker

**Detection Difficulty:**
- Attack appears as a legitimate collection creation transaction
- Malicious ExternalInfo values are not detectable or flagged during transaction processing
- The impact only becomes apparent when someone attempts to create NFT items under the collection
- No inherent red flags in the transaction that would alert monitoring systems

**Likelihood: HIGH** - The attack is straightforward, economically rational for valuable symbols, requires no special privileges beyond SEED NFT ownership, and has no significant technical barriers to execution.

## Recommendation

Implement validation of the `__nft_create_chain_id` ExternalInfo key during NFT collection creation:

1. Add `__nft_create_chain_id` to the reserved external info key list returned by `GetReservedExternalInfoKeyList` to prevent users from setting it directly.

2. If the field is intended to be user-settable, add validation in `CreateNFTCollection` or `AssertValidCreateInput` to ensure the value is a valid, registered chain ID.

3. Consider adding an admin function to allow correction of ExternalInfo for collections in exceptional cases, protected by appropriate governance controls.

4. Alternatively, make the chain ID restriction optional - if the key is not set or invalid, allow NFT creation on any chain rather than blocking it entirely.

## Proof of Concept

```csharp
[Fact]
public async Task ExternalInfoPoisoning_BlocksNFTCreation()
{
    // Step 1: Attacker creates collection with malicious __nft_create_chain_id
    var collectionInfo = new TokenInfo
    {
        Symbol = "ATTACK-0",  // Collection symbol
        TokenName = "Malicious Collection",
        TotalSupply = 0,
        Decimals = 0,
        Issuer = DefaultSender,
        IssueChainId = ChainId,
        ExternalInfo = new ExternalInfo()
        {
            Value =
            {
                {
                    "__nft_create_chain_id",
                    "999999"  // Invalid chain ID
                }
            }
        },
        Owner = DefaultSender
    };
    
    var createCollectionResult = await CreateNFTCollectionAsync(collectionInfo);
    createCollectionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Verify collection was created successfully
    var collectionTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "ATTACK-0" });
    collectionTokenInfo.Symbol.ShouldBe("ATTACK-0");
    
    // Step 3: Attempt to create NFT item - this will permanently fail
    var createNFTResult = await TokenContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        Symbol = "ATTACK-1",  // NFT item under the collection
        TokenName = "NFT Item",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        IssueChainId = ChainId,
        Owner = DefaultSender
    });
    
    // Verify NFT creation is permanently blocked
    createNFTResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    createNFTResult.TransactionResult.Error
        .ShouldContain("NFT create ChainId must be collection's NFT create chainId");
    
    // Step 4: Verify no recovery mechanism exists - collection symbol is squatted permanently
    // Attempting to recreate the collection will fail due to symbol uniqueness
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation where system-critical metadata keys can be set to arbitrary values by users during token creation. The combination of (1) lack of validation during creation, (2) strict enforcement during usage, and (3) immutability of the ExternalInfo field creates a permanent DoS vector. The existing test `CreateNftFailed` in the codebase actually validates this behavior but treats it as an expected feature rather than recognizing the security implication when combined with user-controlled ExternalInfo values.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L26-26)
```csharp
    public const string NftCreateChainIdExternalInfoKey = "__nft_create_chain_id";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L22-28)
```csharp
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
```
