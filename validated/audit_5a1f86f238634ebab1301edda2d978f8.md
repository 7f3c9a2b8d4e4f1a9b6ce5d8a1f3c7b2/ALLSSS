# Audit Report

## Title
Integer Overflow DoS in NFT Protocol Number Generation Due to Incorrect Type Inference

## Summary
The `GetCurrentNumberLength()` function uses `int` type for local variable `protocolNumber` when calculating powers of 10, causing an `OverflowException` when `CurrentSymbolNumberLength` reaches 11. This results in permanent denial-of-service for all NFT protocol creation operations.

## Finding Description

The vulnerability exists in `GetCurrentNumberLength()` at two locations where `protocolNumber` is calculated. [1](#0-0) [2](#0-1) 

The root cause is a type inference issue. The local variable `protocolNumber` is initialized with integer literal `1`, causing C# to infer it as `int` (32-bit) rather than `long` (64-bit). The loop calculates `10^(CurrentSymbolNumberLength - 1)` through repeated multiplication by 10.

Starting from `NumberMinLength = 9`, [3](#0-2)  the system tracks a protocol number flag that grows as more NFT protocols are created.

When `CurrentSymbolNumberLength` reaches 11, the calculation attempts to compute 10^10 = 10,000,000,000, which exceeds `int.MaxValue` (2,147,483,647). The SafeMath multiplication implementation uses checked arithmetic: [4](#0-3) 

This correctly throws an `OverflowException` to prevent silent integer wraparound, but causes the entire transaction to fail. The state variables are properly typed to handle large values: [5](#0-4) 

However, the local variable calculation fails before the value can be stored.

## Impact Explanation

**Operational DoS of Core Functionality**: Once `CurrentSymbolNumberLength` reaches 11, all calls to `Create()` will fail permanently with an `OverflowException`. The NFT protocol creation functionality becomes completely unusable. [6](#0-5) 

**Affected Parties**: All users attempting to create new NFT protocols will be unable to do so. This impacts:
- NFT creators who cannot deploy new collections
- Platform operations that rely on NFT protocol creation
- The entire NFT ecosystem on the chain

**Severity Justification**: This is a High severity issue because:
1. It causes permanent, unrecoverable DoS of a core contract function
2. No administrative action can restore functionality without contract upgrade
3. The threshold (length 11) is reachable through normal protocol usage
4. Once triggered, the impact is immediate and total

## Likelihood Explanation

**Natural Occurrence**: The vulnerability will trigger through normal platform growth:
- Starting at length 9, the system can generate up to 10^9 - 10^8 = 900,000,000 unique protocols
- As more protocols are created, the flag grows and eventually triggers the length increment
- Once length 10 is reached, another ~9 billion protocols can be created before hitting length 11
- At length 11, overflow occurs immediately

**Attack Acceleration**: An attacker can deliberately accelerate reaching this threshold by:
1. Creating multiple NFT protocols (each call to `Create()` increments usage counters)
2. Each creation costs gas fees but is otherwise unrestricted
3. Attack complexity: Low - simply call `Create()` repeatedly with valid inputs
4. Detection: Difficult - appears as legitimate protocol creation until overflow occurs

**Execution Practicality**: 
- Entry point is the public `Create()` method - no special permissions required
- No preconditions beyond standard transaction fees
- Attack is executable under normal AElf contract execution model
- Economic cost is reasonable for an attacker seeking to DoS the protocol

**Probability**: Medium to High
- Will definitely occur given sufficient protocol growth
- Can be accelerated by malicious actors
- No protective mechanisms exist to prevent reaching the overflow threshold

## Recommendation

Change the local variable type from `int` to `long` by using the `L` suffix on the integer literal:

Replace line 96 with: `var protocolNumber = 1L;`
Replace line 108 with: `var protocolNumber = 1L;`

Alternatively, explicitly declare the type: `long protocolNumber = 1;`

This ensures the calculation uses 64-bit arithmetic, which can safely handle values up to 10^18 (far exceeding the maximum needed).

## Proof of Concept

```csharp
[Fact]
public async Task TestIntegerOverflowDoS()
{
    // Setup: Manually set CurrentSymbolNumberLength to 11 to trigger overflow
    // In production, this would occur after ~9 billion protocols created
    
    // This will cause OverflowException in GetCurrentNumberLength()
    // when it tries to calculate 10^10 using int arithmetic
    var exception = await Assert.ThrowsAsync<OverflowException>(async () =>
    {
        await NFTContractStub.Create.SendAsync(new CreateInput
        {
            BaseUri = "ipfs://test/",
            Creator = DefaultAddress,
            IsBurnable = true,
            NftType = NFTType.Art.ToString(),
            ProtocolName = "TEST",
            TotalSupply = 1000
        });
    });
    
    // Verify that Create() is permanently broken
    exception.ShouldNotBeNull();
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L96-97)
```csharp
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L108-109)
```csharp
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-19)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L8-9)
```csharp
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```
