# Audit Report

## Title
NextTerm Block Production Bypasses Tiny Block Limit Due to ActualMiningTimes/ProducedTinyBlocks Desynchronization

## Summary
The `GetConsensusExtraDataForNextTerm` function sets `ProducedTinyBlocks` to 1 but fails to add an entry to `ActualMiningTimes`, creating a state desynchronization. This allows miners producing NextTerm blocks to bypass the 8-block maximum limit and produce 9 total blocks in their time slot, violating the fork prevention mechanism.

## Finding Description

When a miner produces a NextTerm block (transitioning to a new term), the consensus contract creates inconsistent state where `ProducedTinyBlocks` is incremented but `ActualMiningTimes` remains empty.

**Root Cause:**

In `GetConsensusExtraDataForNextTerm`, only `ProducedTinyBlocks` is set to 1 without updating `ActualMiningTimes`: [1](#0-0) 

This contrasts with `GetConsensusExtraDataForNextRound`, which correctly updates both fields: [2](#0-1) 

Similarly, `GetConsensusExtraDataForTinyBlock` and `GetConsensusExtraDataToPublishOutValue` both synchronize these fields: [3](#0-2) [4](#0-3) 

**Why Protections Fail:**

The block production limit enforcement uses `ActualMiningTimes.Count`, not `ProducedTinyBlocks`: [5](#0-4) 

The calculation in `IsLastTinyBlockOfCurrentSlot` uses `ActualMiningTimes.Count` to determine `blocksBeforeCurrentRound`: [6](#0-5) 

After NextTerm processing, the stored round has `ProducedTinyBlocks = 1` but `ActualMiningTimes = []` (empty). The `UpdateProducedBlocksNumberOfSender` method called during `ProcessNextTerm` only updates `ProducedBlocks`, not `ActualMiningTimes`: [7](#0-6) [8](#0-7) 

**Execution Path:**

1. Miner produces NextTerm block → `ProducedTinyBlocks = 1`, `ActualMiningTimes = []`
2. For subsequent tiny blocks, `GetConsensusBehaviour` checks `ActualMiningTimes.Count < 8` (0 < 8 → true)
3. Each tiny block increments both counters via `ProcessTinyBlock`: [9](#0-8) 
4. Miner can produce 8 additional tiny blocks before `ActualMiningTimes.Count = 8`
5. Total: 1 NextTerm + 8 tiny blocks = 9 blocks, exceeding the 8-block limit

The limit is defined as: [10](#0-9) 

## Impact Explanation

**Consensus Integrity Violation**: Miners bypass the fork prevention mechanism that limits blocks to 8 per time slot. The 8-block limit exists explicitly to "avoid too many forks": [11](#0-10) 

**Increased Fork Risk**: Allowing 9 blocks instead of 8 (12.5% increase) directly contradicts the design principle that adjusts tiny block counts to reduce forks during abnormal blockchain status.

**Unfair Advantage**: Only miners producing NextTerm blocks can exceed the limit, creating an unfair advantage over other miners.

**Protocol Safety Degradation**: Undermines the carefully designed block production throttling mechanism that dynamically adjusts based on blockchain health.

**Who is Affected:**
- All network participants suffer from increased fork probability
- Miners not producing NextTerm blocks are disadvantaged  
- Consensus stability and finality are compromised

**Quantification:**
- 1 extra block per NextTerm (12.5% over the 8-block limit)
- Affects every term transition (periodic election cycles)
- Cumulative impact on network fork rate over time

## Likelihood Explanation

**Attacker Capabilities:**
- Requires only being a miner at term transition (no special privileges required)
- No additional authority beyond normal miner role
- Exploitation is automatic—occurs without deliberate malicious action

**Attack Complexity:**
- Low: The vulnerability triggers naturally during NextTerm block production
- No special transaction crafting required
- State desynchronization persists automatically once the NextTerm block is produced

**Feasibility:**
- Occurs at every term transition (periodic and predictable)
- No preconditions beyond being in the miner set during term change
- Publicly observable and verifiable by examining `ActualMiningTimes` vs `ProducedTinyBlocks`

**Detection Difficulty:**
- Hard to detect as it appears as normal block production
- The extra block is produced within normal consensus flow
- Only detectable through careful analysis comparing `ActualMiningTimes.Count` vs `ProducedTinyBlocks`

**Probability:** High - Executes automatically at every term transition for miners producing NextTerm blocks.

## Recommendation

Add an entry to `ActualMiningTimes` in `GetConsensusExtraDataForNextTerm` to maintain synchronization with `ProducedTinyBlocks`:

```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
    AElfConsensusTriggerInformation triggerInformation)
{
    var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
    Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
    if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        // ADD THIS LINE:
        firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
    }

    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = firstRoundOfNextTerm,
        Behaviour = triggerInformation.Behaviour
    };
}
```

This matches the pattern used in `GetConsensusExtraDataForNextRound`, `GetConsensusExtraDataForTinyBlock`, and `GetConsensusExtraDataToPublishOutValue`.

## Proof of Concept

The following test demonstrates the vulnerability by verifying that after a NextTerm block:
1. `ProducedTinyBlocks` equals 1
2. `ActualMiningTimes.Count` equals 0 (should be 1)
3. The miner can still produce 8 more tiny blocks (totaling 9)

```csharp
[Fact]
public async Task NextTerm_Bypasses_TinyBlock_Limit_Test()
{
    // Setup: Mine blocks to reach term transition
    await InitialAElfConsensusContract();
    var termNumber = await AEDPoSContractStub.GetCurrentTermNumber.CallAsync(new Empty());
    
    // Mine to next term
    await MineBlocksToNextTermAsync();
    var newTermNumber = await AEDPoSContractStub.GetCurrentTermNumber.CallAsync(new Empty());
    newTermNumber.Value.ShouldBe(termNumber.Value + 1);
    
    // Get the round information after NextTerm block
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerPubkey = InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex();
    var minerInfo = currentRound.RealTimeMinersInformation[minerPubkey];
    
    // VULNERABILITY: ProducedTinyBlocks is 1 but ActualMiningTimes is empty
    minerInfo.ProducedTinyBlocks.ShouldBe(1);
    minerInfo.ActualMiningTimes.Count.ShouldBe(0); // Should be 1!
    
    // The miner can now produce 8 more tiny blocks (total 9)
    var maximumBlocksCount = await AEDPoSContractStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maximumBlocksCount.Value.ShouldBe(8);
    
    // Verify the bypass: ActualMiningTimes.Count (0) < MaximumBlocksCount (8) allows more blocks
    (minerInfo.ActualMiningTimes.Count < maximumBlocksCount.Value).ShouldBeTrue();
    
    // This allows producing 8 additional tiny blocks for a total of 9 blocks
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L158-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L191-196)
```csharp
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L54-63)
```csharp
        private bool IsLastTinyBlockOfCurrentSlot()
        {
            var producedBlocksOfCurrentRound = MinerInRound.ProducedTinyBlocks;
            var roundStartTime = CurrentRound.GetRoundStartTime();

            if (CurrentBlockTime < roundStartTime) return producedBlocksOfCurrentRound == _maximumBlocksCount;

            var blocksBeforeCurrentRound = MinerInRound.ActualMiningTimes.Count(t => t < roundStartTime);
            return producedBlocksOfCurrentRound == blocksBeforeCurrentRound.Add(_maximumBlocksCount);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L20-35)
```csharp
    private void UpdateProducedBlocksNumberOfSender(Round input)
    {
        var senderPubkey = Context.RecoverPublicKey().ToHex();

        // Update produced block number of transaction sender.
        if (input.RealTimeMinersInformation.ContainsKey(senderPubkey))
            input.RealTimeMinersInformation[senderPubkey].ProducedBlocks =
                input.RealTimeMinersInformation[senderPubkey].ProducedBlocks.Add(1);
        else
            // If the sender isn't in miner list of next term.
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = senderPubkey,
                RecentlyProducedBlocks = 1
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-185)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-22)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
    private int GetMaximumBlocksCount()
```
