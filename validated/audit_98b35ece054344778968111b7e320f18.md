# Audit Report

## Title
Consensus Corruption via Unvalidated Round Fields in NextRound Transition

## Summary
The AEDPoS consensus contract allows malicious block producers to corrupt critical consensus state fields during NextRound transitions. The `NextRoundInput.Create()` and `ToRound()` methods lack input validation, and after-execution hash-based validation excludes six critical fields (`ConfirmedIrreversibleBlockHeight`, `ExtraBlockProducerOfPreviousRound`, `MainChainMinersRoundNumber`, `IsMinerListJustChanged`, `ConfirmedIrreversibleBlockRoundNumber`, `RoundIdForValidation`) from comparison, enabling miners to inject arbitrary values that persist in consensus state.

## Finding Description

**Root Cause:**

The `NextRoundInput.Create()` method directly copies all Round fields without validation [1](#0-0) , and `ToRound()` performs the inverse conversion with no validation [2](#0-1) .

**Validation Gap - Before Execution:**

For NextRound behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied [3](#0-2) . The `RoundTerminateValidationProvider.ValidationForNextRound()` validates only two fields: round number must increment by 1 and InValues must be null [4](#0-3) .

Critically, `LibInformationValidationProvider` does NOT run for NextRound behavior [5](#0-4) , leaving `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` unvalidated.

**Validation Gap - After Execution:**

The `ValidateConsensusAfterExecution()` method compares Round hashes [6](#0-5) . However, `GetCheckableRound()` only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation` (with specific exclusions), and `BlockchainAge` [7](#0-6) .

The protobuf definition confirms that Round contains the excluded fields [8](#0-7) , which are not included in the checkable round for hash comparison.

**Execution Path:**

When NextRound is called [9](#0-8) , it processes the input via `ProcessNextRound()` which calls `input.ToRound()` and adds the round to state via `AddRoundInformation()` [10](#0-9) .

## Impact Explanation

**1. LIB Manipulation & DoS:**
`ConfirmedIrreversibleBlockHeight` is used in `GetMaximumBlocksCount()` to evaluate blockchain mining status [11](#0-10) . Setting an artificially high value causes the evaluator to detect Severe status, reducing `MaximumBlocksCount` to 1 and firing `IrreversibleBlockHeightUnacceptable` events, effectively causing consensus-level DoS.

**2. Unauthorized Mining Privileges:**
`ExtraBlockProducerOfPreviousRound` determines which miner can produce tiny blocks at round start [12](#0-11)  and [13](#0-12) . A malicious miner can set this to their own pubkey, granting themselves unauthorized extra block production rights beyond their allocated time slot.

**3. Secret Sharing Disruption:**
`IsMinerListJustChanged` controls whether secret sharing occurs when adding round information [14](#0-13) . Incorrect values prevent the `SecretSharingInformation` event from firing, breaking the random number generation mechanism that depends on secret sharing between miners.

**4. Cross-Chain Corruption:**
For side chains, `MainChainMinersRoundNumber` tracks main chain consensus synchronization. Manipulation corrupts cross-chain state validation and miner list updates.

**Severity:** HIGH - Direct consensus state corruption enabling DoS, unauthorized mining, broken randomness, and cross-chain integrity violations.

## Likelihood Explanation

**Attacker Capabilities:**
Any current block producer (miner) can execute this attack. Block producers control both block header construction and transaction inclusion, giving them complete authority over block content within protocol rules.

**Attack Execution:**
1. Miner generates legitimate consensus extra data with valid `RoundNumber` (current + 1) and null `InValues` for block header
2. Miner creates `NextRoundInput` transaction with same validated fields (RoundNumber, TermNumber, BlockchainAge, RealTimeMinersInformation) but manipulated excluded fields (e.g., setting `ExtraBlockProducerOfPreviousRound` to own pubkey, or `ConfirmedIrreversibleBlockHeight` to trigger Severe status)
3. Miner includes transaction in block with legitimate header extra data
4. Before-execution validation checks only header extra data for RoundNumber increment and null InValues - passes
5. Transaction executes via `ProcessNextRound()`, calling `input.ToRound()` which writes manipulated Round to state
6. After-execution validation compares `GetHash()` of header Round vs state Round - passes because excluded fields aren't in hash

**Feasibility:** HIGH
- No special permissions beyond being a current miner required
- Attack works within normal consensus protocol operation
- No cryptographic primitives need to be broken
- Undetectable by current validation logic until effects manifest in consensus behavior

**Detection/Prevention:** None currently exists. The validation gap allows the attack to succeed silently.

## Recommendation

**Immediate Fixes:**

1. **Add validation to `NextRoundInput.Create()` and `ToRound()`:**
   - Validate `ConfirmedIrreversibleBlockHeight` never decreases and stays within reasonable bounds relative to current height
   - Validate `ExtraBlockProducerOfPreviousRound` matches the actual extra block producer from previous round state
   - Validate `MainChainMinersRoundNumber` for side chains
   - Validate `IsMinerListJustChanged` matches actual miner list comparison

2. **Include all consensus-critical fields in `GetCheckableRound()`:**
   Modify the method to include:
   - `MainChainMinersRoundNumber`
   - `ExtraBlockProducerOfPreviousRound`
   - `ConfirmedIrreversibleBlockHeight`
   - `ConfirmedIrreversibleBlockRoundNumber`
   - `IsMinerListJustChanged`
   - `RoundIdForValidation`

3. **Add `LibInformationValidationProvider` to NextRound validation:**
   Include LIB validation for NextRound behavior to prevent LIB manipulation [15](#0-14) .

## Proof of Concept

A malicious miner (already in the miner list) can execute the following attack:

**Test Function:**
```csharp
[Fact]
public async Task NextRound_MaliciousFieldManipulation_CorruptsConsensusState()
{
    // 1. Setup: Current miner in round N
    var currentRound = await GetCurrentRoundAsync();
    var maliciousMiner = currentRound.RealTimeMinersInformation.Keys.First();
    
    // 2. Generate legitimate next round structure
    var legitimateNextRound = GenerateNextRoundInformation(currentRound);
    legitimateNextRound.ExtraBlockProducerOfPreviousRound = GetActualExtraBlockProducer(currentRound);
    legitimateNextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
    
    // 3. Create block header with legitimate data
    var headerExtraData = CreateHeaderExtraData(legitimateNextRound);
    
    // 4. Create malicious transaction with manipulated excluded fields
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = legitimateNextRound.RoundNumber, // Same (validated)
        TermNumber = legitimateNextRound.TermNumber,   // Same (validated)
        BlockchainAge = legitimateNextRound.BlockchainAge, // Same (validated)
        RealTimeMinersInformation = legitimateNextRound.RealTimeMinersInformation, // Same (validated)
        
        // Manipulated excluded fields:
        ExtraBlockProducerOfPreviousRound = maliciousMiner, // Grant self extra mining rights
        ConfirmedIrreversibleBlockHeight = 999999, // Trigger Severe status DoS
        IsMinerListJustChanged = true, // Break secret sharing
        MainChainMinersRoundNumber = 0 // Corrupt cross-chain sync
    };
    
    // 5. Execute NextRound with malicious input
    await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // 6. Verify: Malicious fields persisted in state
    var corruptedRound = await GetCurrentRoundAsync();
    corruptedRound.ExtraBlockProducerOfPreviousRound.ShouldBe(maliciousMiner); // Unauthorized!
    corruptedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(999999); // DoS trigger!
    
    // 7. Verify: GetMaximumBlocksCount now returns 1 (DoS achieved)
    var maxBlocks = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocks.Value.ShouldBe(1); // Severe status - chain paralyzed
    
    // Attack succeeded: Consensus state corrupted through validation bypass
}
```

The test demonstrates that a malicious miner can inject arbitrary values into excluded fields, bypassing both before-execution and after-execution validation, resulting in persisted consensus state corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L1-34)
```csharp
using AElf.Standards.ACS4;

// ReSharper disable once CheckNamespace
namespace AElf.Contracts.Consensus.AEDPoS;

public class LibInformationValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
