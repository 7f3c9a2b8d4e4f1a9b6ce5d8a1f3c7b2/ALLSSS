# Audit Report

## Title
Infinite Loop in NFT Symbol Generation Causes Guaranteed Transaction Failure on Collision

## Summary
The `GenerateSymbolNumber()` function in the NFT contract contains a critical infinite loop vulnerability where `randomHash` is computed once before a do-while loop but never updated within the loop. Since `Context.ConvertHashToInt64()` is deterministic, any collision with an existing entry causes an infinite loop that exhausts transaction gas, resulting in guaranteed transaction failure and user fund loss.

## Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` function where the collision detection loop will spin infinitely if a duplicate random number is generated. [1](#0-0) 

The root cause is that `randomHash` is computed once before the do-while loop by hashing the sender address and random bytes from the consensus contract. [2](#0-1) 

Inside the loop, this same unchanging `randomHash` is used to generate a random number via `Context.ConvertHashToInt64()`. [3](#0-2) 

The `Context.ConvertHashToInt64()` method is deterministic - it converts a hash to BigInteger and performs modulo operation, always returning the same value for the same inputs. [4](#0-3) 

This means the loop will **always generate the exact same `randomNumber`** on every iteration. If that number already exists in `State.IsCreatedMap`, the while condition will always evaluate to true, creating an infinite loop. [5](#0-4) 

The function is called during NFT protocol creation from the public `Create()` method [6](#0-5)  which invokes `GetSymbol()` [7](#0-6) 

No existing protections prevent this issue - there is no rehashing mechanism, no fallback strategy, and no iteration limit on the loop.

## Impact Explanation

**Critical DoS of NFT Creation Service:**

1. **Immediate Transaction Failure**: When a collision occurs, the user's transaction enters an infinite loop, exhausts its gas limit, and fails completely. The user loses the transaction fee but receives no NFT protocol.

2. **Increasing Probability**: The protocol starts with 9-digit numbers [8](#0-7) , providing 900 million possible values (10^8 to 10^9). As `State.IsCreatedMap` fills with created protocols, collision probability increases proportionally:
   - At 1% saturation: ~1% failure rate
   - At 10% saturation: ~10% failure rate  
   - At 50% saturation: ~50% failure rate

3. **No Recovery Mechanism**: Once a collision occurs, there is no retry mechanism within the transaction. Users must submit entirely new transactions, paying gas fees each time until they get lucky with non-colliding randomness.

4. **Permanent State Pollution**: Each created protocol permanently occupies a slot in `State.IsCreatedMap`, making the problem progressively worse over time with no remediation path.

## Likelihood Explanation

**High Likelihood - Inevitable and Weaponizable:**

1. **Public Access**: Any user can call the `Create()` method to create NFT protocols - no special privileges required beyond mainchain execution.

2. **Low Attack Complexity**: An attacker can systematically fill the namespace by calling `Create()` repeatedly. Each successful creation permanently increases collision probability for all future users.

3. **Economic Feasibility**: While creating millions of protocols requires transaction fees, an attacker could:
   - Target 10-20% saturation to create significant disruption
   - Amortize cost over time as all future users face increased failure rates
   - Create persistent impact since protocols cannot be removed

4. **Natural Occurrence**: Even without malicious intent, the collision probability increases organically as the protocol grows, making this a time-bomb vulnerability that will eventually impact legitimate users.

5. **No Detection/Prevention**: The contract lacks rate limits, namespace exhaustion monitoring, or collision handling mechanisms.

## Recommendation

Fix the infinite loop by regenerating `randomHash` on each iteration or implementing a collision counter with fallback:

**Option 1: Regenerate hash on collision**
```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    do
    {
        // Regenerate randomHash on each iteration
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(Context.TransactionId) // Add uniqueness
        );
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Option 2: Implement iteration limit with increment fallback**
```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
    {
        Value = Context.CurrentHeight.Sub(1)
    }.ToBytesValue());
    var randomHash = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(Context.Sender),
        HashHelper.ComputeFrom(randomBytes)
    );
    
    long randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    var attempts = 0;
    var maxAttempts = 100;
    
    while (State.IsCreatedMap[randomNumber] && attempts < maxAttempts)
    {
        // Linear probing on collision
        randomNumber = randomNumber.Add(1);
        if (randomNumber >= from.Mul(10)) randomNumber = from;
        attempts++;
    }
    
    Assert(!State.IsCreatedMap[randomNumber], "Symbol generation failed - namespace exhausted");
    return randomNumber;
}
```

## Proof of Concept

The vulnerability can be demonstrated by pre-populating `IsCreatedMap` with a specific number, then calling `Create()` with parameters that will generate that same number. The transaction will hang in the infinite loop until gas exhaustion:

```csharp
[Fact]
public async Task InfiniteLoop_On_Collision_Test()
{
    // Setup: Pre-populate IsCreatedMap with a collision value
    var targetNumber = 123456789L;
    await NFTContractStub.SetIsCreatedMapForTesting.SendAsync(new Int64Value { Value = targetNumber });
    
    // Attempt to create NFT protocol
    // This will call GenerateSymbolNumber() which will hit the collision
    // Transaction should fail with gas exhaustion
    var result = await NFTContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "Test Protocol",
        TotalSupply = 10000,
        BaseUri = "https://test.com/",
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    });
    
    // Expected: Transaction fails due to gas exhaustion from infinite loop
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Insufficient transaction fee");
}
```

**Notes:**
- This vulnerability affects the core NFT protocol creation functionality
- The issue is mathematically guaranteed to occur as the namespace fills
- Current implementation provides no escape mechanism once a collision is detected
- Fix requires either rehashing on collision or implementing a deterministic fallback strategy

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L173-177)
```csharp
        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L10-10)
```csharp
    public MappedState<long, bool> IsCreatedMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
