# Audit Report

## Title
Consensus Behavior Validation Bypass Allows Indefinite Term Change Prevention

## Summary
The AEDPoS consensus validation system validates that block data is internally consistent with the claimed behavior (NextRound vs NextTerm) but never independently verifies that the claimed behavior matches what consensus rules require. A malicious miner can produce NextRound blocks when NextTerm is mandated by consensus rules, indefinitely preventing term transitions and freezing governance.

## Finding Description

The vulnerability exists in the validation flow between behavior determination and validation:

**Behavior Determination for Honest Nodes:** [1](#0-0) 

This method determines whether to return `NextRound` or `NextTerm` by calling `NeedToChangeTerm()`. When `NeedToChangeTerm()` returns true (meaning 2/3 of miners have reached the term threshold), it returns `NextTerm` behavior (unless it's round 1 or single node). [2](#0-1) 

The `NeedToChangeTerm()` method checks if at least 2/3 of miners have mining times indicating the term period has elapsed.

**Critical Validation Gap:** [3](#0-2) 

The validation reads the behavior from `extraData.Behaviour` (the CLAIMED behavior in the block header) and adds validators based on that claim, not based on what the behavior SHOULD be according to consensus rules. [4](#0-3) 

The `RoundTerminateValidationProvider` validates consistency with the claimed behavior but never calls `NeedToChangeTerm()` to verify the behavior choice was correct. It only checks that round numbers increment properly and InValues are null.

**Execution Without Correctness Check:** [5](#0-4) 

The `ProcessConsensusInformation` method dispatches to either `ProcessNextRound` or `ProcessNextTerm` based on the input type without validating that the chosen behavior matches consensus requirements. [6](#0-5) 

The `NextRound` method is public and callable by any miner in the miner list.

**No Kernel-Level Protection:** [7](#0-6) 

The kernel-level validation simply extracts consensus extra data and calls the contract's validation method. No additional behavior correctness checks exist at this level.

**Impact When Term Change Bypassed:** [8](#0-7) 

The `ProcessNextTerm` method handles critical operations that are skipped when a malicious miner calls `NextRound` instead:
- Term number update (line 173)
- Miner list update (lines 187-190) 
- Election snapshot (lines 213-218)
- Treasury release (lines 205-211)

## Impact Explanation

**HIGH - Consensus Integrity Violation:**

This vulnerability fundamentally breaks the AEDPoS democratic consensus mechanism:

1. **Election Results Never Applied**: New miners elected through governance cannot join the consensus, as the miner list update only occurs in `ProcessNextTerm`
2. **Governance Capture**: Current miners can maintain control indefinitely by preventing term changes, making the election system ineffective
3. **Reward Distribution Halted**: Mining rewards and treasury releases tied to term boundaries don't occur
4. **Historical Record Incomplete**: Election snapshots that preserve voting records are not taken
5. **Protocol Invariant Broken**: The consensus rule that terms MUST change when `NeedToChangeTerm()` returns true is violated

This affects all network participants and compromises the entire governance and reward distribution system.

## Likelihood Explanation

**HIGH Likelihood:**

**Reachable Attack Path:**
- The `NextRound` method is public and callable by any current miner
- Only requires `PreCheck()` validation which merely confirms sender is in miner list [9](#0-8) 

**Feasible Execution:**
- Attacker modifies their node software to always generate `NextRound` blocks instead of `NextTerm` when term change is required
- No complex cryptographic operations required
- No special permissions beyond being a current miner

**Economic Rationality:**
- Incumbent miners benefit significantly from preventing replacement
- Attack cost is negligible (just modify block generation behavior)
- Continued mining revenue provides strong economic incentive

**No Detection Mechanism:**
- Validation only checks data consistency with claimed behavior
- No monitoring exists to detect behavior choice mismatches

## Recommendation

Add behavior correctness validation to ensure claimed behavior matches consensus requirements:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    // ... existing code ...
    
    // Add behavior correctness check
    if (extraData.Behaviour == AElfConsensusBehaviour.NextRound || 
        extraData.Behaviour == AElfConsensusBehaviour.NextTerm)
    {
        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var shouldChangeTerm = baseRound.NeedToChangeTerm(
            blockchainStartTimestamp, 
            State.CurrentTermNumber.Value, 
            State.PeriodSeconds.Value);
        
        var expectedBehaviour = (baseRound.RoundNumber == 1 || 
                                baseRound.RealTimeMinersInformation.Keys.Count == 1)
            ? AElfConsensusBehaviour.NextRound
            : (shouldChangeTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound);
        
        if (extraData.Behaviour != expectedBehaviour)
            return new ValidationResult 
            { 
                Success = false, 
                Message = $"Incorrect behavior: claimed {extraData.Behaviour}, expected {expectedBehaviour}" 
            };
    }
    
    // ... rest of existing validation ...
}
```

This ensures the validator independently verifies that the behavior choice matches consensus rules, preventing miners from claiming incorrect behaviors.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanBypassTermChange_ByClaimingNextRound()
{
    // Setup: Advance blockchain to point where NeedToChangeTerm() would return true
    // (2/3 of miners have reached term threshold based on elapsed time)
    
    // Get current round where term change should occur
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var blockchainStartTime = await ConsensusStub.GetBlockchainStartTimestamp.CallAsync(new Empty());
    var periodSeconds = /* term period */;
    
    // Verify NeedToChangeTerm would return true
    Assert.True(currentRound.NeedToChangeTerm(blockchainStartTime, currentRound.TermNumber, periodSeconds));
    
    // Malicious miner calls NextRound instead of NextTerm
    var nextRoundInput = NextRoundInput.Create(/* generate next round data */);
    
    // This should fail but doesn't - validation accepts it
    var result = await MaliciousMinerConsensusStub.NextRound.SendAsync(nextRoundInput);
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Verify term did NOT change (vulnerability confirmed)
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(currentRound.TermNumber, newRound.TermNumber); // Term unchanged!
    Assert.Equal(currentRound.RoundNumber + 1, newRound.RoundNumber); // Round incremented
    
    // Verify miner list was NOT updated (election results not applied)
    var oldMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    var newMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    Assert.Equal(oldMinerList, newMinerList); // Miner list frozen!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-53)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```
