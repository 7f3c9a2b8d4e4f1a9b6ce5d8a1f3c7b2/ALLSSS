# Audit Report

## Title
Consensus Threshold Manipulation via Strategic Mining Abstention Blocks Term Changes

## Summary
A critical vulnerability in the `NeedToChangeTerm()` consensus mechanism allows colluding miners (1/3 + 1 minority) to block term changes by abstaining from block production. The function calculates the consensus threshold based on total miner count but only counts miners who have produced blocks in the current round, creating an exploitable mismatch that prevents election winners from taking positions and delays critical reward distribution for up to 3 days.

## Finding Description

The vulnerability exists in the term change consensus logic where threshold calculation and active miner counting use different bases, creating a Byzantine fault tolerance bypass.

**Root Cause Analysis:**

The `NeedToChangeTerm()` method filters miners to only those with `ActualMiningTimes` entries before checking consensus threshold: [1](#0-0) 

However, `MinersCountOfConsent` is calculated using the **total** miner count: [2](#0-1) 

**Attack Mechanism:**

When a new round is generated, `ActualMiningTimes` is reset (new `MinerInRound` objects created without copying this field): [3](#0-2) 

Miners populate `ActualMiningTimes` only through `UpdateValue`: [4](#0-3) 

Or through `TinyBlock`: [5](#0-4) 

The consensus behavior provider uses `NeedToChangeTerm()` to decide between `NextRound` and `NextTerm`: [6](#0-5) 

**Why Existing Protections Fail:**

Evil miner detection has a 3-day tolerance window (4,320 time slots): [7](#0-6) 

This gives attackers sufficient time to block term changes before punishment. Mid-term miner replacement does not force term changes—it only replaces evil miners with backups within the same term: [8](#0-7) 

## Impact Explanation

**Election Integrity Violation:**

Term changes trigger `GetVictories()` to update the miner list from election results: [9](#0-8) 

Blocking term changes prevents elected miners from taking their rightful positions, violating the democratic election mechanism.

**Reward Distribution Disruption:**

Mining rewards are donated to Treasury and released only during `NextTerm`: [10](#0-9) 

Treasury release to beneficiaries is blocked: [11](#0-10) 

**Governance Data Integrity:**

Election snapshots critical for governance are not taken: [12](#0-11) 

**Quantified Impact:**
- Configuration: 21 miners → threshold = 15
- Attack scenario: 8 miners abstain → 13 active miners < 15 threshold
- Duration: Up to 3 days (4,320 consecutive missed slots)
- Affected parties: Election winners, token holders expecting rewards, governance participants

## Likelihood Explanation

**Attack Prerequisites:**
- Requires 1/3 + 1 miners to collude (8 out of 21 in standard configuration)
- Attackers must be current miners with mining rights
- No special permissions beyond scheduled mining slots

**Execution Complexity:**
- **Trivial execution**: Miners simply abstain from calling `UpdateValue` or `TinyBlock`
- **Detection**: Visible through `MissedTimeSlots` increment but tolerated for 3 days
- **Coordination**: Requires pre-agreement among minority coalition

**Economic Incentive:**
When miners face election loss, they have strong financial motivation to delay term changes. Mining rewards continue accruing during the 3-day window, making the attack economically rational for miners facing replacement.

**Probability Assessment: MEDIUM-HIGH**
- Minority collusion (1/3 + 1) is feasible in adversarial scenarios
- Direct economic benefit for attackers
- No immediate punishment mechanism
- 3-day tolerance provides substantial attack window

## Recommendation

Implement one of the following mitigations:

**Option 1: Use Consistent Miner Count**
Modify `NeedToChangeTerm()` to calculate threshold based on active miners:
```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var activeMiners = RealTimeMinersInformation.Values.Where(m => m.ActualMiningTimes.Any()).ToList();
    var activeMinersCount = activeMiners.Count;
    var minersCountOfConsent = activeMinersCount.Mul(2).Div(3).Add(1);
    
    return activeMiners
               .Select(m => m.ActualMiningTimes.Last())
               .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds))
           >= minersCountOfConsent;
}
```

**Option 2: Force Term Change on Threshold Failure**
If insufficient active miners exist to make consensus decisions, automatically trigger term change after a grace period (e.g., 1 hour) to prevent indefinite blocking.

**Option 3: Reduce Evil Miner Tolerance**
Reduce `TolerableMissedTimeSlotsCount` from 3 days to a shorter period (e.g., 6 hours) to limit attack window.

## Proof of Concept

```csharp
[Fact]
public async Task TermChange_BlockedBy_MinorityAbstention()
{
    // Setup: 21 miners in current term
    const int totalMiners = 21;
    const int colludingMiners = 8; // 1/3 + 1
    
    // Initialize consensus with 21 miners
    await InitializeConsensusAsync(totalMiners);
    
    // Start new round - ActualMiningTimes reset for all miners
    await ProduceBlockAndStartNewRoundAsync();
    
    // Simulate: Only 13 miners produce blocks (8 abstain)
    for (int i = 0; i < totalMiners - colludingMiners; i++)
    {
        await ProduceBlockAsync(GetMinerKeyPair(i));
    }
    
    // Verify: MinersCountOfConsent = 21 * 2 / 3 + 1 = 15
    var currentRound = await GetCurrentRoundAsync();
    currentRound.MinersCountOfConsent.ShouldBe(15);
    
    // Verify: Only 13 miners have ActualMiningTimes
    var activeMiners = currentRound.RealTimeMinersInformation.Values
        .Count(m => m.ActualMiningTimes.Any());
    activeMiners.ShouldBe(13);
    
    // Verify: NeedToChangeTerm returns false (13 < 15)
    var needsTermChange = currentRound.NeedToChangeTerm(
        await GetBlockchainStartTimestampAsync(),
        currentRound.TermNumber,
        await GetPeriodSecondsAsync()
    );
    needsTermChange.ShouldBeFalse();
    
    // Verify: Consensus behavior is NextRound, not NextTerm
    var consensusBehavior = await GetConsensusBehaviorAsync();
    consensusBehavior.ShouldBe(AElfConsensusBehaviour.NextRound);
    
    // Verify: Election winners cannot take positions
    var electionWinners = await GetElectionVictoriesAsync();
    var currentMiners = await GetCurrentMinerListAsync();
    electionWinners.ShouldNotBe(currentMiners); // Winners != Current miners
    
    // Attack continues for up to 3 days (4320 time slots)
    // before evil miner detection triggers
}
```

**Notes:**
This vulnerability represents a fundamental flaw in the Byzantine fault tolerance assumption. By using total miners for threshold calculation but only counting active miners, the protocol inadvertently allows a minority coalition to veto term changes through passive non-participation rather than active malicious behavior.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-330)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
