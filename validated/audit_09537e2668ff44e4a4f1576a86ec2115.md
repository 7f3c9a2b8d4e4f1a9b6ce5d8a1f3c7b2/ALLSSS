# Audit Report

## Title
Incorrect Accounting Assertion in Recharge() Causes Denial of Service for Valid Side Chain Recharges

## Summary
The `Recharge()` function contains a critical accounting error in its balance validation assertion. The assertion incorrectly adds `input.Amount` to a balance that already includes `input.Amount`, effectively requiring approximately double the mathematically correct amount. This causes legitimate recharge transactions to be wrongly rejected, preventing side chains in debt status from being reactivated.

## Finding Description

The vulnerability exists in the `Recharge()` method where the balance validation logic is flawed. [1](#0-0) 

**Execution Flow:**

1. The function first transfers the recharge amount to the side chain's virtual address [2](#0-1) 

2. If the side chain is in debt, it loops through arrears and transfers them to proposers [3](#0-2) 

3. After arrears are paid, it retrieves the current balance using `GetSideChainIndexingFeeDeposit()` [4](#0-3) 

4. It then performs an assertion check [5](#0-4) 

**The Bug:**

The `GetSideChainIndexingFeeDeposit()` method retrieves the current token balance of the virtual address [6](#0-5) , which at line 206 is AFTER the recharge and AFTER arrears payments. Therefore:

`originBalance = old_balance + input.Amount - arrearsAmount`

The assertion then checks: `input.Amount + originBalance >= arrearsAmount + IndexingPrice`

Substituting the actual value of `originBalance`: `input.Amount + (old_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice` which simplifies to `old_balance + 2*input.Amount >= 2*arrearsAmount + IndexingPrice`

This incorrectly requires approximately double the necessary funds because `input.Amount` is counted twice.

**Correct Logic:**

The assertion should verify that after paying arrears, at least `IndexingPrice` remains: `old_balance + input.Amount >= arrearsAmount + IndexingPrice`

Or simply: `originBalance >= IndexingPrice` (since `originBalance` already accounts for recharge minus arrears)

## Impact Explanation

**High Severity - Denial of Service:**

This bug blocks the critical recovery mechanism for side chains in debt. When a side chain falls into `IndexingFeeDebt` status, operators attempting to recharge with the mathematically correct minimum amount will be incorrectly rejected.

**Concrete Example:**
- Existing balance: 75 tokens
- Arrears owed: 100 tokens  
- Required minimum balance: 50 tokens
- User provides: 75 tokens (exactly sufficient)

**Expected:** 75 + 75 - 100 = 50 ≥ 50 ✓ (Should succeed)
**Actual:** 75 + 50 ≥ 100 + 50 → 125 ≥ 150 ✗ (Fails)

**Affected Parties:**
- Side chain creators unable to clear accumulated debt
- Side chain operators unable to maintain service continuity
- Users of side chains stuck in non-operational debt status

The vulnerability completely blocks debt recovery unless users overpay by approximately double the required amount, causing unnecessary capital inefficiency and potential permanent side chain unavailability.

## Likelihood Explanation

**High Likelihood:**

The bug manifests in normal operational scenarios without requiring any adversarial action:

1. **Reachable Entry Point:** The `Recharge()` function is publicly accessible to any user [7](#0-6) 

2. **Common Preconditions:**
   - Side chain naturally enters `IndexingFeeDebt` status when indexing fees deplete the balance
   - Side chain has accumulated arrears to proposers
   - Side chain has non-zero existing balance
   - User has approved token allowance

3. **Economic Incentive:** Users naturally attempt to recharge with minimum required amounts to minimize capital lockup, directly triggering this bug.

4. **No Special Attack Required:** This is a logic error affecting legitimate operations, not an exploit requiring special knowledge or privileges.

## Recommendation

Fix the assertion logic to correctly validate the recharge amount. The assertion should either:

**Option 1:** Check that originBalance (which already includes the recharge and excludes arrears) is sufficient:
```csharp
Assert(originBalance >= sideChainInfo.IndexingPrice, "Indexing fee recharging not enough.");
```

**Option 2:** Retrieve the balance BEFORE the recharge and validate the total will be sufficient:
```csharp
var balanceBeforeRecharge = GetSideChainIndexingFeeDeposit(chainId);
Assert(balanceBeforeRecharge + input.Amount >= arrearsAmount + sideChainInfo.IndexingPrice, "Indexing fee recharging not enough.");
```

Option 1 is cleaner since `originBalance` at line 206 already represents the post-recharge, post-arrears balance.

## Proof of Concept

```csharp
[Fact]
public async Task RechargeForSideChain_IndexingFeeDebt_MinimumAmount_ShouldFail()
{
    var parentChainId = 123;
    long existingBalance = 75;
    long arrearsAmount = 100; 
    long indexingPrice = 50;
    long parentChainHeightOfCreation = 10;

    // Create side chain with initial balance of 75 tokens
    var sideChainId = await InitAndCreateSideChainAsync(parentChainHeightOfCreation, parentChainId, existingBalance, indexingPrice);

    // Index blocks to create debt of 100 tokens (75 balance used, 25 more owed as arrears)
    var fakeSideChainBlockHash = HashHelper.ComputeFrom("sideChainBlockHash");
    var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("txMerkleTreeRoot");
    
    for (int i = 1; i <= 100; i++)
    {
        var sideChainBlockData = CreateSideChainBlockData(fakeSideChainBlockHash, i, sideChainId, fakeTxMerkleTreeRoot);
        var crossChainBlockData = new CrossChainBlockData { SideChainBlockDataList = { sideChainBlockData } };
        await DoIndexAsync(crossChainBlockData, new[] { sideChainId });
    }

    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);

    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(arrearsAmount);

    // User provides exactly 75 tokens (mathematically correct: 0 + 75 >= 25 + 50)
    await ApproveBalanceAsync(75);
    var rechargeInput = new RechargeInput
    {
        ChainId = sideChainId,
        Amount = 75
    };

    // This SHOULD succeed but WILL FAIL due to the bug
    // Bug: 75 + (0 + 75 - 25) >= 25 + 50 → 75 + 50 >= 75 → 125 >= 150 ✗
    var txResult = await CrossChainContractStub.Recharge.SendWithExceptionAsync(rechargeInput);
    txResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    txResult.TransactionResult.Error.ShouldContain("Indexing fee recharging not enough.");
}
```

**Notes:**

This vulnerability is a critical logic error in the cross-chain recharge mechanism that causes denial of service for legitimate debt recovery operations. The bug stems from double-counting the recharge amount in the validation assertion, requiring users to provide approximately double the mathematically necessary funds. This affects side chain availability and creates significant capital inefficiency for operators.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L170-176)
```csharp
    ///     Recharge for side chain.
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L177-215)
```csharp
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-97)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
```
