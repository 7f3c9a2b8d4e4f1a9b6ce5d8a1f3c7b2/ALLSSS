# Audit Report

## Title
Ineffective ImpliedIrreversibleBlockHeight Validation Enables Last Irreversible Block Stalling Attack

## Summary
The validation logic for `ImpliedIrreversibleBlockHeight` is rendered ineffective due to a critical order-of-operations flaw. The base round is modified with provided values before validation occurs, causing the validation check to always pass. This allows malicious miners controlling approximately 1/3 of the mining power to permanently stall Last Irreversible Block (LIB) advancement, breaking the blockchain's finality guarantee.

## Finding Description

The vulnerability exists in the validation flow where `RecoverFromUpdateValue` is called before the `LibInformationValidationProvider` performs its validation check. [1](#0-0) 

The `RecoverFromUpdateValue` method overwrites the base round's `ImpliedIrreversibleBlockHeight` with the value provided by the miner: [2](#0-1) 

Subsequently, the validation compares the now-modified base round against the provided round: [3](#0-2) 

Since both `baseRound` and `providedRound` now contain identical `ImpliedIrreversibleBlockHeight` values after recovery, the check always evaluates to false, allowing any value to bypass validation.

Honest miners set this value to the current block height: [4](#0-3) 

However, malicious miners can provide arbitrarily low values. During execution, this malicious value is stored directly in the state: [5](#0-4) 

The LIB calculation uses these stored values at position `(count-1)/3` from sorted implied heights: [6](#0-5) 

When approximately 1/3 of miners report low values, the calculated LIB becomes lower than the current confirmed LIB. A safeguard prevents LIB from decreasing: [7](#0-6) 

However, this same safeguard prevents LIB from advancing when `libHeight <= currentRound.ConfirmedIrreversibleBlockHeight`, causing permanent LIB stalling.

## Impact Explanation

**Critical Consensus Failure:**
- The LIB mechanism is fundamental to blockchain finality. When LIB stops advancing, no new blocks become irreversible, breaking the core security guarantee that transactions become final.
- Cross-chain operations depend on LIB for security verification. Stalled LIB renders all cross-chain transfers, merkle proof verification, and parent/side-chain synchronization inoperable.
- High-value transactions requiring settlement assurance cannot be confirmed, affecting exchanges, DeFi protocols, and enterprise applications.

**Systemic Operational Impact:**
- The attack causes a permanent denial-of-service on the finality mechanism while block production continues normally, making detection difficult initially.
- No automatic recovery mechanism exists; manual intervention would be required.
- Long-term stalling damages protocol trust and adoption fundamentally.

This represents a **CRITICAL** severity issue because it breaks a fundamental consensus invariant with cascading failures across all protocol layers requiring finality guarantees.

## Likelihood Explanation

**High Feasibility:**
- The attack requires control of approximately 1/3 of active miners, which is within the standard Byzantine fault tolerance threshold the system is designed to handle.
- Attack complexity is minimal: miners only need to modify their node to report a constant low value (e.g., 1) instead of `Context.CurrentHeight`.
- No special permissions beyond being an authorized miner are required.
- No economic disincentives or slashing mechanisms exist for reporting anomalous implied heights.

**Detection Challenges:**
- The attack is difficult to detect initially as block production continues normally.
- Only becomes apparent when finality-dependent operations start failing.
- No monitoring or detection mechanism identifies miners reporting anomalous values.

The **probability is HIGH** because the attack is trivial to implement, requires only standard BFT-threshold collusion (1/3 miners), and has no barriers to execution for motivated adversaries.

## Recommendation

**Immediate Fix:** Reorder the validation flow to perform validation BEFORE modifying the base round with provided values.

Modify `ValidateBeforeExecution` to:
1. Create validation context with unmodified base round
2. Run all validation providers (including LibInformationValidationProvider)
3. Only if validation passes, then call `RecoverFromUpdateValue`

**Additional Hardening:**
- Implement sanity checks on `ImpliedIrreversibleBlockHeight` values (e.g., must be within reasonable range of current height)
- Add monitoring to detect miners consistently reporting anomalous values
- Consider slashing or penalties for miners who report values that cause LIB calculation failures

## Proof of Concept

The vulnerability can be demonstrated by having a malicious miner submit an `UpdateValue` transaction with `ImpliedIrreversibleBlockHeight` set to 1 (or any value significantly lower than the current block height). 

The validation will pass because `RecoverFromUpdateValue` overwrites the base round's value before the comparison occurs. Once approximately 1/3 of miners (the threshold at position `(count-1)/3`) submit such low values, the LIB calculation in `LastIrreversibleBlockHeightCalculator` will produce a value lower than the current confirmed LIB, causing the update condition at line 272 of `AEDPoSContract_ProcessConsensusInformation.cs` to fail, permanently stalling LIB advancement.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-272)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
