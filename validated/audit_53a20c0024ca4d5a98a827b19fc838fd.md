# Audit Report

## Title
Contract Ownership Theft via Expired Proposal State Overwrite

## Summary
The Genesis contract's user contract deployment system contains a critical vulnerability that allows an attacker to steal ownership of legitimately approved contract deployments. By exploiting the expiration mechanism and lack of proposal-to-state validation, an attacker can overwrite proposal metadata after expiration but before release, causing the approved governance proposal to deploy the contract with the attacker as owner instead of the legitimate proposer.

## Finding Description

The vulnerability exists in the interaction between three functions in the user contract deployment workflow: `SendUserContractProposal`, `ReleaseApprovedUserSmartContract`, and `PerformDeployUserSmartContract`.

When a user deploys a contract via `DeployUserSmartContract`, the system creates a state entry in `ContractProposingInputMap` keyed by the input hash, storing the author and proposal metadata. [1](#0-0) 

The critical flaw exists in `SendUserContractProposal` where the expiration check permits complete state overwrite when time has passed, without verifying whether an approved governance proposal is pending execution. [2](#0-1) 

The attack sequence:

1. **Legitimate deployment initiated**: User A calls `DeployUserSmartContract` with specific contract code, creating state entry with `Author = UserA` and `ExpiredTime = CurrentTime + 900 seconds`. [3](#0-2) 

2. **Governance approval**: Miners approve the code check proposal through the governance organization.

3. **State corruption**: After the 900-second expiration passes but before the approved proposal is released, the attacker submits an identical `UserContractDeploymentInput` (same code, category, salt). This generates the same hash, and the expiration check at line 315 passes, allowing complete state overwrite including `Author = Attacker`.

4. **Proposal release with corrupted data**: When miners release the original approved proposal via `ReleaseApprovedUserSmartContract`, the function retrieves the now-corrupted state entry. [4](#0-3) 

The critical missing validation is evident in the release function: it checks that `contractProposingInput.Proposer == Context.Self` (line 483), but for user contracts, `Proposer` is ALWAYS set to `Context.Self` (line 318 of the Helper), making this check useless for distinguishing between different proposals. There is no verification that the state entry corresponds to the specific `ProposalId` being released, even though both values are provided in the `ReleaseContractInput`. [5](#0-4) 

5. **Malicious deployment**: The governance contract executes `PerformDeployUserSmartContract`, which retrieves the corrupted state and deploys the contract using `contractProposingInput.Author` from the attacker's overwritten data. [6](#0-5) 

The fundamental design flaw is that proposal state is keyed by input hash rather than proposal ID, and there is no mechanism to prevent overwrites when approved proposals are pending or to validate the linkage between proposal IDs and state entries during release.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables complete theft of contract ownership with full authorship privileges, violating the core governance guarantee that approved proposals execute with their original parameters.

**Direct Impacts:**

1. **Complete ownership takeover**: The attacker becomes the contract author, granting full control over author-restricted operations including contract updates via `UpdateUserSmartContract`. [7](#0-6) 

2. **Authorship transfer capability**: The attacker can transfer authorship to any address via `SetContractAuthor`, permanently cementing the theft. [8](#0-7) 

3. **Governance subversion**: An approved governance decision executes with materially different parameters than what was reviewed and approved by miners, breaking the integrity of the governance process.

4. **Legitimate proposer disenfranchisement**: Despite their proposal being legitimately approved through governance, the original proposer loses all authorship rights and cannot perform any author-restricted operations on their own contract.

The same vulnerability pattern also affects contract updates via `UpdateUserSmartContract`, as it uses the identical `SendUserContractProposal` mechanism. [9](#0-8) 

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Prerequisites:**

The attack requires minimal privileges. On main chains where the native symbol equals the primary token symbol, `AssertUserDeployContract` passes for all users. [10](#0-9) 

On side chains, users must be in the Parliament proposer whitelist, but whitelisted users can attack each other.

**Attack Complexity: LOW**

The attack requires only:
1. Monitoring `CodeCheckRequired` events to identify deployment proposals
2. Querying the expiration period via `GetCodeCheckProposalExpirationTimePeriod`
3. Waiting for expiration to pass
4. Submitting an identical input to overwrite the state
5. Waiting for the automated release

No need to compromise miners, manipulate governance votes, or exploit cryptographic primitives.

**Timing Window Feasibility:**

While an automated `CodeCheckProposalReleaseTransactionGenerator` exists to release approved proposals, the timing window remains realistic due to:

- Default expiration of only 900 seconds (15 minutes)
- Block production delays during network congestion
- Non-instantaneous transaction generator execution cycles
- Operational delays in miner infrastructure
- Possibility of deliberately short expiration configurations

The automated system generates release transactions but does not eliminate the race condition window. [11](#0-10) 

**Detection Difficulty:**

The attack produces minimal distinguishable on-chain evidence:
- The attacker's `DeployUserSmartContract` call appears as a legitimate re-proposal
- The `CodeCheckRequired` event fires normally
- The final `ContractDeployed` event shows the attacker as author without anomaly flags

## Recommendation

Implement proposal ID linkage to prevent state map overwrites when proposals are pending:

1. **Store proposal ID in state**: Modify `ContractProposingInput` to include the governance `ProposalId` when it's created, not just the input hash.

2. **Prevent overwrites for pending proposals**: In `SendUserContractProposal`, before allowing expiration-based overwrites, query the governance contract to verify no approved proposal is pending for this input hash.

3. **Validate proposal-state correspondence**: In `ReleaseApprovedUserSmartContract`, verify that the `ProposalId` being released matches the `ProposalId` stored in the state entry, ensuring the state corresponds to the specific proposal being executed.

4. **Consider proposal-keyed storage**: Alternatively, key `ContractProposingInputMap` by proposal ID rather than input hash, eliminating the possibility of collisions entirely.

## Proof of Concept

A complete proof of concept would require:

```csharp
[Fact]
public async Task ContractOwnershipTheft_ViaExpiredProposalOverwrite()
{
    // 1. UserA deploys contract with specific code
    var deployInput = new UserContractDeploymentInput { /* ... */ };
    await UserAStub.DeployUserSmartContract.SendAsync(deployInput);
    
    // 2. Miners approve the proposal (simulate governance approval)
    // await ApproveProposalAsMiners(proposalId);
    
    // 3. Advance time past expiration (900+ seconds)
    await AdvanceBlockTimeAsync(901);
    
    // 4. Attacker submits identical input
    await AttackerStub.DeployUserSmartContract.SendAsync(deployInput);
    
    // 5. Release the original approved proposal
    await MinerStub.ReleaseApprovedUserSmartContract.SendAsync(
        new ReleaseContractInput { ProposalId = originalProposalId, ... });
    
    // 6. Verify contract is deployed with Attacker as author, not UserA
    var contractInfo = await GenesisStub.GetContractInfo.CallAsync(deployedAddress);
    contractInfo.Author.ShouldBe(AttackerAddress); // VULNERABILITY: Should be UserA
}
```

The test demonstrates that despite UserA's proposal being legitimately approved, the contract deploys with the Attacker as author due to the state overwrite vulnerability.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-474)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
        Assert(info.Deployer == null || info.Deployer == Context.Sender, "No permission to update.");
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Assert(info.CodeHash != codeHash, "Code is not changed.");
        AssertContractNotExists(codeHash);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformUpdateUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = info.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L476-493)
```csharp
    public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");

        AssertCurrentMiner();

        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L495-505)
```csharp
    public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-323)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L6-6)
```csharp
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckProposalReleaseTransactionGenerator.cs (L36-81)
```csharp
    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight, Hash preBlockHash)
    {
        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash, BlockHeight = preBlockHeight
        };
        if (!_transactionPackingOptionProvider.IsTransactionPackable(chainContext)) return new List<Transaction>();

        var zeroContractAddress = _smartContractAddressService.GetZeroSmartContractAddress();

        if (zeroContractAddress == null) return new List<Transaction>();

        var releasableProposals =
            await _codeCheckProposalService.GetReleasableProposalListAsync(from, preBlockHash, preBlockHeight);
        if (releasableProposals == null || releasableProposals.Count == 0) return new List<Transaction>();

        var alreadyReleased = (await _codeCheckReleasedProposalIdProvider.GetProposalIdsAsync(new BlockIndex
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        })).ProposalIds.ToHashSet();

        var releaseRequired = releasableProposals.Where(o => !alreadyReleased.Contains(o.ProposalId)).ToList();

        var releaseContractTransactions = releaseRequired.Select(proposal => new Transaction
        {
            From = from,
            MethodName = nameof(ACS0Container.ACS0Stub.ReleaseApprovedUserSmartContract),
            To = zeroContractAddress,
            RefBlockNumber = preBlockHeight,
            RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
            Params = new ReleaseContractInput
            {
                ProposalId = proposal.ProposalId,
                ProposedContractInputHash = proposal.ProposedContractInputHash
            }.ToByteString()
        }).ToList();

        await _codeCheckReleasedProposalIdProvider.AddProposalIdsAsync(new BlockIndex
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        }, releaseRequired.Select(p => p.ProposalId).ToList());

        return releaseContractTransactions;
    }
```
