# Audit Report

## Title
Incorrect Threshold Validation in Secret Sharing Reconstruction Causes Consensus Corruption During Miner List Transitions

## Summary
The `RevealSharedInValues()` function in the AEDPoS consensus contract uses the current round's miner count to calculate the decoding threshold for Shamir's secret sharing, but the secrets were encoded using the previous round's miner count. When the miner list shrinks during term transitions, this threshold mismatch causes secret reconstruction to produce mathematically incorrect in-values, corrupting consensus state.

## Finding Description

The vulnerability exists in the `RevealSharedInValues()` function where threshold calculation and validation use the wrong round's miner count. [1](#0-0) 

The root cause is a three-part mismatch:

1. **Threshold Calculation**: The function calculates `minimumCount` (decoding threshold) from the current round's miner count, but secrets were encoded in the previous round using a threshold based on the previous round's miner count. [2](#0-1) 

2. **Validation Check**: The check compares `DecryptedPieces.Count` (from previous round) against current round's `minersCount` using less-than operator, which fails to detect threshold mismatches. [3](#0-2) 

3. **Decoding Operation**: The `DecodeSecret` call uses the incorrectly calculated `minimumCount` from the current round. [4](#0-3) 

**How Secret Sharing Works in AEDPoS:**

During the previous round, each miner encodes their InValue using Shamir's secret sharing with a threshold calculated from the previous round's miner count: [5](#0-4) 

The encoding creates a polynomial of degree `threshold - 1`, requiring at least `threshold` pieces to reconstruct: [6](#0-5) 

The decoding uses Lagrange interpolation with exactly `threshold` points: [7](#0-6) 

**Execution Path:**

This function is called during NextRound consensus behavior through the block production flow: [8](#0-7) 

**Attack Scenario:**

When the miner list shrinks during term transitions (e.g., from 10 to 7 miners):
- Previous round: 10 miners → encoding threshold = `10 * 2 / 3 = 6` pieces required
- Current round: 7 miners → decoding threshold = `7 * 2 / 3 = 4` pieces used
- DecryptedPieces.Count = 10 (from previous round)
- Check: `10 < 7`? False → proceeds with reconstruction
- Attempts to decode with 4 pieces a secret requiring 6 pieces → **produces incorrect result**

The integer division is performed by SafeMath extension methods: [9](#0-8) 

Term transitions regularly update the miner list based on election results: [10](#0-9) 

## Impact Explanation

**HIGH Severity** - This vulnerability corrupts core consensus data during normal protocol operations:

1. **Consensus Data Corruption**: The reconstructed `PreviousInValue` values will be mathematically incorrect. In Shamir's secret sharing, using fewer pieces than the encoding threshold cannot reconstruct the original secret - the result is a random incorrect value.

2. **Deterministic Network-Wide Failure**: All nodes execute the same deterministic (but incorrect) reconstruction logic, leading to network-wide consensus state corruption rather than detection through disagreement.

3. **Critical Consensus Components Affected**: Previous in-values are fundamental to:
   - Signature validation in the consensus mechanism
   - Random number generation for block production
   - Consensus integrity verification

4. **Regular Occurrence**: Term transitions happen regularly (typically every 7 days), and miner list fluctuations are expected protocol behavior driven by election dynamics.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability triggers automatically during normal protocol operations:

1. **No Attacker Required**: Term transitions with miner list changes occur naturally through the governance and election mechanisms. No malicious actor is needed.

2. **Common Conditions**: The conditions are standard protocol events:
   - Term transitions occur regularly (every ~7 days)
   - Miner list changes are expected based on election voting results
   - Miner list reductions are common due to election dynamics

3. **Direct Execution Path**: The vulnerable code path is directly reachable through standard consensus block production (NextRound behavior).

4. **No Privilege Required**: The vulnerability triggers during normal miner block production operations without requiring any special privileges.

## Recommendation

Fix the threshold calculation and validation to use the previous round's miner count consistently:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");

    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

    // FIX: Use previous round's miner count for threshold calculation
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;

    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        if (pair.Key == publicKey) continue;

        if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

        var publicKeyOfAnotherMiner = pair.Key;
        var anotherMinerInPreviousRound = pair.Value;

        if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
        // FIX: Validate against previous round's miner count for consistency
        if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

        var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                previousRound.RealTimeMinersInformation.Values
                    .First(m => m.Pubkey ==
                                anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
            .ToList();

        var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
            .Select(s => s.ToByteArray()).ToList();

        // Now threshold matches the encoding threshold
        var revealedInValue =
            HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

        currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
    }
}
```

## Proof of Concept

A test demonstrating the vulnerability would:

1. Initialize a round with 10 miners and encode secrets with threshold=6
2. Transition to a new round with 7 miners
3. Call `RevealSharedInValues()` with the new current round (7 miners)
4. Observe that it attempts to decode with threshold=4 instead of the correct threshold=6
5. Verify that the reconstructed in-values are incorrect by comparing with the original values

The test would need access to the consensus contract test framework and would verify that when `DecryptedPieces.Count >= currentMinersCount` but `DecryptedPieces.Count < previousMinersCount`, the reconstruction produces incorrect results rather than skipping or using the correct threshold.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L14-41)
```csharp
        public static List<byte[]> EncodeSecret(byte[] secretMessage, int threshold, int totalParts)
        {
            // Polynomial construction.
            var coefficients = new BigInteger[threshold];
            // Set p(0) = secret message.
            coefficients[0] = secretMessage.ToBigInteger();
            for (var i = 1; i < threshold; i++)
            {
                var foo = new byte[32];
                Array.Copy(HashHelper.ComputeFrom(Guid.NewGuid().ToByteArray()).ToArray(), foo, 32);
                coefficients[i] = BigInteger.Abs(new BigInteger(foo));
            }

            var result = new List<byte[]>();
            for (var i = 1; i < totalParts + 1; i++)
            {
                var secretBigInteger = coefficients[0];
                for (var j = 1; j < threshold; j++)
                {
                    secretBigInteger += coefficients[j] * BigInteger.Pow(new BigInteger(i), j);
                    secretBigInteger %= SecretSharingConsts.FieldPrime;
                }

                result.Add(secretBigInteger.ToByteArray());
            }

            return result;
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-24)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }

    public static int Div(this int a, int b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
