# Audit Report

## Title
Inconsistent Profit Detail Matching Logic Causes Welfare Misattribution in Multi-Vote Scenarios

## Summary
The Election contract's `ChangeVotingOption` function with `IsResetVotingTime=true` uses inconsistent profit detail matching logic when handling old-style profit details (where `Id` is null). The validation step uses `LastOrDefault` while the extension step uses `FirstOrDefault(OrderBy StartPeriod)`, causing the wrong profit detail to be extended when a voter has multiple votes with identical weight. [1](#0-0) [2](#0-1) 

## Finding Description

The Election contract maintains backwards compatibility for "old world" profit details where the `Id` field is null. When a voter calls `ChangeVotingOption` with `IsResetVotingTime=true`, the `ExtendVoterWelfareProfits` method performs two operations:

1. **Validation:** Calls `GetProfitDetailByElectionVotingRecord` which uses `LastOrDefault` to match profit details by shares when `Id` is null [3](#0-2) 

2. **Extension:** Calls `FixProfitDetail` which uses `FirstOrDefault(OrderBy StartPeriod)` to match profit details by shares when `ProfitDetailId` doesn't match [4](#0-3) 

**Execution Flow:**

When `ChangeVotingOption` is invoked with `IsResetVotingTime=true`: [5](#0-4) 

The `ExtendVoterWelfareProfits` method executes: [6](#0-5) 

**Why Protections Fail:**

The null check at line 141 only validates that SOME profit detail with matching shares exists, but doesn't ensure the SAME detail will be used by `FixProfitDetail`. The `ProfitDetailId` parameter passed as `voteId` fails to match old-style details (they have null `Id`), causing `FixProfitDetail` to fall back to shares-based matching with different ordering logic.

**Security Guarantee Broken:**

The invariant "when extending a vote's welfare profit period, the profit detail corresponding to that specific vote should be extended" is violated. For a voter with Vote A (StartPeriod=5) and Vote B (StartPeriod=10), both having identical shares, changing Vote B's option will validate Vote B exists but extend Vote A's EndPeriod instead.

## Impact Explanation

**Financial Harm:**
- The voter loses welfare profit claiming rights on the intended vote for multiple periods
- The voter gains unintended welfare profit entitlement on the wrong vote
- This represents misallocation of Treasury welfare funds, affecting the accuracy of the citizen welfare distribution scheme

**Affected Parties:**
- Any voter with multiple old-style profit details having identical weight (same token amount and lock duration)
- The welfare profit scheme experiences incorrect share distribution across periods

**Concrete Example:**
If Vote B should extend from period 24→32 (8 periods of welfare profit), but Vote A extends from period 22→32 (10 periods) instead:
- Vote B loses 8 periods of welfare profit claiming rights
- Vote A gains 10 periods it shouldn't have
- The voter's entitled welfare token distribution per period is misattributed

**Severity: Medium** - Direct financial impact on welfare distribution with concrete misallocation, but limited to the voter's own profit details (not theft from others) and requires specific preconditions.

## Likelihood Explanation

**Attacker Capabilities:**
Any voter can trigger this by calling the public `ChangeVotingOption` method. No special privileges required.

**Preconditions:**
1. Old-style profit details must exist (from pre-upgrade system where `ProfitDetailId` was not set)
2. Voter must have multiple active votes with identical weight (shares)
3. Voter calls `ChangeVotingOption` with `IsResetVotingTime=true`

**Feasibility:**
The code explicitly includes backwards compatibility for "the old world" / "old time", indicating old-style profit details were expected to exist in production following system upgrades. [7](#0-6) 

Multiple votes with same weight are realistic - a voter can stake the same amount for the same duration multiple times to different candidates.

**Detection:**
Test coverage creates multiple votes with identical parameters but uses new-style profit details (with `Id` set), not validating the old-style multi-vote scenario. [8](#0-7) 

**Probability: Medium** - If the system was upgraded and had existing votes, old-style details would exist. The bug is deterministic once preconditions are met.

## Recommendation

Ensure consistent matching logic by storing the profit detail returned from `GetProfitDetailByElectionVotingRecord` and verifying it matches the detail that `FixProfitDetail` will modify. 

**Option 1:** Pass the actual profit detail's identifying information (like StartPeriod) to `FixProfitDetail` to ensure the same detail is selected.

**Option 2:** Modify `GetProfitDetailByElectionVotingRecord` to use the same ordering as `FixProfitDetail`:
```csharp
if (profitDetail == null)
{
    profitDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
        .FirstOrDefault(d => d.Shares == electionVotingRecord.Weight);
}
```

**Option 3:** Add validation in `ExtendVoterWelfareProfits` to ensure the detail exists before and after the operation, comparing identifying fields.

## Proof of Concept

```csharp
[Fact]
public async Task OldStyleProfitDetail_MultipleVotes_WrongDetailExtended()
{
    // Setup: Create two old-style profit details with identical shares but different StartPeriods
    // This simulates pre-upgrade data where Id was null
    
    // Vote A: StartPeriod=5, EndPeriod=25, Shares=100 (representing 100 token weight)
    // Vote B: StartPeriod=10, EndPeriod=30, Shares=100 (same weight)
    
    // Both profit details have Id=null (old-style)
    // Stored in order: [Vote A, Vote B]
    
    // When: User calls ChangeVotingOption for Vote B with IsResetVotingTime=true
    
    // Expected: Vote B's profit detail (StartPeriod=10) should extend to EndPeriod=38
    // Actual: Vote A's profit detail (StartPeriod=5) gets extended instead
    
    // Reason: 
    // - GetProfitDetailByElectionVotingRecord uses LastOrDefault -> returns Vote B (validates correctly)
    // - FixProfitDetail uses OrderBy(StartPeriod).FirstOrDefault -> selects Vote A (extends wrong detail)
    
    // Result: Welfare profit misattribution between the voter's two votes
}
```

**Notes:**

This vulnerability exploits a subtle inconsistency in backwards compatibility code paths. The comments explicitly acknowledge the "old world" scenario, confirming this is production-relevant code handling legacy data post-upgrade. The issue only manifests when old-style profit details exist with identical shares, which is a realistic scenario for voters who made multiple votes with the same token amount and lock duration before the system upgrade that introduced profit detail IDs.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-38)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Election.Tests/Full/ChangeVotingOptionTests.cs (L12-89)
```csharp
    [Fact]
    public async Task ChangeVotingOptionTest()
    {
        foreach (var keyPair in CoreDataCenterKeyPairs)
        {
            await AnnounceElectionAsync(keyPair);
        }

        // Term 1
        // Voter 1 votes 3 times.
        for (var i = 0; i < 3; i++)
        {
            await VoteToCandidateAsync(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 20 * 86400,
                10);
        }

        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        // Term 2
        // Change voting option for first vote.
        {
            var electorVotes = await ElectionContractStub.GetElectorVote.CallAsync(new StringValue
            {
                Value = VoterKeyPairs[0].PublicKey.ToHex()
            });
            await ChangeVotingOption(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(),
                electorVotes.ActiveVotingRecordIds.First(), true);
        }
        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        // Term 4
        // Change voting option for second vote.
        {
            var electorVotes = await ElectionContractStub.GetElectorVote.CallAsync(new StringValue
            {
                Value = VoterKeyPairs[0].PublicKey.ToHex()
            });
            await ChangeVotingOption(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(),
                electorVotes.ActiveVotingRecordIds.Skip(1).First(), true);
        }
        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        // Term 6
        // Change voting option for last vote.
        {
            var electorVotes = await ElectionContractStub.GetElectorVote.CallAsync(new StringValue
            {
                Value = VoterKeyPairs[0].PublicKey.ToHex()
            });
            await ChangeVotingOption(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(),
                electorVotes.ActiveVotingRecordIds.Last(), true);
        }
        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        {
            var profitDetails =
                await GetCitizenWelfareProfitDetails(Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
            profitDetails.Details.Count.ShouldBe(3);
        }

        // Term 7
        for (var i = 0; i < 5; i++)
        {
            await ClaimProfitsAsync(VoterKeyPairs[0]);
            await ProduceBlocks(BootMinerKeyPair, 10);
            await NextTerm(BootMinerKeyPair);
        }
    }
```
