# Audit Report

## Title
Time-of-Check-Time-of-Use (TOCTOU) Race Condition Allows Multiple Proposals with Same Salt Leading to Governance Resource Waste

## Summary
The `DeployUserSmartContract` function validates salt availability at proposal creation but does not recheck at execution in `PerformDeployUserSmartContract`. This allows multiple proposals with the same salt to proceed through full governance approval, even though only the first to execute succeeds, wasting validator effort and transaction fees.

## Finding Description

The vulnerability exists across two functions in the Genesis contract deployment flow. At proposal creation time, `DeployUserSmartContract` checks if the salt-based contract address is available: [1](#0-0) 

The proposal hash is calculated from the entire `UserContractDeploymentInput` structure, which includes category, code, and salt fields: [2](#0-1) [3](#0-2) 

Since the hash includes all fields, proposals with the same salt but different code produce different proposal hashes and can both be registered. The `CalculateHashFromInput` helper computes the hash from the complete protobuf message: [4](#0-3) 

During execution, `PerformDeployUserSmartContract` retrieves the stored proposal data and passes the salt directly to `DeploySmartContract` without revalidating address availability: [5](#0-4) 

The only enforcement happens deep in the `DeploySmartContract` helper, where the assertion fails for subsequent proposals attempting to use the same salt: [6](#0-5) 

This creates a TOCTOU gap where multiple proposals pass validation at line 421 but only one can succeed at execution. The existing test suite confirms this behavior when attempting to deploy different contracts with the same salt: [7](#0-6) 

## Impact Explanation

This vulnerability causes **operational governance degradation**:

1. **Governance Resource Waste**: Multiple proposals with identical salt values proceed through complete parliamentary voting cycles, consuming validator voting power and attention on proposals that cannot all succeed

2. **Code Review Waste**: Validators perform thorough security audits and code reviews on smart contracts that are guaranteed to fail deployment, wasting critical security review capacity

3. **Unpredictable Execution Order**: When multiple approved proposals exist with the same salt, execution order depends on miner/executor selection, creating uncertainty about which contract actually gets deployed at the deterministic address

4. **Transaction Fee Loss**: Both proposal creators and executors pay transaction fees for proposals that will inevitably fail with "Contract address exists" errors

While this does not directly compromise funds or protocol security, it degrades governance efficiency and wastes validator resources that should be reviewing legitimate proposals.

## Likelihood Explanation

This vulnerability has **medium-high likelihood**:

**Attacker Capabilities**: Any user authorized to create contract deployment proposals can trigger this. On side-chains, this is any user. On main-chain, this requires being on the proposer whitelist, but whitelisted users are legitimate participants who may accidentally create collisions.

**Attack Complexity**: Trivial - simply submit multiple `DeployUserSmartContract` transactions with the same salt but different contract code. The system accepts all proposals since each has a unique hash.

**Realistic Scenario**:
- User creates Proposal P1: `{category: 0, code: ContractA, salt: Hash("mydapp")}`
- Different user (or same user) creates Proposal P2: `{category: 0, code: ContractB, salt: Hash("mydapp")}`
- Both pass `AssertContractAddressAvailable` check since no contract is deployed yet
- Both get different hashes: `Hash(0, ContractA, "mydapp")` â‰  `Hash(0, ContractB, "mydapp")`
- Both proposals proceed through full governance approval
- P1 executes successfully, deploying ContractA at `Address(user, "mydapp")`
- P2 execution fails with "Contract address exists" error

**Economic Rationality**: While intentional griefing seems unlikely (attacker pays proposal fees to waste validator time), **accidental collisions are realistic** when:
- Multiple developers independently choose common salt values like "v1", "main", "test"
- Teams reuse salt values from test environments
- Popular naming conventions lead to salt collisions

## Recommendation

Add address availability revalidation in `PerformDeployUserSmartContract` before calling `DeploySmartContract`:

```csharp
public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
{
    RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

    var inputHash = CalculateHashFromInput(input);
    TryClearContractProposingData(inputHash, out var contractProposingInput);

    // ADD THIS CHECK: Revalidate address availability before deployment
    if (input.Salt != null)
    {
        AssertContractAddressAvailable(contractProposingInput.Author, input.Salt);
    }

    var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
        contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
    return address;
}
```

This ensures that even if multiple proposals with the same salt pass initial validation, only the first to execute succeeds, and subsequent proposals fail immediately with a clear error before wasting governance approval cycles.

Alternatively, check for salt conflicts during proposal registration in `SendUserContractProposal` by tracking pending salt values, though this is more complex.

## Proof of Concept

```csharp
[Fact]
public async Task DeployUserSmartContract_SameSalt_DifferentCode_TOCTOU_Test()
{
    // Setup: Start side chain where any user can deploy
    StartSideChain();
    
    var salt = HashHelper.ComputeFrom("collision-test");
    var codeA = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicFunction")).Value);
    var codeB = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicSecurity")).Value);
    
    // Step 1: Create first proposal with salt S and code A
    var proposal1Result = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract),
        new UserContractDeploymentInput
        {
            Category = 0,
            Code = codeA,
            Salt = salt
        });
    proposal1Result.Status.ShouldBe(TransactionResultStatus.Mined);
    var proposalHash1 = ContractProposed.Parser
        .ParseFrom(proposal1Result.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
        .ProposedContractInputHash;
    
    // Step 2: Create second proposal with SAME salt but DIFFERENT code
    var proposal2Result = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract),
        new UserContractDeploymentInput
        {
            Category = 0,
            Code = codeB,  // Different code
            Salt = salt    // Same salt!
        });
    proposal2Result.Status.ShouldBe(TransactionResultStatus.Mined);  // Both proposals succeed!
    
    // Step 3: Approve and execute first proposal - succeeds
    var proposalId1 = ProposalCreated.Parser
        .ParseFrom(proposal1Result.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    await ApproveWithMinersAsync(SideChainTester, SideParliamentAddress, proposalId1);
    var releaseResult1 = await CurrentMinerReleaseApprovedUserContract(proposalHash1, proposalId1);
    releaseResult1.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Approve and execute second proposal - FAILS with governance resources wasted
    var proposalId2 = ProposalCreated.Parser
        .ParseFrom(proposal2Result.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    await ApproveWithMinersAsync(SideChainTester, SideParliamentAddress, proposalId2);
    var releaseResult2 = await CurrentMinerReleaseApprovedUserContract(
        ContractProposed.Parser.ParseFrom(proposal2Result.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed).ProposedContractInputHash,
        proposalId2);
    
    // Vulnerability: Second proposal fails only at execution after full approval cycle
    releaseResult2.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult2.Error.ShouldContain("Contract address exists");
}
```

## Notes

This vulnerability specifically affects the `DeployUserSmartContract` flow used on side-chains and by whitelisted deployers. The similar `ProposeNewContract` flow for system contracts has the same pattern but uses `ContractOperation` signatures which provide additional validation. The core issue is the lack of revalidation between proposal time and execution time when the state may have changed.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L419-422)
```csharp
        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L424-424)
```csharp
        var proposedContractInputHash = CalculateHashFromInput(input);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L495-505)
```csharp
    public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
        return address;
    }
```

**File:** protobuf/acs0.proto (L164-170)
```text
message UserContractDeploymentInput {
    // The category of contract code(0: C#).
    sint32 category = 1;
    // The byte array of the contract code.
    bytes code = 2;
    aelf.Hash salt = 3;
}
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L34-40)
```csharp
        else
        {
            serialNumber = 0;
            contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        }

        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractTests_Deterministic.cs (L57-74)
```csharp
        code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicSecurity")).Value);
        var result = await DeployWithResultAsync(SideChainTester, SideParliamentAddress, SideBasicContractZeroAddress,
            new ContractDeploymentInput
            {
                Category = KernelConstants.DefaultRunnerCategory, // test the default runner
                Code = code,
                ContractOperation = new ContractOperation
                {
                    ChainId = sideChainId,
                    CodeHash = HashHelper.ComputeFrom(code.ToByteArray()),
                    Deployer = CreatorAddress,
                    Salt = salt,
                    Version = 1,
                    Signature = GenerateContractSignature(CreatorKeyPair.PrivateKey, sideChainId,
                        HashHelper.ComputeFrom(code.ToByteArray()), CreatorAddress, salt, 1)
                }
            });
        result.Error.ShouldContain("Contract address exists");
```
