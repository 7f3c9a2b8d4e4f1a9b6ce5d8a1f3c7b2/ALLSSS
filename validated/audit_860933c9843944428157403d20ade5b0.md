# Audit Report

## Title
Arithmetic Overflow in Bancor Formula Causes DoS for Valid Extreme Weight Ratios

## Summary
The TokenConverter contract's Bancor pricing calculation uses a Taylor series approximation with 20 terms to compute exponential functions. When connector weight ratios reach extreme but mathematically valid values (e.g., 0.99/0.01 = 99), combined with moderate trade sizes, the power function in the exponential calculation overflows, causing transaction revert and complete denial of service for legitimate Buy/Sell operations.

## Finding Description

The vulnerability exists in the Bancor pricing calculation path used by both `Buy()` and `Sell()` operations. [1](#0-0) [2](#0-1) 

These methods invoke BancorHelper functions that compute `Exp(y * Ln(x))` where `y` represents the weight ratio and `x` represents a balance ratio. [3](#0-2) [4](#0-3) 

Connector weights are validated using the `IsBetweenZeroAndOne()` function, which only checks that individual weights are strictly between 0 and 1 (exclusive). [5](#0-4) [6](#0-5) 

This validation permits extreme weight ratios such as wf=0.99 and wt=0.01, creating y=99, which is mathematically valid but causes computational overflow.

The root cause lies in the `Exp()` function's Taylor series implementation using 20 iterations. [7](#0-6) 

At iteration 20, the function computes `Pow(y, 20)`. For large absolute values of y (e.g., y ≈ -40 when wf=0.99, wt=0.01, and balance ratio x≈0.667), calculating y^20 produces approximately 10^32, which exceeds the C# decimal type's maximum value of approximately 7.9 × 10^28.

The AElf contract compilation requirements mandate `CheckForOverflowUnderflow=true` for both Debug and Release configurations. [8](#0-7) [9](#0-8) 

This causes the overflow to throw an `OverflowException`, reverting the transaction.

The `Pow()` function implements binary exponentiation without overflow guards. [10](#0-9) 

The existing `PayLimit` and `ReceiveLimit` checks in Buy() and Sell() occur AFTER the Bancor calculation completes, providing no protection against overflow during price computation. [11](#0-10) [12](#0-11) 

## Impact Explanation

**High Severity - Complete DoS of Token Conversion Operations:**

When connector pairs are deployed with extreme but valid weight ratios (e.g., wf=0.99, wt=0.01), all Buy and Sell operations for those pairs will revert with overflow exceptions when users attempt trades of moderate to large sizes (approximately ≥50% of connector balance). This creates:

1. **Service Unavailability**: Users cannot trade tokens through affected connector pairs
2. **Locked Liquidity**: Tokens deposited in these connectors become difficult or impossible to trade efficiently  
3. **Protocol Dysfunction**: Resource token conversion functionality is impaired for affected pairs
4. **Economic Impact**: If key connector pairs become dysfunctional, the entire economic model's stability is compromised

While no funds are directly lost, the complete denial of service for legitimate operations constitutes a critical availability breach. The vulnerability is particularly severe because:
- Once connector weights are set by governance, they remain static until updated via governance process
- Normal users attempting legitimate trades suffer the consequences  
- The mathematical constraints (0 < weight < 1) do not prevent this scenario
- No warnings or precautions exist to prevent governance from deploying vulnerable configurations

## Likelihood Explanation

**Medium Likelihood:**

**Reachable Entry Point:** Yes - `Buy()` and `Sell()` are public methods callable by any user on the TokenConverter contract.

**Feasible Preconditions:**
1. Governance deploys connector pair with extreme weight ratio (e.g., wf=0.99, wt=0.01) via `AddPairConnector()` or `UpdateConnector()` [13](#0-12) [14](#0-13) 
2. User attempts trade size that creates balance ratio x resulting in |y * Ln(x)| > ~35

**Execution Practicality:**
- Connector weights are governance-controlled but mathematically valid per current validation
- Trade size of ~50% of connector balance is reasonable for moderate-sized pools
- No attacker privileges needed - normal trading triggers the overflow
- Predictable and deterministic failure for specific weight ratios and trade sizes

**Probability Assessment:** While extreme weight ratios (e.g., 99:1) may be less common than balanced ratios, they are:
- Mathematically valid per current validation rules
- Potentially useful for specific economic models (pegged assets, highly asymmetric bonding curves)
- Not prevented by any warnings or safeguards in the governance process
- Permanently problematic once deployed until governance updates them

## Recommendation

Implement multiple layers of protection:

1. **Add Weight Ratio Validation**: In `AssertValidConnectorWeight()` and pair connector operations, add validation to prevent extreme weight ratios that could cause overflow:
   - Calculate and validate the ratio between paired connector weights
   - Reject ratios exceeding a safe threshold (e.g., 10:1 or 20:1)

2. **Implement Overflow Guards in Pow()**: Add bounds checking before multiplications in the `Pow()` function to detect potential overflow conditions and handle them gracefully (e.g., by reverting with a clear error message before overflow occurs).

3. **Add Input Validation in Bancor Functions**: Calculate the expected exponent value (y * Ln(x)) before calling `Exp()` and validate it's within safe computational bounds (e.g., |y * Ln(x)| < 30).

4. **Early Limit Checks**: Move PayLimit and ReceiveLimit checks to occur before the Bancor calculation when possible, though this may require estimation logic.

## Proof of Concept

```csharp
[Fact]
public async Task Buy_With_Extreme_Weight_Ratio_Causes_Overflow_Test()
{
    // Setup: Create connector pair with extreme weight ratio (0.99/0.01 = 99)
    await InitializeTokenConverterContract();
    
    // Add connector pair via governance with extreme weights
    var extremeWeightPair = new PairConnectorParam
    {
        ResourceConnectorSymbol = "EXTREME",
        ResourceWeight = "0.01",  // Very low weight
        NativeWeight = "0.99",    // Very high weight
        NativeVirtualBalance = 100_000_000
    };
    
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(DefaultStub.AddPairConnector),
        extremeWeightPair
    );
    
    // Enable the connector and prepare for trading
    await PrepareExtremeWeightConnectorForTrading("EXTREME");
    
    // Attempt to buy with moderate trade size (~50% of balance)
    // This should cause overflow in Pow(y, 20) calculation
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(
        new BuyInput
        {
            Symbol = "EXTREME",
            Amount = 50_000_000,  // 50% of connector balance
            PayLimit = long.MaxValue
        }
    );
    
    // Verify overflow exception occurs
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    buyResult.TransactionResult.Error.ShouldContain("Overflow");
}
```

**Notes**

This vulnerability demonstrates a critical edge case where mathematically valid governance decisions (setting extreme but permitted weight ratios) can inadvertently create permanent DoS conditions for token conversion operations. The issue is exacerbated by the fact that the weight validation logic checks individual weights in isolation rather than considering the implications of extreme ratios between paired connectors. The mandatory overflow checking in AElf contracts, while generally a security feature, converts what would be a silent calculation error into a transaction-reverting exception, making this a high-impact availability issue rather than a data corruption issue.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-127)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-180)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/project.md (L20-30)
```markdown
- It is required to enable `CheckForOverflowUnderflow` for both Release and Debug mode so that your contract will use arithmetic operators that will throw `OverflowException` if there is any overflow. This is to ensure that execution will not continue in case of an overflow in your contract and result with unpredictable output.

```xml
<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>
```
```
