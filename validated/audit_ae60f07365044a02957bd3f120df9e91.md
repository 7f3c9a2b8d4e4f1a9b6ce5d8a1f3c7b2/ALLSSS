# Audit Report

## Title
Assembled NFTs Can Be Burned Directly, Permanently Locking Component NFTs

## Summary
The NFT contract's `Burn` method allows destruction of assembled NFTs without returning locked component assets. When minters burn assembled NFTs directly instead of using `Disassemble`, the component NFTs and fungible tokens remain permanently trapped in the contract with no recovery mechanism.

## Finding Description

The NFT contract implements an assembly mechanism where NFTs and fungible tokens can be locked into composite "assembled" NFTs. During assembly, component NFTs are transferred to the contract itself and their mappings stored for later retrieval. [1](#0-0) 

The locked components are recorded in state mappings: [2](#0-1) [3](#0-2) 

The intended flow for retrieving locked assets is through `Disassemble`, which burns the assembled NFT and transfers components back: [4](#0-3) 

**Root Cause**: The `Burn` method validates caller permissions and balance but does NOT check if the NFT being burned has locked components in `AssembledNftsMap` or `AssembledFtsMap`: [5](#0-4) 

When a minter calls `Burn` on an assembled NFT, the assembled NFT is destroyed but the component assets remain locked in the contract forever with no mechanism to recover them. The `AssembledNftsMap` entry becomes orphaned.

**Attack Vector**: Any user can create their own NFT protocol and become its minter automatically: [6](#0-5) 

They can assemble NFTs from any protocol (the `Assemble` method accepts any token hash the sender owns), then burn the assembled NFT to permanently lock the components.

## Impact Explanation

**Severity: HIGH**

**Direct Fund Loss**: Component NFTs and fungible tokens locked during assembly become permanently inaccessible. The locked assets remain in the contract's balance but cannot be retrieved by anyone, including governance. The value depends on what was assembled but could include rare NFTs or significant token amounts.

**Broken Invariants**: The assembly/disassembly mechanism creates an explicit expectation that locked assets can be retrieved. This vulnerability violates that core guarantee, as burning assembled NFTs bypasses the retrieval flow entirely.

**Affected Parties**:
- Users who accidentally call `Burn` instead of `Disassemble` (user error)
- Victims of malicious actors who intentionally burn assembled NFTs (griefing)
- The protocol itself accumulates unrecoverable locked assets in perpetuity

**No Recovery Path**: There is no admin function, governance mechanism, or emergency procedure to rescue locked assets from orphaned `AssembledNftsMap` entries. The loss is permanent and irreversible.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Entry Point**: The `Burn` method is publicly accessible to any protocol minter with sufficient balance.

**Preconditions**:
1. Attacker creates an NFT protocol (any user can do this via `Create`)
2. Attacker is automatically added as protocol minter upon creation
3. Attacker assembles NFTs from other protocols into their protocol
4. Protocol must be burnable (can be set during creation)

**Attack Complexity**: LOW - The attack requires only standard protocol operations:
- Create a burnable protocol (single transaction)
- Assemble NFTs into the protocol (single transaction)
- Burn the assembled NFT (single transaction)

**Real-World Scenarios**:
1. **User Error**: Users may confuse `Burn` and `Disassemble` methods, especially if wallet interfaces don't clearly distinguish them
2. **Malicious Griefing**: Attackers can intentionally burn assembled NFTs to cause fund loss at minimal cost (only transaction fees)
3. **Integration Bugs**: External dApps or contracts that incorrectly call `Burn` on assembled NFTs

## Recommendation

Add a check in the `Burn` method to prevent burning of assembled NFTs:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add check for assembled NFTs
    Assert(State.AssembledNftsMap[tokenHash] == null && State.AssembledFtsMap[tokenHash] == null,
        "Cannot burn assembled NFT directly. Use Disassemble method to retrieve locked components.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    // ... rest of existing logic
}
```

Alternatively, the `Burn` method could automatically disassemble and return locked components before burning, similar to how `Disassemble` works.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_LocksComponentsPermanently()
{
    // Setup: Create first protocol and mint an NFT to be locked
    var symbol1 = await CreateTest();
    await AddMinterAsync(symbol1);
    var componentTokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol1,
        Alias = "Component NFT",
        Owner = DefaultAddress,
        Uri = $"{BaseUri}component"
    })).Output;

    // Setup: Create second burnable protocol
    var symbol2Result = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = BaseUri,
        Creator = DefaultAddress,
        IsBurnable = true, // Must be burnable
        NftType = NFTType.VirtualWorlds.ToString(),
        ProtocolName = "ASSEMBLED",
        TotalSupply = 1_000_000
    });
    var symbol2 = symbol2Result.Output.Value;

    // Assemble: Lock component NFT into new protocol
    var assembledHash = (await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol2,
        AssembledNfts = new AssembledNfts
        {
            Value = { [componentTokenHash.ToHex()] = 1 }
        }
    })).Output;

    // Verify component is locked in contract
    var contractBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = NFTContractAddress,
        Symbol = symbol1,
        TokenId = 1
    })).Balance;
    contractBalance.ShouldBe(1);

    // VULNERABILITY: Burn assembled NFT directly instead of disassembling
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol2,
        TokenId = 1,
        Amount = 1
    });

    // Verify: Component NFT is permanently locked
    // The assembled NFT is destroyed
    var assembledBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = symbol2,
        TokenId = 1
    })).Balance;
    assembledBalance.ShouldBe(0); // Assembled NFT is burned

    // But component NFT remains in contract forever
    contractBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = NFTContractAddress,
        Symbol = symbol1,
        TokenId = 1
    })).Balance;
    contractBalance.ShouldBe(1); // Still locked, no way to retrieve

    // AssembledNftsMap entry is orphaned
    var assembledNfts = await NFTContractStub.GetAssembledNfts.CallAsync(assembledHash);
    assembledNfts.ShouldNotBeNull(); // Map entry still exists but unusable
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L124-131)
```csharp
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-178)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-209)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```
