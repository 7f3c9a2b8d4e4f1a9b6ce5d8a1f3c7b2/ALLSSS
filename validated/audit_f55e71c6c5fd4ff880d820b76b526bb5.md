# Audit Report

## Title
Sponsor Can DOS Voters by Rapidly Exhausting Snapshots Regardless of EndTimestamp

## Summary
The Vote contract's `TakeSnapshot` function lacks time-based restrictions, allowing sponsors to prematurely terminate voting by exhausting all snapshots in rapid succession. Voting eligibility depends solely on snapshot count rather than the declared `EndTimestamp`, enabling sponsors to deny voter participation despite the advertised voting period.

## Finding Description

The vulnerability stems from a fundamental design flaw where voting period enforcement relies exclusively on snapshot count rather than the declared time boundaries.

The `TakeSnapshot` function only validates sponsor authorization and snapshot count limits, with no time-based restrictions: [1](#0-0) 

The function increments `CurrentSnapshotNumber` and sets the new snapshot's start time to the current block without validating against the voting item's `EndTimestamp`.

The critical flaw appears in `AssertValidVoteInput`, which determines voting eligibility based solely on snapshot count: [2](#0-1) 

The check at lines 382-383 compares `CurrentSnapshotNumber <= TotalSnapshotNumber`, making no reference to time. Once snapshots are exhausted, voting immediately fails with "Current voting item already ended."

During registration, `EndTimestamp` is stored but only validated to exceed `StartTimestamp`: [3](#0-2) 

The `EndTimestamp` field is never checked during subsequent voting or snapshot operations, rendering it purely informational rather than a security enforcement mechanism.

**Attack Scenario:**
1. Sponsor registers voting item with `EndTimestamp` 30 days in future and `TotalSnapshotNumber = 10`
2. Sponsor immediately calls `TakeSnapshot` 10 times in rapid succession
3. `CurrentSnapshotNumber` reaches 11, exceeding `TotalSnapshotNumber`
4. All voter attempts fail, despite being well before the declared `EndTimestamp`
5. Governance outcome is determined only by votes cast in the brief window before snapshot exhaustion

## Impact Explanation

**Severity: High**

This vulnerability enables complete denial of the voting system's core functionality with severe governance implications:

1. **Operational DOS**: Voters are systematically denied their ability to participate in governance despite the declared voting period, violating the fundamental expectation that `EndTimestamp` defines when voting closes.

2. **Governance Manipulation**: Sponsors can strategically control voter participation windows to influence outcomes. By terminating voting prematurely, they can exclude late voters who might have different preferences, effectively rigging governance decisions.

3. **Trust Violation**: The voting system's inability to honor its time commitments undermines trust in the governance process. A 30-day voting period advertised to the community can be terminated in minutes.

4. **Unfair Advantage**: Early voters who manage to vote before snapshot exhaustion gain disproportionate influence, while late voters are completely excluded despite acting within the declared timeframe.

While no direct fund theft occurs, governance manipulation at this level can lead to protocol-level damage through unauthorized parameter changes, malicious proposals, or captured decision-making processes.

Test evidence confirms this behavior - when snapshots are exhausted, voting immediately fails: [4](#0-3) 

## Likelihood Explanation

**Likelihood: High**

This vulnerability has exceptionally high exploitability:

1. **Low Attack Complexity**: The entry point is the public `TakeSnapshot` method accessible to any sponsor. Execution requires only repeatedly calling `TakeSnapshot` with sequential snapshot numbers - no sophisticated techniques needed.

2. **No Special Privileges Required**: The sponsor role is part of normal operation, obtained simply by registering a voting item. This is not a compromised or privileged account scenario.

3. **Trivial Execution**: The attack can be executed in consecutive blocks or even within a single block (gas permitting). No economic barriers exist beyond negligible gas costs.

4. **Difficult Detection**: Rapid snapshots appear as legitimate sponsor activity with no on-chain indicators to distinguish malicious from legitimate snapshot progression. Voters only discover the DOS when their transactions fail.

Test evidence demonstrates snapshots can be taken in rapid succession without any time delays: [5](#0-4) 

The test takes multiple snapshots immediately in sequence, proving no time-based restrictions exist.

## Recommendation

Add time-based validation to enforce the `EndTimestamp` constraint:

1. **In `AssertValidVoteInput`**: Add a check to validate that `Context.CurrentBlockTime <= votingItem.EndTimestamp` before allowing votes.

2. **In `TakeSnapshot`**: Add validation to prevent taking snapshots after `EndTimestamp` has passed, or add minimum time delays between snapshots.

3. **Alternative Design**: Consider making voting periods time-based by default, using snapshots only as optional checkpoints rather than voting terminators.

Example fix for `AssertValidVoteInput`:
```csharp
Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
    "Current voting item already ended.");
Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
    "All snapshots have been taken.");
```

## Proof of Concept

The existing test demonstrates the vulnerability: [6](#0-5) 

This test shows:
1. Voting item registered with `TotalSnapshotNumber = 3`
2. Snapshots taken at lines 41, 101, and 121 in rapid succession
3. After the 3rd snapshot, voting fails with "Current voting item already ended" (line 127)
4. No time-based validation prevents this premature termination

## Notes

The vulnerability is confirmed by code review showing that `EndTimestamp` appears only in four locations in the Vote contract: storage (line 47), event emission (line 75), snapshot end time assignment (line 253 - different field), and initial validation (line 361). It is never checked during voting or snapshot operations, making it purely informational. The voting system terminates based solely on snapshot exhaustion, not the declared time period.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L11-129)
```csharp
    [Fact]
    public async Task MultipleUsers_Vote_Scenario_Test()
    {
        var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 3);

        var user1 = Accounts[1];
        var user2 = Accounts[2];
        var user3 = Accounts[3];

        //phase 1
        {
            //user1 vote 100
            var transactionResult1 = await Vote(user1.KeyPair, registerItem.VotingItemId, registerItem.Options[0], 100);
            transactionResult1.Status.ShouldBe(TransactionResultStatus.Mined);

            //user2 vote 150
            var transactionResult2 = await Vote(user2.KeyPair, registerItem.VotingItemId, registerItem.Options[0], 150);
            transactionResult2.Status.ShouldBe(TransactionResultStatus.Mined);

            //user3 vote 200
            var transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, registerItem.Options[1], 200);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingResult = await GetVotingResult(registerItem.VotingItemId, 1);
            votingResult.VotersCount.ShouldBe(3);
            votingResult.Results.Count.ShouldBe(2);
            votingResult.Results[registerItem.Options[0]].ShouldBe(250);
            votingResult.Results[registerItem.Options[1]].ShouldBe(200);

            //take snapshot
            var snapshotResult = await TakeSnapshot(registerItem.VotingItemId, 1);
            snapshotResult.Status.ShouldBe(TransactionResultStatus.Mined);

            //query vote ids
            var voteIds = await GetVoteIds(user1.KeyPair, registerItem.VotingItemId);
            //query result
            var voteRecord = await GetVotingRecord(voteIds.ActiveVotes.First());
            voteRecord.Option.ShouldBe(registerItem.Options[0]);
            voteRecord.Amount.ShouldBe(100);

            //withdraw
            var beforeBalance = GetUserBalance(user1.Address);
            await Withdraw(user1.KeyPair, voteIds.ActiveVotes.First());
            var afterBalance = GetUserBalance(user1.Address);

            beforeBalance.ShouldBe(afterBalance - 100);

            voteIds = await GetVoteIds(user1.KeyPair, registerItem.VotingItemId);
            voteIds.ActiveVotes.Count.ShouldBe(0);
            voteIds.WithdrawnVotes.Count.ShouldBe(1);
        }

        //phase 2
        {
            //add some more option
            var options = new[]
            {
                Accounts[3].Address.ToBase58(),
                Accounts[4].Address.ToBase58(),
                Accounts[5].Address.ToBase58()
            };
            var optionResult = (await VoteContractStub.AddOptions.SendAsync(new AddOptionsInput
            {
                VotingItemId = registerItem.VotingItemId,
                Options = { options }
            })).TransactionResult;
            optionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            //user1 vote new option 1
            var transactionResult1 = await Vote(user1.KeyPair, registerItem.VotingItemId, options[0], 100);
            transactionResult1.Status.ShouldBe(TransactionResultStatus.Mined);

            //user2 vote new option 2
            var transactionResult2 = await Vote(user2.KeyPair, registerItem.VotingItemId, options[1], 100);
            transactionResult2.Status.ShouldBe(TransactionResultStatus.Mined);

            //user3 vote new option 3 twice
            var transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);
            transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingResult = await GetVotingResult(registerItem.VotingItemId, 2);
            votingResult.VotersCount.ShouldBe(7);
            votingResult.Results.Count.ShouldBe(3);
            votingResult.Results[options[0]].ShouldBe(100);
            votingResult.Results[options[1]].ShouldBe(100);
            votingResult.Results[options[2]].ShouldBe(200);

            //take snapshot
            var snapshotResult = await TakeSnapshot(registerItem.VotingItemId, 2);
            snapshotResult.Status.ShouldBe(TransactionResultStatus.Mined);

            //query vote ids
            var user1VoteIds = await GetVoteIds(user1.KeyPair, registerItem.VotingItemId);
            user1VoteIds.ActiveVotes.Count.ShouldBe(1);
            user1VoteIds.WithdrawnVotes.Count.ShouldBe(1);

            var user2VoteIds = await GetVoteIds(user2.KeyPair, registerItem.VotingItemId);
            user2VoteIds.ActiveVotes.Count.ShouldBe(2);
            user2VoteIds.WithdrawnVotes.Count.ShouldBe(0);

            var user3VoteIds = await GetVoteIds(user3.KeyPair, registerItem.VotingItemId);
            user3VoteIds.ActiveVotes.Count.ShouldBe(3);
            user3VoteIds.WithdrawnVotes.Count.ShouldBe(0);
        }

        //phase 3
        {
            //take snapshot
            var snapshotResult = await TakeSnapshot(registerItem.VotingItemId, 3);
            snapshotResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var transactionResult =
                await VoteWithException(user2.KeyPair, registerItem.VotingItemId, registerItem.Options[0], 100);
            transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
        }
    }
```
