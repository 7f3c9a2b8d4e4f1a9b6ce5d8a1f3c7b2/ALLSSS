# Audit Report

## Title
Sponsor Can Manipulate Voting Outcomes Through Unrestricted Option Modification During Active Voting

## Summary
The Vote contract allows sponsors to add or remove voting options at any time without validating whether voting is active or votes have been cast. This enables sponsors to manipulate voting outcomes by adding new options mid-vote for collusion or removing winning options to invalidate votes, directly undermining the integrity of the voting system.

## Finding Description

The Vote contract contains four option modification methods that lack critical timing and state validations. The `AddOption` method [1](#0-0) , `RemoveOption` method [2](#0-1) , `AddOptions` method [3](#0-2) , and `RemoveOptions` method [4](#0-3)  only verify sponsor authorization but fail to check:
1. Whether the voting period has started (no validation against `StartTimestamp`)
2. Whether voting is still active (no validation against `EndTimestamp`)
3. Whether votes have been cast (no check of vote existence)

The VotingItem structure contains timestamp fields that define the voting period [5](#0-4) . However, the option modification methods never validate against these timestamps. Meanwhile, the Vote method strictly enforces that voters can only vote for options currently in the options list [6](#0-5) .

This creates an exploitable inconsistency window. When votes are cast, they are stored in the VotingResult.Results mapping by option name [7](#0-6) . If a sponsor removes an option after votes have been cast for it, those votes remain in the Results map but the option is removed from the visible options list returned by GetVotingItem [8](#0-7) .

This effectively invalidates those votes while preventing new voters from selecting that option.

**Attack Scenarios:**

1. **Late Option Addition for Collusion**: After honest voters cast their votes for existing options A, B, C, the sponsor adds option D mid-vote and coordinates with colluding voters to vote for it. Early voters who already voted have no knowledge of option D and cannot adjust their votes without withdrawal (if token-locked voting).

2. **Vote Invalidation via Option Removal**: If option A is winning with significant votes, the sponsor removes option A. The votes remain in `VotingResult.Results["A"]` but option A is removed from `votingItem.Options`. New voters cannot vote for A (fails the assertion check), and the option is hidden from the visible options list, effectively invalidating those votes.

The Vote contract is used by the Election contract for miner elections [9](#0-8) , demonstrating its role in critical governance operations within the AElf ecosystem.

## Impact Explanation

**Severity: HIGH**

This vulnerability directly undermines the fundamental purpose of the voting system - fair and transparent democratic decision-making. The impact includes:

1. **Governance Manipulation**: Sponsors can directly control voting outcomes through option manipulation, enabling systematic capture of governance decisions.

2. **Vote Invalidation**: Sponsors can retroactively invalidate votes by removing winning options, making those votes invisible to new voters while keeping them in the underlying data structure.

3. **Unfair Advantage**: Early voters operate with incomplete information when sponsors can add options after voting begins, creating an asymmetric information advantage.

4. **Trust Breakdown**: All voters are affected as their voting decisions can be rendered meaningless through sponsor manipulation. Any system relying on this voting mechanism for governance, elections, or decision-making is compromised.

The vote contract is used throughout the AElf ecosystem for governance decisions, and this vulnerability affects the integrity of all such decisions.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Attacker Capabilities**: The sponsor role is obtained simply by calling the `Register` method to create a voting item [10](#0-9)  - any user can become a sponsor. No special privileges beyond sponsor status are required.

2. **Attack Complexity: LOW**: The exploit requires only calling public methods (`AddOption`, `RemoveOption`, `AddOptions`, `RemoveOptions`) with standard transaction fees. No complex setup, precise timing, or technical sophistication is needed.

3. **Execution Practicality**: The attack is fully executable within AElf contract semantics using standard method calls. All option modification methods are public entry points accessible to sponsors.

4. **Detection Difficulty**: The contract does not emit events when options are modified, making it difficult for voters to detect mid-vote manipulation unless they continuously monitor the voting item state.

5. **Economic Rationality**: The cost is minimal (standard transaction fees), while the potential benefit is enormous (controlling governance decisions, election outcomes, or other vote-dependent processes).

## Recommendation

Add timing and state validations to all option modification methods. The methods should:

1. **Validate voting has not started**: Check that `Context.CurrentBlockTime < votingItem.StartTimestamp` before allowing option modifications
2. **Alternative: Lock options after first vote**: Check if any votes have been cast by verifying the VotingResult's VotersCount is zero before allowing modifications
3. **Emit events**: Add events for option additions and removals to enable transparency and voter monitoring

Example fix for `AddOption`:

```csharp
public override Empty AddOption(AddOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // NEW: Validate voting has not started
    Assert(Context.CurrentBlockTime < votingItem.StartTimestamp, 
        "Cannot modify options after voting has started.");
    
    // OR: Validate no votes have been cast
    var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
    var votingResult = State.VotingResults[votingResultHash];
    Assert(votingResult.VotersCount == 0, 
        "Cannot modify options after votes have been cast.");
    
    AssertOption(votingItem, input.Option);
    Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    votingItem.Options.Add(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    
    // NEW: Emit event
    Context.Fire(new OptionAdded 
    {
        VotingItemId = votingItem.VotingItemId,
        Option = input.Option
    });
    
    return new Empty();
}
```

Apply similar validations to `RemoveOption`, `AddOptions`, and `RemoveOptions` methods.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. User A registers a voting item with options ["OptionA", "OptionB"] as sponsor
2. User B votes for "OptionA" with 100 tokens
3. Sponsor (User A) calls `RemoveOption` to remove "OptionA" - this succeeds despite votes being cast
4. User C attempts to vote for "OptionA" - this fails with "Option not found" assertion
5. Query `GetVotingResult` shows votes for "OptionA" still exist in Results map
6. Query `GetVotingItem` shows "OptionA" is no longer in the options list

This demonstrates that votes can be invalidated by removing options after they receive votes, creating an inconsistency between the visible options and the actual vote results, allowing sponsors to manipulate voting outcomes.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-180)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L314-324)
```csharp
    public override Empty AddOptions(AddOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L326-339)
```csharp
    public override Empty RemoveOptions(RemoveOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options)
        {
            Assert(votingItem.Options.Contains(option), "Option doesn't exist.");
            Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
            votingItem.Options.Remove(option);
        }

        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L381-381)
```csharp
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** protobuf/vote_contract.proto (L122-124)
```text
    google.protobuf.Timestamp start_timestamp = 8;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 9;
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L27-32)
```csharp
    public override VotingItem GetVotingItem(GetVotingItemInput input)
    {
        var votingEvent = State.VotingItems[input.VotingItemId];
        Assert(votingEvent != null, "Voting item not found.");
        return votingEvent;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L54-76)
```csharp
    public override Empty RegisterElectionVotingEvent(Empty input)
    {
        Assert(!State.VotingEventRegistered.Value, "Already registered.");

        State.VoteContract.Value = Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);

        State.MinerElectionVotingItemId.Value = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(votingRegisterInput),
            HashHelper.ComputeFrom(Context.Self));

        State.VotingEventRegistered.Value = true;
        return new Empty();
    }
```
