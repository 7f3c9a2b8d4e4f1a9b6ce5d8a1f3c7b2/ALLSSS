# Audit Report

## Title
Missing Validation of Critical Consensus Fields Allows Miners to Corrupt Round State and Manipulate Mining Order

## Summary
The AEDPoS consensus contract fails to validate critical fields in `UpdateValueInput` that control next-round mining orders and secret sharing. The `UpdateValueValidationProvider` only validates three fields (OutValue, Signature, PreviousInValue) for the sender, while `ProcessUpdateValue` directly applies unvalidated fields (`SupposedOrderOfNextRound`, `TuneOrderInformation`, `MinersPreviousInValues`) that affect ALL miners to the round state. This allows any malicious miner to manipulate the mining schedule, exclude honest miners, and corrupt the secret sharing mechanism used for random number generation.

## Finding Description

The validation flow for `UpdateValue` consensus behavior has a critical gap between what is validated and what is applied to state.

**Insufficient Validation**: The `UpdateValueValidationProvider.ValidateHeaderInformation()` method only validates that the sender's `OutValue` and `Signature` are non-empty [1](#0-0)  and that the sender's `PreviousInValue` correctly hashes to the previous round's `OutValue` [2](#0-1) .

**Unvalidated Critical Fields**: However, `UpdateValueInput` contains many additional fields that control consensus state for ALL miners, including `supposed_order_of_next_round`, `tune_order_information` (a map setting other miners' orders), and `miners_previous_in_values` (a map setting other miners' secret sharing values) [3](#0-2) .

**Unvalidated Application to State**: During execution, `ProcessUpdateValue` directly applies these unvalidated fields to the round state:

1. **SupposedOrderOfNextRound** is accepted without validation and directly assigned [4](#0-3) , even though it should be calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1` [5](#0-4) .

2. **TuneOrderInformation** allows the submitting miner to arbitrarily set `FinalOrderOfNextRound` for OTHER miners without any validation [6](#0-5) .

3. **MinersPreviousInValues** allows setting `PreviousInValue` for OTHER miners in the secret sharing scheme without validation [7](#0-6) .

**Critical Impact on Mining Schedule**: The `FinalOrderOfNextRound` values determine the mining order in the next round, as shown in the round generation logic where miners are sorted by this field to assign time slots [8](#0-7) .

**Miner Exclusion Vulnerability**: The `GetMinedMiners()` method identifies miners who successfully mined by filtering for `SupposedOrderOfNextRound != 0` [9](#0-8) . By providing manipulated round data that sets other miners' `SupposedOrderOfNextRound` to 0, an attacker can cause honest miners to be excluded from the list of miners who mined, affecting reward distribution and LIB calculation.

**Validation Flow Weakness**: Before validation, `RecoverFromUpdateValue` updates ALL miners' `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` from the provided round data without any checks [10](#0-9) , which is then used as the base for validation [11](#0-10) .

**Compounding Bug**: The `NextRoundMiningOrderValidationProvider` attempts to detect duplicate orders but incorrectly calls `Distinct()` on `MinerInRound` objects (reference types) rather than on the `FinalOrderOfNextRound` integer values [12](#0-11) , which would fail to detect duplicate order values. However, this validator is only used for `NextRound` behavior, not `UpdateValue` [13](#0-12) .

**Attack Vector**: The `UpdateValue` method is a public entry point [14](#0-13)  with only basic permission checks (sender must be in miner list) [15](#0-14) . A malicious miner can construct a custom `UpdateValueInput` with manipulated values for other miners and submit it via the `UpdateValue` method.

## Impact Explanation

This vulnerability has **HIGH** severity impact on consensus integrity:

1. **Mining Schedule Manipulation**: A malicious miner can arbitrarily control the mining order for the next round by providing manipulated `TuneOrderInformation`, violating the deterministic schedule that should be based on VRF signature calculations. This allows the attacker to decide which miners produce blocks at which times.

2. **Honest Miner Exclusion**: By setting other miners' `SupposedOrderOfNextRound` to 0 in the provided round data, the attacker can cause honest miners to be excluded from `GetMinedMiners()`, making them appear to have missed their time slots even if they mined successfully. This affects reward distribution and potentially LIB calculation.

3. **Secret Sharing Corruption**: By providing malicious `MinersPreviousInValues`, the attacker can corrupt the secret sharing mechanism used for random number generation and consensus validation, potentially allowing them to predict or influence random values used in consensus.

4. **Duplicate Order Chaos**: The lack of validation combined with the bug in `NextRoundMiningOrderValidationProvider` allows duplicate `FinalOrderOfNextRound` values to persist in the round state, causing undefined behavior in sorting and time slot assignment.

5. **Consensus Disruption**: These manipulations can cause chain halts, consensus forks, or allow a single malicious miner to gain disproportionate control over block production scheduling.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

1. **Easily Reachable**: The `UpdateValue` method is a standard public entry point that miners call during normal block production.

2. **Minimal Prerequisites**: The attacker only needs to be an elected miner (in the miner list), which is achievable through the normal election process.

3. **Simple Exploitation**: The attacker simply constructs an `UpdateValueInput` message with:
   - Valid `OutValue` and `Signature` for themselves (to pass validation)
   - Manipulated `TuneOrderInformation` to control other miners' orders
   - Manipulated `MinersPreviousInValues` to corrupt secret sharing
   - Manipulated `SupposedOrderOfNextRound` values in the provided round data

4. **No Detection**: The validation flow does not check these fields, so the malicious values are accepted and persisted to state without any warnings or errors.

5. **Immediate Effect**: Once a malicious `UpdateValue` transaction is accepted in a block, the corrupted state becomes canonical and affects all subsequent consensus operations.

## Recommendation

Implement comprehensive validation of all consensus-critical fields in `UpdateValueValidationProvider`:

1. **Validate SupposedOrderOfNextRound**: Calculate the expected value using `GetAbsModulus(signature.ToInt64(), minersCount) + 1` and verify it matches the provided value.

2. **Validate TuneOrderInformation**: Ensure that:
   - Only the sender's own `FinalOrderOfNextRound` can be different from `SupposedOrderOfNextRound`
   - Or implement proper conflict resolution logic that is deterministic and validated
   - Verify no duplicate `FinalOrderOfNextRound` values exist

3. **Validate MinersPreviousInValues**: Ensure that:
   - Only the sender can update their own `PreviousInValue`
   - Other miners' values are not modified without proper authorization
   - Values are consistent with the secret sharing protocol

4. **Fix NextRoundMiningOrderValidationProvider**: Change the duplicate detection to operate on the integer values:
   ```csharp
   var distinctCount = providedRound.RealTimeMinersInformation.Values
       .Where(m => m.FinalOrderOfNextRound > 0)
       .Select(m => m.FinalOrderOfNextRound)
       .Distinct()
       .Count();
   ```

5. **Restrict RecoverFromUpdateValue**: Only allow recovery of the sender's own fields, not all miners' fields, or add validation after recovery.

## Proof of Concept

A malicious miner can execute the following attack:

1. Call `GetConsensusCommand` to determine when to produce a block
2. Instead of using the legitimate `GenerateConsensusTransactions` flow, manually construct an `UpdateValueInput`:
   - Set valid `OutValue` and `Signature` for themselves (passes validation)
   - Set `TuneOrderInformation` to manipulate other miners' `FinalOrderOfNextRound` (e.g., set all to 1 to create chaos)
   - Set `MinersPreviousInValues` to corrupt other miners' secret sharing values
   - Include a manipulated round in the consensus extra data with `SupposedOrderOfNextRound = 0` for target miners
3. Sign and submit the `UpdateValue` transaction in their block
4. The validation passes because only the sender's OutValue, Signature, and PreviousInValue are checked
5. `ProcessUpdateValue` applies all the malicious values to the round state
6. The next round uses the corrupted state, disrupting consensus

The attack succeeds because:
- `UpdateValueValidationProvider` doesn't validate the critical fields
- `RecoverFromUpdateValue` applies all provided values without verification
- No validation prevents manipulation of other miners' consensus state

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** protobuf/aedpos_contract.proto (L194-220)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-101)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
```
