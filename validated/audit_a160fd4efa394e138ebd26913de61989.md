# Audit Report

## Title
Case-Sensitive Ban Bypass in ReplaceCandidatePubkey Allows Banned Miners to Evade Restrictions

## Summary
The `BannedPubkeyMap` state mapping uses case-sensitive string comparison while pubkey bans are stored in lowercase hex format. The `ReplaceCandidatePubkey` method accepts user-provided pubkey strings without normalization, allowing a banned miner's admin to bypass the ban check by providing the banned pubkey in uppercase or mixed case, enabling the miner to evade permanent restrictions.

## Finding Description

**Root Cause: Case-Sensitive String Key Mismatch**

The `BannedPubkeyMap` is defined as `MappedState<string, bool>` [1](#0-0) , which internally uses a C# `Dictionary<TKey, ValuePair>` with case-sensitive string keys [2](#0-1) .

When pubkeys are converted to hex strings via the `ToHex()` extension method, the implementation uses the formula `b + 0x37 + 0x20` which always produces lowercase characters ('a'-'f') [3](#0-2) .

When miners are marked as evil through the consensus contract, their pubkeys come from `RealTimeMinersInformation` dictionary keys, which are created using `miner.ToHex()` and thus stored in lowercase [4](#0-3) . The ban is then stored using this lowercase pubkey [5](#0-4) .

**Vulnerable Code Path:**

The `ReplaceCandidatePubkey` method performs a ban check directly on the user-provided input without normalization [6](#0-5) . The `IsPubkeyBanned` helper performs a case-sensitive lookup [7](#0-6) .

For initial miners, admins can be set via `SetCandidateAdmin` using a user-provided pubkey string in any case [8](#0-7) . The `IsCurrentCandidateOrInitialMiner` check converts pubkeys to bytes using `HexStringToByteArray`, which is case-insensitive [9](#0-8) [10](#0-9) .

**Attack Scenario:**
1. Initial miner sets admin with uppercase pubkey via `SetCandidateAdmin(Pubkey: "ABC123...", Admin: adminAddress)`
2. Consensus contract marks miner as evil, storing ban as `BannedPubkeyMap["abc123..."] = true`
3. Admin calls `ReplaceCandidatePubkey(OldPubkey: "ABC123...", NewPubkey: "newkey")`
4. Ban check `IsPubkeyBanned("ABC123...")` performs case-sensitive lookup, missing the lowercase entry
5. Initial miner check passes due to case-insensitive bytes comparison
6. Admin check passes because admin was stored with uppercase key
7. Replacement proceeds, effectively unbanning the malicious miner

## Impact Explanation

**Critical Consensus Integrity Violation:**

This vulnerability directly undermines the fundamental security invariant that banned malicious miners must be permanently excluded from consensus operations. A banned miner can:

1. **Rejoin Consensus**: After bypassing the ban, the miner's new pubkey can participate in block production and consensus decisions
2. **Continue Malicious Behavior**: The same actor that was banned for evil behavior (double-signing, censorship, deliberate forks) can continue operating
3. **Subvert Governance**: Emergency response organization's ban decisions become ineffective
4. **Extract Rewards**: Continue receiving mining rewards and subsidies despite being banned
5. **Degrade Network Security**: Persistently malicious actors cannot be removed, weakening the entire consensus security model

This affects all network participants who rely on the integrity of the consensus mechanism and the effectiveness of the ban system as a security enforcement mechanism.

## Likelihood Explanation

**High Likelihood:**

**Attacker Prerequisites:**
- Banned miner must have previously set a candidate admin (standard operational practice)
- Admin retains control over a valid AElf address
- No special privileges required beyond normal admin rights

**Attack Complexity: Low**
- Single transaction to `ReplaceCandidatePubkey` with case-manipulated pubkey
- Simple string manipulation (lowercase â†’ uppercase)
- No timing constraints or complex state setup
- Method is publicly accessible [11](#0-10) 

**Economic Incentive: Strong**
- Banned miners lose all mining rewards and network influence
- Strong financial motivation to evade permanent ban
- Allows continued participation in lucrative consensus operations

**Detection Difficulty:**
- Appears as legitimate pubkey replacement operation
- Case variation in on-chain events may not be obvious
- Monitoring systems comparing string representations would miss the bypass

## Recommendation

**Normalize all pubkey inputs to lowercase before any state operations:**

```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    // Normalize pubkey inputs to lowercase
    var oldPubkey = input.OldPubkey?.ToLower();
    var newPubkey = input.NewPubkey?.ToLower();
    
    Assert(IsCurrentCandidateOrInitialMiner(oldPubkey),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(oldPubkey) && !IsPubkeyBanned(newPubkey),
        "Pubkey is already banned.");
    
    // Permission check
    Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = oldPubkey }), "No permission.");
    
    // Use normalized pubkeys for all subsequent operations
    // ...
}
```

Apply the same normalization to:
- `SetCandidateAdmin` input validation
- `UpdateCandidateInformation` (ensure consistency)
- All other methods that accept pubkey strings as input

Alternatively, validate that input pubkeys match the expected format (lowercase hex) and reject non-conforming inputs.

## Proof of Concept

A test demonstrating this vulnerability would follow these steps:

1. Setup: Initialize election contract with initial miners
2. Set admin for initial miner using uppercase pubkey via `SetCandidateAdmin`
3. Mark miner as evil via consensus contract (ban stored lowercase)
4. Call `ReplaceCandidatePubkey` with uppercase old pubkey
5. Verify ban check is bypassed and replacement succeeds
6. Confirm miner can rejoin consensus with new pubkey

The test would validate that the ban check at [6](#0-5)  fails to detect the banned pubkey when provided in different case, allowing the replacement to proceed despite the active ban.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L33-33)
```csharp
    public MappedState<string, bool> BannedPubkeyMap { get; set; }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L24-24)
```csharp
    internal Dictionary<TKey, ValuePair> Cache = new();
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L17-17)
```csharp
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L96-96)
```csharp
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-173)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L177-177)
```csharp
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L42-42)
```csharp
        State.CandidateAdmins[pubkey] = input.Admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-63)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L79-80)
```csharp
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L16-16)
```csharp
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
```
