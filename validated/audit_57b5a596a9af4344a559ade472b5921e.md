# Audit Report

## Title
Secret Sharing Manipulation Through Selective Decrypted Piece Withholding

## Summary
The AEDPoS consensus contract contains a critical threshold mismatch in the secret sharing revelation logic. The `RevealSharedInValues()` function requires 100% miner participation to reveal InValues, despite Shamir's Secret Sharing only requiring a 2/3 threshold. This allows any single malicious miner to selectively withhold decrypted pieces, forcing targeted miners to use deterministic fake values that manipulate consensus randomness and mining order for subsequent rounds.

## Finding Description

The vulnerability stems from an architectural flaw where the on-chain revelation check is stricter than the cryptographic threshold requirement.

**Threshold Mismatch**:
The `RevealSharedInValues()` function checks if all miners (100%) have provided decrypted pieces before attempting InValue reconstruction: [1](#0-0) 

However, the underlying Shamir's Secret Sharing scheme only requires a 2/3 threshold for successful reconstruction: [2](#0-1) [3](#0-2) 

**Missing Validation**:
During the `UpdateValue` consensus behavior, miners provide decrypted pieces through `UpdateValueInput`. The processing logic accepts whatever decrypted pieces are provided without completeness validation: [4](#0-3) 

The validation provider only checks OutValue and PreviousInValue fields, not the completeness of DecryptedPieces: [5](#0-4) 

**Fake Value Fallback**:
When InValue revelation fails due to insufficient decrypted pieces, the system generates a deterministic fake value: [6](#0-5) 

This fake value is then used to calculate the signature: [7](#0-6) 

**Mining Order Manipulation**:
The signature directly determines mining order for the next round through modulo arithmetic: [8](#0-7) 

The signature calculation uses XOR with all previous signatures: [9](#0-8) 

**Attack Execution**:
1. A malicious miner's off-chain service decrypts all encrypted pieces from other miners (standard operation): [10](#0-9) 

2. The attacker calculates mining orders under two scenarios for each target miner (Scenario A: provide the piece; Scenario B: withhold the piece)

3. The attacker selectively omits decrypted pieces from their `UpdateValueInput` where withholding produces favorable mining orders

4. Since the fake value is deterministic (based on pubkey and block height), the attacker can predict exact impacts on signatures and mining order

**No Detection**:
Evil miner detection only tracks missed time slots, not decrypted piece withholding: [11](#0-10) 

## Impact Explanation

**Consensus Integrity Violation**: The mining order for round N+1 is determined by signatures calculated using InValues (or fake values) from round N. By forcing specific miners to use predictable fake values instead of their actual InValues, an attacker can influence the XOR-based signature calculation and manipulate which miners receive favorable or unfavorable mining positions.

**Economic Impact**: Mining order directly affects block reward capture frequency, transaction fee collection (earlier positions process more transactions), and the ability to produce consecutive blocks for increased revenue.

**Protocol Invariant Break**: The secret sharing scheme is designed to ensure that as long as 2/3 of miners participate honestly, InValues can be revealed correctly. The implementation requiring 100% participation allows any single miner (even <5% of the network) to selectively block revelations, completely bypassing the intended cryptographic threshold security property.

## Likelihood Explanation

**High Likelihood** due to:

1. **Minimal Attacker Capabilities**: Any single miner in the active consensus set can execute this attack. The standard consensus node already decrypts all pieces off-chain. The attack requires only filtering which decrypted pieces to include in the on-chain transaction.

2. **Trivial Implementation**: Modify the off-chain secret sharing service to selectively filter decrypted pieces before calling `UpdateValue`, calculate expected mining orders for different withholding strategies, and submit `UpdateValueInput` with strategically omitted pieces.

3. **Zero Detection Probability**: The system cannot distinguish between an honest miner who legitimately failed to decrypt due to technical issues and a malicious miner intentionally withholding valid decryptions.

4. **Economic Rationality**: High incentive (improved mining positions increase block rewards and fee capture) with zero cost (no transaction fees, no stake slashing, no detection risk). Every round provides new manipulation opportunities.

## Recommendation

Fix the threshold mismatch by changing the revelation check to use the cryptographic threshold (2/3) instead of requiring 100% participation:

```csharp
// In RevealSharedInValues()
if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue; // Changed from minersCount
```

Additionally, implement validation in `UpdateValueValidationProvider` to verify that miners who successfully decrypted pieces for other miners in the previous round are providing those decrypted pieces in the current round. This prevents selective withholding while maintaining the 2/3 threshold property.

## Proof of Concept

A proof of concept would involve:
1. Setting up a test network with N miners (e.g., 7 miners)
2. Having one malicious miner successfully decrypt all pieces off-chain in round N-1
3. The malicious miner withholds specific decrypted pieces when calling `UpdateValue` in round N-1
4. Demonstrating that the target miner's InValue cannot be revealed in round N (due to line 36 check failing)
5. Showing that the target miner uses the deterministic fake value when producing their block in round N
6. Calculating and verifying that this fake value produces a different mining order in round N+1 compared to what would have occurred with the correct InValue
7. Confirming no evil miner detection triggers despite the selective withholding

The test would demonstrate that a single miner can manipulate mining order with zero detection, violating the 2/3 threshold security guarantee of Shamir's Secret Sharing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-293)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L101-101)
```csharp
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L127-137)
```csharp
            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
```
