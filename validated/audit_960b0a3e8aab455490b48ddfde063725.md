# Audit Report

## Title
Cross-Chain Token Creation Bypasses TokenName Length Validation Allowing Unbounded Names

## Summary
The `CrossChainCreateToken` method does not validate the `TokenName` length against the 80-character protocol limit, allowing tokens with arbitrarily large names to be created via cross-chain transfers. This creates a validation inconsistency where locally-created tokens enforce strict name length limits while cross-chain imported tokens do not.

## Finding Description

The vulnerability exists due to a validation bypass in the cross-chain token creation path compared to the local token creation path.

**Local Token Creation Path (Protected):**
The `CreateToken` method enforces token name length validation by calling `AssertValidCreateInput` [1](#0-0) , which validates that token names do not exceed the maximum length [2](#0-1) . The constant `TokenNameLength` is defined as 80 characters [3](#0-2) .

**Cross-Chain Token Creation Path (Vulnerable):**
The `CrossChainCreateToken` method constructs a `TokenInfo` object directly from the cross-chain input [4](#0-3)  and calls `RegisterTokenInfo` without any length validation [5](#0-4) . The `RegisterTokenInfo` method only validates that the `TokenName` is not empty, but does not check the maximum length [6](#0-5) .

**Root Cause:**
The cross-chain verification only validates the merkle proof cryptographically [7](#0-6) , not the semantic validity of token parameters against local chain validation rules. The protobuf definition has no length constraint on the token_name field [8](#0-7) , allowing unbounded strings to be transmitted.

**Attack Scenario:**
A malicious or compromised side chain operator can create tokens with excessively long names (e.g., 10,000+ characters) on their side chain, then use legitimate cross-chain mechanisms to propagate these tokens to the main chain. The main chain will accept them because the merkle proof is cryptographically valid, even though the token violates the protocol's semantic constraints.

## Impact Explanation

This vulnerability has **Medium severity** operational impact:

1. **Storage Bloat**: Token names of unlimited length consume excessive contract storage, permanently increasing state size. Each oversized token name represents irreversible state pollution.

2. **Gas Inefficiency**: All operations that read or write the token information (transfers, queries, approvals) will consume significantly more gas due to larger string operations, affecting all users interacting with the malicious token.

3. **UI/Display Issues**: Frontend applications and block explorers may crash or malfunction when attempting to display extremely long token names, degrading user experience across the ecosystem.

4. **Protocol Invariant Violation**: The protocol establishes a clear rule that token names should not exceed 80 characters. This inconsistency creates two classes of tokens with different validation rules, breaking the security model's uniformity.

While this does not directly enable fund theft, it represents a significant denial-of-service vector through permanent state growth and creates operational problems that cannot be easily remediated once malicious tokens are registered.

## Likelihood Explanation

The likelihood is **Medium** based on the following factors:

**Required Attacker Capabilities:**
- Control or compromise of a side chain registered in the cross-chain whitelist [9](#0-8) 
- Ability to create tokens on that side chain
- Ability to submit valid merkle proofs to the main chain

**Feasibility Assessment:**
While controlling a side chain is a high barrier, it is realistic in a multi-chain ecosystem where:
- Side chains may be operated by different organizations with varying security standards
- Malicious side chain operators could pass initial governance review
- Existing side chains could be compromised through governance attacks or security breaches
- Side chains are NOT in the protocol's trusted roles list (genesis, Parliament, consensus contracts)

The `CrossChainCreateToken` method is a public function [10](#0-9)  callable by anyone with valid merkle proofs, and the cross-chain infrastructure is operational and actively used. Once side chain access is obtained, the attack complexity is low with no sophisticated cryptographic manipulation required.

## Recommendation

Add token name length validation in the `RegisterTokenInfo` method to ensure consistency across all token creation paths:

```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
        "Invalid symbol.");
    Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
    Assert(tokenInfo.TokenName.Length <= TokenContractConstants.TokenNameLength, 
        "Token name exceeds maximum length.");
    Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
    Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
    Assert(tokenInfo.Owner != null, "Invalid owner address.");
    State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
    State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
}
```

This ensures that all tokens, regardless of their creation path (local or cross-chain), adhere to the same validation rules.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_WithExcessivelyLongTokenName_ShouldSucceed()
{
    // Setup: Generate side chain and register cross-chain addresses
    var sideChainId = await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    await RegisterMainChainTokenContractAddressOnSideChainAsync(sideChainId);

    // Create a token with an excessively long name (10,000 characters) on side chain
    var longTokenName = new string('A', 10000); // 10,000 characters - far exceeds 80 char limit
    var createTransaction = await CreateTransactionForTokenCreationWithName(
        SideChainTokenContractStub,
        SideChainTestKit.DefaultAccount.Address,
        "LONGNAME",
        longTokenName,
        SideTokenContractAddress);
    
    var executedSet = await SideChainTestKit.MineAsync(new List<Transaction> { createTransaction });
    var createResult = executedSet.TransactionResultMap[createTransaction.GetHash()];
    createResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Validate token exists on side chain
    var tokenValidationTransaction = SideChainTokenContractStub.ValidateTokenInfoExists.GetTransaction(
        new ValidateTokenInfoExistsInput
        {
            Symbol = "LONGNAME",
            TokenName = longTokenName,
            Decimals = 8,
            Issuer = SideChainTestKit.DefaultAccount.Address,
            Owner = SideChainTestKit.DefaultAccount.Address,
            IsBurnable = true,
            TotalSupply = 1000,
            IssueChainId = sideChainId
        });
    
    executedSet = await SideChainTestKit.MineAsync(new List<Transaction> { tokenValidationTransaction });
    
    // Index to main chain
    var merklePath = GetTransactionMerklePathAndRoot(tokenValidationTransaction, out var blockRoot);
    await MainAndSideIndexAsync(sideChainId, executedSet.Height, blockRoot);
    var boundParentChainHeightAndMerklePath = await GetBoundParentChainHeightAndMerklePathByHeight(executedSet.Height);
    
    // Cross-chain create token on main chain with excessively long name
    var crossChainCreateTokenInput = new CrossChainCreateTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = boundParentChainHeightAndMerklePath.BoundParentChainHeight,
        TransactionBytes = tokenValidationTransaction.ToByteString(),
        MerklePath = merklePath
    };
    
    // This should fail due to token name length but will succeed - demonstrating the vulnerability
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainCreateTokenInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify the token with 10,000 character name was registered on main chain
    var mainChainTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "LONGNAME"
    });
    mainChainTokenInfo.TokenName.Length.ShouldBe(10000); // Exceeds 80 char limit
}
```

This test demonstrates that a token with a 10,000-character name can bypass the 80-character limit via `CrossChainCreateToken`, while the same token created locally via `CreateToken` would be rejected.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L50-50)
```csharp
        AssertValidCreateInput(input, symbolType);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-478)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L488-488)
```csharp
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L508-508)
```csharp
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L274-277)
```csharp
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L5-5)
```csharp
    public const int TokenNameLength = 80;
```

**File:** protobuf/token_contract_impl.proto (L255-255)
```text
    string token_name = 2;
```
