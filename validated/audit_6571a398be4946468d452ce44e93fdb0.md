# Audit Report

## Title
Unvalidated RevealedInValues Allow PreviousInValue Poisoning Leading to Miner DoS

## Summary
The AEDPoS consensus contract accepts `RevealedInValues` from block producers without cryptographic validation and uses them to set other miners' `PreviousInValue` fields. A malicious consensus miner can inject fake revealed values to poison victim miners' state, causing their subsequent blocks to fail validation. This enables targeted denial-of-service attacks against specific miners.

## Finding Description

The vulnerability exists in the secret sharing mechanism where off-chain cryptographic validation is not enforced on-chain.

**Root Cause**: The `UpdateLatestSecretPieces()` function directly applies `RevealedInValues` from trigger information to other miners' `PreviousInValue` fields without any cryptographic validation. [1](#0-0) 

The trigger information is created off-chain by the block producer's node software, where `SecretSharingService` performs proper cryptographic validation using Shamir's Secret Sharing. [2](#0-1) 

However, a malicious miner can modify their node software to replace these cryptographically validated values with arbitrary fake values before signing the block. [3](#0-2) 

**Missing Validation**: The consensus validation only checks the block producer's own `PreviousInValue`, not the `RevealedInValues` they provide for other miners. [4](#0-3) 

The validation uses `validationContext.SenderPubkey` (line 38), validating only the block producer's data, not the revealed values for victims.

**Why Protection Fails**: Once a `PreviousInValue` is set (even to a fake value), the conditional check in `ApplyNormalConsensusData` prevents legitimate updates. [5](#0-4) 

**Attack Execution**:
1. Victim miner misses a mining round (PreviousInValue becomes Hash.Empty)
2. Malicious miner M modifies their node to provide fake `RevealedInValues[Victim] = FakeHash`
3. M produces a block; `UpdateLatestSecretPieces` applies `FakeHash` to Victim's `PreviousInValue` without validation
4. Block passes validation (only M's own data is validated)
5. When Victim tries to mine, their correct `PreviousInValue` cannot overwrite `FakeHash` due to the Hash.Empty check
6. Victim's block validation fails at line 48 of UpdateValueValidationProvider because `HashHelper.ComputeFrom(FakeHash) != Victim.PreviousOutValue`
7. Victim's block is rejected, they lose rewards

## Impact Explanation

**Consensus Integrity Impact**: Malicious miners can arbitrarily prevent specific victim miners from producing valid blocks, directly violating consensus fairness guarantees. The attack enables targeted exclusion of competing miners from block production.

**Economic Impact**: Victim miners lose block production rewards for each rejected block. The validation failure prevents `ProducedBlocks` increment while `MissedTimeSlots` increases, affecting reputation metrics and potentially future mining slot assignments.

**Operational Impact**: Network throughput is reduced if multiple miners are targeted. The attack creates unpredictability in consensus operations and can persist across multiple rounds.

**Affected Parties**: Individual miners who missed mining in previous rounds become vulnerable. The network overall experiences reduced reliability, and token holders may experience delays in transaction finality.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must be an authorized consensus miner (high privilege but within the adversarial threat model for Byzantine fault-tolerant consensus systems). They must modify their node software to inject fake `RevealedInValues` - a simple code change requiring no cryptographic expertise.

**Attack Complexity**: LOW - The attacker only needs to modify trigger information generation before producing a block. No timing precision or multi-step coordination is required.

**Feasibility Conditions**: 
- Victim must have missed mining in a previous round (common due to network issues, maintenance, or restarts)
- Attacker must produce a block before victim in the subsequent round
- Secret sharing must be enabled (configuration-dependent) [6](#0-5) 

**Detection Constraints**: While theoretically detectable by comparing on-chain `RevealedInValues` with legitimate secret sharing reconstruction, detection is post-facto. No in-contract prevention mechanism exists, and victims have no recourse once poisoned.

**Probability**: MEDIUM-HIGH - Miners routinely miss rounds due to operational issues. Malicious miners in competitive scenarios have strong economic incentives to exclude competitors.

## Recommendation

Add on-chain cryptographic validation of `RevealedInValues` before applying them to miners' `PreviousInValue` fields. The contract should verify that revealed values are cryptographically correct using the same Shamir's Secret Sharing validation that exists off-chain.

Specifically:
1. In `UpdateLatestSecretPieces`, add validation that checks if sufficient decrypted pieces exist for each revealed value
2. Use `SecretSharingHelper.DecodeSecret` (similar to `RevealSharedInValues` method) to cryptographically verify each revealed value
3. Only apply verified revealed values to `PreviousInValue` fields
4. Alternatively, remove the direct application of `RevealedInValues` and rely solely on the `RevealSharedInValues` method during round transitions

Reference the secure implementation pattern: [7](#0-6) 

## Proof of Concept

```csharp
[Fact]
public async Task PreviousInValuePoisoning_Attack_Test()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeConsensusAsync();
    
    // Round 1: Victim miner misses their mining slot
    // Their PreviousInValue remains Hash.Empty
    
    // Round 2: Malicious miner produces block with fake RevealedInValues
    var maliciousMiner = InitialCoreDataCenterKeyPairs[0];
    var victimMiner = InitialCoreDataCenterKeyPairs[1];
    KeyPairProvider.SetKeyPair(maliciousMiner);
    
    // Create trigger with fake revealed value for victim
    var fakeRevealedValue = HashHelper.ComputeFrom("fake_value");
    var trigger = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(maliciousMiner.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        InValue = HashHelper.ComputeFrom("malicious_in_value")
    };
    trigger.RevealedInValues.Add(victimMiner.PublicKey.ToHex(), fakeRevealedValue);
    
    // Malicious miner produces block - fake value gets applied
    await AEDPoSContractStub.GetConsensusExtraData.CallAsync(trigger.ToBytesValue());
    
    // Verify victim's PreviousInValue is now poisoned with fake value
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var victimInfo = currentRound.RealTimeMinersInformation[victimMiner.PublicKey.ToHex()];
    victimInfo.PreviousInValue.ShouldBe(fakeRevealedValue);
    
    // Victim tries to mine with correct value - validation will fail
    KeyPairProvider.SetKeyPair(victimMiner);
    var correctInValue = HashHelper.ComputeFrom("correct_victim_value");
    var victimTrigger = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(victimMiner.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        InValue = correctInValue,
        PreviousInValue = fakeRevealedValue // Cannot override, stuck with fake value
    };
    
    // Validation fails because hash(fakeRevealedValue) != victim's previous OutValue
    var validationResult = await ValidateConsensusBeforeExecutionAsync(victimTrigger);
    validationResult.Success.ShouldBeFalse();
    validationResult.Message.ShouldContain("Incorrect previous in value");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L175-176)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L38-52)
```csharp
            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
