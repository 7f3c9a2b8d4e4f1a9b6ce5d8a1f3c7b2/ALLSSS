# Audit Report

## Title
Missing Option Length Validation in Vote Contract Registration Allows Permanent Storage Bloat

## Summary
The `Register()` function in the Vote contract does not validate the length of individual option strings when creating a voting item, while `AddOption()`, `AddOptions()`, `RemoveOption()`, and `Vote()` all enforce the 1024-character limit defined in the contract constants. This inconsistency allows attackers to register voting items with arbitrarily long option strings, causing permanent blockchain storage bloat that cannot be cleaned up.

## Finding Description

The vulnerability exists in the `Register()` function where options are directly copied from input without any length validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem()` called during registration only validates timestamps and voting item uniqueness, but does not check option lengths. [2](#0-1) 

In contrast, the `AssertOption()` validation function enforces the 1024-character limit defined in constants. [3](#0-2) [4](#0-3) 

The `AddOption()` function enforces the length limit through `AssertOption()`. [5](#0-4) 

The `RemoveOption()` function also enforces the length limit **before** checking if the option exists, which creates a permanent lock situation where oversized options cannot be removed. [6](#0-5) 

The `Vote()` function validates option length through `AssertValidVoteInput()`, preventing votes on oversized options. [7](#0-6) 

This inconsistency breaks the contract's intended invariant that all options must be â‰¤ 1024 characters. Once an oversized option is registered, it creates a permanent inconsistent state because:
1. The option exists in storage
2. It cannot be voted on (Vote validates length)
3. It cannot be removed (RemoveOption validates length before checking existence)

## Impact Explanation

**Storage Bloat**: An attacker can register voting items with option strings containing millions of characters, consuming excessive blockchain storage that all nodes must maintain permanently.

**Permanent Pollution**: The oversized options become permanently stuck in the blockchain state. To remove an option, the sponsor must provide the exact string to `RemoveOption()`, but if the string exceeds 1024 characters, the transaction fails at the length validation check (line 307) before even checking if the option exists (line 308).

**Useless Voting Items**: The voting items become non-functional because users cannot vote for the oversized options (Vote() validates length at line 380), and the sponsor cannot clean up the options (RemoveOption() validates length at line 307). The voting item persists in storage but serves no purpose.

**Cost to Network**: This is a griefing attack vector where malicious actors can bloat the blockchain state at relatively low cost (only transaction fees), affecting all node operators who must store this data permanently. The impact scales with the number of oversized options registered.

## Likelihood Explanation

**Reachable Entry Point**: The `Register()` function is a public method callable by any user. [8](#0-7) 

**Low Preconditions**: The only requirement is that the accepted currency token must be in the whitelist, which is checked at lines 29-34. [9](#0-8)  For common tokens like the native token, this requirement is trivially satisfied.

**Simple Execution**: An attacker simply needs to:
1. Prepare a `VotingRegisterInput` with valid timestamps and accepted currency
2. Include one or more option strings exceeding 1024 characters
3. Call `Register()` 
4. Pay only the standard transaction fee

**No Detection**: The `AssertValidNewVotingItem()` helper only validates voting item uniqueness and timestamps - there is no check that would prevent or detect oversized options before they are permanently stored.

## Recommendation

Add option length validation in the `Register()` function before storing the voting item. The fix should validate each option in the input against the `OptionLengthLimit` constant, similar to how `AddOption()` and `AddOptions()` validate options.

Recommended fix in `Register()` method:
```csharp
public override Empty Register(VotingRegisterInput input)
{
    var votingItemId = AssertValidNewVotingItem(input);

    // Add validation for option lengths
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
    }

    // ... rest of the method
}
```

Alternatively, modify `AssertValidNewVotingItem()` to validate option lengths:
```csharp
private Hash AssertValidNewVotingItem(VotingRegisterInput input)
{
    var votingItemId = input.GetHash(Context.Sender);
    Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");
    
    // Validate option lengths
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
    }

    if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;
    Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
    
    return votingItemId;
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task Register_WithOversizedOptions_ShouldStoreAndCannotRemove()
{
    // Arrange
    var oversizedOption = new string('A', 2000); // 2000 characters, exceeds 1024 limit
    var input = new VotingRegisterInput
    {
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(7),
        AcceptedCurrency = "ELF",
        TotalSnapshotNumber = 1,
        Options = { oversizedOption }
    };

    // Act - Register succeeds without validation
    var result = await VoteContractStub.Register.SendAsync(input);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Get the voting item ID
    var votingItemId = input.GetHash(DefaultSender);
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput 
    { 
        VotingItemId = votingItemId 
    });

    // Assert - Oversized option is stored
    votingItem.Options.Count.ShouldBe(1);
    votingItem.Options[0].Length.ShouldBe(2000);

    // Attempt to remove - fails due to length validation
    var removeResult = await VoteContractStub.RemoveOption.SendWithExceptionAsync(new RemoveOptionInput
    {
        VotingItemId = votingItemId,
        Option = oversizedOption
    });
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeResult.TransactionResult.Error.ShouldContain("Invalid input");

    // Attempt to vote - fails due to length validation
    var voteResult = await VoteContractStub.Vote.SendWithExceptionAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = oversizedOption,
        Amount = 100
    });
    voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.TransactionResult.Error.ShouldContain("Invalid input");

    // The oversized option is permanently stuck in storage
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L29-34)
```csharp
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```
