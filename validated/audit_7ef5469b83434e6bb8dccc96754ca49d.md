# Audit Report

## Title
Chain ID Spoofing in Cross-Chain Token Verification Enables Unlimited Token Minting

## Summary
The `CrossChainReceiveToken` function in the MultiToken contract accepts a user-controlled `FromChainId` parameter that directly determines which chain's merkle root is used for transaction verification, without validating that this chain ID matches the actual source of the cross-chain transfer. An attacker controlling any indexed side chain can exploit this to mint unlimited tokens by providing their compromised chain ID and forged merkle proofs.

## Finding Description

The vulnerability exists in the cross-chain token verification flow where the source chain ID is treated as a trusted user input rather than being validated or derived from authenticated data.

In `CrossChainReceiveToken`, the user-provided `input.FromChainId` is used to retrieve the registered token contract address, but there is no validation that this chain ID corresponds to the actual source chain of the transfer. [1](#0-0) 

This `FromChainId` is then passed directly to the `CrossChainVerify` helper function, which constructs a `VerifyTransactionInput` with `VerifiedChainId` set to the user-provided value. [2](#0-1) 

The `VerifyTransaction` function in the CrossChain contract uses this `VerifiedChainId` to select which merkle root to verify against by calling `GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight)`. [3](#0-2) 

The `GetMerkleTreeRoot` function returns different merkle roots based on the chain ID: parent chain merkle root if it matches `State.ParentChainId.Value`, side chain merkle root if the chain exists in `State.SideChainInfo`, or cousin chain merkle root otherwise. [4](#0-3) 

**Attack Scenario:**
1. Attacker compromises or controls a side chain that is indexed by the main chain (e.g., through weak validators or governance)
2. Attacker creates a fake `CrossChainTransfer` transaction on their controlled side chain with any desired amount and recipient
3. Attacker crafts a valid merkle proof for this fake transaction (possible because they control the side chain's block production and merkle tree construction)
4. Attacker calls `CrossChainReceiveToken` on the main chain with:
   - `FromChainId` set to their controlled side chain ID
   - `ParentChainHeight` set to a height where their side chain data is indexed
   - `MerklePath` containing the forged proof
5. Verification passes because it checks against the attacker's controlled side chain merkle root
6. Tokens are minted to the attacker's chosen address

The system fails to validate that the `FromChainId` parameter matches the actual source chain where the `CrossChainTransfer` event was originally fired. The `CrossChainTransfer` event includes `ToChainId` but not `FromChainId` because the source is implicitly the current chain. [5](#0-4) 

## Impact Explanation

**Critical Impact - Token Supply Integrity Breach:**

This vulnerability allows an attacker who controls any single indexed side chain to mint unlimited tokens of any symbol on any connected chain, causing:

1. **Unlimited Token Inflation**: The attacker can mint arbitrary amounts of any token, completely breaking the token supply guarantees. Since verification passes for any indexed side chain the attacker controls, there is no practical limit to the exploitation.

2. **Economic Collapse**: Massive token inflation destroys the economic value of legitimate token holdings through dilution. Token holders lose value without any legitimate burn or transfer occurring.

3. **Cross-Chain Trust Model Failure**: The security guarantee that cross-chain token transfers must correspond to legitimate burns on the source chain is completely violated. The entire cross-chain token system becomes untrustworthy.

4. **Cascade Effect**: Since any indexed side chain can be used to mint tokens on any other chain, a single compromised side chain compromises the entire ecosystem of connected chains.

**Affected Parties:**
- All token holders on chains that accept cross-chain transfers
- The economic integrity of the entire AElf ecosystem
- Any applications or protocols built on top of these tokens

## Likelihood Explanation

**HIGH Likelihood:**

1. **Attack Preconditions Are Realistic:**
   - Only requires compromising ONE side chain in the ecosystem (not the main chain)
   - Side chains may have varying security levels - weaker side chains are easier targets
   - The attacker needs standard transaction submission capabilities (no special privileges)

2. **Growing Attack Surface:**
   - As the ecosystem grows and more side chains are added, the probability that at least one becomes compromised increases significantly
   - Each new side chain represents a potential attack vector

3. **Simple Exploitation Path:**
   - No complex cryptographic attacks needed
   - No race conditions or timing dependencies
   - Straightforward parameter substitution in a public function call
   - The test suite demonstrates that side chain verification with custom `VerifiedChainId` is a supported use case [6](#0-5) 

4. **Economic Incentives:**
   - Attack cost: Compromising one side chain (may be achievable through governance attacks, validator collusion, or exploiting side chain vulnerabilities)
   - Attack benefit: Unlimited value extraction through token minting
   - The risk/reward ratio strongly favors attackers

5. **No Detection Mechanisms:**
   - No validation exists to detect chain ID substitution
   - The attack appears as legitimate cross-chain activity from the system's perspective
   - Retrospective detection would require off-chain analysis of indexed data

## Recommendation

Implement proper validation of the source chain ID in cross-chain token transfers:

**Solution 1 - Remove User-Controlled Chain ID (Recommended):**
Modify `CrossChainReceiveToken` to derive the source chain ID from the indexed block data rather than accepting it as a parameter. When a side chain block is indexed, the chain ID is already recorded in the `SideChainBlockData`. The verification should:
1. Look up which chain(s) have indexed data at the given `ParentChainHeight`
2. Search through those chains for the transaction ID
3. Use the chain ID where the transaction is actually found for verification

**Solution 2 - Add Chain ID Validation:**
If the API must remain unchanged for compatibility, add validation that the provided `FromChainId` matches the chain where the transaction was actually indexed:
1. After merkle proof verification succeeds, query the indexed side chain data
2. Confirm that the transaction exists in the merkle tree of the specified `FromChainId`
3. Reject if the transaction is not found or exists in a different chain's data

**Solution 3 - Require Additional Proof:**
Include authenticated chain ID information in the cross-chain transfer data itself (e.g., signed by the source chain's consensus) and validate it matches the `FromChainId` parameter.

The recommended approach is Solution 1 as it eliminates the root cause by not trusting user-provided chain IDs for security-critical decisions.

## Proof of Concept

The vulnerability can be demonstrated by extending the existing test suite:

```csharp
[Fact]
public async Task CrossChainReceiveToken_ChainIdSpoofing_Attack()
{
    // Setup: Initialize main chain and two side chains (A and B)
    var mainChainId = ChainHelper.ConvertBase58ToChainId("AELF");
    var sideChainA_Id = await CreateSideChainAsync(); // Attacker controls this
    var sideChainB_Id = await CreateSideChainAsync(); // Legitimate side chain
    
    // Attacker creates fake transaction on side chain A
    var fakeTransferTx = CreateFakeCrossChainTransferTransaction(
        from: attackerAddress,
        to: victimAddress, 
        amount: 1_000_000_000, // 1 billion tokens
        symbol: "ELF",
        toChainId: mainChainId
    );
    
    // Attacker crafts merkle proof on their controlled side chain A
    var attackerMerklePath = GenerateMerklePathOnControlledChain(
        sideChainA_Id, 
        fakeTransferTx
    );
    
    // Index side chain A's data (including attacker's fake transaction)
    var indexHeight = await IndexSideChainDataAsync(sideChainA_Id);
    
    // Attack: Call CrossChainReceiveToken with side chain A's ID
    var result = await TokenContractStub.CrossChainReceiveToken.SendAsync(
        new CrossChainReceiveTokenInput
        {
            FromChainId = sideChainA_Id, // Attacker specifies their chain
            ParentChainHeight = indexHeight,
            TransferTransactionBytes = fakeTransferTx.ToByteString(),
            MerklePath = attackerMerklePath
        }
    );
    
    // Verification: Attack succeeds - tokens are minted
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = victimAddress,
        Symbol = "ELF"
    });
    balance.Balance.ShouldBe(1_000_000_000); // Tokens illegitimately minted
}
```

This test demonstrates that by controlling a side chain and providing its chain ID as `FromChainId`, an attacker can mint tokens without any legitimate burn occurring on the claimed source chain.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L560-584)
```csharp
    public override Empty CrossChainTransfer(CrossChainTransferInput input)
    {
        Assert(!IsInTransferBlackListInternal(Context.Sender), "Sender is in transfer blacklist.");
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        AssertValidMemo(input.Memo);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == input.IssueChainId, "Incorrect issue chain id.");
        var burnInput = new BurnInput
        {
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol
        };
        Burn(burnInput);
        Context.Fire(new CrossChainTransferred
        {
            From = Context.Sender,
            To = input.To,
            Symbol = tokenInfo.Symbol,
            Amount = input.Amount,
            IssueChainId = input.IssueChainId,
            Memo = input.Memo,
            ToChainId = input.ToChainId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-617)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs (L1674-1695)
```csharp
        {
            // side chain verification
            var merklePath = sideChainTxStatusMerkleTree.GenerateMerklePath(2);
            merklePath.MerklePathNodes.Add(new MerklePathNode
            {
                Hash = sideChainTxStatusMerkleTree.Root,
                IsLeftChildNode = true
            });

            {
                var verificationInput = new VerifyTransactionInput
                {
                    TransactionId = sideChainTxId,
                    ParentChainHeight = blockHeight,
                    Path = merklePath,
                    VerifiedChainId = sideChainId
                };

                var txRes = await CrossChainContractStub.VerifyTransaction.SendAsync(verificationInput);
                var verified = BoolValue.Parser.ParseFrom(txRes.TransactionResult.ReturnValue).Value;
                verified.ShouldBeTrue();
            }
```
