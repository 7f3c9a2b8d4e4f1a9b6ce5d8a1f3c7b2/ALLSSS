# Audit Report

## Title
Non-Retroactive Vote Weight Updates Allow Early Voters to Maintain Permanently Inflated Profit Shares After Interest Rate Decreases

## Summary
When governance decreases vote weight interest rates via `SetVoteWeightInterest()`, existing votes retain their original (higher) weights calculated under previous rates, while new votes receive lower weights for identical economic commitments. This creates permanent unfairness in welfare profit distribution, as vote weights are calculated once at voting time and never retroactively adjusted.

## Finding Description

The vulnerability stems from the interaction between three contract mechanisms that fail to maintain economic fairness when interest rate parameters change:

**Mechanism 1: Interest Rate Updates Without Retroactive Effect**

The `SetVoteWeightInterest()` function updates global interest rate parameters but contains no logic to recalculate existing vote weights: [1](#0-0) 

This function simply updates `State.VoteWeightInterestList.Value` without iterating through existing votes.

**Mechanism 2: One-Time Weight Calculation at Voting**

When users vote, the weight is calculated once using current interest rates and stored permanently as profit shares: [2](#0-1) 

The `GetVotesWeight()` function applies compound interest formula using the current `VoteWeightInterestList`: [3](#0-2) 

This calculated weight becomes the beneficiary's shares in the welfare profit scheme via `AddBeneficiaryToVoter()`.

**Mechanism 3: Permanent Weight Preservation**

Vote weights stored as shares persist unchanged throughout the vote's lifetime. Even when `ExtendVoterWelfareProfits()` is called during vote target changes, the shares remain constant: [4](#0-3) 

The function passes the original `electionVotingRecord.Weight` to `FixProfitDetail`, which explicitly preserves shares: [5](#0-4) 

The `FixProfitDetail()` method clones the existing detail and only updates period boundaries (lines 297-301), never recalculating the shares value.

**Evidence of Abandoned Fix Implementation**

The protocol definition includes a `FixTotalWeightsInput` message that was never implemented: [6](#0-5) 

Additionally, a `WeightsAlreadyFixedMap` state variable exists but is never set to `true` anywhere in the codebase: [7](#0-6) [8](#0-7) 

The variable is only checked and removed, suggesting functionality that was planned but never completed.

## Impact Explanation

This vulnerability creates **systematic unfairness** in the welfare profit distribution mechanism:

**Quantified Impact Example:**
- Governance decreases 365-day interest rate from `Interest=1, Capital=1000` to `Interest=1, Capital=10000`
- Early voter who locked 1,000,000 tokens for 365 days receives weight ≈ 1,440,000 shares
- New voter with identical stake and duration receives weight ≈ 1,037,000 shares  
- **Result**: Early voter receives ~39% more welfare profits for the same commitment

**Affected Parties:**
- All new voters receive disproportionately lower profit shares compared to legacy voters
- Welfare profit distribution becomes inequitable and undermines protocol fairness guarantees
- Governance authority over economic parameters is effectively bypassed for existing votes

**Severity Justification (High):**
- Affects core economic incentive mechanism
- Creates permanent two-tier system until old votes naturally expire (no self-correcting mechanism)
- Undermines governance's ability to adjust economic parameters uniformly
- Quantifiable advantage can range from 1.5x to 10x depending on the magnitude of rate changes
- Persists indefinitely without manual intervention

## Likelihood Explanation

**Exploitation Path:**
1. Monitor governance proposals for interest rate decreases
2. Call `Vote()` with maximum amount and longest lock time before proposal execution
3. Maintain inflated weight throughout lock period automatically

**Feasibility Assessment:**
- **Entry Point**: `Vote()` function is public and unrestricted (only requires valid candidate and lock time) [9](#0-8) 

- **Preconditions**: Only requires governance decision to decrease interest rates (realistic economic adjustment)
- **Execution Complexity**: Single transaction, no special permissions needed
- **Cost**: Requires locking capital, which is returned after lock period with bonus profits

**Probability Assessment (High):**
- Front-running governance proposals is trivial on public blockchains
- Rational economic actors will naturally maximize returns under available rules
- Every interest rate decrease will affect multiple voters
- Issue persists across all future rate changes until fixed

## Recommendation

Implement a mechanism to retroactively recalculate vote weights when interest rates change:

1. **Complete the `FixTotalWeights` functionality**: Implement the unfinished `FixTotalWeightsInput` method to allow retroactive weight adjustments:
   - Accept list of vote IDs to recalculate
   - For each vote, recalculate weight using current interest rates
   - Update profit scheme shares via `FixProfitDetail`
   - Mark as fixed in `WeightsAlreadyFixedMap`

2. **Automatic recalculation on rate changes**: In `SetVoteWeightInterest()`, either:
   - Queue all active votes for weight recalculation, or
   - Emit an event requiring governance to call `FixTotalWeights` for active votes

3. **Migration strategy**: Provide a one-time governance action to recalculate all existing vote weights to current standards.

## Proof of Concept

This vulnerability can be demonstrated by:

1. Creating two votes with identical parameters (amount, lock duration) but at different times
2. Changing interest rates via `SetVoteWeightInterest()` between the two votes
3. Observing that both votes have different weights (shares) in the profit scheme
4. When profits are distributed, confirming the first voter receives disproportionately higher rewards

The test would show that `GetVotesWeight()` returns different values for identical inputs before and after `SetVoteWeightInterest()` is called, and these differences permanently affect profit distribution through the welfare scheme.

## Notes

This is a **legitimate high-severity vulnerability** that breaks economic fairness guarantees. The presence of unimplemented `FixTotalWeightsInput` and unused `WeightsAlreadyFixedMap` strongly indicates this was recognized during development but left incomplete. The issue affects the core incentive mechanism and undermines governance authority over economic parameters, making it a systemic concern that requires immediate attention.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-443)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L665-669)
```csharp
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** protobuf/election_contract.proto (L46-50)
```text
    // Used for voting for a candidate to be elected. The tokens you vote with will be locked until the end time. 
    // According to the number of token you voted and its lock time, you can get corresponding weight for 
    // sharing the bonus in the future. And return the vote id.
    rpc Vote (VoteMinerInput) returns (aelf.Hash) {
    }
```

**File:** protobuf/election_contract.proto (L530-533)
```text
message FixTotalWeightsInput {
    repeated aelf.Hash vote_ids = 1;
    
}
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L99-99)
```csharp
    public MappedState<Hash, bool> WeightsAlreadyFixedMap { get; set; }
```
