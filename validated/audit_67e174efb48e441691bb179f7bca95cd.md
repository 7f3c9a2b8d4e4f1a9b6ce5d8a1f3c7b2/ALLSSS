# Audit Report

## Title
Integer Overflow in GetMiningInterval() Enables Consensus Disruption via Malicious Round Submission

## Summary
The `GetMiningInterval()` method performs an unsafe cast from `long` to `int` without overflow protection. A malicious miner can submit a `NextRoundInput` with `ExpectedMiningTime` intervals exceeding `int.MaxValue`, causing integer overflow that disrupts time slot validation and propagates to subsequent rounds, potentially halting consensus progression.

## Finding Description

The vulnerability exists in the interaction between round validation and mining interval retrieval in the AEDPoS consensus mechanism.

**Root Cause - Unsafe Type Cast:**

The `GetMiningInterval()` method casts a `long` value from `Milliseconds()` to `int` without bounds checking. [1](#0-0)  The `Milliseconds()` extension method can return values up to `long.MaxValue`. [2](#0-1) 

When the interval exceeds `int.MaxValue` (2,147,483,647 milliseconds), the cast produces a negative value due to two's complement overflow. Even after `Math.Abs()`, the resulting value is incorrect (e.g., 3,000,000,000 ms becomes 1,294,967,296 ms).

**Insufficient Validation:**

The `CheckRoundTimeSlots()` validation operates on `long` values and only validates that intervals are positive and relatively equal, without checking if they exceed `int` range. [3](#0-2) 

**Attack Execution Path:**

1. A malicious miner submits `NextRound` via the public method [4](#0-3) 

2. The transaction passes through `ProcessConsensusInformation` [5](#0-4) 

3. `TimeSlotValidationProvider` validates the new round by calling `CheckRoundTimeSlots()` [6](#0-5) 

4. The round passes validation and gets stored [7](#0-6) 

5. Subsequently, `CheckMinerTimeSlot()` calls the vulnerable `GetMiningInterval()` to calculate time slot boundaries [8](#0-7) 

6. The overflowed interval corrupts the `endOfExpectedTimeSlot` calculation, causing legitimate miners to fail validation

**Propagation Mechanism:**

The corrupted interval propagates to future rounds because `GenerateNextRoundInformation()` retrieves the mining interval and uses it to calculate `ExpectedMiningTime` for all miners in the next round. [9](#0-8) 

## Impact Explanation

**Consensus Integrity Violation:**
The attack breaks the fundamental time slot validation mechanism. Legitimate miners fail `CheckMinerTimeSlot()` validation because the time slot window is calculated using the overflowed interval value. The validation window becomes incorrect, causing valid blocks to be rejected as "time slot already passed."

**Network-Wide Availability Impact:**
All honest miners are unable to produce valid blocks once the corrupted round becomes active. The blockchain cannot progress, transactions remain unconfirmed, and the entire network enters a halted state.

**Cascade and Persistence:**
The corrupted interval propagates through `GenerateNextRoundInformation()` to all subsequent rounds, making the issue persistent across multiple rounds. Recovery requires either governance intervention to update the consensus contract or manual chain state manipulation.

**Severity Assessment:**
This represents a high-impact consensus availability attack. While it requires miner privileges, the execution is straightforward, the impact is immediate and network-wide, and recovery is non-trivial.

## Likelihood Explanation

**Attacker Prerequisites:**
The attacker must be an active miner in the current or previous round's miner list, verified by `PreCheck()`. [10](#0-9)  This is achievable for elected miners.

**Attack Complexity:**
Low. The attacker crafts a `NextRoundInput` protobuf message with `ExpectedMiningTime` timestamps spaced more than `int.MaxValue` milliseconds apart. [11](#0-10)  The message passes all validation logic because `CheckRoundTimeSlots()` validates intervals as `long` values.

**Execution Feasibility:**
- No special blockchain state required
- Single transaction execution via public `NextRound` method
- Deterministic outcome
- No additional timing constraints

**Detection and Recovery:**
The attack becomes evident when subsequent blocks fail validation, but by then the corrupted round is already in state. There is no built-in recovery mechanism.

## Recommendation

Add bounds checking to validate that mining intervals do not exceed `int.MaxValue` before storing round information:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    // ADD THIS CHECK
    if (baseMiningInterval > int.MaxValue)
        return new ValidationResult { Message = "Mining interval exceeds maximum allowed value." };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        
        // ADD THIS CHECK
        if (miningInterval > int.MaxValue)
            return new ValidationResult { Message = "Mining interval exceeds maximum allowed value." };
            
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, change `GetMiningInterval()` to return `long` instead of `int` and update all calling code to handle `long` values consistently.

## Proof of Concept

```csharp
[Fact]
public async Task IntegerOverflow_ConsensusHalt_Attack()
{
    // Setup: Initialize consensus with normal miners
    var miners = GenerateMiners(3);
    await InitializeConsensus(miners);
    
    // Attack: Malicious miner crafts NextRoundInput with intervals > int.MaxValue
    var maliciousRound = new Round
    {
        RoundNumber = 2,
        TermNumber = 1,
        RealTimeMinersInformation = { }
    };
    
    var baseTime = TimestampHelper.GetUtcNow();
    // Set intervals to 3,000,000,000 milliseconds (~35 days) - exceeds int.MaxValue
    long maliciousInterval = 3_000_000_000L;
    
    for (int i = 0; i < miners.Count; i++)
    {
        maliciousRound.RealTimeMinersInformation.Add(miners[i], new MinerInRound
        {
            Pubkey = miners[i],
            Order = i + 1,
            ExpectedMiningTime = baseTime.AddMilliseconds(maliciousInterval * (i + 1))
        });
    }
    
    var maliciousInput = NextRoundInput.Create(maliciousRound, GenerateRandomNumber());
    
    // Execute attack
    var result = await MinerKeyPairs[0].ExecuteConsensusContractMethodAsync(
        ConsensusMethod.NextRound,
        maliciousInput
    );
    
    // Verify: CheckRoundTimeSlots passes (validates as long)
    Assert.True(maliciousRound.CheckRoundTimeSlots().Success);
    
    // Verify: GetMiningInterval returns corrupted value due to overflow
    int corruptedInterval = maliciousRound.GetMiningInterval();
    Assert.True(corruptedInterval < maliciousInterval); // Overflow occurred
    Assert.Equal(1_294_967_296, corruptedInterval); // Actual corrupted value
    
    // Verify: Consensus halts - subsequent miners cannot produce valid blocks
    var nextMinerResult = await MinerKeyPairs[1].ExecuteConsensusContractMethodAsync(
        ConsensusMethod.UpdateValue,
        CreateUpdateValueInput()
    );
    
    // Validation fails due to corrupted interval in CheckMinerTimeSlot
    Assert.Contains("Time slot already passed", nextMinerResult.Error);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L71-76)
```csharp
    public static long Milliseconds(this Duration duration)
    {
        return duration.Seconds > long.MaxValue.Div(1000)
            ? long.MaxValue
            : duration.Seconds.Mul(1000).Add(duration.Nanos.Div(1000000));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-87)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }

        var miningInformationUpdated = new MiningInformationUpdated
        {
            // _processingBlockMinerPubkey is set during PreCheck.
            Pubkey = _processingBlockMinerPubkey,
            Behaviour = callerMethodName,
            MiningTime = Context.CurrentBlockTime,
            BlockHeight = Context.CurrentHeight,
            PreviousBlockHash = Context.PreviousBlockHash
        };
        Context.Fire(miningInformationUpdated);
        Context.LogDebug(() => $"Synced mining information: {miningInformationUpdated}");

        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);

        if (TryToGetCurrentRoundInformation(out var currentRound))
            Context.LogDebug(() =>
                $"Current round information:\n{currentRound.ToString(_processingBlockMinerPubkey)}");

        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");

        if (!State.IsMainChain.Value && currentRound.RoundNumber > 1) Release();

        // Clear cache.
        _processingBlockMinerPubkey = null;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```
