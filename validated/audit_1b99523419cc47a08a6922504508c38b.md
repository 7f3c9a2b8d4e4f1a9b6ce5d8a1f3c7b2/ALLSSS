# Audit Report

## Title
Association Contract Threshold Validation Allows Governance Deadlock

## Summary
The `Validate(Organization)` function in the Association contract fails to enforce a critical combined constraint on voting thresholds, allowing creation of organizations where proposals can enter permanent deadlock states. When threshold configuration satisfies `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = organizationMemberCount + 1`, proposals become undecidable, violating the governance determinism invariant.

## Finding Description

The validation logic only checks two independent pairwise constraints [1](#0-0)  but does not validate that the combined sum prevents deadlock scenarios where all three threshold boundaries are simultaneously reached.

The proposal release determination uses asymmetric inequality operators: rejection [2](#0-1)  and abstention checks [3](#0-2)  use strict inequality (`>`), while approval uses non-strict inequality [4](#0-3)  (`>=`). This asymmetry creates a gap where proposals become undecidable.

**Concrete Example:**
With 10 members, `MinimalApprovalThreshold = 5`, `MaximalRejectionThreshold = 3`, `MaximalAbstentionThreshold = 3`:
- Passes validation: Both checks satisfy `3+5=8≤10`
- With votes distributed as 4 approvals, 3 rejections, 3 abstentions:
  - NOT rejected: `rejectionMemberCount (3) > MaximalRejectionThreshold (3)` → false
  - NOT abstained: `abstentionMemberCount (3) > MaximalAbstentionThreshold (3)` → false  
  - NOT approved: `approvedMemberCount (4) >= MinimalApprovalThreshold (5)` → false

The `IsReleaseThresholdReached` check returns false [5](#0-4) , causing the `Release` method to revert [6](#0-5)  with "Not approved."

## Impact Explanation

**HIGH Severity - Governance DoS**

1. **Permanent Proposal Lockup**: Proposals in deadlocked organizations cannot be released. The only escape is proposal expiration via `ClearProposal` [7](#0-6) , which blocks time-sensitive governance actions.

2. **Self-Healing Impossible**: Organizations fix thresholds via `ChangeOrganizationThreshold` [8](#0-7) , which requires `Context.Sender` to be the organization address—meaning it must execute through a proposal. If the fix-threshold proposal deadlocks, the organization is permanently broken.

3. **Protocol Invariant Violation**: The governance system guarantees that with full participation, proposals reach deterministic outcomes. This vulnerability breaks that fundamental guarantee.

4. **Widespread Applicability**: Any Association organization can be affected, including those controlling critical protocol parameters or treasury funds throughout the AElf ecosystem.

## Likelihood Explanation

**HIGH Likelihood**

1. **Public Entry Point**: `CreateOrganization` is a public method [9](#0-8)  callable by any user without authorization checks.

2. **No Economic Barrier**: Organization creation requires no stake, deposit, or approval from any governance entity.

3. **Simple Configuration**: The deadlock condition `R + A + M = N + 1` is straightforward to calculate and can occur in legitimate threshold designs (e.g., "require 50% approval, tolerate 30% rejection and 30% abstention").

4. **Detection Difficulty**: The validation passes during creation [10](#0-9) , and deadlock only manifests during voting, making it extremely hard to detect preventatively.

5. **Realistic Scenario**: Organizations designed with seemingly reasonable thresholds can inadvertently create deadlock configurations.

## Recommendation

Add a combined constraint validation that ensures the sum of all three thresholds cannot exceed the organization member count:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           // NEW: Combined constraint to prevent deadlock
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

Alternatively, make all three checks use consistent inequality operators (all strict or all non-strict) to eliminate the gap.

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_DeadlockConfiguration_Test()
{
    // Create organization with deadlock-prone thresholds
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { 
                Accounts[0].Address, Accounts[1].Address, Accounts[2].Address,
                Accounts[3].Address, Accounts[4].Address, Accounts[5].Address,
                Accounts[6].Address, Accounts[7].Address, Accounts[8].Address,
                Accounts[9].Address // 10 members total
            }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5,
            MinimalVoteThreshold = 10,
            MaximalAbstentionThreshold = 3,
            MaximalRejectionThreshold = 3
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Accounts[0].Address }
        }
    };
    
    // Organization creation succeeds (validation passes)
    var createResult = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var organizationAddress = createResult.Output;
    
    // Create a proposal
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        Params = new TransferInput { To = Accounts[0].Address, Symbol = "ELF", Amount = 100 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    };
    var proposalResult = await GetAssociationContractStub(Accounts[0].KeyPair).CreateProposal.SendAsync(proposalInput);
    var proposalId = proposalResult.Output;
    
    // 4 members approve
    await GetAssociationContractStub(Accounts[0].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractStub(Accounts[1].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractStub(Accounts[2].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractStub(Accounts[3].KeyPair).Approve.SendAsync(proposalId);
    
    // 3 members reject
    await GetAssociationContractStub(Accounts[4].KeyPair).Reject.SendAsync(proposalId);
    await GetAssociationContractStub(Accounts[5].KeyPair).Reject.SendAsync(proposalId);
    await GetAssociationContractStub(Accounts[6].KeyPair).Reject.SendAsync(proposalId);
    
    // 3 members abstain
    await GetAssociationContractStub(Accounts[7].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractStub(Accounts[8].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractStub(Accounts[9].KeyPair).Abstain.SendAsync(proposalId);
    
    // Verify deadlock: Release should fail with "Not approved."
    var releaseResult = await GetAssociationContractStub(Accounts[0].KeyPair).Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved.");
    
    // Verify proposal cannot be released despite full participation
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBe(false); // Deadlocked!
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L38-38)
```csharp
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L44-44)
```csharp
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L51-51)
```csharp
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L77-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```
