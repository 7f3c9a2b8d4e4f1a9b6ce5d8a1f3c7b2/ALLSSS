# Audit Report

## Title
Permissionless Proposal Deletion Enables Griefing of Approved Governance Actions Across All Governance Contracts

## Summary
A critical timing vulnerability exists in all three AElf governance contracts (Association, Parliament, and Referendum) where the `ClearProposal()` function allows any address to permanently delete expired proposals without authorization, while the `Release()` function rejects proposals at the exact moment of expiration. This creates a zero-width window enabling griefing attacks that can permanently block approved governance actions.

## Finding Description

The vulnerability stems from inconsistent expiration time checks across proposal deletion and release operations in all three governance contracts.

**In Association Contract:**

The `ClearProposal()` function allows anyone to delete proposals when the expiration time is reached, requiring only `Context.CurrentBlockTime >= proposal.ExpiredTime` with no authorization checks. [1](#0-0) 

However, the `Release()` function calls `GetValidProposal()` [2](#0-1) , which internally validates using a strict less-than check. The `GetValidProposal()` method asserts `Validate(proposal)` must be true [3](#0-2) , and `Validate()` returns false when `Context.CurrentBlockTime >= proposal.ExpiredTime` because it requires `Context.CurrentBlockTime < proposal.ExpiredTime` [4](#0-3) .

**In Parliament Contract:**

The same pattern exists with `ClearProposal()` allowing permissionless deletion at expiration [5](#0-4) , while `Release()` uses `GetValidProposal()` [6](#0-5) , which validates via `CheckProposalNotExpired()` requiring `Context.CurrentBlockTime < proposal.ExpiredTime` [7](#0-6) .

**In Referendum Contract:**

The identical vulnerability exists with permissionless `ClearProposal()` [8](#0-7)  and strict expiration validation in `Validate()` that returns false when `Context.CurrentBlockTime >= proposal.ExpiredTime` [9](#0-8) .

**Root Cause:** At exactly `CurrentBlockTime == ExpiredTime`, proposals transition from "cannot be released" (due to strict `<` check) to "can be deleted by anyone" (due to `>=` check), creating a zero-width griefing window with no grace period or authorization requirement.

## Impact Explanation

This vulnerability enables **HIGH severity** denial-of-service attacks against the entire governance system:

**Direct Governance Disruption:**
- Approved proposals that reached voting thresholds can be permanently deleted before execution
- Organization members' voting efforts and transaction fees are wasted
- Time-critical governance actions (emergency responses, parameter updates, fund transfers) can be blocked

**Systemic Impact:**
- Affects all three governance mechanisms (Association, Parliament, Referendum)
- Creates griefing opportunities for malicious actors or competing interests
- Undermines trust in the governance process
- No recovery mechanism exists - deleted proposals cannot be restored

**Who Is Affected:**
- Proposers who worked to achieve approval but faced legitimate delays
- Organization members whose votes are nullified
- Entire organizations whose governance processes are disrupted
- Beneficiaries of proposed actions who lose expected outcomes

The impact qualifies as HIGH because it breaks governance availability guarantees and can cause operational DoS without requiring privileged access.

## Likelihood Explanation

The likelihood of exploitation is **HIGH** due to multiple realistic factors:

**Low Attack Complexity:**
- Single transaction call to `ClearProposal(proposalId)` with no authorization required
- Minimal gas cost (single storage deletion)
- Can be easily automated with monitoring scripts
- No special permissions or tokens needed

**Realistic Delay Scenarios:**
Proposers may legitimately fail to release before expiration due to:
- Network congestion causing transaction delays
- Gas price spikes making immediate release expensive
- Proposer not actively monitoring the exact expiration timestamp
- Time zone differences or human unavailability
- Block production timing uncertainty in AEDPoS consensus

**No Prevention Mechanisms:**
- No on-chain warning system before proposals become vulnerable
- Proposer cannot "lock in" their release intention
- No grace period between expiration and deletion eligibility
- No special handling for approved proposals vs rejected ones

The attack is highly feasible whether executed maliciously or occurring accidentally through automated cleanup scripts.

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Add Grace Period**
Modify `ClearProposal()` to require a grace period after expiration:
```csharp
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    var gracePeriod = new Duration { Seconds = 86400 }; // 24 hours
    Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime.Add(gracePeriod), 
        "Proposal clear failed");
    State.Proposals.Remove(input);
    return new Empty();
}
```

**Option 2: Align Expiration Checks**
Change `Validate()` methods to use `<=` instead of `<` for consistency:
```csharp
private bool Validate(ProposalInfo proposal)
{
    // ... other checks ...
    return proposal.ExpiredTime != null && Context.CurrentBlockTime <= proposal.ExpiredTime;
}
```

**Option 3: Restrict ClearProposal Authorization**
Require proposer or organization authority to delete proposals:
```csharp
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
    Assert(Context.Sender == proposal.Proposer || 
           Context.Sender == proposal.OrganizationAddress, "No permission to clear");
    State.Proposals.Remove(input);
    return new Empty();
}
```

**Recommended Approach:** Implement Option 1 (grace period) combined with Option 3 (authorization) for defense-in-depth.

## Proof of Concept

```csharp
[Fact]
public async Task ProposalGriefingAtExactExpiration_Test()
{
    // Setup: Create organization and proposal
    var organizationAddress = await CreateAssociationOrganization();
    var proposalId = await CreateProposal(organizationAddress, expiredTime: currentBlockTime + 100);
    
    // Members vote and approve the proposal
    await ApproveWithMembers(proposalId);
    
    // Advance to exact expiration time
    AdvanceBlockTime(100); // Now CurrentBlockTime == ExpiredTime
    
    // Attacker attempts to clear proposal (should succeed)
    var clearResult = await AssociationContractStub.ClearProposal.SendAsync(proposalId);
    clearResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Proposer attempts to release (should fail - proposal deleted)
    var releaseResult = await AssociationContractStub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid proposal id");
    
    // Verify proposal is permanently deleted
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ProposalId.ShouldBe(Hash.Empty); // Proposal no longer exists
}
```

## Notes

This vulnerability affects all production deployments of AElf governance contracts. The zero-width timing window is deterministic and exploitable. Organizations relying on these contracts for critical governance operations should implement emergency procedures until a fix is deployed. The vulnerability does not require any special privileges and can be triggered by any address, making it a serious availability threat to the governance system.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L101-107)
```csharp
    private ProposalInfo GetValidProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        Assert(proposal != null, "Invalid proposal id.");
        Assert(Validate(proposal), "Invalid proposal.");
        return proposal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```
