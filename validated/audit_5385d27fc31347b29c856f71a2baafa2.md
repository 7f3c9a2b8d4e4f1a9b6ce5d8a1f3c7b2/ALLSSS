# Audit Report

## Title
Continuous Block Limit Bypass via Public Key Replacement

## Summary
A miner can bypass the AEDPoS consensus continuous block production limit (8 blocks) by strategically replacing their public key. The `RecordCandidateReplacement` method updates round information but fails to update `State.LatestPubkeyToTinyBlocksCount`, causing validation checks to be skipped and the block counter to reset instead of decrement. This allows a malicious miner to produce significantly more continuous blocks than intended by using a series of fresh keypairs.

## Finding Description

The vulnerability exists in the interaction between the Election contract's key replacement mechanism and the AEDPoS consensus validation system.

**Entry Point:** The `ReplaceCandidatePubkey` method allows any candidate admin to replace their public key: [1](#0-0) 

This invokes `PerformReplacement`, which calls the consensus contract: [2](#0-1) 

**Core Issue:** The `RecordCandidateReplacement` method updates `RealTimeMinersInformation` but critically fails to update `State.LatestPubkeyToTinyBlocksCount`: [3](#0-2) 

After this executes, `State.LatestPubkeyToTinyBlocksCount` still references the old pubkey while the miner's identity in the round has been updated to the new key.

**Validation Bypass:** The `ContinuousBlocksValidationProvider` checks continuous block limits by comparing pubkeys: [4](#0-3) 

When pubkeys don't match (old key stored vs. new key producing block), the `BlocksCount < 0` check is skipped entirely. The `SenderPubkey` is validated to match the block signer: [5](#0-4) [6](#0-5) 

**Counter Reset:** After validation, `ResetLatestProviderToTinyBlocksCount` executes: [7](#0-6) 

When stored pubkey doesn't match current producer (line 352), the else branch (lines 358-363) resets the counter to `minersCountInTheory.Sub(1)` instead of decrementing it.

**Maximum Block Limit:** The intended limit is defined as: [8](#0-7) 

**Attack Flow:**
1. Miner produces blocks with key_1, counter decrements: 7→6→5...→1
2. Before reaching 0, call `ReplaceCandidatePubkey(key_1, key_2)`
3. Produce next block with key_2: validation bypassed, counter resets to 7
4. Repeat with key_3, key_4, etc.

**Constraints:** Old keys are banned after replacement: [9](#0-8) 

However, fresh keys are unlimited. Code inspection confirms no rate limiting or cooldown on replacements exists.

## Impact Explanation

This vulnerability breaks a core consensus security guarantee. The continuous block limit exists to prevent centralization and ensure fair block production rotation among miners.

**Quantified Impact:**
- Normal limit: 8 continuous blocks per miner
- With N prepared keypairs: ~8 + 7*(N-1) continuous blocks
- Example: 10 keypairs = ~71 blocks vs. intended 8 blocks (787% increase)

**Concrete Harms:**
1. **Unfair Mining Advantage**: Attacker gains disproportionate block production opportunities
2. **Reward Misallocation**: More blocks means more mining rewards, directly extracting value from honest miners
3. **Centralization Risk**: Single miner can dominate block production, defeating the decentralization purpose of the limit
4. **Network Security Degradation**: The continuous block limit was designed to reduce fork risks and improve network resilience

All honest miners suffer reduced mining opportunities and rewards. The entire network's decentralization and consensus security guarantees are weakened.

## Likelihood Explanation

**Reachable Entry Point:** `ReplaceCandidatePubkey` requires only candidate admin authorization: [10](#0-9) 

Every miner controls their own candidate admin by default.

**Attacker Requirements:**
- Control of candidate admin address (standard for any participating miner)
- Preparation of multiple fresh keypairs (cryptographically trivial, zero marginal cost)
- Timing of replacements during mining time slots (straightforward with known consensus schedule)

**Execution Feasibility:**
- No technical barriers beyond standard miner capabilities
- No rate limiting or protective constraints in the code
- Clear economic incentive: additional block rewards

**Probability Assessment:** Medium-High likelihood. The attack is technically straightforward with clear financial incentive, requiring only premeditation and preparation of multiple keypairs.

## Recommendation

Update `RecordCandidateReplacement` to synchronize `State.LatestPubkeyToTinyBlocksCount` when updating miner information:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // ADD THIS: Update LatestPubkeyToTinyBlocksCount to maintain continuous block tracking
    var latestCount = State.LatestPubkeyToTinyBlocksCount.Value;
    if (latestCount != null && latestCount.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = latestCount.BlocksCount
        };
    }

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Additionally, consider implementing a cooldown period or rate limit on key replacements to prevent rapid successive replacements.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimitBypass_ViaKeyReplacement_Test()
{
    // Setup: Initialize consensus with a miner
    var minerKeyPair1 = ValidationDataCenterKeyPairs[0];
    var minerKeyPair2 = ValidationDataCenterKeyPairs[1];
    var minerKeyPair3 = ValidationDataCenterKeyPairs[2];
    
    // Miner produces blocks with key1 until counter is low (e.g., 2 blocks remaining)
    // Track that LatestPubkeyToTinyBlocksCount.BlocksCount is decreasing
    
    // Replace key1 with key2
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair1.PublicKey.ToHex(),
        NewPubkey = minerKeyPair2.PublicKey.ToHex()
    });
    
    // Produce blocks with key2 - validation should bypass and counter should reset
    // Verify that continuous block production continues beyond 8 blocks total
    
    // Replace key2 with key3 and repeat
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair2.PublicKey.ToHex(),
        NewPubkey = minerKeyPair3.PublicKey.ToHex()
    });
    
    // Assert: Total continuous blocks produced > 8 (the intended limit)
    // This proves the bypass allows exceeding MaximumTinyBlocksCount
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L14-17)
```csharp
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
