# Audit Report

## Title
Inconsistent Null Handling in GetProfitDetails Causes DoS in TokenHolder and Election Contracts

## Summary
The `GetProfitDetails()` view method in the Profit contract returns `null` when querying non-existent beneficiaries without any defensive handling, while the similar `GetAllProfitsMap()` method explicitly checks for null cases. This inconsistency causes `NullReferenceException` crashes in multiple critical callers including `TokenHolderContract.AddBeneficiary`, `TokenHolderContract.RemoveBeneficiary`, and `ElectionContract` methods, creating a denial-of-service condition that prevents legitimate profit distribution operations.

## Finding Description

The root cause is the `GetProfitDetails` view method that directly returns the nested dictionary lookup result without null checking: [1](#0-0) 

When a beneficiary doesn't exist in the scheme's `ProfitDetailsMap`, AElf's `MappedState` returns `null`, as confirmed by the state definition: [2](#0-1) 

In contrast, the similar `GetAllProfitsMap` method properly handles null cases with an explicit guard: [3](#0-2) 

This inconsistency causes crashes in multiple critical callers:

**TokenHolderContract.AddBeneficiary** crashes when adding a new beneficiary because it accesses `.Details.Any()` without null checking: [4](#0-3) 

**TokenHolderContract.RemoveBeneficiary** crashes when attempting to remove a non-existent beneficiary by immediately chaining `.Details.Single()`: [5](#0-4) 

**ElectionContract.GetProfitDetailByElectionVotingRecord** crashes when processing voting records for new voters by accessing `.Details.FirstOrDefault()` on a null object: [6](#0-5) 

The Profit contract's own `AddBeneficiary` method demonstrates the correct defensive pattern: [7](#0-6) 

## Impact Explanation

**Operational Denial-of-Service Impact:**

1. **TokenHolder schemes**: Scheme managers cannot add new beneficiaries to their profit schemes. The first `AddBeneficiary` call for any new address triggers a `NullReferenceException`, causing the transaction to fail and permanently blocking this core functionality until the view method is fixed.

2. **Election system**: Vote processing operations that query profit details for voters who haven't been registered yet will fail, disrupting the election reward distribution mechanism and potentially blocking voting operations.

3. **Profit scheme management**: Attempting to remove beneficiaries that don't exist causes crashes, though this is a less critical user-error scenario.

**Affected Parties:**
- TokenHolder scheme managers and participants who cannot add beneficiaries or manage profit distributions
- Election voters and reward recipients experiencing disrupted reward mechanisms  
- Any external contracts calling `GetProfitDetails` without implementing their own null guards

**Severity:** This breaks core economic functionality (profit distribution, staking rewards, election rewards) across multiple critical system contracts, preventing legitimate users from participating in the protocol's incentive mechanisms. While no funds are at risk, the availability of essential operations is compromised.

## Likelihood Explanation

**High Likelihood - Triggered During Normal Operations:**

All affected methods are public contract methods callable by regular users:
- `TokenHolderContract.AddBeneficiary` is callable by any scheme manager
- `TokenHolderContract.RemoveBeneficiary` is callable by scheme managers
- Election contract methods are triggered during standard voting operations

**Minimal Preconditions:** Simply calling `AddBeneficiary` with a new beneficiary address (the expected and normal use case) triggers the vulnerability. No special attack construction or privileged access is needed.

**Execution Practicality:** The bug manifests during legitimate operations—the first time anyone tries to add a new beneficiary to a TokenHolder profit scheme, the transaction fails with a `NullReferenceException`.

**Economic Rationality:** No attack cost required—this occurs naturally during normal operations. While a malicious scheme manager could intentionally DoS their own scheme, the primary concern is that any legitimate user will encounter this when performing standard profit scheme management.

**Detection:** The bug is deterministic and reproducible. Every `AddBeneficiary` call for a non-existent beneficiary will fail consistently.

## Recommendation

Add null checks to `GetProfitDetails` to return an empty `ProfitDetails` object when the beneficiary doesn't exist, matching the defensive pattern used in `GetAllProfitsMap`:

```csharp
public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
{
    var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    return profitDetails ?? new ProfitDetails();
}
```

Alternatively, add null checks in all calling contracts before accessing the `.Details` property, though fixing the root cause in the view method is the cleaner solution that prevents future issues.

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_NullReference_Test()
{
    // Create a TokenHolder profit scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });

    // Attempt to add a NEW beneficiary that doesn't exist in ProfitDetailsMap yet
    // This should trigger NullReferenceException when GetProfitDetails returns null
    // and AddBeneficiary tries to access detail.Details.Any()
    var result = await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(), // New beneficiary, not in ProfitDetailsMap
        Shares = 100
    });
    
    // Expected: Transaction should succeed
    // Actual: Transaction fails with NullReferenceException
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

The vulnerability is confirmed by comparing the defensive null handling in `GetAllProfitsMap` with the missing null check in `GetProfitDetails`. The Profit contract's own `AddBeneficiary` method also demonstrates proper null checking, establishing that this is a known pattern that was simply not applied consistently to the view method. This affects multiple critical system contracts and should be addressed to restore availability of profit distribution functionality.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L103-110)
```csharp
    private GetAllProfitsMapOutput GetAllProfitsMap(Hash schemeId, Address beneficiary, string symbol = null)
    {
        var scheme = State.SchemeInfos[schemeId];
        Assert(scheme != null, "Scheme not found.");
        beneficiary = beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L13-13)
```csharp
    public MappedState<Hash, Address, ProfitDetails> ProfitDetailsMap { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-46)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-78)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-177)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```
