# Audit Report

## Title
NFT Metadata Loss When Re-minting Burned Tokens with IsTokenIdReuse Enabled

## Summary
When `IsTokenIdReuse` is true and all tokens of a specific token ID are burned (quantity reaches 0), subsequent re-minting of the same token ID ignores the new minter's Uri, Metadata, and Alias inputs, causing permanent loss of intended NFT data. Additionally, the `NFTMinted` event emits the new metadata values while the actual on-chain state retains the old metadata, creating a critical state-event inconsistency.

## Finding Description

The vulnerability exists in the `PerformMint` function when handling re-minting scenarios for protocols with `IsTokenIdReuse = true` (ERC-1155 style NFTs). [1](#0-0) 

**Root Cause:**

When burning tokens in a protocol with `IsTokenIdReuse = true`, if the quantity reaches 0, the NFTInfo entry remains in `NftInfoMap` with quantity=0 but the `IsBurned` flag is NOT set: [2](#0-1) 

**Execution Path:**

1. On re-minting, `PerformMint` retrieves the existing NFTInfo from state: [3](#0-2) 

2. The uniqueness check is skipped when `IsTokenIdReuse` is true: [4](#0-3) 

3. Fresh metadata is prepared by merging protocol metadata with input metadata: [5](#0-4) 

4. **CRITICAL BUG:** When `nftInfo` is not null (existing entry), the code enters the else block which ONLY updates Quantity and Minters, completely ignoring the prepared metadata, uri, and alias: [6](#0-5) 

5. The NFTInfo with old metadata is saved to state: [7](#0-6) 

6. **STATE-EVENT MISMATCH:** The `NFTMinted` event uses the NEW metadata values from input, creating a critical discrepancy: [8](#0-7) 

**Why Protections Fail:**

The code prepares fresh metadata (lines 408-413) but never applies it when `nftInfo` already exists. There is no check for whether the existing NFTInfo has quantity=0 (fully burned state), which should trigger metadata updates rather than just quantity additions.

## Impact Explanation

**Direct Harm:**
- **Data Loss:** Minters lose their intended NFT metadata, URI, and alias completely. This data cannot be recovered through normal minting operations, only through the separate `Recast` function which requires specific conditions (ownership of all tokens).
- **Financial Loss:** Users pay transaction fees to mint NFTs but receive tokens with incorrect/unintended metadata that doesn't match their expectations or input parameters.
- **State-Event Inconsistency:** Off-chain systems, NFT marketplaces, and blockchain explorers reading `NFTMinted` events will display different metadata than what exists on-chain. This creates widespread confusion and breaks the fundamental AElf guarantee that events accurately reflect state changes.

**Attack Scenario:**
1. Attacker creates an NFT protocol with `IsTokenIdReuse = true`
2. Attacker mints tokenId 1 with malicious metadata (e.g., fake rarity claims, misleading artwork URLs, inappropriate content)
3. Attacker burns all tokens (quantity = 0)
4. Victim attempts to mint tokenId 1 with legitimate metadata
5. Victim's mint succeeds but inherits attacker's malicious metadata on-chain
6. Events show victim's metadata, but all on-chain queries return attacker's metadata
7. NFT marketplaces display victim's metadata from events while actual token state contains malicious data

**Affected Parties:**
- NFT minters who re-mint burned token IDs lose their intended token data
- NFT marketplaces and explorers display inconsistent information
- NFT buyers receive misrepresented assets
- Protocol creators lose user trust due to data integrity issues

**Severity:** Medium-High due to guaranteed data loss on realistic user flows (burn-then-remint operations), state corruption, and potential for malicious exploitation.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Minting permissions in an NFT protocol (normal user privilege granted by protocol creator)
- Ability to burn tokens (standard protocol feature when `IsBurnable = true`)
- No special privileges, governance control, or system access needed

**Attack Complexity:**
- Simple 3-step process: mint → burn all → wait for victim to remint same token ID
- No timing windows or complex state manipulation required
- Executable entirely through standard public contract methods
- Can even occur accidentally when multiple minters in a protocol independently mint/burn/remint the same token IDs

**Feasibility Conditions:**
- Protocols with `IsTokenIdReuse = true` are affected (ERC-1155 style is a common NFT pattern)
- Token IDs being fully burned and then re-minted is a realistic scenario in dynamic NFT systems
- The vulnerability is triggered automatically without requiring any special conditions

**Detection Constraints:**
- The state-event inconsistency makes detection extremely difficult
- No error or warning is generated during the transaction
- Contract execution succeeds normally with a successful return value
- Off-chain systems have no indication that the stored metadata differs from event metadata

**Probability:** HIGH - This occurs naturally whenever anyone re-mints a fully burned token ID in any protocol with `IsTokenIdReuse = true`. The vulnerability is triggered by normal user operations, not malicious actions.

## Recommendation

Modify the `PerformMint` function to detect when re-minting a fully burned token (quantity = 0) and update all metadata fields in that case:

```csharp
else
{
    nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
    if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
    
    // If quantity was 0 (fully burned), update metadata/uri/alias from new mint
    if (nftInfo.Quantity == quantity) // quantity was 0 before this addition
    {
        nftInfo.Metadata = nftMetadata;
        if (input.Uri != null) nftInfo.Uri = input.Uri;
        if (input.Alias != null) nftInfo.Alias = input.Alias;
    }
}
```

Alternatively, create a separate code path for re-minting burned tokens:
```csharp
if (nftInfo == null || (nftInfo.Quantity == 0 && protocolInfo.IsTokenIdReuse))
{
    // Create or fully reinitialize NFTInfo
    nftInfo = new NFTInfo { /* ... with all metadata fields ... */ };
}
else
{
    // Just add quantity and minters for existing non-burned tokens
    nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
    if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BurnAndRemint_MetadataLoss_Test()
{
    // Create protocol with IsTokenIdReuse = true (ERC-1155 style)
    var symbol = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://aelf/",
        Creator = DefaultAddress,
        IsBurnable = true,
        IsTokenIdReuse = true, // Enable token ID reuse
        Metadata = new Metadata { Value = { { "Protocol", "Test" } } },
        NftType = NFTType.Art.ToString(),
        ProtocolName = "REUSE_TEST",
        TotalSupply = 1000000,
        MinterList = new MinterList { Value = { DefaultAddress, MinterAddress } }
    });
    
    // Mint tokenId 1 with original metadata
    var originalMetadata = new Metadata { Value = { { "Original", "DataA" } } };
    await NFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol.Output.Value,
        TokenId = 1,
        Uri = "ipfs://original",
        Alias = "OriginalAlias",
        Metadata = originalMetadata,
        Quantity = 10
    });
    
    // Verify original metadata is stored
    var nftInfo1 = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
    {
        Symbol = symbol.Output.Value,
        TokenId = 1
    });
    nftInfo1.Metadata.Value["Original"].ShouldBe("DataA");
    nftInfo1.Uri.ShouldBe("ipfs://original");
    nftInfo1.Alias.ShouldBe("OriginalAlias");
    
    // Burn all tokens (quantity = 0)
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol.Output.Value,
        TokenId = 1,
        Amount = 10
    });
    
    // Verify quantity is 0 but NFTInfo still exists
    var burnedInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
    {
        Symbol = symbol.Output.Value,
        TokenId = 1
    });
    burnedInfo.Quantity.ShouldBe(0);
    
    // Remint tokenId 1 with NEW metadata (as different minter)
    var newMetadata = new Metadata { Value = { { "New", "DataB" } } };
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol.Output.Value,
        TokenId = 1,
        Uri = "ipfs://new",
        Alias = "NewAlias",
        Metadata = newMetadata,
        Quantity = 5
    });
    
    // BUG: On-chain state still has ORIGINAL metadata, not new metadata
    var remintedInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
    {
        Symbol = symbol.Output.Value,
        TokenId = 1
    });
    
    // VULNERABILITY: These assertions will FAIL because old metadata persists
    remintedInfo.Metadata.Value.ContainsKey("New").ShouldBe(false); // Should have "New" but doesn't
    remintedInfo.Metadata.Value["Original"].ShouldBe("DataA"); // Still has old metadata
    remintedInfo.Uri.ShouldBe("ipfs://original"); // Still has old URI (not "ipfs://new")
    remintedInfo.Alias.ShouldBe("OriginalAlias"); // Still has old Alias (not "NewAlias")
    
    // Event log would show the NEW metadata, creating state-event inconsistency
}
```

**Notes:**
- This vulnerability only affects NFT protocols where `IsTokenIdReuse = true` (ERC-1155 style collections)
- The `Recast` function exists to modify metadata, but it requires the caller to own ALL tokens of that ID, making it unusable immediately after minting to a different owner
- The state-event mismatch is particularly dangerous because it breaks the fundamental assumption that AElf events accurately represent state changes
- Off-chain indexers, marketplaces, and explorers that rely on events will show completely different NFT data than what's stored on-chain

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L99-99)
```csharp
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-463)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);

        var nftMinted = new NFTMinted
        {
            Symbol = input.Symbol,
            ProtocolName = protocolInfo.ProtocolName,
            TokenId = tokenId,
            Metadata = nftMetadata,
            Owner = owner,
            Minter = Context.Sender,
            Quantity = quantity,
            Alias = input.Alias,
            BaseUri = protocolInfo.BaseUri,
            Uri = input.Uri ?? string.Empty,
            Creator = protocolInfo.Creator,
            NftType = protocolInfo.NftType,
            TotalQuantity = nftInfo.Quantity,
            TokenHash = tokenHash
        };
        Context.Fire(nftMinted);

        return nftMinted;
    }
```
