# Audit Report

## Title
Missing Empty Address Validation in AddBeneficiary Allows Permanent Profit Loss

## Summary
The Profit contract's `AddBeneficiary` method fails to validate that beneficiary addresses have non-empty `Value` fields, only checking for null object references. Combined with missing recipient validation in the MultiToken contract's `Transfer` method, this allows scheme managers to add beneficiaries with empty addresses, causing allocated profits to be permanently locked when distributed and claimed.

## Finding Description

The vulnerability exists due to insufficient address validation at multiple points in the execution path:

**Validation Gap in AddBeneficiary:**

The `AssertValidInput` method only checks if the Address object reference is not null, but does not verify that the Address has a non-empty ByteString Value field. [1](#0-0) 

This contrasts sharply with proper validation patterns used elsewhere in the MultiToken contract, where `AssertValidInputAddress` correctly validates both the object reference AND the ByteString Value: [2](#0-1) 

**Execution Flow:**

1. A scheme manager calls `AddBeneficiary` with an Address created via `new Address()` (which has empty Value per the protobuf definition): [3](#0-2) 

2. The validation passes because the Address object is not null, and the empty address beneficiary is stored with allocated shares: [4](#0-3) 

3. When profits are claimed, the system transfers tokens via virtual inline call to the MultiToken Transfer method: [5](#0-4) 

4. The MultiToken `Transfer` method does NOT validate the recipient address - it only validates the token and amount: [6](#0-5) 

5. The internal `DoTransfer` method only checks that sender and recipient are different, but does NOT validate if the recipient address is empty: [7](#0-6) 

6. The balance is modified and stored for the empty address: [8](#0-7) 

Since no one possesses the private key for an empty address (addresses are derived from public keys using FromPublicKey or FromBytes methods that require 32-byte arrays), these tokens become permanently locked and irrecoverable. [9](#0-8) 

## Impact Explanation

**Direct Financial Loss:** Tokens allocated to the empty address beneficiary are permanently lost with no recovery mechanism. The empty address has no corresponding private key, making the tokens completely inaccessible.

**Quantified Damage:** The loss is proportional to the shares allocated to the empty address. For example, if an empty address receives 100 shares out of 1,000 total scheme shares, 10% of all distributed profits across all periods are permanently lost.

**Affected Parties:**
- All legitimate beneficiaries suffer reduced profit shares due to dilution
- The profit scheme loses assets that could have been redistributed
- Multiple distribution periods are affected until the beneficiary is detected and removed

**Severity: HIGH** - This vulnerability causes irreversible loss of funds, violates the critical invariant of profit distribution accuracy in the Economics & Treasury component, and can compound over multiple distribution periods.

## Likelihood Explanation

**Attacker Capabilities:** The attacker must be either the scheme manager (creator/owner) or the TokenHolder system contract: [10](#0-9) 

While this is a privileged role, it is commonly held by various entities managing profit schemes.

**Attack Complexity: LOW** - A single transaction to `AddBeneficiary` with `new Address()` as the beneficiary is sufficient. No complex preconditions, timing requirements, or state manipulation needed.

**Feasibility:**
- **Accidental scenario (high probability):** Programming errors in calling contracts or management interfaces that fail to properly initialize Address objects
- **Malicious scenario:** Compromised or malicious scheme manager
- **No protection:** The existing codebase demonstrates that `new Address()` is a commonly used construct for representing absent/default addresses

**Detection:** Difficult to detect until profits are distributed and claimed. Empty address entries may not be immediately visible in standard queries.

**Likelihood: MEDIUM-HIGH** - While requiring privileged access, the complete lack of validation combined with the ease of accidentally creating empty Address objects makes this highly probable in real-world usage.

## Recommendation

Add proper address validation in the `AssertValidInput` method to check for non-empty ByteString Value:

```csharp
private void AssertValidInput(AddBeneficiaryInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    Assert(input.BeneficiaryShare?.Beneficiary != null && 
           !input.BeneficiaryShare.Beneficiary.Value.IsNullOrEmpty(), 
           "Invalid beneficiary address.");
    Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
}
```

Additionally, consider adding recipient address validation in the MultiToken `Transfer` method or `DoTransfer` method to prevent system-wide issues:

```csharp
private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
{
    AssertValidInputAddress(to); // Add this validation
    Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
    Assert(from != to, "Can't do transfer to sender itself.");
    AssertValidMemo(memo);
    ModifyBalance(from, symbol, -amount);
    ModifyBalance(to, symbol, amount);
    // ... rest of method
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task EmptyAddressBeneficiary_CausesPermamentProfitLoss()
{
    // Setup: Create a profit scheme
    var schemeId = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        ProfitReceivingDuePeriodCount = 10
    });
    
    // Vulnerability: Add beneficiary with empty address
    var emptyAddress = new Address(); // Creates Address with empty ByteString Value
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId.Output,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = emptyAddress, // Empty address passes validation!
            Shares = 100
        },
        EndPeriod = long.MaxValue
    });
    
    // Distribute profits
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Claim profits - tokens transferred to empty address
    await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId.Output,
        Beneficiary = emptyAddress
    });
    
    // Verify: Tokens are now locked at empty address with no recovery
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = emptyAddress,
        Symbol = "ELF"
    });
    
    balance.Balance.ShouldBeGreaterThan(0); // Tokens locked forever!
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-215)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;

        Context.LogDebug(() =>
            $"Added {input.BeneficiaryShare.Shares} weights to scheme {input.SchemeId.ToHex()}: {profitDetail}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L887-895)
```csharp
                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** src/AElf.Types/Types/Address.cs (L37-57)
```csharp
        public static Address FromPublicKey(byte[] bytes)
        {
            var hash = bytes.ComputeHash().ComputeHash();
            return new Address(hash);
        }

        /// <summary>
        ///     Loads the content value from 32-byte long byte array.
        /// </summary>
        /// <param name="bytes"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public static Address FromBytes(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Address
            {
                Value = ByteString.CopyFrom(bytes)
            };
```
