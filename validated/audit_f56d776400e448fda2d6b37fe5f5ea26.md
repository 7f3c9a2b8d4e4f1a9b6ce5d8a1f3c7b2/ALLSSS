# Audit Report

## Title
Side Chain Miner Count Limit Bypass via Cross-Chain Synchronization

## Summary
Side chains fail to enforce the governance-configured `MaximumMinersCount` limit when synchronizing miner lists from the main chain. The cross-chain update path accepts and persists an unlimited number of miners, allowing all main chain miners to participate in side chain consensus regardless of the side chain's configured maximum, violating the intended consensus security model.

## Finding Description

The AEDPoS consensus contract on side chains does not validate incoming miner counts against the `MaximumMinersCount` parameter during cross-chain synchronization. This creates multiple enforcement gaps:

**Root Cause 1: Unvalidated Cross-Chain Update**
The `UpdateInformationFromCrossChain` method extracts all miner keys from the main chain's consensus information and stores them without checking the side chain's configured limit. [1](#0-0) 

**Root Cause 2: Unchecked Round Creation**  
The `NextTermInput.Create()` method copies all entries from `round.RealTimeMinersInformation` without validation. [2](#0-1) 

**Root Cause 3: Side Chain Fallback Path**
Side chains return false from `TryToGetVictories` because they don't use election-based miner selection. [3](#0-2)  This causes the fallback to use the current round's unvalidated miner list. [4](#0-3) 

**Root Cause 4: Unvalidated Term Processing**
`ProcessNextTerm` creates a `MinerList` from all keys in `nextRound.RealTimeMinersInformation` without checking the count limit. [5](#0-4) 

**Root Cause 5: Insufficient Validation**
The `ValidationForNextTerm` method only validates term and round number increments but does not check if the miner count exceeds `MaximumMinersCount`. [6](#0-5) 

**Critical Finding: MaximumMinersCount Only Used for Reporting**
The `GetMinersCount` method enforces `MaximumMinersCount` via `Math.Min`. [7](#0-6)  However, this method is only called for reporting to the Election contract, [8](#0-7)  not to limit actual consensus participation.

**Block Production Uses Unvalidated List**
Mining permission validation only checks if the sender exists in `RealTimeMinersInformation.Keys`. [9](#0-8)  This means all miners in the round can produce blocks regardless of the configured maximum.

## Impact Explanation

**Consensus Integrity Violation:**
Side chains can operate with arbitrarily many block producers, violating the governance-approved `MaximumMinersCount` safety parameter. If the main chain has 25 miners and the side chain's limit is 17, all 25 miners will participate in side chain consensus, breaking the intended security model.

**Concrete Harms:**
1. **Security Degradation:** More miners than intended changes the security assumptions around block finality, fork resolution, and Byzantine fault tolerance thresholds (e.g., 2f+1 honest assumption requires knowing the actual value of f)

2. **Economic Inconsistency:** The Election contract receives a capped miner count via `UpdateMinersCountToElectionContract`, but the actual consensus round operates with more miners, creating potential accounting mismatches in reward calculations and miner weight computations

3. **Governance Bypass:** The `MaximumMinersCount` parameter set by Parliament via `SetMaximumMinersCount` [10](#0-9)  becomes unenforceable on side chains, rendering governance decisions ineffective

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is not an attack but a design flaw that triggers automatically:

1. **Reachable Entry Point:** `UpdateInformationFromCrossChain` is restricted to the CrossChain contract. [11](#0-10)  It is called during routine cross-chain indexing operations.

2. **Realistic Preconditions:**
   - Side chain exists with `MaximumMinersCount` configured (standard setup)
   - Main chain has more miners than side chain's limit (common as main chains typically have larger validator sets)
   - Cross-chain indexing is active (required for normal side chain operation)

3. **Automatic Trigger:** No attacker action needed - happens during normal cross-chain synchronization whenever the main chain's miner count exceeds the side chain's configured limit

4. **Reproducible:** This is deterministic behavior, confirmed by test case showing all miners are accepted. [12](#0-11) 

## Recommendation

Add validation in `UpdateInformationFromCrossChain` to enforce the `MaximumMinersCount` limit:

```csharp
var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;

// Enforce MaximumMinersCount for side chains
if (minersKeys.Count > State.MaximumMinersCount.Value)
{
    Context.LogDebug(() => 
        $"Main chain miner count {minersKeys.Count} exceeds side chain limit {State.MaximumMinersCount.Value}");
    // Take only the first N miners or implement a selection strategy
    minersKeys = minersKeys.Take(State.MaximumMinersCount.Value).ToList();
}

State.MainChainCurrentMinerList.Value = new MinerList
{
    Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
};
```

Additionally, add validation in `ProcessNextTerm` before creating the MinerList to ensure the count never exceeds the configured maximum.

## Proof of Concept

The existing test demonstrates the vulnerability. Modify `UpdateInformationFromCrossChainTest` to verify the flaw:

```csharp
[Fact]
public async Task UpdateInformationFromCrossChain_ExceedsMaximumMinersCount()
{
    SetToSideChain();
    InitialContracts();
    
    // Set MaximumMinersCount to 2
    await ConsensusStub.SetMaximumMinersCount.SendAsync(new Int32Value { Value = 2 });
    
    var mockedCrossChain = SampleAccount.Accounts.Last();
    var mockedCrossChainStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        mockedCrossChain.KeyPair);

    // Send 5 miners from main chain (exceeds limit of 2)
    var headerInformation = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 2,
            RealTimeMinersInformation =
            {
                { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[3].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[4].KeyPair.PublicKey.ToHex(), new MinerInRound() }
            }
        }
    };

    await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(
        new BytesValue { Value = headerInformation.ToByteString() });

    var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
    
    // VULNERABILITY: All 5 miners are stored despite MaximumMinersCount=2
    minerList.Pubkeys.Count.ShouldBe(5); // Should be 2 but is 5
}
```

This test proves that `MaximumMinersCount` is not enforced during cross-chain synchronization, allowing side chains to operate with more miners than governance intended.

## Notes

This vulnerability represents a fundamental mismatch between the governance interface (which allows setting `MaximumMinersCount` on side chains) and the actual enforcement (which ignores this limit during cross-chain synchronization). Side chains always return `NextRound` behavior rather than `NextTerm`, [13](#0-12)  suggesting they are designed to follow the main chain's miner set. However, the existence of the configurable `MaximumMinersCount` parameter on side chains creates a reasonable expectation that this limit would be enforced, which it is not.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-36)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L12-12)
```csharp
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L236-241)
```csharp
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L268-272)
```csharp
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L386-390)
```csharp
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L55-60)
```csharp
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs (L79-80)
```csharp
        var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
        minerList.Pubkeys.Select(m => m.ToHex()).ShouldBe(headerInformation.Round.RealTimeMinersInformation.Keys);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```
