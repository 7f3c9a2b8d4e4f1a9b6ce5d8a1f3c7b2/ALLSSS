# Audit Report

## Title
Cross-Snapshot Withdrawal Leaves Stale Vote Counts in Subsequent Snapshots

## Summary
The `Withdraw()` function in the Vote contract only updates the voting result for the snapshot where the vote was originally cast, but fails to update subsequent snapshots that have inherited the cumulative `VotersCount` and `VotesAmount` metrics. This causes withdrawn votes to persist in later snapshots' aggregate statistics, leading to inflated governance metrics exposed by the Election contract.

## Finding Description

The vulnerability occurs due to a mismatch between how snapshots inherit cumulative data and how withdrawals update that data.

When `TakeSnapshot()` creates a new snapshot, it explicitly copies the previous snapshot's `VotersCount` and `VotesAmount` as carried-over cumulative metrics: [1](#0-0) 

However, when a voter withdraws their vote via `Withdraw()`, the function retrieves the voting result using only the snapshot number stored in the original voting record (which records the snapshot at the time of voting): [2](#0-1) [3](#0-2) 

This means `Withdraw()` only updates the voting result of the original snapshot, subtracting the withdrawn vote's amount from `VotesAmount`, `Results`, and potentially `VotersCount`: [4](#0-3) 

**Root Cause:** The withdrawal logic does not iterate through or update any subsequent snapshots that have already carried over the vote counts. Once `TakeSnapshot()` copies the cumulative counts forward, those copies become immutable with respect to withdrawals from earlier snapshots.

**Attack Scenario:**
1. Attacker votes with 10,000 tokens in snapshot N
2. Sponsor calls `TakeSnapshot()` creating snapshot N+1 (inherits VotesAmount=10,000, VotersCount=1)
3. Attacker withdraws the vote from snapshot N
4. Snapshot N correctly shows VotesAmount=0, VotersCount=0
5. Snapshot N+1 incorrectly retains VotesAmount=10,000, VotersCount=1

## Impact Explanation

The inflated metrics directly affect systems that rely on accurate voting statistics:

**1. Governance Decisions:** The Election contract exposes `GetVotersCount()` and `GetVotesAmount()` methods that query the latest voting results and return these inflated values: [5](#0-4) 

These methods call `GetLatestVotingResult` which retrieves the current snapshot's voting result: [6](#0-5) 

**2. Quorum Manipulation:** If governance decisions or reward distributions rely on voter participation thresholds, attackers can artificially inflate these metrics by voting in early snapshots, waiting for snapshot inheritance, then withdrawing while leaving later snapshots with inflated counts.

**3. Multi-Snapshot Amplification:** With multiple snapshots, a single vote can be counted multiple times across snapshots even after withdrawal, creating a multiplier effect on aggregate statistics.

While this does not cause direct fund loss, it compromises the integrity of governance metrics that external contracts, dApps, or governance mechanisms may rely upon for decision-making.

## Likelihood Explanation

**Attacker Capabilities:** Any voter can execute this - no special permissions required beyond standard voting operations.

**Attack Complexity:** Very low:
- Vote in snapshot N
- Wait for `TakeSnapshot()` to create snapshot N+1
- Call `Withdraw()` to remove the vote
- Snapshot N+1 retains inflated counts

**Feasibility:** Always feasible when:
- Voting item has multiple snapshots (`TotalSnapshotNumber > 1`)
- Token locking is enabled (voter can withdraw after snapshot) OR token locking is disabled (sponsor can withdraw on behalf)

**Detection Difficulty:** The discrepancy is not easily detectable without comparing snapshot results and tracing vote histories, as inflated values appear as normal aggregate statistics.

The existing test suite demonstrates this scenario without detecting the issue: [7](#0-6) 

The test votes, takes a snapshot at line 259, then withdraws at line 263. However, it only verifies snapshot 1's state after withdrawal (lines 270-278) but doesn't check that snapshot 2 still has the inflated counts.

## Recommendation

Modify the `Withdraw()` function to update all subsequent snapshots that have already been created. When withdrawing a vote, iterate through all snapshot numbers greater than `votingRecord.SnapshotNumber` and decrement their `VotesAmount`, `VotersCount`, and `Results` accordingly.

```csharp
// After updating the original snapshot, also update subsequent snapshots
var votingItem = State.VotingItems[votingRecord.VotingItemId];
for (long i = votingRecord.SnapshotNumber + 1; i <= votingItem.CurrentSnapshotNumber; i++)
{
    var subsequentHash = GetVotingResultHash(votingRecord.VotingItemId, i);
    var subsequentResult = State.VotingResults[subsequentHash];
    if (subsequentResult != null)
    {
        subsequentResult.Results[votingRecord.Option] = 
            subsequentResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        subsequentResult.VotesAmount = subsequentResult.VotesAmount.Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            subsequentResult.VotersCount = subsequentResult.VotersCount.Sub(1);
        State.VotingResults[subsequentHash] = subsequentResult;
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossSnapshotWithdrawalInflatesVoteCounts()
{
    // Register voting item with 3 snapshots
    var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
    var voteUser = Accounts[1].KeyPair;
    var voteItemId = registerItem.VotingItemId;
    var voteAmount = 100;
    
    // Vote in snapshot 1
    await Vote(voteUser, voteItemId, registerItem.Options[0], voteAmount);
    var voteIds = await GetVoteIds(voteUser, voteItemId);
    var voteId = voteIds.ActiveVotes.First();
    
    // Take snapshot to create snapshot 2 (copies VotersCount and VotesAmount)
    await TakeSnapshot(voteItemId, 1);
    
    // Verify snapshot 2 has inherited the counts
    var snapshot2Before = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 2,
        VotingItemId = voteItemId
    });
    snapshot2Before.VotesAmount.ShouldBe(voteAmount);
    snapshot2Before.VotersCount.ShouldBe(1);
    
    // Withdraw the vote
    await Withdraw(voteUser, voteId);
    
    // Snapshot 1 is correctly updated
    var snapshot1After = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 1,
        VotingItemId = voteItemId
    });
    snapshot1After.VotesAmount.ShouldBe(0);
    snapshot1After.VotersCount.ShouldBe(0);
    
    // BUG: Snapshot 2 still has inflated counts despite withdrawal
    var snapshot2After = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 2,
        VotingItemId = voteItemId
    });
    // This assertion will FAIL - demonstrating the vulnerability
    snapshot2After.VotesAmount.ShouldBe(0); // Expected 0, but will be 100
    snapshot2After.VotersCount.ShouldBe(0); // Expected 0, but will be 1
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L207-207)
```csharp
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-222)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L264-271)
```csharp
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-238)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }

    public override Int64Value GetVotesAmount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotesAmount
        };
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L44-53)
```csharp
    public override VotingResult GetLatestVotingResult(Hash input)
    {
        var votingItem = AssertVotingItem(input);
        var votingResultHash = new VotingResult
        {
            VotingItemId = input,
            SnapshotNumber = votingItem.CurrentSnapshotNumber
        }.GetHash();
        return State.VotingResults[votingResultHash];
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L238-281)
```csharp
    public async Task VoteContract_Withdraw_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);

        var voteUser = Accounts[1].KeyPair;
        var voteAddress = Accounts[1].Address;
        var voteItemId = registerItem.VotingItemId;
        var voteAmount = 100;
        await Vote(voteUser, voteItemId, registerItem.Options[1], voteAmount);
        var voteIds = await GetVoteIds(voteUser, voteItemId);
        var currentVoteId = voteIds.ActiveVotes.First();
        var voteRecordBeforeWithdraw = await VoteContractStub.GetVotingRecord.CallAsync(currentVoteId);
        voteRecordBeforeWithdraw.IsWithdrawn.ShouldBe(false);
        var voteItems = await VoteContractStub.GetVotedItems.CallAsync(voteAddress);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].ActiveVotes.Count.ShouldBe(1);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].WithdrawnVotes.Count.ShouldBe(0);
        var voteResultBeforeWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            SnapshotNumber = 1,
            VotingItemId = voteItemId
        });
        await TakeSnapshot(voteItemId, 1);


        var beforeBalance = GetUserBalance(voteAddress);
        var transactionResult = await Withdraw(voteUser, currentVoteId);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        voteItems = await VoteContractStub.GetVotedItems.CallAsync(voteAddress);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].ActiveVotes.Count.ShouldBe(0);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].WithdrawnVotes.Count.ShouldBe(1);
        var voteRecordAfterWithdraw = await VoteContractStub.GetVotingRecord.CallAsync(currentVoteId);
        voteRecordAfterWithdraw.IsWithdrawn.ShouldBe(true);
        var voteResultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            SnapshotNumber = 1,
            VotingItemId = voteItemId
        });
        voteResultBeforeWithdraw.VotesAmount.Sub(voteResultAfterWithdraw.VotesAmount).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.Results[registerItem.Options[1]]
            .Sub(voteResultAfterWithdraw.Results[registerItem.Options[1]]).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.VotersCount.Sub(1).ShouldBe(voteResultAfterWithdraw.VotersCount);
        var afterBalance = GetUserBalance(voteAddress);
        beforeBalance.ShouldBe(afterBalance - 100);
    }
```
