# Audit Report

## Title
Missing Signature Validation Allows Consensus Schedule Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miner-provided signatures are correctly calculated, allowing malicious miners to manipulate their mining order in the next round and control extra block producer selection. This completely undermines the consensus protocol's randomness guarantees.

## Finding Description

The vulnerability exists in how the `UpdateValue` transaction processes miner signatures. The signature field is designed to provide cryptographic randomness for determining the next round's mining schedule by XORing the miner's previous in-value with all signatures from the previous round. [1](#0-0) 

During legitimate block production, the signature is correctly calculated using `previousRound.CalculateSignature(previousInValue)`. [2](#0-1) 

However, the validation provider only checks that the signature field is non-null and non-empty, without verifying correctness against the expected calculated value. [3](#0-2) 

When processing the `UpdateValue` transaction, the signature from user input is directly assigned to the round state without any cryptographic validation that it matches the expected signature. [4](#0-3) 

This signature directly determines the miner's position in the next round through the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [5](#0-4) [6](#0-5) 

Additionally, if the attacker is the first miner in the current round, their signature determines which miner becomes the extra block producer in the next round. [7](#0-6) 

## Impact Explanation

**HIGH SEVERITY** - This vulnerability directly compromises the core consensus mechanism:

1. **Consensus Schedule Manipulation**: Miners can choose any mining order (1 to N) in the next round by selecting signature values that produce their desired modulus result. This allows strategic positioning for maximum profit or to coordinate attacks.

2. **Extra Block Producer Control**: The first miner in each round can deterministically select who becomes the extra block producer in the next round, enabling reward manipulation and potential collusion schemes.

3. **Randomness Violation**: The signature mechanism is the primary source of randomness for fair mining schedule distribution. Allowing arbitrary signatures completely eliminates this randomness, making the consensus protocol predictable and manipulable.

4. **Collusion Potential**: Multiple malicious miners can coordinate their signature values to dominate consecutive rounds, concentrating rewards and potentially enabling other attacks like censorship or double-spending attempts.

## Likelihood Explanation

**CERTAIN** - This vulnerability is trivially exploitable:

- **Entry Point**: The `UpdateValue` method is the standard transaction every miner sends during normal block production, making it constantly accessible. [8](#0-7) 

- **Preconditions**: The attacker only needs to be a valid miner in the current validator set, which is the normal operational state for any miner.

- **Execution**: The exploit requires no special timing, state manipulation, or complex transactions. The attacker simply provides an arbitrary Hash value instead of calling `CalculateSignature()` when constructing their `UpdateValueInput`. [9](#0-8) 

- **Cost**: Zero - changing a hash value in the transaction input costs nothing beyond normal transaction fees.

- **Detection**: Impossible - there is no validation logic that compares the provided signature against the expected value, so the attack is indistinguishable from legitimate behavior.

- **Success Rate**: 100% - every malicious signature is accepted and stored.

## Recommendation

Add signature correctness validation in the `UpdateValueValidationProvider`. The validator should:

1. Retrieve the previous round information
2. Calculate the expected signature using `previousRound.CalculateSignature(previousInValue)`
3. Compare the provided signature against the expected signature
4. Reject the transaction if they do not match

Example fix in `UpdateValueValidationProvider.cs`:

```csharp
private bool ValidateSignatureCorrectness(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var previousInValue = minerInRound.PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // Skip validation for first round or missing previous in value
        
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return minerInRound.Signature == expectedSignature;
}
```

Add this check to the `ValidateHeaderInformation` method after the existing checks.

## Proof of Concept

A malicious miner can exploit this by:

1. Generating a normal `UpdateValueInput` during their mining turn
2. Instead of using the correctly calculated signature from `previousRound.CalculateSignature(previousInValue)`, iterate through Hash values to find one where `hash.ToInt64() % minersCount` equals their desired position minus 1
3. Replace the signature field in `UpdateValueInput` with this crafted Hash value
4. Submit the transaction normally

The transaction will pass validation because `UpdateValueValidationProvider` only checks that the signature is non-null and non-empty. The crafted signature will be stored in state and used to determine the miner's position in the next round, allowing them to choose any mining order position they desire.

## Notes

This vulnerability fundamentally breaks the AEDPoS consensus randomness guarantees. The signature-based randomness mechanism was designed to prevent miners from predicting or manipulating their mining schedule, but the missing validation makes this protection completely ineffective. Any miner can freely choose their position in the next round by crafting appropriate signature values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-50)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
```
