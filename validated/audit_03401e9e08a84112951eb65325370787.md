# Audit Report

## Title
Continuous Block Limit Bypass via Candidate Public Key Replacement

## Summary
A miner can bypass the continuous blocks production limit (MaximumTinyBlocksCount = 8) by exploiting the candidate public key replacement mechanism. When `ReplaceCandidatePubkey` is called, the consensus contract updates round information but fails to update the `LatestPubkeyToTinyBlocksCount` state, creating a pubkey mismatch that allows validation checks to be bypassed and the counter to be reset, enabling extended continuous block production beyond the protocol limit.

## Finding Description

The AEDPoS consensus system enforces a continuous blocks limit to prevent network forks and ensure decentralization. [1](#0-0)  This limit is tracked and enforced through three critical checkpoints that all depend on public key equality comparison:

**Validation Check:** The `ContinuousBlocksValidationProvider` validates that a miner hasn't exceeded the limit by checking if the stored pubkey matches the sender's pubkey AND if the counter is negative. [2](#0-1) 

**Command Generation Check:** The `GetConsensusCommand` method forces a `NextRound` behavior when the stored pubkey matches the miner's pubkey AND the counter is negative. [3](#0-2) 

**Counter Reset Logic:** The `ResetLatestProviderToTinyBlocksCount` method either decrements the counter (if pubkeys match) or resets it to maximum value (if pubkeys differ). [4](#0-3) 

**Root Cause:** When a miner calls `ReplaceCandidatePubkey` through the Election contract [5](#0-4) , the consensus contract's `RecordCandidateReplacement` method updates the round information by swapping the old pubkey for the new one in `RealTimeMinersInformation`. [6](#0-5) 

However, `RecordCandidateReplacement` never updates `State.LatestPubkeyToTinyBlocksCount`. Verification confirms that `LatestPubkeyToTinyBlocksCount.Value` is only set in the `ResetLatestProviderToTinyBlocksCount` method, and nowhere else in the codebase updates this state during candidate replacement.

This creates a permanent mismatch where `LatestPubkeyToTinyBlocksCount.Pubkey` contains the old pubkey while the miner produces blocks with the new pubkey. When the miner produces the next block:
1. Validation passes because old_pubkey â‰  new_pubkey
2. GetConsensusCommand doesn't force NextRound because the pubkey check fails  
3. Counter resets to `minersCountInTheory - 1` instead of continuing to decrement

The old pubkey becomes banned after replacement [7](#0-6) , but a miner can prepare multiple keypairs in advance and repeat this exploit.

## Impact Explanation

**Consensus Integrity Violation:** The continuous blocks limit exists to prevent network instability and forks. The maximum blocks count is dynamically adjusted based on blockchain health to detect abnormal or severe network conditions. [8](#0-7) 

By bypassing this limit, a malicious miner can:
- Produce more continuous blocks than protocol-defined limits by repeatedly changing keys
- Defeat fork prevention mechanisms designed to protect network synchronization  
- Cause network instability for other nodes attempting to synchronize
- Violate protocol-level decentralization guarantees
- Undermine the blockchain health monitoring system

**Affected Parties:** All network participants suffer from potential network instability, increased fork risk, and compromised consensus integrity. This breaks a fundamental consensus safety mechanism that ensures no single miner can monopolize block production.

**Severity:** Medium - While this violates a critical consensus safety mechanism, it requires preparation (multiple keypairs), is visible on-chain, and doesn't directly steal funds or compromise other miners' rewards.

## Likelihood Explanation

**Attacker Capabilities:**
- Miner must control their candidate admin account (typical scenario). [9](#0-8) 
- Miner must have multiple valid keypairs prepared in advance
- Each old key becomes banned after replacement, requiring fresh keypairs for each iteration

**Attack Complexity:** Low - The attack requires only calling a public contract method (`ReplaceCandidatePubkey`) between block productions. No complex timing or state manipulation is needed.

**Feasibility:** High - Entry point is publicly accessible with no special privileges required beyond normal miner admin control. No rate limiting or cooldown period exists on key replacements. Miner can prepare multiple keypairs offline before initiating the attack.

**Detection:** Partial - Replacements are visible on-chain via `CandidatePubkeyReplaced` events [10](#0-9) . However, distinguishing legitimate replacements from exploit attempts is difficult without additional context.

**Economic Rationality:** High - The cost is minimal (only transaction fees), no collateral is at risk, and the potential advantage in block production could provide competitive benefits.

**Overall Likelihood:** Medium - Practical for any motivated miner to execute with modest preparation of multiple keypairs.

## Recommendation

Update the `RecordCandidateReplacement` method to also update `State.LatestPubkeyToTinyBlocksCount` when a candidate's public key is replaced:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // If this candidate is current miner, need to modify current round information.
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // FIX: Update LatestPubkeyToTinyBlocksCount if it contains the old pubkey
    if (State.LatestPubkeyToTinyBlocksCount.Value != null &&
        State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount
        };
    }

    // Notify Treasury Contract to update replacement information.
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

## Proof of Concept

This vulnerability can be demonstrated with a test that:
1. Has a miner produce 8 continuous blocks to reach the limit
2. Calls `ReplaceCandidatePubkey` to swap to a new key
3. Verifies that the miner can continue producing blocks with the new key, bypassing the continuous block limit
4. Shows that `LatestPubkeyToTinyBlocksCount` still contains the old pubkey while blocks are produced with the new pubkey

The test would verify that without the fix, the validation checks pass and the counter resets instead of continuing to enforce the limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L350-364)
```csharp
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-256)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-79)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```
