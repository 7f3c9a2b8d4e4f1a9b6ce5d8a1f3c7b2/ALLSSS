# Audit Report

## Title
Permanent DoS of NFT Cross-Chain Creation via Malformed Token Metadata

## Summary
The `CrossChainCreate()` function in NFTContract uses `bool.Parse()` on token metadata without validation or error handling. An attacker can bypass `NFTContract.Create()` and directly call `TokenContract.Create()` with malformed metadata, causing permanent denial-of-service for NFT protocol registration on side chains.

## Finding Description

The vulnerability exists in the NFT protocol's cross-chain registration flow where metadata value validation is missing across multiple contract layers.

**Vulnerable Code Path:**

The `CrossChainCreate()` method directly parses boolean metadata without validation: [1](#0-0) 

When C#'s `bool.Parse()` receives a value that is not "True" or "False" (case-insensitive), it throws `FormatException`.

**Bypass Mechanism:**

While `NFTContract.Create()` properly formats metadata using `ToString()`: [2](#0-1) 

Attackers can call `TokenContract.Create()` directly, which accepts arbitrary `ExternalInfo`: [3](#0-2) 

**Missing Validation:**

The metadata validation only checks keys, not values: [4](#0-3) 

Cross-chain validation only checks that metadata matches between chains, not format correctness: [5](#0-4) 

**Malformed Metadata Propagation:**

The `CrossChainCreateToken()` method directly copies the malformed metadata to the side chain: [6](#0-5) 

**Permanent DoS:**

On the side chain, the protocol registration check passes: [7](#0-6) 

But the `bool.Parse()` always fails, creating an infinite loop of failures with no recovery path.

**Attack Steps:**
1. Attacker obtains a seed NFT for symbol "AR12345" (standard NFT protocol symbol)
2. Attacker calls `TokenContract.Create()` with `ExternalInfo["aelf_nft_token_id_reuse"] = "invalid"`
3. Token is created on main chain with malformed metadata
4. When `NFTContract.CrossChainCreate()` is called on side chain, it throws `FormatException`
5. The NFT protocol can never be registered on the side chain

## Impact Explanation

**HIGH Severity** - This vulnerability enables permanent denial-of-service of NFT protocol registration on side chains:

- **Permanent DoS**: Once a token with malformed metadata exists on the main chain and is validated for cross-chain use, `CrossChainCreate()` will permanently fail. There is no method to update token `ExternalInfo` after creation (only `ExtendSeedExpirationTime` exists for seed expiration, not general metadata). [8](#0-7) 

- **Protocol-Level Impact**: The entire NFT collection becomes unusable on side chains - no minting, transferring, or burning of NFTs from that collection is possible on side chains.

- **Ecosystem Disruption**: Attackers can grief legitimate NFT projects by front-running their deployment with malformed metadata, blocking their cross-chain functionality indefinitely.

- **No Recovery Path**: The assertion at line 79 passes (protocol doesn't exist), but line 88 always fails. Cannot update metadata on main chain, cannot create with different metadata on side chain (must match via `ValidateTokenInfoExists`).

## Likelihood Explanation

**MEDIUM-to-HIGH Likelihood**:

**Attacker Requirements:**
- Obtain a seed NFT for the target symbol (costs resources but publicly available through standard mechanisms) [9](#0-8) 

- Knowledge to call `TokenContract.Create()` instead of `NFTContract.Create()`
- Craft malformed `ExternalInfo` with invalid boolean string

**Attack Complexity:** LOW-to-MEDIUM
- Single transaction on main chain
- No special privileges required beyond seed NFT ownership
- No timing constraints or race conditions

**Economic Rationality:**
- **Cost**: Price of seed NFT (variable but obtainable)
- **Gain**: Denial of competitor's cross-chain deployment, griefing valuable symbols
- **Incentive**: Competitive advantage or extortion potential

## Recommendation

Add metadata value validation in multiple layers:

1. **In TokenContract.Create()**: Validate reserved NFT metadata key values before token creation
2. **In CrossChainCreate()**: Add try-catch around `bool.Parse()` or use `bool.TryParse()` with validation
3. **Add recovery mechanism**: Implement a method to update token ExternalInfo for specific metadata fields, restricted to token owner or governance

**Example Fix for CrossChainCreate():**
```csharp
// Replace line 88 with:
if (!bool.TryParse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey], out var isTokenIdReuse))
{
    throw new AssertionException($"Invalid {NftTokenIdReuseMetadataKey} metadata value.");
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task CrossChainCreate_WithMalformedMetadata_ShouldFail()
{
    // 1. Attacker obtains seed NFT for symbol "AR12345"
    var seedSymbol = await CreateSeedNFT("AR12345");
    
    // 2. Attacker calls TokenContract.Create() directly with malformed metadata
    var createInput = new CreateInput
    {
        Symbol = "AR12345",
        TokenName = "MaliciousNFT",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = AttackerAddress,
        IsBurnable = true,
        IssueChainId = MainChainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "aelf_nft_type", "Art" },
                { "aelf_nft_base_uri", "https://example.com" },
                { "aelf_nft_token_id_reuse", "invalid" } // Malformed value
            }
        }
    };
    
    var result = await TokenContractStub.Create.SendAsync(createInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 3. Validate for cross-chain (passes - only checks metadata exists and matches)
    await TokenContractStub.ValidateTokenInfoExists.SendAsync(new ValidateTokenInfoExistsInput
    {
        Symbol = "AR12345",
        TokenName = "MaliciousNFT",
        // ... other fields match
        ExternalInfo = createInput.ExternalInfo.Value
    });
    
    // 4. On side chain, CrossChainCreate() fails permanently
    var crossChainResult = await SideChainNFTContractStub.CrossChainCreate.SendWithExceptionAsync(
        new CrossChainCreateInput { Symbol = "AR12345" }
    );
    
    // Verify FormatException is thrown at line 88 (bool.Parse)
    crossChainResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    crossChainResult.TransactionResult.Error.ShouldContain("FormatException");
    
    // 5. Verify no recovery mechanism exists - subsequent calls fail identically
    var retryResult = await SideChainNFTContractStub.CrossChainCreate.SendWithExceptionAsync(
        new CrossChainCreateInput { Symbol = "AR12345" }
    );
    retryResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

## Notes

- The vulnerability specifically targets the `aelf_nft_token_id_reuse` metadata key which is parsed as boolean, but applies to any reserved metadata key that requires format validation.
- The attack requires a seed NFT, which can be obtained through standard token creation mechanisms on the main chain.
- The permanent nature of the DoS (no recovery mechanism) significantly increases the severity.
- Similar validation gaps may exist for other metadata keys that require specific formats.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-79)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L88-88)
```csharp
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L199-199)
```csharp
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L449-456)
```csharp
        if (tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.Count > 0 ||
            input.ExternalInfo != null && input.ExternalInfo.Count > 0)
        {
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```
