# Audit Report

## Title
ConnectorController Privilege Escalation Through Unvalidated Contract Address

## Summary
The `ChangeConnectorController` method in the TokenConverter contract fails to validate that the `ContractAddress` in the new `AuthorityInfo` corresponds to a legitimate governance contract (Parliament, Association, or Referendum). This allows an entity with temporary controller access to permanently bypass all governance by pointing to a malicious contract, gaining unrestricted control over connector management, fee settings, and token conversion operations.

## Finding Description
The vulnerability exists in the `ChangeConnectorController` method, which validates new authority using only `CheckOrganizationExist(input)`. [1](#0-0) 

The `CheckOrganizationExist` method performs a cross-contract call to `ValidateOrganizationExist` on whatever `ContractAddress` is provided in the `AuthorityInfo`, without verifying this address is a legitimate governance contract. [2](#0-1) 

Legitimate governance contracts (Parliament, Association, Referendum) implement `ValidateOrganizationExist` by checking if an organization exists in their state storage. [3](#0-2)  However, an attacker can deploy a malicious contract that always returns `true`, effectively bypassing this check.

After the malicious authority is set, all protected operations use `AssertPerformedByConnectorController()`, which only verifies that `Context.Sender` matches the `OwnerAddress` in the stored authority - it does NOT consult the governance contract for proposal approval. [4](#0-3) 

**Attack Sequence:**
1. Attacker obtains temporary control of current ConnectorController (via governance vote or compromise)
2. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` to return `true` for any input
3. Attacker calls `ChangeConnectorController` with `AuthorityInfo { ContractAddress = malicious_contract, OwnerAddress = attacker_address }`
4. Validation passes because malicious contract returns `true`
5. Future operations only check if sender equals attacker_address, completely bypassing governance

This breaks the security guarantee that all critical authority changes must flow through legitimate governance organizations with proposals, voting, and thresholds.

## Impact Explanation
**Critical Severity** - The attacker gains permanent, unrestricted control over:

1. **Connector Management**: Can manipulate connector weights, virtual balances, and related symbols via `UpdateConnector` and `AddPairConnector` [5](#0-4) [6](#0-5) , directly affecting Bancor pricing calculations and liquidity

2. **Fee Control**: Can set arbitrary fee rates via `SetFeeRate` [7](#0-6) , enabling value extraction or DoS

3. **Connector Activation**: Can enable/disable connectors via `EnableConnector` [8](#0-7) , freezing token conversions

4. **Fund Risk**: Can drain reserves by manipulating connector parameters and pricing functions, or lock funds by disabling conversion paths

The impact extends beyond the TokenConverter to any protocol components relying on its pricing and conversion functionality. The governance bypass also sets a dangerous precedent that undermines the entire separation-of-powers model.

## Likelihood Explanation
**Medium-High Likelihood:**

- **Precondition**: Requires controlling the current ConnectorController, which by default is the Parliament default organization [9](#0-8) . This could be achieved through winning a governance vote, temporary compromise, or collusion within the organization.
- **Attack Complexity**: Low - requires only deploying a simple malicious contract and calling one method
- **Detection**: The attack would be visible on-chain but cannot be prevented by the contract itself
- **No Existing Protections**: There is no whitelist, no validation against known governance contract addresses (Parliament, Association, Referendum), and no additional checks in the authorization flow

The key insight is that this represents **privilege escalation** - even legitimate temporary governance control should not enable permanent bypass of all future governance. This violates the principle of least privilege and creates an asymmetric risk where a single compromised vote can have permanent consequences.

## Recommendation
Implement a whitelist validation in `CheckOrganizationExist` to ensure the `ContractAddress` is one of the known governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var validContracts = new List<Address>
    {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(validContracts.Contains(authorityInfo.ContractAddress), 
        "ContractAddress must be Parliament, Association, or Referendum contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

This ensures that only legitimate governance contracts can be used for authorization, preventing the privilege escalation attack.

## Proof of Concept
```csharp
[Fact]
public async Task ConnectorController_PrivilegeEscalation_Test()
{
    // 1. Deploy malicious contract that always returns true for ValidateOrganizationExist
    var maliciousContract = await DeployMaliciousContractAsync();
    
    // 2. Create malicious AuthorityInfo pointing to attacker's address
    var maliciousAuthority = new AuthorityInfo
    {
        ContractAddress = maliciousContract,
        OwnerAddress = AttackerAddress
    };
    
    // 3. As current controller (via governance), change to malicious authority
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplStub.ChangeConnectorController),
        maliciousAuthority);
    
    // 4. Verify attacker can now directly call protected methods without governance
    var result = await AttackerStub.SetFeeRate.SendAsync(new StringValue { Value = "0.99" });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 5. Verify governance is bypassed - no proposal needed
    var feeRate = await DefaultStub.GetFeeRate.CallAsync(new Empty());
    feeRate.Value.ShouldBe("0.99");
}
```

**Notes:**
This vulnerability represents a fundamental flaw in the authorization model where contract address validation is missing. The attack leverages the trust assumption that `ValidateOrganizationExist` will only be called on legitimate governance contracts, but there is no enforcement of this assumption in the code. The fix requires adding explicit whitelist validation to prevent privilege escalation through malicious contract substitution.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-267)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
        var feeRate = AssertedDecimal(input.Value);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L405-416)
```csharp
    private AuthorityInfo GetDefaultConnectorController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
