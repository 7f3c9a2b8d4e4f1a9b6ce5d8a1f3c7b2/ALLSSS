# Audit Report

## Title
Incorrect LIB Index Calculation Violates 2/3 Consensus Threshold in AEDPoS

## Summary
The Last Irreversible Block (LIB) height calculation uses an incorrect index formula that fails to ensure 2/3 consensus when exactly `MinersCountOfConsent` miners have mined. This allows blocks to be finalized with as low as 57% miner agreement instead of the required 67%, violating Byzantine Fault Tolerance guarantees.

## Finding Description

The vulnerability exists in the LIB calculation logic within the `LastIrreversibleBlockHeightCalculator` class. [1](#0-0)  The algorithm collects implied irreversible heights from miners who mined in the current round, verifies the count meets the minimum threshold, then selects a height using the index formula `(Count - 1) / 3`.

The `MinersCountOfConsent` property is calculated as `(TotalMiners * 2 / 3) + 1`, representing the minimum number of miners required for 2/3 consensus. [2](#0-1) 

**Root Cause:**

For a sorted list of heights [H₀, H₁, ..., Hₙ₋₁], selecting index `i` means that `(n - i)` miners have reported heights ≥ Hᵢ. The current index formula `(n-1)/3` produces the following violations:

- **For 7 total miners**: MinersCountOfConsent = 5
  - When Count = 5: index = 1, agreeing miners = 4 (57% of 7)
  - Required: 5 miners (67% of 7)
  - **Violation**: 4 < 5

- **For 10 total miners**: MinersCountOfConsent = 7  
  - When Count = 7: index = 2, agreeing miners = 5 (50% of 10)
  - Required: 7 miners (67% of 10)
  - **Violation**: 5 < 7

The check at line 26 only ensures sufficient miners have mined, but doesn't validate that the selected index provides 2/3 consensus. The index formula doesn't align with the MinersCountOfConsent threshold, resulting in insufficient agreement for block finalization.

## Impact Explanation

This vulnerability compromises the fundamental security guarantees of the consensus system:

1. **Byzantine Fault Tolerance Breakdown**: Blocks can be finalized with only ~57% agreement, breaking the BFT assumption that up to 1/3 malicious nodes can be tolerated. This means the system cannot handle the intended fault threshold.

2. **Irreversible Block Compromise**: The incorrectly calculated LIB triggers the `IrreversibleBlockFound` event, which updates the chain state system-wide. [3](#0-2) 

3. **Cross-Chain Impact**: The LIB is processed by `IrreversibleBlockFoundLogEventProcessor` and propagated throughout the system via `SetIrreversibleBlockAsync`, affecting cross-chain verification and state finalization. [4](#0-3) 

4. **No Additional Validation**: The existing validation only prevents LIB regression, not consensus threshold violations. [5](#0-4) 

The entire security model of Byzantine Fault Tolerance is violated, allowing consensus with insufficient agreement and potentially enabling attacks that should be prevented by the 2/3 threshold.

## Likelihood Explanation

This vulnerability occurs naturally during normal protocol operation:

1. **Reachable Entry Point**: The vulnerability is triggered when miners call the public `UpdateValue` method during consensus operations. [6](#0-5) 

2. **Natural Occurrence**: The vulnerable condition manifests when exactly `MinersCountOfConsent` miners have mined in the current round—a common scenario during normal operations. No special circumstances are required.

3. **No Attack Required**: This is a logic bug in the consensus algorithm itself, not requiring any malicious actor to exploit. It occurs automatically when the natural threshold is reached.

4. **Frequency**: With 7 miners, the probability that exactly 5 have mined when a miner processes `UpdateValue` is substantial during each consensus round. The issue is deterministic once this condition is met.

5. **Detection Difficulty**: The miscalculation produces a valid block height that passes all existing validations, making it undetectable without analyzing the consensus mathematics.

## Recommendation

The index formula should be corrected to ensure that at least `MinersCountOfConsent` miners agree on the selected height. The correct formula is:

```csharp
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count - _currentRound.MinersCountOfConsent];
```

This ensures that when selecting the height at index `i`, the number of agreeing miners `(Count - i)` is always ≥ `MinersCountOfConsent`, properly maintaining the 2/3 consensus threshold.

For example, with 7 miners and Count = 5:
- Correct index = 5 - 5 = 0
- Agreeing miners = 5 - 0 = 5 (71% of 7) ✓

Alternative formula maintaining the same semantic intent:
```csharp
libHeight = impliedIrreversibleHeights[0]; // When Count == MinersCountOfConsent
```

## Proof of Concept

```csharp
[Fact]
public void LIB_Calculation_Violates_TwoThirds_Consensus()
{
    // Setup: 7 total miners, MinersCountOfConsent = 5
    var totalMiners = 7;
    var minersCountOfConsent = (totalMiners * 2 / 3) + 1; // = 5
    
    // Simulate exactly 5 miners providing implied heights
    var impliedHeights = new List<long> { 100, 150, 200, 250, 300 };
    impliedHeights.Sort();
    
    // Current buggy formula
    var currentIndex = (impliedHeights.Count - 1) / 3; // = 1
    var selectedHeight = impliedHeights[currentIndex]; // = 150
    var agreeingMiners = impliedHeights.Count - currentIndex; // = 4
    
    // Assertion: Only 4 miners agree, but we need 5 for 2/3 consensus
    Assert.True(agreeingMiners < minersCountOfConsent); // 4 < 5 - VIOLATION
    Assert.True(agreeingMiners < (totalMiners * 2.0 / 3.0)); // 4 < 4.67 - Below 67%
    
    // Correct formula would be
    var correctIndex = impliedHeights.Count - minersCountOfConsent; // = 0
    var correctAgreeingMiners = impliedHeights.Count - correctIndex; // = 5
    Assert.True(correctAgreeingMiners >= minersCountOfConsent); // 5 >= 5 - VALID
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-280)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L54-87)
```csharp
    private async Task ProcessLogEventAsync(Block block, IrreversibleBlockFound irreversibleBlockFound)
    {
        try
        {
            var chain = await _blockchainService.GetChainAsync();

            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;

            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;

            if (chain.LastIrreversibleBlockHeight == irreversibleBlockFound.IrreversibleBlockHeight) return;

            var blockIndex = new BlockIndex(libBlockHash, irreversibleBlockFound.IrreversibleBlockHeight);
            Logger.LogDebug($"About to set new lib height: {blockIndex.BlockHeight} " +
                            $"Event: {irreversibleBlockFound} " +
                            $"BlockIndex: {blockIndex.BlockHash} - {blockIndex.BlockHeight}");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var currentChain = await _blockchainService.GetChainAsync();
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
                }, KernelConstants.UpdateChainQueueName);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to resolve IrreversibleBlockFound event.");
            throw;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
