# Audit Report

## Title
Unbounded Token Symbol Accumulation Causes DoS in Side Chain Profit Distribution

## Summary
The Profit Contract allows unlimited token symbols to be added to `scheme.ReceivedTokenSymbols` without size limits. Side chain TokenHolder schemes are vulnerable to DoS attacks where adversaries poison the symbol list through public donation methods, causing profit distribution transactions to exceed gas limits due to excessive cross-contract calls.

## Finding Description

**Root Cause**: The `ReceivedTokenSymbols` field is defined as an unbounded repeated string field with no size constraint enforced in contract logic. [1](#0-0) 

**Vulnerable Entry Point**: On side chains, `AEDPoS.Donate` is a public method that anyone can call to contribute tokens. [2](#0-1) 

This method calls `TokenHolder.ContributeProfits`: [3](#0-2) 

Which forwards to `Profit.ContributeProfits` where symbols are unconditionally added to `ReceivedTokenSymbols`: [4](#0-3) 

The validation only checks that tokens exist and amounts are positive, with no limit on symbol count: [5](#0-4) 

**Gas Exhaustion Path**: When side chain profit distribution triggers automatically, it calls `DistributeProfits` without an `AmountsMap`: [6](#0-5) 

TokenHolder forwards this with an empty `AmountsMap` by default: [7](#0-6) 

This triggers the vulnerable code path that iterates through ALL accumulated symbols in `ReceivedTokenSymbols`: [8](#0-7) 

Each symbol requires multiple cross-contract `GetBalance` calls - one in the initial loop and another in `UpdateDistributedProfits`: [9](#0-8) 

**Missing Protection**: While `TokenAmountLimit` constant exists with value 5: [10](#0-9) 

It is only enforced in `SetMethodFee`: [11](#0-10) 

No limit validation exists in the `DistributeProfits` method for `ReceivedTokenSymbols.Count` or `AmountsMap.Count`.

**Irreversibility**: No mechanism exists to remove symbols from `ReceivedTokenSymbols` once added - the codebase contains no Clear or Remove operations for this field, making the DoS permanent.

## Impact Explanation

**Side Chain Economic DoS**: An attacker can permanently prevent profit distribution for side chain TokenHolder schemes by causing `DistributeProfits` to exceed gas limits. With 100+ poisoned symbols, the distribution transaction would require 200+ cross-contract `GetBalance` calls plus transfer operations, resulting in gas exhaustion.

**Affected Systems**: Side chain dividends pools used by AEDPoS consensus for staking rewards. The side chain scheme is created with `IsReleaseAllBalanceEveryTimeByDefault = true`: [12](#0-11) 

**Note on Treasury**: Main chain Treasury schemes are NOT vulnerable despite having `IsReleaseAllBalanceEveryTimeByDefault = true` because they always explicitly provide an `AmountsMap` with controlled symbols from `SymbolList`: [13](#0-12) 

**Severity**: Medium/High - While no funds are stolen, side chain economic operations become non-functional, preventing users from receiving staking rewards and disrupting the side chain economic model.

## Likelihood Explanation

**Reachable Entry Point**: `AEDPoS.Donate` is fully public with implicit authorization through `TransferFrom` requiring only token approval and balance. No sender restrictions exist beyond token ownership validation.

**Attack Requirements**:
1. Access to multiple valid token symbols (realistic - attacker can create tokens or use existing ones)
2. Small amounts of each token (1 unit minimum per symbol)
3. Token approval for AEDPoS contract
4. Transaction fees (~1 ELF per donation call)

**Attack Cost**: For 100 poisoned symbols: ~100-200 ELF in fees + 100 token units (minimal value). This is economically rational compared to DoSing an entire side chain's economic distribution system.

**Detection**: The attack appears as normal donations and would only be detected when automatic distribution begins failing due to gas exhaustion.

## Recommendation

1. **Enforce Symbol Limit**: Add validation in `ContributeProfits` to limit `ReceivedTokenSymbols.Count`:
```csharp
Assert(scheme.ReceivedTokenSymbols.Count < ProfitContractConstants.TokenAmountLimit,
    "Maximum token symbol limit reached.");
```

2. **Apply Limit in DistributeProfits**: Add validation before the iteration:
```csharp
Assert(scheme.ReceivedTokenSymbols.Count <= ProfitContractConstants.TokenAmountLimit,
    "Too many token symbols for distribution.");
Assert(profitsMap.Count <= ProfitContractConstants.TokenAmountLimit,
    "Too many symbols in amounts map.");
```

3. **Add Symbol Removal Mechanism**: Implement a manager-controlled method to remove inactive symbols from `ReceivedTokenSymbols`.

4. **Side Chain Specific Protection**: Add authorization check to `AEDPoS.Donate` or limit accepted token symbols to a whitelist maintained by governance.

## Proof of Concept

While I cannot provide executable tests without the full test framework setup, the attack flow is:

```
1. Attacker creates or acquires 100+ different token symbols
2. Approves AEDPoS contract for each token
3. Repeatedly calls AEDPoS.Donate(symbol, minAmount) for each symbol
4. Each call adds symbol to ReceivedTokenSymbols via ContributeProfits
5. When automatic release triggers, DistributeProfits is called without AmountsMap
6. Iteration through 100+ symbols causes gas exhaustion
7. Side chain profit distribution permanently fails
```

The vulnerability is confirmed by code analysis showing the complete attack path from public entry point through symbol accumulation to gas exhaustion in distribution.

## Notes

- **Main chain Treasury schemes are NOT vulnerable** - they always provide controlled AmountsMap
- **Side chain TokenHolder schemes via AEDPoS ARE vulnerable** - automatic distribution uses empty AmountsMap
- **Custom TokenHolder schemes** may also be vulnerable if managers call DistributeProfits without AmountsMap
- The vulnerability exists in the Profit contract design but is only exploitable where the vulnerable code path (empty AmountsMap) is actually used in production

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L28-32)
```csharp
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-94)
```csharp
    public override Empty Donate(DonateInput input)
    {
        EnsureTokenContractAddressSet();

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });

        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;

        Context.LogDebug(() => $"Contributed {input.Amount} {input.Symbol}s to side chain dividends pool.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L117-120)
```csharp
            State.TokenHolderContract.DistributeProfits.Send(new DistributeProfitsInput
            {
                SchemeManager = Context.Self
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L448-460)
```csharp
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L570-580)
```csharp
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L656-659)
```csharp
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L136-143)
```csharp
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L14-14)
```csharp
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L129-134)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```
