# Audit Report

## Title
MinimalVoteThreshold Counts Historical Votes Instead of Current Member Participation, Bypassing Quorum Requirements

## Summary
The Association contract's `CheckEnoughVoteAndApprovals()` function counts all historical votes toward `MinimalVoteThreshold` without filtering by current organization membership, unlike all other threshold checks. This allows proposals to be released without adequate participation from the current organization when membership changes occur after voting begins.

## Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals()` method where the `MinimalVoteThreshold` check concatenates and counts all vote lists without filtering by current membership. [1](#0-0) 

This is inconsistent with how other threshold checks properly filter votes by current organization membership:

**Approval threshold filtering:** [2](#0-1) 

**Rejection threshold filtering:** [3](#0-2) 

**Abstention threshold filtering:** [4](#0-3) 

The vulnerability occurs because organizations can modify membership after voting begins using methods like `AddMember`, `RemoveMember`, and `ChangeMember`: [5](#0-4) [6](#0-5) [7](#0-6) 

When `Release()` is called, it retrieves the current organization state and checks thresholds against it: [8](#0-7) 

The organization validation only ensures thresholds are valid for the current member count at modification time, not that actual votes counted come from current members: [9](#0-8) 

The `AssertProposalNotYetVotedBySender` protection only prevents duplicate votes by the same address, not membership changes: [10](#0-9) 

## Impact Explanation

**HIGH severity** - This vulnerability breaks the quorum mechanism, a fundamental governance protection:

1. **Quorum Bypass via Member Addition**: An organization with 10 members that receives 8 votes (80% participation) can add 20 new members. The proposal can still be released with only 8/30 votes (26.7% participation) because `MinimalVoteThreshold` counts historical votes while other checks filter by current membership. The intended quorum becomes meaningless.

2. **Vote Inflation via Removed Members**: Members who vote and are subsequently removed still have their votes count toward `MinimalVoteThreshold` while not counting toward approval/rejection/abstention thresholds. This creates an inconsistent state where historical non-members influence quorum decisions.

3. **Governance Integrity Violation**: The `MinimalVoteThreshold` is designed to ensure adequate organizational participation before executing proposals. This vulnerability allows proposals to execute without true quorum from current membership, undermining the governance model's fundamental invariant that proposals require sufficient current member participation.

## Likelihood Explanation

**HIGH likelihood** - This vulnerability can be triggered through standard governance operations:

- **Attack Complexity**: LOW - Simple sequence: create proposal → gather votes → modify membership → release proposal
- **Required Privileges**: Only standard governance capabilities (proposer whitelist membership and organization governance approval for membership changes)
- **Feasibility**: Organizations frequently modify membership as part of normal operations. Proposals can have long lifetimes until `ExpiredTime`, providing ample opportunity for membership changes.
- **Natural Occurrence**: This can happen unintentionally during legitimate governance operations, making it both an exploitable vulnerability and an operational flaw.

The inconsistency is subtle and wouldn't be detected until detailed analysis of vote ratios versus current membership, making membership changes unsuspicious operations.

## Recommendation

Modify the `CheckEnoughVoteAndApprovals()` method to filter the MinimalVoteThreshold check by current organization membership, consistent with how approval, rejection, and abstention thresholds are already handled.

The fix should change line 56 in `Association_Helper.cs` from:
```csharp
proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count()
```

To filter by current membership:
```csharp
proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
    .Count(organization.OrganizationMemberList.Contains)
```

This ensures that only votes from current organization members count toward the MinimalVoteThreshold, maintaining the quorum invariant.

## Proof of Concept

```csharp
[Fact]
public async Task MinimalVoteThreshold_Quorum_Bypass_Via_Member_Addition_Test()
{
    // Setup: Create organization with 3 members, MinimalVoteThreshold=3, MinimalApprovalThreshold=2
    var minimalApproveThreshold = 2;
    var minimalVoteThreshold = 3;
    var maximalAbstentionThreshold = 1;
    var maximalRejectionThreshold = 1;
    var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
        maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
    
    // Create proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // All 3 members vote (2 approve, 1 reject) - meets MinimalVoteThreshold of 3
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await RejectAsync(Reviewer3KeyPair, proposalId);
    
    // Verify proposal can be released now
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // 3/3 voted, meets quorum
    
    // Add 7 new members to organization (now 10 total)
    var organizationStub = GetAssociationContractTester(organizationAddress);
    for (int i = 0; i < 7; i++)
    {
        var newMember = Address.FromPublicKey(CryptoHelper.GenerateKeyPair().PublicKey);
        await organizationStub.AddMember.SendAsync(newMember);
    }
    
    // VULNERABILITY: Proposal can still be released with only 3/10 votes (30% participation)
    // MinimalVoteThreshold check: 3 historical votes >= 3 ✓ (should require 3/10 current members)
    // MinimalApprovalThreshold check: 2 current member approvals >= 2 ✓
    proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // Still true despite only 30% participation
    
    // Release succeeds with insufficient quorum from current membership
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Expected: Release should fail because only 3/10 (30%) current members voted
    // Actual: Release succeeds because MinimalVoteThreshold counts historical votes
}
```

**Notes**

The vulnerability stems from an inconsistency in how vote thresholds are validated. While approval, rejection, and abstention thresholds correctly filter votes by current organization membership using `.Count(organization.OrganizationMemberList.Contains)`, the MinimalVoteThreshold check uses a plain `.Count()` on the concatenated vote lists without any membership filtering.

This creates a governance bypass where:
- Adding members after voting dilutes the effective participation rate while historical votes still count toward quorum
- Removing members after voting allows non-members' votes to count toward quorum
- The MinimalVoteThreshold becomes decoupled from actual current member participation

The fix is straightforward: apply the same membership filtering to MinimalVoteThreshold that is already applied to the other threshold checks, ensuring all governance thresholds consistently operate on votes from current members only.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-80)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L132-138)
```csharp
    private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
    {
        var isAlreadyVoted = proposal.Approvals.Contains(sender) || proposal.Rejections.Contains(sender) ||
                             proposal.Abstentions.Contains(sender);

        Assert(!isAlreadyVoted, "Sender already voted.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-188)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
