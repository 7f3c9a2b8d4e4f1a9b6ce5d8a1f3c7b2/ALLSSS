# Audit Report

## Title
Unchecked Return Value in Term Transition Causes Consensus Failure and Potential Blockchain Halt

## Summary
The `GenerateFirstRoundOfNextTerm()` method fails to validate the return value of `TryToGetCurrentRoundInformation()`, creating a critical vulnerability where null reference exceptions or assertion failures can halt blockchain consensus during term transitions. When round information is invalid or election victories are empty, the consensus system cannot establish a new term, resulting in complete network unavailability.

## Finding Description

The vulnerability exists in the consensus term transition logic where the return value of a critical state-checking method is ignored.

**Entry Point:**
The public `GetConsensusExtraData` method implements the ACS4 consensus interface [1](#0-0) , which delegates to `GetConsensusBlockExtraData`.

When the consensus behavior is `NextTerm`, it invokes `GetConsensusExtraDataForNextTerm` [2](#0-1) .

This method calls `GenerateFirstRoundOfNextTerm` to create the first round of the new term [3](#0-2) .

**Critical Missing Check:**
In `GenerateFirstRoundOfNextTerm`, the method calls `TryToGetCurrentRoundInformation(out var currentRound)` **without checking the return value** [4](#0-3) .

The `TryToGetCurrentRoundInformation` helper explicitly sets `round = null` and returns `false` when the round number is 0 or the round is empty [5](#0-4) .

**Null Reference Path - Scenario 1:**
When `TryToGetVictories()` returns `true`, the code passes the potentially null `currentRound` to `victories.GenerateFirstRoundOfNewTerm()` [6](#0-5) . This method accesses `currentRound.RoundNumber`, `currentRound.TermNumber`, `currentRound.ConfirmedIrreversibleBlockHeight`, and `currentRound.ConfirmedIrreversibleBlockRoundNumber` [7](#0-6) , causing a `NullReferenceException` if `currentRound` is null.

**Null Reference Path - Scenario 2:**
When `TryToGetVictories()` returns `false`, the code accesses `currentRound.RealTimeMinersInformation.Keys` [8](#0-7) , which throws a `NullReferenceException` if `currentRound` is null. Even in the successful path, it later accesses `currentRound.ConfirmedIrreversibleBlockHeight` and `currentRound.ConfirmedIrreversibleBlockRoundNumber` [9](#0-8) .

**Empty Round Generation - Scenario 3:**
If `currentRound` is not null but has empty miner information, and `TryToGetVictories` returns false, the code creates a `MinerList` with empty `Pubkeys`. When this is passed to `GenerateFirstRoundOfNewTerm`, the for loop iterates zero times [10](#0-9) , resulting in a round with empty `RealTimeMinersInformation`.

The `RoundId` property computes the sum of all miners' `ExpectedMiningTime.Seconds`. With an empty dictionary, this sum is zero [11](#0-10) . The `IsEmpty` property returns `true` when `RoundId` equals zero [12](#0-11) .

**Assertion Failure:**
The calling method asserts that `firstRoundOfNextTerm.RoundId != 0` [13](#0-12) . When the round has no miners, this assertion fails with "Failed to generate new round information."

**Circular Dependency:**
The Election contract's `GetVictories` retrieves the current miner list as fallback [14](#0-13) . When there are insufficient valid candidates, it takes backup miners from this list [15](#0-14) . The `GetCurrentMinerList` method returns an empty list when round information is invalid [16](#0-15) , and `TryToGetVictories` returns false when the victories list is empty [17](#0-16) .

## Impact Explanation

**Critical Availability Impact:**
This vulnerability causes complete blockchain unavailability. When a term transition executes under the vulnerable conditions, the consensus transaction fails with either a `NullReferenceException` or an assertion error. Since term transitions are fundamental to the consensus mechanism, failure prevents the blockchain from advancing to the next term.

Without a valid new term, no miner schedule exists for block production. The consensus system cannot generate valid consensus commands, and validators cannot produce blocks, resulting in a complete network halt.

**Non-Self-Healing:**
This is not a transient failure. The blockchain remains halted until manual intervention occursâ€”either through chain rollback or emergency governance intervention to repair the state. This affects all network validators, users, and dApps dependent on the blockchain.

While this does not involve direct fund loss, the complete denial of service to the entire blockchain network constitutes a HIGH severity issue. Blockchain availability is a critical security property.

## Likelihood Explanation

**Reachability:**
The vulnerable code path is directly reachable through normal consensus operations via the ACS4 interface during block production. When term transition is needed, the consensus behavior provider triggers `NextTerm` behavior.

**Triggering Conditions:**
The vulnerability manifests when:
1. The current round information is invalid or missing (`TryToGetCurrentRoundInformation` returns false with round number = 0 or empty round), OR
2. The Election contract returns empty victories (no valid candidates with votes) AND the current miner list is empty

**Realistic Scenarios:**
- **Initialization edge cases**: During chain startup or state initialization issues
- **Election participation failures**: When no candidates are registered or all have zero votes
- **State corruption**: Due to bugs in state management or unexpected transitions
- **Circular dependency**: `GetCurrentMinerList` depends on valid round information, creating a dependency loop

While these conditions may not occur frequently in a healthy network, the unchecked return value **guarantees failure** when preconditions are met. The deterministic nature makes this a latent reliability issue that could manifest during network stress or initialization problems.

## Recommendation

Add a return value check and handle the failure case appropriately:

```csharp
private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
{
    Round newRound;
    if (!TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Handle the case where current round is not available
        // Option 1: Return a minimal valid round for initialization
        // Option 2: Throw a more descriptive error
        Assert(false, "Cannot generate next term: current round information is not available");
    }

    if (TryToGetVictories(out var victories))
    {
        Context.LogDebug(() => "Got victories successfully.");
        newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
            currentRound);
    }
    else
    {
        // Ensure currentRound has miners before proceeding
        Assert(currentRound.RealTimeMinersInformation.Keys.Any(), 
            "Cannot generate next term: no miners in current round and no election victories");
        
        var miners = new MinerList();
        miners.Pubkeys.AddRange(
            currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
            Context.CurrentBlockTime, currentRound);
    }

    newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
    newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
    newRound.BlockchainAge = GetBlockchainAge();

    if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
        newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
    else
        UpdateCandidateInformation(senderPubkey, 1, 0);

    newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

    return newRound;
}
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Initialize the consensus contract with minimal state
2. Set `State.CurrentRoundNumber.Value = 0` (or clear round state to make it return empty)
3. Set up Election contract to return empty victories
4. Call `GetConsensusExtraData` with `NextTerm` behavior
5. Observe either `NullReferenceException` or assertion failure with "Failed to generate new round information"

The exact test implementation depends on the test framework setup, but the key is simulating the state where `TryToGetCurrentRoundInformation` returns false while attempting a term transition.

---

**Notes:**
This is a valid defensive programming issue where a critical state-checking method's return value is ignored, leading to null dereferences in multiple code paths. The vulnerability is deterministic and can halt the blockchain under specific but realistic conditions related to consensus state initialization or election failures.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L45-47)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-210)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-226)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L234-242)
```csharp
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L47-54)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval, Timestamp currentBlockTime, Round currentRound)
    {
        var round = GenerateFirstRoundOfNewTerm(miningInterval, currentBlockTime, currentRound.RoundNumber,
            currentRound.TermNumber);
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L26-26)
```csharp
    public bool IsEmpty => RoundId == 0;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-77)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }
```
