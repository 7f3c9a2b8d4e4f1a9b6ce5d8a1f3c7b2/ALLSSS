# Audit Report

## Title
Quadratic Voting Results Corruption Due to Inconsistent Amount Tracking

## Summary
The Vote contract contains a critical accounting inconsistency in quadratic voting that causes voting results to become negative and completely corrupt vote tallies. During voting, the contract increments the `Results` map by 1 (vote count), but during withdrawal, it decrements by the token amount, creating a fundamental mismatch that breaks the voting system.

## Finding Description

The vulnerability exists in the asymmetric handling of quadratic voting results between the `Vote` and `Withdraw` functions in the Vote contract.

**During Voting (Vote function):** [1](#0-0) 

For quadratic voting, the `amount` variable is calculated as the token amount to be locked (`ticketCost * currentVotesCount`). However, when updating the voting result: [2](#0-1) 

The contract passes `1` (vote count) instead of `amount` (token amount) for quadratic voting to the `UpdateVotingResult` function.

**In UpdateVotingResult:** [3](#0-2) 

This increments both `Results[option]` and `VotesAmount` by the passed parameter, which is `1` for quadratic voting.

**The VotingRecord stores the token amount:** [4](#0-3) 

The `VotingRecord.Amount` field stores the actual token amount (e.g., 100, 200, 300 tokens), not the vote count.

**During Withdrawal:** [5](#0-4) 

The withdrawal decrements both `Results[option]` and `VotesAmount` by `votingRecord.Amount`, which is the token amount stored in the record.

This creates a fundamental mismatch: the `Results` map is incremented by 1 during voting but decremented by potentially large token amounts during withdrawal.

## Impact Explanation

**Severity: Critical**

The impact is severe and affects the core functionality of quadratic voting:

1. **Voting Results Corruption**: After the first withdrawal, `Results[option]` becomes negative. For example, if `ticketCost = 100`:
   - After first vote: `Results["OptionA"] = 1`, tokens locked = 100
   - After withdrawal: `Results["OptionA"] = 1 - 100 = -99`

2. **VotesAmount Corruption**: The total `VotesAmount` field similarly becomes negative, making it impossible to accurately track total participation.

3. **Governance Failure**: Any governance or decision-making system relying on these vote results will operate on completely corrupted data, potentially leading to incorrect outcomes.

4. **Feature Unusability**: The quadratic voting feature is entirely broken and unusable in production.

**Who is Affected:**
- All users participating in quadratic voting items
- Voting item sponsors who depend on accurate vote counts
- Any downstream contracts or governance systems reading vote results

## Likelihood Explanation

**Likelihood: Very High**

This vulnerability has an extremely high probability of occurrence:

1. **No Special Privileges Required**: Any regular user can trigger this bug by simply participating in a quadratic voting item and later withdrawing their vote.

2. **Low Attack Complexity**: The bug manifests through normal, intended operations (vote + withdraw). No sophisticated setup or timing is required.

3. **Automatic Manifestation**: The issue occurs automatically in any quadratic voting scenario where users exercise their legitimate right to withdraw.

4. **Preconditions**: Only requires a voting item with `IsQuadratic = true` (as shown in the Register function): [6](#0-5) 

5. **Detection**: The bug is immediately observable through negative or incorrect vote tallies after any withdrawal.

## Recommendation

The fix is to ensure consistent tracking of vote amounts. For quadratic voting, the contract should store and track either:

**Option 1 (Recommended)**: Store the token amount in Results and use it consistently:
```csharp
// In Vote function, line 119:
UpdateVotingResult(votingItem, input.Option, amount);  // Use amount for both quadratic and non-quadratic

// This ensures Results[option] and VotesAmount track token amounts consistently
```

**Option 2**: Store vote counts and convert during withdrawal:
```csharp
// In Withdraw function, calculate the vote count from the token amount for quadratic voting
if (votingItem.IsQuadratic)
{
    long voteCount = 1;  // Each vote record represents 1 vote count in quadratic voting
    votingResult.Results[votingRecord.Option] = 
        votingResult.Results[votingRecord.Option].Sub(voteCount);
    votingResult.VotesAmount = votingResult.VotesAmount.Sub(voteCount);
}
else
{
    votingResult.Results[votingRecord.Option] = 
        votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
    votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
}
```

Option 1 is simpler and maintains semantic consistency where `Results` represents the weighted vote power (token amounts).

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_WithdrawalCorruptsResults_Test()
{
    // Setup: Register a quadratic voting item with ticketCost = 100
    var votingItemId = await RegisterQuadraticVotingItem(ticketCost: 100);
    
    // Step 1: User votes once (first vote)
    var voteId1 = await VoteForOption(votingItemId, "OptionA");
    
    // Verify: Results should be 1, locked amount should be 100
    var result1 = await GetVotingResult(votingItemId);
    Assert.Equal(1, result1.Results["OptionA"]);  // Vote count = 1
    Assert.Equal(1, result1.VotesAmount);          // But this is also 1!
    
    var record1 = await GetVotingRecord(voteId1);
    Assert.Equal(100, record1.Amount);             // Tokens locked = 100
    
    // Step 2: Withdraw the vote
    await Withdraw(voteId1);
    
    // BUG: Results becomes negative!
    var result2 = await GetVotingResult(votingItemId);
    Assert.Equal(-99, result2.Results["OptionA"]); // 1 - 100 = -99 (NEGATIVE!)
    Assert.Equal(-99, result2.VotesAmount);        // 1 - 100 = -99 (CORRUPTED!)
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L50-51)
```csharp
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L98-103)
```csharp
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```
