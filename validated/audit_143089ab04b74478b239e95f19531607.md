# Audit Report

## Title
Miner Can Bypass Consensus Data Submission by Submitting TinyBlock Instead of UpdateValue

## Summary
A malicious miner can avoid providing critical consensus data (OutValue, Signature, PreviousInValue) by submitting TinyBlock behavior when UpdateValue behavior is expected. The validation logic does not verify that the submitted behavior type matches the miner's state in the current round, allowing miners who have not yet mined (OutValue == null) to bypass UpdateValue submission requirements.

## Finding Description

The AEDPoS consensus system determines expected behavior based on miner state. When a miner's OutValue is null (hasn't mined in current round) and their time slot hasn't passed, `HandleMinerInNewRound()` returns `AElfConsensusBehaviour.UpdateValue` as the expected behavior. [1](#0-0) 

The consensus system uses different Round structures for different behaviors. `GetUpdateValueRound` includes consensus-critical fields (OutValue, Signature, PreviousInValue), [2](#0-1)  while `GetTinyBlockRound` only includes mining timestamps and block counts. [3](#0-2) 

However, the validation in `ValidateBeforeExecution` does not check whether the submitted behavior matches what the miner's state requires. The validation applies different validators based on the submitted behavior type in the switch statement, not the expected behavior. [4](#0-3) 

For TinyBlock behavior, only three validators are applied: `MiningPermissionValidationProvider`, `TimeSlotValidationProvider`, and `ContinuousBlocksValidationProvider`. [5](#0-4) 

None of these validators check whether the miner's OutValue is null in the base round. `MiningPermissionValidationProvider` only verifies the sender is in the miner list, [6](#0-5)  `TimeSlotValidationProvider` returns true when `latestActualMiningTime` is null (which occurs when the miner hasn't mined yet), [7](#0-6)  and `ContinuousBlocksValidationProvider` only checks continuous block limits. [8](#0-7) 

The recovery process for TinyBlock only extracts ActualMiningTimes and ImpliedIrreversibleBlockHeight, [9](#0-8)  while `RecoverFromUpdateValue` updates OutValue, Signature, and PreviousInValue. [10](#0-9) 

The processing functions show the critical difference. `ProcessUpdateValue` updates consensus data and calculates LIB height, [11](#0-10)  while `ProcessTinyBlock` only updates mining counters. [12](#0-11) 

At round transition, `SupplyCurrentRoundInformation` fills in fake/derived values for miners who didn't provide real data. For miners with OutValue == null, it generates fake previousInValue and signature using `HashHelper.ComputeFrom(miner)`. [13](#0-12) 

## Impact Explanation

**Consensus Integrity Compromise:** This vulnerability breaks fundamental AEDPoS consensus guarantees:

1. **Random Number Generation Broken:** OutValue and Signature are used for generating random numbers. Without authentic values from all miners, the randomness mechanism is compromised.

2. **Secret Sharing Disrupted:** PreviousInValue is required for the secret sharing protocol. Missing values prevent proper verification by other miners, breaking the distributed trust model.

3. **LIB Height Stalled:** The Last Irreversible Block height calculation only occurs during UpdateValue processing via `LastIrreversibleBlockHeightCalculator`. [14](#0-13)  Bypassing UpdateValue prevents LIB advancement, affecting finality guarantees.

4. **Fake Value Injection:** The system compensates for missing consensus data by generating deterministic fake values, which can be predicted by attackers and used to manipulate consensus outcomes.

Multiple colluding miners could systematically degrade consensus integrity while still receiving mining rewards, undermining the security assumptions of the entire blockchain.

## Likelihood Explanation

**High Likelihood:** This vulnerability is easily exploitable:

1. **Reachable Entry Point:** Any miner can submit consensus data through normal block production. The behavior type is self-declared in the consensus header via `AElfConsensusHeaderInformation`.

2. **No Special Permissions Required:** The attacker only needs to be in the validator set, which is a normal operational requirement.

3. **Simple Execution:** The attacker modifies their node software to submit TinyBlock behavior when `GetConsensusCommand` indicates UpdateValue is expected. All existing validators pass because none check behavior type matching.

4. **Low Detection Risk:** The submitted data appears valid (correct time slot, valid miner, within block limits). Only checking the base round's OutValue state against submitted behavior could detect this, and no validator performs this check.

5. **Rational Attack Vector:** An attacker could selectively withhold consensus data to manipulate random number generation outcomes while still earning mining rewards.

## Recommendation

Add a behavior type matching validator that verifies the submitted behavior matches what is expected based on the miner's state. Specifically:

1. Create a new `BehaviourTypeValidationProvider` that:
   - Retrieves the miner's state from `baseRound.RealTimeMinersInformation[senderPubkey]`
   - Calls the appropriate `ConsensusBehaviourProvider.GetConsensusBehaviour()` to determine expected behavior
   - Compares submitted behavior with expected behavior
   - Returns validation failure if they don't match

2. Add this provider to the validation list in `ValidateBeforeExecution` before other validators are applied, ensuring it runs for all behavior types.

3. Alternatively, add explicit checks in the existing validators (particularly `UpdateValueValidationProvider`) to verify that if OutValue is null and time slot hasn't passed, only UpdateValue behavior is acceptable.

## Proof of Concept

```csharp
[Fact]
public async Task Miner_Can_Bypass_UpdateValue_With_TinyBlock_Test()
{
    // Setup: Initialize first round with boot miner
    await AEDPoSContract_FirstRound_BootMiner_Test();
    
    // Get second miner who hasn't mined yet (OutValue == null)
    var secondMinerKeyPair = InitialCoreDataCenterKeyPairs[1];
    KeyPairProvider.SetKeyPair(secondMinerKeyPair);
    
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfo = currentRound.RealTimeMinersInformation[secondMinerKeyPair.PublicKey.ToHex()];
    
    // Verify preconditions: OutValue should be null
    minerInfo.OutValue.ShouldBeNull();
    
    // Set block time within miner's time slot
    BlockTimeProvider.SetBlockTime(minerInfo.ExpectedMiningTime);
    
    // Attacker: Create TinyBlock consensus header instead of UpdateValue
    var maliciousTinyBlockHeader = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(secondMinerKeyPair.PublicKey),
        Behaviour = AElfConsensusBehaviour.TinyBlock, // Should be UpdateValue!
        Round = currentRound.GetTinyBlockRound(secondMinerKeyPair.PublicKey.ToHex())
    };
    
    // Validate: This should FAIL but currently PASSES
    var validationResult = await AEDPoSContractStub.ValidateConsensusBeforeExecution
        .CallAsync(maliciousTinyBlockHeader.ToBytesValue());
    
    // BUG: Validation passes even though behavior type is wrong
    validationResult.Success.ShouldBeTrue(); // This demonstrates the vulnerability
    
    // Process the malicious tiny block
    var randomNumber = await GenerateRandomProofAsync(secondMinerKeyPair);
    await AEDPoSContractStub.UpdateTinyBlockInformation.SendAsync(new TinyBlockInput
    {
        ActualMiningTime = Context.CurrentBlockTime,
        RoundId = currentRound.RoundId,
        RandomNumber = ByteString.CopyFrom(randomNumber)
    });
    
    // Verify impact: OutValue still null (consensus data not submitted)
    var roundAfter = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerAfter = roundAfter.RealTimeMinersInformation[secondMinerKeyPair.PublicKey.ToHex()];
    minerAfter.OutValue.ShouldBeNull(); // Critical consensus data missing!
    minerAfter.Signature.ShouldBeNull(); // Signature not provided!
    
    // This proves the miner bypassed UpdateValue submission requirements
}
```

## Notes

The vulnerability exists because the consensus validation architecture assumes miners will honestly submit the behavior type returned by `GetConsensusCommand`. However, since the behavior type is client-controlled and included in the block header, a malicious miner can modify their node software to submit a different behavior type. The validation logic never verifies that the submitted behavior matches what should be expected based on the miner's current state in the round, creating this bypass opportunity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L92-114)
```csharp
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-75)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L9-34)
```csharp
    private class LastIrreversibleBlockHeightCalculator
    {
        private readonly Round _currentRound;
        private readonly Round _previousRound;

        public LastIrreversibleBlockHeightCalculator(Round currentRound, Round previousRound)
        {
            _currentRound = currentRound;
            _previousRound = previousRound;
        }

        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
    }
```
