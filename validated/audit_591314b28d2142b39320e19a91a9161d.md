# Audit Report

## Title
Broken ImpliedIrreversibleBlockHeight Validation Allows Consensus Finality Manipulation

## Summary
The `LibInformationValidationProvider` contains a critical logic flaw where the base round state is modified before validation, rendering the regression check permanently ineffective. Additionally, a zero-value bypass allows miners to submit `ImpliedIrreversibleBlockHeight = 0`, potentially disrupting Last Irreversible Block (LIB) calculations and stalling chain finality.

## Finding Description

The AEDPoS consensus validation flow contains a fundamental ordering defect. When validating `UpdateValue` consensus behavior, the `ValidateBeforeExecution` method calls `RecoverFromUpdateValue` to merge provided round data into the base round **before** validation providers are executed. [1](#0-0) 

This recovery operation directly copies the `ImpliedIrreversibleBlockHeight` from the provided round into the base round that will subsequently be used for validation: [2](#0-1) 

After this state mutation, the `LibInformationValidationProvider` is added to the validation chain: [3](#0-2) 

The validator's regression check compares the base round's value against the provided round's value. However, the `ProvidedRound` property returns `ExtraData.Round`, which is the same source that was already copied into `BaseRound`: [4](#0-3) [5](#0-4) 

**Critical Bug**: Since `RecoverFromUpdateValue` already copied `providedRound[pubkey].ImpliedIrreversibleBlockHeight` to `baseRound[pubkey].ImpliedIrreversibleBlockHeight`, the comparison checks if a value is greater than itself—a condition that can never be true.

**Zero-Value Bypass**: Line 24 contains an additional flaw that skips validation entirely when `ImpliedIrreversibleBlockHeight = 0`, allowing regression from any valid height to zero without triggering validation failure.

The unvalidated value is then written to state during block processing: [6](#0-5) 

This affects LIB calculation, as zero values are filtered out: [7](#0-6) 

If sufficient miners submit zero values, the count falls below the consensus threshold, causing LIB calculation to return 0: [8](#0-7) 

The consensus threshold is defined as 2/3 + 1 of total miners: [9](#0-8) 

## Impact Explanation

**Consensus Finality Disruption**: The broken validation enables a compromised or malicious miner to submit `ImpliedIrreversibleBlockHeight = 0` or regressed values in their consensus updates. When miners with zero values are filtered out during LIB calculation, if the remaining count falls below `MinersCountOfConsent`, the LIB returns 0, effectively stalling chain finality.

This impacts:
- **Cross-chain security**: Cross-chain operations rely on LIB heights for irreversibility guarantees
- **Transaction finality**: Users cannot trust that transactions are irreversible  
- **Network integrity**: The consensus mechanism's core finality guarantees are compromised

The broader security issue is that **no regression validation is being performed** on this critical consensus parameter due to the ordering bug.

## Likelihood Explanation

**Prerequisites**:
- Requires control of one or more miner nodes (elected consensus participants)
- Miner must modify node software to submit malicious `ImpliedIrreversibleBlockHeight` values
- Normal consensus logic sets this value correctly: [10](#0-9) 

**Attack Complexity**: Low—once a miner node is compromised, submitting invalid values is trivial since validation is non-functional.

**Detection**: The attack would be visible in block explorer data and LIB progression metrics, making it detectable but potentially difficult to prevent in real-time.

**Probability**: Medium-Low—Requires compromising trusted miner infrastructure, but the validation being completely broken means there are no technical barriers once a miner is compromised.

## Recommendation

Fix the ordering issue by performing validation **before** state mutation. The validation should compare the original state against the provided values, not the already-mutated state.

Suggested fix in `ValidateBeforeExecution`:

1. Remove the early `RecoverFromUpdateValue` call (line 47)
2. Let validators compare the original `baseRound` against `providedRound`  
3. Only apply `RecoverFromUpdateValue` **after** all validations pass, during the actual processing phase

Additionally, remove or reconsider the zero-value bypass on line 24 of `LibInformationValidationProvider.cs`, as it allows complete regression without validation.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test miner node
2. Modifying the consensus data generation to set `ImpliedIrreversibleBlockHeight = 0` or to a regressed value
3. Submitting the block with `UpdateValue` behavior
4. Observing that validation passes despite the invalid regression
5. Confirming the corrupted value is written to state
6. Verifying that with sufficient miners submitting zeros, LIB calculation returns 0

The core issue is observable in the code flow itself: the comparison in `LibInformationValidationProvider` compares `baseRound[pubkey].ImpliedIrreversibleBlockHeight > providedRound[pubkey].ImpliedIrreversibleBlockHeight` after both have been set to the same value by `RecoverFromUpdateValue`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-29)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```
