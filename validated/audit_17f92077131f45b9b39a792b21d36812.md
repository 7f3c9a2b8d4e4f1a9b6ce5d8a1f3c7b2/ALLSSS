# Audit Report

## Title
Decimal Overflow in Bancor Exponential Calculation Causes DoS of Token Conversion Operations

## Summary
The `Exp()` function in BancorHelper computes exponentials using `Pow(y, 20)` without bounds checking. When connector weights have extreme ratios (>40), the computation overflows decimal.MaxValue, causing an OverflowException that permanently reverts all Buy and Sell transactions for the affected token pair until governance intervention.

## Finding Description

The vulnerability exists in the exponential calculation used by the Bancor pricing formula. The `Exp()` function implements a Taylor series expansion that computes powers up to `y^20`. [1](#0-0) 

At each iteration, it calls `Pow(y, (uint)iteration)` where iteration ranges from 20 down to 1, without any validation on the magnitude of y. [2](#0-1) 

**How the Argument Becomes Large:**

In `GetAmountToPayFromReturn()` (Buy operation), the argument to `Exp()` is computed as `y * Ln(x)` where `y = toConnectorWeight / fromConnectorWeight`. [3](#0-2) 

In `GetReturnFromPaid()` (Sell operation), the argument is `y * Ln(x)` where `y = fromConnectorWeight / toConnectorWeight`. [4](#0-3) 

**Why Protections Fail:**

Connector weights are only validated to be between 0 and 1 (exclusive) via `IsBetweenZeroAndOne()`. [5](#0-4) [6](#0-5) 

However, the **ratio** of two weights is unbounded. For example, weights 0.98 and 0.02 yield ratio 49, which is explicitly allowed by the validation but causes overflow when multiplied by maximum Ln(x) values.

The Buy and Sell methods have no try-catch blocks to handle overflow exceptions. [7](#0-6) [8](#0-7) 

AElf requires `CheckForOverflowUnderflow` to be enabled for all contracts, ensuring arithmetic overflow throws System.OverflowException that reverts transactions. [9](#0-8) [10](#0-9) 

## Impact Explanation

**Severity: HIGH**

**Concrete Harm:**
1. **Complete DoS**: All Buy and Sell operations fail with OverflowException for any token pair configured with weight ratio > ~40
2. **Fund Lockup**: Users cannot trade out of positions, effectively locking their funds in the affected token until governance intervenes
3. **Protocol Revenue Loss**: No trading fees can be collected, treasury receives no donations from the affected pair
4. **Systemic Impact**: TokenConverter contract becomes non-functional for the affected trading pair

**Affected Parties:**
- All users holding or attempting to trade the affected token pair
- Protocol treasury and fee recipients lose expected revenue
- Overall protocol utility is impaired

The vulnerability breaks the core security guarantee that users can always trade tokens through the TokenConverter contract. Once triggered, there is no user-level recovery mechanism - only governance intervention to modify weights can restore functionality.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Preconditions:**
- A token pair must be configured with weight ratio > ~40 (e.g., 0.98:0.02 or 0.976:0.024)
- Such configurations are ALLOWED by current validation logic that only checks individual weights are between 0 and 1
- Weights are set through governance (Parliament contract) via UpdateConnector [11](#0-10) 

**Trigger Scenarios:**
1. **Malicious governance proposal**: Attacker with governance influence proposes extreme weight ratios
2. **Accidental misconfiguration**: Governance accidentally sets extreme weights (e.g., typo: 0.98 instead of 0.098)
3. **Intentional economic design**: Designers choose extreme weights for specific economic properties without realizing the overflow risk

**Attack Complexity: LOW**
- Once extreme weights are configured, ANY user calling Buy() or Sell() triggers the DoS
- No special privileges required beyond normal user access
- Transaction parameters are straightforward (symbol, amount)

**Probability:** HIGH if extreme weight ratios are ever configured (either maliciously or accidentally). Given that the validation explicitly allows any weight between 0 and 1, such configurations are easily achievable.

## Recommendation

Implement ratio validation when setting or updating connector weights:

1. Add a maximum allowed weight ratio constant (e.g., MAX_WEIGHT_RATIO = 20)
2. In `AssertValidConnectorWeight()`, validate the ratio between paired connector weights:
   - Get the related connector's weight
   - Calculate ratio = max(weight1/weight2, weight2/weight1)
   - Assert ratio <= MAX_WEIGHT_RATIO

3. Alternatively, add bounds checking in `Exp()` function:
   - Check if |y| > 27 before computing powers
   - Throw InvalidValueException with descriptive message

4. Consider adding try-catch in Buy/Sell methods as defense-in-depth to provide better error messages.

## Proof of Concept

```csharp
[Fact]
public async Task Buy_With_Extreme_Weight_Ratio_Causes_Overflow_DoS_Test()
{
    // Setup: Create connectors with extreme weight ratio (49:1)
    var extremeWeightConnector1 = new Connector
    {
        Symbol = "EXTREME1",
        VirtualBalance = 100_0000,
        Weight = "0.98",  // 98%
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "EXTREME2",
        IsDepositAccount = true
    };
    
    var extremeWeightConnector2 = new Connector
    {
        Symbol = "EXTREME2",
        VirtualBalance = 0,
        Weight = "0.02",  // 2% - ratio is 0.98/0.02 = 49
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = false,
        RelatedSymbol = "EXTREME1",
        IsDepositAccount = false
    };
    
    // Initialize with extreme weights (passes validation)
    await CreateTokenWithSymbol("EXTREME2");
    var initResult = await DefaultStub.Initialize.SendAsync(new InitializeInput
    {
        BaseTokenSymbol = "ELF",
        FeeRate = "0.005",
        Connectors = { extremeWeightConnector1, extremeWeightConnector2 }
    });
    initResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attempt Buy operation - should fail with OverflowException
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = "EXTREME2",
        Amount = 50_0000,  // Significant amount to maximize Ln(x)
        PayLimit = 0
    });
    
    // Verify DoS: Transaction fails with overflow
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    buyResult.TransactionResult.Error.ShouldContain("System.OverflowException");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L51-53)
```csharp
        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/project.md (L20-30)
```markdown
- It is required to enable `CheckForOverflowUnderflow` for both Release and Debug mode so that your contract will use arithmetic operators that will throw `OverflowException` if there is any overflow. This is to ensure that execution will not continue in case of an overflow in your contract and result with unpredictable output.

```xml
<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>
```
```

**File:** test/AElf.Contracts.TestContract.Tests/ContractSecurityTests.cs (L30-41)
```csharp
        var transactionResult = (await TestBasicSecurityContractStub.TestInt32State.SendWithExceptionAsync(
            new Int32Input
            {
                Int32Value = 100
            })).TransactionResult;
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        transactionResult.Error.Contains("System.OverflowException").ShouldBeTrue();

        //state not change
        var resultValue1 = (await TestBasicSecurityContractStub.QueryInt32State.CallAsync(
            new Empty())).Int32Value;
        resultValue1.ShouldBe(int.MaxValue);
```
