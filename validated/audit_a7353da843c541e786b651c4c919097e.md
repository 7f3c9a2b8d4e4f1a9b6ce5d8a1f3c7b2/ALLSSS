# Audit Report

## Title
Cross-Chain NFT Type Metadata Desynchronization Leading to Protocol Info Corruption

## Summary
The `CrossChainCreate()` method in the NFT contract ignores the authoritative NFT type stored in `tokenInfo.ExternalInfo[NftTypeMetadataKey]` and instead derives it from the symbol's first two characters using a local chain-specific mapping. This breaks cross-chain consistency when custom NFT types are added via governance, causing DoS and permanent protocol data corruption.

## Finding Description

When an NFT protocol is created on the mainchain via `Create()`, the NFT type is explicitly stored in the token's ExternalInfo metadata: [1](#0-0) 

This authoritative value is preserved during cross-chain token creation by the MultiToken contract, which correctly maintains ExternalInfo across chains: [2](#0-1) 

However, the `CrossChainCreate()` method completely ignores this authoritative value: [3](#0-2) 

Instead of reading `tokenInfo.ExternalInfo.Value[NftTypeMetadataKey]`, the method extracts the first 2 characters from the symbol and looks them up in the **local sidechain's** `State.NFTTypeFullNameMap`, throwing an error if the mapping doesn't exist. It then uses this locally-mapped value as the NFT type: [4](#0-3) 

The NFT type mappings are managed independently on each chain via the governance-controlled `AddNFTType` method: [5](#0-4) 

This method only modifies the **local chain's** state and provides no cross-chain synchronization mechanism. The mappings are stored in chain-local state variables: [6](#0-5) 

**Security Guarantee Violated:**

The protocol guarantees cross-chain consistency of token and NFT metadata. When an NFT protocol is cross-chain created, it should maintain identical properties across chains. By deriving the NFT type from a local mapping instead of the authoritative ExternalInfo value, this guarantee is broken.

The constant defining the metadata key exists but is unused in cross-chain creation: [7](#0-6) 

## Impact Explanation

**Concrete Harm Scenarios:**

1. **DoS of Cross-Chain NFT Creation:** If Parliament adds a custom NFT type on mainchain (e.g., "CustomArt" → "CA") via `AddNFTType` and creates an NFT protocol with this type, calling `CrossChainCreate` on any sidechain without this mapping will fail with "Full name of CA not found", completely blocking legitimate cross-chain NFT protocol creation.

2. **Protocol Info Corruption:** If mainchain and sidechain have conflicting mappings for the same short name (e.g., mainchain: "CT" → "CustomType", sidechain: "CT" → "CollectibleType"), the same NFT protocol will have **different NftType values on different chains**, violating the fundamental cross-chain consistency requirement.

3. **Internal Metadata Inconsistency:** The NFT protocol's `Metadata` field correctly preserves the mainchain's ExternalInfo: [8](#0-7) 

But the `NftType` field uses the incorrect locally-derived value, creating contradictory type information within the same protocol data structure.

**Affected Parties:**
- NFT protocol creators using custom types via governance
- Cross-chain applications relying on consistent NFT classification
- Marketplaces and explorers querying NFT protocol information
- Indexers displaying NFT metadata

**Severity: HIGH** - Violates critical cross-chain integrity invariants, causes permanent protocol data corruption, and can DoS legitimate operations.

## Likelihood Explanation

This is a design flaw that manifests through normal protocol operations:

1. **Public Entry Point:** `CrossChainCreate` is a public method with no authorization checks: [9](#0-8) 

Any user can call it after the underlying token is cross-chain created.

2. **Realistic Preconditions:** Only requires Parliament on any chain to use the legitimate `AddNFTType` governance function: [10](#0-9) 

3. **Execution Flow:**
   - Parliament on mainchain adds custom NFT type via proposal → approved and executed
   - User creates NFT protocol with custom type on mainchain → succeeds
   - Token is cross-chain created to sidechain via standard flow → ExternalInfo preserved
   - Any user calls `CrossChainCreate` on sidechain → immediate failure or corruption

4. **Detection Difficulty:** When types mismatch (corruption scenario), no error is thrown. The inconsistent data persists permanently with silent corruption.

**Probability: HIGH** - Any use of custom NFT types (an intended governance feature) combined with cross-chain NFT operations (a core protocol feature) triggers this vulnerability.

## Recommendation

Modify `CrossChainCreate()` to read the NFT type directly from the authoritative ExternalInfo instead of deriving it from local mappings:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
    var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
    // FIX: Read NFT type from authoritative source
    var nftTypeFullName = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];
    
    var nftProtocolInfo = new NFTProtocolInfo
    {
        Symbol = input.Symbol,
        TotalSupply = tokenInfo.TotalSupply,
        BaseUri = baseUri,
        Creator = tokenInfo.Issuer,
        IsBurnable = tokenInfo.IsBurnable,
        IssueChainId = tokenInfo.IssueChainId,
        IsTokenIdReuse = isTokenIdReuse,
        Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
        ProtocolName = tokenInfo.TokenName,
        NftType = nftTypeFullName  // Use authoritative value
    };
    
    State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
    // ... rest of the method
}
```

This ensures cross-chain consistency by always using the NFT type value that was set during the original `Create()` call on the mainchain.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithCustomNFTType_ShouldFailOrCorrupt()
{
    // Setup: Parliament adds custom NFT type "CustomArt" -> "CA" on mainchain
    await ParliamentContractStub.AddNFTType.SendAsync(new AddNFTTypeInput
    {
        FullName = "CustomArt",
        ShortName = "CA"
    });
    
    // Create NFT protocol on mainchain with custom type
    var createResult = await NftContractStub.Create.SendAsync(new CreateInput
    {
        NftType = "CustomArt",
        ProtocolName = "Test Protocol",
        TotalSupply = 1000,
        // ... other fields
    });
    var symbol = createResult.Output.Value; // e.g., "CA123456789"
    
    // Verify mainchain NFT protocol has correct type
    var mainchainProtocol = await NftContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    mainchainProtocol.NftType.ShouldBe("CustomArt");
    
    // Simulate cross-chain token creation (TokenContract preserves ExternalInfo)
    await TokenContractStub.CrossChainCreateToken.SendAsync(/* cross-chain data */);
    
    // Attempt to call CrossChainCreate on sidechain without the custom mapping
    // Expected: Should fail with "Full name of CA not found"
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await SidechainNftContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    exception.Message.ShouldContain("Full name of CA not found");
    
    // Alternative: If sidechain has different mapping "CA" -> "CollectableArt"
    await SidechainParliamentContractStub.AddNFTType.SendAsync(new AddNFTTypeInput
    {
        FullName = "CollectableArt",  // DIFFERENT from mainchain
        ShortName = "CA"
    });
    
    // Now CrossChainCreate succeeds but with WRONG type
    await SidechainNftContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = symbol
    });
    
    // Verify corruption: same protocol has different NftType across chains
    var sidechainProtocol = await SidechainNftContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    sidechainProtocol.NftType.ShouldBe("CollectableArt");  // Wrong! Should be "CustomArt"
    
    // Internal inconsistency: Metadata has "CustomArt" but NftType has "CollectableArt"
    sidechainProtocol.Metadata.Value["aelf_nft_type"].ShouldBe("CustomArt");  // From ExternalInfo
    sidechainProtocol.NftType.ShouldNotBe(sidechainProtocol.Metadata.Value["aelf_nft_type"]);  // CONTRADICTION!
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-75)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-93)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L104-104)
```csharp
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L106-106)
```csharp
            NftType = nftTypeFullName
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-143)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-196)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-36)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-7)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
```
