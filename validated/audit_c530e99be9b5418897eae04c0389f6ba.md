# Audit Report

## Title
Extra Block Producer Can Delay Secret Revelation by Manipulating NextRound Block Timing

## Summary
The AEDPoS consensus validation flow contains a critical timing validation gap for NextRound block transitions. When producing a NextRound block, `TimeSlotValidationProvider` only validates the structural correctness of the new round data but does not enforce timing constraints on when the block is produced. This allows the extra block producer to delay revealing secrets via `RevealSharedInValues()`, violating the fairness guarantees of the secret sharing mechanism.

## Finding Description

The vulnerability exists in the validation logic that checks consensus block production timing.

During NextRound block generation, the `RevealSharedInValues()` function is called to reconstruct and reveal other miners' secret in-values using secret sharing. [1](#0-0) 

The critical flaw is in `TimeSlotValidationProvider`. When a new round is being produced (indicated by `ProvidedRound.RoundId != BaseRound.RoundId`), the validator only calls `CheckRoundTimeSlots()` to validate structural correctness. [2](#0-1) 

The `CheckRoundTimeSlots()` method only validates that all miners have valid `ExpectedMiningTime` values, that mining intervals are positive, and that time slots are evenly spaced—it never checks `Context.CurrentBlockTime`. [3](#0-2) 

In contrast, for same-round blocks, `TimeSlotValidationProvider` calls `CheckMinerTimeSlot()` which validates that the miner is producing within their designated time window. [4](#0-3)  However, this timing validation is explicitly bypassed for NextRound transitions.

The other validators for NextRound behavior also do not check timing. `NextRoundMiningOrderValidationProvider` only validates mining order correctness [5](#0-4)  and `RoundTerminateValidationProvider` only validates round/term number increments. [6](#0-5) 

While the expected extra block mining time is calculated via `GetExtraBlockMiningTime()`, [7](#0-6)  this value is never enforced during NextRound validation. It's only used in the `IsCurrentMiner()` view method, [8](#0-7)  which determines when a node should attempt to mine, not as an on-chain validation constraint.

The validation service for NextRound behavior includes `TimeSlotValidationProvider` but it does not enforce timing for new rounds. [9](#0-8) 

## Impact Explanation

This vulnerability compromises a critical consensus invariant: the timely and fair revelation of secret values used in randomness generation and mining order determination.

**Consensus Integrity Violation**: The secret sharing mechanism in AEDPoS relies on all miners revealing their secrets in a timely manner to maintain fairness. The `RevealSharedInValues()` method reconstructs other miners' secret in-values using secret sharing data from the previous round. [10](#0-9)  By delaying the NextRound block, the extra block producer gains an unfair information advantage, seeing network transactions, mempool contents, and other miners' actions before committing to reveal secrets.

**Specific Harms**:
1. **Timing Manipulation**: The extra block producer can strategically time round transitions to their advantage
2. **Information Asymmetry**: Observing network state before secret revelation undermines randomness guarantees
3. **MEV-like Exploitation**: Similar to MEV attacks, the attacker can order or time their block to extract value
4. **Attack Window**: The extra block producer has exclusive rights during their time slot, which they can manipulate [11](#0-10) 

The severity is Medium because while it doesn't directly steal funds, it breaks a fundamental consensus protocol assumption (timely round transitions and fair secret revelation), potentially affecting block production order fairness and randomness generation across the entire network.

## Likelihood Explanation

**Attacker Profile**: Any validator in the consensus set can execute this attack when designated as the extra block producer for a round. The extra block producer role is determined by the `IsExtraBlockProducer` flag in the round information. [12](#0-11) 

**Attack Execution**: The attack has very low complexity—the attacker simply delays calling the consensus command that produces the NextRound block. The command is generated through `TerminateRoundCommandStrategy` [13](#0-12)  but there's no on-chain enforcement of when the block must be produced.

**Preconditions**:
- Attacker must be in the miner list (realistic for any block producer)
- Attacker must be designated as extra block producer for that round (1/N probability where N = number of miners)
- No additional compromises required

**Detection Difficulty**: The delay appears as normal network latency or processing time, making it difficult to distinguish malicious delays from legitimate network issues.

**Probability Assessment**: Medium-High. Every extra block producer has both the opportunity (when it's their turn) and potential incentive (gaining timing advantage) to exploit this validation gap. Given that validators rotate through this role regularly, the attack surface is persistent.

## Recommendation

Add timing validation for NextRound blocks in `TimeSlotValidationProvider`. When a new round is being produced, validate that `Context.CurrentBlockTime` is within an acceptable window relative to `GetExtraBlockMiningTime()`.

Specifically, modify `TimeSlotValidationProvider.ValidateHeaderInformation()` to check that NextRound blocks are produced at or after the expected extra block mining time, with a reasonable tolerance for network latency.

The fix should add a timing check similar to `CheckMinerTimeSlot()` but specifically for the extra block producer role during NextRound transitions, ensuring the block is not produced arbitrarily early or late relative to the designated extra block time slot.

## Proof of Concept

A malicious extra block producer can exploit this by:

1. Being designated as the extra block producer for round N (via `IsExtraBlockProducer` flag)
2. Waiting beyond `GetExtraBlockMiningTime()` to observe network state
3. Producing the NextRound block with delayed timing
4. The block passes validation because `TimeSlotValidationProvider` only calls `CheckRoundTimeSlots()` which doesn't check `Context.CurrentBlockTime`
5. Secrets are revealed via `RevealSharedInValues()` at the delayed time, giving the attacker information advantage

The vulnerability can be demonstrated by showing that a NextRound block produced significantly after `GetExtraBlockMiningTime()` still passes all validation checks, while the same delay for a same-round block would fail `CheckMinerTimeSlot()` validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L24-30)
```csharp
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L173-178)
```csharp
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-31)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```
