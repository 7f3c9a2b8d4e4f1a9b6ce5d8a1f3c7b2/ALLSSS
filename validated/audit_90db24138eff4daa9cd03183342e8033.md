# Audit Report

## Title
Missing Miner Order Validation in NextTerm Allows Mining Schedule Manipulation

## Summary
The AEDPoS consensus contract fails to validate miner `Order` values during NextTerm transitions. While the protocol expects deterministic Order assignment based on public key sorting, no validator checks this constraint. A malicious miner proposing a NextTerm block can manipulate Order values to gain favorable mining positions, breaking consensus integrity.

## Finding Description

The AEDPoS consensus mechanism deterministically assigns miner orders by sorting miners by the first byte of their public key in descending order, then assigning sequential Order values (1, 2, 3...). [1](#0-0) 

When a NextTerm block is proposed, `NextTermInput.Create()` simply copies the `RealTimeMinersInformation` from the provided Round without validation. [2](#0-1) 

During validation, `ValidateBeforeExecution` for NextTerm behavior only adds `RoundTerminateValidationProvider` to the validation chain. [3](#0-2) 

Critically, `RoundTerminateValidationProvider.ValidationForNextTerm()` only validates round number progression, term number progression, and that InValues are null - it does NOT validate Order values. [4](#0-3) 

The `TimeSlotValidationProvider` checks time slot spacing, but it uses the PROVIDED Order values to sort miners without verifying they match the expected deterministic assignment. [5](#0-4) 

Notably, NextRound behavior includes `NextRoundMiningOrderValidationProvider` for order validation [6](#0-5) , but NextTerm lacks equivalent validation despite also requiring deterministic Order assignment.

The consensus extra data is generated correctly via `GetConsensusExtraDataForNextTerm` → `GenerateFirstRoundOfNextTerm` → `MinerList.GenerateFirstRoundOfNewTerm`. [7](#0-6) 

However, a malicious miner running modified node software can alter Order values after generation but before block inclusion. When other nodes validate the block, they do not regenerate the expected Round and compare Order values - they only check logical consistency.

Finally, `ProcessNextTerm` directly uses the provided Round without additional Order validation, storing the manipulated Order values to state. [8](#0-7) 

## Impact Explanation

**HIGH Severity** - This vulnerability breaks fundamental consensus assumptions:

1. **Mining Schedule Integrity Violated**: Attackers can swap Order values to assign themselves earlier mining positions (e.g., Order 1 instead of Order 7), gaining unfair advantage in the block production sequence.

2. **Consensus Determinism Broken**: The protocol's deterministic Order assignment based on public key sorting is bypassed, allowing arbitrary scheduling that contradicts the consensus rules.

3. **Repeated Exploitation**: The attack can be executed at every term transition (default ~7 days), providing persistent advantage throughout the blockchain's lifetime.

4. **Network-Wide Impact**: All network participants are affected as the mining schedule governs when each miner produces blocks, impacting transaction ordering, MEV opportunities, and block reward distribution.

5. **Validation Asymmetry**: The existence of `NextRoundMiningOrderValidationProvider` for NextRound but not for NextTerm indicates this is an oversight rather than intentional design, confirming the validation gap is a genuine security issue.

## Likelihood Explanation

**MODERATE-HIGH Likelihood**:

1. **Accessible Precondition**: Any current miner can exploit this during their turn to propose the NextTerm block, which occurs periodically in the consensus rotation.

2. **Technical Feasibility**: While exploitation requires running modified node software to alter consensus extra data before block inclusion, this is within the capabilities of sophisticated mining operators.

3. **Low Detection Risk**: The malicious Order values pass all existing validation checks. There is no mechanism to detect that Order values don't match the expected deterministic assignment.

4. **Economic Incentive**: Miners have strong motivation to gain favorable mining positions for increased block rewards and potential MEV extraction.

5. **Regular Opportunity**: Term transitions occur regularly (default ~7 days), providing repeated exploitation windows.

## Recommendation

Add Order validation for NextTerm behavior similar to NextRound. Create a `NextTermMiningOrderValidationProvider` that:

1. Retrieves the expected miner list from `ElectionContract.GetVictories()` 
2. Regenerates the expected Round using `MinerList.GenerateFirstRoundOfNewTerm()` with the same sorting logic
3. Compares the provided Order values with the expected Order values
4. Rejects blocks where Order values don't match the deterministic assignment

Add this validator to the NextTerm validation chain in `ValidateBeforeExecution`: [3](#0-2) 

## Proof of Concept

A valid PoC would require:
1. Setting up a test blockchain with multiple miners
2. Triggering a NextTerm transition
3. Modifying the Order values in the consensus extra data before block proposal
4. Verifying the block passes validation despite incorrect Order values
5. Confirming the manipulated Order values are persisted to state

The vulnerability is confirmed by code inspection showing the absence of Order validation in the NextTerm validation path, contrasted with its presence in NextRound validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-31)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```
