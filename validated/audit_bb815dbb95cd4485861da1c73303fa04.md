# Audit Report

## Title
Regex Anchor Bypass Allows Invalid Token Symbols with Trailing Newlines

## Summary
The token symbol validation functions use the C# regex `$` anchor which matches before a trailing newline character, allowing attackers to create multiple tokens with visually identical symbols (e.g., `"ABC"` and `"ABC\n"`). This bypasses the symbol uniqueness invariant and enables symbol collision attacks where malicious tokens can impersonate legitimate ones.

## Finding Description

The AElf MultiToken contract contains three regex validation functions that use the `$` anchor without proper end-of-string anchoring. [1](#0-0) 

In C# .NET regex, the `$` anchor has special behavior: it matches at the end of the string **OR** before a trailing `\n` character. This means `Regex.IsMatch("ABC\n", "^[a-zA-Z0-9]+$")` returns TRUE when it should return FALSE, because the pattern matches "ABC" and `$` matches the position before the trailing newline.

The vulnerability is triggered through the public `Create` method which accepts user input for token creation. [2](#0-1) 

When a user calls `Create` with `input.Symbol = "ABC\n"`, the validation flow proceeds as:

1. **GetSymbolType validation**: The method splits the symbol and validates the prefix using `IsValidCreateSymbol`, which incorrectly accepts symbols with trailing newlines. [3](#0-2) 

2. **Token creation and registration**: The `CreateToken` method creates a TokenInfo object with the unvalidated symbol and proceeds to register it. [4](#0-3) 

3. **RegisterTokenInfo validation**: This function also validates using `IsValidSymbol` which has the same `$` anchor flaw, then stores the token with the newline-containing symbol in contract state. [5](#0-4) 

4. **Insufficient duplicate check**: The uniqueness check uses `symbol.ToUpper()` which preserves the newline character. In C#, `"ABC\n".ToUpper()` returns `"ABC\n"` (not `"ABC"`). [6](#0-5) 

Therefore, `"ABC"` and `"ABC\n"` are treated as distinct tokens in the state mappings `State.TokenInfos` and `State.InsensitiveTokenExisting`, despite being visually identical to users.

## Impact Explanation

**Protocol Invariant Violation**: The fundamental invariant that each token has a unique, visually distinguishable symbol is broken. Multiple tokens can exist with identical visual representations, violating the core design assumption of the token system.

**Symbol Collision Attack**: Attackers can create tokens with symbols like `"USDT\n"`, `"USDT\r"`, or other control character variations that all appear identical to the legitimate `"USDT"` token in user interfaces, blockchain explorers, and wallet applications that render these control characters as whitespace.

**User Confusion and Scams**: Users cannot distinguish between legitimate tokens and malicious duplicates. An attacker can exploit this by:
1. Monitoring for creation of valuable tokens with specific symbols
2. Immediately creating duplicate tokens with trailing newlines or other control characters
3. Distributing the malicious tokens through airdrops or social channels
4. Convincing users that the fake token is legitimate
5. Executing rug pulls, pump-and-dump schemes, or other scams

**State Pollution**: The contract state becomes polluted with symbols containing non-printable control characters (`\n`, `\r`, etc.), which may break external integrations, indexers, APIs, and tools that assume symbols contain only printable alphanumeric characters as defined by the validation rules.

The severity is **Medium** because while direct fund theft does not occur through this vulnerability alone, it enables significant social engineering attacks, violates a core protocol invariant, and creates systemic confusion in the token ecosystem.

## Likelihood Explanation

**Publicly Reachable**: The `Create` method is a public entry point accessible to any user who meets the standard token creation requirements. [2](#0-1) 

**Feasible Preconditions**: The attacker needs to obtain a seed NFT or be added to the create whitelist. [7](#0-6)  While this represents a moderate barrier, seed NFTs can be purchased on secondary markets or obtained through legitimate participation in the ecosystem, making the attack feasible for any motivated attacker with moderate resources.

**Simple Execution**: The exploit requires only passing a symbol string with a trailing newline character to the `Create` method through a standard transaction. No complex state manipulation, precise timing requirements, or privilege escalation is needed. The protobuf string type used for the symbol field accepts any characters including newlines without sanitization. [8](#0-7) 

**Difficult Detection**: Trailing newlines and other control characters are invisible in most debugging outputs, logs, and UI displays. The vulnerability is subtle and unlikely to be caught through normal testing, code review, or runtime monitoring unless specifically tested for.

**Deterministic and Reliable**: The exploit is reproducible and deterministic - it will succeed every time as the regex behavior is a consistent feature of the C# .NET regex engine, not a race condition or environmental dependency.

The likelihood is **Medium** - the attack is practical and highly reliable once the moderate precondition (seed NFT ownership) is met.

## Recommendation

Replace the `$` anchor with `\z` in all three validation functions to match only at the absolute end of the string, not before a trailing newline. Additionally, add explicit input sanitization:

```csharp
private static bool IsValidSymbol(string symbol)
{
    return Regex.IsMatch(symbol, @"^[a-zA-Z0-9]+(-[0-9]+)?\z");
}

private bool IsValidItemId(string symbolItemId)
{
    return Regex.IsMatch(symbolItemId, @"^\d+\z");
}

private bool IsValidCreateSymbol(string symbol)
{
    return Regex.IsMatch(symbol, @"^[a-zA-Z0-9]+\z");
}
```

Alternatively, use `RegexOptions.ECMAScript` which makes `$` match only at the end of the string:

```csharp
private static bool IsValidSymbol(string symbol)
{
    return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$", RegexOptions.ECMAScript);
}
```

Additionally, add input sanitization at the entry point to reject any symbols containing control characters:

```csharp
private void ValidateSymbolInput(string symbol)
{
    Assert(!string.IsNullOrWhiteSpace(symbol), "Symbol cannot be null or whitespace.");
    Assert(!symbol.Any(c => char.IsControl(c)), "Symbol cannot contain control characters.");
}
```

## Proof of Concept

```csharp
[Fact]
public void Test_Regex_Anchor_Bypass_With_Trailing_Newline()
{
    // This test demonstrates the C# regex $ anchor behavior
    // that allows symbols with trailing newlines to pass validation
    
    var symbolWithNewline = "ABC\n";
    var symbolWithoutNewline = "ABC";
    
    // Both patterns from the contract
    var createSymbolPattern = "^[a-zA-Z0-9]+$";
    var generalSymbolPattern = "^[a-zA-Z0-9]+(-[0-9]+)?$";
    
    // The vulnerability: both return TRUE when only the second should
    var createResult = Regex.IsMatch(symbolWithNewline, createSymbolPattern);
    var generalResult = Regex.IsMatch(symbolWithNewline, generalSymbolPattern);
    
    createResult.ShouldBeTrue(); // BUG: Should be false
    generalResult.ShouldBeTrue(); // BUG: Should be false
    
    // Demonstrate ToUpper() preserves newlines
    var upperWithNewline = symbolWithNewline.ToUpper();
    var upperWithoutNewline = symbolWithoutNewline.ToUpper();
    
    upperWithNewline.ShouldBe("ABC\n"); // Newline is preserved
    upperWithoutNewline.ShouldBe("ABC");
    
    // These are treated as different keys in state mappings
    (upperWithNewline == upperWithoutNewline).ShouldBeFalse();
    
    // Fix verification: using \z anchor rejects trailing newlines
    var fixedPattern = @"^[a-zA-Z0-9]+\z";
    Regex.IsMatch(symbolWithNewline, fixedPattern).ShouldBeFalse(); // Correctly rejects
    Regex.IsMatch(symbolWithoutNewline, fixedPattern).ShouldBeTrue(); // Correctly accepts
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-31)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }

    private bool IsValidItemId(string symbolItemId)
    {
        return Regex.IsMatch(symbolItemId, "^[0-9]+$");
    }

    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L296-303)
```csharp
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-88)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };

        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }

        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** protobuf/token_contract.proto (L279-281)
```text
message CreateInput {
    // The symbol of the token.
    string symbol = 1;
```
