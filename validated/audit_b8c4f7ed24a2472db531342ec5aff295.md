# Audit Report

## Title
Broken Validation Allows Miners to Manipulate ImpliedIrreversibleBlockHeight and Suppress LIB Finality

## Summary
The AEDPoS consensus validation flow contains a critical ordering bug where `RecoverFromUpdateValue` is called before validation, causing `LibInformationValidationProvider` to compare the provided value against itself rather than the original state value. This allows miners to arbitrarily manipulate their `ImpliedIrreversibleBlockHeight`, and with 1/3+ colluding miners, they can suppress Last Irreversible Block (LIB) advancement indefinitely, breaking finality guarantees.

## Finding Description

The vulnerability exists in the validation flow for consensus block production. During normal operation, when a miner generates consensus block data, the system correctly sets `ImpliedIrreversibleBlockHeight` to the current block height. [1](#0-0) 

However, the validation process has a critical ordering flaw. The `ValidateBeforeExecution` method first retrieves the current round from state into `baseRound`, then immediately calls `RecoverFromUpdateValue` to mutate this object BEFORE validation occurs. [2](#0-1) 

The recovery operation directly overwrites the original `ImpliedIrreversibleBlockHeight` value from state with the provided value. [3](#0-2) 

Subsequently, when `LibInformationValidationProvider` executes, it attempts to validate by comparing `baseRound` (already modified) against `providedRound`. [4](#0-3) 

Since `baseRound[pubkey].ImpliedIrreversibleBlockHeight` was just set equal to `providedRound[pubkey].ImpliedIrreversibleBlockHeight` by the recovery operation, this check compares the value against itself (`X > X`) and always evaluates to false, allowing any value to pass validation.

The validation providers are added and executed after the mutation occurs. [5](#0-4) 

A malicious miner can exploit this by modifying both the block header's `Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` and the transaction's `UpdateValueInput.ImpliedIrreversibleBlockHeight` to the same arbitrary value before signing the block. The manipulated value is then stored directly in state. [6](#0-5) 

This stored value directly influences LIB calculation, which sorts all miners' implied heights and selects the value at index `(count-1)/3`. [7](#0-6) 

Critically, there is **no validation** that `ImpliedIrreversibleBlockHeight <= Context.CurrentHeight` or that it equals the current height during the validation phase.

## Impact Explanation

**LIB Suppression Attack:**
The LIB calculation uses a Byzantine fault-tolerant approach where it takes the value at index `(count-1)/3` from a sorted list of all miners' implied heights. If 1/3 or more miners set artificially low `ImpliedIrreversibleBlockHeight` values (e.g., 0 or slowly increasing values), the selected LIB value will be suppressed. For a network with 21 miners, 7+ malicious miners setting low values will place a low value at the 7th position (index 6), effectively preventing LIB advancement.

**Consequences:**
- **Breaks Finality Guarantees:** Legitimate blocks remain reversible indefinitely, violating the core consensus security property
- **Enables Double-Spend Attacks:** Without finality, long-range reorganizations become theoretically possible, allowing transaction reversals
- **Stalls Cross-Chain Operations:** Cross-chain bridges rely on LIB for irreversibility confirmation before processing cross-chain transfers
- **Undermines Economic Security:** DeFi protocols, payment systems, and any application requiring transaction finality become unreliable

**Severity: Critical** - This breaks a fundamental blockchain security guarantee that protects against reorganization attacks and ensures transaction irreversibility, which is essential for economic finality.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be elected miners through the DPoS voting system
- Need to control approximately 1/3+ of elected miners for sustained impact (7 out of 21 miners in typical mainnet configuration)

**Attack Complexity:**
- **Very Low:** The attack is trivial to execute - simply modify the `ImpliedIrreversibleBlockHeight` values in both the consensus extra data and transaction input before signing
- **No Detection Mechanism:** No validation checks exist to detect manipulated values that differ from `Context.CurrentHeight`
- **100% Reliable:** The validation flaw makes the attack consistently exploitable on every block production

**Feasibility:**
- Attack uses the normal block production flow accessible to all elected miners via the public `UpdateValue` method [8](#0-7) 
- The validation bypass is guaranteed due to the ordering bug
- No cryptographic or consensus assumptions need to be violated

**Economic Rationality:**
For high-value targets (major DeFi protocols, cross-chain bridges with significant TVL), the cost of controlling 1/3 mining power could be economically justified by potential gains from double-spend attacks or extortion scenarios.

**Likelihood: Medium** - While it requires significant resources to control 1/3+ miners, the trivial execution complexity, lack of detection, and guaranteed success make this a realistic threat for well-funded attackers targeting high-value systems.

## Recommendation

**Fix the Validation Ordering:**
Move the `RecoverFromUpdateValue` call to AFTER validation, or preserve the original state values before recovery for comparison. The validation should compare the provided value against the unmodified state value.

**Add Explicit Bound Validation:**
Add explicit checks in `LibInformationValidationProvider` to ensure:
```csharp
// Validate implied height is not greater than current block height
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > Context.CurrentHeight)
{
    validationResult.Message = "Implied irreversible block height cannot exceed current height.";
    return validationResult;
}
```

**Recommended Fix Pattern:**
1. Preserve original `baseRound` before calling `RecoverFromUpdateValue`
2. Use the preserved original values for validation comparisons
3. Add upper bound check against `Context.CurrentHeight`

## Proof of Concept

The vulnerability can be demonstrated by tracing the execution flow:

**Setup:** Network with 21 miners, 7 colluding malicious miners

**Attack Steps:**
1. Malicious miner at block height 1000 prepares to produce block
2. Instead of setting `ImpliedIrreversibleBlockHeight = 1000`, sets it to `10`
3. Modifies both block header consensus data and `UpdateValueInput` transaction to have the same value `10`
4. Signs and produces the block
5. Validation executes:
   - `baseRound` loaded from state (has miner's previous legitimate value, e.g., 990)
   - `RecoverFromUpdateValue` called, overwrites `baseRound[miner].ImpliedIrreversibleBlockHeight = 10`
   - `LibInformationValidationProvider` checks: `10 > 10` → false → validation passes
6. Value `10` is stored in state
7. LIB calculation collects all miners' values: `[10, 10, 10, 10, 10, 10, 10, 995, 996, 997, ...]`
8. Sorted list position `(21-1)/3 = 6` contains value `10`
9. LIB remains stuck at height 10 despite chain progressing to height 1000+

**Result:** LIB advancement completely suppressed, all blocks after height 10 remain reversible indefinitely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-47)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-98)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
