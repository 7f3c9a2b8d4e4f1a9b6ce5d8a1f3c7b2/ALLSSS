# Audit Report

## Title
Missing Miner List Validation in NextRound Allows Consensus Takeover

## Summary
The AEDPoS consensus contract fails to validate that the miner list remains unchanged during round transitions. The `NextRound` validation only checks round number increments and null `InValue` fields, allowing any current miner to inject arbitrary miners and completely take over the consensus mechanism.

## Finding Description

The vulnerability exists in the consensus validation pipeline for `NextRound` behavior. When a miner transitions to the next round, the system validates the input through two providers:

**RoundTerminateValidationProvider** only verifies:
- Round number increments by exactly 1 [1](#0-0) 
- All `InValue` fields in next round are null [2](#0-1) 

**NextRoundMiningOrderValidationProvider** checks the provided round (which is the next round N+1) by comparing counts of miners with `FinalOrderOfNextRound > 0` vs `OutValue != null` [3](#0-2) . This can be bypassed by setting all values to 0/null, making the check 0 == 0.

**Critical gap:** Neither validator checks that the miner list keys (public keys in `RealTimeMinersInformation`) in the next round match the current round's miner list.

In legitimate round generation, the next round preserves the current round's miners, only reordering them [4](#0-3) . However, the validation does not enforce this invariant.

After validation passes, the malicious round is processed:
- `ProcessNextRound` converts input to Round via `ToRound()` [5](#0-4) 
- `ToRound()` copies all fields including arbitrary miner list [6](#0-5) 
- `AddRoundInformation` stores it directly without validation [7](#0-6) 

The `ValidateConsensusAfterExecution` also fails to detect this because it compares the round from the block header with the current round in state (which are now identical after storage) [8](#0-7) .

## Impact Explanation

**CRITICAL** - This represents a complete breakdown of consensus security:

1. **Consensus Takeover:** An attacker can replace all legitimate miners with arbitrary public keys they control, gaining monopoly over block production
2. **Miner Disenfranchisement:** All legitimately elected miners lose their mining rights and block rewards
3. **Election Bypass:** Democratic validator election becomes meaningless as results can be overridden by any current miner
4. **Chain Halt Risk:** Attacker can set invalid mining orders (all Order = 0) to halt the chain
5. **Governance Compromise:** Proposals and cross-chain operations requiring miner consensus become compromised

This violates the fundamental invariant that miner lists should only change during term transitions (via Election contract), not during regular round transitions.

## Likelihood Explanation

**HIGH** - The attack is trivially executable:

**Attacker Requirements:**
- Must be a current miner in the round (typical configurations have 5-17 miners)
- No special privileges beyond normal mining rights

**Attack Complexity:** LOW
1. Monitor for round completion
2. Craft `NextRoundInput` with arbitrary miner list
3. Set `RoundNumber = current + 1`, all `InValue = null`, `OutValue = null`, `FinalOrderOfNextRound = 0`
4. Submit during attacker's time slot via `NextRound` method [9](#0-8) 

**Feasibility:** 
- No economic cost (attacker earns block rewards)
- No complex cryptography required
- Occurs naturally during round transitions (every ~8 minutes with typical configurations)
- `PreCheck` only verifies sender is in current/previous miner list [10](#0-9) , allowing the attack

## Recommendation

Add miner list validation in `RoundTerminateValidationProvider.ValidationForNextRound`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate miner list remains unchanged during round transitions
    var currentMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    if (currentMiners.Count != nextMiners.Count || !currentMiners.SequenceEqual(nextMiners))
        return new ValidationResult { Message = "Miner list must remain unchanged during round transitions." };
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_ShouldReject_ArbitraryMinerList()
{
    // Setup: Initialize consensus with legitimate miners [Alice, Bob, Charlie]
    var legitimateMiners = new[] { "Alice", "Bob", "Charlie" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Alice is current miner, creates malicious NextRoundInput
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 2, // Current is 1
        RealTimeMinersInformation = 
        {
            ["Alice"] = new MinerInRound { Pubkey = "Alice", Order = 1, InValue = null },
            ["Attacker1"] = new MinerInRound { Pubkey = "Attacker1", Order = 2, InValue = null },
            ["Attacker2"] = new MinerInRound { Pubkey = "Attacker2", Order = 3, InValue = null }
            // Bob and Charlie are removed!
        }
    };
    
    // Alice submits NextRound with arbitrary miner list
    var result = await AliceConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // EXPECTED: Transaction should fail due to miner list validation
    // ACTUAL (VULNERABLE): Transaction succeeds, consensus is taken over
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Miner list must remain unchanged");
    
    // Verify Bob and Charlie still have mining rights
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation.Keys.ShouldContain("Bob");
    currentRound.RealTimeMinersInformation.Keys.ShouldContain("Charlie");
}
```

## Notes

This vulnerability affects only regular round transitions (`NextRound`), not term transitions (`NextTerm`). Term transitions properly update the miner list through the Election contract and set it explicitly [11](#0-10) . However, `NextRound` should preserve the miner list but fails to validate this invariant, allowing consensus takeover during any of the frequent round transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-39)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-113)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
