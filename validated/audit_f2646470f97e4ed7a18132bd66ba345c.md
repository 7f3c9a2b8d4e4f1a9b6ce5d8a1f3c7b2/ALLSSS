# Audit Report

## Title
NFT Burn Function Incorrectly Requires Minter Status, Preventing Legitimate Token Owners from Burning Their Own Assets

## Summary
The NFT contract's `Burn()` function enforces an overly restrictive authorization check that requires callers to be in the minter list, even when they legitimately own the NFTs. This prevents non-minter owners from burning their own assets, violating fundamental ownership rights and breaking the `Disassemble()` functionality.

## Finding Description

The NFT contract's `Burn()` function contains a flawed authorization check that conflates ownership with minting privileges. [1](#0-0) 

The authorization logic requires BOTH conditions to be satisfied simultaneously:
1. The caller must have sufficient balance (legitimate ownership verification)
2. The caller must be in the minter list (inappropriate restriction for burn operations)

This is fundamentally inconsistent with the MultiToken contract's burn implementation, which only requires the token to be burnable and the caller to have sufficient balance. [2](#0-1) 

**How Non-Minters Legitimately Acquire NFTs:**

1. **Direct minting to non-minter owners:** The `PerformMint()` function allows minters to specify a different owner address, assigning NFT balance directly to non-minter addresses. [3](#0-2) 

2. **Transfer operations:** The `Transfer()` function allows any NFT owner to transfer tokens to any address without minter status checks. [4](#0-3)  The internal `DoTransfer()` function only validates balance, not minter status. [5](#0-4) 

3. **TransferFrom operations:** Approved spenders can transfer NFTs to non-minters without any minter checks. [6](#0-5) 

**Cascading Impact on Disassemble:**

The `Disassemble()` function internally calls `Burn()`, causing it to fail for non-minter owners who cannot recover their underlying locked assets. [7](#0-6) 

**Protocol Design Intent Violation:**

NFT protocols are created with an `IsBurnable` flag defined in the protocol structure [8](#0-7) , suggesting that burning should be controlled by this flag rather than minter status. The protocol definition includes this burnable flag without any indication that only minters can burn. [9](#0-8) 

The `Burn()` function checks this flag but then adds an additional minter requirement not present in the protocol design. [10](#0-9) 

## Impact Explanation

**HIGH SEVERITY** - This vulnerability fundamentally breaks ownership rights for NFT holders:

1. **Ownership Rights Violation:** Legitimate NFT owners cannot destroy assets they possess, contradicting basic digital asset ownership principles where ownership implies control over disposition.

2. **Protocol Inconsistency:** The `IsBurnable` flag becomes meaningless for the majority of NFT holders (non-minters), creating a misleading protocol design where "burnable" only applies to a privileged subset of owners.

3. **Asset Lock-in:** Users who assemble NFTs by locking underlying assets cannot disassemble them to recover those assets if they are not minters, resulting in permanent inaccessibility of locked value.

4. **Economic Impact:** Owners cannot reduce token supply or exit positions, affecting token economics and user autonomy. This prevents normal deflationary mechanisms in NFT ecosystems.

5. **Widespread Affected Users:** In typical NFT ecosystems, the vast majority of holders are not minters. This design affects nearly all NFT owners who acquire tokens through secondary markets or transfers.

## Likelihood Explanation

**VERY HIGH** - This is not an attack scenario but a design flaw affecting normal operations:

1. **Trivial to Trigger:** Any non-minter owner attempting to burn their NFT encounters this issue immediately with no special conditions required.

2. **Common Scenario:** NFT transferability is a core feature explicitly supported by the contract. Most NFT owners in any ecosystem acquire tokens through transfers rather than direct minting, making non-minter ownership the dominant use case.

3. **No Preconditions Required:** Simply owning an NFT as a non-minter is sufficient to encounter this restriction. The contract's own `PerformMint()` function supports minting directly to non-minter addresses.

4. **By Design:** The contract explicitly allows and facilitates non-minter ownership through multiple pathways (mint-to-owner parameter, transfers, transferFrom), making this scenario an intentional part of the protocol flow rather than an edge case.

## Recommendation

Remove the minter status check from the `Burn()` function to align with MultiToken contract behavior and respect ownership rights. The authorization should only verify:
1. The protocol's `IsBurnable` flag is true
2. The caller has sufficient balance

Modify the Assert statement in `Burn()` from:
```csharp
Assert(
    State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
    minterList.Value.Contains(Context.Sender),
    "No permission.");
```

To:
```csharp
Assert(State.BalanceMap[tokenHash][Context.Sender] >= input.Amount, "Insufficient balance.");
```

This change maintains security by:
- Still requiring ownership (balance check)
- Still respecting the protocol's burnability design (IsBurnable flag)
- Removing the inappropriate minter privilege requirement for burn operations
- Aligning with MultiToken contract patterns for consistency

## Proof of Concept

```csharp
[Fact]
public async Task NonMinterOwner_Cannot_Burn_OwnedNFT()
{
    // Setup: Create burnable NFT protocol
    var symbol = await CreateNFTProtocol(isBurnable: true);
    
    // Minter mints NFT to non-minter owner
    var minterStub = GetNFTContractStub(MinterKeyPair);
    var nonMinterOwner = Accounts[1].Address;
    await minterStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        TokenId = 1,
        Owner = nonMinterOwner,  // Minting to non-minter
        Quantity = 1
    });
    
    // Verify non-minter owns the NFT
    var balance = await minterStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = symbol,
        TokenId = 1,
        Owner = nonMinterOwner
    });
    balance.Balance.ShouldBe(1);
    
    // Non-minter owner attempts to burn their own NFT
    var nonMinterStub = GetNFTContractStub(Accounts[1].KeyPair);
    var burnResult = await nonMinterStub.Burn.SendWithExceptionAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = 1
    });
    
    // Vulnerability: Owner cannot burn despite having balance and protocol being burnable
    burnResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    burnResult.TransactionResult.Error.ShouldContain("No permission.");
}
```

**Notes:**
- The proof of concept demonstrates that even with a burnable NFT protocol and legitimate ownership (confirmed balance), non-minter owners are blocked from burning their own assets.
- This is inconsistent with fundamental ownership principles and the MultiToken contract's behavior.
- The vulnerability affects the `Disassemble()` function as well, preventing asset recovery for assembled NFTs owned by non-minters.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L86-93)
```csharp
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-198)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L440-441)
```csharp
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L261-285)
```text
message NFTProtocolInfo {
    // The symbol of the token.
    string symbol = 1;
    // The minted number of the token.
    int64 supply = 2;
    // The total number of the token.
    int64 total_supply = 3;
    // The address that creat the token.
    aelf.Address creator = 4;
    // Base Uri.
    string base_uri = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // The chain to mint this token.
    int32 issue_chain_id = 7;
    // The metadata of the token.
    Metadata metadata = 8;
    // NFT Type.
    string nft_type = 9;
    // Protocol name, aka token name in MultiToken Contract.
    string protocol_name = 10;
    // Is token id can be reused.
    bool is_token_id_reuse = 11;
    int64 issued = 12;
}
```
