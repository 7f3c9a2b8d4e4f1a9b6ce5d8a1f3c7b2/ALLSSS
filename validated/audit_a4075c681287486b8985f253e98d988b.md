# Audit Report

## Title
Users Lose 100 ELF When Calling Create on Sidechains Due to Chain-Agnostic Fee Configuration

## Summary
The NFT contract's `GetMethodFee()` returns a hardcoded 100 ELF fee for the `Create` method without checking chain context. Since `Create()` only executes on mainchain, users on sidechains pay 100 ELF during pre-execution fee charging, then the main transaction fails at the chain ID assertion. The pre-execution state changes (fee deduction) persist even when the main transaction fails, resulting in permanent fund loss with no service provided.

## Finding Description

This vulnerability stems from a fundamental mismatch between fee configuration and execution restrictions in a multi-chain environment.

**Chain-Agnostic Fee Configuration:**
The NFT contract's `GetMethodFee()` returns 100 ELF for the Create method without any chain ID validation. [1](#0-0) 

**Mainchain-Only Execution Restriction:**
The `Create()` method enforces mainchain-only execution through a chain ID assertion that fails on sidechains. [2](#0-1) 

**Pre-Execution Fee Charging:**
Transaction fees are charged before the main transaction executes. The fee charging transaction queries `GetMethodFee` and deducts the returned amount from the user's balance. [3](#0-2) [4](#0-3) 

**Pre-Transaction State Commitment:**
When the pre-execution fee charging succeeds, its state changes are immediately committed to the state cache before the main transaction executes. [5](#0-4) 

**Stop Execution Logic:**
The `IsStopExecuting` check returns false when fee charging succeeds, allowing the main transaction to proceed. [6](#0-5) 

**Critical Flaw - No Rollback on Main Transaction Failure:**
When the main transaction fails, the system only commits state changes from successful pre-transactions. Since fee charging was successful, its state changes persist even though the main transaction failed. [7](#0-6) 

**Complete Execution Flow on Sidechains:**
1. User calls `Create()` on sidechain (NFT contract deployed for `CrossChainCreate` support)
2. Pre-execution plugin generates `ChargeTransactionFees` transaction
3. Fee charging queries `GetMethodFee("Create")` → returns 100 ELF
4. User has sufficient balance, fee charging succeeds (ModifyBalance deducts 100 ELF)
5. Fee deduction state changes committed to cache
6. `IsStopExecuting` returns false (Success = true)
7. Main transaction `Create()` executes
8. Chain ID assertion fails on sidechain
9. Main transaction fails, but pre-transaction was successful
10. `TryUpdateStateCache` commits successful pre-transaction state changes
11. User permanently loses 100 ELF with no service provided

## Impact Explanation

**Direct Financial Loss:**
Each failed call costs exactly 100_00000000 base units (100 ELF with 8 decimals). This represents significant direct financial harm to users who receive absolutely no benefit or service in return.

**Affected User Categories:**
- Users unaware of the mainchain-only restriction
- Users accidentally calling from sidechain wallets/dApps
- Developers testing NFT creation functionality on sidechains
- Users misled by the proto interface which provides no indication of chain restrictions [8](#0-7) 

**Protocol Trust Damage:**
This creates a fee trap that appears as either a protocol bug or intentional fund extraction. The issue is particularly problematic because `CrossChainCreate` exists specifically for sidechain NFT protocol registration but charges no fees, creating an inconsistent and confusing user experience.

**Violated Security Guarantee:**
The fundamental principle that users should only pay fees when they receive the service they're paying for is broken. Pre-execution fee charging should not persist when the main transaction fails to execute.

## Likelihood Explanation

**No Attack Required:**
This is a design flaw in normal protocol operation. No malicious actor is needed - ordinary users simply calling a public method triggers the loss.

**Low Complexity Preconditions:**
- User must be on a sidechain (where NFT contract is deployed for `CrossChainCreate` functionality)
- User needs ≥100 ELF balance
- No other preconditions, privileges, or timing requirements

**High Probability of Occurrence:**
- `Create` is the primary entry point for NFT protocol creation
- The proto interface exposes it as a standard public RPC without any mainchain indication
- Error messages only appear after fee deduction
- Natural user behavior (trying to create NFTs on sidechains) directly triggers the issue
- No warning or prevention mechanism exists

## Recommendation

**Solution 1: Chain-Aware Fee Configuration (Recommended)**
Modify `GetMethodFee()` to return zero fees for mainchain-only methods when called from sidechains:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    if (input.Value == nameof(Create))
    {
        // Only charge fee on mainchain where Create actually executes
        if (Context.ChainId != ChainHelper.ConvertBase58ToChainId("AELF"))
            return new MethodFees();
            
        return new MethodFees
        {
            MethodName = input.Value,
            Fees = { new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 100_00000000 } }
        };
    }
    return new MethodFees();
}
```

**Solution 2: Pre-Execution Validation**
Add chain ID validation to the pre-execution plugin that checks if chain-restricted methods will fail before charging fees. This requires modifying the plugin framework to be aware of method-specific execution restrictions.

**Solution 3: Rollback Mechanism**
Implement a rollback mechanism in `TryUpdateStateCache` that discards pre-execution state changes when the main transaction fails due to assertion failures (not just any failure). This is more complex and could have broader implications.

**Recommended Approach:**
Solution 1 is cleanest as it prevents the issue at the source - don't charge fees for services that cannot be provided on that chain.

## Proof of Concept

```csharp
[Fact]
public async Task Create_On_Sidechain_Loses_User_Funds_Test()
{
    // Setup: User has 100 ELF on sidechain
    var userInitialBalance = 200_00000000; // 200 ELF
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = userInitialBalance,
        To = DefaultAddress
    });
    
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "ELF"
    })).Balance;
    
    // Configure test to simulate sidechain (non-AELF chain ID)
    // This would require test infrastructure to set Context.ChainId to non-AELF value
    
    // Execute: User calls Create on sidechain
    var result = await NFTContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        BaseUri = "ipfs://test/",
        NftType = NFTType.Art.ToString(),
        ProtocolName = "TEST",
        TotalSupply = 1000
    });
    
    // Verify: Transaction failed with chain ID assertion
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("NFT Protocol can only be created at aelf mainchain");
    
    // Verify: User still lost 100 ELF in fees
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "ELF"
    })).Balance;
    
    var feeLost = balanceBefore - balanceAfter;
    feeLost.ShouldBe(100_00000000); // 100 ELF lost
    
    // Verify: No NFT protocol was created
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = "any_symbol" });
    protocolInfo.Symbol.ShouldBeEmpty(); // No protocol exists
}
```

## Notes

**Architecture Context:**
The NFT contract must be deployed on sidechains to support `CrossChainCreate`, which allows sidechain users to register NFT protocols created on the mainchain. However, this deployment creates a trap where users can inadvertently call mainchain-only methods.

**Systemic Issue:**
This pattern could potentially affect other methods with chain-specific restrictions across the AElf ecosystem. A comprehensive audit of all contracts with chain-restricted methods and their fee configurations is recommended.

**User Experience:**
The lack of clear documentation or proto-level indication that `Create` is mainchain-only, combined with the contract's presence on sidechains, creates a confusing and potentially costly user experience.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-18)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L36-40)
```csharp
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L237-266)
```csharp
    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        Assert(!IsInTransferBlackListInternal(fromAddress), "Charge fee address is in transfer blacklist.");
        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        // Update balances and allowances
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }

        if (freeAllowancesMap.Map == null || freeAllowancesMap.Map.Count == 0) return;

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount > 0)
            {
                ModifyFreeFeeAllowanceAmount(fromAddress, freeAllowancesMap, symbol, -amount);
            }
        }
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L275-286)
```csharp
                var preTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);
                if (preTrace == null)
                    return false;
                trace.PreTransactions.Add(preTx);
                trace.PreTraces.Add(preTrace);

                if (!preTrace.IsSuccessful()) return false;

                var stateSets = preTrace.GetStateSets().ToList();
                internalStateCache.Update(stateSets);
                var parentStateCache = txContext.StateCache as TieredStateCache;
                parentStateCache?.Update(stateSets);
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** protobuf/nft_contract.proto (L22-24)
```text
    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
```
