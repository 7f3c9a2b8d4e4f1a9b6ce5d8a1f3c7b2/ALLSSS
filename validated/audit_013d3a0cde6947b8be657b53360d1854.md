# Audit Report

## Title
Withdrawal Function Corrupts Historical Snapshots and Current Aggregate Vote Counts

## Summary
The `Withdraw()` function in the Vote contract modifies finalized snapshot data and causes current snapshots to retain stale aggregate vote counts. When a user withdraws a vote after `TakeSnapshot()` has been called, the withdrawal only updates the historical snapshot where the vote originated, but the current snapshot (which copied forward those aggregate counts) retains the inflated values. This breaks snapshot immutability guarantees and causes governance decisions to be based on incorrect vote data.

## Finding Description

The vulnerability exists in how the Vote contract handles withdrawals across multiple snapshots. The issue arises from a fundamental mismatch between how votes are recorded and how snapshot data is propagated:

**When voting occurs**, the voting record stores the current snapshot number at the time of the vote: [1](#0-0) 

**When TakeSnapshot is called**, it finalizes the previous snapshot by setting `SnapshotEndTimestamp`, then creates a new `VotingResult` for the next snapshot and **copies forward** the aggregate counts (`VotersCount` and `VotesAmount`) from the previous snapshot: [2](#0-1) 

**When Withdraw is called**, it retrieves the `VotingResult` using the snapshot number stored in the original voting record and modifies **only that specific snapshot's data**, without any mechanism to update subsequent snapshots that inherited those counts: [3](#0-2) 

**Root Cause**: The withdrawal logic assumes each vote exists only in its original snapshot, but `TakeSnapshot` copies aggregate counts forward to new snapshots. When a withdrawal modifies the original snapshot, subsequent snapshots retain stale copied counts that no longer reflect the actual vote state.

The security guarantee being broken is **snapshot immutability** - once a snapshot is finalized with `SnapshotEndTimestamp`, its data should not be modified. Additionally, the **current snapshot accuracy** guarantee is violated because aggregate counts include votes that have been withdrawn and tokens that have been unlocked.

## Impact Explanation

**Impact: HIGH**

1. **Historical Data Corruption**: Finalized snapshots with `SnapshotEndTimestamp` set are retroactively modified, violating the fundamental immutability guarantee of snapshot data. This is demonstrated in the existing test suite, which shows historical snapshot modification after finalization: [4](#0-3) 

2. **Incorrect Current Snapshot Counts**: The current snapshot's `VotesAmount` and `VotersCount` become inflated because they include withdrawn votes that were copied forward during `TakeSnapshot` but were never decremented when those votes were withdrawn.

3. **Governance Decision Corruption**: The Election contract relies on these values for critical governance operations. The `GetVotesAmount` and `GetVotersCount` methods query the latest voting result, which will return incorrect inflated values: [5](#0-4) 

These methods use `GetLatestVotingResult`, which returns the current snapshot's data: [6](#0-5) 

The Election contract's `GetVictories` method uses vote counts to determine miner selection, meaning inflated counts will lead to incorrect governance decisions: [7](#0-6) 

4. **Token Double-Use**: Users can withdraw tokens that were locked in previous snapshots and use them for other purposes, while the current snapshot still counts those votes in its aggregate totals, allowing effective double-counting of voting power.

**Quantified Impact**: For a voting item with N snapshots:
- If users withdraw votes after snapshot advancement, all historical snapshots 1 to N-1 get modified post-finalization
- Current snapshot N shows `VotesAmount = (actual votes in N) + (sum of withdrawn votes from snapshots 1 to N-1)`
- Election governance decisions based on these inflated counts will be systematically incorrect

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities**: Any user who can vote and withdraw their own votes. No special privileges are required - these are standard public methods available to all users.

**Attack Complexity**: LOW
1. Vote with any amount in snapshot N
2. Wait for `TakeSnapshot(N)` to be called by the sponsor (normal governance flow)
3. Call `Withdraw()` to remove the vote from snapshot N
4. Snapshot N+1 automatically retains the inflated counts that were copied during `TakeSnapshot`

**Feasibility Conditions**:
- Voting items with multiple snapshots (the standard configuration for governance scenarios - elections use multiple term snapshots)
- `Vote` and `Withdraw` are public methods with only basic permission checks (voter can withdraw their own votes)
- No time locks or restrictions prevent withdrawal after snapshot advancement
- No validation checks the integrity of subsequent snapshots when withdrawals occur

**Detection Constraints**: The issue manifests as state data inconsistencies that are not immediately visible. The current test suite actually demonstrates this behavior but treats it as expected functionality, confirming the vulnerability exists in production code.

**Probability**: This will occur naturally in any multi-snapshot voting scenario where users exercise their legitimate right to withdraw votes. It does not require malicious intent - it happens as a side effect of normal operations.

## Recommendation

The `Withdraw()` function must update not only the original snapshot but also all subsequent snapshots that have copied the aggregate counts. Two approaches:

**Option 1: Update all subsequent snapshots when withdrawing**
```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    
    // ... existing permission checks ...
    
    votingRecord.IsWithdrawn = true;
    votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
    State.VotingRecords[input.VoteId] = votingRecord;
    
    // Update all snapshots from the original vote snapshot to current
    for (long i = votingRecord.SnapshotNumber; i <= votingItem.CurrentSnapshotNumber; i++)
    {
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, i);
        var votingResult = State.VotingResults[votingResultHash];
        
        votingResult.Results[votingRecord.Option] = 
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
        
        // Only decrement voter count if this is the last active vote
        if (!hasOtherActiveVotes) 
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);
            
        State.VotingResults[votingResultHash] = votingResult;
    }
    
    // ... rest of existing logic ...
}
```

**Option 2: Prevent withdrawals after snapshot finalization**
Add a check to prevent withdrawals once a snapshot has been finalized:
```csharp
var originalSnapshotHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
var originalSnapshot = State.VotingResults[originalSnapshotHash];
Assert(originalSnapshot.SnapshotEndTimestamp == null, "Cannot withdraw from finalized snapshot.");
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_Withdraw_Corrupts_Snapshots_Test()
{
    // Register voting item with 3 snapshots
    var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 3);
    var voteUser = Accounts[1].KeyPair;
    var voteAmount = 100;
    
    // User votes 100 in snapshot 1
    await Vote(voteUser, registerItem.VotingItemId, registerItem.Options[0], voteAmount);
    
    var snapshot1Before = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 1,
        VotingItemId = registerItem.VotingItemId
    });
    snapshot1Before.VotesAmount.ShouldBe(100);
    snapshot1Before.VotersCount.ShouldBe(1);
    
    // Take snapshot - this finalizes snapshot 1 and creates snapshot 2 with copied counts
    await TakeSnapshot(registerItem.VotingItemId, 1);
    
    var snapshot1After = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 1,
        VotingItemId = registerItem.VotingItemId
    });
    snapshot1After.SnapshotEndTimestamp.ShouldNotBeNull(); // Snapshot 1 is now FINALIZED
    
    var snapshot2 = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 2,
        VotingItemId = registerItem.VotingItemId
    });
    snapshot2.VotesAmount.ShouldBe(100); // Copied from snapshot 1
    snapshot2.VotersCount.ShouldBe(1);   // Copied from snapshot 1
    
    // User withdraws the vote
    var voteIds = await GetVoteIds(voteUser, registerItem.VotingItemId);
    await Withdraw(voteUser, voteIds.ActiveVotes.First());
    
    // VULNERABILITY: Snapshot 1 (finalized) was modified!
    var snapshot1Modified = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 1,
        VotingItemId = registerItem.VotingItemId
    });
    snapshot1Modified.VotesAmount.ShouldBe(0);    // Modified even though finalized!
    snapshot1Modified.VotersCount.ShouldBe(0);    // Modified even though finalized!
    
    // VULNERABILITY: Snapshot 2 retains stale inflated counts!
    var snapshot2Stale = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        SnapshotNumber = 2,
        VotingItemId = registerItem.VotingItemId
    });
    snapshot2Stale.VotesAmount.ShouldBe(100);  // Still 100 but vote was withdrawn!
    snapshot2Stale.VotersCount.ShouldBe(1);    // Still 1 but vote was withdrawn!
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L238-281)
```csharp
    public async Task VoteContract_Withdraw_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);

        var voteUser = Accounts[1].KeyPair;
        var voteAddress = Accounts[1].Address;
        var voteItemId = registerItem.VotingItemId;
        var voteAmount = 100;
        await Vote(voteUser, voteItemId, registerItem.Options[1], voteAmount);
        var voteIds = await GetVoteIds(voteUser, voteItemId);
        var currentVoteId = voteIds.ActiveVotes.First();
        var voteRecordBeforeWithdraw = await VoteContractStub.GetVotingRecord.CallAsync(currentVoteId);
        voteRecordBeforeWithdraw.IsWithdrawn.ShouldBe(false);
        var voteItems = await VoteContractStub.GetVotedItems.CallAsync(voteAddress);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].ActiveVotes.Count.ShouldBe(1);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].WithdrawnVotes.Count.ShouldBe(0);
        var voteResultBeforeWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            SnapshotNumber = 1,
            VotingItemId = voteItemId
        });
        await TakeSnapshot(voteItemId, 1);


        var beforeBalance = GetUserBalance(voteAddress);
        var transactionResult = await Withdraw(voteUser, currentVoteId);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        voteItems = await VoteContractStub.GetVotedItems.CallAsync(voteAddress);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].ActiveVotes.Count.ShouldBe(0);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].WithdrawnVotes.Count.ShouldBe(1);
        var voteRecordAfterWithdraw = await VoteContractStub.GetVotingRecord.CallAsync(currentVoteId);
        voteRecordAfterWithdraw.IsWithdrawn.ShouldBe(true);
        var voteResultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            SnapshotNumber = 1,
            VotingItemId = voteItemId
        });
        voteResultBeforeWithdraw.VotesAmount.Sub(voteResultAfterWithdraw.VotesAmount).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.Results[registerItem.Options[1]]
            .Sub(voteResultAfterWithdraw.Results[registerItem.Options[1]]).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.VotersCount.Sub(1).ShouldBe(voteResultAfterWithdraw.VotersCount);
        var afterBalance = GetUserBalance(voteAddress);
        beforeBalance.ShouldBe(afterBalance - 100);
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-238)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }

    public override Int64Value GetVotesAmount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotesAmount
        };
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L44-53)
```csharp
    public override VotingResult GetLatestVotingResult(Hash input)
    {
        var votingItem = AssertVotingItem(input);
        var votingResultHash = new VotingResult
        {
            VotingItemId = input,
            SnapshotNumber = votingItem.CurrentSnapshotNumber
        }.GetHash();
        return State.VotingResults[votingResultHash];
    }
```
