# Audit Report

## Title
Unbounded ReceivedTokenSymbols Growth Enables State Bloat and Iteration DoS on Profit Schemes

## Summary
The `ReceivedTokenSymbols` field in profit schemes lacks size constraints and can be populated by any user through the permissionless `ContributeProfits()` method. When this list grows large (1000+ symbols), operations iterating over all symbols—including profit distribution, claiming, and consensus dividend pool queries—will experience severe gas consumption issues, potentially exceeding block gas limits and causing operational denial-of-service for scheme managers, beneficiaries, and critical consensus infrastructure.

## Finding Description

The `ReceivedTokenSymbols` field is defined as an unbounded repeated string field with no maximum size constraint. [1](#0-0) 

This list is populated when distributing profits to sub-schemes without bound validation. [2](#0-1) 

The critical vulnerability exists in `ContributeProfits()` which unconditionally adds any contributed token symbol to the list. [3](#0-2) 

The `ContributeProfits()` method has no access control beyond basic validation that the token exists, amount is positive, and scheme exists. [4](#0-3) 

Any user can contribute dust amounts (1 unit) of any valid token to any profit scheme, causing permanent addition to `ReceivedTokenSymbols`. The `TokenAmountLimit` constant only restricts method fee configuration and is unrelated to this vulnerability. [5](#0-4) 

**DoS Vector 1:** When `DistributeProfits()` is called with `IsReleaseAllBalanceEveryTimeByDefault` true and no specific amounts, it iterates ALL symbols making external `GetBalance` calls. [6](#0-5) 

**DoS Vector 2:** `ProfitAllPeriods()` iterates all symbols when calculating profits for beneficiaries during claims. [7](#0-6) 

**DoS Vector 3:** The AEDPoS consensus contract's `GetUndistributedDividends()` method iterates all symbols with external GetBalance calls for the consensus dividend pool. [8](#0-7) 

There is no mechanism to remove symbols from the list, and no size limit is enforced anywhere in the codebase.

## Impact Explanation

**Critical Operational DoS:**
- The consensus dividend pool scheme becomes non-operational when gas costs for iterating symbols exceed block limits, disrupting validator reward distributions
- Scheme managers become unable to call `DistributeProfits()` due to prohibitive gas costs
- Beneficiaries cannot claim profits via `ClaimProfits()` when calculation gas limits are exceeded
- Critical economic infrastructure availability guarantees are broken

**Permanent State Bloat:**
- Each added symbol increases Scheme object storage permanently
- No cleanup mechanism exists for expired or zero-balance symbols
- Storage costs accumulate indefinitely

**Affected Parties:**
- Consensus validators (reward distribution failure)
- All profit scheme managers and beneficiaries
- Protocol economic system integrity

This constitutes a high-severity availability attack on critical protocol infrastructure, not merely a performance degradation issue.

## Likelihood Explanation

**Attack Feasibility:**
- **Technical Complexity:** Low—repeated calls to public `ContributeProfits()` with different token symbols
- **Economic Cost:** For N=1000 symbols: N × (transaction_fee + 1_token_unit). This is economically feasible for motivated attackers, especially when targeting high-value infrastructure like consensus rewards
- **Required Capabilities:** Access to multiple token symbols (existing tokens or create new ones) and transaction fees
- **Detection:** Gradual accumulation over time makes detection difficult without specific monitoring

**Execution Path:**
1. Attacker identifies target scheme (e.g., consensus dividend pool)
2. For each of 1000+ token symbols: call `ContributeProfits(schemeId, 1, 0, symbol)`
3. Each call adds symbol to `ReceivedTokenSymbols` if not already present
4. Subsequent distribution or claim operations experience linear gas growth
5. Eventually operations exceed gas limits or become economically prohibitive

**Probability:** Medium-Low. While technically trivial and economically feasible for high-value targets (consensus infrastructure, treasury schemes), it requires sustained effort and upfront transaction costs. Most likely against critical infrastructure where DoS has maximum protocol impact.

## Recommendation

Implement multiple protective measures:

1. **Add Access Control to ContributeProfits:**
   - Restrict contribution to scheme managers or whitelisted addresses
   - Alternative: require minimum contribution amounts that make dust attacks uneconomical

2. **Implement Symbol Limit:**
   - Add maximum size constant for `ReceivedTokenSymbols` (e.g., 100 symbols)
   - Enforce limit in `ContributeProfits()` before adding new symbols
   - Add assertion: `Assert(scheme.ReceivedTokenSymbols.Count < MAX_TOKEN_SYMBOLS, "Too many token symbols");`

3. **Add Symbol Removal Mechanism:**
   - Allow scheme managers to remove symbols with zero balance
   - Implement periodic cleanup of zero-balance, old symbols

4. **Optimize Iteration:**
   - Cache frequently accessed balances
   - Add pagination for symbol iteration in view methods
   - Consider only iterating symbols with non-zero balances

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_UnboundedSymbolsDoS_Test()
{
    // Create a profit scheme
    var schemeId = await CreateSchemeAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true
    });
    
    // Attacker adds many token symbols (simulating 1000+)
    // In production, attacker would create or use existing tokens
    const int attackSymbolCount = 1000;
    
    for (int i = 0; i < attackSymbolCount; i++)
    {
        // Create a new token symbol (or use existing)
        var symbol = $"ATK{i}";
        await TokenContractStub.Create.SendAsync(new CreateInput
        {
            Symbol = symbol,
            TokenName = $"Attack Token {i}",
            TotalSupply = 1000000,
            Issuer = DefaultAddress,
            IsBurnable = true
        });
        
        // Contribute dust amount to add symbol to ReceivedTokenSymbols
        await Creators[0].ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Amount = 1, // Dust amount
            Symbol = symbol,
            Period = 0
        });
    }
    
    // Verify symbols were added
    var scheme = await Creators[0].GetScheme.CallAsync(schemeId);
    scheme.ReceivedTokenSymbols.Count.ShouldBe(attackSymbolCount);
    
    // Now DistributeProfits will iterate all 1000+ symbols
    // Each iteration makes external GetBalance call
    // This will exceed gas limits or be prohibitively expensive
    var distributionResult = await Creators[0].DistributeProfits.SendAsync(
        new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = 1,
            AmountsMap = { } // Empty = iterate all symbols
        });
    
    // In production, this transaction would fail with out-of-gas
    // or cost excessive gas proportional to symbol count
}
```

## Notes

This vulnerability is particularly concerning because:

1. The consensus dividend pool (used by AEDPoS for validator rewards) is susceptible to this attack, potentially disrupting the entire consensus mechanism's economic incentives

2. No cleanup mechanism exists—once symbols are added, they remain forever even if balances reach zero

3. The attack scales linearly: each additional symbol increases gas costs proportionally across all distribution and claiming operations

4. The vulnerability affects not just the target scheme but all beneficiaries and sub-schemes connected to it

5. Detection requires monitoring `ReceivedTokenSymbols` growth, which may not be part of standard operational monitoring

The fix should prioritize protecting critical infrastructure schemes (consensus, treasury) while maintaining the flexibility of the profit distribution system for legitimate use cases.

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L448-459)
```csharp
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-666)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-853)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L14-14)
```csharp
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L154-158)
```csharp
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
```
