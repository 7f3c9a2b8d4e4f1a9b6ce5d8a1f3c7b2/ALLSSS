# Audit Report

## Title
DepositBalance Accounting Underflow in Sell() Due to Virtual Balance Pricing Discrepancy

## Summary
The TokenConverter's `Sell()` function uses Bancor pricing that includes both virtual and real deposit balances, but only subtracts from the real `DepositBalance` state variable. With production-configured virtual balances of 10 million tokens and small real deposits, the calculated return can exceed available real balance, causing SafeMath to throw `OverflowException` and revert transactions. This creates a critical denial-of-service where users cannot sell resource tokens and their capital becomes locked.

## Finding Description

The vulnerability stems from an architectural mismatch between the pricing and accounting layers in the TokenConverter contract.

**Pricing Layer - Uses Combined Balance:**

When calculating sell returns, the `Sell()` function calls `GetSelfBalance()` for the deposit connector: [1](#0-0) 

The `GetSelfBalance()` method returns the sum of virtual and real balances for deposit accounts with `IsVirtualBalanceEnabled=true`: [2](#0-1) 

This combined balance is fed into the Bancor formula to calculate the return amount: [3](#0-2) 

**Accounting Layer - Uses Only Real Balance:**

After calculating the return amount, the contract attempts to subtract it from the real `DepositBalance` only, completely ignoring that the virtual balance was included in the pricing calculation: [4](#0-3) 

**Why SafeMath Doesn't Prevent the Issue:**

The SafeMath `Sub()` operation uses checked arithmetic that throws `OverflowException` on underflow, preventing silent corruption but converting the bug into a denial-of-service condition: [5](#0-4) 

**Production Configuration:**

Deposit connectors are initialized with large virtual balances in production. The test configuration demonstrates this with `NativeVirtualBalance = 1_000_000_00000000` (10 million tokens with 8 decimals): [6](#0-5) 

Deposit connectors are created with `IsVirtualBalanceEnabled=true` and `IsDepositAccount=true`: [7](#0-6) 

**Mathematical Proof:**

Consider a scenario with equal weights (0.5):
- Virtual balance: 10,000,000 ELF
- Real balance: 1,000 ELF (small initial deposit)
- Total balance for pricing: 10,001,000 ELF
- User sells 50,000 resource tokens (50% of 100,000 supply)

Using the Bancor formula for equal weights:
```
Return = toBalance * sellAmount / (fromBalance + sellAmount)
       = 10,001,000 * 50,000 / (100,000 + 50,000)
       = 3,333,666 ELF
```

The accounting operation attempts:
```
1,000 - 3,333,666 = Underflow â†’ OverflowException
```

**Execution Path:**
1. Connector pair created with 10 million token virtual balance
2. `EnableConnector` called, setting small real deposit (calculated by `GetNeededDeposit`)
3. User attempts to sell moderate/large amount of resource tokens
4. Bancor calculates return based on (10M virtual + small real) balance
5. If calculated return > real deposit balance, `Sub()` throws exception
6. Transaction reverts - user cannot sell tokens

## Impact Explanation

**Critical Denial-of-Service Impact:**

This vulnerability causes complete failure of the token selling mechanism, a core protocol function. The `Sell()` function is publicly accessible: [8](#0-7) 

Users who purchase resource tokens through the `Buy()` function cannot sell them back when the Bancor-calculated return exceeds the real deposit balance.

**Fund Lockup:**
User capital becomes permanently locked in resource tokens with no exit path through the TokenConverter contract. While users technically still own their tokens, the intended liquidity mechanism is broken.

**Protocol Integrity:**
The Bancor-based resource token market fails to function as designed. The virtual balance mechanism, intended to bootstrap liquidity, is fundamentally incompatible with the accounting system, breaking the core economic model.

**Affected Parties:**
- All resource token holders attempting to exit positions
- The broader AElf ecosystem relying on functional resource markets
- Protocol reputation as the core conversion mechanism is non-functional

The severity is **CRITICAL** because:
- Complete DoS of core functionality (selling) under normal conditions
- Affects all users equally - not just attacker-controlled scenarios
- Occurs with standard production configuration values (10M token virtual balance)
- No user-accessible workaround exists
- Requires contract upgrade to resolve

## Likelihood Explanation

**High Likelihood of Occurrence:**

The vulnerability triggers during normal protocol usage without any malicious intent. The preconditions are:
- Virtual balances enabled by default in production configurations (10,000,000 tokens)
- Real deposit balances start small (calculated from `GetNeededDeposit`) and grow only incrementally through buy operations
- No special privileges required - any token holder can trigger this by calling the public `Sell()` method

**Natural Occurrence:**
1. After `EnableConnector`, real deposit is small while virtual balance is 10 million tokens
2. User performs legitimate sell operation with moderate to large amount
3. Bancor formula calculates return based on inflated (virtual + real) balance
4. If return exceeds real balance, transaction automatically reverts

**Economic Rationality:**
- Zero attack cost - happens during legitimate usage
- Cannot be prevented by users since pricing is protocol-determined
- Affects all participants equally
- Detection is immediate (transaction failure) but resolution requires governance intervention and contract upgrade

The likelihood is **HIGH** because the vulnerability is architectural and occurs naturally under standard operating conditions with production configuration values.

## Recommendation

Add a pre-check before the subtraction to ensure sufficient real balance is available:

```csharp
public override Empty Sell(SellInput input)
{
    // ... existing code ...
    
    var amountToReceive = BancorHelper.GetReturnFromPaid(
        GetSelfBalance(fromConnector), GetWeight(fromConnector),
        GetSelfBalance(toConnector), GetWeight(toConnector),
        input.Amount
    );
    
    // Add validation before subtraction
    Assert(State.DepositBalance[toConnector.Symbol] >= amountToReceive, 
        "Insufficient real deposit balance to fulfill sell order.");
    
    var fee = Convert.ToInt64(amountToReceive * GetFeeRate());
    // ... rest of function ...
}
```

**Better Solution:** Redesign the system to ensure consistency between pricing and accounting:
- Option 1: Only use real balance in Bancor pricing (remove virtual balance from `GetSelfBalance` for pricing)
- Option 2: Include virtual balance in accounting (track it separately and allow it to decrease)
- Option 3: Calculate initial deposits correctly to ensure real balance always covers potential returns

## Proof of Concept

```csharp
[Fact]
public async Task Sell_Underflow_With_Large_Virtual_Balance_Test()
{
    // Setup: Create resource token with 100,000 total supply
    await CreateWriteToken(100_000L);
    
    // Initialize TokenConverter with large virtual balance (10M)
    var largeVirtualBalance = 10_000_000_00000000L;
    var ntWriteConnector = new Connector
    {
        Symbol = "(NT)WRITE",
        VirtualBalance = largeVirtualBalance,
        IsVirtualBalanceEnabled = true,
        IsDepositAccount = true,
        RelatedSymbol = "WRITE",
        Weight = "0.5",
        IsPurchaseEnabled = false
    };
    
    await InitializeTokenConverterContract();
    await PrepareToBuyAndSell();
    
    // Enable connector - this sets a small real deposit balance
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = "WRITE",
        AmountToTokenConvert = 0
    });
    
    // Attempt to sell 50% of resource token supply (50,000 tokens)
    // Bancor will calculate return based on (10M virtual + small real)
    // This return will exceed the small real balance
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(
        new SellInput
        {
            Symbol = "WRITE",
            Amount = 50_000L,
            ReceiveLimit = 0
        });
    
    // Verify: Transaction fails with OverflowException due to underflow
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    sellResult.TransactionResult.Error.ShouldContain("Overflow");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-108)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-162)
```csharp
    public override Empty Sell(SellInput input)
    {
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** test/AElf.Contracts.Economic.TestBase/ContractsPreparation.cs (L595-601)
```csharp
            await SetConnector(new PairConnectorParam
            {
                ResourceConnectorSymbol = EconomicContractsTestConstants.TransactionFeeChargingContractTokenSymbol,
                ResourceWeight = "0.05",
                NativeWeight = "0.05",
                NativeVirtualBalance = 1_000_000_00000000
            });
```
