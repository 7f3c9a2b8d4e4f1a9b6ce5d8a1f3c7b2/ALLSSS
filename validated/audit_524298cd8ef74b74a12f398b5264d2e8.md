# Audit Report

## Title
Authorization Bypass in Contract Update Proposals for Non-Whitelisted Deployments

## Summary
A critical authorization flaw in the Genesis contract allows any address to propose updates to contracts deployed by non-whitelisted proposers. When `DecideNonSystemContractAuthor` assigns `Context.Self` as the author for contracts from non-whitelisted deployers, the `AssertAuthorityByContractInfo` function's OR condition creates an authorization bypass, enabling arbitrary users to propose contract modifications requiring only governance approval rather than author permission.

## Finding Description

The vulnerability spans multiple interconnected functions in the contract deployment and update system:

**Root Cause - Improper Author Assignment:**
When a non-whitelisted proposer deploys a contract through the standard proposal flow, the `DecideNonSystemContractAuthor` function assigns `Context.Self` (the Genesis contract address) as the author instead of the actual proposer. [1](#0-0) 

This occurs when deployment authority is required but the proposer is not in the deployment controller's whitelist.

**Authorization Bypass - Flawed Permission Logic:**
The `AssertAuthorityByContractInfo` function uses an OR condition that passes if EITHER `contractInfo.Author == Context.Self` OR the provided address equals the contract's author. [2](#0-1) 

When a contract has `Author = Context.Self`, the first condition evaluates to TRUE, allowing ANY sender to pass authorization regardless of the second condition.

**Exploitation in ProposeUpdateContract:**
The `ProposeUpdateContract` method validates authority using the flawed check. [3](#0-2) 

Any user can successfully propose updates to contracts with `Author = Context.Self` because the authorization check on line 183 will pass for any `Context.Sender`.

**Update Execution Path:**
During the contract deployment flow, the author is determined using `DecideNonSystemContractAuthor`. [4](#0-3) 

**Secondary Check Bypass:**
When the approved update executes via `UpdateSmartContract`, a secondary permission check exists but gets bypassed. [5](#0-4) 

If `TryClearContractProposingData` returns true (for approved proposals), the check on line 332 is skipped entirely. The method then calls the internal helper with `info.Author` as a parameter.

**Ineffective Internal Validation:**
The internal `UpdateSmartContract` helper contains a permission check. [6](#0-5) 

However, since the caller passes `info.Author` as the author parameter, this check becomes `Assert(info.Author == info.Author, "No permission.")`, which always passes.

**Unrestricted Entry Point:**
The vulnerability is easily reachable because `ProposeNewContract` has no active authorization check. [7](#0-6) 

The authorization check on line 124 is commented out, allowing any user to propose contract deployments.

## Impact Explanation

**Critical Authorization Breach:**
This vulnerability fundamentally subverts the contract ownership model. The security invariant that only contract authors can propose updates to their contracts is completely broken for all contracts deployed by non-whitelisted proposers. Any attacker can propose modifications to these contracts.

**Contract Integrity Compromise:**
Attackers with sufficient governance voting power (or through social engineering of legitimate voters) can:
- Inject malicious logic to steal funds held by the target contract
- Manipulate contract state to benefit the attacker
- Break integrations with other contracts that depend on the original contract's behavior
- Deploy backdoors for future exploitation
- Disrupt critical protocol operations

**Broad Scope:**
ALL contracts deployed through `ProposeNewContract` by users not in the deployment whitelist are vulnerable. This could include numerous third-party applications, protocol extensions, and legitimate user contracts. The test suite confirms this behavior - contracts are explicitly deployed with `Author = BasicContractZeroAddress` when the proposer lacks whitelist status.

**Severity: CRITICAL** - While governance approval is still required, this represents a fundamental authorization bypass. Attackers with voting power, or those who can convince governance through deceptive proposals (e.g., claiming to be the author or presenting the update as legitimate maintenance), can take control of arbitrary contracts they do not own.

## Likelihood Explanation

**High Accessibility:**
- Entry point `ProposeUpdateContract` is a public method accessible to any address
- Contracts with `Author = Context.Self` are easily identifiable on-chain via `GetContractAuthor`
- No technical barriers prevent proposal submission

**Attacker Requirements:**
1. Ability to craft malicious contract code
2. Submission of governance proposal (permissionless)
3. Obtaining governance approval through:
   - Direct voting power accumulation
   - Convincing legitimate voters the update is authorized
   - Taking advantage of low voter participation

**Realistic Attack Scenarios:**
- Well-funded attackers can accumulate governance voting power
- Social engineering: Attacker claims to be the original author with lost keys
- Deceptive proposals disguised as security patches or feature upgrades
- Targeting contracts with valuable assets or critical protocol functions

**Detection Difficulty:**
- Governance voters see standard update proposals with no indication that the proposer lacks author authority
- No events or errors signal unauthorized access attempts
- The authorization check passes silently for any sender

**Likelihood: MODERATE** - The technical exploit is straightforward, but requires governance approval. However, governance systems are susceptible to influence through voting power or social engineering, making this realistically exploitable by determined attackers.

## Recommendation

Implement a strict author validation that cannot be bypassed:

1. **Fix Author Assignment:**
   - Store the original proposer address separately from the contract author
   - Never assign `Context.Self` as the author for user-deployed contracts
   - If deployment authority is required, use the proposer as author or create an explicit ownership transfer mechanism

2. **Fix Authorization Check:**
   - Remove the `contractInfo.Author == Context.Self` condition from `AssertAuthorityByContractInfo`
   - Only allow updates if `Context.Sender == contractInfo.Author`
   - For system contracts where `Context.Self` is legitimate, handle them separately

3. **Strengthen Update Validation:**
   - In `UpdateSmartContract`, validate that the actual `Context.Sender` or `Context.Origin` matches the contract author, not just the passed parameter
   - Store the original proposer in `ContractProposingInput` and verify they match the contract author

4. **Add Ownership Transfer:**
   - Keep the existing `SetContractAuthor` method for legitimate ownership transfers
   - Require the current author to initiate ownership transfers
   - Emit clear events when ownership changes

Fixed code structure:
```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    // Only allow the actual author, remove Context.Self bypass
    Assert(address == contractInfo.Author, "No permission.");
}

private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
{
    // Always return the actual proposer for non-system contracts
    if (!State.ContractDeploymentAuthorityRequired.Value)
        return sender;
    
    // Return proposer, not Context.Self
    return proposer;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task AuthorizationBypass_UpdateNonWhitelistedContract_Test()
{
    // Step 1: Change deployment controller to require authority
    var organizationAddress = await CreateParliamentOrganization();
    await ChangeContractDeploymentController(organizationAddress);
    
    // Step 2: Non-whitelisted user deploys a contract
    var victimUser = Tester.CreateNewContractTester(VictimKeyPair);
    var deployInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(SampleContractCode)
    };
    
    var proposalHash = await victimUser.ProposeNewContract(deployInput);
    await ApproveAndReleaseProposal(proposalHash);
    
    var deployedAddress = GetDeployedContractAddress(proposalHash);
    var contractInfo = await GetContractInfo(deployedAddress);
    
    // Verify author is set to Context.Self (vulnerability condition)
    contractInfo.Author.ShouldBe(BasicContractZeroAddress);
    
    // Step 3: ATTACKER proposes update to victim's contract
    var attackerUser = Tester.CreateNewContractTester(AttackerKeyPair);
    var maliciousCode = ByteString.CopyFrom(MaliciousContractCode);
    
    var updateProposal = await attackerUser.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeUpdateContract),
        new ContractUpdateInput
        {
            Address = deployedAddress,
            Code = maliciousCode
        });
    
    // VULNERABILITY: Authorization check should fail but passes!
    updateProposal.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: After governance approval, attacker's malicious code is deployed
    var updateProposalHash = GetProposalHash(updateProposal);
    await ApproveAndReleaseProposal(updateProposalHash);
    
    var updatedInfo = await GetContractInfo(deployedAddress);
    updatedInfo.CodeHash.ShouldBe(HashHelper.ComputeFrom(maliciousCode.ToByteArray()));
    
    // Attacker successfully updated victim's contract without being the author!
}
```

## Notes

The vulnerability is confirmed by existing test cases in the codebase. The `ChangeContractZeroOwner_Test` explicitly demonstrates that contracts deployed after changing the deployment controller have their author set to `BasicContractZeroAddress`. [8](#0-7) 

This test shows the problematic state exists by design, but lacks validation that only authorized parties can update these contracts. The security model incorrectly relies solely on governance approval rather than combining governance with author authorization.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-103)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-124)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-183)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L822-837)
```csharp
        var creator = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).Indexed[0])
            .Author;

        creator.ShouldBe(BasicContractZeroAddress);

        var deployAddress = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed)
            .Address;

        deployAddress.ShouldNotBeNull();

        var author = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractAuthor), deployAddress));

        author.ShouldBe(BasicContractZeroAddress);
```
