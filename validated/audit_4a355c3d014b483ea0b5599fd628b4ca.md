# Audit Report

## Title
Incomplete Evil Miner Replacement Due to Insufficient Alternative Candidates

## Summary
The consensus contract's miner replacement mechanism fails to replace all evil miners when the candidate pool is exhausted. The replacement loop only iterates for the count of available alternatives, leaving unreplaced evil miners in the active miner set. This compromises consensus integrity by retaining offline or malicious miners who won't produce blocks.

## Finding Description

The vulnerability exists in the coordination between the Election and Consensus contracts during evil miner replacement.

When evil miners are detected (miners who have missed 4,320 time slots over 3 days), [1](#0-0)  they are identified through the detection mechanism [2](#0-1)  and marked as banned in the Election contract's `BannedPubkeyMap`. [3](#0-2) 

During next round generation, the consensus contract calls `GetMinerReplacementInformation` to obtain replacement candidates. [4](#0-3)  This function attempts to find alternatives from the previous term's election snapshot and initial miners as fallback. [5](#0-4) 

The critical flaw occurs when alternative candidates are insufficient. The fallback logic filters initial miners to exclude those already banned or currently serving, but this filtering happens **before** the `.Take()` operation. [6](#0-5)  This means if many initial miners are already banned, fewer alternatives than needed will be returned.

The consensus contract's replacement loop then only iterates for the count of alternatives provided. [7](#0-6)  Using index `i` to pair alternatives with evil miners, [8](#0-7)  only the first N evil miners (where N = `AlternativeCandidatePubkeys.Count`) get replaced via the remove/add operations. [9](#0-8)  The remaining evil miners stay in `currentRound.RealTimeMinersInformation` with their assigned time slots, but being offline/evil, they won't produce blocks.

The validation mechanism only verifies the correctness of replacements that occurred, not whether all evil miners were replaced. [10](#0-9) 

## Impact Explanation

**HIGH severity** - This vulnerability directly compromises the consensus layer's miner schedule integrity:

- **Consensus Degradation:** Unreplaced evil miners occupy time slots but won't produce blocks. In a scenario with 21 miners where 10 become evil but only 3 get replaced, 7 non-functional miners remain active, reducing effective block production by ~33%.

- **Network Liveness Risk:** If sufficient unreplaced evil miners remain, the network may fail to achieve the 2/3+ majority needed for block finalization, potentially causing consensus stalls that halt all transaction processing and state transitions.

- **Affected Parties:** All network participants (validators, users, dApps), treasury/reward distribution systems, and cross-chain operations that depend on reliable consensus.

The severity is HIGH rather than CRITICAL because funds aren't directly at risk, but the operational impact on network availability is severe and affects all protocol functionality.

## Likelihood Explanation

**MEDIUM-HIGH probability** - The vulnerability can trigger under realistic conditions:

**Trigger Conditions:**
1. Multiple miners going offline for 3+ days (detected threshold: 4,320 missed slots)
2. Depleted candidate pool from low election participation
3. Initial miners already serving or previously banned

**Execution Complexity:** MEDIUM - No special permissions required. Natural network stress (infrastructure failures, coordinated DDoS attacks) can cause multiple miners to go offline simultaneously. An adversary could amplify this by disincentivizing election participation.

**Detection:** The replacement flow executes automatically during round generation without requiring governance approval, making it difficult to prevent once conditions are met.

The probability increases over time as mature networks develop stable miner sets, naturally shrinking the available candidate pool for emergency replacements.

## Recommendation

Add validation to ensure complete replacement before proceeding:

1. In `GetMinerReplacementInformation`, modify the initial miner fallback logic to apply filtering AFTER `.Take()` to ensure the requested count is returned when possible.

2. In `GenerateNextRoundInformation`, add an assertion to verify that all evil miners have replacements before executing the replacement loop:
   ```csharp
   Assert(minerReplacementInformation.AlternativeCandidatePubkeys.Count == 
          minerReplacementInformation.EvilMinerPubkeys.Count,
          "Insufficient alternative candidates to replace all evil miners");
   ```

3. Implement a governance-controlled emergency mechanism to handle scenarios where insufficient alternatives exist, allowing for controlled network operation until more candidates become available.

## Proof of Concept

A proof of concept would demonstrate:
1. Configuring a network with 21 miners and limited initial miners
2. Causing 10 miners to accumulate 4,320+ missed time slots
3. Banning most initial miners or having them already serve as current miners
4. Triggering round generation which calls `GetMinerReplacementInformation`
5. Observing that only 3 alternatives are returned when 10 are needed
6. Verifying that only the first 3 evil miners are replaced while 7 remain active
7. Confirming that the 7 unreplaced evil miners still occupy time slots in `RealTimeMinersInformation` but don't produce blocks

The test would validate that `currentRound.RealTimeMinersInformation` contains banned pubkeys that were not replaced, and that block production rate drops proportionally to the number of unreplaced evil miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-392)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
