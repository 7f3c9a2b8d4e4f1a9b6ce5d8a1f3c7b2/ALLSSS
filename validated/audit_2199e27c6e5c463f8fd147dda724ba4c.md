# Audit Report

## Title
ConnectorController Privilege Escalation Through Unvalidated Contract Address

## Summary
The `ChangeConnectorController` method in the TokenConverter contract fails to validate that the `ContractAddress` in the new `AuthorityInfo` corresponds to a legitimate governance contract (Parliament, Association, or Referendum). This allows an entity with temporary controller access to permanently bypass all governance by pointing to a malicious contract, gaining unrestricted control over connector management, fee settings, and token conversion operations.

## Finding Description

The vulnerability exists in the `ChangeConnectorController` method, which validates new authority using only `CheckOrganizationExist(input)` without verifying the contract address is legitimate. [1](#0-0) 

The `CheckOrganizationExist` method performs a cross-contract call to `ValidateOrganizationExist` on whatever `ContractAddress` is provided in the `AuthorityInfo`, without verifying this address is a legitimate governance contract. [2](#0-1) 

Legitimate governance contracts implement `ValidateOrganizationExist` by checking if an organization exists in their state storage. [3](#0-2) [4](#0-3) [5](#0-4) 

However, an attacker can deploy a malicious contract that always returns `true`, bypassing this validation entirely.

After the malicious authority is set, all protected operations use `AssertPerformedByConnectorController()`, which only verifies that `Context.Sender` matches the `OwnerAddress` in the stored authority - it does NOT consult the governance contract for proposal approval. [6](#0-5) 

**Attack Sequence:**
1. Attacker obtains temporary control of current ConnectorController (via governance vote)
2. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` to return `true` for any input
3. Attacker calls `ChangeConnectorController` with `AuthorityInfo { ContractAddress = malicious_contract, OwnerAddress = attacker_address }`
4. Validation passes because malicious contract returns `true`
5. Future operations only check if sender equals attacker_address, completely bypassing governance

This breaks the security guarantee that all critical authority changes must flow through legitimate governance organizations with proposals, voting, and thresholds. The proper governance flow requires proposals to be released via virtual inline calls [7](#0-6) , but the TokenConverter's authorization model bypasses this entirely.

## Impact Explanation

**Critical Severity** - The attacker gains permanent, unrestricted control over:

1. **Connector Management**: Can manipulate connector weights, virtual balances, and related symbols via `UpdateConnector` and `AddPairConnector` [8](#0-7) [9](#0-8) , directly affecting Bancor pricing calculations and liquidity

2. **Fee Control**: Can set arbitrary fee rates via `SetFeeRate` [10](#0-9) , enabling value extraction or DoS

3. **Connector Activation**: Can enable/disable connectors, freezing token conversions

4. **Fund Risk**: Can drain reserves by manipulating connector parameters and pricing functions, or lock funds by disabling conversion paths

The impact extends beyond the TokenConverter to any protocol components relying on its pricing and conversion functionality. The governance bypass also sets a dangerous precedent that undermines the entire separation-of-powers model.

## Likelihood Explanation

**Medium-High Likelihood:**

- **Precondition**: Requires controlling the current ConnectorController, which by default is the Parliament default organization [11](#0-10) . This could be achieved through winning a governance vote or collusion within the organization.

- **Attack Complexity**: Low - requires only deploying a simple malicious contract and calling one method

- **Detection**: The attack would be visible on-chain but cannot be prevented by the contract itself

- **No Existing Protections**: There is no whitelist, no validation against known governance contract addresses (Parliament, Association, Referendum), and no additional checks in the authorization flow

The key insight is that this represents **privilege escalation** - even legitimate temporary governance control should not enable permanent bypass of all future governance. This violates the principle of least privilege and creates an asymmetric risk where a single compromised vote can have permanent consequences.

## Recommendation

Add validation to ensure the `ContractAddress` in the new `AuthorityInfo` is one of the legitimate governance contracts:

```csharp
public override Empty ChangeConnectorController(AuthorityInfo input)
{
    AssertPerformedByConnectorController();
    
    // Validate the contract address is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        input.ContractAddress == parliamentAddress ||
        input.ContractAddress == associationAddress ||
        input.ContractAddress == referendumAddress,
        "Invalid governance contract address"
    );
    
    Assert(CheckOrganizationExist(input), "new controller does not exist");
    State.ConnectorController.Value = input;
    return new Empty();
}
```

This ensures that only legitimate governance contracts can be set as the controller, preventing the privilege escalation attack.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploying a malicious contract with:
```csharp
public override BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true }; // Always returns true
}
```

2. As current controller, calling `ChangeConnectorController` with the malicious contract address and an attacker-controlled address as `OwnerAddress`

3. The validation passes because the malicious contract returns `true`

4. The attacker can now directly call `UpdateConnector`, `AddPairConnector`, `SetFeeRate`, etc. without going through governance proposals, voting, or thresholds

5. This bypasses the entire governance model that requires proposals to be approved and released through the legitimate governance contracts

The attack fundamentally breaks the authorization model by allowing the controller address to be set to a non-organization address that doesn't require governance approval for actions.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-267)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
        var feeRate = AssertedDecimal(input.Value);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L405-416)
```csharp
    private AuthorityInfo GetDefaultConnectorController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
