# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function creates a new `DistributedProfitsInfo` object and unconditionally overwrites existing `DistributedProfitsMap` entries without preserving pre-contributed profits. When users contribute tokens to future periods and the scheme later has zero beneficiaries, calling `DistributeProfits` triggers `BurnProfits`, which destroys accounting records while contributed tokens remain permanently locked in period-specific virtual addresses.

## Finding Description

This vulnerability arises from the interaction between `ContributeProfits`, `DistributeProfits`, and `BurnProfits` in the Profit contract, causing permanent fund loss through accounting corruption.

**Attack Flow:**

1. **Users contribute to future periods:** `ContributeProfits` allows contributions to periods greater than the current period. [1](#0-0)  Tokens are transferred to period-specific virtual addresses, and the amounts are tracked in `DistributedProfitsMap`. [2](#0-1) 

2. **Scheme beneficiaries are removed:** Between contribution and distribution time, all beneficiaries are legitimately removed, resulting in `totalShares = 0`.

3. **DistributeProfits invokes BurnProfits:** When `DistributeProfits` is called for the future period, the condition `totalShares <= 0` triggers `BurnProfits`. [3](#0-2) 

4. **Critical flaw - BurnProfits destroys accounting:** `BurnProfits` creates a **brand new** `DistributedProfitsInfo` object without reading existing state. [4](#0-3)  It then burns tokens from the scheme's general ledger (not the period-specific address where pre-contributions were deposited). [5](#0-4)  Finally, it unconditionally overwrites the state, destroying all records of previously contributed profits. [6](#0-5) 

5. **Funds become permanently locked:** The tokens physically remain in the period-specific virtual address, but the accounting that tracked them is destroyed. After `BurnProfits` sets `IsReleased = true`, future contributions are blocked. [7](#0-6)  Recovery through `ClaimProfits` is impossible because it relies on the now-corrupted `DistributedProfitsMap`. [8](#0-7) 

The period-specific virtual address is consistently generated using `GetDistributedPeriodProfitsVirtualAddress`. [9](#0-8) 

## Impact Explanation

**HIGH SEVERITY - Direct Permanent Fund Loss:**

This vulnerability causes complete and irrecoverable loss of user funds:

1. **Permanent Lock:** Tokens contributed to future periods become permanently trapped. The tokens exist on-chain at the period-specific virtual address but are completely inaccessible because the accounting in `DistributedProfitsMap` has been overwritten with an empty or incorrect state.

2. **Quantified Damage:** If a user contributes 10,000 ELF tokens to period 5, and the scheme has zero beneficiaries when period 5 arrives, all 10,000 ELF become permanently unrecoverable. The impact scales linearly with contribution amounts.

3. **Affected Parties:**
   - Users who contribute profits to future periods expecting eventual distribution
   - Scheme managers who inadvertently trigger this during legitimate scheme wind-down
   - The protocol itself, as tokens become permanently stuck, reducing effective circulating supply

4. **No Recovery Mechanism:** Once `BurnProfits` executes, the `IsReleased` flag prevents any future contributions to that period, and `ClaimProfits` cannot work because it checks `TotalShares` and `AmountsMap` in the corrupted state object.

## Likelihood Explanation

**MEDIUM LIKELIHOOD - Feasible Through Normal Operations:**

This vulnerability can be triggered through legitimate contract operations:

1. **Publicly Accessible:** `ContributeProfits` is a public method callable by any user with token allowance. No special permissions are required to contribute to future periods.

2. **Realistic Preconditions:**
   - A profit scheme exists and accepts contributions
   - A user contributes to a future period (e.g., period 5 when current is 1) - a common pattern for scheduled distributions
   - All beneficiaries are removed via `RemoveBeneficiary` (a legitimate operation when winding down schemes)
   - The scheme manager calls `DistributeProfits` for the target period

3. **Natural Occurrence Scenarios:**
   - Schemes being discontinued after users have made forward-looking contributions
   - Gradual removal of beneficiaries during scheme wind-down overlapping with existing future-period commitments
   - Users optimistically contributing to future periods of schemes that later become inactive

4. **Low Detection Difficulty:** Both operations are legitimate and emit no warnings. The fund loss only becomes apparent when users attempt to claim profits.

## Recommendation

**Solution: Preserve existing contributions in BurnProfits**

The `BurnProfits` function should read and preserve existing `DistributedProfitsInfo` before overwriting:

```csharp
private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
    Address profitsReceivingVirtualAddress)
{
    scheme.CurrentPeriod = period.Add(1);

    // READ existing state instead of creating new
    var distributedProfitsInfo = State.DistributedProfitsMap[profitsReceivingVirtualAddress] 
        ?? new DistributedProfitsInfo();
    
    distributedProfitsInfo.IsReleased = true;
    
    foreach (var profits in profitsMap)
    {
        var symbol = profits.Key;
        var amount = profits.Value;
        if (amount > 0)
        {
            var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            });
            if (balanceOfToken.Balance < amount)
                continue;
            Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                nameof(State.TokenContract.Transfer), new TransferInput
                {
                    To = Context.Self,
                    Amount = amount,
                    Symbol = symbol
                }.ToByteString());
            State.TokenContract.Burn.Send(new BurnInput
            {
                Amount = amount,
                Symbol = symbol
            });
            // Update existing amounts, don't replace them
            distributedProfitsInfo.AmountsMap[symbol] = 
                distributedProfitsInfo.AmountsMap.ContainsKey(symbol) 
                    ? distributedProfitsInfo.AmountsMap[symbol].Sub(amount)
                    : -amount;
        }
    }

    State.SchemeInfos[scheme.SchemeId] = scheme;
    State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
    return new Empty();
}
```

Additionally, consider:
1. Preventing `BurnProfits` execution when pre-contributions exist for that period
2. Adding a recovery mechanism for the scheme manager to retrieve locked funds
3. Emitting warning events when burning is attempted with existing contributions

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

```csharp
// 1. Create a scheme
var schemeId = ProfitContract.CreateScheme(...);

// 2. Add beneficiaries so totalShares > 0
ProfitContract.AddBeneficiary(schemeId, beneficiary1, shares: 100);

// 3. User contributes 10,000 ELF to future period 5 (current period is 1)
ProfitContract.ContributeProfits(new ContributeProfitsInput {
    SchemeId = schemeId,
    Symbol = "ELF",
    Amount = 10_000,
    Period = 5
});
// Tokens are now at GetDistributedPeriodProfitsVirtualAddress(schemeId, 5)
// State.DistributedProfitsMap[virtualAddress] = {AmountsMap: {"ELF": 10000}}

// 4. Remove all beneficiaries (legitimate wind-down operation)
ProfitContract.RemoveBeneficiary(schemeId, beneficiary1);
// Now scheme.TotalShares = 0

// 5. Advance periods to period 5 and call DistributeProfits
// (assuming periods 2,3,4 were distributed)
ProfitContract.DistributeProfits(new DistributeProfitsInput {
    SchemeId = schemeId,
    Period = 5
});
// BurnProfits is called because totalShares = 0
// New DistributedProfitsInfo is created, overwriting the {"ELF": 10000} record
// Tokens remain locked at period-specific address with destroyed accounting

// 6. Verify funds are lost
var distributedInfo = ProfitContract.GetDistributedProfitsInfo(schemeId, period: 5);
// distributedInfo.AmountsMap is empty or has negative burned amounts
// distributedInfo.TotalShares = 0
// The original 10,000 ELF contribution record is gone

// 7. User cannot claim - ClaimProfits will skip this period
// because TotalShares = 0 or AmountsMap is empty
```

This test demonstrates that the 10,000 ELF tokens remain at the period-specific virtual address but are permanently inaccessible due to destroyed accounting records.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L522-525)
```csharp
        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L532-550)
```csharp
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L556-556)
```csharp
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L685-712)
```csharp
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L864-871)
```csharp
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-55)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }
```
