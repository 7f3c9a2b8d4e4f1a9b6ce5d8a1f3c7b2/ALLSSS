# Audit Report

## Title
Missing Validation of Decrypted Secret Pieces Allows Consensus Randomness Manipulation

## Summary
The AEDPoS consensus mechanism's secret sharing implementation fails to validate that reconstructed InValues match committed OutValues. Malicious miners can submit arbitrary decrypted pieces, causing incorrect InValue reconstruction that manipulates signature calculations and miner ordering in subsequent rounds, breaking the VRF randomness property of the consensus mechanism.

## Finding Description

The secret sharing mechanism uses a commit-reveal scheme where miners commit to `OutValue = Hash(InValue)` and later reveal the `InValue` through decrypted secret pieces. The protocol is missing critical validation at multiple points.

**Unvalidated Storage of Decrypted Pieces:**

The `UpdateLatestSecretPieces()` function stores decrypted pieces without authenticity checks: [1](#0-0) 

Similarly, `PerformSecretSharing()` stores decrypted pieces without validation: [2](#0-1) 

**Missing Validation During Reconstruction:**

When `RevealSharedInValues()` reconstructs a miner's InValue from decrypted pieces, it performs no validation against the committed OutValue: [3](#0-2) 

The critical missing check is: `Hash(reconstructedInValue) == OutValue` from the previous round.

**Impact on Consensus:**

The incorrectly reconstructed PreviousInValue is used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks: [4](#0-3) 

The signature calculation XORs the previousInValue with all existing signatures: [5](#0-4) 

This signature directly determines miner ordering through modulo calculation: [6](#0-5) [7](#0-6) 

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates the block producer's own PreviousInValue, not other miners' revealed values: [8](#0-7) 

The DecodeSecret implementation uses only the first threshold pieces: [9](#0-8) 

If a malicious miner's fake piece is among the first threshold (2/3) pieces, reconstruction produces an incorrect value with approximately 67% probability.

## Impact Explanation

**Consensus Integrity Breach:**
- Manipulates which miners get assigned to which time slots in subsequent rounds
- Breaks the unpredictability guarantee of the VRF-based consensus mechanism
- Enables strategic manipulation of consensus order for economic advantage
- Violates the fundamental invariant of fair and random miner scheduling

**Attack Scenario:**
1. Round N: Honest Miner A commits `OutValue_A = Hash(InValue_A)` and shares encrypted pieces
2. Round N+1: Malicious Miner B submits arbitrary fake bytes as "decrypted" pieces for Miner A
3. Round N+1: `RevealSharedInValues()` reconstructs incorrect `InValue_A'` using the fake pieces
4. Round N+2: If Miner A didn't mine in Round N+1, `SupplyCurrentRoundInformation()` uses fake `InValue_A'` to calculate Miner A's signature
5. Result: Miner A gets assigned wrong order in next round based on manipulated signature

This breaks the core security property that mining order should be determined by unpredictable VRF outputs, not by adversarial manipulation.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current miner (realistic - elected positions)
- Secret sharing must be enabled (typical configuration)
- No special privileges beyond normal miner status

**Attack Complexity:**
- Low - attacker simply provides arbitrary bytes instead of correct decryption
- No cryptographic attacks required
- Executed during normal block production workflow
- Success probability â‰ˆ 67% (threshold/total miners) per attempt
- Can retry across multiple rounds until successful

**Detection Difficulty:**
- On-chain: Impossible to distinguish fake from real decrypted pieces without private keys
- Off-chain: Would require extensive statistical analysis of miner ordering patterns
- No existing validation mechanisms catch this attack

**Economic Incentives:**
- Cost: Minimal (submitting data during normal mining)
- Benefit: Improved mining positions, ability to favor/punish specific miners, increased block rewards
- Risk: Low (undetectable through current validation)

## Recommendation

Add validation in `RevealSharedInValues()` to verify reconstructed InValues against committed OutValues:

```csharp
var revealedInValue = HashHelper.ComputeFrom(
    SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// CRITICAL: Validate reconstructed value against committed OutValue
if (previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue != null &&
    HashHelper.ComputeFrom(revealedInValue) != 
    previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue)
{
    Context.LogDebug(() => $"Invalid revealed InValue for {publicKeyOfAnotherMiner}");
    continue; // Skip this miner's invalid reconstruction
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

Additionally, consider adding cryptographic authentication (e.g., MACs) to decrypted pieces to prove authenticity without requiring validation against OutValue.

## Proof of Concept

A test would demonstrate:
1. Setup: Initialize consensus with multiple miners and secret sharing enabled
2. Round N: Miner A produces block with valid OutValue and encrypted pieces
3. Round N+1: Malicious Miner B produces block and submits fake decrypted pieces via UpdateValue
4. Round N+1: Extra block producer triggers NextRound, calling RevealSharedInValues
5. Verification: Check that Miner A's PreviousInValue in current round state does NOT match Hash(InValue_A) from Round N
6. Round N+2: Verify Miner A's signature and FinalOrderOfNextRound are based on the incorrect PreviousInValue

The test would confirm that fake decrypted pieces propagate through to affect miner ordering without any validation failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-48)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L48-50)
```csharp
            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
```
