# Audit Report

## Title
Mining Interval Manipulation in NextRound Allows Strategic Block Production Time Limit Control

## Summary
A miner producing a NextRound block can manipulate the mining interval by crafting custom `ExpectedMiningTime` values in the consensus data. The validation logic only checks internal consistency within the provided round but fails to validate that the mining interval matches the previous round, allowing the attacker to control block production time limits for all miners in subsequent rounds.

## Finding Description

The vulnerability stems from insufficient validation during NextRound transitions in the AEDPoS consensus mechanism.

**Root Cause Chain:**

The `DefaultBlockMiningLimit` determines how much time miners have to produce blocks. This limit is calculated based on `TinyBlockSlotInterval` which derives from `MiningInterval`. [1](#0-0) 

The `MiningInterval` property retrieves the interval from the current round via `GetMiningInterval()`. [2](#0-1) 

The `GetMiningInterval()` method calculates the interval from the difference between the first two miners' `ExpectedMiningTime` values. [3](#0-2) 

When generating a NextRound honestly, `GenerateNextRoundInformation()` uses the current round's mining interval to set `ExpectedMiningTime` for all miners. [4](#0-3) [5](#0-4) [6](#0-5) 

**Validation Gap:**

The validation for NextRound behavior includes `TimeSlotValidationProvider` in the validation pipeline. [7](#0-6) [8](#0-7) 

This provider calls `CheckRoundTimeSlots()` on the provided round. [9](#0-8) 

However, `CheckRoundTimeSlots()` only validates internal consistency - ensuring all miners have valid ExpectedMiningTime, intervals are greater than zero, and consecutive intervals are relatively equal. [10](#0-9) 

The `RoundTerminateValidationProvider` only validates round number increment and that InValues are null. [11](#0-10) 

**Exploitation Path:**

1. Attacker is selected to produce the NextRound block (regular occurrence in protocol)
2. Instead of calling the standard `GetConsensusExtraDataForNextRound()`, [12](#0-11)  craft a custom `NextRoundInput` with modified `ExpectedMiningTime` values
3. Ensure internal consistency (all consecutive miners have equal spacing)
4. Submit via `NextRound` transaction [13](#0-12) 
5. Validation passes because `CheckRoundTimeSlots()` only checks internal consistency
6. The manipulated round is stored via `ProcessNextRound()` [14](#0-13) 
7. All miners generate consensus commands using this manipulated round's `GetMiningInterval()`
8. `DefaultBlockMiningLimit` changes for all miners according to the manipulated interval, affecting the `LimitMillisecondsOfMiningBlock` field in consensus commands [15](#0-14) 

## Impact Explanation

This vulnerability breaks the consensus security guarantee that mining intervals should remain constant within a term. The impact is significant:

**Quantified Impact on Block Production:**
- Normal 4000ms interval → 300ms mining limit (via DefaultBlockMiningLimit calculation)
- Doubled to 8000ms → 600ms limit (100% increase)
- Halved to 2000ms → 150ms limit (50% decrease)

**Strategic Advantages:**
1. **Timing Control**: Attacker chooses when manipulation activates
2. **Preparation Advantage**: Knows new limits before other miners
3. **Information Asymmetry**: Other miners discover change only when generating commands
4. **Persistence**: Manipulation propagates through subsequent rounds until NextTerm resets to `State.MiningInterval` [16](#0-15) 

**Consensus Impact:**
- Can make block production systematically harder or easier for all miners
- Affects consensus timing and block finalization rates
- Can be used to manipulate network conditions strategically
- Undermines fairness assumptions in the consensus protocol

## Likelihood Explanation

**Attacker Capabilities:**
- Must be in the miner set (required for consensus participation - part of normal threat model)
- Must be selected to produce a NextRound block (happens regularly for each miner)
- Must modify node software to craft custom consensus data
- Must maintain internal consistency in the crafted round (technically feasible)

**Feasibility Assessment:**
- **Entry Point**: NextRound block production is a regular protocol occurrence
- **Preconditions**: Being in miner set and selected for NextRound (realistic for consensus attackers)
- **Technical Barrier**: Requires node modification (non-trivial but achievable for sophisticated attacker)
- **Detection**: Changes are on-chain but require active monitoring to detect
- **Constraints**: Extreme changes obvious; subtle manipulation more effective

**Overall Probability**: Medium to High
- Opportunity occurs every round for each miner
- Requires technical sophistication (node modification)
- Detection requires active monitoring
- Economic incentive exists for strategic timing manipulation

## Recommendation

Add validation in `CheckRoundTimeSlots()` or create a new validation provider for NextRound that compares the mining interval of the provided round against the previous round's interval:

```csharp
// In TimeSlotValidationProvider or new MiningIntervalValidationProvider
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        // Validate that mining interval remains constant
        var currentInterval = validationContext.BaseRound.GetMiningInterval();
        var providedInterval = validationContext.ProvidedRound.GetMiningInterval();
        
        if (currentInterval != providedInterval)
        {
            return new ValidationResult 
            { 
                Message = $"Mining interval must remain constant within term. Expected {currentInterval}ms, got {providedInterval}ms" 
            };
        }
    }
    return new ValidationResult { Success = true };
}
```

Add this provider to the NextRound validation pipeline in `AEDPoSContract_Validation.cs`.

## Proof of Concept

A proof of concept would involve:

1. Setting up a test environment with multiple miners
2. Modifying a miner's node to craft a `NextRoundInput` with manipulated `ExpectedMiningTime` values (e.g., doubling the intervals from 4000ms to 8000ms while maintaining internal consistency)
3. Having that miner produce the NextRound block
4. Observing that validation passes despite the interval change
5. Verifying that subsequent miners calculate `DefaultBlockMiningLimit` based on the manipulated 8000ms interval (resulting in 600ms limit instead of 300ms)
6. Confirming the manipulation persists across rounds until the next term transition

The test would demonstrate that no validation prevents mining interval manipulation during NextRound transitions, allowing a single miner to alter consensus timing parameters for the entire network.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-49)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

        protected int MinersCount => CurrentRound.RealTimeMinersInformation.Count;

        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-36)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L50-51)
```csharp
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L71-71)
```csharp
            new TimeSlotValidationProvider(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L17-17)
```csharp
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L209-209)
```csharp
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L39-39)
```csharp
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```
