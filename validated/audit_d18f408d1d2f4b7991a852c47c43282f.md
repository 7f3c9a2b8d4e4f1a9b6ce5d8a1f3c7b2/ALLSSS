# Audit Report

## Title
Double-Counting Vulnerability in RemoveBeneficiary Allows Artificial Deflation of TotalShares

## Summary
The `RemoveBeneficiary` function in the Profit contract contains a critical logic flaw that allows the same profit detail to be processed multiple times when called with the same `ProfitDetailId`. This causes shares to be subtracted from `TotalShares` repeatedly, violating the invariant that each beneficiary's shares should only be counted once during removal. This leads to artificial deflation of `TotalShares` and inflated profit distributions to remaining beneficiaries.

## Finding Description

The vulnerability exists in the `RemoveProfitDetails` helper method called by `RemoveBeneficiary`. The primary protection against double-counting is implemented at lines 321-324, which filters profit details using the `!d.IsWeightRemoved` condition to exclude already-processed details. [1](#0-0) 

However, lines 333-338 contain logic that explicitly bypasses this protection. This code adds a profit detail with a specific `profitDetailId` to `detailsCanBeRemoved` **without checking** if `IsWeightRemoved` is already set to true: [2](#0-1) 

The exploit sequence works as follows:

**First Call**: When `RemoveBeneficiary` is called with a `profitDetailId`:
1. The detail is added to `detailsCanBeRemoved` (lines 333-338)
2. `IsWeightRemoved = true` is set (line 345)
3. If the detail's `LastProfitPeriod < CurrentPeriod` and `EndPeriod < CurrentPeriod`, it remains in the persistent state (lines 346-356)
4. The detail's shares are added to `removedDetails` (line 358)
5. State is saved with `IsWeightRemoved = true` (line 378)
6. `TotalShares` is decremented (line 260) [3](#0-2) [4](#0-3) 

**Second Call**: When `RemoveBeneficiary` is called again with the SAME `profitDetailId`:
1. Lines 321-324 filter out the detail because `IsWeightRemoved = true`
2. Lines 333-338 check if the detail is NOT in `detailsCanBeRemoved` (condition passes because it was filtered out)
3. The detail is added to `detailsCanBeRemoved` AGAIN
4. The detail's shares are added to `removedDetails` AGAIN (line 358)
5. `TotalShares` is decremented AGAIN (line 260)

The `TryAdd()` method correctly accumulates shares within a single invocation, but the vulnerability spans across multiple `RemoveBeneficiary` calls: [5](#0-4) 

## Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

When `TotalShares` is artificially deflated through repeated removal of the same profit detail, the profit distribution calculation `(beneficiary_shares / TotalShares)` becomes incorrect. This directly impacts the `SafeCalculateProfits` calculation used throughout the contract, causing remaining beneficiaries to receive larger profit percentages than they are entitled to.

**Quantified Example:**
- Initial `TotalShares`: 10,000
- Beneficiary A has 1,000 shares to be removed
- After legitimate removal: `TotalShares` = 9,000 (correct)
- After malicious second removal: `TotalShares` = 8,000 (incorrect, 11.1% deviation)
- Remaining beneficiaries now receive 12.5% more profit than they should (9000/8000 = 1.125x)

**Affected Parties:**
- Legitimate beneficiaries who should receive correct profit shares but receive inflated amounts
- The scheme manager who may be held responsible for distribution errors
- The integrity of the entire profit distribution scheme
- Any sub-schemes relying on accurate total share calculations

This breaks the critical economic invariant that `TotalShares` must equal the sum of all active beneficiary shares.

## Likelihood Explanation

**Attacker Capabilities:**

The attacker must be either the scheme manager or control the TokenHolder contract, as enforced by the authorization check: [6](#0-5) 

While this requires privileged access, scheme managers are user-created roles, not trusted system entities. A malicious or compromised scheme manager can exploit this vulnerability.

**Attack Complexity:**
1. Attacker creates or controls a profit scheme
2. Adds beneficiaries with specific `ProfitDetailId` values
3. Calls `RemoveBeneficiary` with a `ProfitDetailId` where the detail's `LastProfitPeriod < CurrentPeriod` and `EndPeriod < CurrentPeriod`
4. Calls `RemoveBeneficiary` again with the same `ProfitDetailId`
5. Shares are subtracted from `TotalShares` twice

**Feasibility Conditions:**
- The profit detail must remain in the list after first removal (occurs when `LastProfitPeriod < CurrentPeriod` AND `EndPeriod < CurrentPeriod`, which is the common case for expired details)
- No additional validation prevents duplicate removal requests
- The exploit is deterministic and requires only 2 transactions

**Detection/Operational Constraints:**
- No on-chain events distinguish legitimate from duplicate removals
- Off-chain monitoring would need to track all `RemoveBeneficiary` calls and their `ProfitDetailId` parameters
- The error could also occur **accidentally** if a manager mistakenly submits the same removal transaction twice

**Probability:** MEDIUM-HIGH for compromised/malicious managers; LOW-MEDIUM for accidental occurrence

## Recommendation

Add an explicit check at lines 333-338 to verify that the detail has not already been marked as `IsWeightRemoved` before adding it to `detailsCanBeRemoved`:

```csharp
// Fixed code at lines 333-338
if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    var detailToAdd = profitDetails.Details.Single(d => d.Id == profitDetailId);
    // Add this check to prevent double-counting
    if (!detailToAdd.IsWeightRemoved)
    {
        detailsCanBeRemoved.Add(detailToAdd);
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_RemoveBeneficiary_DoubleCount_Vulnerability_Test()
{
    const int shares = 1000;
    const int amount = 1000;

    var creator = Creators[0];
    var beneficiary = Normal[0];
    var receiverAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);

    // Create scheme with CanRemoveBeneficiaryDirectly = false (default)
    var schemeId = await CreateSchemeAsync();
    
    var profitDetailId = HashHelper.ComputeFrom("test_detail_id");
    
    // Add beneficiary with specific ProfitDetailId and EndPeriod = 1
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = receiverAddress, Shares = shares },
        SchemeId = schemeId,
        EndPeriod = 1,
        ProfitDetailId = profitDetailId
    });

    // Verify initial TotalShares
    var scheme1 = await creator.GetScheme.CallAsync(schemeId);
    scheme1.TotalShares.ShouldBe(shares);

    // Distribute profits for period 1
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, amount } },
        Period = 1
    });

    // Move to period 2 - now detail has EndPeriod < CurrentPeriod
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 0 } },
        Period = 2
    });

    // First removal with profitDetailId
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        Beneficiary = receiverAddress,
        SchemeId = schemeId,
        ProfitDetailId = profitDetailId
    });

    // Check TotalShares after first removal
    var scheme2 = await creator.GetScheme.CallAsync(schemeId);
    scheme2.TotalShares.ShouldBe(0); // Correct: shares removed once

    // Second removal with SAME profitDetailId - should be a no-op
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        Beneficiary = receiverAddress,
        SchemeId = schemeId,
        ProfitDetailId = profitDetailId
    });

    // Check TotalShares after second removal
    var scheme3 = await creator.GetScheme.CallAsync(schemeId);
    
    // VULNERABILITY: TotalShares becomes negative (underflow wraps to large positive value)
    // Expected: 0 (no change)
    // Actual: -1000 (wrapped to large positive due to unsigned arithmetic)
    scheme3.TotalShares.ShouldBe(0); // This will FAIL, proving the vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L333-338)
```csharp
        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L342-359)
```csharp
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }

                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
            }
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```
