# Audit Report

## Title
VoteId Collision Enables Vote Overwriting and Permanent Token Lock DoS in Delegated Voting

## Summary
The VoteContract contains a critical vulnerability where VoteIds can be overwritten across different voting items due to lack of uniqueness validation. Attackers can register delegated voting items (IsLockToken=false), compute victim VoteIds from public blockchain data, and overwrite VotingRecords, causing permanent token lock DoS for victims who can no longer withdraw their locked funds.

## Finding Description

**Root Cause - Missing Uniqueness Check:**

The Vote function directly overwrites VotingRecords without checking if a VoteId already exists. [1](#0-0) 

**Delegated Voting Allows Arbitrary VoteIds:**

For delegated voting (IsLockToken=false), sponsors can provide arbitrary VoteIds with minimal validation. The code only checks that the sponsor is the caller and that VoteId is not null, but does not verify VoteId uniqueness. [2](#0-1) 

**VoteId Generation is Deterministic and Public:**

For locked voting (IsLockToken=true), VoteIds are generated deterministically from publicly observable transaction data. [3](#0-2) 

The GenerateId implementation concatenates OriginTransactionId (the transaction ID), contract address, and the provided bytes (VotesAmount), then computes a hash. All these values become publicly observable after the transaction is mined. [4](#0-3) 

**Attack Path:**
1. Attacker registers voting item with IsLockToken=false via unrestricted Register method
2. Victim votes on legitimate voting item with IsLockToken=true, tokens get locked
3. Attacker observes victim's transaction on blockchain and computes VoteId from public data (OriginTransactionId + VoteContract address + VotesAmount at time of vote)
4. Attacker calls Vote on their voting item with victim's VoteId, overwriting the VotingRecord
5. VotingRecord.VotingItemId now points to attacker's voting item instead of victim's

**Withdrawal Fails Due to Permission Check:**

When victim attempts withdrawal, the Withdraw function retrieves the overwritten VotingRecord and checks permissions based on the voting item it references. [5](#0-4) 

Since the overwritten VotingRecord references the attacker's voting item (IsLockToken=false), the check requires the caller to be the sponsor of the attacker's item, which fails for the victim.

**Tokens Remain Permanently Locked:**

Victims cannot bypass VoteContract and unlock directly because the TokenContract's Lock/Unlock mechanism uses virtual addresses computed from Context.Sender. The Unlock function computes the virtual address using the caller as Context.Sender. [6](#0-5) 

The Lock function originally computed the virtual address with VoteContract as Context.Sender. [7](#0-6) 

When a victim calls Unlock directly, Context.Sender would be the victim's address, resulting in a different virtual address computation. The tokens remain locked at the original virtual address (computed with VoteContract as sender) where the victim cannot access them.

## Impact Explanation

**Permanent Token Lock DoS:**
- Victim's tokens are locked in TokenContract at a virtual address computed as Hash(VoteContract + victim.Address + VoteId)
- Withdrawal through VoteContract.Withdraw fails due to permission check against the attacker's voting item
- Direct unlock from TokenContract is impossible because it would compute a different virtual address Hash(victim.Address + victim.Address + VoteId)
- No recovery mechanism exists; funds are permanently inaccessible to the victim

**Data Corruption:**
- VotedItemsMap maintains inconsistent state where VoteIds may reference wrong voting items
- Vote counting integrity is compromised as legitimate votes can be effectively erased
- Double counting occurs where the same VoteId contributes to multiple voting items

**Severity Assessment:**
HIGH severity due to:
- Permanent and irreversible fund loss for victims
- No administrative recovery function available
- Affects core voting and token locking functionality
- Simple attack requiring only 2 transactions

## Likelihood Explanation

**Attack Requirements:**
1. Register voting item with IsLockToken=false (unrestricted public method)
2. Observe victim's vote transaction on public blockchain
3. Compute VoteId from public data (OriginTransactionId + VoteContract address + VotesAmount)
4. Call Vote with computed VoteId

**Attack Complexity:** LOW
- Only 2 transactions required (Register + Vote)
- All required data is publicly observable on-chain after victim's transaction is mined
- VoteId computation is deterministic and easily reproducible
- No special permissions, roles, or privileged access required

**Feasibility:** HIGH
- Minimal gas fees required (standard transaction costs)
- No rate limiting or detection mechanisms in place
- Attack is undetectable until victim attempts withdrawal
- Works against any user participating in legitimate IsLockToken=true voting items

**Probability:** HIGH
Given the low attack cost, complete public data availability, absence of access controls, and lack of uniqueness validation, this attack is highly likely to occur once discovered.

## Recommendation

**Immediate Fix:**
Add uniqueness validation before storing VotingRecords:

```csharp
// In Vote function, before line 117:
Assert(State.VotingRecords[input.VoteId] == null, "Vote ID already exists.");
State.VotingRecords[input.VoteId] = votingRecord;
```

**Additional Hardening:**
1. For delegated voting, enforce VoteId generation within the contract rather than accepting arbitrary external VoteIds
2. Include the VotingItemId in VoteId generation to ensure VoteIds are scoped to specific voting items
3. Add a mapping from VoteId to VotingItemId to verify consistency
4. Consider adding emergency withdrawal mechanisms for stuck tokens with appropriate governance controls

## Proof of Concept

```csharp
[Fact]
public async Task VoteId_Collision_Causes_Permanent_Token_Lock()
{
    // 1. Setup: Victim registers and votes on legitimate voting item (IsLockToken=true)
    var legitimateItem = await VictimRegisterVotingItemAsync(isLockToken: true);
    var victimInitialBalance = await GetTokenBalanceAsync(VictimAddress);
    
    // Victim votes and locks tokens
    var voteAmount = 1000;
    var victimVoteId = await VictimVoteOnLegitimateItemAsync(legitimateItem.VotingItemId, voteAmount);
    
    // Verify tokens are locked
    var victimBalanceAfterVote = await GetTokenBalanceAsync(VictimAddress);
    Assert.Equal(victimInitialBalance - voteAmount, victimBalanceAfterVote);
    
    // 2. Attacker observes blockchain and computes victim's VoteId
    // In real scenario: Extract OriginTransactionId from victim's transaction
    var computedVoteId = victimVoteId; // Attacker recomputes this from public data
    
    // 3. Attacker registers their own voting item (IsLockToken=false)
    var attackerItem = await AttackerRegisterVotingItemAsync(isLockToken: false);
    
    // 4. Attacker overwrites victim's VotingRecord
    await AttackerVoteWithVictimVoteIdAsync(
        votingItemId: attackerItem.VotingItemId,
        voteId: computedVoteId,
        voter: VictimAddress
    );
    
    // 5. Verify VotingRecord is overwritten
    var votingRecord = await GetVotingRecordAsync(computedVoteId);
    Assert.Equal(attackerItem.VotingItemId, votingRecord.VotingItemId);
    
    // 6. Victim attempts withdrawal - FAILS
    var withdrawResult = await VictimWithdrawAsync(computedVoteId);
    Assert.False(withdrawResult.Success);
    Assert.Contains("No permission", withdrawResult.Error);
    
    // 7. Tokens remain locked - victim cannot recover them
    var victimFinalBalance = await GetTokenBalanceAsync(VictimAddress);
    Assert.Equal(victimInitialBalance - voteAmount, victimFinalBalance);
    
    // 8. Verify tokens are permanently stuck (no recovery path)
    Assert.True(await AreTokensPermanentlyLockedAsync(VictimAddress, computedVoteId, voteAmount));
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-200)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-145)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-236)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
```
