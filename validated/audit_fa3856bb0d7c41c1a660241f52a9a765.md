# Audit Report

## Title
Missing Empty Address Validation in AddBeneficiary Allows Permanent Profit Loss Through Share Dilution

## Summary
The `AddBeneficiary` method in the Profit contract uses inconsistent address validation that only checks for null references but not empty Address values, allowing scheme managers to accidentally add beneficiaries with empty addresses. This causes permanent profit loss as shares allocated to empty addresses dilute all other beneficiaries while remaining unclaimable.

## Finding Description

The vulnerability exists in the `AssertValidInput` validation method which only performs a null check on the beneficiary address: [1](#0-0) 

In AElf's protobuf-based Address type, `new Address()` creates an Address instance with an empty ByteString Value that passes the null check but has no valid address data.

This contrasts with the proper validation pattern used in `ResetManager` within the same contract: [2](#0-1) 

And the standard validation helper in MultiToken contract: [3](#0-2) 

**Execution Path:**

1. Scheme manager calls `AddBeneficiary` with empty address, which passes validation: [4](#0-3) 

2. Empty address is stored in ProfitDetailsMap with allocated shares: [5](#0-4) 

3. Shares are added to scheme's TotalShares (denominator in profit calculations): [6](#0-5) 

4. When `DistributeProfits` is called, all profits are transferred to the period's virtual address, with TotalShares including the empty address shares as the denominator.

5. When `ClaimProfits` calculates each beneficiary's share using the formula: [7](#0-6) 

All legitimate beneficiaries receive proportionally less because TotalShares includes the empty address's shares.

6. When attempting to claim for the empty address beneficiary, the transfer fails during MultiToken validation: [8](#0-7) 

The profits "allocated" to the empty address remain permanently locked in the period's virtual address with no recovery mechanism.

## Impact Explanation

**Direct Fund Impact:** Profits proportional to empty address shares are permanently lost through dilution of all other beneficiaries' shares.

**Quantified Damage:** If an empty address receives X shares out of N total shares, then (X/N) × 100% of all distributed profits are permanently inaccessible. For example, 100 shares out of 1000 total means 10% permanent loss per distribution period.

**Affected Parties:**
- All legitimate beneficiaries suffer reduced profit shares due to TotalShares dilution
- The scheme loses assets with no recovery path
- Multiple distribution periods compound the loss until detected

**Severity Justification: HIGH**
- Irreversible fund loss through share dilution
- Violates profit distribution integrity
- No admin recovery mechanism exists
- Can affect multiple periods before detection

## Likelihood Explanation

**Attacker Capabilities Required:** Must be scheme manager (scheme creator/owner) OR the TokenHolder system contract. [9](#0-8) 

**Attack Complexity: LOW** - Single transaction to `AddBeneficiary` with `new Address()` as beneficiary parameter.

**Feasibility Conditions:**
- Most likely scenario: Programming error in calling contract or management interface
- Malicious scenario: Compromised or malicious scheme manager
- No on-chain protection exists to prevent this

**Probability Assessment: MEDIUM-HIGH** - While requiring privileged access, the lack of validation makes accidental occurrence through programming bugs highly probable. The codebase demonstrates awareness of this validation pattern through its use in ResetManager: [10](#0-9) 

This inconsistency indicates an oversight rather than intentional design.

## Recommendation

Implement consistent address validation in `AssertValidInput` matching the pattern used in `ResetManager`:

```csharp
private void AssertValidInput(AddBeneficiaryInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    Assert(input.BeneficiaryShare?.Beneficiary != null && 
           input.BeneficiaryShare.Beneficiary.Value.Any(), 
           "Invalid beneficiary address.");
    Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
}
```

Alternatively, use the existing `AssertValidInputAddress` helper from MultiToken contract for consistency across the codebase.

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_EmptyAddress_CausesProfitLoss_Test()
{
    // Setup: Create scheme with 1000 ELF to distribute
    var schemeId = await CreateSchemeAsync();
    await ContributeProfitsAsync(schemeId, 1000);
    
    // Add legitimate beneficiary with 900 shares
    var legitimateBeneficiary = Address.FromPublicKey(CreatorKeyPair[1].PublicKey);
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = legitimateBeneficiary,
            Shares = 900
        }
    });
    
    // BUG: Add empty address with 100 shares (should fail but doesn't)
    var emptyAddress = new Address(); // Empty Value
    var result = await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = emptyAddress,
            Shares = 100
        }
    });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // BUG: Should fail
    
    // Distribute profits
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Legitimate beneficiary can only claim 900 ELF (90% due to dilution)
    // Expected: 1000 ELF, Actual: 900 ELF due to empty address holding 100 shares
    var claimableAmount = await ProfitContractStub.GetProfitAmount.CallAsync(
        new GetProfitAmountInput
        {
            SchemeId = schemeId,
            Beneficiary = legitimateBeneficiary,
            Symbol = "ELF"
        });
    claimableAmount.Value.ShouldBe(900); // 10% loss due to empty address dilution
    
    // Empty address cannot claim (transfer would fail), 100 ELF permanently lost
    var emptyAddressClaim = await ProfitContractStub.ClaimProfits.SendWithExceptionAsync(
        new ClaimProfitsInput
        {
            SchemeId = schemeId,
            Beneficiary = emptyAddress
        });
    emptyAddressClaim.TransactionResult.Error.ShouldContain("Invalid input address");
    
    // Result: 100 ELF permanently locked in period's virtual address with no recovery
}
```

## Notes

The report's technical description states tokens are "locked in `State.Balances[emptyAddress][symbol]`" which is slightly inaccurate. The actual mechanism is that tokens remain in the period's virtual address because the transfer TO the empty address fails MultiToken validation. However, the core vulnerability—permanent profit loss through share dilution—remains valid and exploitable through programming error or malicious scheme manager action.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-160)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L209-209)
```csharp
        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L730-730)
```csharp
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L1526-1531)
```csharp
        resetRet = await creator.ResetManager.SendWithExceptionAsync(new ResetManagerInput
        {
            NewManager = new Address(),
            SchemeId = schemeId
        });
        resetRet.TransactionResult.Error.ShouldContain("Invalid new sponsor.");
```
