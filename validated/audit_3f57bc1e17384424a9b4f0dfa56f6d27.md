# Audit Report

## Title
Delegated Voting VoteId Overwrite Enables Vote Double-Counting and Record Corruption

## Summary
The Vote contract's `Vote` function unconditionally overwrites voting records without checking for duplicate VoteIds in delegated voting mode, allowing sponsors to artificially inflate vote tallies and corrupt withdrawal tracking by reusing VoteIds across different voters.

## Finding Description
When a voting item is registered with `IsLockToken = false` (delegated voting), the sponsor controls the `VoteId` parameter and can submit votes on behalf of different voters. [1](#0-0) 

The validation logic in `AssertValidVoteInput` checks that `input.VoteId` is not null but does not verify whether that VoteId has been previously used. [1](#0-0) 

The `Vote` function then unconditionally writes the voting record to state storage, overwriting any existing record at that key. [2](#0-1) 

Subsequently, `UpdateVotingResult` is called, which increments vote totals without any duplicate detection. [3](#0-2)  Each invocation adds the vote amount to the running total, regardless of whether the VoteId was previously used.

The `UpdateVotedItems` function adds the VoteId to the new voter's ActiveVotes list without checking if this VoteId already belongs to another voter. [4](#0-3)  This means multiple voters can have the same VoteId in their tracking lists even though only the last record persists in storage.

**Attack Execution:**
1. Anyone can call `Register` to create a voting item with `IsLockToken = false` and become the sponsor (no access control exists). [5](#0-4) 
2. Sponsor calls `Vote(VoteId=X, Voter=Alice, Amount=100)` - record stored, Alice's ActiveVotes updated, total incremented by 100
3. Sponsor calls `Vote(VoteId=X, Voter=Bob, Amount=200)` with the same VoteId - record overwritten with Bob's data, Bob's ActiveVotes updated, total incremented by 200 (now 300 instead of 200)
4. Result: Only Bob's record exists at `State.VotingRecords[X]`, but Alice's ActiveVotes still contains X, vote total is inflated by 100, and withdrawal attempts by Alice will operate on Bob's record

## Impact Explanation
**Critical Severity:**

1. **Governance Manipulation**: Vote totals are artificially inflated through double-counting. Each reuse of a VoteId increments the tally without replacing the previous amount, enabling sponsors to manipulate voting outcomes. This can cause unauthorized proposals to pass or legitimate proposals to fail.

2. **Irreversible State Corruption**: When a VoteId is reused, the previous voter's record is permanently lost from `State.VotingRecords`. The on-chain voting history becomes corrupted and cannot be reconstructed, breaking audit trails and data integrity guarantees.

3. **Withdrawal Function Corruption**: The `Withdraw` function retrieves records by VoteId. [6](#0-5)  When a VoteId is reused, the original voter's ActiveVotes list still contains that VoteId, but the actual record points to a different voter. Withdrawal attempts will either fail or incorrectly manipulate the wrong voter's data.

4. **Protocol Invariant Violations**:
   - Each VoteId should map to exactly one voting record - VIOLATED
   - Vote totals should equal the sum of all active records - VIOLATED  
   - Each voter's ActiveVotes should reference their own valid records - VIOLATED

## Likelihood Explanation
**High Likelihood:**

1. **No Access Control**: The `Register` function has no authorization checks - any address can create a voting item with `IsLockToken = false` and become a sponsor. [5](#0-4) 

2. **Trivial Exploitation**: A malicious or buggy sponsor only needs to call `Vote` multiple times with the same VoteId for different voters. No special privileges or complex setup is required.

3. **Real-World Scenarios**:
   - Buggy third-party voting integrations accidentally reusing VoteIds
   - Malicious sponsors intentionally manipulating vote counts
   - Poorly audited contracts failing to implement unique identifier generation

4. **Difficult Detection**: The corruption is subtle - aggregate vote tallies appear normal, but examining individual records reveals inconsistencies. Post-hoc auditing may fail to detect the issue until disputes arise.

5. **No Mitigation**: While trusted contracts like Election generate unique VoteIds correctly [7](#0-6) , this provides no protection against untrusted sponsors misusing the Vote contract directly.

## Recommendation
Add a duplicate VoteId check in the `AssertValidVoteInput` function before allowing votes in delegated mode:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    if (!votingItem.IsLockToken)
    {
        Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
        Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
        Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        // ADD THIS CHECK:
        Assert(State.VotingRecords[input.VoteId] == null, "Vote Id already exists.");
    }
    else
    {
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        input.Voter = Context.Sender;
        input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
    }

    return votingItem;
}
```

This ensures each VoteId can only be used once, preventing record overwrites, double-counting, and withdrawal corruption.

## Proof of Concept
```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task VoteId_Overwrite_DoubleCounting_Test()
{
    // Setup: Register a delegated voting item (IsLockToken = false)
    var votingItemId = await RegisterDelegatedVotingItem();
    
    // Malicious sponsor creates votes with same VoteId for different voters
    var duplicateVoteId = HashHelper.ComputeFrom("duplicate");
    
    // First vote: Alice votes 100
    await VoteContract.Vote(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = duplicateVoteId,
        Voter = AliceAddress,
        Amount = 100,
        Option = "OptionA"
    });
    
    // Check first vote recorded correctly
    var record1 = await VoteContract.GetVotingRecord.CallAsync(duplicateVoteId);
    record1.Voter.ShouldBe(AliceAddress);
    record1.Amount.ShouldBe(100);
    
    var result1 = await VoteContract.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    result1.VotesAmount.ShouldBe(100); // Total is 100
    
    // Second vote: Bob votes 200 with SAME VoteId
    await VoteContract.Vote(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = duplicateVoteId, // REUSED VoteId
        Voter = BobAddress,
        Amount = 200,
        Option = "OptionA"
    });
    
    // Verify vulnerability:
    // 1. Record overwritten - now shows Bob instead of Alice
    var record2 = await VoteContract.GetVotingRecord.CallAsync(duplicateVoteId);
    record2.Voter.ShouldBe(BobAddress); // Alice's record lost!
    record2.Amount.ShouldBe(200);
    
    // 2. Vote total DOUBLE-COUNTED - should be 200 but is 300
    var result2 = await VoteContract.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    result2.VotesAmount.ShouldBe(300); // BUG: Should be 200, but is 300!
    
    // 3. Alice's ActiveVotes still contains the VoteId even though record shows Bob
    var aliceVotes = await VoteContract.GetVotedItems.CallAsync(AliceAddress);
    aliceVotes.VotedItemVoteIds[votingItemId.ToHex()].ActiveVotes.ShouldContain(duplicateVoteId);
    
    // Vulnerability confirmed: double-counting (300 vs 200) + record corruption
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```
