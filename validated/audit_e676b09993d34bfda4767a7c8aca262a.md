# Audit Report

## Title
Insufficient Validation in Recharge() Allows Side Chain to Immediately Return to Debt Status

## Summary
The `Recharge()` function in the CrossChain contract contains a critical validation flaw at line 207 that reads the balance AFTER paying arrears, causing double-counting of `input.Amount`. This allows side chains to be recharged with insufficient funds, passing validation but immediately returning to `IndexingFeeDebt` status upon the next block indexing attempt. [1](#0-0) 

## Finding Description

The validation logic has a critical ordering flaw in its execution sequence:

1. **Lines 181-188**: Transfer `input.Amount` from sender to the side chain's virtual address, increasing the virtual address balance to `balance_before + input.Amount`

2. **Lines 194-204**: For chains in `IndexingFeeDebt` status, iterate through all arrears and transfer from the virtual address to pay proposers, reducing balance to `balance_before + input.Amount - arrearsAmount`

3. **Line 206**: Call `GetSideChainIndexingFeeDeposit(chainId)` which queries the current balance of the virtual address [2](#0-1) 
   
   At this point: `originBalance = balance_before + input.Amount - arrearsAmount`

4. **Line 207**: Validation check `Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice)`

Substituting the actual value of `originBalance`:
```
input.Amount + (balance_before + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice
2 × input.Amount + balance_before >= 2 × arrearsAmount + IndexingPrice
```

This double-counts `input.Amount` (appears twice on left side) and requires `arrearsAmount` twice on the right side despite being paid only once.

**Correct validation should be:** After recharge and paying arrears, the remaining balance must support at least one more block indexing:
```
balance_before + input.Amount - arrearsAmount >= IndexingPrice
input.Amount >= arrearsAmount + IndexingPrice - balance_before
```

**The discrepancy:** The flawed check only requires:
```
input.Amount >= arrearsAmount + (IndexingPrice - balance_before) / 2
```

This creates an exploit gap of `(IndexingPrice - balance_before) / 2` tokens.

When the chain subsequently attempts indexing, the insufficient balance causes it to immediately return to debt status: [3](#0-2) 

## Impact Explanation

This vulnerability breaks the invariant that side chains marked as `Active` must have sufficient balance to index at least one block. The impacts include:

1. **Operational Disruption**: Side chains oscillate between `Active` and `IndexingFeeDebt` status without successfully maintaining operation. The chain appears healthy in status but lacks functional capability.

2. **Miner Payment Loss**: Miners proposing blocks for indexing don't receive immediate payment. Instead, arrears accumulate again, creating a debt cycle that requires repeated recharge attempts.

3. **Resource Waste**: Multiple recharge transactions are required before achieving stable operation, wasting gas fees. Users must make additional transactions to reach the correct balance.

4. **Cross-Chain Communication Degradation**: The parent chain's ability to reliably index side chain data is compromised, as chains repeatedly fall back into debt status. While indexing continues, the payment mechanism becomes unstable.

5. **State Confusion**: The chain's status indicates `Active` but the actual balance is insufficient for operation, creating misleading state information for monitoring and management systems.

**Severity: Medium** - This causes operational disruption and payment delays but does not result in direct fund theft or complete denial of service. The cross-chain indexing mechanism continues to function, but with degraded reliability and payment guarantees.

## Likelihood Explanation

This vulnerability has **high likelihood** of occurrence:

**Reachable Entry Point**: `Recharge()` is a public function callable by any address with sufficient token allowance and approval.

**Feasible Preconditions**:
- Side chain must be in `IndexingFeeDebt` status - this is a common operational scenario when chains exhaust their deposited funds
- `balance_before_recharge < IndexingPrice` - typical for chains that have gone into debt

**Execution Practicality**: The exploit requires simple arithmetic calculation:
- Given `arrearsAmount = 100`, `IndexingPrice = 100`, `balance_before = 0`
- Correct requirement: `input.Amount >= 200`
- Flawed validation allows: `input.Amount >= 150`
- Recharging with 150 leaves balance of 50, insufficient for the next 100-token indexing operation

**Attack Complexity**: Low - requires only a single recharge transaction with a calculated amount. No special privileges, complex multi-step sequences, or timing dependencies.

**Economic Rationality**: The scenario can occur through honest mistake or intentional exploitation. The recharger doesn't lose funds (they're deposited to the chain), but creates an unstable state. The minimal cost is the gas for the transaction plus the recharge amount.

## Recommendation

Modify the validation logic to check the balance BEFORE paying arrears, or restructure the validation to correctly verify the post-payment balance:

**Option 1 - Check before payment:**
```csharp
if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
{
    var currentBalance = GetSideChainIndexingFeeDeposit(chainId);
    Assert(input.Amount + currentBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
        "Indexing fee recharging not enough.");
    
    // Then pay arrears
    foreach (var arrears in sideChainInfo.ArrearsInfo)
    {
        arrearsAmount += arrears.Value;
        TransferDepositToken(new TransferInput
        {
            To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = arrears.Value,
            Memo = "Indexing fee recharging."
        }, chainId);
    }
}
```

**Option 2 - Verify post-payment balance directly:**
```csharp
if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
{
    // Pay arrears first
    foreach (var arrears in sideChainInfo.ArrearsInfo)
    {
        arrearsAmount += arrears.Value;
        TransferDepositToken(new TransferInput
        {
            To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = arrears.Value,
            Memo = "Indexing fee recharging."
        }, chainId);
    }
    
    // Verify remaining balance is sufficient
    var remainingBalance = GetSideChainIndexingFeeDeposit(chainId);
    Assert(remainingBalance >= sideChainInfo.IndexingPrice,
        "Indexing fee recharging not enough.");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RechargeWithInsufficientAmount_PassesValidationButImmediatelyReturnsToDebt()
{
    // Setup: Create side chain with specific parameters to demonstrate the vulnerability
    var lockedToken = 0;  // Chain has exhausted initial funds
    var indexingPrice = 100;  // Cost per block
    var parentChainId = 123;
    var parentChainHeightOfCreation = 10;
    
    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, parentChainId, lockedToken, indexingPrice, AnotherKeyPair);
    
    // Index one block to create debt of 100
    var sideChainBlockData = CreateSideChainBlockData(
        HashHelper.ComputeFrom("hash"), 1, sideChainId, HashHelper.ComputeFrom("merkle"));
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { sideChainBlockData } }, 
        new[] { sideChainId });
    
    // Verify chain is in debt with arrears of 100
    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(
        new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(100);
    
    // VULNERABILITY: Recharge with 150 instead of required 200
    // Flawed validation: 150 + (0 + 150 - 100) >= 100 + 100 → 200 >= 200 ✓ PASSES
    // Correct should require: 150 + 0 - 100 >= 100 → 50 >= 100 ✗ SHOULD FAIL
    await ApproveBalanceAsync(150, AnotherKeyPair);
    var rechargeResult = await GetCrossChainContractStub(AnotherKeyPair).Recharge.SendAsync(
        new RechargeInput { ChainId = sideChainId, Amount = 150 });
    rechargeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Chain is marked as Active
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.Active);
    
    // But balance is only 50 (150 - 100 arrears), insufficient for next indexing
    var balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(50);
    
    // Attempt to index next block - chain immediately returns to debt
    var sideChainBlockData2 = CreateSideChainBlockData(
        HashHelper.ComputeFrom("hash2"), 2, sideChainId, HashHelper.ComputeFrom("merkle2"));
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { sideChainBlockData2 } }, 
        new[] { sideChainId });
    
    // PROOF: Chain immediately returned to IndexingFeeDebt status
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    // New debt accumulated (100 - 50 = 50 shortfall)
    debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(
        new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(50);
}
```

## Notes

The validation flaw is subtle but mathematically provable. The gap in validation is exactly `(IndexingPrice - balance_before) / 2`, which for typical scenarios where `balance_before = 0` and `IndexingPrice >= 2`, allows integer amounts that violate the invariant. The existing test suite validates correct behavior but doesn't test the boundary conditions where this vulnerability manifests with parameters that create exploitable integer gaps.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L844-851)
```csharp
                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
```
