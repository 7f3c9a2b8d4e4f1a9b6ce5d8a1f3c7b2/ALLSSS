# Audit Report

## Title
Missing Order Value Validation in Round Structure Enables Consensus DoS Attack

## Summary
The AEDPoS consensus contract fails to validate that miner Order values in `NextRoundInput` are sequential starting from 1. The `GetMiningInterval()` method assumes miners with Order 1 and 2 exist, leading to an `ArgumentOutOfRangeException` when a malicious miner submits a round with invalid Order values. This causes all nodes to crash when attempting to retrieve consensus commands, halting the entire blockchain.

## Finding Description

The vulnerability exists because the consensus system assumes miner Order values are sequential starting from 1, but never validates this assumption when accepting external input.

The `CommandStrategyBase` constructor stores a Round parameter without validation [1](#0-0) . All strategy implementations access the `MiningInterval` property [2](#0-1) , which calls `GetMiningInterval()` on the CurrentRound.

The critical flaw is in `GetMiningInterval()` which filters for miners with Order == 1 or Order == 2, then accesses `firstTwoMiners[1]` without bounds checking [3](#0-2) . If no miners have these Order values, this throws an unhandled exception.

The validation in `CheckRoundTimeSlots()` only verifies time intervals between consecutive miners ordered by their Order property, but does NOT validate that Order values start from 1 [4](#0-3) . This validation is called by `TimeSlotValidationProvider` when processing new rounds [5](#0-4) .

The `NextRoundInput.ToRound()` conversion performs no validation on Order values [6](#0-5) . When `ProcessNextRound()` processes the input, it directly stores the unvalidated Round [7](#0-6)  via `AddRoundInformation()` [8](#0-7) .

The attack path:
1. Malicious miner crafts `NextRoundInput` with Order values starting from 10 (e.g., 10, 11, 12...)
2. Sets ExpectedMiningTime with consistent intervals to pass `CheckRoundTimeSlots()`
3. Submits NextRound transaction - validation passes
4. Malicious Round is stored in state
5. When any miner calls `GetConsensusCommand()` [9](#0-8) , strategy classes are instantiated with the malicious Round
6. All strategies (`NormalBlockCommandStrategy` [10](#0-9) , `TinyBlockCommandStrategy` [11](#0-10) , `TerminateRoundCommandStrategy` [12](#0-11) ) access `MiningInterval`
7. Crash occurs when accessing `firstTwoMiners[1]` with insufficient elements

The code in `Round_Generation.cs` shows the system expects sequential Order values starting from 1 [13](#0-12)  and explicitly checks for Order == 1 miners [14](#0-13) , but validation never enforces this invariant on external input.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial of service of the consensus mechanism. Once a malicious Round is stored, ALL nodes crash with an unhandled `ArgumentOutOfRangeException` when attempting to retrieve consensus commands. This halts block production entirely.

The impact is catastrophic:
- **Operational**: Complete blockchain halt - no blocks can be produced
- **Scope**: Affects all network participants regardless of behavior
- **Duration**: Permanent until manual intervention
- **Recovery**: Requires coordinated manual state reset across all nodes

All miners are unable to produce blocks, users cannot submit transactions, and the entire chain becomes frozen. The attack persists in state, so the crash repeats on every consensus command retrieval attempt until the malicious Round is manually removed from storage.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Capabilities**: The attacker must be an active miner (verified by `PreCheck()` [15](#0-14) ), which is obtainable through the standard election process. Miners are NOT trusted roles in the threat model.

**Attack Complexity**: LOW - The attacker only needs to:
1. Craft a `NextRoundInput` with Order values starting from 10 instead of 1
2. Set ExpectedMiningTime values with consistent intervals
3. Ensure FinalOrderOfNextRound matches OutValue counts per `NextRoundMiningOrderValidationProvider` [16](#0-15) 
4. Submit the NextRound transaction

**Feasibility**: The validation pipeline [17](#0-16)  includes multiple providers but NONE validate Order sequentiality. The malicious input passes all checks and gets stored. The attack requires a single malicious block with minimal economic cost beyond being a miner.

**Detection**: Pre-execution detection is difficult because the malformed Round passes all validation. Post-execution detection is immediate (all nodes crash), but damage is already done.

## Recommendation

Add validation in `CheckRoundTimeSlots()` or in a dedicated validator to ensure Order values are sequential starting from 1:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    // NEW: Validate Order values are sequential starting from 1
    for (var i = 0; i < miners.Count; i++)
    {
        if (miners[i].Order != i + 1)
            return new ValidationResult { Message = $"Invalid Order value. Expected {i + 1}, got {miners[i].Order}" };
    }

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // ... rest of existing validation
}
```

Alternatively, add bounds checking in `GetMiningInterval()`:

```csharp
public int GetMiningInterval()
{
    if (RealTimeMinersInformation.Count == 1)
        return 4000;

    var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
        .OrderBy(m => m.Order).ToList();

    if (firstTwoMiners.Count < 2)
        return 4000; // Fallback for invalid Order configuration

    return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
        .Milliseconds());
}
```

The first approach (validation) is preferred as it prevents invalid state from being stored.

## Proof of Concept

```csharp
[Fact]
public async Task OrderValidation_MissingSequentialOrders_CausesConsensusCrash()
{
    // Setup: Initialize consensus with valid round
    var initialMiners = GenerateInitialMiners(3); // Orders 1, 2, 3
    await InitializeConsensus(initialMiners);
    
    // Attack: Craft malicious NextRoundInput with invalid Orders
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            { initialMiners[0].Pubkey, new MinerInRound { Pubkey = initialMiners[0].Pubkey, Order = 10, ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMinutes(1)), FinalOrderOfNextRound = 10, OutValue = Hash.Generate() }},
            { initialMiners[1].Pubkey, new MinerInRound { Pubkey = initialMiners[1].Pubkey, Order = 11, ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMinutes(2)), FinalOrderOfNextRound = 11, OutValue = Hash.Generate() }},
            { initialMiners[2].Pubkey, new MinerInRound { Pubkey = initialMiners[2].Pubkey, Order = 12, ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMinutes(3)), FinalOrderOfNextRound = 12, OutValue = Hash.Generate() }}
        }
    };
    
    // Execute: Submit malicious NextRound (should be rejected but isn't)
    var result = await ConsensusContract.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes validation!
    
    // Trigger: Attempt to get consensus command - this will crash
    var exception = await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => 
    {
        await ConsensusContract.GetConsensusCommand.CallAsync(new BytesValue());
    });
    
    // Verify crash occurs due to accessing firstTwoMiners[1] when list is empty
    exception.Message.ShouldContain("Index was out of range");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L28-33)
```csharp
        protected CommandStrategyBase(Round currentRound, string pubkey, Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;
            Pubkey = pubkey;
            CurrentBlockTime = currentBlockTime;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L20-57)
```csharp
    private ConsensusCommand GetConsensusCommand(AElfConsensusBehaviour behaviour, Round currentRound,
        string pubkey, Timestamp currentBlockTime = null)
    {
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        Context.LogDebug(() => $"Params to get command: {behaviour}, {pubkey}, {currentBlockTime}");

        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();

        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();

            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();

            case AElfConsensusBehaviour.TinyBlock:
            {
                var consensusCommand =
                    new ConsensusCommandProvider(new TinyBlockCommandStrategy(currentRound, pubkey,
                        currentBlockTime, GetMaximumBlocksCount())).GetConsensusCommand();
                return consensusCommand;
            }

            default:
                return ConsensusCommandProvider.InvalidConsensusCommand;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L38-38)
```csharp
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L34-38)
```csharp
                ? roundStartTime.AddMilliseconds(-MiningInterval)
                : CurrentRound.RoundNumber == 1
                    ? MinerInRound.ActualMiningTimes.First()
                    : MinerInRound.ExpectedMiningTime;
            var currentTimeSlotEndTime = currentTimeSlotStartTime.AddMilliseconds(MiningInterval);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L35-35)
```csharp
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L41-41)
```csharp
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```
