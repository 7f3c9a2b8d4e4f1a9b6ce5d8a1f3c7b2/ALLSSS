# Audit Report

## Title
Accounting Error: SymbolList Mismatch Causes Donated Tokens to Be Stuck in Treasury

## Summary
The Treasury contract accepts donations of any burnable token without validating against `SymbolList`, while the `Release` function only distributes tokens present in `SymbolList`. This architectural mismatch causes donated tokens excluded from or removed from `SymbolList` to accumulate permanently in the treasury without distribution, resulting in fund loss for beneficiaries and accounting discrepancies.

## Finding Description

The vulnerability stems from a critical validation mismatch between donation acceptance and distribution logic in the Treasury contract.

**Donation Acceptance - No SymbolList Validation**

The `Donate` function only validates that a token is burnable by checking `IsTokenAvailableForMethodFee`, which simply returns `tokenInfo.IsBurnable`. [1](#0-0)  There is no validation against `SymbolList` during donation acceptance. [2](#0-1) 

For non-convertible tokens (those not sellable via TokenConverter), the donation proceeds directly to contribute to the profit scheme without any SymbolList check. [3](#0-2) 

**Distribution Logic - Only SymbolList Tokens**

The `Release` function creates an `AmountsMap` exclusively from `SymbolList`, meaning only tokens in this list will be distributed. [4](#0-3) 

All sub-scheme distributions also create their `AmountsMap` from `SymbolList` only. [5](#0-4) 

**Profit Contract Distribution**

The Profit contract's `DistributeProfits` processes only symbols present in the input `AmountsMap`, building a `profitsMap` from the provided amounts. [6](#0-5)  Symbols not in the map are never distributed. [7](#0-6) 

**Accounting Query Gap**

The `GetUndistributedDividends` function also queries balances only for symbols in `SymbolList`, making non-listed tokens invisible to accounting. [8](#0-7) 

**Insufficient SetSymbolList Validation**

While `SetSymbolList` validates that the native token is included and that non-native tokens are burnable or whitelisted, [9](#0-8)  there is no validation preventing removal of tokens that have existing donated balances in the treasury.

## Impact Explanation

**HIGH Severity** - This vulnerability causes permanent fund loss and breaks critical treasury accounting invariants:

1. **Permanent Fund Loss**: Donated tokens not in `SymbolList` accumulate in the treasury's virtual address but are never distributed to beneficiaries (miners, citizens, backup nodes). There is no administrative recovery mechanism to extract these stuck tokens.

2. **Accounting Discrepancy**: The actual treasury balance exceeds the reported undistributed balance from `GetUndistributedDividends`, violating the accounting invariant that all donated funds should be distributable.

3. **Affected Parties**:
   - Donors lose their contributed tokens
   - Beneficiaries (miners, voters, backup nodes) lose rightful dividend distributions
   - Treasury accounting becomes unreliable for protocol economics

4. **Protocol Economics Impact**: This affects the core reward distribution mechanism for AElf consensus participants, potentially undermining network incentives.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability can be triggered through normal protocol operations without malicious intent:

**Attack Complexity: LOW**
1. Token X must be burnable (available for method fees)
2. Token X must not be convertible to native via TokenConverter
3. Either: Token X is never added to `SymbolList`, OR Token X is removed from `SymbolList` after receiving donations

**Feasibility: HIGHLY FEASIBLE**
- Multiple tokens on AElf are likely burnable (method fee eligible) but not all are in `SymbolList`
- Governance regularly updates `SymbolList` for legitimate policy reasons (token deprecation, adding new tokens)
- No validation prevents donation of non-listed tokens
- No validation prevents removal of tokens with existing balances

**Realistic Scenarios**:
1. A new burnable token is created but not added to treasury `SymbolList` - users can still donate it
2. Governance decides to deprecate a token and removes it from `SymbolList` - all accumulated donations become stuck
3. Human error during `SymbolList` updates accidentally removes active tokens

This can easily occur accidentally during normal treasury governance operations.

## Recommendation

Implement one of the following fixes:

**Option 1: Add SymbolList validation to Donate (Recommended)**

Add validation in the `Donate` function to ensure the token is in `SymbolList` before accepting it:

```csharp
public override Empty Donate(DonateInput input)
{
    Assert(input.Amount > 0, "Invalid amount of donating. Amount needs to be greater than 0.");
    
    // Add SymbolList validation
    var symbolList = State.SymbolList.Value;
    Assert(symbolList != null && symbolList.Value.Contains(input.Symbol), 
        "Token must be in SymbolList to be donated.");
    
    // ... rest of function
}
```

**Option 2: Add balance validation to SetSymbolList**

Prevent removal of tokens with existing balances:

```csharp
public override Empty SetSymbolList(SymbolList input)
{
    AssertPerformedByTreasuryController();
    Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
    
    // Validate no tokens with balances are being removed
    var currentSymbolList = State.SymbolList.Value;
    if (currentSymbolList != null)
    {
        var removedSymbols = currentSymbolList.Value.Where(s => !input.Value.Contains(s));
        foreach (var symbol in removedSymbols)
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = State.TreasuryVirtualAddress.Value,
                Symbol = symbol
            }).Balance;
            Assert(balance == 0, $"Cannot remove symbol {symbol} with existing balance {balance}");
        }
    }
    
    // ... rest of validation
}
```

**Option 3: Add recovery mechanism**

Add an admin function to recover stuck tokens (least recommended as it requires ongoing governance):

```csharp
public override Empty RecoverStuckTokens(RecoverStuckTokensInput input)
{
    AssertPerformedByTreasuryController();
    // Transfer stuck tokens to a designated address
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Treasury_Donate_NonSymbolList_Token_Stuck_Test()
{
    // Setup: Create a burnable token not in SymbolList and not convertible
    var stuckTokenSymbol = "STUCK";
    var stuckTokenAmount = 1000_00000000L;
    
    // Create burnable token
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = stuckTokenSymbol,
        TokenName = "Stuck Token",
        TotalSupply = 10000_00000000L,
        Decimals = 8,
        Issuer = BootMinerAddress,
        IsBurnable = true // Burnable = can be donated
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = stuckTokenSymbol,
        Amount = stuckTokenAmount,
        To = BootMinerAddress
    });
    
    // Verify token is NOT in SymbolList
    var symbolList = await TreasuryContractStub.GetSymbolList.CallAsync(new Empty());
    symbolList.Value.Contains(stuckTokenSymbol).ShouldBe(false);
    
    // Verify token is NOT convertible
    var isConvertible = await TokenConverterContractStub.IsSymbolAbleToSell.CallAsync(
        new StringValue { Value = stuckTokenSymbol });
    isConvertible.Value.ShouldBe(false);
    
    var treasuryVirtualAddress = await GetTreasurySchemeVirtualAddressAsync();
    
    // Approve and Donate the stuck token - THIS SUCCEEDS
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = stuckTokenSymbol,
        Amount = stuckTokenAmount,
        Spender = TreasuryContractAddress
    });
    
    var donateResult = await TreasuryContractStub.Donate.SendAsync(new DonateInput
    {
        Symbol = stuckTokenSymbol,
        Amount = stuckTokenAmount
    });
    donateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify token is now in treasury virtual address
    var treasuryBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = stuckTokenSymbol,
        Owner = treasuryVirtualAddress
    });
    treasuryBalance.Balance.ShouldBe(stuckTokenAmount);
    
    // Verify GetUndistributedDividends does NOT show the stuck token
    var undistributedDividends = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
    undistributedDividends.Value.ContainsKey(stuckTokenSymbol).ShouldBe(false); // Accounting gap!
    
    // Attempt Release - stuck tokens are NOT distributed
    var currentTerm = await AEDPoSContractStub.GetCurrentTermNumber.CallAsync(new Empty());
    await AEDPoSContractStub.NextTerm.SendAsync(new Empty());
    
    // After release, stuck token balance remains unchanged in treasury
    var treasuryBalanceAfterRelease = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = stuckTokenSymbol,
        Owner = treasuryVirtualAddress
    });
    treasuryBalanceAfterRelease.Balance.ShouldBe(stuckTokenAmount); // Still stuck!
    
    // No beneficiaries receive the stuck token - funds are permanently lost
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L252-257)
```csharp
    private bool IsTokenAvailableForMethodFee(string symbol)
    {
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null) throw new AssertionException("Token is not found.");
        return tokenInfo.IsBurnable;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L129-134)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L181-182)
```csharp
        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L210-223)
```csharp
        {
            State.TokenContract.Approve.Send(new ApproveInput
            {
                Symbol = input.Symbol,
                Amount = input.Amount,
                Spender = State.ProfitContract.Value
            });

            State.ProfitContract.ContributeProfits.Send(new ContributeProfitsInput
            {
                SchemeId = State.TreasuryHash.Value,
                Symbol = input.Symbol,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-310)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L367-380)
```csharp
    public override Dividends GetUndistributedDividends(Empty input)
    {
        return new Dividends
        {
            Value =
            {
                State.SymbolList.Value.Value.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = State.TreasuryVirtualAddress.Value,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
            }
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L705-735)
```csharp
    private void ReleaseTreasurySubProfitItems(long termNumber)
    {
        var amountsMap = State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.RewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.BasicRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L432-446)
```csharp
        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-603)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
```
