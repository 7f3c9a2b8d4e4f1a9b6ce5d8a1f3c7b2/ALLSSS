# Audit Report

## Title
Side Chain Validator Permanent Control Through Cross-Chain Indexing Censorship

## Summary
AElf side chains contain a critical architectural flaw where validators can achieve permanent control by refusing to index parent chain consensus data. The validator update mechanism creates an unbreakable circular dependency with no recovery path.

## Finding Description

Side chains in AElf's architecture contain a structural vulnerability in their validator update mechanism.

**The Circular Dependency:**

Side chains permanently operate in NextRound mode (never NextTerm) [1](#0-0)  and have no Election Contract initialized. [2](#0-1) 

The ONLY mechanism for validator updates on side chains is when `GenerateNextRoundInformation` detects that `State.MainChainCurrentMinerList` has changed. [3](#0-2) 

This state variable is ONLY updated by `UpdateInformationFromCrossChain`, [4](#0-3)  which can ONLY be called by the CrossChain contract on side chains. [5](#0-4) 

The CrossChain contract calls this method when indexing parent chain blocks containing consensus extra data. [6](#0-5) 

However, both `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` require the caller to be a current miner. [7](#0-6) [8](#0-7)  This permission check verifies the address through the consensus contract's `IsCurrentMiner` verification. [9](#0-8) [10](#0-9) 

Even `NextRound` requires the caller to be a current or previous miner through the `PreCheck()` validation. [11](#0-10) 

**Why Alternative Protections Don't Exist:**

The `RecordCandidateReplacement` mechanism requires an Election Contract sender, [12](#0-11)  which side chains never initialize. The evil node replacement logic is explicitly only for main chains. [13](#0-12) 

**Attack Execution:**

Once validators become compromised:
1. They refuse to call `ProposeCrossChainIndexing` or `ReleaseCrossChainIndexingProposal` with parent chain consensus data
2. `State.MainChainCurrentMinerList` never updates
3. `GenerateNextRoundInformation` never changes the validator set
4. Malicious validators maintain permanent control

The only recovery mechanism, `DisposeSideChain`, merely terminates the chain and returns the creation deposit to the proposer - it does not recover user funds or state on the compromised side chain. [14](#0-13) 

## Impact Explanation

**Critical Severity** - Complete compromise of side chain security and governance:

**Permanent Governance Capture:** Compromised validators maintain indefinite control over all consensus, block production, and transaction inclusion. They can censor transactions, manipulate ordering, and prevent any governance actions.

**Cross-Chain Bridge Failure:** The side chain becomes isolated from parent chain updates. Users cannot receive validator changes, security patches, or protocol upgrades. Cross-chain asset transfers break down as validators can censor cross-chain transfer transactions.

**No Recovery Path:** Unlike main chains with elections and replacement mechanisms, side chains have zero recovery options. The parent chain cannot force updates, governance organizations cannot override validators, and time-based mechanisms don't exist. `DisposeSideChain` only terminates the chain without recovering user assets.

**Affected Parties:** All users and applications on the compromised side chain lose access to their funds and state with no recovery mechanism.

## Likelihood Explanation

**High Likelihood** given realistic preconditions:

**Realistic Threat Model:** Post-deployment validator compromise is realistic through:
- External coercion via side chain economic incentives
- Infrastructure compromise or key theft
- Validator collusion for side chain-specific economic gain
- Gradual acquisition of multiple validator keys

**Trivial Execution:** The attack is entirely passive - validators simply don't call two specific functions. No complex exploits required. Success probability is 100% once validators are compromised.

**Difficult Detection:** The attack appears identical to network connectivity issues or operational failures, making malicious censorship nearly impossible to distinguish from technical problems.

**No Countermeasures:** The architecture provides zero defensive mechanisms - no time-bound updates, emergency overrides, parent chain intervention capability, or alternative validator update paths.

## Recommendation

Implement one or more of the following architectural changes:

1. **Time-bound forced updates**: Add a mechanism where validator updates must occur within a maximum time period, with automatic fallback to parent chain miner list if the deadline is exceeded.

2. **Parent chain intervention capability**: Allow the parent chain's `SideChainLifetimeController` to directly update the side chain's miner list through a privileged operation.

3. **Emergency governance override**: Implement an emergency multisig or DAO mechanism that can forcibly update validators when malicious behavior is detected.

4. **Dual-path validator updates**: Create an alternative update path that doesn't require current validator cooperation, such as direct state updates from parent chain governance.

## Proof of Concept

The vulnerability is a systemic architectural flaw proven through code analysis. A functional PoC would require:

1. Deploy a side chain with initial validators from parent chain
2. Have parent chain miners change (new election results)
3. Compromised side chain validators refuse to call `ProposeCrossChainIndexing` or `ReleaseCrossChainIndexingProposal` with parent chain consensus data
4. Observe that `State.MainChainCurrentMinerList` never updates
5. Observe that side chain validator set remains unchanged indefinitely
6. Attempt to use `DisposeSideChain` and confirm it only terminates the chain without recovering user funds

The code analysis above definitively proves this attack vector exists with no mitigation mechanisms.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L37-40)
```csharp
        if (input.IsTermStayOne || input.IsSideChain)
        {
            State.IsMainChain.Value = false;
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-134)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-343)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-38)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L58-61)
```csharp
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L222-242)
```csharp
    public override Int32Value DisposeSideChain(Int32Value input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var chainId = input.Value;
        var info = State.SideChainInfo[chainId];
        Assert(info != null, "Side chain not found.");
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");

        if (TryGetIndexingProposal(chainId, out _))
            ResetChainIndexingProposal(chainId);

        UnlockTokenAndResource(info);
        info.SideChainStatus = SideChainStatus.Terminated;
        State.SideChainInfo[chainId] = info;
        Context.Fire(new Disposed
        {
            ChainId = chainId
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-286)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-297)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
