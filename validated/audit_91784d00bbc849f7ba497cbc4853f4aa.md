# Audit Report

## Title
Unvalidated Secret Reconstruction in RevealSharedInValues Allows Consensus State Corruption

## Summary
The `RevealSharedInValues` function reconstructs miners' InValues from DecryptedPieces without validating that the reconstructed secret matches the original OutValue hash. A malicious miner can submit corrupted DecryptedPieces via UpdateValue transactions, causing incorrect PreviousInValue storage that propagates to signature calculations and corrupts consensus state.

## Finding Description

The vulnerability exists in the AEDPoS consensus secret sharing mechanism across multiple components:

**Missing Validation in Secret Reconstruction**: The `RevealSharedInValues` function collects DecryptedPieces from miners and uses `SecretSharingHelper.DecodeSecret` for Lagrange interpolation reconstruction, then directly stores the reconstructed value as `PreviousInValue` without verifying that `Hash(revealedInValue)` equals the original `OutValue` stored in the previous round. [1](#0-0) 

**Unvalidated DecryptedPieces Acceptance**: When miners submit UpdateValue transactions, `PerformSecretSharing` accepts and stores their DecryptedPieces without any correctness validation. [2](#0-1) 

**Validation Gap**: The existing validation in `UpdateValueValidationProvider` only checks the sender's own PreviousInValue against their previous OutValue, not the revealed PreviousInValues reconstructed for other miners through secret sharing. [3](#0-2) 

**Corrupted Value Usage**: When miners fail to produce blocks, `SupplyCurrentRoundInformation` retrieves the potentially corrupted `PreviousInValue` from the current round and uses it to calculate signatures via `CalculateSignature`. [4](#0-3) 

**Impact on Consensus**: The signature calculation XORs the inValue with all miners' signatures aggregated together, so one corrupted signature affects the collective result used for mining order determination. [5](#0-4) 

**Attack Vector**: A malicious miner submits UpdateValue with corrupted DecryptedPieces. Since Shamir's Secret Sharing has no error correction, even one corrupted share among the 2/3 threshold produces a completely incorrect reconstruction. The `DecodeSecret` method always succeeds via Lagrange interpolation regardless of input validity. [6](#0-5) 

## Impact Explanation

**Critical Consensus Integrity Violation**: This vulnerability breaks the core security guarantee of the AEDPoS consensus mechanism - correct round transitions and verifiable randomness. When corrupted DecryptedPieces cause incorrect PreviousInValue reconstruction, subsequent signature calculations become wrong, directly affecting:

1. **Consensus Randomness**: Signatures are combined via XOR to generate randomness for mining order selection. One corrupted signature pollutes the entire result through the XOR operation.

2. **Mining Schedule Integrity**: The corrupted signature produces incorrect mining order calculations, potentially allowing attackers to manipulate block production scheduling and break the fairness guarantees of the consensus protocol.

3. **Cryptographic Chain Break**: The InValue→OutValue→Signature chain that ensures consensus unpredictability is broken for affected miners, compromising the Byzantine fault tolerance properties that the protocol depends on.

All miners and the consensus mechanism are affected because miners who fail to produce blocks have their signatures filled using the corrupted PreviousInValue, propagating the corruption through subsequent rounds.

## Likelihood Explanation

**High Likelihood - Low Complexity Attack**:

**Attacker Requirements**: Any miner in the consensus set can execute this attack, requiring only:
- Miner status (normal operational requirement for consensus participation)
- Ability to submit UpdateValue transactions (standard consensus behavior)

**Attack Execution**: The attacker simply provides corrupted byte arrays as DecryptedPieces values when submitting UpdateValue. The attack succeeds because:
- No validation checks DecryptedPieces correctness before storage
- Shamir's Secret Sharing inherently fails completely with any corrupted share among the threshold
- If the attacker's piece is among the first 2/3 used for reconstruction, the result is guaranteed wrong
- The corruption is silent - no errors are thrown, wrong values are stored normally

**Detection Difficulty**: The attack is difficult to detect because the incorrect PreviousInValue is stored without errors, and corruption only manifests when signatures don't match expected values in subsequent consensus rounds, which could be misattributed to network issues or other factors.

## Recommendation

Add validation after secret reconstruction in `RevealSharedInValues` to verify that the reconstructed InValue matches the original OutValue commitment:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate reconstructed InValue against previous OutValue
if (anotherMinerInPreviousRound.OutValue != null && 
    revealedInValue != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Secret sharing reconstruction validation failed for {publicKeyOfAnotherMiner}");
    continue; // Skip storing corrupted value
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures that only correctly reconstructed secrets that match the original OutValue commitments are stored as PreviousInValue, preventing consensus state corruption from malicious DecryptedPieces submissions.

## Proof of Concept

The vulnerability can be demonstrated through the following attack scenario:

1. **Setup**: Consensus round N completes with multiple miners producing blocks and storing their OutValue (Hash of InValue)
2. **Attack**: In round N+1, malicious miner submits UpdateValue transaction with corrupted DecryptedPieces for victim miner
3. **Exploitation**: In round N+1 extra block or N+2, when NextRound is called:
   - `RevealSharedInValues` is invoked [7](#0-6) 
   - Corrupted DecryptedPieces are used to reconstruct victim's InValue without validation
   - Wrong PreviousInValue is stored in consensus state
4. **Impact**: When victim fails to produce a block later, `SupplyCurrentRoundInformation` retrieves the corrupted PreviousInValue and calculates an incorrect signature, propagating corruption through the consensus mechanism via XOR operations

The proof of concept confirms that no validation prevents storing incorrectly reconstructed secrets, and the corrupted values are used in critical consensus calculations affecting all miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L112-114)
```csharp
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-64)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```
