# Audit Report

## Title
Vote Record Overwrite Enables Double-Counting in Delegated Voting

## Summary
The Vote contract allows sponsors of delegated voting items to call `Vote()` multiple times with the same VoteId but different voters. Each call unconditionally overwrites the previous voting record while still incrementing vote totals, causing permanent inflation of vote counts that persists even after withdrawal.

## Finding Description

The vulnerability exists in the `Vote()` method's validation logic for delegated voting scenarios. [1](#0-0) 

For delegated voting (when `IsLockToken=false`), the `AssertValidVoteInput` method validates that the sender is the sponsor, the Voter address is provided, and the VoteId is not null. [2](#0-1) 

However, **the contract does not check whether the VoteId already exists** in `State.VotingRecords` before proceeding. This allows a sponsor to reuse the same VoteId for multiple different voters.

When `Vote()` is called, the voting record is unconditionally stored, overwriting any existing record with the same VoteId. [1](#0-0) 

The `UpdateVotingResult()` method then increments vote totals regardless of whether this VoteId was previously used. [3](#0-2)  The vote tallies (`Results[option]`, `VotersCount`, `VotesAmount`) are incremented every time `Vote()` is called, even when overwriting an existing VoteId.

The `UpdateVotedItems()` method adds the VoteId to the new voter's `ActiveVotes` list without checking if another voter already has this VoteId. [4](#0-3) 

**Attack Scenario:**
1. Sponsor calls `Vote(VoteId=X, Voter=Alice, Amount=100)` → Results increase by 100
2. Sponsor calls `Vote(VoteId=X, Voter=Bob, Amount=200)` → `VotingRecords[X]` now points to Bob (Alice's record overwritten), Results increase by another 200 (total now 300)
3. Alice has VoteId X in her `ActiveVotes` but cannot withdraw (only sponsor can withdraw for delegated voting)
4. When sponsor withdraws VoteId X, only Bob's 200 is subtracted → 100 phantom votes remain permanently

For regular voting (`IsLockToken=true`), VoteIds are auto-generated using transaction-specific data, preventing collisions. [5](#0-4)  However, this protection does not exist for delegated voting where sponsors provide their own VoteIds.

## Impact Explanation

**Vote Integrity Compromise**: A malicious sponsor can artificially inflate vote totals by reusing VoteIds with different voters. Each reuse adds to the aggregate vote count while only maintaining the last voter's record, creating phantom votes that cannot be traced back or removed.

**Permanent State Corruption**: The withdrawal mechanism only subtracts the amount from the current voting record. [6](#0-5)  When a duplicate VoteId is withdrawn, only the final voter's amount is subtracted, leaving previously counted votes permanently inflated in the results.

**Orphaned Vote Tracking**: Previous voters retain the VoteId in their `ActiveVotes` list but cannot withdraw because the withdrawal permission check validates that the sender must be the sponsor for delegated voting. [7](#0-6)  This creates irrecoverable inconsistencies in voter state.

**Real-World Impact**: While the Election contract implements its own duplicate VoteId protection [8](#0-7) , any other contracts or users creating custom delegated voting items (DAOs, community governance, voting polls) would be vulnerable to vote manipulation. This breaks the fundamental voting integrity guarantee that each vote is counted exactly once.

## Likelihood Explanation

**Attack Feasibility**: The exploit requires only that a sponsor:
1. Create a delegated voting item by calling `Register()` with `IsLockToken=false` (any user can do this)
2. Call the public `Vote()` method multiple times with the same VoteId but different Voter addresses

No special permissions beyond being the sponsor of a voting item are needed, and any user can become a sponsor by registering their own voting item.

**Access Control**: For delegated voting, only the sponsor can call `Vote()`, as enforced by the contract. [9](#0-8)  However, any user can become a sponsor by creating their own voting item.

**Detection Difficulty**: The attack leaves minimal traces since `VotingRecords` only shows the final state. Off-chain monitoring would need to track all `Vote()` transactions and compare against stored records to detect the discrepancy.

**Realistic Scenario**: Custom voting systems built on top of the Vote contract (community polls, DAO governance, reputation systems) would be vulnerable if they don't implement Election-style duplicate checks in their own contracts.

## Recommendation

Add duplicate VoteId validation in the `AssertValidVoteInput` method for delegated voting scenarios:

```csharp
if (!votingItem.IsLockToken)
{
    Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
    Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
    Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
    // Add duplicate check
    Assert(State.VotingRecords[input.VoteId] == null, "Vote Id already exists.");
}
```

This follows the same pattern used by the Election contract to prevent duplicate votes.

## Proof of Concept

```csharp
[Fact]
public async Task VoteId_Reuse_Inflates_Vote_Count()
{
    // Setup: Create delegated voting item
    var sponsor = Accounts[0].Address;
    var alice = Accounts[1].Address;
    var bob = Accounts[2].Address;
    
    var votingItemId = await RegisterDelegatedVotingItem(sponsor);
    var duplicateVoteId = HashHelper.ComputeFrom("duplicate");
    
    // Step 1: Sponsor votes for Alice with amount 100
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = duplicateVoteId,
        Voter = alice,
        Amount = 100,
        Option = "OptionA"
    });
    
    var resultAfterFirst = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    resultAfterFirst.Results["OptionA"].ShouldBe(100);
    resultAfterFirst.VotesAmount.ShouldBe(100);
    
    // Step 2: Sponsor votes for Bob with SAME VoteId, amount 200
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = duplicateVoteId,
        Voter = bob,
        Amount = 200,
        Option = "OptionA"
    });
    
    var resultAfterSecond = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    // BUG: Vote count doubled even though same VoteId was reused
    resultAfterSecond.Results["OptionA"].ShouldBe(300); // 100 + 200
    resultAfterSecond.VotesAmount.ShouldBe(300);
    
    // Step 3: Withdraw VoteId
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput
    {
        VoteId = duplicateVoteId
    });
    
    var resultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    // BUG: Only Bob's 200 was subtracted, Alice's 100 phantom votes remain
    resultAfterWithdraw.Results["OptionA"].ShouldBe(100); // Should be 0
    resultAfterWithdraw.VotesAmount.ShouldBe(100);
}
```

## Notes

The vulnerability specifically affects delegated voting scenarios where sponsors provide their own VoteIds. Regular voting (`IsLockToken=true`) auto-generates VoteIds using transaction context, preventing collisions. The Election contract protects itself by checking `State.LockTimeMap[voteId] == 0` before voting, but this protection is not built into the base Vote contract, leaving custom integrators vulnerable unless they implement their own duplicate checks.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L197-200)
```csharp
        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```
