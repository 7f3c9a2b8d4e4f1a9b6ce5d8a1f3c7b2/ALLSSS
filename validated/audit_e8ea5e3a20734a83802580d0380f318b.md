# Audit Report

## Title
Hash Collision in AssembledNftsMap Due to Unseparated String Concatenation in Token Hash Calculation

## Summary
The `CalculateTokenHash` function concatenates NFT symbol and tokenId without a separator, allowing different (symbol, tokenId) pairs to produce identical hash values. This causes hash collisions in `AssembledNftsMap`, where assembled NFT data from one NFT can overwrite another's, leading to permanent loss of assembled assets when users disassemble their NFTs.

## Finding Description

The vulnerability originates in the `CalculateTokenHash` function which performs direct string concatenation without any separator before hashing. [1](#0-0) 

NFT protocol symbols follow a specific format where a 2-letter prefix is combined with a numeric portion. The 2-letter prefix requirement is enforced during NFT type addition. [2](#0-1) 

The symbol is generated by concatenating the short name with a random number. [3](#0-2) 

The minimum number length is defined as 9 digits. [4](#0-3) 

The number length can grow dynamically as more protocols are created, transitioning from 9 digits to 10+ digits. [5](#0-4) 

**Collision Example:**
- NFT1: symbol="AR123456789" (2-letter + 9-digit), tokenId=10 → concatenates to "AR12345678910"
- NFT2: symbol="AR1234567891" (2-letter + 10-digit), tokenId=0 → concatenates to "AR12345678910"

Both produce identical strings and thus identical hashes.

The `AssembledNftsMap` state variable uses these token hashes as keys to store assembled NFT data. [6](#0-5) 

During the assembly process, the map entry is written using the calculated token hash. [7](#0-6) 

During disassembly, the contract reads from and removes the entry from `AssembledNftsMap`. [8](#0-7) 

When a collision occurs:
1. User A assembles NFT1, storing valuable assembled NFTs at hash H
2. User B (or attacker) assembles NFT2 with the same hash H, **overwriting** User A's data in the map
3. User A attempts to disassemble NFT1, but retrieves User B's assembled data instead of their own
4. User A permanently **loses** their original assembled NFTs

Minters can specify custom tokenIds when minting. If tokenId is provided as 0, the system auto-generates it; otherwise, the provided custom value is used. [9](#0-8) 

The tokenId field is explicitly defined in the MintInput message structure. [10](#0-9) 

Uniqueness validation only checks if a tokenId already exists for that specific symbol, not across different symbols. [11](#0-10) 

## Impact Explanation

**Direct Asset Loss:** Users assembling NFTs with valuable components (rare NFTs or fungible tokens) will permanently lose these assets if a hash collision overwrites their `AssembledNftsMap` entry. When they disassemble, they receive the wrong assets or nothing at all (if the other party already disassembled).

**Affected Parties:** All users who assemble NFTs are at risk. As the protocol scales with more NFT protocols being created and the number length growing from 9 to 10+ digits, collision opportunities increase.

**Severity Justification:** HIGH severity due to:
- Permanent, unrecoverable asset loss with no on-chain recovery mechanism
- No collision detection or prevention mechanism exists
- Impact directly affects core NFT assembly functionality
- The assembled NFTs can contain high-value assets (rare NFTs, fungible tokens)
- Vulnerability becomes more likely as protocol adoption grows

## Likelihood Explanation

**Natural Collision Probability:** Given that symbols start with 2-letter prefixes and 9-digit numbers, but the number length can grow to 10+ digits as more protocols are created, natural collisions become possible. The collision example demonstrates this: a 9-digit symbol with tokenId=10 collides with a 10-digit symbol with tokenId=0.

**Attacker Capabilities:** An attacker can:
1. Monitor on-chain for assembled NFTs via blockchain events
2. Wait for or anticipate when number lengths transition (e.g., from 9 to 10 digits)
3. Create new protocols during transition periods
4. Specify custom tokenIds to craft collisions
5. Assemble with minimal value to overwrite victim's valuable assembled data

**Attack Complexity:** For targeted attacks against a specific victim, the attacker would need to repeatedly create protocols until obtaining a symbol that collides with the target - requiring approximately 10^9 attempts on average, making this economically impractical. However, opportunistic attacks exploiting natural collisions during number length transitions are feasible and require significantly fewer resources.

**Likelihood Assessment:** MEDIUM - While targeted attacks against specific victims are impractical due to high costs, natural collisions become increasingly likely as the system scales and number lengths grow. Opportunistic attackers can monitor for high-value assembled NFTs and exploit these natural collisions, making exploitation inevitable as protocol adoption increases.

## Recommendation

Modify the `CalculateTokenHash` function to include a separator between symbol and tokenId to prevent ambiguous concatenations:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
}
```

Alternatively, use a structured hashing approach:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

**Migration Consideration:** This change will alter all token hashes. Implement carefully with appropriate migration logic to preserve existing NFT mappings in `BalanceMap`, `NftInfoMap`, `AllowanceMap`, `AssembledNftsMap`, and `AssembledFtsMap`.

## Proof of Concept

```csharp
[Fact]
public async Task HashCollisionInAssembledNftsMap_Test()
{
    // Setup: Create two NFT protocols with colliding hashes
    // Protocol 1: "AR123456789" (9-digit number)
    // Protocol 2: "AR1234567891" (10-digit number, created later when number length grows)
    
    // Simulate User A assembling NFT1 with symbol "AR123456789", tokenId=10
    var symbol1 = "AR123456789";
    var tokenId1 = 10L;
    var hash1 = CalculateTokenHash(symbol1, tokenId1);
    
    // Simulate User B assembling NFT2 with symbol "AR1234567891", tokenId=0
    var symbol2 = "AR1234567891";
    var tokenId2 = 0L;
    var hash2 = CalculateTokenHash(symbol2, tokenId2);
    
    // Verify collision: both hashes should be identical
    hash1.ShouldBe(hash2); // This assertion will pass, proving the collision
    
    // The concatenated strings are identical:
    // "AR123456789" + "10" = "AR12345678910"
    // "AR1234567891" + "0" = "AR12345678910"
    
    // When both NFTs are assembled, they use the same key in AssembledNftsMap,
    // causing the second assembly to overwrite the first user's assembled data,
    // resulting in permanent asset loss when the first user disassembles.
}

private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}{tokenId}");
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-176)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L202-209)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-392)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L136-136)
```csharp
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-36)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-32)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
```

**File:** protobuf/nft_contract.proto (L209-217)
```text
message MintInput {
    string symbol = 1;
    aelf.Address owner = 2;
    string uri = 3;
    string alias = 4;
    Metadata metadata = 5;
    int64 quantity = 6;
    int64 token_id = 7;
}
```
