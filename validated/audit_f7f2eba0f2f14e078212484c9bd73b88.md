# Audit Report

## Title
Quit Candidates Can Bypass Election Restrictions and Become Consensus Validators via InitialMiners List

## Summary
The Election Contract's `GetVictories()` method fails to validate that pubkeys in the `InitialMiners` list are legitimate current candidates before selecting them as backup consensus validators. This allows a candidate who has quit the election to be moved into `InitialMiners` via `ReplaceCandidatePubkey()` and subsequently selected as a validator, bypassing the election process entirely.

## Finding Description

The vulnerability stems from insufficient validation in the `IsCurrentCandidateOrInitialMiner()` authorization check and the `GetVictories()` backup selection logic.

**Root Cause 1: Overly Permissive Authorization Check**

The `IsCurrentCandidateOrInitialMiner()` function grants full privileges to any pubkey in `InitialMiners`, regardless of whether they are current candidates or have quit the election: [1](#0-0) 

This check is used to authorize sensitive operations like `SetCandidateAdmin`: [2](#0-1) 

And `ReplaceCandidatePubkey`: [3](#0-2) 

**Root Cause 2: QuitElection Doesn't Remove from InitialMiners**

When a candidate quits, their `IsCurrentCandidate` flag is set to false and they are removed from the `Candidates` list: [4](#0-3) [5](#0-4) 

However, there is no logic to remove the pubkey from `InitialMiners` if present, allowing quit candidates to retain their position if they were previously added via replacement.

**Root Cause 3: ReplaceCandidatePubkey Allows Arbitrary Additions to InitialMiners**

The `ReplaceCandidatePubkey()` method allows an initial miner's admin to replace their pubkey with any pubkey, including quit candidates: [6](#0-5) 

There is no validation that the new pubkey is a current candidate or legitimately entitled to be in `InitialMiners`.

**Root Cause 4: GetVictories Lacks Validation for InitialMiners Backups**

The critical flaw is in `GetVictories()`, which uses `InitialMiners` as backups when there are insufficient valid candidates, but performs NO validation on these pubkeys: [7](#0-6) 

The function does not check:
- Whether the pubkey has `IsCurrentCandidate = true`
- Whether the pubkey is in the `Candidates` list
- Whether the pubkey is banned (though `ReplaceCandidatePubkey` only bans the OLD pubkey, not the new one)

**Attack Path:**

1. Attacker announces election with pubkey A (becomes a current candidate, locks 100k ELF)
2. Attacker calls `QuitElection()` with pubkey A:
   - `IsCurrentCandidate` set to false
   - A removed from `Candidates` list  
   - Locked tokens returned
3. An initial miner B's admin (compromised or cooperating) calls `ReplaceCandidatePubkey(B -> A)`:
   - B removed from `InitialMiners`, A added to `InitialMiners`
   - B is banned, A is NOT banned
4. When consensus contract calls `GetVictories()` during term transition with insufficient valid candidates:
   - A is added to backups from `InitialMiners`
   - A is selected as a consensus validator
5. The consensus contract uses this result to generate the next round: [8](#0-7) [9](#0-8) 

**Why Existing Protections Fail:**

The prevention of initial miners announcing election only works one direction: [10](#0-9) 

This prevents initial miners from becoming candidates, but doesn't prevent quit candidates from entering `InitialMiners` through replacement.

## Impact Explanation

**Critical Consensus Integrity Violation:**
- A quit candidate who bypassed the election becomes a consensus validator
- They can produce blocks, participate in consensus decisions, and earn mining rewards
- This fundamentally violates the election-based validator selection mechanism
- Token holders' votes are circumvented for validator selection

**High Authorization Bypass:**
- Quit candidates in `InitialMiners` retain admin management capabilities through `IsCurrentCandidateOrInitialMiner()` 
- They can call `SetCandidateAdmin` and enable further `ReplaceCandidatePubkey` operations
- This creates a persistent, unaccountable validator position outside the election system
- The position can be perpetually maintained through cyclic replacements

**Protocol Governance Impact:**
- `InitialMiners` is designed for trusted bootstrap nodes, not arbitrary participants
- Allowing quit candidates to occupy these slots undermines the bootstrap security model
- Legitimate candidates are excluded from miner selection
- The attacker earns block production rewards without community approval

## Likelihood Explanation

**Attacker Capabilities Required:**
1. Ability to announce and quit election (publicly accessible - trivial)
2. Cooperation from or compromise of an initial miner's admin to authorize `ReplaceCandidatePubkey` (moderate-to-high barrier)
3. Period when valid candidates are insufficient (naturally occurring condition)

**Feasibility Assessment: Moderate-to-High**

The main barrier is obtaining initial miner admin cooperation/compromise, which could occur through:
- Key rotation scenarios where security procedures are lax
- Social engineering or economic incentives (bribery)
- Exploitation of governance processes if replacements can be proposed
- Insider threats or compromised administrator accounts

The insufficient candidates condition occurs naturally during:
- Network launch and early growth phases
- Low participation periods
- Following mass candidate withdrawal events
- Market downturns affecting validator economics

**Economic Rationality:**
- Benefits: Block production rewards, consensus influence, validator reputation
- Costs: 100k ELF deposit (recoverable after quit), cost of compromising initial miner admin
- Attack is profitable if mining rewards over time exceed compromise costs

**Detection Difficulty:**
- Appears as legitimate key rotation in `ReplaceCandidatePubkey` transactions  
- No obvious on-chain indicators distinguish malicious from legitimate replacements
- Historical election participation is preserved but not validated during backup selection

## Recommendation

**Fix 1: Add Candidate Status Validation in GetVictories**

Modify `GetVictories()` to validate that `InitialMiners` pubkeys are current candidates before adding them as backups:

```csharp
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k))
            .Where(k => State.CandidateInformationMap[k] != null && 
                       State.CandidateInformationMap[k].IsCurrentCandidate)
            .Where(k => !State.BannedPubkeyMap[k]));
```

**Fix 2: Validate New Pubkey in ReplaceCandidatePubkey**

Add validation that the new pubkey being added to `InitialMiners` is a current candidate:

```csharp
if (initialMiners.Value.Contains(oldPubkeyBytes))
{
    var newCandidateInfo = State.CandidateInformationMap[input.NewPubkey];
    Assert(newCandidateInfo != null && newCandidateInfo.IsCurrentCandidate,
        "New pubkey must be a current candidate to join InitialMiners.");
    initialMiners.Value.Remove(oldPubkeyBytes);
    initialMiners.Value.Add(newPubkeyBytes);
    State.InitialMiners.Value = initialMiners;
}
```

**Fix 3: Remove from InitialMiners in QuitElection**

Ensure quit candidates are removed from `InitialMiners`:

```csharp
// After removing from Candidates list
var initialMiners = State.InitialMiners.Value;
if (initialMiners != null && initialMiners.Value.Contains(publicKeyByteString))
{
    initialMiners.Value.Remove(publicKeyByteString);
    State.InitialMiners.Value = initialMiners;
}
```

## Proof of Concept

Due to the complexity of setting up a full consensus test environment, the POC demonstrates the core vulnerability by showing that `GetVictories()` returns quit candidates from `InitialMiners`:

```csharp
[Fact]
public async Task QuitCandidate_CanBecomeValidator_ViaInitialMiners()
{
    // Step 1: Attacker announces election with pubkey A
    var attackerKeyPair = SampleKeyPairs.KeyPairs[10];
    var attackerPubkey = attackerKeyPair.PublicKey.ToHex();
    await AnnounceElectionAsync(attackerKeyPair);
    
    // Verify A is a current candidate
    var candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = attackerPubkey });
    candidateInfo.IsCurrentCandidate.ShouldBeTrue();
    
    // Step 2: Attacker quits election  
    await ElectionContractStub.QuitElection.SendAsync(new StringValue { Value = attackerPubkey });
    
    // Verify A is no longer a current candidate
    candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = attackerPubkey });
    candidateInfo.IsCurrentCandidate.ShouldBeFalse();
    
    // Step 3: Simulate initial miner B replacing with quit candidate A
    // (In production, this requires initial miner admin cooperation)
    var initialMinerPubkey = InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex();
    var initialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    initialMiners.Value.ShouldContain(ByteStringHelper.FromHexString(initialMinerPubkey));
    
    // Call ReplaceCandidatePubkey(B -> A)
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = initialMinerPubkey,
        NewPubkey = attackerPubkey
    });
    
    // Verify A is now in InitialMiners but not a current candidate
    initialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    initialMiners.Value.ShouldContain(ByteStringHelper.FromHexString(attackerPubkey));
    candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = attackerPubkey });
    candidateInfo.IsCurrentCandidate.ShouldBeFalse(); // Still false!
    
    // Step 4: When GetVictories is called with insufficient candidates,
    // the quit candidate A will be selected as a backup validator
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // VULNERABILITY: Quit candidate is selected as validator!
    victories.Value.Select(v => v.ToHex()).ShouldContain(attackerPubkey);
}
```

The test demonstrates that a quit candidate (with `IsCurrentCandidate = false`) who enters `InitialMiners` via `ReplaceCandidatePubkey` will be selected by `GetVictories()` as a consensus validator, bypassing the election process.

## Notes

This vulnerability represents a significant breach of the election-based consensus mechanism. The core issue is that `InitialMiners` was designed for trusted bootstrap nodes at genesis, but the pubkey replacement mechanism combined with insufficient validation in `GetVictories()` allows it to be abused by quit candidates. The fix requires both preventing quit candidates from entering `InitialMiners` and validating `InitialMiners` entries before using them as backup validators.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L21-22)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-254)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L298-298)
```csharp
        State.Candidates.Value.Value.Remove(publicKeyByteString);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-176)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L67-69)
```csharp
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-274)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
```
