# Audit Report

## Title
Bootstrap Validation Bypass Allows Any Authorized Miner to Skip Consensus Checks During Early Blockchain Phase

## Summary

The `ValidateBeforeExecution()` function in the AEDPoS consensus contract contains a bootstrap bypass mechanism that fails to verify the current block sender's identity. During the first 24 blocks, any authorized miner can bypass critical consensus validations (time slots, continuous block limits, LIB checks, round transitions) as long as only one miner produced blocks historically. This breaks fundamental consensus invariants during the critical bootstrap period.

## Finding Description

The vulnerability exists in the bootstrap bypass logic designed to facilitate initial blockchain startup. [1](#0-0) 

The bypass activates when three conditions are met:

1. Multiple miners exist in the current round configuration (not a single-node scenario)
2. Current blockchain height is less than 24 blocks [2](#0-1) 
3. All historical rounds had exactly one block producer with the same public key

**Critical Flaw**: The code iterates through historical rounds to identify `producedMiner` (the single historical producer), but **never verifies that `extraData.SenderPubkey` (the current block's sender) matches this historical producer**. When all conditions pass, the function returns success immediately at line 43, completely bypassing all subsequent validation providers.

The bypassed validations include:

- **TimeSlotValidationProvider**: Ensures miners produce blocks only within their assigned time slots [3](#0-2) 

- **ContinuousBlocksValidationProvider**: Prevents miners from producing excessive consecutive blocks [4](#0-3) 

- **LibInformationValidationProvider**, **UpdateValueValidationProvider**, **NextRoundMiningOrderValidationProvider**, and **RoundTerminateValidationProvider** for specific consensus behaviors [5](#0-4) 

This validation is invoked through the ACS4 standard's public method: [6](#0-5) 

## Impact Explanation

**Severity: HIGH** - This vulnerability breaks fundamental consensus integrity during the bootstrap phase:

1. **Time Slot Violation**: Any authorized miner coming online during blocks 0-23 can produce blocks outside their designated time slots, potentially enabling rapid block production or disrupting the intended schedule.

2. **Block Production Monopolization**: Miners can exceed continuous block limits, dominating block production and potentially excluding other miners from participating.

3. **Round Transition Manipulation**: Attackers can trigger `NextRound` or `NextTerm` transitions at incorrect times or with invalid parameters, destabilizing consensus state.

4. **LIB Integrity Compromise**: For `UpdateValue` behavior, blocks can be submitted with incorrect implied irreversible block heights without validation.

During typical blockchain bootstrap with 17 configured miners [7](#0-6) , if only the genesis node operator is initially online, each subsequent miner joining during the 24-block window can exploit this bypass to violate consensus rules.

## Likelihood Explanation

**Likelihood: HIGH** - This scenario occurs naturally during blockchain bootstrap:

**Attacker Capabilities**: Must be an authorized miner (in genesis configuration or added through governance), which is a realistic assumption for nodes joining a new blockchain.

**Attack Timing**: The 24-block window (blocks 0-23) provides substantial opportunity for multiple miners to join and exploit the bypass during normal network startup.

**Realistic Scenario**:
1. Genesis configuration includes multiple miners (standard practice)
2. Genesis node operator starts producing blocks alone
3. Other authorized miners gradually come online during blocks 0-23
4. Each joining miner can bypass validation without detection

**Complexity**: LOW - No special privileges beyond authorized miner status; no complex transaction sequencing required; exploitation occurs as a natural consequence of the flawed bootstrap logic.

## Recommendation

Add a sender identity check in the bootstrap bypass logic:

```csharp
if (baseRound.RealTimeMinersInformation.Count != 1 &&
    Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
{
    string producedMiner = null;
    var result = true;
    for (var i = baseRound.RoundNumber; i > 0; i--)
    {
        var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
            .Where(m => m.ActualMiningTimes.Any()).ToList();
        if (producedMiners.Count != 1)
        {
            result = false;
            break;
        }

        if (producedMiner == null)
            producedMiner = producedMiners.Single().Pubkey;
        else if (producedMiner != producedMiners.Single().Pubkey) result = false;
    }

    // CRITICAL FIX: Verify current sender is the historical producer
    if (result && extraData.SenderPubkey.ToHex() == producedMiner) 
        return new ValidationResult { Success = true };
}
```

This ensures the bootstrap bypass only applies to the original single producer, not to any authorized miner who comes online later.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize a blockchain with multiple miners configured (e.g., 17 miners)
2. Have Miner A produce blocks 1-10 alone
3. At block 11 (still within 24-block window), have Miner B attempt to produce a block outside their time slot
4. Verify that validation succeeds (when it should fail due to time slot violation)
5. Confirm that Miner B's block is accepted despite violating consensus rules

The test would show that any authorized miner (not just the historical producer) can bypass validation during the bootstrap period, confirming the security flaw.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L23-44)
```csharp
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L8-35)
```csharp
public class TimeSlotValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L6-28)
```csharp
public class ContinuousBlocksValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```
