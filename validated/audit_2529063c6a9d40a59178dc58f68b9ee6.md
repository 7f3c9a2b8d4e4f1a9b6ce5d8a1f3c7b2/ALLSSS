# Audit Report

## Title
Empty Pubkey Candidate Registration Causes Consensus Failure During Term Transition

## Summary
The Election Contract's `AnnounceElectionFor` method lacks validation to prevent registration of empty pubkey strings. When an empty pubkey candidate receives sufficient votes and is elected as a miner, the subsequent term transition fails with an `IndexOutOfRangeException` in `GenerateFirstRoundOfNewTerm`, halting blockchain consensus indefinitely.

## Finding Description

**Root Cause:**

The Election Contract allows registration of candidates with empty pubkey strings. In `AnnounceElectionFor`, the input pubkey is converted to a byte array without length validation: [1](#0-0) 

The `ByteArrayHelper.HexStringToByteArray("")` returns an empty byte array `byte[0]`, which is then passed to the internal `AnnounceElection` method: [2](#0-1) 

This creates an empty `ByteString` that gets added to the candidates list: [3](#0-2) 

Users can vote for this empty candidate because the validation only checks if the candidate exists and is current: [4](#0-3) [5](#0-4) 

**Attack Path:**

During term transitions, the Consensus Contract retrieves the new miner list from the Election Contract: [6](#0-5) 

The Election Contract returns top-voted candidates including the empty pubkey if it has sufficient votes: [7](#0-6) 

The Consensus Contract then calls `GenerateFirstRoundOfNewTerm` which attempts to sort miners by accessing the first byte of each pubkey: [8](#0-7) [9](#0-8) 

When `miner` is an empty `ByteString` (length = 0), the indexing operation `miner[0]` throws an `IndexOutOfRangeException`, crashing the term generation process.

**Why Existing Protections Fail:**

The candidate validation checks multiple conditions but omits pubkey length validation: [10](#0-9) 

The `GetValidCandidates` method only filters by vote amounts: [11](#0-10) 

## Impact Explanation

**Direct Harm:**
- Complete denial of service of the blockchain's consensus mechanism
- The blockchain cannot transition to new terms, preventing miner list updates
- Block production may halt entirely if all current miners lose authorization
- All consensus-dependent operations (block validation, finalization, cross-chain communication) become impossible

**Protocol Damage:**
- Indefinite blockchain freeze requiring emergency intervention or hard fork
- Loss of network liveness and availability for all users
- Potential economic losses from halted transactions and frozen funds
- Severe reputational damage to the blockchain network

**Affected Parties:**
- All network participants (users, dApps, validators)
- The entire AElf mainchain or affected sidechain

This is **HIGH severity** because it completely disables the consensus mechanism, affecting the entire blockchain network and requiring emergency measures to resolve.

## Likelihood Explanation

**Attacker Capabilities Required:**
1. Lock 100,000 ELF tokens as candidate registration deposit
2. Acquire or coordinate sufficient voting power to place the empty pubkey in the top N miners (typically requires millions of locked ELF tokens depending on network participation)

**Attack Complexity:**
- **Low technical complexity**: Single contract call to register empty pubkey, standard voting operations
- **High economic cost**: Requires substantial capital (100K ELF deposit + voting power)
- **Medium coordination**: Can be executed by single wealthy actor or requires coordinating multiple voters

**Feasibility Conditions:**
- Attacker must either control significant voting power directly or manipulate voters
- Voting period allows accumulation of votes over time
- Network must not detect and mitigate the empty candidate before term transition

**Probability Assessment:**
**MEDIUM likelihood** because the entry point is unrestricted (public method) and while the economic barrier is high, it remains feasible for well-funded attackers. The one-time cost can cause persistent DoS until fixed, and there is no technical complexity barrier.

## Recommendation

Add pubkey length validation in the `AnnounceElectionFor` and `AnnounceElection` methods:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    Assert(!string.IsNullOrEmpty(pubkey), "Pubkey cannot be empty.");
    
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    Assert(pubkeyBytes.Length > 0, "Invalid pubkey length.");
    
    var address = Address.FromPublicKey(pubkeyBytes);
    AnnounceElection(pubkeyBytes);
    // ... rest of the method
}

private void AnnounceElection(byte[] pubkeyBytes)
{
    Assert(pubkeyBytes != null && pubkeyBytes.Length > 0, "Invalid pubkey.");
    
    var pubkey = pubkeyBytes.ToHex();
    var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);
    // ... rest of the method
}
```

Additionally, add defensive validation in `GenerateFirstRoundOfNewTerm` to reject empty pubkeys:

```csharp
internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
    Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
{
    var sortedMiners =
        (from obj in Pubkeys
                .Where(miner => miner.Length > 0) // Filter out empty pubkeys
                .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
            orderby obj.Value descending
            select obj.Key).ToList();
    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPubkey_Causes_Consensus_Failure()
{
    // Step 1: Register empty pubkey candidate
    var sponsorKeyPair = ValidationDataCenterKeyPairs.First();
    var electionStub = GetElectionContractTester(sponsorKeyPair);
    
    await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = "", // Empty pubkey
        Admin = Address.FromPublicKey(sponsorKeyPair.PublicKey)
    });
    
    // Step 2: Vote for empty candidate to get it into top N
    var voterKeyPair = ValidationDataCenterKeyPairs[1];
    var voteAmount = 1000000_00000000; // Large amount to rank high
    
    await VoteToCandidateAsync(voterKeyPair, "", voteAmount, 120);
    
    // Step 3: Attempt term transition - this should throw IndexOutOfRangeException
    var consensusStub = GetConsensusContractTester(InitialCoreDataCenterKeyPairs.First());
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    var miners = new MinerList { Pubkeys = { victories.Value } };
    
    // This will throw IndexOutOfRangeException when accessing miner[0] on empty ByteString
    Should.Throw<IndexOutOfRangeException>(() => 
    {
        miners.GenerateFirstRoundOfNewTerm(
            4000,
            BlockTimeProvider.GetBlockTime(),
            1,
            1
        );
    });
}
```

## Notes

This vulnerability demonstrates a critical input validation failure that cascades through multiple contract interactions. The empty pubkey bypasses all validation checkpoints because:

1. `ByteArrayHelper.HexStringToByteArray("")` silently returns an empty array rather than throwing
2. `Address.FromPublicKey(byte[0])` succeeds by hashing the empty array
3. Candidate registration validates existence and status but not pubkey structure
4. Vote validation assumes valid candidate structure after existence check
5. Consensus contract assumes all miners have valid pubkeys with at least one byte

The fix requires defense-in-depth: validate at the entry point (registration), during state updates (voting), and at the consumption point (term transition) to prevent similar structural assumptions from causing critical failures.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-126)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L313-318)
```csharp
    private void AssertValidCandidateInformation(CandidateInformation candidateInformation)
    {
        Assert(candidateInformation != null, "Candidate not found.");
        // ReSharper disable once PossibleNullReferenceException
        Assert(candidateInformation.IsCurrentCandidate, "Candidate quited election.");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-425)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-19)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```
