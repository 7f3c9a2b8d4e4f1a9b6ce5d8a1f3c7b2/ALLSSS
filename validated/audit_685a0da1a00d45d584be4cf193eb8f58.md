# Audit Report

## Title
State Bloat DoS Through Unlimited TokenHolder Scheme Creation

## Summary
The `CreateScheme()` function in TokenHolderContract allows unlimited profit scheme creation without validation, causing permanent state bloat in the Profit contract. Each call creates a new scheme with a unique ID, but TokenHolder only tracks one scheme per address, orphaning all subsequent schemes. With no deletion mechanism and a 10 ELF cost per scheme, a well-funded attacker can create thousands of schemes, imposing permanent storage burden on all validators.

## Finding Description

The vulnerability exists in TokenHolder's `CreateScheme()` method, which lacks validation to prevent repeated calls from the same address. [1](#0-0) 

When called, it creates a new scheme in the Profit contract by sending a CreateSchemeInput with the sender as manager. [2](#0-1) 

TokenHolder then stores the scheme configuration locally using `Context.Sender` as the key in a single-value mapping, meaning it only maintains ONE scheme reference per address. [3](#0-2) [4](#0-3) 

In the Profit contract, each call to `CreateScheme()` generates a unique scheme ID based on the manager's current scheme count. [5](#0-4) 

The scheme ID increments with each call because it uses the count of existing schemes for that manager, ensuring each subsequent call generates a different ID. [6](#0-5) 

Each scheme is permanently stored in `State.SchemeInfos[schemeId]`, and the scheme ID is added to the manager's list in `State.ManagingSchemeIds[scheme.Manager]`. [7](#0-6) [8](#0-7) 

Critically, the Profit contract's interface contains no method to delete schemes - only `RemoveSubScheme` exists for removing sub-schemes from parent schemes, not for deleting top-level schemes. [9](#0-8) 

When TokenHolder needs to retrieve a scheme, it queries the Profit contract for the first scheme ID in the manager's list using `.FirstOrDefault()`. [10](#0-9) 

**Attack Sequence:**
1. Attacker calls `CreateScheme()` first time → Creates scheme1 in Profit, stores locally in TokenHolder
2. Attacker calls `CreateScheme()` second time → Creates scheme2 in Profit, overwrites local TokenHolder state
3. Attacker repeats N times → Creates schemeN in Profit each time
4. Result: Only scheme1 is functionally used (via `.FirstOrDefault()`), but all N schemes exist permanently in Profit contract state

## Impact Explanation

**Permanent State Bloat:**
Each orphaned scheme consumes permanent storage in the Profit contract's state, including the full `Scheme` object with virtual address, manager, total shares, current period, sub-schemes list, delay distribution settings, cached total shares mapping, and received token symbols list. All validators must store and sync this data indefinitely.

**Quantified Impact:**
- Each scheme stores substantial data across multiple state mappings in ProfitContractState
- 1,000 orphaned schemes could consume megabytes of state storage
- 10,000 schemes would cost attacker 100,000 ELF but causes permanent validator storage burden
- No cleanup mechanism exists to remove orphaned schemes
- Affects query performance for all Profit contract interactions as the state grows

**Severity Assessment - Medium:**
The attack requires significant capital (10 ELF per scheme as confirmed in the method fee configuration). [11](#0-10) 

However, the impact is cumulative and permanent, degrading network performance over time if exploited at scale. While it doesn't directly steal funds or break consensus, the irreversible nature and network-wide impact justify Medium severity.

## Likelihood Explanation

**Reachability:** The `CreateScheme()` method is public and callable by any address without special permissions or existence checks.

**Attacker Capabilities:**
- Requires only an account with sufficient ELF balance
- No special privileges needed
- Simple repeated transaction submission

**Attack Complexity:**
- Trivial to execute: repeatedly call `CreateScheme()` with identical or varied parameters
- Fully automatable with a simple script
- No timing requirements or complex state manipulation

**Economic Feasibility:**
- Cost: 10 ELF per scheme creation
- Creating 1,000 schemes = 10,000 ELF
- Creating 10,000 schemes = 100,000 ELF
- While expensive, this is within reach of well-funded attackers
- The permanent network-wide burden may exceed attacker's costs

**Detection:** Repeated `CreateScheme` calls from the same address are visible on-chain but may not trigger immediate response if executed gradually over time.

## Recommendation

Add a check in `TokenHolderContract.CreateScheme()` to prevent creating multiple schemes for the same address:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation to prevent duplicate scheme creation
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this address.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

This simple check ensures that each address can only create one scheme, preventing state bloat in the Profit contract.

## Proof of Concept

```csharp
[Fact]
public async Task StateBlot_UnlimitedSchemeCreation_CreatesOrphanedSchemes()
{
    // Arrange: Setup TokenHolder contract and get initial scheme count
    var tokenHolderStub = GetTokenHolderContractStub(DefaultKeyPair);
    var profitStub = GetProfitContractStub(DefaultKeyPair);
    var userAddress = Address.FromPublicKey(DefaultKeyPair.PublicKey);
    
    // Act: Create multiple schemes from the same address
    const int schemeCount = 5;
    for (int i = 0; i < schemeCount; i++)
    {
        await tokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = 100
        });
    }
    
    // Assert: Verify multiple schemes exist in Profit contract
    var managingSchemeIds = await profitStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = userAddress });
    
    // Should have 5 schemes in Profit contract
    managingSchemeIds.SchemeIds.Count.ShouldBe(schemeCount);
    
    // But TokenHolder only references the first one
    var tokenHolderScheme = await tokenHolderStub.GetScheme.CallAsync(userAddress);
    tokenHolderScheme.ShouldNotBeNull();
    
    // Verify all 5 schemes exist and are accessible in Profit
    foreach (var schemeId in managingSchemeIds.SchemeIds)
    {
        var scheme = await profitStub.GetScheme.CallAsync(schemeId);
        scheme.ShouldNotBeNull();
        scheme.Manager.ShouldBe(userAddress);
    }
    
    // Demonstrates: 4 orphaned schemes remain permanently in Profit state
    // Only the first scheme (managingSchemeIds.SchemeIds[0]) is used by TokenHolder
    // The other 4 schemes consume permanent storage but serve no purpose
}
```

This test demonstrates that calling `CreateScheme()` multiple times creates orphaned schemes in the Profit contract that remain permanently in state, causing unbounded state bloat.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L60-71)
```csharp
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L9-15)
```csharp
    public MappedState<Hash, Scheme> SchemeInfos { get; set; }

    public MappedState<Address, DistributedProfitsInfo> DistributedProfitsMap { get; set; }

    public MappedState<Hash, Address, ProfitDetails> ProfitDetailsMap { get; set; }

    public MappedState<Address, CreatedSchemeIds> ManagingSchemeIds { get; set; }
```

**File:** protobuf/profit_contract.proto (L59-61)
```text
    // Remove sub scheme from a scheme.
    rpc RemoveSubScheme (RemoveSubSchemeInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
