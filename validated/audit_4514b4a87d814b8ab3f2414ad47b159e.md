# Audit Report

## Title
Referendum Organizations Can Become Permanently Locked Through Invalid Configuration Changes

## Summary
The Referendum contract's organization configuration change methods lack sufficient validation to prevent setting values that make future governance impossible. Organizations can become permanently locked through either malicious proposals or configuration errors, with no recovery mechanism available.

## Finding Description

The Referendum contract allows organizations to modify their configuration exclusively through self-executed proposals via `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList` methods. Both methods enforce that only the organization itself can execute these changes. [1](#0-0) [2](#0-1) 

The critical issue lies in the `Validate(Organization)` method which performs insufficient validation. [3](#0-2) 

**Three Locking Scenarios Exist:**

**1. Unreachable Whitelist Lock:** The validation only checks `ProposerWhiteList.Empty()` which verifies the count is not zero. [4](#0-3) [5](#0-4)  It does NOT validate whether addresses are reachable, valid, or controlled by anyone. An organization can set its whitelist to burn addresses, lost keys, or non-cooperative parties, making proposal creation impossible since only whitelisted addresses can create proposals. [6](#0-5) 

**2. Impossible Threshold Lock:** The validation checks `MinimalApprovalThreshold > 0` and `MinimalApprovalThreshold <= MinimalVoteThreshold` but imposes NO upper bounds on any threshold values. [7](#0-6)  An organization can set `MinimalVoteThreshold` or `MinimalApprovalThreshold` to `long.MaxValue` (9,223,372,036,854,775,807) or any value exceeding practical voting capacity, making it mathematically impossible to pass proposals. The threshold fields are defined as `int64` allowing this full range. [8](#0-7) 

**3. Zero-Tolerance Lock:** The validation allows `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` to be set to zero. [9](#0-8)  When checking release conditions, the code evaluates with strict greater-than comparisons. [10](#0-9)  With zero thresholds, even a single rejection or abstention vote blocks release, creating impossible coordination requirements.

## Impact Explanation

Once an organization is locked through invalid configuration:

1. **Complete Governance DoS:** The organization can never create, approve, or execute proposals again. If the whitelist contains only unreachable addresses, no proposals can be created. If thresholds are impossible to reach, no proposals can pass. If rejection/abstention thresholds are zero, proposals cannot be released.

2. **Permanent Fund Lock:** Any tokens or assets held in the organization's virtual address become permanently unrecoverable since only successful proposals can execute transfers. [11](#0-10) 

3. **No Recovery Mechanism:** The organization address is deterministically derived from the creation input. [12](#0-11)  There is no admin override, no fallback governance, and no way to recover control once locked.

4. **External Dependency Failure:** Any contracts or systems relying on this organization's governance decisions become permanently blocked.

The severity is HIGH because this results in complete and permanent loss of governance functionality with irreversible fund lock and no recovery path.

## Likelihood Explanation

**Attack Vector:**
A malicious proposer (legitimate whitelist member) creates a proposal to change organization configuration with locking values, gathers enough votes to pass it within current thresholds, and releases it. The attack follows the normal proposal workflow using public methods. [13](#0-12) [14](#0-13) 

**Feasibility:**
- Entry point: Standard `CreateProposal` method (public, intended functionality)
- Required privileges: Proposer whitelist membership (legitimate role)
- Attack complexity: LOW - follows normal governance flow
- Can occur both maliciously AND accidentally (typos, copy-paste errors)

**No Safeguards:**
The contract provides no warnings about potentially locking configurations. Organizations must manually verify configuration changes before approval, but there are no automated checks or bounds to prevent dangerous values.

The likelihood is HIGH due to low attack complexity and high probability of accidental occurrence.

## Recommendation

Add comprehensive validation bounds in the `Validate(Organization)` method:

1. **For Whitelist Validation:** Consider adding a maximum count check or requiring at least one known valid address. Document that whitelist addresses must be controlled and reachable.

2. **For Threshold Validation:** Add reasonable upper bounds:
   - `MinimalVoteThreshold` should have a maximum cap (e.g., based on total token supply)
   - `MinimalApprovalThreshold` should have a maximum cap
   - Add checks to ensure thresholds are practically achievable

3. **For Rejection/Abstention Thresholds:** Either:
   - Require minimum non-zero values (e.g., `> 0` instead of `>= 0`), OR
   - Change release logic to use `>=` instead of `>` to allow zero to mean "unlimited", OR
   - Document that zero means "any single vote blocks release" with explicit warnings

4. **Add Safety Mechanisms:**
   - Emit warning events when configuration changes approach dangerous values
   - Consider a time-lock or two-step process for critical configuration changes
   - Add emergency recovery mechanism through Parliament or another trusted governance layer

## Proof of Concept

```csharp
[Fact]
public async Task Organization_Permanent_Lock_Through_Zero_Rejection_Threshold_Test()
{
    // Create organization with valid initial thresholds
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 5000,
        minimalVoteThreshold: 5000,
        maximalAbstentionThreshold: 10000,
        maximalRejectionThreshold: 10000,
        proposerWhiteList: new[] { DefaultSender }
    );
    
    // Create a malicious proposal to set MaximalRejectionThreshold to 0
    var lockingThreshold = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 5000,
        MinimalVoteThreshold = 5000,
        MaximalAbstentionThreshold = 10000,
        MaximalRejectionThreshold = 0  // This will lock the organization
    };
    
    var lockProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        lockingThreshold,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress
    );
    
    // Approve and release the locking proposal
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, lockProposalId);
    await ApproveAsync(Accounts[3].KeyPair, lockProposalId);
    var releaseResult = await ReferendumContractStub.Release.SendAsync(lockProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify organization is now locked - try to create and pass a new proposal
    var testProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        new Empty(),
        "SomeMethod",
        organizationAddress,
        TokenContractAddress
    );
    
    // Get enough approvals
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 10000, testProposalId);
    await ApproveAsync(Accounts[3].KeyPair, testProposalId);
    
    // Even one rejection now blocks the proposal due to zero threshold
    await ApproveAllowanceAsync(Accounts[4].KeyPair, 1, testProposalId);
    await RejectAsync(Accounts[4].KeyPair, testProposalId);
    
    // Verify proposal cannot be released
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(testProposalId);
    proposal.ToBeReleased.ShouldBeFalse();  // Organization is permanently locked
    
    var releaseAttempt = await ReferendumContractStub.Release.SendWithExceptionAsync(testProposalId);
    releaseAttempt.TransactionResult.Error.ShouldContain("Not approved");
}
```

## Notes

This vulnerability affects all three AElf governance contracts (Parliament, Association, and Referendum) as they share similar validation logic through the ACS3 standard. The issue is particularly severe because:

1. **Governance-Critical**: These contracts control protocol parameters, treasury funds, and system upgrades
2. **Irreversible**: Once locked, there is no recovery mechanism
3. **Silent Failure**: The validation passes but creates unusable configurations
4. **Cross-Contract Impact**: Many protocol components depend on governance organizations

The fix should be coordinated across all three governance contract implementations to ensure consistent validation standards.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L126-127)
```csharp
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L141-142)
```csharp
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L20-26)
```csharp
        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L207-218)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress = Context.ConvertVirtualAddressToContractAddressWithContractHashName(
            CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));

        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** protobuf/acs3.proto (L128-137)
```text
message ProposalReleaseThreshold {
    // The value for the minimum approval threshold.
    int64 minimal_approval_threshold = 1;
    // The value for the maximal rejection threshold.
    int64 maximal_rejection_threshold = 2;
    // The value for the maximal abstention threshold.
    int64 maximal_abstention_threshold = 3;
    // The value for the minimal vote threshold.
    int64 minimal_vote_threshold = 4;
}
```
