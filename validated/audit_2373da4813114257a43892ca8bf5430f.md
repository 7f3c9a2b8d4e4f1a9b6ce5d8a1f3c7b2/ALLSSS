# Audit Report

## Title
Cross-Chain NFT Protocol Creation Bypasses Metadata Validation Allowing Malicious ExternalInfo Injection

## Summary
The `CrossChainCreate()` function in the NFT contract copies all `tokenInfo.ExternalInfo` directly into `NFTProtocolInfo.Metadata` without validating that metadata keys don't conflict with NFT-reserved keys. An attacker can create a token on the mainchain via `MultiToken.Create()` with malicious ExternalInfo containing NFT-reserved keys, sync it to a sidechain, and register it as an NFT protocol with unvalidated metadata, bypassing the metadata validation enforced by the legitimate `NFT.Create()` flow.

## Finding Description

The vulnerability exists in the `CrossChainCreate()` function where it blindly copies all token metadata without validation. The function retrieves token information from the MultiToken contract and directly copies the entire ExternalInfo dictionary into the NFT protocol's metadata field. [1](#0-0) 

This contrasts sharply with the legitimate mainchain `Create()` flow, which validates user-provided metadata to ensure it doesn't use reserved keys. The mainchain flow calls `GetTokenExternalInfo()` which includes validation: [2](#0-1) 

The `AssertMetadataKeysAreCorrect()` function checks that user metadata doesn't conflict with reserved NFT keys: [3](#0-2) 

These reserved keys include critical NFT metadata fields that control protocol behavior: [4](#0-3) 

**Root Cause:** The `CrossChainCreate()` function incorrectly assumes that any token retrieved from the TokenContract was created through the proper `NFT.Create()` flow and thus has properly validated metadata. However, tokens can be created directly via `MultiToken.Create()` on the mainchain. When creating NFT collections (symbols matching NFT naming conventions), the MultiToken contract routes to `CreateNFTCollection()`: [5](#0-4) 

Which calls `CreateToken()` that simply assigns the ExternalInfo without NFT-specific validation: [6](#0-5) 

The `AssertValidCreateInput()` method called at the start of `CreateToken()` only validates basic properties like symbol length and decimals, but does not check ExternalInfo content against NFT reserved keys: [7](#0-6) 

**Exploitation Path:**
1. Attacker creates an NFT collection token on mainchain (AELF) via `MultiToken.Create()` with symbol matching NFT naming conventions (e.g., "AR12345678-0")
2. Attacker includes malicious ExternalInfo with NFT-reserved keys (e.g., `aelf_nft_base_uri` pointing to a phishing site, `aelf_nft_type`, `aelf_nft_token_id_reuse`)
3. Token is synced to sidechain via standard cross-chain flow (`CrossChainCreateToken`)
4. Attacker calls `CrossChainCreate()` on sidechain NFT contract - this is a public method with no authorization checks: [8](#0-7) 

5. Function extracts baseUri and other critical fields directly from unvalidated ExternalInfo: [9](#0-8) 

6. All malicious metadata is copied into NFT protocol without validation, bypassing the security guarantees provided by the legitimate creation flow.

## Impact Explanation

**Concrete Harm:**

- **Malicious baseUri Injection:** The `baseUri` field is extracted directly from `ExternalInfo` without validation. An attacker can set this to a phishing URL, causing all NFT metadata queries to direct users to malicious websites for credential harvesting or malware distribution. This affects any wallet, marketplace, or application that displays NFT metadata to users.

- **Metadata Poisoning:** The entire `ExternalInfo` dictionary is copied into `NFTProtocolInfo.Metadata`, allowing injection of arbitrary key-value pairs that could override or corrupt NFT-specific metadata fields, include misleading information about token properties (e.g., false rarity claims, fake creator information), or inject malicious content into metadata fields consumed by wallets and marketplaces.

- **Protocol Integrity Violation:** NFT protocols created via this vulnerability bypass the metadata validation guarantees enforced on the mainchain, creating a trust inconsistency where sidechain NFT protocols don't meet the same security standards as mainchain protocols. This undermines the integrity of the entire cross-chain NFT system.

**Affected Parties:**
- End users viewing NFT metadata through frontends/wallets
- NFT marketplaces and applications consuming this metadata
- Legitimate NFT creators whose reputation may be damaged by malicious protocols
- The overall integrity of the AElf NFT ecosystem

**Severity Justification (Medium):**
- No direct fund theft, but significant operational and trust impact
- Enables phishing attacks targeting end users
- Metadata manipulation can cause financial harm through deception
- Affects user safety and protocol reputation

## Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to call public smart contract methods (available to any user)
- Token creation cost on mainchain (standard SEED NFT consumption or whitelist access - publicly available mechanisms)
- Cross-chain transaction fees (minimal cost)

**Attack Complexity:** LOW
1. Call `MultiToken.Create()` on mainchain with crafted ExternalInfo containing malicious reserved keys
2. Wait for standard cross-chain token sync process via `CrossChainCreateToken`
3. Call `CrossChainCreate()` on sidechain - public method with no authorization checks

**Feasibility Conditions:**
- No special privileges required beyond obtaining a SEED NFT (publicly available through the SEED collection)
- All preconditions are standard operational requirements
- Cross-chain infrastructure is available and functional (normal operating condition)
- No race conditions or timing dependencies
- Attack can be executed at any time

**Economic Rationality:**
- Attack cost: Standard token creation fee + cross-chain transaction fees (relatively low)
- Potential gain: Phishing victims, reputation damage to competing projects, manipulation of NFT marketplace perception
- Cost-benefit ratio highly favorable for targeted attacks on high-value NFT collections

**Detection Constraints:**
- Malicious metadata appears as legitimate NFT protocol on sidechain (no on-chain difference)
- No on-chain indicators distinguishing bypassed validation from properly validated protocols
- Requires off-chain monitoring of baseUri endpoints and metadata content analysis
- Retroactive detection difficult after protocol is established

## Recommendation

Add metadata validation to the `CrossChainCreate()` function to ensure ExternalInfo from cross-chain synced tokens doesn't contain NFT-reserved keys. The function should validate that user-controlled metadata keys don't conflict with reserved keys before copying the metadata:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    // ADDED: Validate that ExternalInfo doesn't contain reserved keys
    var reservedKeys = GetNftMetadataReservedKeys();
    foreach (var key in tokenInfo.ExternalInfo.Value.Keys)
    {
        Assert(!reservedKeys.Contains(key), 
            $"Cross-chain token contains reserved NFT metadata key: {key}");
    }

    // Continue with existing logic...
    var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
    // ... rest of implementation
}
```

Alternatively, instead of rejecting tokens with reserved keys, extract only the required reserved keys and construct the metadata manually without copying unvalidated user-provided fields, similar to how the mainchain `Create()` function uses `GetTokenExternalInfo()`.

## Proof of Concept

The vulnerability can be demonstrated with the following test case:

1. On mainchain: Create an NFT collection token via `MultiToken.Create()` with malicious ExternalInfo:
   - Symbol: "AR12345678-0" (valid NFT collection format)
   - ExternalInfo includes: `{"aelf_nft_base_uri": "https://phishing-site.com/metadata/"}`

2. Sync token to sidechain via standard `CrossChainCreateToken` mechanism

3. On sidechain: Call `NFT.CrossChainCreate()` with the synced token symbol

4. Verify that the resulting NFT protocol contains the malicious baseUri in its metadata, bypassing the validation that would have rejected this in the legitimate `NFT.Create()` flow

The test confirms that metadata validation is bypassed, allowing arbitrary ExternalInfo injection into NFT protocols on sidechains.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L104-104)
```csharp
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L186-186)
```csharp
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L97-107)
```csharp
    private List<string> GetNftMetadataReservedKeys()
    {
        return new List<string>
        {
            NftTypeMetadataKey,
            NftBaseUriMetadataKey,
            AssembledNftsKey,
            AssembledFtsKey,
            NftTokenIdReuseMetadataKey
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```
