# Audit Report

## Title
Circular Swap Logic in BreakContinuousMining Fails to Prevent Consecutive Block Production with Two Miners

## Summary
The `BreakContinuousMining` function in the AEDPoS consensus contract contains a logic flaw where two sequential swap operations cancel each other out when exactly two miners participate in consensus. This allows the same miner to produce both the extra block terminating round N and the first regular block of round N+1, violating the consensus fairness invariant explicitly stated in the code.

## Finding Description

The vulnerability exists in the `BreakContinuousMining` method, which is designed to prevent consecutive block production across round boundaries. [1](#0-0) 

The method performs two independent swap operations:

**First swap**: If the first miner of the next round (order 1) matches the extra block producer of the current round, it swaps miners at positions 1 and 2. [2](#0-1) 

**Second swap**: If the last miner of the next round matches the extra block producer of the next round, it swaps the last miner with the second-to-last miner. [3](#0-2) 

**Root Cause**: When `minersCount = 2`, both swaps operate on the same pair of miners (order 1 ↔ order 2). The function only excludes `minersCount <= 1`, explicitly supporting 2-miner configurations. [4](#0-3) 

Critically, the `IsExtraBlockProducer` flag is NOT modified during swaps—only the `Order` field changes. The `GetExtraBlockProducerInformation()` method returns the miner with `IsExtraBlockProducer = true`. [5](#0-4) 

**Execution Flow with 2 Miners**:
1. Initial state: Miner A has order=1, IsExtraBlockProducer=true; Miner B has order=2
2. First swap triggers (Miner A == extra block producer of current round): Orders swap to A=2, B=1
3. Second swap checks: lastMiner (order 2, now Miner A) equals extraBlockProducerOfNextRound (returns Miner A because IsExtraBlockProducer=true)
4. Second swap reverses: A returns to order=1, B returns to order=2

This violates the explicit invariant at line 78: "First miner of next round != Extra block producer of current round".

The extra block producer selection uses pseudo-random calculation based on the first miner's signature with modulo operation. [6](#0-5)  With 2 miners, this provides approximately 50% probability of selecting the same miner for consecutive rounds.

## Impact Explanation

**Consensus Fairness Violation**: The AEDPoS consensus mechanism explicitly implements `BreakContinuousMining` with the stated purpose of preventing consecutive block production. The comment at line 78 directly states the invariant that should be maintained. When this protection fails, a single miner produces both the extra block terminating one round and the first regular block of the next round, defeating the core fairness guarantee.

**Pseudo-Random Manipulation Risk**: The next round's extra block producer selection depends on the first miner's signature. [7](#0-6)  Consecutive block production by the same miner means they control the signature input used for selection, creating potential for influencing the pseudo-random process.

**Validation System Conflict**: The consensus system includes `ContinuousBlocksValidationProvider` to detect excessive continuous block production. [8](#0-7)  When the same miner legitimately produces consecutive blocks across round boundaries due to this bug, it may trigger false positives or create ambiguity in validation logic.

**Reward Concentration**: The miner accumulates both the extra block reward and the first regular block reward consecutively, concentrating economic incentives contrary to the intended distribution pattern.

## Likelihood Explanation

**Automatic Trigger**: The vulnerability triggers automatically during normal consensus operation when `GenerateNextRoundInformation` is called. [9](#0-8) 

**Supported Configuration**: While the default `SupposedMinersCount` is 17 [10](#0-9) , the code explicitly supports `minersCount >= 2` and does not enforce a minimum. Legitimate scenarios include:
- Test networks with minimal validators
- Initial network deployment phases
- Private or consortium chains with small validator sets
- Edge cases during validator set transitions

**High Conditional Probability**: When the precondition is met (minersCount=2), there is approximately 50% probability per round that the pseudo-random selection will choose the same miner as extra block producer for both current and next rounds.

**No Attacker Control**: This occurs through the natural consensus mechanism without requiring any malicious actor or special privileges.

## Recommendation

Modify the `BreakContinuousMining` function to prevent circular swaps by either:

1. **Update the IsExtraBlockProducer flag** during swaps to reflect the new mining order
2. **Perform a single consolidated check** instead of two independent swaps
3. **Add special handling for minersCount=2** to detect and prevent the circular condition

Example fix approach:
```csharp
private void BreakContinuousMining(ref Round nextRound)
{
    var minersCount = RealTimeMinersInformation.Count;
    if (minersCount <= 1) return;

    var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
    var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
    
    if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
    {
        var secondMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
        // Swap orders
        secondMinerOfNextRound.Order = 1;
        firstMinerOfNextRound.Order = 2;
        var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
        secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
        firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        
        // Update the extra block producer flag if necessary
        if (firstMinerOfNextRound.IsExtraBlockProducer)
        {
            firstMinerOfNextRound.IsExtraBlockProducer = false;
            secondMinerOfNextRound.IsExtraBlockProducer = true;
        }
    }

    // Second check now uses updated state
    var lastMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
    if (lastMinerOfNextRound == null) return;

    var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
    if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
    {
        var lastButOneMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
        // Swap orders
        lastButOneMinerOfNextRound.Order = minersCount;
        lastMinerOfNextRound.Order = minersCount.Sub(1);
        var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
        lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
        lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        
        // Update flags
        if (lastMinerOfNextRound.IsExtraBlockProducer)
        {
            lastMinerOfNextRound.IsExtraBlockProducer = false;
            lastButOneMinerOfNextRound.IsExtraBlockProducer = true;
        }
    }
}
```

## Proof of Concept

```csharp
[Fact]
public void BreakContinuousMining_CircularSwap_TwoMiners_Test()
{
    // Setup: Create a round with 2 miners
    var round = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation =
        {
            ["MinerA"] = new MinerInRound
            {
                Pubkey = "MinerA",
                Order = 1,
                IsExtraBlockProducer = true, // MinerA is extra block producer of current round
                ExpectedMiningTime = TimestampHelper.GetUtcNow(),
                Signature = ByteString.CopyFrom(new byte[] { 0x01 }) // Will produce same miner via modulo
            },
            ["MinerB"] = new MinerInRound
            {
                Pubkey = "MinerB",
                Order = 2,
                IsExtraBlockProducer = false,
                ExpectedMiningTime = TimestampHelper.GetUtcNow().AddMilliseconds(4000)
            }
        }
    };

    // Generate next round - this calls BreakContinuousMining internally
    round.GenerateNextRoundInformation(
        TimestampHelper.GetUtcNow().AddMilliseconds(8000),
        TimestampHelper.GetUtcNow(),
        out var nextRound
    );

    // Verify the bug: MinerA should NOT be at order 1 if it was the extra block producer
    // But due to circular swap, it ends up back at order 1
    var firstMiner = nextRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    var extraBlockProducer = nextRound.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer);
    
    // This assertion should pass with the bug (violation of invariant)
    Assert.Equal("MinerA", firstMiner.Pubkey);
    Assert.Equal("MinerA", extraBlockProducer.Pubkey);
    
    // Invariant violated: first miner of next round == extra block producer who terminated current round
    Assert.True(firstMiner.Pubkey == "MinerA"); // Proves consecutive block production
}
```

## Notes

This vulnerability represents a clear logic error where the implementation fails to achieve its stated design goal. The explicit comment at line 78 demonstrates the intended invariant, and the circular swap bug directly violates it when operating with 2 miners. While 2-miner configurations may be uncommon on production mainnet, the code explicitly supports this scenario and the bug creates a direct breach of the consensus fairness guarantee that `BreakContinuousMining` was designed to enforce.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L67-67)
```csharp
        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
