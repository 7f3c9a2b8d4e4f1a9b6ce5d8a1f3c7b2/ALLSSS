# Audit Report

## Title
Quadratic Voting Implementation Broken - All Votes Cost Same Amount Due to Incorrect Vote Count Tracking

## Summary
The quadratic voting mechanism in the Vote contract is fundamentally broken because `QuadraticVotesCountMap` is keyed by `VoteId`, which changes with every vote. This causes each vote to start with a fresh counter at zero instead of accumulating, resulting in all votes costing a flat `TicketCost * 1` instead of the intended progressive quadratic cost (1x, 2x, 3x, etc.).

## Finding Description

The quadratic voting implementation tracks vote counts in `QuadraticVotesCountMap` using `VoteId` as the key. [1](#0-0) 

However, the `VoteId` is generated during input validation by incorporating the current `votingResult.VotesAmount` value, which changes with every vote: [2](#0-1) 

Since `VotesAmount` is incremented after each vote, [3](#0-2)  every subsequent vote by the same voter generates a different `VoteId`. This breaks the quadratic cost calculation: [4](#0-3) 

**Execution Flow:**
1. **First vote:** VotesAmount=0 → VoteId1 generated → QuadraticVotesCountMap[VoteId1]=0+1=1 → cost = TicketCost × 1
2. **Second vote:** VotesAmount=TicketCost → VoteId2 generated (different!) → QuadraticVotesCountMap[VoteId2]=0+1=1 → cost = TicketCost × 1 (should be TicketCost × 2!)
3. **Nth vote:** Always creates new VoteId → Always costs TicketCost × 1

The map should be keyed by `(Voter, VotingItemId, SnapshotNumber)` to properly track cumulative votes per voter. There is no reset or decrement logic anywhere in the codebase - confirmed by searching all occurrences of `QuadraticVotesCountMap`, which only appears in the declaration and these two lines.

## Impact Explanation

**Severity: High** - This completely negates the fundamental security mechanism of quadratic voting.

Quadratic voting is designed to prevent plutocracy by making it exponentially more expensive to dominate voting outcomes. The intended cost progression is:
- 1st vote: TicketCost × 1
- 2nd vote: TicketCost × 2  
- 3rd vote: TicketCost × 3
- Total for N votes: TicketCost × (1+2+3+...+N) = TicketCost × N(N+1)/2

**With this bug:**
- Every vote costs: TicketCost × 1
- Total for N votes: TicketCost × N

**Concrete Impact:**
- A voter wanting 100 votes should pay: TicketCost × 5,050
- Instead they pay: TicketCost × 100 (50× cheaper!)
- For 1000 votes: should pay TicketCost × 500,500, actually pays TicketCost × 1,000 (500× cheaper!)

**Protocol Damage:**
- Wealthy voters can buy disproportionate voting power cheaply
- Governance becomes plutocratic (money-based) instead of quadratic (preference-intensity-based)
- All decisions made through quadratic voting are invalidated
- The core security property that distinguishes quadratic voting from simple token-weighted voting is completely broken

The vulnerability affects all voting items where `IsQuadratic = true`. [5](#0-4) 

## Likelihood Explanation

**Likelihood: Certain** - This bug triggers automatically for every quadratic vote.

**Attacker Capabilities:** Any user can call the public `Vote()` method. [6](#0-5) 

**Attack Complexity:** Trivial - simply call `Vote()` multiple times on the same quadratic voting item. Each subsequent call will cost the same flat `TicketCost` instead of increasing quadratically.

**Preconditions:** Only requires:
- A voting item registered with `IsQuadratic = true`
- The voting item must be active (within start/end timestamps)

The bug is inherent in the design - there are no special conditions, timing windows, or state manipulations required. Every single quadratic vote in the system suffers from this issue.

**Economic Rationality:** Exploiting this provides maximum voting power for minimum cost with no downside. A rational voter would always exploit this to maximize their influence.

## Recommendation

Replace the `VoteId`-based tracking with a composite key that properly identifies unique (voter, voting item, snapshot) combinations:

```csharp
// In VoteContractState.cs, replace:
public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }

// With:
public MappedState<Address, Hash, long, long> QuadraticVotesCountMap { get; set; }
// Keys: (Voter Address, VotingItemId, SnapshotNumber) → Vote Count

// In VoteContract.cs Vote() method, replace lines 100-102:
var quadraticKey = HashHelper.ConcatAndCompute(
    HashHelper.ComputeFrom(input.Voter),
    votingItem.VotingItemId,
    HashHelper.ComputeFrom(votingItem.CurrentSnapshotNumber)
);
var currentVotesCount = State.QuadraticVotesCountMap[input.Voter][votingItem.VotingItemId][votingItem.CurrentSnapshotNumber].Add(1);
State.QuadraticVotesCountMap[input.Voter][votingItem.VotingItemId][votingItem.CurrentSnapshotNumber] = currentVotesCount;
amount = votingItem.TicketCost.Mul(currentVotesCount);
```

Additionally, implement proper cleanup in the `Withdraw()` method to decrement the counter when votes are withdrawn, ensuring accurate tracking across the voting lifecycle.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
public async Task QuadraticVoting_ShouldCostProgressively_ButCostsSameAmount()
{
    // Setup: Register quadratic voting item with TicketCost = 100
    var votingItemId = await RegisterQuadraticVotingItem(ticketCost: 100);
    
    // Alice casts first vote
    var vote1Result = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0 // Ignored for quadratic
    });
    
    // Check: First vote should lock 100 tokens (TicketCost * 1)
    var vote1Record = await VoteContractStub.GetVotingRecord.CallAsync(vote1Result.TransactionResult.TransactionId);
    vote1Record.Amount.ShouldBe(100); // ✓ Correct
    
    // Alice casts second vote
    var vote2Result = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0
    });
    
    // Check: Second vote should lock 200 tokens (TicketCost * 2)
    var vote2Record = await VoteContractStub.GetVotingRecord.CallAsync(vote2Result.TransactionResult.TransactionId);
    vote2Record.Amount.ShouldBe(200); // ✗ FAILS - Actually locks 100 tokens!
    
    // Alice casts third vote
    var vote3Result = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0
    });
    
    // Check: Third vote should lock 300 tokens (TicketCost * 3)
    var vote3Record = await VoteContractStub.GetVotingRecord.CallAsync(vote3Result.TransactionResult.TransactionId);
    vote3Record.Amount.ShouldBe(300); // ✗ FAILS - Actually locks 100 tokens!
    
    // Total locked should be 100 + 200 + 300 = 600
    // But actually is 100 + 100 + 100 = 300
    var totalLocked = vote1Record.Amount + vote2Record.Amount + vote3Record.Amount;
    totalLocked.ShouldBe(600); // ✗ FAILS - Actually 300!
}
```

**Notes**

The vulnerability stems from a fundamental design flaw where the vote counter key changes with each vote instead of being tied to the voter's identity. This allows voters to bypass the quadratic cost mechanism entirely, undermining the core security property that makes quadratic voting resistant to plutocratic capture. The impact scales dramatically with the number of votes - the more votes a malicious actor wants, the greater their discount compared to the intended quadratic cost.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L33-33)
```csharp
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-90)
```csharp
    public override Empty Vote(VoteInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L94-103)
```csharp
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L179-179)
```csharp
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```
