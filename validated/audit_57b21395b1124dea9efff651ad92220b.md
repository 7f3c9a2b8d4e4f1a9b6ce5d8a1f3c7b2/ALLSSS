# Audit Report

## Title
Mining Order Manipulation via Unvalidated SupposedOrderOfNextRound and TuneOrderInformation

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` and `TuneOrderInformation` values from miner-provided input without cryptographically validating that they match the deterministic calculation from the miner's signature. This allows a malicious miner to manipulate mining order in subsequent rounds, consistently positioning themselves first to maximize block rewards while disadvantaging honest miners.

## Finding Description

The vulnerability exists because mining order values are calculated during consensus extra data generation but never re-validated during block validation or execution.

**Root Cause - Order Calculation Only Occurs During Generation:**

The correct calculation of `SupposedOrderOfNextRound` from a miner's signature occurs in `ApplyNormalConsensusData`, where it computes the order deterministically based on the signature hash modulo the number of miners. [1](#0-0) 

This calculation happens during `GetConsensusExtraDataToPublishOutValue` when generating consensus extra data. [2](#0-1) 

**Vulnerability 1 - ProcessUpdateValue Blindly Accepts Input Values:**

During block execution, `ProcessUpdateValue` directly uses the provided values without recalculation or validation that they match the expected calculation from the signature. [3](#0-2) 

The `TuneOrderInformation` is blindly applied to modify other miners' orders without validation. [4](#0-3) 

**Vulnerability 2 - UpdateValueValidationProvider Insufficient:**

The validation provider only checks that `OutValue` and `Signature` are filled, but does NOT validate that `SupposedOrderOfNextRound` matches the calculation from the signature. [5](#0-4) 

**Vulnerability 3 - RecoverFromUpdateValue Blindly Copies:**

During pre-execution validation, the recovery process copies order values from provided data without recalculation or validation. [6](#0-5) 

**Vulnerability 4 - After-Execution Validation Ineffective:**

The after-execution validation compares rounds that both contain the same manipulated values. Since `RecoverFromUpdateValue` copies the manipulated values into both rounds being compared, the hash comparison cannot detect tampering. [7](#0-6) 

**Attack Path:**

The simplified round data returned by `GetUpdateValueRound` includes the order values that can be modified by the attacker. [8](#0-7) 

## Impact Explanation

**Critical Consensus Integrity Violation:**

The manipulated `FinalOrderOfNextRound` values directly determine the mining schedule for the next round. When generating the next round, miners are scheduled according to their `FinalOrderOfNextRound` in ascending order. [9](#0-8) 

**Concrete Harm:**

1. **Unfair Mining Advantage**: Attacker can set their `FinalOrderOfNextRound = 1` to consistently mine first in subsequent rounds, maximizing their block production opportunities
2. **Reward Misallocation**: First miners have higher probability of producing blocks and earning rewards; the attacker gains disproportionate rewards at the expense of honest miners
3. **Consensus Fairness Breakdown**: The security guarantee that mining order is unpredictably determined from signature hashes is completely bypassed
4. **Competitor Suppression**: Attacker can use malicious `TuneOrderInformation` to push specific honest miners to later positions, reducing their mining opportunities

**Severity**: CRITICAL - This breaks a core consensus invariant (miner schedule integrity) and directly impacts economic fairness and block production distribution across all network participants.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an authorized miner in the current round (standard precondition for block production)
- Control over their own node software (typical for all miners)
- No special cryptographic capabilities beyond normal block signing

**Attack Feasibility**: HIGH

The attack is straightforward:
1. Node calls `GetConsensusExtraData` through standard miner process
2. Miner parses the returned `AElfConsensusHeaderInformation` protobuf
3. Miner modifies `SupposedOrderOfNextRound` to desired value (e.g., 1 to mine first)
4. Miner modifies `TuneOrderInformation` to suppress competitors
5. Miner serializes modified data and includes in block header
6. Miner signs block with their own key

**Why Block Validation Passes:**
- `UpdateValueValidationProvider` doesn't check order calculations
- `RecoverFromUpdateValue` blindly copies manipulated values
- After-execution hash comparison compares manipulated values with themselves
- No code path recalculates expected values from signatures

**Detection**: NONE - The contract has no mechanism to detect order manipulation since it never recalculates the expected values from signatures.

**Economic Rationality**: Highly profitable - mining rewards justify the manipulation, especially for validators with significant stake who can exploit this persistently across many rounds.

## Recommendation

Add validation in `UpdateValueValidationProvider` to recalculate the expected `SupposedOrderOfNextRound` from the signature and compare it to the provided value:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var signature = minerInRound.Signature;
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    
    // Recalculate expected order from signature
    var sigNum = signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    
    // Validate it matches provided value
    if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
        return false;
        
    return true;
}
```

Additionally, validate `TuneOrderInformation` entries to ensure they only adjust orders for legitimate conflict resolution, not arbitrary manipulation.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanManipulateMiningOrder_Test()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = await BootMiner();
    
    // Attacker is miner at index 1
    var attackerKeyPair = initialMiners[1];
    var attackerStub = GetAEDPoSContractStub(attackerKeyPair);
    
    // Get legitimate consensus extra data
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(attackerKeyPair.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        InValue = HashHelper.ComputeFrom("test"),
        PreviousInValue = Hash.Empty
    };
    
    var extraData = await attackerStub.GetConsensusExtraData.CallAsync(
        new BytesValue { Value = triggerInfo.ToByteString() });
    
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(extraData.Value);
    
    // ATTACK: Modify SupposedOrderOfNextRound to 1 (mine first next round)
    var attackerPubkeyHex = attackerKeyPair.PublicKey.ToHex();
    headerInfo.Round.RealTimeMinersInformation[attackerPubkeyHex].SupposedOrderOfNextRound = 1;
    headerInfo.Round.RealTimeMinersInformation[attackerPubkeyHex].FinalOrderOfNextRound = 1;
    
    // Validation should fail but doesn't
    var validationResult = await attackerStub.ValidateConsensusBeforeExecution.CallAsync(
        new BytesValue { Value = headerInfo.ToByteString() });
    
    // BUG: Validation passes even with manipulated order
    validationResult.Success.ShouldBeTrue(); // This should be False but is True
    
    // Execute UpdateValue with manipulated data
    var updateInput = headerInfo.Round.ExtractInformationToUpdateConsensus(
        attackerPubkeyHex, ByteString.Empty);
    await attackerStub.UpdateValue.SendAsync(updateInput);
    
    // Verify attacker's order was stored as 1
    var currentRound = await attackerStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation[attackerPubkeyHex].FinalOrderOfNextRound.ShouldBe(1);
    
    // Advance to next round
    await ProduceBlocks(attackerKeyPair, 100);
    
    // Verify attacker mines first in next round
    var nextRound = await attackerStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var firstMiner = nextRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    firstMiner.Pubkey.ShouldBe(attackerPubkeyHex); // Attacker is first!
}
```

## Notes

This vulnerability breaks a fundamental consensus invariant: that mining order is determined unpredictably and fairly from cryptographic signatures. The absence of validation that recalculates and verifies the order values allows any authorized miner to manipulate their position in subsequent rounds. The validation framework only checks that cryptographic primitives (OutValue, Signature) are present, but never validates that derived values (SupposedOrderOfNextRound) match their expected calculations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
