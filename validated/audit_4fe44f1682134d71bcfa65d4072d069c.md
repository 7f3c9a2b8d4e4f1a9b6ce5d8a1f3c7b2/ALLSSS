# Audit Report

## Title
Missing Miner List Validation in NextRound Transition Enables Complete Consensus Takeover

## Summary
The AEDPoS consensus contract lacks validation to ensure the miner list remains unchanged during NextRound transitions. A malicious current miner can craft a NextRound block containing an arbitrary miner list, bypassing all validation checks and achieving complete consensus control in a single block.

## Finding Description

The vulnerability exists due to three critical gaps in the NextRound validation logic:

**1. No Miner List Comparison in Before-Execution Validators**

The `ValidationForNextRound` method only validates round number increments and null InValues, with no check that the proposed miner list matches the current round: [1](#0-0) 

The `NextRoundMiningOrderValidationProvider` only validates internal consistency within the provided round (counting miners with FinalOrderOfNextRound vs OutValue), not comparing the miner set against the base round: [2](#0-1) 

The `MiningPermissionValidationProvider` only checks if the sender exists in the current round, not whether the proposed next round's miner list is valid: [3](#0-2) 

**2. Direct State Write Without Miner List Validation**

The `ProcessNextRound` method converts the NextRoundInput to a Round object and directly writes it to state without validating that the miner list matches the current round: [4](#0-3) 

The `AddRoundInformation` method stores the entire Round including `RealTimeMinersInformation` without modification: [5](#0-4) 

**3. Ineffective After-Execution Validation**

The `ValidateConsensusAfterExecution` compares the block header's round information against the state AFTER the NextRound transaction has executed. Since both can contain the same malicious miner list (attacker controls both header and transaction content), they match and validation passes: [6](#0-5) 

The `TryToGetCurrentRoundInformation` fetches from state that was just written by the transaction: [7](#0-6) 

**Expected vs Actual Behavior**

The legitimate `GenerateNextRoundInformation` method preserves miner list consistency by deriving the next round from current round miners: [8](#0-7) 

However, miners are not forced to use this generation method and can provide arbitrary NextRoundInput data.

## Impact Explanation

This vulnerability enables **complete consensus takeover** with catastrophic consequences:

**Direct Impacts:**
- **Consensus Capture**: A single malicious miner replaces all other miners with attacker-controlled nodes, gaining 100% consensus control
- **Double-Spending**: Full control enables transaction reversal and double-spending attacks
- **Censorship**: Complete ability to exclude any transactions or blocks
- **Chain Reorganization**: Rewrite blockchain history with attacker supermajority
- **Economic Destruction**: Unlimited token minting, theft of all chain assets via consensus control
- **Permanent Takeover**: Attacker maintains control indefinitely by continuing to use manipulated miner list

**Affected Parties:** All token holders (assets at risk), all dApp users (services disrupted), entire blockchain ecosystem (complete loss of security guarantees).

This represents a **CRITICAL** severity issue as it allows instant consensus capture without requiring 51% stake acquisition through normal election mechanisms.

## Likelihood Explanation

The attack has **HIGH** likelihood due to minimal prerequisites:

**Attacker Requirements:**
1. Control one current miner position (publicly elected role)
2. Wait for their block production opportunity
3. Craft malicious NextRoundInput with arbitrary `RealTimeMinersInformation`

**Attack Feasibility:**
- **Low Complexity**: Simply modify the RealTimeMinersInformation in NextRoundInput
- **No Additional Cost**: No stake beyond existing miner position required
- **Single Transaction**: Complete attack executes in one NextRound block
- **No Detection Window**: State is corrupted before any detection possible

**Validation Bypass Confirmed:**
The before-execution validators applied to NextRound behavior only check mining permission, timing, continuous blocks, and internal consistency: [9](#0-8) 

None of these validators compare the provided miner list against the base round miner list, allowing the attack to succeed.

## Recommendation

Add a validator that explicitly checks miner list consistency for NextRound (as distinct from NextTerm which legitimately changes miners):

```csharp
public class MinerListConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        // For NextRound, miner list must remain unchanged
        var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var providedMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        if (baseMiners.Count != providedMiners.Count || 
            !baseMiners.SequenceEqual(providedMiners))
        {
            validationResult.Message = "NextRound miner list must match current round miner list.";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this validator to the NextRound validation chain in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new MinerListConsistencyValidationProvider()); // ADD THIS
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_MinerListManipulation_ConsensusT akeover()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker: Control miner1 position
    var attackerMiner = "miner1";
    
    // Attack: Craft NextRound with arbitrary attacker-controlled miner list
    var maliciousMinerList = new[] { "attacker1", "attacker2", "attacker3" };
    var maliciousNextRound = CreateNextRoundWithMiners(maliciousMinerList);
    
    // Execute: Submit NextRound transaction
    var result = await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Attacker's miner list is now in consensus state
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var actualMiners = currentRound.RealTimeMinersInformation.Keys.ToList();
    
    // VULNERABILITY CONFIRMED: Malicious miner list accepted
    actualMiners.ShouldBe(maliciousMinerList);
    actualMiners.ShouldNotContain(legitimateMiners);
    
    // Impact: Attacker now controls consensus completely
}
```

## Notes

This vulnerability breaks the fundamental security invariant that **NextRound transitions preserve the miner set** (as opposed to NextTerm which explicitly updates miners via election results). The validation framework assumes miners will use the legitimate `GenerateNextRoundInformation` method, but provides no enforcement of this assumption. Any current miner can exploit this gap to achieve immediate and complete consensus takeover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-92)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```
