# Audit Report

## Title
Zero Deposit Allows Connector Enablement Without Base Token Reserves, Breaking Sell Functionality

## Summary
The `GetNeededDeposit()` function returns zero when all circulating tokens are transferred during connector enablement, allowing a connector to be enabled without base token reserves. This creates a permanently broken Bancor market where the `Sell()` function fails due to insufficient base token balance, causing a Denial of Service for all token holders attempting to exit their positions.

## Finding Description

The vulnerability exists in the `GetNeededDeposit()` calculation logic. When `AmountToTokenConvert` equals all circulating tokens (`totalSupply - balance`), the function calculates `amountOutOfTokenConvert = 0` and skips deposit calculation, returning `needDeposit = 0`. [1](#0-0) 

This zero deposit value is then used directly in `EnableConnector()` to set the deposit balance without validation. [2](#0-1) 

When users attempt to sell tokens, the function retrieves the deposit balance through `GetSelfBalance()` for deposit account connectors. [3](#0-2) 

With zero deposit balance, the `Sell()` operation fails when `BancorHelper.GetReturnFromPaid()` is called, as it explicitly throws an exception when connector balance is zero or negative. [4](#0-3) 

Critically, `EnableConnector()` has no permission checks, making it callable by any address after connectors are configured by the controller. [5](#0-4) 

Once enabled, the connector cannot be fixed, as `UpdateConnector()` explicitly prevents updates to activated connectors. [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This vulnerability creates a permanent Denial of Service condition with the following impacts:

1. **Operational Failure**: The `Sell()` function becomes permanently unusable for the affected connector, breaking a core protocol invariant that Bancor markets provide continuous bidirectional liquidity.

2. **Fund Lock**: Token holders cannot exit their positions, effectively experiencing locked funds with zero liquidity despite holding valid tokens.

3. **Market Integrity**: Creates a one-way market where users can only buy tokens but never sell them back, fundamentally breaking the Bancor automated market maker model.

4. **No Recovery Path**: Once enabled, the connector cannot be updated or fixed through `UpdateConnector()`, making the DoS permanent.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability has realistic triggering conditions:

1. **Permissionless Entry Point**: `EnableConnector()` requires no authorization beyond possession of tokens, executable by anyone after governance adds connector pairs.

2. **Realistic Scenario**: For newly created tokens with fixed supply, the issuer naturally holds all tokens and might legitimately transfer them all to maximize perceived liquidity, unaware of the deposit requirement implications.

3. **No Validation**: The contract provides no warnings, input validation, or deposit minimum requirements to prevent this configuration.

4. **Detection Difficulty**: The issue only manifests when users attempt to sell, potentially after tokens have been distributed, making recovery complex.

5. **Test Evidence**: The existing test validates connector enablement with 99.9999% of supply (999,999 out of 1,000,000 units), confirming the edge case of 100% is not tested. [7](#0-6) 

## Recommendation

Add validation in `EnableConnector()` to ensure minimum deposit requirements:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    var needDeposit = GetNeededDeposit(input);
    
    // ADD THIS VALIDATION
    Assert(needDeposit.NeedAmount > 0 || input.AmountToTokenConvert == 0, 
        "Cannot enable connector with zero deposit when converting all circulating tokens.");
    
    if (needDeposit.NeedAmount > 0)
        State.TokenContract.TransferFrom.Send(/* ... */);
    // ... rest of function
}
```

Alternatively, fix `GetNeededDeposit()` to properly calculate required deposit even when all tokens are converted.

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_With_All_Tokens_Creates_Zero_Deposit_DoS()
{
    // Setup: Create token with 1,000,000 supply
    var tokenSymbol = "VULN";
    var totalSupply = 1_000_000_00000000;
    await CreateTokenAsync(tokenSymbol, totalSupply);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue ALL tokens to user
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = totalSupply,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // Enable connector with ALL circulating tokens
    var enableInput = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = totalSupply
    };
    
    // Verify deposit is ZERO (vulnerability)
    var deposit = await DefaultStub.GetNeededDeposit.CallAsync(enableInput);
    deposit.NeedAmount.ShouldBe(0); // BUG: Should require deposit
    
    // Enable connector with zero deposit
    await DefaultStub.EnableConnector.SendAsync(enableInput);
    
    // Verify connector is enabled
    var connector = await DefaultStub.GetPairConnector.CallAsync(
        new TokenSymbol { Symbol = tokenSymbol });
    connector.ResourceConnector.IsPurchaseEnabled.ShouldBe(true);
    
    // Attempt to sell - this will FAIL permanently
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = tokenSymbol,
        Amount = 1000
    });
    
    // VULNERABILITY: Sell fails with "Connector balance needs to be a positive number"
    sellResult.TransactionResult.Error.ShouldContain("Connector balance needs to be a positive number");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-389)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L386-399)
```csharp
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Amount = 99_9999_0000,
            To = DefaultSender,
            Symbol = tokenSymbol
        });
        var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 99_9999_0000
        };
        var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
        deposit.NeedAmount.ShouldBe(100);
        await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
```
