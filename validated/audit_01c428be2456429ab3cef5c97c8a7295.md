# Audit Report

## Title
Input Collision Vulnerability in Token Hash Calculation Allows Cross-Protocol Balance Manipulation

## Summary
The NFT contract's `CalculateTokenHash` function concatenates symbol and tokenId without a delimiter, enabling different (symbol, tokenId) pairs to produce identical hashes. This causes distinct tokens to share storage slots for balances, allowances, and metadata, enabling unauthorized token transfers across protocols.

## Finding Description

The vulnerability exists in the `CalculateTokenHash` function which performs simple string concatenation without any delimiter: [1](#0-0) 

This implementation allows input collisions where different (symbol, tokenId) combinations produce identical concatenated strings. For example:
- Symbol="AR123456789" + tokenId=0 → "AR1234567890"
- Symbol="AR1234567" + tokenId=890 → "AR1234567890"

Both produce the same hash value, causing storage collisions.

**Affected State Mappings:**

All critical NFT state uses the colliding tokenHash as storage key: [2](#0-1) [3](#0-2) [4](#0-3) 

**Exploitation Path:**

1. **Token Creation**: Attacker creates a regular token "AR1234567" (9 characters, within the 10-character limit for regular tokens) in MultiToken contract: [5](#0-4) 

This requires either CreateWhitelist membership or a seed NFT: [6](#0-5) 

2. **Protocol Registration**: Attacker calls `CrossChainCreate` which only validates token existence and that the first 2 characters match a valid NFT type, with no authorization check: [7](#0-6) 

The attacker becomes the protocol creator and sole minter: [8](#0-7) 

3. **Collision Minting**: Attacker mints NFT with tokenId=890, which produces the colliding hash. The minting operation uses the tokenHash for all storage operations: [9](#0-8) [10](#0-9) 

4. **Balance Manipulation**: Transfer operations check and modify balances using the shared tokenHash, allowing the attacker to manipulate the combined balance pool: [11](#0-10) 

The legitimate protocol "AR123456789" (11 characters, generated by NFT contract with minimum 9-digit numbers) with tokenId=0 shares the same hash: [12](#0-11) 

## Impact Explanation

**Direct Fund Impact:**
- Attackers can transfer tokens from the shared balance pool that they don't legitimately own
- Balance checks operate on the combined balance across both colliding protocols
- Victims holding tokens in the legitimate protocol lose control over their balances as the attacker manipulates the shared storage
- Balance queries return incorrect aggregated values across different protocols

**Severity Justification:**
HIGH - This enables direct token theft. While exploitation requires seed NFT acquisition or CreateWhitelist access, the fundamental design flaw in hash calculation allows theft of arbitrary amounts once collision conditions are met. The discrepancy between MultiToken's 10-character limit for regular tokens and NFT contract's 11+ character symbols creates the exploitable gap.

## Likelihood Explanation

**Attacker Capabilities Required:**
1. Obtain seed NFT for the target symbol or gain CreateWhitelist membership (Parliament-controlled)
2. Call `CrossChainCreate` in NFT contract (permissionless)
3. Mint NFTs with calculated tokenId to produce collision (attacker is the minter)
4. Execute transfer operations to manipulate shared balances

**Feasibility Assessment:**
MEDIUM complexity - Requires understanding the concatenation vulnerability and calculating collision parameters, but no cryptographic attacks needed. The ExternalInfo field can be set arbitrarily during token creation: [13](#0-12) 

This allows providing the required NFT metadata keys that `CrossChainCreate` expects: [14](#0-13) 

**Probability Assessment:**
MEDIUM overall - Primary barrier is seed NFT availability or whitelist access. However, this is a fundamental design flaw that persists regardless of access controls. As more protocols deploy and seed NFTs become tradeable, the probability increases.

## Recommendation

Add a delimiter between symbol and tokenId in the hash calculation to prevent collisions:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}");
}
```

Alternatively, hash the components separately:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, consider adding symbol length validation in `CrossChainCreate` to prevent short symbols that could collide with NFT-generated symbols.

## Proof of Concept

```csharp
[Fact]
public async Task TokenHashCollision_EnablesBalanceManipulation()
{
    // Setup: Legitimate protocol "AR123456789" with tokenId=0
    var legitimateSymbol = "AR123456789";
    var legitimateTokenId = 0L;
    
    // Attacker creates colliding token "AR1234567" with tokenId=890
    var attackerSymbol = "AR1234567";
    var attackerTokenId = 890L;
    
    // Verify collision: both produce "AR1234567890"
    var legitimateHash = CalculateTokenHash(legitimateSymbol, legitimateTokenId);
    var attackerHash = CalculateTokenHash(attackerSymbol, attackerTokenId);
    
    Assert.Equal(legitimateHash, attackerHash); // Collision confirmed
    
    // Victim mints legitimate NFT, balance stored at colliding hash
    await LegitimateProtocol.Mint(legitimateSymbol, legitimateTokenId, victim);
    
    // Attacker registers colliding protocol and mints at same hash
    await MultiToken.Create(attackerSymbol); // With seed NFT
    await NFTContract.CrossChainCreate(attackerSymbol);
    await NFTContract.Mint(attackerSymbol, attackerTokenId, attacker);
    
    // Attacker can now transfer from shared balance pool
    await NFTContract.Transfer(attackerSymbol, attackerTokenId, attacker, thief, amount);
    
    // Verify: Victim's balance decreased despite attacker using different symbol
    var victimBalance = await NFTContract.GetBalance(legitimateSymbol, legitimateTokenId, victim);
    Assert.True(victimBalance < originalAmount); // Balance stolen
}
```

## Notes

The vulnerability is rooted in the hash calculation design that assumes symbol uniqueness without considering that different token creation paths (NFT contract vs. MultiToken contract) have different symbol length constraints. The permissionless nature of `CrossChainCreate` combined with arbitrary `ExternalInfo` setting in MultiToken's `Create` method makes this exploitable despite access controls on token creation itself.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L52-54)
```csharp
        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-393)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L441-441)
```csharp
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-17)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L22-22)
```csharp
    public MappedState<Hash, Address, long> BalanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L30-30)
```csharp
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-93)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L110-113)
```csharp
        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** protobuf/token_contract.proto (L296-297)
```text
    // The external information of the token.
    ExternalInfo external_info = 9;
```
