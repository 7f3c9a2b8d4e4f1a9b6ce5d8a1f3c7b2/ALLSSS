# Audit Report

## Title
Missing Pubkey Field Validation in Round Transitions Enables LIB Consensus Manipulation

## Summary
The `NextRound` and `NextTerm` methods accept externally-controlled round data without validating that `MinerInRound.Pubkey` field values match their dictionary keys or are non-empty. A malicious miner can submit round data where dictionary keys are valid pubkeys but corresponding `MinerInRound.Pubkey` fields are empty strings, causing those miners to be incorrectly excluded from Last Irreversible Block (LIB) consensus calculations, breaking Byzantine Fault Tolerance assumptions.

## Finding Description

The vulnerability exists because the consensus contract accepts round transition data from external input without validating the consistency between dictionary keys and `MinerInRound.Pubkey` field values.

**Root Cause - Unchecked Data Conversion:**

The `ToRound()` method performs blind copying of `RealTimeMinersInformation` without any validation of the Pubkey field values: [1](#0-0) [2](#0-1) 

The protobuf definition allows dictionary keys to differ from `MinerInRound.pubkey` field values with no structural constraint: [3](#0-2) [4](#0-3) 

**Validation Bypass:**

All existing validation providers check dictionary keys but NOT the `Pubkey` field values:

`MiningPermissionValidationProvider` only checks if sender exists in dictionary keys: [5](#0-4) 

`IsInMinerList` (used in PreCheck) also only checks dictionary keys: [6](#0-5) [7](#0-6) 

`NextRoundMiningOrderValidationProvider` only validates order counts, not Pubkey field values: [8](#0-7) 

`RoundTerminateValidationProvider` only checks round/term numbers and InValues: [9](#0-8) 

The validation service runs all providers sequentially but none validate `Pubkey` field values: [10](#0-9) 

**LIB Manipulation:**

The LIB calculation retrieves mined miners' pubkeys and filters by their `Pubkey` field value, NOT dictionary keys: [11](#0-10) 

`GetSortedImpliedIrreversibleBlockHeights` performs `specificPublicKeys.Contains(i.Pubkey)`. If `i.Pubkey` is an empty string while `specificPublicKeys` contains valid hex pubkeys, the `Contains()` check returns false, excluding that miner: [12](#0-11) 

**Persistence Mechanism:**

The vulnerability persists because `GenerateNextRoundInformation` explicitly copies the `Pubkey` field from the current round to the next: [13](#0-12) [14](#0-13) 

**Attack Path:**

1. Attacker becomes a miner via Election contract staking/voting
2. Attacker calls the public `NextRound` method (defined as public RPC): [15](#0-14) [16](#0-15) 

3. Attacker crafts malicious `NextRoundInput` where dictionary keys are valid pubkeys but victim `MinerInRound.Pubkey` fields are empty strings
4. All validations pass (they only check dictionary keys, not field values)
5. Malicious round is stored: [17](#0-16) 

6. LIB calculations now exclude miners with empty `Pubkey` fields
7. Effect persists across subsequent rounds until `NextTerm` regenerates from Election contract

## Impact Explanation

**Critical Consensus Integrity Breach:**

The Last Irreversible Block (LIB) is a fundamental consensus primitive that determines transaction finality. The LIB height calculation uses Byzantine Fault Tolerance logic where the irreversible height is determined by taking the `(count-1)/3` position in sorted implied heights from miners who have mined blocks.

By excluding miners with manipulated empty `Pubkey` fields from this calculation, an attacker can:

1. **Delay Finality**: Exclude miners reporting higher implied irreversible block heights, causing the LIB to advance more slowly than it should
2. **Accelerate Finality Inappropriately**: Exclude miners reporting lower implied heights, causing premature finality
3. **Break BFT Assumptions**: If more than 1/3 of miners are excluded, the `(count-1)/3` formula operates on an incorrect subset, violating the 2f+1 consensus requirement

**Affected Parties:**
- All network participants relying on LIB for transaction finality guarantees
- Cross-chain bridges and indexing systems depending on confirmed irreversible block heights
- DApps and smart contracts that require finality assurances
- Economic systems (DEXs, lending protocols) that need settlement guarantees

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an active miner in the current or previous round (achievable by staking tokens and receiving votes through the Election contract)
- Can call `NextRound` as any miner passing PreCheck

**Attack Execution:**
Once the attacker is a miner, they can call `NextRound` with crafted input. The attack succeeds with 100% certainty because:
1. No validation checks `Pubkey` field values match dictionary keys or are non-empty
2. The protobuf structure allows arbitrary mismatches between map keys and field values
3. The malicious round data is accepted and stored in contract state

**Persistence:**
The attack has automatic persistence because `GenerateNextRoundInformation` copies the `Pubkey` field values to subsequent rounds. This means a single successful attack affects multiple rounds until a `NextTerm` transition regenerates miner data from the Election contract.

**Detection Difficulty:**
- External observers see miners continuing to produce blocks (dictionary keys remain valid)
- LIB manipulation appears as legitimate consensus behavior
- Requires monitoring internal round state data to detect

## Recommendation

Add validation in the `ToRound()` methods and/or in `ValidateBeforeExecution` to ensure:
1. Every `MinerInRound.Pubkey` field value matches its dictionary key
2. No `Pubkey` field is empty or null

Example fix in `NextRoundInput.ToRound()`:
```csharp
public Round ToRound()
{
    var round = new Round
    {
        RoundNumber = RoundNumber,
        RealTimeMinersInformation = { RealTimeMinersInformation },
        // ... other fields
    };
    
    // Validate Pubkey field consistency
    foreach (var kvp in round.RealTimeMinersInformation)
    {
        Assert(kvp.Value.Pubkey == kvp.Key, 
            $"Pubkey field {kvp.Value.Pubkey} does not match dictionary key {kvp.Key}");
        Assert(!string.IsNullOrEmpty(kvp.Value.Pubkey), 
            "Pubkey field cannot be empty");
    }
    
    return round;
}
```

Alternatively, add a dedicated validation provider:
```csharp
public class PubkeyConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        foreach (var kvp in validationContext.ProvidedRound.RealTimeMinersInformation)
        {
            if (kvp.Value.Pubkey != kvp.Key)
                return new ValidationResult 
                { 
                    Message = $"Pubkey field mismatch: {kvp.Value.Pubkey} != {kvp.Key}" 
                };
            
            if (string.IsNullOrEmpty(kvp.Value.Pubkey))
                return new ValidationResult 
                { 
                    Message = "Pubkey field cannot be empty" 
                };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

## Proof of Concept

A test demonstrating the vulnerability would:
1. Set up a consensus round with multiple miners
2. Have a malicious miner call `NextRound` with `NextRoundInput` where some miners have empty `Pubkey` field values while dictionary keys are valid
3. Verify the malicious round is accepted (no validation failure)
4. Trigger LIB calculation via `UpdateValue` operations
5. Verify that miners with empty `Pubkey` fields are excluded from LIB calculation
6. Demonstrate the incorrect LIB height that results from the manipulated miner set

The test would confirm that the vulnerability allows manipulation of LIB consensus calculations through Pubkey field tampering.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** protobuf/aedpos_contract.proto (L33-35)
```text
    // Update consensus information, create a new round.
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-98)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
