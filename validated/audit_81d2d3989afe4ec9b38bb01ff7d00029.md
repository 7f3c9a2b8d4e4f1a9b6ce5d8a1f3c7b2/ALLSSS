# Audit Report

## Title
Critical Miner List Manipulation Vulnerability in NextRound Validation Allows Consensus Takeover

## Summary
The `ValidationForNextRound()` function in `RoundTerminateValidationProvider` fails to validate that the miner list in the provided next round matches the current round's miner list. An attacker who is a valid miner can craft a malicious `NextRound` transaction with an arbitrary set of miners, bypassing all validation checks and achieving complete consensus control.

## Finding Description

**Root Cause:**

The `ValidationForNextRound()` method only validates round number increment and null InValues, with no check that the miner set in the provided round derives from the current round's miners. [1](#0-0) 

**Why Other Protections Fail:**

1. **MiningPermissionValidationProvider** only validates the transaction sender is in the current BaseRound, not whether the provided next round's miner list is valid: [2](#0-1) 

2. **NextRoundMiningOrderValidationProvider** checks internal consistency within the provided round but does not compare against BaseRound: [3](#0-2) 

For a fresh NextRound with all `FinalOrderOfNextRound = 0` and `OutValue = null`, this passes as `0 == 0`.

3. The validation pipeline applies these providers for NextRound but none verify miner list consistency: [4](#0-3) 

4. After validation passes, `ProcessNextRound` stores the malicious round without miner list checks: [5](#0-4) 

5. The `AddRoundInformation` method stores rounds without validation: [6](#0-5) 

**Contrast with Legitimate Behavior:**

The legitimate `GenerateNextRoundInformation` derives the next round's miner list exclusively from current round miners: [7](#0-6) 

However, an attacker bypasses this by submitting a crafted `NextRoundInput` directly via the public `NextRound` method: [8](#0-7) 

The `NextRoundInput.ToRound()` conversion transfers all provided fields including arbitrary miner lists: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Breach:**

Once the malicious round is stored, the arbitrary miner list becomes the active consensus authority. This results in:

- **Complete consensus takeover**: The attacker replaces all legitimate miners with arbitrary addresses they control
- **Permanent control**: The malicious miner set perpetuates itself by controlling all future round transitions
- **Governance bypass**: Election contract and vote mechanisms become irrelevant as consensus is no longer bound to elected candidates
- **Chain integrity compromise**: The attacker controls block production, enabling censorship, transaction manipulation, and collusion attacks

**Quantified Damage:**

- **100% miner displacement**: All legitimate miners excluded in a single transaction
- **Irreversible state corruption**: The malicious round in `State.Rounds[roundNumber]` becomes the authoritative source for mining permission validation
- **Total decentralization failure**: Blockchain becomes centralized under attacker control
- **Reward theft**: Legitimate miners lose all block production rewards
- **Voter disenfranchisement**: Token holders who voted for candidates have their governance nullified

## Likelihood Explanation

**Attacker Capabilities:**

The attacker needs only to be a valid miner in the current round, which passes `MiningPermissionValidationProvider` by being in `BaseRound.RealTimeMinersInformation.Keys`.

**Attack Complexity:**

Low. The attacker crafts a `NextRoundInput` with:
- `RoundNumber = BaseRound.RoundNumber + 1` (passes round validation)
- `RealTimeMinersInformation` containing arbitrary miners they control with valid `Order` and `ExpectedMiningTime`
- All `InValue`, `OutValue`, `FinalOrderOfNextRound` set to null/0 (passes all validations)

**Feasibility:**

- **Trigger opportunity**: Executable during attacker's designated time slot (regular occurrence)
- **Economic barrier**: Only normal transaction fees
- **Detection avoidance**: Passes all on-chain validation checks

**Probability:** High. Any current miner (17-21 on mainnet) can execute this attack immediately and repeatedly.

## Recommendation

Add miner list consistency validation in `RoundTerminateValidationProvider.ValidationForNextRound()`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate miner list consistency
    var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    if (!baseMiners.SequenceEqual(nextMiners))
        return new ValidationResult { Message = "NextRound miner list must match current round miner list." };
    
    return new ValidationResult { Success = true };
}
```

This ensures the miner list cannot be arbitrarily changed during normal round transitions. Legitimate miner list changes should only occur via `NextTerm` which properly integrates with the election contract.

## Proof of Concept

```csharp
[Fact]
public async Task MinerListManipulation_NextRound_ConsensusHijack()
{
    // Setup: Initialize consensus with legitimate miners [M1, M2, M3]
    var legitimateMiners = new[] { "M1_pubkey", "M2_pubkey", "M3_pubkey" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker: M1 crafts malicious NextRound with arbitrary miners [A1, A2, A3]
    var attackerPubkey = "M1_pubkey";
    var maliciousMiners = new[] { "A1_pubkey", "A2_pubkey", "A3_pubkey" };
    
    var currentRound = await GetCurrentRound();
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = CreateMinerInfo(maliciousMiners),
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute malicious NextRound transaction as M1
    var result = await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Malicious miner list is now active
    var newRound = await GetCurrentRound();
    newRound.RealTimeMinersInformation.Keys.ShouldBe(maliciousMiners);
    
    // Verify: Legitimate miners can no longer produce blocks
    foreach (var legitimateMiner in legitimateMiners.Except(new[] { attackerPubkey }))
    {
        var permission = await ValidateMiningPermission(legitimateMiner);
        permission.Success.ShouldBeFalse();
    }
    
    // Verify: Arbitrary miners can now produce blocks
    foreach (var maliciousMiner in maliciousMiners)
    {
        var permission = await ValidateMiningPermission(maliciousMiner);
        permission.Success.ShouldBeTrue();
    }
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-37)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
