# Audit Report

## Title
Missing UpdateValue Uniqueness Check Allows Mining Order Manipulation

## Summary
The consensus validation logic fails to verify whether a miner has already published their OutValue in the current round before accepting an UpdateValue transaction. This allows malicious miners to invoke UpdateValue multiple times within the same round with different InValues, repeatedly overwriting their signature to optimize their mining position in the next round, breaking the fairness of VRF-based mining order determination.

## Finding Description

The AEDPoS consensus mechanism expects each miner to call UpdateValue exactly once per round to commit their OutValue and Signature, which then determines their mining order in the next round. However, the validation logic contains a critical gap that allows this invariant to be violated.

**Root Cause:**

The validation flow in ValidateBeforeExecution [1](#0-0)  calls `RecoverFromUpdateValue` which overwrites the baseRound's OutValue with the provided value BEFORE validation occurs. The UpdateValueValidationProvider then only checks that the ProvidedRound contains non-empty values [2](#0-1) , but never verifies whether the ORIGINAL baseRound state (before recovery) already had OutValue set.

The RecoverFromUpdateValue method unconditionally overwrites the OutValue and Signature fields [3](#0-2) , destroying any evidence that these values were previously set.

**Expected Behavior:**

The consensus behavior logic expects OutValue to be null for the first block (UpdateValue behavior) and non-null for subsequent blocks (TinyBlock behavior) [4](#0-3) . An honest miner would receive UpdateValue behavior once, then TinyBlock for additional blocks in their time slot.

**Insufficient Protection:**

The only duplicate prevention is EnsureTransactionOnlyExecutedOnceInOneBlock [5](#0-4) , which prevents multiple consensus transactions per BLOCK but not per ROUND. Since miners can produce up to 8 blocks per time slot [6](#0-5) , they can call UpdateValue up to 8 times per round.

**Attack Execution:**

When ProcessUpdateValue executes, it unconditionally overwrites OutValue and Signature [7](#0-6) . A malicious miner can:
1. Produce block 1 with UpdateValue and InValue1 → generates Signature1
2. Produce block 2 with UpdateValue and InValue2 → overwrites to Signature2
3. Repeat up to 8 times, selecting the InValue that produces the optimal mining order

**Order Calculation:**

The signature directly determines mining order through modulo arithmetic [8](#0-7)  using the GetAbsModulus helper [9](#0-8) . The formula `(|signature| % minersCount) + 1` means different signatures produce different mining orders, allowing optimization through multiple attempts.

## Impact Explanation

**Consensus Integrity Compromise:**

This vulnerability breaks a fundamental security guarantee of the AEDPoS consensus mechanism: that mining order is determined fairly through VRF-based randomness that miners cannot manipulate after seeing the value. By allowing multiple UpdateValue calls, miners can:

- Calculate offline which InValue produces the most favorable mining order
- Effectively "reroll" their mining position up to 8 times per round
- Consistently achieve top mining positions (e.g., with 21 miners and 8 attempts, improve from average position 11 to position ~3)

**Network-Wide Effects:**

- Honest miners receive reduced mining opportunities and lower block rewards
- Attackers gain disproportionate influence over block production and transaction ordering
- Network decentralization degrades as rational miners adopt this strategy
- Long-term consensus security weakens as mining becomes predictably manipulable

**Economic Harm:**

The attack costs only standard transaction fees for additional blocks (minimal), while providing significant benefit through improved mining positions and higher rewards. This makes it economically rational for all miners to exploit, creating a tragedy-of-the-commons scenario where consensus fairness collapses.

## Likelihood Explanation

**Attacker Requirements:**

- Must be an authorized miner (realistic for blockchain validators)
- Must control block production during their time slot (inherent miner capability)
- No special privileges or compromised keys required

**Attack Complexity:**

The attack is straightforward:
1. Call GetConsensusExtraData [10](#0-9)  with UpdateValue behavior and different InValues for each block
2. The validation accepts all blocks as valid
3. Each execution overwrites the previous OutValue/Signature

No exploitation of complex race conditions, no need to compromise other nodes, and the attack path uses normal transaction execution.

**Detection:**

While the attack leaves visible on-chain evidence (multiple UpdateValue transactions from the same miner in one round), the current validation logic treats this as acceptable behavior. No automated detection or prevention mechanism exists.

## Recommendation

Add a check in ValidateBeforeExecution to verify that OutValue has not already been set before allowing UpdateValue behavior:

```csharp
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    // Store original OutValue before recovery
    var originalOutValue = baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()].OutValue;
    
    // Verify OutValue is not already set in this round
    if (originalOutValue != null && originalOutValue != Hash.Empty)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "OutValue already published in current round" 
        };
    }
    
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

This check must occur BEFORE RecoverFromUpdateValue modifies the baseRound, preserving the original state for validation.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy a test consensus contract with multiple miners
2. Have one miner produce their first block with UpdateValue behavior and InValue1
3. Verify their OutValue and Signature are set in state
4. Have the same miner produce a second block (within time slot) with UpdateValue behavior and InValue2
5. Observe that validation passes despite OutValue already being set
6. Verify the OutValue and Signature have been overwritten with new values
7. Calculate that different InValues produce different mining orders, confirming manipulation is possible

The test would validate that currently, step 4 succeeds when it should fail, and that step 6 shows state has been overwritten, confirming the vulnerability exists.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-56)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```
