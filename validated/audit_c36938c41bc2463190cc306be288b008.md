# Audit Report

## Title
Incorrect Factorial Array Initialization in Exp() Causes Systematic Bancor Pricing Errors

## Summary
The production `BancorHelper.cs` contains an off-by-one error in factorial array initialization that causes all token swaps with non-equal connector weights to use mathematically incorrect exponential calculations, resulting in systematically wrong pricing for all Buy() and Sell() operations.

## Finding Description

The vulnerability stems from a discrepancy between how the factorial array is initialized and how it is indexed during exponential calculations.

**Production Code Initialization:**
The static constructor initializes the factorial array by calling `DynFact(0)` through `DynFact(19)`, which produces factorials 0! through 19! stored at array indices 0-19. [1](#0-0) 

The `DynFact()` helper function computes factorial values where `DynFact(0)` returns 0!=1, `DynFact(1)` returns 1!=1, `DynFact(2)` returns 2!=2, etc. [2](#0-1) 

**Incorrect Usage in Exp():**
The `Exp()` function implements the exponential series exp(y) = 1 + y + y²/2! + y³/3! + ... and accesses the factorial array using `Fact[iteration - 1]`. [3](#0-2) 

This creates an off-by-one error:
- When iteration=20: Uses Fact[19] = 19! to compute y²⁰/19! (should be y²⁰/20!)
- When iteration=2: Uses Fact[1] = 1! to compute y²/1! (should be y²/2!)
- When iteration=n: Uses Fact[n-1] = (n-1)! to compute y^n/(n-1)! (should be y^n/n!)

**Correct Implementation in Test Code:**
The test version explicitly initializes the array with 1! through 20! at indices 0-19, making the same indexing pattern `Fact[iteration - 1]` retrieve the correct factorial values. [4](#0-3) 

**Affected Operations:**
Both `Buy()` and `Sell()` operations in the TokenConverter contract call Bancor pricing functions that use the buggy `Exp()` function. [5](#0-4) [6](#0-5) 

The `GetAmountToPayFromReturn()` and `GetReturnFromPaid()` functions only invoke `Exp()` when `wf != wt` (connector weights differ). [7](#0-6) [8](#0-7) 

Production configurations use non-equal weights: 0.5 for native token connectors and 0.005 for resource token connectors. [9](#0-8) [10](#0-9) 

## Impact Explanation

**Direct Economic Impact:**
Every token swap with non-equal connector weights receives incorrect pricing. The mathematical error systematically distorts exponential calculations, with each term y^n/n! being replaced by y^n/(n-1)!, effectively multiplying each term by n. For example:
- The y²/2! term becomes y²/1!, inflating it by 2x
- The y³/3! term becomes y³/2!, inflating it by 3x

This causes users to receive incorrect token amounts in both buy and sell operations.

**Reserve Imbalance:**
Accumulated pricing errors across many transactions lead to gradual deviation from the intended Bancor curve dynamics. The protocol's reserve balances will drift from their theoretical values, potentially causing insolvency or excessive accumulation over time.

**Arbitrage Vulnerability:**
If external systems or other implementations use correct Bancor formulas, the predictable pricing discrepancy creates an arbitrage opportunity where attackers can systematically extract value from the protocol by exploiting the pricing difference between the buggy implementation and correct pricing.

**Scope:**
All users performing token conversions through the TokenConverter contract are affected. Given that non-equal weights (0.5 vs 0.005) are standard in production deployments, this affects the majority of token swap operations.

## Likelihood Explanation

**High Likelihood:**
- No special permissions required - any user can call `Buy()` or `Sell()`
- The bug is always active for swaps with non-equal connector weights (wf ≠ wt)
- Production configurations use non-equal weights as the standard case (0.5 for native tokens, 0.005 for resource tokens)
- Every affected transaction automatically triggers the incorrect calculation
- No complex setup, timing requirements, or preconditions needed
- The error is deterministic and reproducible for every transaction

## Recommendation

Fix the factorial array initialization to match the test implementation. Change the static constructor to initialize the array with 1! through 20! instead of 0! through 19!:

```csharp
static BancorHelper()
{
    Fact = Array.AsReadOnly(Enumerable.Range(1, 20).Select(x => DynFact(x)).ToArray());
}
```

Alternatively, adjust the indexing in `Exp()` to use `Fact[iteration]` instead of `Fact[iteration - 1]`, but this would require expanding the array to include 20!.

## Proof of Concept

The following test demonstrates the discrepancy between production and test implementations when computing exponential values for Bancor pricing:

```csharp
[Fact]
public void ExponentialCalculation_ShowsOffByOneError()
{
    // Setup connectors with non-equal weights (production scenario)
    var fromConnector = new Connector { VirtualBalance = 1000000, Weight = "0.5" };
    var toConnector = new Connector { VirtualBalance = 100000, Weight = "0.005" };
    long paidAmount = 1000;
    
    // Call production BancorHelper
    var productionResult = ProductionBancorHelper.GetReturnFromPaid(
        fromConnector.VirtualBalance, 
        decimal.Parse(fromConnector.Weight),
        toConnector.VirtualBalance, 
        decimal.Parse(toConnector.Weight),
        paidAmount);
    
    // Call test BancorHelper (correct implementation)
    var testResult = TestBancorHelper.GetReturnFromPaid(
        fromConnector.VirtualBalance, 
        decimal.Parse(fromConnector.Weight),
        toConnector.VirtualBalance, 
        decimal.Parse(toConnector.Weight),
        paidAmount);
    
    // Results will differ due to factorial array initialization error
    productionResult.ShouldNotBe(testResult);
}
```

This test will fail because the production implementation uses incorrect factorials in the exponential series calculation, while the test implementation uses correct factorials.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L11-14)
```csharp
    static BancorHelper()
    {
        Fact = Array.AsReadOnly(Enumerable.Range(0, 20).Select(x => DynFact(x)).ToArray());
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L16-21)
```csharp
    private static long DynFact(long number)
    {
        var fact = number == 0 ? 1 : number;
        for (var i = number - 1; i >= 1; i--) fact *= i;
        return fact;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-53)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/BancorHelper.cs (L78-102)
```csharp
    private static readonly long[] Fact =
    {
        1L,
        1L * 2,
        1L * 2 * 3,
        1L * 2 * 3 * 4,
        1L * 2 * 3 * 4 * 5,
        1L * 2 * 3 * 4 * 5 * 6,
        1L * 2 * 3 * 4 * 5 * 6 * 7,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20
        //14197454024290336768L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21,        // NOTE: Overflow during compilation
        //17196083355034583040L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21 * 22    // NOTE: Overflow during compilation
    };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L217-224)
```csharp
            new()
            {
                Symbol = Context.Variables.NativeSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L230-239)
```csharp
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
```
