# Audit Report

## Title
Evil Miners Continue Block Production After Being Banned Until Next Round Transition

## Summary
When a miner is marked as evil through `UpdateCandidateInformation(IsEvilNode=true)`, the Election contract updates its `BannedPubkeyMap` but the Consensus contract does not immediately remove the miner from the current round's active miner list. The evil miner can continue producing blocks until the next round transition, creating a vulnerability window where consensus integrity is compromised.

## Finding Description

When an evil node is detected (either through automatic detection when missed time slots exceed the threshold, or through governance action via `RemoveEvilNode`), the `UpdateCandidateInformation()` method in the Election contract is called with `IsEvilNode=true`. This sets `State.BannedPubkeyMap[input.Pubkey] = true` and removes the candidate from the Election contract's state. [1](#0-0) 

However, this update to the Election contract does NOT immediately affect the Consensus contract's current round state. The banned miner remains in the current round's `RealTimeMinersInformation` map, which is the authoritative list used for block production validation.

The Consensus contract's `PreCheck()` method only verifies that a miner exists in the current or previous round's miner list, without checking the banned status: [2](#0-1) 

The `IsInMinerList()` method simply checks membership in `RealTimeMinersInformation`: [3](#0-2) 

Similarly, the `MiningPermissionValidationProvider` used during block header validation only checks the `RealTimeMinersInformation` keys: [4](#0-3) 

The `BannedPubkeyMap` is ONLY checked during round transitions when `GenerateNextRoundInformation()` calls `GetMinerReplacementInformation()`: [5](#0-4) 

The Election contract's `GetEvilMinersPubkeys()` filters miners by checking the `BannedPubkeyMap`: [6](#0-5) 

This check only happens during next round generation when `GetConsensusExtraDataForNextRound()` is called: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation**: The core security guarantee of AEDPoS consensus is that only authorized, non-malicious miners can produce blocks. This vulnerability breaks that invariant by allowing banned miners to continue participating after being officially marked as evil.

**Time Window**: The vulnerability window extends from the moment `UpdateCandidateInformation(IsEvilNode=true)` is called until the next round transition occurs. Since AElf rounds contain one time slot per active miner, this window can encompass multiple blocks.

**Reward Misallocation**: The evil miner continues earning block production rewards during this window. The `DonateMiningReward()` method calculates rewards based on total blocks produced in the round, which includes blocks produced by the evil miner after being banned: [8](#0-7) 

**Attack Opportunities**: During the vulnerability window, the evil miner can:
- Continue producing blocks with full consensus authority
- Include or exclude specific transactions (censorship)
- Potentially coordinate with other compromised nodes
- Undermine network security while officially banned

**Affected Parties**: All network participants are affected as the consensus mechanism's security guarantees are compromised.

## Likelihood Explanation

**Reachable Entry Points**: The vulnerability can be triggered through two realistic paths:

1. Automatic detection when `ProcessNextRound()` detects miners exceeding the missed time slot threshold: [9](#0-8) 

2. Governance action via `RemoveEvilNode()` by the emergency response organization: [10](#0-9) 

**Feasible Preconditions**: 
- A node is currently an active miner in the current round's miner list
- The node is detected as evil or reported through governance
- Standard protocol operation

**Execution Practicality**: The vulnerability occurs automatically once the conditions are met. No special attacker capabilities are required beyond being a current miner who gets detected as evil. The evil miner simply continues their normal block production until the round naturally ends.

**Attack Complexity**: Low - this is an inherent design issue in the separation between the Election and Consensus contracts. Once a miner is marked as evil, they automatically continue producing blocks without any additional action.

**Detection**: The evil behavior that triggered the banning may be detected, but the continued block production during the vulnerability window appears legitimate from a consensus validation perspective since the miner remains in `RealTimeMinersInformation`.

## Recommendation

Implement immediate removal of banned miners from the Consensus contract's current round state when `UpdateCandidateInformation(IsEvilNode=true)` is called:

1. Add a cross-contract call from Election contract to Consensus contract to immediately remove the evil miner from `RealTimeMinersInformation`
2. Alternatively, modify block validation to check both `RealTimeMinersInformation` AND `BannedPubkeyMap` (via Election contract call) before allowing block production
3. Add validation in `PreCheck()` and `MiningPermissionValidationProvider` to query the Election contract's `BannedPubkeyMap` before accepting blocks from any miner

The fix should ensure that once a miner is marked as evil, they cannot produce any more blocks in the current round, not just in the next round.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a network with multiple miners
2. Have one miner miss enough time slots to trigger automatic evil detection OR call `RemoveEvilNode()` via governance
3. Verify that `BannedPubkeyMap[evilMiner] = true` in Election contract
4. Verify that the evil miner is still in `currentRound.RealTimeMinersInformation` in Consensus contract
5. Show that the evil miner can still produce blocks successfully before the round transition
6. Verify that the mining rewards include blocks produced by the evil miner after being marked as evil
7. Confirm that only after the round transition is the evil miner removed from the active miner list

## Notes

This is a time-of-check to time-of-use (TOCTOU) vulnerability in the consensus mechanism. The Election contract updates its view of banned miners, but the Consensus contract continues to use stale round information until the next round transition. This architectural separation creates a security gap where banned miners retain full consensus authority temporarily.

The vulnerability is particularly concerning because:
- It's automatically exploitable without requiring attacker action
- The evil miner retains full block production authority during the window
- Network participants have no way to prevent the evil miner from producing blocks during this period
- The evil miner continues earning rewards for this unauthorized participation

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-342)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
