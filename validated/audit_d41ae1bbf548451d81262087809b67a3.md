# Audit Report

## Title
RemoveSubScheme Fails to Update CachedDelayTotalShares Leading to Profit Misallocation

## Summary
The `RemoveSubScheme` function in ProfitContract does not update the `CachedDelayTotalShares` map when removing a sub-scheme, unlike the analogous `RemoveBeneficiary` function. This inconsistency causes stale cached share values to persist during profit distribution in schemes with delayed distribution enabled (`DelayDistributePeriodCount > 0`), resulting in legitimate beneficiaries receiving less than their entitled share of profits due to inflated total shares calculations.

## Finding Description

The vulnerability stems from an implementation inconsistency between two related functions in the Profit contract.

**The Vulnerable Function - RemoveSubScheme:** [1](#0-0) 

This function removes a sub-scheme by clearing profit details, removing from the SubSchemes list, and updating TotalShares, but critically **does NOT update CachedDelayTotalShares**.

**The Correct Implementation - RemoveBeneficiary:** [2](#0-1) 

This function properly handles delayed distribution by iterating through affected cached periods and subtracting the removed shares from each cached entry.

**How Delayed Distribution Works:**

When `DistributeProfits` is called for a scheme with `DelayDistributePeriodCount > 0`, it caches the current `TotalShares` for future periods: [3](#0-2) 

The cached `totalShares` value is stored in `DistributedProfitsInfo.TotalShares`: [4](#0-3) 

When beneficiaries claim profits, this stored `TotalShares` is used as the denominator in the profit calculation: [5](#0-4) 

**Why AddSubScheme Also Participates:**

When adding a sub-scheme, the function internally calls `AddBeneficiary`: [6](#0-5) 

This means when a sub-scheme is added, its shares are cached for future periods. When removed via `RemoveSubScheme`, the cached values are NOT updated, leaving stale inflated totals.

**Production Impact - TreasuryContract:**

The TreasuryContract creates the Welfare scheme with delayed distribution enabled: [7](#0-6) 

The TreasuryContract uses `RemoveSubScheme` in its `ResetWeight` function to adjust sub-scheme allocations: [8](#0-7) 

Additional production usage occurs in weight update functions: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Direct Financial Impact:**

When a sub-scheme is added and subsequently removed before the delayed period arrives:

1. **Period N**: Sub-scheme added with X shares → `TotalShares` increases, cached as `CachedDelayTotalShares[N + DelayDistributePeriodCount]`
2. **Period N**: `DistributeProfits` called → caches the inflated total (including X shares)
3. **Period N+1**: Sub-scheme removed → `TotalShares` decreases, but cached value remains unchanged
4. **Period N+DelayDistributePeriodCount**: Distribution uses the stale cached value with inflated denominator
5. **Result**: Each beneficiary receives `(theirShares / inflatedTotal) * amount` instead of `(theirShares / actualTotal) * amount`

**Quantified Example:**
- Initial state: 100 shares from regular beneficiaries, `DelayDistributePeriodCount = 1`
- Period 1: Add sub-scheme with 100 shares → `TotalShares = 200`, `CachedDelayTotalShares[2] = 200`
- Period 1: Distribute 1000 ELF
- Period 2: Remove sub-scheme → `TotalShares = 100`, but `CachedDelayTotalShares[2]` still `= 200`
- Period 2: Distribution uses cached `totalShares = 200`
- **Impact**: Beneficiaries with 100 shares receive only 500 ELF (100/200 × 1000) instead of 1000 ELF
- **Loss**: 50% underpayment to legitimate beneficiaries, 500 ELF permanently locked

The unclaimed portion cannot be recovered because no beneficiary has sufficient shares to claim it under the inflated denominator calculation.

## Likelihood Explanation

**Triggering Conditions:**

1. **Scheme Configuration**: Requires `DelayDistributePeriodCount > 0` - confirmed in production (TreasuryContract Welfare scheme)
2. **Manager Permissions**: Requires scheme manager authority for `AddSubScheme`/`RemoveSubScheme` - this is by design
3. **Operational Sequence**: Normal operations like weight rebalancing via `ResetWeight` can trigger this

**Realistic Scenarios:**

1. **Legitimate Operations**: TreasuryContract's `ResetWeight` function legitimately calls `RemoveSubScheme` to adjust reward distribution weights between schemes. If this occurs during a delayed distribution period, the bug triggers automatically.

2. **Governance Changes**: Protocol governance may decide to adjust sub-scheme allocations for economic policy reasons, inadvertently triggering the vulnerability.

3. **No Detection**: The issue is silent - no transaction reverts, no events indicate the problem. Beneficiaries only discover underpayment when they claim and notice the shortfall.

**Probability Assessment:**

This is not a malicious attack scenario but rather a **logic bug that occurs during legitimate operations**. The TreasuryContract demonstrates this functionality is actively used in production. The probability is MEDIUM-HIGH given:
- Production code uses both features together (delayed distribution + RemoveSubScheme)
- No warnings or checks prevent this scenario
- Can happen accidentally during routine adjustments

## Recommendation

The `RemoveSubScheme` function should update `CachedDelayTotalShares` similar to how `RemoveBeneficiary` handles it. After line 152 in ProfitContract.cs, add the following logic:

```csharp
// Update cached delay total shares
if (scheme.DelayDistributePeriodCount > 0)
{
    for (var removedPeriod = scheme.CurrentPeriod;
         removedPeriod < scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
         removedPeriod++)
    {
        if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
        {
            scheme.CachedDelayTotalShares[removedPeriod] =
                scheme.CachedDelayTotalShares[removedPeriod].Sub(shares.Shares);
        }
    }
}
```

This ensures consistency between `RemoveSubScheme` and `RemoveBeneficiary`, preventing stale cached values from persisting.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveSubScheme_DoesNotUpdate_CachedDelayTotalShares_Test()
{
    const int delayDistributePeriodCount = 1;
    const int subSchemeShares = 100;
    const int beneficiaryShares = 100;
    
    var creator = Creators[0];
    
    // Create parent scheme with delayed distribution
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = delayDistributePeriodCount
    });
    
    var parentSchemeId = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creator.GetAddress() })).SchemeIds.First();
    
    // Create sub-scheme
    await creator.CreateScheme.SendAsync(new CreateSchemeInput());
    var subSchemeId = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creator.GetAddress() })).SchemeIds.Last();
    
    // Add beneficiary with 100 shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = parentSchemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = Accounts[0].Address,
            Shares = beneficiaryShares
        }
    });
    
    // Add sub-scheme with 100 shares
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = subSchemeShares
    });
    
    // Period 1: Distribute profits - this caches TotalShares=200 for period 2
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Symbol = "ELF",
        Amount = 1000
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Period = 1,
        AmountsMap = { { "ELF", 0 } }
    });
    
    // Remove sub-scheme - TotalShares becomes 100, but cached value stays 200
    await creator.RemoveSubScheme.SendAsync(new RemoveSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subSchemeId
    });
    
    var schemeAfterRemoval = await creator.GetScheme.CallAsync(parentSchemeId);
    schemeAfterRemoval.TotalShares.ShouldBe(beneficiaryShares); // 100
    
    // Period 2: Distribute - uses stale cached value of 200
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Symbol = "ELF",
        Amount = 1000
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Period = 2,
        AmountsMap = { { "ELF", 0 } }
    });
    
    // Check distributed info - TotalShares should be 100 but will be 200 (BUG)
    var distributedInfo = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
    {
        SchemeId = parentSchemeId,
        Period = 2
    });
    
    // This assertion will FAIL, proving the bug
    distributedInfo.TotalShares.ShouldBe(200); // Should be 100, but is 200 due to bug
    
    // Beneficiary will receive only 500 ELF instead of 1000 ELF
    // (100/200 * 1000 = 500 instead of 100/100 * 1000 = 1000)
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-257)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L868-874)
```csharp
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-68)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L520-540)
```csharp
    private void ResetWeight(Hash parentSchemeId, Hash subSchemeId, int oldWeight,
        int newWeight)
    {
        if (oldWeight == newWeight)
            return;

        // old weight equals 0 indicates the subScheme has not been registered
        if (oldWeight > 0)
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });

        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = parentSchemeId,
            SubSchemeId = subSchemeId,
            SubSchemeShares = newWeight
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L858-862)
```csharp
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L895-904)
```csharp
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.WelfareHash.Value
        });
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
```
