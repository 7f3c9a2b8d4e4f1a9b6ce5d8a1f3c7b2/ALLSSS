# Audit Report

## Title
Missing Validation Allows Consensus DoS via Zero FinalOrderOfNextRound Values

## Summary
The `ProcessUpdateValue` method accepts arbitrary `SupposedOrderOfNextRound` and `TuneOrderInformation` values without validation, allowing malicious miners to write invalid order values (including 0) to consensus state. While `NextRoundMiningOrderValidationProvider` detects this corruption during round transitions, the invalid data has already been persisted, creating an unrecoverable denial-of-service condition that permanently blocks round progression.

## Finding Description

The vulnerability exists in the consensus state update flow where miners submit `UpdateValueInput` data during block production.

**Root Cause - Missing Input Validation:**

In `ProcessUpdateValue`, user-controlled values from `UpdateValueInput` are directly assigned to consensus state without range validation: [1](#0-0) 

The `TuneOrderInformation` dictionary allows arbitrary key-value pairs to overwrite any miner's `FinalOrderOfNextRound`: [2](#0-1) 

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are non-null/non-empty, and that `PreviousInValue` matches the hash of the previous `OutValue`. It does NOT validate order values: [3](#0-2) 

**Detection at NextRound (Too Late):**

The `NextRoundMiningOrderValidationProvider` validates that the count of miners with `FinalOrderOfNextRound > 0` equals the count with non-null `OutValue`: [4](#0-3) 

However, this validation only runs for `NextRound` behavior, not for `UpdateValue`: [5](#0-4) 

**Expected vs Actual Behavior:**

By design, `ApplyNormalConsensusData` calculates order values in the valid range [1, minersCount]: [6](#0-5) 

The `GetAbsModulus` function ensures non-negative results: [7](#0-6) 

However, miners control the `UpdateValueInput` they submit via the public `UpdateValue` method: [8](#0-7) 

The only access control is that the sender must be in the miner list: [9](#0-8) 

**Attack Execution:**

A malicious miner can craft an `UpdateValueInput` with invalid order values when producing their block. Since they control the block production during their time slot, they can include a crafted `UpdateValue` transaction with:
- Their own `SupposedOrderOfNextRound = 0`
- `TuneOrderInformation` entries setting other miners' `FinalOrderOfNextRound = 0`

These invalid values bypass validation and get written to state. When any miner attempts `NextRound`, validation fails because miners have `FinalOrderOfNextRound = 0` but non-null `OutValue`, permanently blocking round transitions.

## Impact Explanation

**Complete Consensus Halt:**
- Once invalid `FinalOrderOfNextRound` values are written to state, all subsequent `NextRound` attempts fail validation
- The blockchain cannot progress to the next round
- Block production halts completely
- All network participants experience service interruption
- DApps and users cannot submit transactions
- Economic activity on the chain stops entirely

**No Built-In Recovery:**

The `SupplyCurrentRoundInformation` method called before `NextRound` only fills missing `InValue`/`Signature` data - it does not fix corrupted `FinalOrderOfNextRound` values: [10](#0-9) 

Recovery would require governance intervention or chain restart.

**Severity:** High - Complete denial of service of consensus mechanism with no automatic recovery path.

## Likelihood Explanation

**Attack Feasibility:**
- **Entry Point:** Public `UpdateValue` method accessible to all miners
- **Access Control:** Only requires being in the miner list (miners are not trusted roles per threat model)
- **Technical Complexity:** Low - malicious miner modifies node software to generate invalid `UpdateValueInput`
- **Collusion Requirement:** Single malicious miner can execute when producing their block

**Attack Sequence:**
1. Malicious miner waits for their turn to produce a block
2. Malicious miner crafts `UpdateValueInput` with:
   - `SupposedOrderOfNextRound = 0`
   - `TuneOrderInformation` containing entries with value 0
3. Transaction passes validation (only `OutValue`/`Signature` checked)
4. Invalid values written to consensus state
5. All subsequent `NextRound` attempts fail validation
6. Chain halted

**Overall Likelihood:** Medium - Practical to execute with single malicious miner during their block production time slot.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values are within valid range [1, minersCount]:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate order values are in valid range [1, minersCount]
    Assert(updateValueInput.SupposedOrderOfNextRound > 0 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid SupposedOrderOfNextRound value.");
    
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount,
               $"Invalid FinalOrderOfNextRound value for miner {tuneOrder.Key}.");
    }
    
    // ... rest of method
}
```

Alternatively, add order validation to `UpdateValueValidationProvider` to check these values during the validation phase.

## Proof of Concept

A test demonstrating the vulnerability would:
1. Deploy AEDPoS contract with test miners
2. Have one miner call `UpdateValue` with crafted input containing `SupposedOrderOfNextRound = 0`
3. Verify the invalid value is written to state
4. Attempt `NextRound` and verify it fails with "Invalid FinalOrderOfNextRound" validation error
5. Demonstrate that subsequent `NextRound` attempts continue to fail, proving permanent DoS

The vulnerability is confirmed by the lack of validation in the identified code paths and the architectural design where validation occurs after state corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```
