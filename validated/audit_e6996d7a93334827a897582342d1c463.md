# Audit Report

## Title
Duplicate Mining Order Validation Bypass Allows Consensus Disruption Through Time Slot Collisions

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method incorrectly validates uniqueness of `FinalOrderOfNextRound` values by calling `Distinct()` on `MinerInRound` objects rather than on the order values themselves. This allows a malicious miner to assign duplicate `FinalOrderOfNextRound` values to multiple miners, causing them to be scheduled for the same time slot in the next round, breaking the fundamental consensus invariant that each time slot has exactly one designated miner.

## Finding Description

### Core Validation Bug

The validation logic contains a critical flaw in how it checks for distinct mining orders. [1](#0-0) 

The code calls `Distinct()` on a collection of `MinerInRound` objects. Since `MinerInRound` is a protobuf-generated class [2](#0-1)  where each instance has a unique `Pubkey` field, the `Distinct()` method treats all miners as distinct even if they have identical `FinalOrderOfNextRound` values. Protobuf classes use field-by-field equality comparison, so two `MinerInRound` objects with different `Pubkey` values are never equal regardless of other field values.

The correct validation should extract order values first: `.Select(m => m.FinalOrderOfNextRound).Distinct().Count()`

### Attack Vectors

A miner can manipulate `FinalOrderOfNextRound` values through two mechanisms during `UpdateValue` behavior:

**Vector 1:** Direct assignment via `SupposedOrderOfNextRound` in `UpdateValueInput`. [3](#0-2)  The `ProcessUpdateValue` method directly applies this value without validation. [4](#0-3) 

**Vector 2:** Modification of other miners' values via `TuneOrderInformation` map in `UpdateValueInput`. [5](#0-4)  This dictionary is applied directly to update each miner's `FinalOrderOfNextRound`. [6](#0-5) 

The `UpdateValueValidationProvider` does not validate these fields, only checking `OutValue`, `Signature`, and `PreviousInValue`. [7](#0-6)  Additionally, when validation is configured for UpdateValue behavior, the `NextRoundMiningOrderValidationProvider` is not included in the validation chain. [8](#0-7) 

### Consequence in Next Round Generation

When `GenerateNextRoundInformation()` transitions to the next round, it directly assigns `FinalOrderOfNextRound` as the miner's `Order` and calculates `ExpectedMiningTime` based on this order. [9](#0-8) 

Multiple miners with the same `FinalOrderOfNextRound` receive identical `Order` values and identical `ExpectedMiningTime` values (calculated by multiplying the order by the mining interval). This violates the core consensus invariant that each time slot has exactly one designated miner.

## Impact Explanation

**Consensus Integrity Violation:** This vulnerability directly breaks the fundamental invariant that each time slot has exactly one designated miner. Multiple miners become authorized to produce blocks at the same `ExpectedMiningTime`, creating:

1. **Competing Valid Blocks:** Both miners can produce valid blocks at the same height and timestamp, causing fork conditions
2. **Chain Instability:** The network must resolve which block to accept, potentially requiring manual intervention  
3. **Consensus Disruption:** Predictable block production schedule is broken, affecting all applications relying on deterministic timing
4. **Potential Double-Spend Window:** During fork resolution, transaction finality is compromised

**Severity: HIGH** - Directly compromises consensus protocol integrity without requiring token stake, governance privileges, or cryptographic attacks. The attack breaks a critical safety property of the consensus mechanism.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner (one of the authorized block producers in the current round)
- Must produce a block with `UpdateValue` behavior during their designated time slot
- Can craft malicious `UpdateValueInput` with duplicate order assignments

**Attack Complexity: LOW**
1. Being selected as a miner is part of normal network participation
2. Requires producing a single block with crafted `UpdateValueInput` containing:
   - Valid `OutValue` and `Signature` (to pass validation)
   - `SupposedOrderOfNextRound` = X (for attacker)  
   - `TuneOrderInformation[victim_pubkey]` = X (for victim)
3. No validation prevents these duplicate values from being processed
4. No economic cost beyond normal mining operations

**Feasibility: HIGH** - The validation bypass is deterministic. The `NextRoundMiningOrderValidationProvider` will count two distinct `MinerInRound` objects (different pubkeys) as valid even though they have the same `FinalOrderOfNextRound` value. Any malicious miner can execute this attack during their mining slot.

## Recommendation

Fix the validation logic in `NextRoundMiningOrderValidationProvider` to check distinctness of order values rather than object distinctness:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract order values
    .Distinct()
    .Count();
```

Additionally, add validation in `UpdateValueValidationProvider` to verify that `SupposedOrderOfNextRound` matches the calculated value from the signature, and validate that any `TuneOrderInformation` entries are legitimate conflict resolutions.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a round with multiple miners
2. Have miner M1 produce an `UpdateValue` block with:
   - Valid `OutValue` and `Signature` 
   - `SupposedOrderOfNextRound` = 1
   - `TuneOrderInformation[M2.Pubkey]` = 1
3. Verify the transaction is accepted (passes `UpdateValueValidationProvider`)
4. Trigger `NextRound` behavior
5. Verify the next round has both M1 and M2 with `Order` = 1 and identical `ExpectedMiningTime`
6. Demonstrate that the validation passes despite the duplicate orders due to the `Distinct()` bug

The test would confirm that the consensus invariant (one miner per time slot) is violated.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L206-206)
```text
    int32 supposed_order_of_next_round = 6;
```

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L268-301)
```text
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L13-19)
```csharp
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
