# Audit Report

## Title
Hex String Case Sensitivity Bypass in Consensus Round Transitions Enables Complete Blockchain Halt

## Summary
The AEDPoS consensus contract fails to normalize hexadecimal string casing when processing `NextRoundInput`, allowing an authorized miner to inject uppercase public key strings into the round state. This causes a fatal mismatch with the lowercase keys produced by the `ToHex()` method, permanently blocking all subsequent miners from mining and halting consensus indefinitely.

## Finding Description

The vulnerability arises from a case sensitivity mismatch in the consensus round transition logic. The `ToHex()` extension method deterministically produces lowercase hexadecimal strings by adding `0x20` to convert uppercase ASCII values to lowercase. [1](#0-0) 

When miners produce blocks, their public keys are recovered and converted to hex strings using this method, guaranteeing lowercase output in both transaction processing and validation contexts. [2](#0-1) [3](#0-2) 

The `NextRound` method is publicly accessible and accepts `NextRoundInput` containing a protobuf map of miner public keys to miner information. [4](#0-3) [5](#0-4) 

The `NextRoundInput.ToRound()` method performs a direct field copy without any case normalization. [6](#0-5) 

The authorization check in `PreCheck()` validates the sender's recovered public key (lowercase) against the current round's miner list, but does not validate the public key strings within the incoming `NextRoundInput`. [7](#0-6) 

After passing authorization, `ProcessNextRound` stores the new round directly without case normalization. [8](#0-7) [9](#0-8) 

### Attack Execution Path

1. **Attacker prerequisites**: Attacker controls a current miner (has a legitimate slot in the current round with lowercase pubkey)
2. **Malicious transaction**: Attacker crafts a `NextRoundInput` with uppercase public key strings instead of the standard lowercase format
3. **Authorization bypass**: `PreCheck()` validates the attacker's recovered pubkey (lowercase) against current round (lowercase) - passes âœ“
4. **Validation bypass**: No validator checks pubkey case in the incoming round data
5. **State corruption**: New round is stored with uppercase public keys
6. **Consensus failure**: When any miner attempts to produce blocks, the `MiningPermissionValidationProvider` performs case-sensitive validation before block execution

The `IsInMinerList()` method performs case-sensitive dictionary key lookup. [10](#0-9) 

The mining permission validator performs case-sensitive key lookup during the pre-execution validation phase, causing all miners to be rejected. [11](#0-10) [12](#0-11) 

Additionally, `GetMinerReplacementInformation` in the Election contract uses case-sensitive `Contains()` checks that would fail to properly filter miners if case mismatches occur. [13](#0-12) 

## Impact Explanation

**Critical Severity - Complete Blockchain Halt**

This vulnerability enables a single malicious or compromised miner to permanently halt the entire blockchain. Once uppercase public keys are stored in a round:

1. **Immediate consensus DoS**: All miners (including the attacker) are locked out because their recovered public keys (lowercase) don't match the stored uppercase keys during the pre-execution validation phase
2. **Irreversible without hard fork**: The corrupted round state is committed to the blockchain. Normal operations cannot recover since no miner can pass the `ValidateBeforeExecution` check
3. **No automatic recovery**: Unlike temporary network issues, this is a persistent state corruption that breaks the fundamental consensus mechanism
4. **Affects all chain operations**: Token transfers, contract calls, governance - everything stops when blocks stop being produced

The attack breaks the core security guarantee of consensus availability and violates the invariant that authorized miners in the current round can produce blocks in the next round.

## Likelihood Explanation

**High Likelihood of Exploitation**

**Attacker Requirements:**
- Must be an authorized miner in the current round (moderate barrier)
- Must be able to craft custom transactions with uppercase hex strings in protobuf maps (trivial for any miner)
- Must wait for their designated time slot (guaranteed in normal operation)

**Attack Complexity:** Very Low
- Requires only changing hex string casing in a single transaction
- No sophisticated cryptography, timing attacks, or race conditions
- Standard transaction submission through normal node RPC

**Feasibility Scenarios:**
1. **Compromised miner keys**: If an attacker gains control of any miner's private key, they can execute this attack
2. **Malicious insider**: A validator with malicious intent can trivially DOS their own chain
3. **Software bugs**: A buggy mining client that accidentally uses uppercase hex strings would trigger this
4. **Cross-chain incentive misalignment**: In multi-chain scenarios, attacking one chain might benefit another

**Detection:**
The attack would be immediately obvious (consensus stops), but by then it's too late - the corrupted state is already committed to the blockchain.

While the economic rationality of a miner attacking their own chain is questionable, the defense-in-depth principle mandates that the code should validate and normalize user inputs regardless of trust assumptions. The trivial attack complexity and catastrophic impact make this a critical vulnerability.

## Recommendation

Implement case normalization for all public key strings in the consensus contract:

1. **Input Normalization**: Add validation in `ProcessNextRound` and `ProcessNextTerm` to normalize all pubkey strings to lowercase before storing:
```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Normalize all pubkey strings to lowercase
    var normalizedMiners = new Dictionary<string, MinerInRound>();
    foreach (var miner in nextRound.RealTimeMinersInformation)
    {
        var normalizedKey = miner.Key.ToLower();
        var minerInfo = miner.Value;
        minerInfo.Pubkey = normalizedKey;
        normalizedMiners[normalizedKey] = minerInfo;
    }
    nextRound.RealTimeMinersInformation.Clear();
    nextRound.RealTimeMinersInformation.Add(normalizedMiners);
    
    // Also normalize extra block producer
    if (!string.IsNullOrEmpty(nextRound.ExtraBlockProducerOfPreviousRound))
        nextRound.ExtraBlockProducerOfPreviousRound = nextRound.ExtraBlockProducerOfPreviousRound.ToLower();
    
    // Continue with existing logic...
    RecordMinedMinerListOfCurrentRound();
    // ...
}
```

2. **Add Validation**: Add an assertion to ensure all keys match the expected format:
```csharp
private void ValidateRoundPubkeyFormat(Round round)
{
    foreach (var key in round.RealTimeMinersInformation.Keys)
    {
        Assert(key == key.ToLower(), $"Invalid pubkey format: {key}. All pubkeys must be lowercase hex strings.");
    }
}
```

3. **ToRound() Enhancement**: Modify `NextRoundInput.ToRound()` and `NextTermInput.ToRound()` to normalize keys during conversion.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task ConsensusHalt_ViaUppercasePubkeyInjection()
{
    // Setup: Initialize chain with 3 miners in lowercase format
    var initialMiners = new[] { "miner1pubkey", "miner2pubkey", "miner3pubkey" };
    await InitializeConsensusWithMiners(initialMiners);
    
    // Attacker: miner1 (authorized in current round)
    var attacker = "miner1pubkey";
    
    // Craft malicious NextRoundInput with UPPERCASE pubkeys
    var maliciousNextRound = new NextRoundInput();
    maliciousNextRound.RoundNumber = 2;
    foreach (var miner in initialMiners)
    {
        var uppercaseKey = miner.ToUpper(); // "MINER1PUBKEY", etc.
        maliciousNextRound.RealTimeMinersInformation[uppercaseKey] = new MinerInRound
        {
            Pubkey = uppercaseKey,
            Order = 1,
            // ... other fields
        };
    }
    
    // Execute attack: Call NextRound as authorized miner
    var result = await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes PreCheck
    
    // Verify state corruption: Round 2 now has uppercase keys
    var storedRound = await ConsensusContract.GetRoundInformation.CallAsync(new Int64Value { Value = 2 });
    storedRound.RealTimeMinersInformation.Keys.First().ShouldBe("MINER1PUBKEY"); // Uppercase stored
    
    // Attempt block production: ANY miner tries to produce a block
    var blockProducerPubkey = "miner2pubkey"; // Recovered as lowercase
    
    // ValidateBeforeExecution will be called (simulation)
    var baseRound = storedRound; // Has uppercase keys
    var senderPubkey = blockProducerPubkey; // Lowercase from ToHex()
    
    // MiningPermissionValidationProvider check:
    var isAuthorized = baseRound.RealTimeMinersInformation.Keys.Contains(senderPubkey);
    isAuthorized.ShouldBe(false); // FAILS: "miner2pubkey" not in {"MINER1PUBKEY", "MINER2PUBKEY", "MINER3PUBKEY"}
    
    // Result: Block rejected, consensus halted permanently
}
```

## Notes

This vulnerability demonstrates a critical defense-in-depth failure where input validation is missing for user-controlled string data. The protobuf `map<string, MinerInRound>` structure accepts any string as a key, but the consensus logic assumes all keys are lowercase. This mismatch creates a trivial attack vector for authorized miners to permanently DOS the blockchain.

The fix requires normalizing all pubkey strings to lowercase during round transitions, ensuring consistency between stored state and runtime-recovered public keys.

### Citations

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** protobuf/aedpos_contract.proto (L34-34)
```text
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-75)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L374-390)
```csharp
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
```
