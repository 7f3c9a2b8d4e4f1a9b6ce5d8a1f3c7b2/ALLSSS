# Audit Report

## Title
Insufficient Recharge Validation Allows Side Chain to Immediately Fall Back Into Debt

## Summary
The `Recharge` function contains a critical mathematical error in its validation logic that double-counts the recharge amount. This allows side chains to be recharged with insufficient funds (as little as `arrears + indexingPrice/2` instead of the required `arrears + indexingPrice`), causing the chain to immediately fall back into `IndexingFeeDebt` status upon the next block indexing operation, resulting in direct fund loss for rechargers and preventing proper chain reactivation.

## Finding Description

The vulnerability exists in the `Recharge` function's validation assertion. [1](#0-0) 

**Execution Flow Analysis:**

1. The function first transfers the recharge amount from the sender to the side chain's virtual address. [2](#0-1) 

2. If the chain is in debt status, all arrears are paid out from the chain's virtual address to the creditors. [3](#0-2) 

3. The `originBalance` is fetched AFTER arrears have been paid. [4](#0-3) 

4. The flawed assertion validates: `input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice`. [5](#0-4) 

**Mathematical Analysis:**

Let R = recharge amount, A = total arrears, P = IndexingPrice, B = initial balance.

- After step 1: balance = B + R
- After step 2: balance = B + R - A  
- At step 3: originBalance = B + R - A
- At step 4: Assert R + (B + R - A) >= A + P

Simplifying: 2R + B - A >= A + P â†’ 2R + B >= 2A + P

For a fully drained chain (B = 0): **R >= A + P/2**

**Correct Requirement:** After paying arrears, the remaining balance must cover at least one indexing operation: (B + R - A) >= P, therefore R >= A + P - B. For B = 0: **R >= A + P**.

The flawed assertion effectively double-counts the recharge amount by adding it to `originBalance`, which already includes it.

**Consequence in Subsequent Indexing:**

When `IndexSideChainBlockData` is called after a successful recharge, it determines the locked token amount based on chain status. [6](#0-5) 

Since `Recharge` sets the status to `Active`, [7](#0-6)  the next indexing operation fetches the actual balance (which would be P/2 for a minimal recharge scenario).

When indexing a block, the indexing price is deducted from locked tokens. [8](#0-7) 

If the result is negative, new arrears are created and the chain status reverts to `IndexingFeeDebt`. [9](#0-8) 

## Impact Explanation

This vulnerability has **HIGH** severity impact:

**Direct Financial Loss:**
- Rechargers lose funds without achieving chain reactivation. With IndexingPrice = 10 and arrears = 100, a user recharging with 105 tokens (the minimum allowed by the flawed assertion) will pay 100 to clear arrears, leaving only 5 tokens. The next indexing requiring 10 tokens will create 5 new tokens of arrears, making the 105-token recharge effectively worthless.

**Operational Disruption:**
- Side chains cannot be properly reactivated from debt status
- Cross-chain indexing functionality remains broken
- Miners/proposers don't receive payment for indexing work, accumulating more debt

**System Integrity:**
- Breaks the invariant that a successful recharge should enable at least one indexing operation
- Undermines trust in the side chain fee system

**Affected Parties:**
- Side chain operators attempting to recharge
- Block proposers/miners who index but aren't paid
- Users relying on cross-chain functionality

## Likelihood Explanation

This vulnerability has **HIGH** likelihood:

**Accessibility:**
- The `Recharge` function is publicly accessible to any user with no special permissions required beyond standard token allowance

**Preconditions:**
- Side chain in `IndexingFeeDebt` status (common operational state when chains run low on funds)
- `IndexingPrice >= 2` (typical in production; test suite uses `indexingPrice = 1` which masks the bug) [10](#0-9) 

**Triggering:**
- Occurs naturally when operators attempt minimal recharges to minimize costs
- No malicious intent required - legitimate users will encounter this
- Deterministic mathematical error that always triggers under the specified conditions

**Detection Difficulty:**
- The recharge transaction succeeds without error
- Only subsequent indexing reveals the problem
- Users may repeatedly attempt recharges, losing funds each time

## Recommendation

Replace the flawed assertion with a correct validation that checks only the remaining balance after arrears payment:

```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

This ensures the chain has sufficient balance for at least one indexing operation after arrears are cleared, preventing immediate return to debt status.

## Proof of Concept

```csharp
[Fact]
public async Task Recharge_InsufficientAmount_CausesImmediateDebt()
{
    // Setup: Create side chain with IndexingPrice = 10
    var indexingPrice = 10L;
    var lockedTokenAmount = 100L;
    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation: 0,
        parentChainId: 0,
        lockedTokenAmount: lockedTokenAmount,
        indexingFee: indexingPrice
    );

    // Drain the chain to create debt
    // Index blocks until chain has no balance and accumulates arrears
    var sideChainBlockData = CreateSideChainBlockData(
        HashHelper.ComputeFrom("hash1"), 1, sideChainId, 
        HashHelper.ComputeFrom("root1")
    );
    
    // Index enough blocks to create 100 tokens of arrears
    for (int i = 0; i < 10; i++)
    {
        var crossChainBlockData = new CrossChainBlockData
        {
            SideChainBlockDataList = { CreateSideChainBlockData(
                HashHelper.ComputeFrom($"hash{i}"), i + 1, sideChainId,
                HashHelper.ComputeFrom($"root{i}")
            )}
        };
        await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
        await CrossChainContractStub.ReleaseCrossChainIndexingProposal.SendAsync(
            new ReleaseCrossChainIndexingProposalInput { ChainIdList = { sideChainId } }
        );
    }

    // Verify chain is in debt
    var sideChainInfo = await CrossChainContractStub.GetSideChainInfo.CallAsync(
        new Int32Value { Value = sideChainId }
    );
    sideChainInfo.SideChainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    // Recharge with minimum amount allowed by flawed assertion: arrears + indexingPrice/2
    // With 100 arrears and 10 indexingPrice, this is 105 tokens
    var rechargeAmount = 105L; // arrears (100) + indexingPrice/2 (5)
    
    await ApproveBalanceAsync(rechargeAmount);
    var rechargeResult = await CrossChainContractStub.Recharge.SendAsync(
        new RechargeInput { ChainId = sideChainId, Amount = rechargeAmount }
    );
    
    // Recharge succeeds (but shouldn't with insufficient funds)
    rechargeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify status changed to Active
    sideChainInfo = await CrossChainContractStub.GetSideChainInfo.CallAsync(
        new Int32Value { Value = sideChainId }
    );
    sideChainInfo.SideChainStatus.ShouldBe(SideChainStatus.Active);
    
    // Index one more block - this should work but will create new debt
    var nextBlock = CreateSideChainBlockData(
        HashHelper.ComputeFrom("hash_after_recharge"), 
        11, 
        sideChainId,
        HashHelper.ComputeFrom("root_after_recharge")
    );
    
    var indexData = new CrossChainBlockData { SideChainBlockDataList = { nextBlock } };
    await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(indexData);
    await CrossChainContractStub.ReleaseCrossChainIndexingProposal.SendAsync(
        new ReleaseCrossChainIndexingProposalInput { ChainIdList = { sideChainId } }
    );
    
    // Verify chain is back in debt (proves the vulnerability)
    sideChainInfo = await CrossChainContractStub.GetSideChainInfo.CallAsync(
        new Int32Value { Value = sideChainId }
    );
    sideChainInfo.SideChainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    // User lost 105 tokens but chain is still in debt
    // This demonstrates the fund loss and failed reactivation
}
```

## Notes

The test suite currently uses `indexingPrice = 1` in most tests, which masks this vulnerability because integer division makes P/2 = 0, so the requirement becomes R >= A (same as the correct requirement). The bug only manifests with `indexingPrice >= 2`, which is the expected production configuration.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L828-830)
```csharp
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L842-844)
```csharp
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L846-851)
```csharp
                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L1243-1243)
```csharp
                    IndexingPrice = 1,
```
