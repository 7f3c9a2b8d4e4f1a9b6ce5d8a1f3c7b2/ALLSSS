# Audit Report

## Title
Missing LIB Validation in NextTerm Allows Malicious Miners to DoS Blockchain via Inconsistent Irreversible Block Fields

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) fields during NextTerm transitions, allowing a malicious miner to inject arbitrary values that trigger blockchain-wide denial-of-service by forcing the network into Severe mining status, reducing throughput by over 99%.

## Finding Description

The consensus validation architecture contains a critical gap in NextTerm behavior validation. When validating consensus behaviors through `ValidateBeforeExecution`, the NextTerm case only registers `RoundTerminateValidationProvider` and explicitly excludes `LibInformationValidationProvider`, which is exclusively added for UpdateValue behavior: [1](#0-0) 

The `LibInformationValidationProvider` is the sole validator ensuring LIB fields (`ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber`) maintain monotonicity and correctness: [2](#0-1) 

Furthermore, the post-execution validation using `GetCheckableRound` for hash comparison intentionally excludes LIB fields, only including `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`: [3](#0-2) 

During NextTerm generation, the system legitimately copies LIB values from the current round: [4](#0-3) 

However, since miners control block production and consensus header inclusion, they can modify the serialized consensus data before block creation. The `NextTermInput.Create` method blindly copies all fields including manipulated LIB values: [5](#0-4) 

The `ProcessNextTerm` method converts the input to a Round object and stores it directly without additional validation: [6](#0-5) 

The malicious values persist through direct state storage: [7](#0-6) 

## Impact Explanation

The corrupted LIB values directly compromise the `GetMaximumBlocksCount` mechanism, which determines block production limits per miner. This method retrieves LIB values from the current round: [8](#0-7) 

The `BlockchainMiningStatusEvaluator` compares current round number against LIB round number, triggering Severe status when the difference exceeds the threshold (minimum 8 rounds): [9](#0-8) 

In Severe status, all miners are restricted to producing only 1 block per time slot, and the system fires `IrreversibleBlockHeightUnacceptable` events: [10](#0-9) 

**Attack Execution**: A malicious miner waiting for their NextTerm opportunity can modify the consensus header to set `ConfirmedIrreversibleBlockRoundNumber` to 0 and `ConfirmedIrreversibleBlockHeight` to `Int64.MaxValue`. After 8+ rounds, the condition `currentRoundNumber >= 0 + 8` triggers Severe status, crippling blockchain throughput to single-block mode.

The corruption persists because `ProcessUpdateValue`'s correction mechanism contains a guard preventing updates when stored height is artificially high: [11](#0-10) 

With `ConfirmedIrreversibleBlockHeight` set to maximum value, the condition `currentRound.ConfirmedIrreversibleBlockHeight < libHeight` never satisfies, preventing correction for the entire term.

## Likelihood Explanation

**Prerequisites**: The attacker must be an active miner, validated through `PreCheck`: [12](#0-11) 

**Execution Complexity**: Low to Medium
1. Wait for term transition (periodic, predictable)
2. Deserialize consensus header from `GetConsensusExtraData`
3. Modify LIB fields before block production
4. Produce block - bypasses validation due to proven gaps
5. Effect activates within 8 rounds

**Feasibility Assessment**: Medium-High
- Miners are partially-trusted actors (unlike genesis/organization controllers)
- No additional privileges beyond standard mining rights required
- Single compromised miner sufficient
- Repeatable at every term boundary
- Detection requires manual LIB field auditing

## Recommendation

Add `LibInformationValidationProvider` to the NextTerm validation chain:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
```

Additionally, include LIB fields in `GetCheckableRound` hash computation to enable post-execution validation of these critical consensus parameters.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextTerm_CausesBlockchainDoS()
{
    // Setup: Initialize consensus and reach term transition point
    var keyPair = CryptoHelper.GenerateKeyPair();
    var maliciousMiner = Address.FromPublicKey(keyPair.PublicKey);
    
    // Simulate reaching NextTerm condition
    await AdvanceToTermTransition();
    
    // Attacker generates legitimate consensus data
    var legitimateHeader = await GetConsensusExtraData(keyPair.PublicKey);
    
    // Attacker modifies LIB fields
    var maliciousInput = NextTermInput.Parser.ParseFrom(legitimateHeader);
    maliciousInput.ConfirmedIrreversibleBlockRoundNumber = 0;
    maliciousInput.ConfirmedIrreversibleBlockHeight = long.MaxValue;
    
    // Execute NextTerm with malicious data
    await ExecuteConsensusTransaction(maliciousInput, keyPair);
    
    // Verify malicious values stored
    var currentRound = await GetCurrentRound();
    currentRound.ConfirmedIrreversibleBlockRoundNumber.ShouldBe(0);
    
    // Advance 8 rounds to trigger Severe status
    for(int i = 0; i < 8; i++)
        await ProduceNormalBlock();
    
    // Verify DoS condition: maximum blocks reduced to 1
    var maxBlocks = await GetMaximumBlocksCount();
    maxBlocks.ShouldBe(1); // Down from normal value (e.g., 8)
}
```

## Notes

This vulnerability exploits a fundamental architectural decision where NextTerm transitions were deemed low-risk and excluded from LIB consistency checks. However, since miners control block construction and can modify serialized consensus data before inclusion, this validation gap enables persistent DoS attacks that degrade blockchain performance by over 99% for entire terms (potentially thousands of blocks). The attack requires no special privileges beyond standard miner status, making it particularly dangerous in adversarial network conditions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-36)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```
