# Audit Report

## Title
Parliament Organization Governance Lock via Impossible Threshold Configuration

## Summary
The Parliament contract's threshold validation logic allows setting governance thresholds that require 100% unanimous approval while tolerating zero rejections or abstentions. While mathematically valid, these thresholds create a practical impossibility for ongoing governance, permanently locking the organization with no recovery mechanism.

## Finding Description

The vulnerability exists in the `Validate()` method that checks organization threshold configurations. [1](#0-0) 

This validation only enforces mathematical consistency against the constant `AbstractVoteTotal` (10,000 representing 100%): [2](#0-1) 

The validation allows the following configuration to pass:
- `MinimalApprovalThreshold = 10000` (100% approval required)
- `MinimalVoteThreshold = 10000` (100% participation required)  
- `MaximalRejectionThreshold = 0` (any rejection blocks)
- `MaximalAbstentionThreshold = 0` (any abstention blocks)

This is confirmed by the test suite: [3](#0-2) 

Once these thresholds are set via `ChangeOrganizationThreshold()` (which can only be called by the organization itself through a proposal), [4](#0-3)  the proposal approval logic enforces impossible conditions:

**Rejection Check:** [5](#0-4) 
With `MaximalRejectionThreshold = 0`, any single rejection blocks the proposal (formula: `rejectionCount * 10000 > 0 * memberCount` evaluates to TRUE if rejectionCount ≥ 1).

**Abstention Check:** [6](#0-5) 
With `MaximalAbstentionThreshold = 0`, any single abstention blocks the proposal.

**Approval Check:** [7](#0-6) 
With `MinimalApprovalThreshold = 10000`, ALL members must approve (formula: `approvalCount * 10000 ≥ 10000 * memberCount` requires approvalCount = memberCount).

These conditions mean proposals can ONLY pass if every single member actively approves and none reject, abstain, or remain offline. While technically possible for a single perfectly-coordinated vote, maintaining this requirement for all future governance decisions is practically impossible.

## Impact Explanation

**Severity: HIGH**

The impact is complete and permanent governance paralysis:

1. **Irreversible Lock:** Once these thresholds are set, changing them back requires passing a proposal under the locked thresholds, creating an impossible catch-22. The organization cannot self-govern.

2. **No Recovery Mechanism:** No organization deletion methods exist (verified via grep search), no admin overrides, and the emergency response organization [8](#0-7)  is just another parliament organization with high thresholds—it cannot override locked organizations.

3. **Chain-Wide Risk:** If the default Parliament organization (which governs core system contracts) is affected, the entire AElf blockchain's governance becomes paralyzed. [9](#0-8) 

4. **Fundamental Invariant Broken:** Organizations must be able to govern themselves. This configuration violates that core principle by making future proposals practically impossible to pass.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack requires passing a single malicious proposal under the organization's current (reasonable) thresholds:

1. **Social Engineering Vector:** The proposal can be framed as "security hardening" or "requiring unanimous approval for critical decisions," making it appear legitimate to parliament members who may not fully understand the implications.

2. **Honest Misconfiguration Risk:** Administrators may genuinely believe 100% approval with zero tolerance is a good security measure without recognizing it creates a governance deadlock.

3. **Mis-Scoped Privilege:** This is a design flaw where the validation logic is too permissive. The system should prevent self-harm configurations, similar to preventing division by zero or integer overflow—even if requested by trusted parties.

4. **Single Proposal Attack:** Unlike multi-step exploits, this requires only one successful proposal execution, reducing complexity.

While parliament members are typically trusted (current miners), the framework acknowledges that even trusted roles should be protected from mis-scoped privileges that allow dangerous configurations.

## Recommendation

Add validation that checks thresholds against practical governance feasibility:

```csharp
private bool Validate(Organization organization)
{
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Existing mathematical validation...
    var basicValidation = proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    
    if (!basicValidation)
        return false;
    
    // NEW: Prevent impossible threshold combinations
    // If requiring 100% approval, must allow some tolerance for rejection/abstention
    if (proposalReleaseThreshold.MinimalApprovalThreshold == AbstractVoteTotal)
    {
        // Cannot require 100% approval with zero tolerance for any dissent
        if (proposalReleaseThreshold.MaximalRejectionThreshold == 0 ||
            proposalReleaseThreshold.MaximalAbstentionThreshold == 0)
            return false;
    }
    
    return true;
}
```

Alternatively, implement a governance safety mechanism that requires supermajority (e.g., 80-90%) rather than allowing 100% thresholds, or add an emergency recovery path that can reset thresholds after a time lock.

## Proof of Concept

```csharp
[Fact]
public async Task Test_Governance_Lock_Via_Impossible_Thresholds()
{
    // Create organization with reasonable thresholds (67% approval)
    var organizationAddress = await CreateOrganizationAsync(6667, 2000, 2000, 8000);
    
    // Create proposal to change to "impossible" thresholds
    var impossibleThresholds = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 10000,  // 100% approval required
        MinimalVoteThreshold = 10000,      // 100% participation required
        MaximalRejectionThreshold = 0,     // Any rejection blocks
        MaximalAbstentionThreshold = 0     // Any abstention blocks
    };
    
    var changeThresholdProposal = await CreateProposalAsync(
        DefaultSenderKeyPair,
        organizationAddress,
        nameof(ParliamentContractStub.ChangeOrganizationThreshold),
        impossibleThresholds);
    
    // Approve with 2 out of 3 miners (sufficient under original 67% threshold)
    await ApproveAsync(InitialMinersKeyPairs[0], changeThresholdProposal);
    await ApproveAsync(InitialMinersKeyPairs[1], changeThresholdProposal);
    
    // Release succeeds - organization is now locked
    var releaseResult = await ParliamentContractStub.Release.SendAsync(changeThresholdProposal);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify thresholds were changed
    var org = await ParliamentContractStub.GetOrganization.CallAsync(organizationAddress);
    org.ProposalReleaseThreshold.MinimalApprovalThreshold.ShouldBe(10000);
    org.ProposalReleaseThreshold.MaximalRejectionThreshold.ShouldBe(0);
    
    // Now try to create and pass ANY new proposal - it will fail
    var newProposal = await CreateProposalAsync(DefaultSenderKeyPairs, organizationAddress);
    
    // Even if 2 out of 3 approve, proposal cannot pass
    await ApproveAsync(InitialMinersKeyPairs[0], newProposal);
    await ApproveAsync(InitialMinersKeyPairs[1], newProposal);
    
    var proposalStatus = await ParliamentContractStub.GetProposal.CallAsync(newProposal);
    proposalStatus.ToBeReleased.ShouldBeFalse(); // Fails because 1 member didn't vote
    
    // Organization is permanently locked - no recovery possible
}
```

## Notes

This vulnerability represents a **mis-scoped privilege** issue where the validation logic is too permissive. While parliament members are trusted actors, the system should implement safeguards against configurations that make ongoing governance impossible, especially when no recovery mechanism exists. The test suite confirms these thresholds pass validation, but the system fails to validate practical governance feasibility beyond mathematical consistency.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L189-195)
```csharp
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-37)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```
