# Audit Report

## Title
Premature Loop Exit in Transaction Fee Token Selection Causes Delegation Payment Failure

## Summary
The `GetAvailableSymbolToPayTxFee()` function in the MultiToken contract contains a logic error where it uses `break` instead of `continue` when delegation checks fail, causing the token selection loop to exit prematurely. This prevents evaluation of remaining configured tokens and causes legitimate transactions to fail with "Transaction fee not enough" errors even when alternative tokens have sufficient delegation allowances.

## Finding Description

The vulnerability exists in the transaction size fee token selection logic when delegation is active. The function is designed to iterate through a list of configured tokens to find one with adequate delegation allowance for fee payment.

**Root Cause:** [1](#0-0) 

When checking delegation sufficiency, if the validation fails for the current token, the code executes `break` at line 480, immediately terminating the entire foreach loop. The correct behavior should be `continue` to skip only the current token and proceed to evaluate subsequent tokens in the list.

**Execution Path:**

The bug is triggered through the standard transaction fee charging flow:

1. [2](#0-1) 
   The public `ChargeTransactionFees()` entry point is automatically invoked by the ACS1 pre-plugin infrastructure.

2. [3](#0-2) 
   The `ChargeFromDelegations()` method attempts to charge fees from delegatees when configured.

3. [4](#0-3) 
   For each delegatee, `ChargeTransactionFeesToBill()` is called with the delegations parameter, which then calls `ChargeSizeFee()` at line 296.

4. [5](#0-4) 
   The `ChargeSizeFee()` function invokes `GetAvailableSymbolToPayTxFee()` with the list of configured alternative tokens at line 396-398. If this returns null due to the premature break, the function returns false at line 412, causing the transaction to fail.

**Why Existing Protections Fail:** [6](#0-5) 

The function initializes fallback variables intended to capture valid token alternatives. However, these protections become ineffective because: [7](#0-6) 

The fallback selection logic at the end of the function can only work with tokens the loop actually evaluated. The premature `break` prevents the loop from reaching tokens that would pass delegation checks and populate these fallback variables.

## Impact Explanation

**Denial of Service - Medium Severity:**

This vulnerability breaks the multi-token delegation feature's core functionality, causing legitimate transactions to be rejected. The severity is medium because:

1. **No Direct Fund Loss**: The bug causes transaction rejections rather than fund theft or unauthorized transfers
2. **Feature-Specific Impact**: Only affects users utilizing the delegation feature (ACS12) with multi-token size fee configurations
3. **Operational Disruption**: Blocks legitimate transactions and renders the multi-token fallback mechanism non-functional

**Affected Parties:**
- Users who depend on delegatees to pay transaction fees
- Delegatees who have properly allocated sufficient delegation allowances for alternative tokens
- DApps and smart contract operations requiring fee delegation functionality

**Realistic Scenario:**

When the system is configured with tokens [ELF, USDT, TOKEN1] for size fees via [8](#0-7) , and a delegatee has 0 ELF delegation but sufficient USDT/TOKEN1 delegations, the transaction will fail at the ELF check without evaluating USDT or TOKEN1.

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is not an attack scenario but a systematic failure that triggers automatically under common production conditions:

1. **Directly Reachable**: The bug triggers through the public `ChargeTransactionFees()` method [9](#0-8) , which is automatically invoked by the ACS1 pre-plugin infrastructure for every transaction requiring fee payment.

2. **Standard Configuration**: Multi-token fee configuration is an explicitly supported production feature [8](#0-7) , and delegation is a standard ACS12 feature.

3. **Common Preconditions**:
   - Multiple tokens configured for transaction size fees
   - Active delegation relationships 
   - Token list ordering where a token with insufficient delegation appears before tokens with sufficient delegation

4. **High Probability**: The bug triggers whenever the first token in the configured list has insufficient delegation, regardless of whether subsequent tokens would be adequate. Users cannot control token ordering in their transactions.

## Recommendation

Change line 480 to use `continue` instead of `break`:

```csharp
if (delegations != null)
{
    var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
        symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
        txSizeFeeAmount, delegations);
    if (!delegationEnough) continue;  // Skip to next token instead of breaking
}
```

This allows the loop to evaluate all configured tokens and find one with sufficient delegation allowance.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task ChargeTransactionFee_Delegation_PrematureBreak_PoC()
{
    // Setup: Create multiple tokens for size fees
    await SetPrimaryTokenSymbolAsync();
    await CreateTokenAsync(DefaultSender, "USDT");
    await CreateTokenAsync(DefaultSender, "TOKEN1");
    
    // Issue tokens to delegatee: 0 ELF, 1000 USDT, 1000 TOKEN1
    await IssueTokenToUserAsync(NativeTokenSymbol, 0, DelegateeAddress);
    await IssueTokenToUserAsync("USDT", 1000, DelegateeAddress);
    await IssueTokenToUserAsync("TOKEN1", 1000, DelegateeAddress);
    
    // Set delegation: 0 ELF delegation, 1000 USDT delegation, 1000 TOKEN1 delegation
    await SetDelegateeWithLimitedTokensAsync(0, 1000, 1000);
    
    // Configure multi-token size fee list: [ELF, USDT, TOKEN1]
    var sizeFeeSymbolList = new SymbolListToPayTxSizeFee
    {
        SymbolsToPayTxSizeFee =
        {
            new SymbolToPayTxSizeFee { TokenSymbol = NativeTokenSymbol, AddedTokenWeight = 1, BaseTokenWeight = 1 },
            new SymbolToPayTxSizeFee { TokenSymbol = "USDT", AddedTokenWeight = 1, BaseTokenWeight = 1 },
            new SymbolToPayTxSizeFee { TokenSymbol = "TOKEN1", AddedTokenWeight = 1, BaseTokenWeight = 1 }
        }
    };
    await TokenContractImplStub.SetSymbolsToPayTxSizeFee.SendAsync(sizeFeeSymbolList);
    
    // Execute transaction requiring 100 size fee
    var chargeInput = new ChargeTransactionFeesInput
    {
        MethodName = "Transfer",
        ContractAddress = TokenContractAddress,
        TransactionSizeFee = 100
    };
    chargeInput.SymbolsToPayTxSizeFee.AddRange(sizeFeeSymbolList.SymbolsToPayTxSizeFee);
    
    var result = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeInput);
    
    // BUG: Transaction fails even though USDT/TOKEN1 have sufficient delegation
    // Expected: Success = true (should use USDT or TOKEN1)
    // Actual: Success = false, ChargingInformation = "Transaction fee not enough."
    result.Output.Success.ShouldBe(false);
    result.Output.ChargingInformation.ShouldContain("Transaction fee not enough");
}
```

This test proves the vulnerability by showing that when ELF (first in list) has 0 delegation but USDT and TOKEN1 (later in list) have sufficient delegation, the transaction still fails because the loop breaks at ELF without evaluating USDT or TOKEN1.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-32)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L167-209)
```csharp
    private bool ChargeFromDelegations(ChargeTransactionFeesInput input, ref Address fromAddress,
        ref TransactionFeeBill bill, ref TransactionFreeFeeAllowanceBill allowanceBill,
        Dictionary<string, long> fee, bool isSizeFeeFree, Address delegatorAddress)
    {
        var chargingResult = false;
        // Try to charge delegatees
        // Get delegatee list according to the delegator
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;

        if (delegationInfo == null)
        {
            return false;
        }

        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }

            break;
        }

        return chargingResult;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L268-300)
```csharp
    private bool ChargeTransactionFeesToBill(ChargeTransactionFeesInput input, Address fromAddress,
        ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee, bool isSizeFeeFree = false,
        TransactionFeeDelegations delegations = null)
    {
        var successToChargeBaseFee = true;

        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L375-414)
```csharp
    private bool ChargeSizeFee(ChargeTransactionFeesInput input, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {

        Context.LogDebug(() => "ChargeSizeFee Start");

        //If delegation != null,from address->delegateeAddress
        // Size Fee is charged in primary token, elf.
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
        //Get primary token balance
        GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
            out var symbolChargedForBaseFee, out var amountChargedForBaseFee, out var amountChargedForBaseAllowance,
            out var availableBalance, out var availableAllowance);
        var txSizeFeeAmount = input.TransactionSizeFee;

        // SymbolsToPayTxSizeFee is set of all available token can be charged, and with the ratio of primary token and another.
        if (input.SymbolsToPayTxSizeFee.Any())
        {
            var allSymbolToTxFee = input.SymbolsToPayTxSizeFee.ToList();
            var availableSymbol = GetAvailableSymbolToPayTxFee(allSymbolToTxFee, fromAddress, txSizeFeeAmount,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseFee,
                amountChargedForBaseAllowance, delegations);

            if (availableSymbol != null && availableSymbol.TokenSymbol != symbolToPayTxFee)
            {
                symbolToPayTxFee = availableSymbol.TokenSymbol;
                txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight)
                    .Div(availableSymbol.BaseTokenWeight);
                GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
                    out symbolChargedForBaseFee, out amountChargedForBaseFee, out amountChargedForBaseAllowance,
                    out availableBalance, out availableAllowance);
            }

            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L467-471)
```csharp
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;

```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L475-481)
```csharp
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L513-516)
```csharp
        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L616-649)
```csharp
    public override Empty SetSymbolsToPayTxSizeFee(SymbolListToPayTxSizeFee input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        if (input == null)
            throw new AssertionException("invalid input");
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
        State.SymbolListToPayTxSizeFee.Value = input;
        Context.Fire(new ExtraTokenListModified
        {
            SymbolListToPayTxSizeFee = input
        });
        return new Empty();
    }
```
