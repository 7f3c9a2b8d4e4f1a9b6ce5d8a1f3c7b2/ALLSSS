# Audit Report

## Title
Unvalidated Miner Order Manipulation via TuneOrderInformation Allows Consensus Schedule Disruption

## Summary
The AEDPoS consensus contract allows miners to submit arbitrary `TuneOrderInformation` values during `UpdateValue` that directly modify other miners' `FinalOrderOfNextRound` without any validation. This enables malicious miners to set invalid order values (zero, negative, exceeding miner count) or duplicate orders, causing mining time slot manipulation and consensus disruption in the next round.

## Finding Description

The vulnerability exists in the consensus order determination mechanism where `TuneOrderInformation` values are applied without validation.

**Root Cause:** In `ProcessUpdateValue`, the `TuneOrderInformation` dictionary from user input is directly applied to modify miners' `FinalOrderOfNextRound` values without any bounds checking, uniqueness validation, or sanity checks. [1](#0-0) 

The `UpdateValue` method is publicly callable by any miner. [2](#0-1) 

The only authorization check verifies the caller is in the current or previous miner list. [3](#0-2) 

**Validation Gaps:**

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are filled, and that `PreviousInValue` hashes correctly - it does NOT validate the `TuneOrderInformation` content. [4](#0-3) 

When the next round is generated, these unvalidated `FinalOrderOfNextRound` values are directly used to set mining orders and calculate `ExpectedMiningTime`. [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` only checks that the COUNT of miners with `FinalOrderOfNextRound > 0` equals the count who mined - it does NOT validate that the order values themselves are within valid bounds or unique. [6](#0-5) 

The `CheckRoundTimeSlots` validation only verifies that mining intervals are consistent and greater than zero - it does NOT validate that order values are within [1, minerCount] bounds. [7](#0-6) 

The protobuf definition shows `TuneOrderInformation` is simply a map with no constraints. [8](#0-7) 

**Legitimate Use Case:** The `TuneOrderInformation` mechanism is designed for conflict resolution when multiple miners have the same `SupposedOrderOfNextRound` (calculated from their signature hash). [9](#0-8) 

However, the extraction logic assumes miners will honestly report their current state, and there's no validation to enforce this when the values are applied. [10](#0-9) 

## Impact Explanation

**Consensus Schedule Manipulation:**
- Setting `FinalOrderOfNextRound = 0` causes `ExpectedMiningTime = currentBlockTime` (via `miningInterval.Mul(0)`), allowing immediate mining out of turn
- Setting negative values (e.g., -10) creates past timestamps, enabling time slot violations
- Setting extremely large values (e.g., 1000000) makes affected miners unable to mine as their slots become unreachably far in the future

**Denial of Service via Duplicate Orders:**
- Setting duplicate order values for multiple miners creates time slot conflicts where two miners have the same `Order` and `ExpectedMiningTime`
- This violates the consensus invariant that each miner must have a unique time slot
- The `ableOrders` calculation logic may produce incorrect results when duplicates exist in `occupiedOrders`

**Severity:** High - This directly violates the "Correct round transitions and time-slot validation, miner schedule integrity" critical invariant. A malicious miner can:
- Manipulate who mines when in the next round
- Prevent specific miners from participating by assigning them invalid orders
- Disrupt the consensus mechanism's fairness and predictability
- Potentially control block production by manipulating the order sequence

## Likelihood Explanation

**Attacker Capabilities:** Any active miner can execute this attack during their legitimate mining slot when calling `UpdateValue`. No additional permissions or privileges are required beyond being in the miner list.

**Attack Complexity:** Low - The attacker simply needs to:
1. Be an active miner (normal operational requirement)
2. Submit `UpdateValue` with a custom `TuneOrderInformation` dictionary containing arbitrary order values for target miners
3. No economic cost beyond normal mining transaction fees

**Feasibility:** Very High - The attack has:
- No additional permission requirements
- Direct execution path through a public method
- No cryptographic or computational barriers
- Immediate effect on the next round generation

**Detection:** Difficult to detect proactively since `TuneOrderInformation` is a legitimate consensus feature designed for order conflict resolution. The malicious manipulation only becomes apparent when the next round starts with corrupted mining schedules.

## Recommendation

Add comprehensive validation for `TuneOrderInformation` in the `ProcessUpdateValue` method:

```csharp
// In ProcessUpdateValue, before applying TuneOrderInformation:
var minersCount = currentRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate the miner exists
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key), 
        "Cannot tune order for non-existent miner.");
    
    // Validate order is within valid bounds [1, minerCount]
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
        $"Order must be between 1 and {minersCount}.");
    
    // Validate no duplicate orders among miners who will mine
    var existingMinerWithOrder = currentRound.RealTimeMinersInformation.Values
        .FirstOrDefault(m => m.Pubkey != tuneOrder.Key && 
                            m.FinalOrderOfNextRound == tuneOrder.Value && 
                            m.OutValue != null);
    Assert(existingMinerWithOrder == null, 
        $"Order {tuneOrder.Value} is already assigned to another miner.");
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

Additionally, enhance `NextRoundMiningOrderValidationProvider` to validate order uniqueness:

```csharp
// Check that all FinalOrderOfNextRound values are unique
var orders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (orders.Count != orders.Distinct().Count())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}

// Check that all orders are within valid bounds
var minersCount = providedRound.RealTimeMinersInformation.Count;
if (orders.Any(o => o < 1 || o > minersCount))
{
    validationResult.Message = "FinalOrderOfNextRound values out of valid bounds.";
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanManipulateNextRoundOrdersViaUnvalidatedTuneOrderInformation()
{
    // Setup: Initialize consensus with 5 miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Miner1 produces a block and submits UpdateValue with malicious TuneOrderInformation
    var maliciousMiner = initialMiners[0];
    var victimMiner = initialMiners[1];
    
    var updateValueInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test_out_value"),
        Signature = HashHelper.ComputeFrom("test_signature"),
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            // Malicious: Set victim's FinalOrderOfNextRound to 0 (invalid)
            { victimMiner.PublicKey.ToHex(), 0 },
            // Or set duplicate orders for multiple miners
            // { victimMiner.PublicKey.ToHex(), 3 },
            // { initialMiners[2].PublicKey.ToHex(), 3 }
        },
        RandomNumber = ByteString.CopyFrom(new byte[64])
    };
    
    // Execute: Malicious miner submits UpdateValue - this should fail validation but doesn't
    var result = await MaliciousMiner.UpdateValue.SendAsync(updateValueInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // VULNERABILITY: Succeeds
    
    // Verify: When NextRound is generated, victim has invalid order
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var victimMinerInfo = currentRound.RealTimeMinersInformation[victimMiner.PublicKey.ToHex()];
    
    // VULNERABILITY CONFIRMED: Victim's FinalOrderOfNextRound is set to invalid value (0)
    victimMinerInfo.FinalOrderOfNextRound.ShouldBe(0);
    
    // When NextRound is triggered, this will cause ExpectedMiningTime calculation error
    // or create duplicate time slots if duplicates were set
}
```

## Notes

The vulnerability is particularly severe because:

1. **Silent Corruption**: The malicious values are accepted without error, silently corrupting the consensus state
2. **Delayed Impact**: The attack effects only become visible in the next round, making attribution difficult
3. **Trust Exploitation**: The mechanism assumes miners will honestly report consensus state, but provides no enforcement
4. **Wide Attack Surface**: Any of the active miners can exploit this, increasing the likelihood

The legitimate use case (conflict resolution) should still be preserved, but with proper validation to ensure only valid, unique orders within bounds are accepted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
