# Audit Report

## Title
Unhandled KeyNotFoundException in IsCurrentMiner for Removed Miners During Term Transitions

## Summary
The `IsCurrentMiner` method contains an unsafe dictionary access at line 158 that throws `KeyNotFoundException` when called with addresses of miners removed during term transitions. This occurs because the safety check is conditionally skipped when `IsMinerListJustChanged = true`, while `ConvertAddressToPubkey` still returns pubkeys from previous rounds. The bug causes unhandled exceptions for removed miners instead of graceful authorization failures.

## Finding Description

**Root Cause Chain:**

The `ConvertAddressToPubkey` helper combines miners from both current and previous rounds when resolving addresses to pubkeys. [1](#0-0) 

The `IsCurrentMiner(string pubkey)` method has a conditional safety check that is bypassed during term transitions. [2](#0-1)  When `IsMinerListJustChanged` is false, it validates key existence before dictionary access. When true, this validation is skipped.

After bypassing the safety check, there's a special case for `ExtraBlockProducerOfPreviousRound` that returns early. [3](#0-2) 

For all other miners from the previous round who are NOT in the current round and NOT the extra block producer, execution reaches an unguarded dictionary access. [4](#0-3)  This throws `KeyNotFoundException` if the pubkey doesn't exist in the current round.

The `IsMinerListJustChanged` flag is set to true when generating the first round of a new term. [5](#0-4) 

**Affected Operations:**

The `ClaimTransactionFees` method uses `AssertSenderIsCurrentMiner()` for authorization. [6](#0-5)  This calls the consensus contract's `IsCurrentMiner` method. [7](#0-6) 

Cross-chain indexing operations use `AssertAddressIsCurrentMiner`, [8](#0-7)  which calls `CheckCrossChainIndexingPermission`. [9](#0-8) 

## Impact Explanation

**Severity: Low-Medium** (Degraded Error Handling)

This vulnerability causes unhandled exceptions instead of controlled authorization failures, but with **limited scope**:

1. **Scope Limited to Removed Miners**: Only affects miners who were removed during term transitions. Current miners in the active miner list can still perform all operations normally without any impact.

2. **Poor Error Handling**: Removed miners attempting to claim fees or perform cross-chain operations receive `KeyNotFoundException` instead of a clean "No permission" error message, degrading user experience.

3. **No Protocol-Wide DoS**: The system continues to function normally for legitimate current miners. Cross-chain communication and fee claiming work correctly for authorized participants.

4. **Predictable Window**: The vulnerability window is limited to the first round of each new term while `IsMinerListJustChanged = true`.

The impact is primarily on error handling quality rather than protocol availability or integrity. No funds are at risk, and no unauthorized access is possible.

## Likelihood Explanation

**Likelihood: Moderate**

The vulnerability can be triggered during predictable conditions:

1. **Regular Occurrence**: Term transitions happen periodically as part of normal consensus cycles.

2. **Natural Triggering**: Removed miners may attempt operations without realizing they've been removed from the active set, naturally encountering the exception.

3. **Public Method Exposure**: `IsCurrentMiner` is a public view method that can be called by any address with any input, allowing direct triggering of the exception.

4. **Limited Practical Impact**: While technically triggerable, the practical impact is minimal since removed miners shouldn't be performing miner-specific operations in the new term.

## Recommendation

Add a dictionary key existence check before the access at line 158:

```csharp
// After the ExtraBlockProducerOfPreviousRound check, add:
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    return false;

var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

This ensures graceful failure with a boolean false return instead of throwing an unhandled exception, regardless of the `IsMinerListJustChanged` state.

## Proof of Concept

A test demonstrating the vulnerability would:
1. Create a round with specific miners
2. Transition to a new term with a different miner set (IsMinerListJustChanged = true)
3. Call IsCurrentMiner with the address of a miner from the previous term who is NOT in the current term and NOT the ExtraBlockProducerOfPreviousRound
4. Observe KeyNotFoundException being thrown instead of returning false

The vulnerable code path is reachable when a removed miner's address is passed to IsCurrentMiner during the first round of a new term.

## Notes

This is a valid but **low-severity** vulnerability affecting error handling quality during term transitions. The original claim significantly overstates the impact by suggesting it "blocks critical operations" system-wide, when in reality it only affects operations attempted by removed miners who are no longer authorized. Current miners and the protocol's core functionality remain unaffected.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L128-130)
```csharp
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-158)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L869-869)
```csharp
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L905-905)
```csharp
        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
