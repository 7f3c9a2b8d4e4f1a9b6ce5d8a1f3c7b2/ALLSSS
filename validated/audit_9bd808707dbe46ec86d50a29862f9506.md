# Audit Report

## Title
Mid-Voting Member Addition Enables Retroactive Vote Manipulation

## Summary
The Association contract allows organizations to add new members while proposals are actively being voted on. These newly added members can immediately vote on pre-existing proposals, and their votes are counted using the current organization member list rather than a membership snapshot at proposal creation time. This enables retroactive manipulation of vote outcomes, fundamentally violating governance integrity.

## Finding Description

The vulnerability exists in the interaction between member management and vote counting mechanisms in the Association governance contract.

**Member Addition Without Snapshot Protection**: The `AddMember()` function adds new members to the organization without any checks for active proposals or creation of historical snapshots. [1](#0-0) 

**Vote Authorization Using Current Membership**: When members attempt to vote (approve/reject/abstain), the system checks if they are authorized by verifying their presence in the CURRENT organization member list, not whether they were members when the proposal was created. The authorization check calls `AssertIsAuthorizedOrganizationMember()` [2](#0-1)  which verifies membership against the current list [3](#0-2) 

**Vote Counting Filters By Current Membership**: When determining if a proposal can be released via `IsReleaseThresholdReached()`, the system counts votes by filtering them against the CURRENT organization member list:
- Rejections are counted using `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` [4](#0-3) 
- Abstentions are counted using `proposal.Abstentions.Count(organization.OrganizationMemberList.Contains)` [5](#0-4) 
- Approvals are counted using `proposal.Approvals.Count(organization.OrganizationMemberList.Contains)` [6](#0-5) 

**Missing Membership Snapshot**: The `ProposalInfo` structure stores the lists of voters (approvals, rejections, abstentions) and a reference to the organization address, but does not capture a snapshot of organization members at proposal creation time. [7](#0-6) 

**Attack Scenario**:
1. Organization has 5 members {A,B,C,D,E} with thresholds: MinimalApprovalThreshold=3, MaximalRejectionThreshold=2
2. Proposal P1 is created and receives 3 approvals from A, B, and C (ready to pass)
3. Attacker controls enough members to pass a proposal adding new members F, G, H via the organization's governance process
4. New members F, G, H immediately call `Reject()` on P1, passing the authorization check since they are now in the current member list
5. When checking if P1 can be released, `IsProposalRejected()` counts 3 rejections (F,G,H) which exceeds MaximalRejectionThreshold (2)
6. P1 is now blocked despite having sufficient approvals before the membership change

**Reverse Attack**: If members who previously voted to approve a proposal are later removed, their votes will no longer count during release verification, potentially invalidating a previously passing proposal.

This breaks the fundamental governance invariant that vote outcomes should be determined by the electorate at proposal creation time, not retroactively changed by electorate modifications.

## Impact Explanation

**HIGH severity** - This vulnerability enables multiple critical governance attacks:

**Proposal Blocking**: Legitimate proposals that have already achieved the required approval threshold can be retroactively blocked by adding new members who vote to reject them, pushing rejections above `MaximalRejectionThreshold`.

**Malicious Approval**: Failing malicious proposals can be rescued by adding new attacker-controlled members who vote to approve them, pushing approvals above `MinimalApprovalThreshold`.

**Vote Invalidation**: Removing members who have already voted can invalidate their votes retroactively, changing proposal outcomes after votes were cast in good faith.

**Governance Integrity Violation**: The core principle of democratic governance is that the outcome should be determined by the electorate as it existed when the vote began. This vulnerability allows the electorate to be changed mid-vote to alter outcomes, fundamentally undermining trust in the governance system.

**Widespread Applicability**: This affects all Association organizations in the AElf ecosystem, making it a systemic governance vulnerability rather than an isolated issue. Any organization using the Association contract for governance is vulnerable to this manipulation.

## Likelihood Explanation

**MEDIUM-HIGH likelihood** - The attack is practical and straightforward:

**Attacker Prerequisites**: 
- Requires control of sufficient organization members to pass an `AddMember` (or `RemoveMember`) proposal
- This is the same level of control needed for many legitimate governance actions
- Once this threshold is reached, the attack becomes trivial

**Attack Complexity**: LOW
- No technical sophistication required beyond normal governance operations
- Simple transaction sequence: create AddMember proposal → approve it → release it → new members vote
- No timing constraints beyond proposal expiration windows
- All operations use standard public contract methods

**Detection Limitations**: 
- Member additions emit `MemberAdded` events but occur on-chain via legitimate proposal execution [8](#0-7) 
- By the time additions are detected, new members can immediately vote on existing proposals
- No automated protection mechanisms exist in the contract to prevent this

**Economic Feasibility**: If an attacker already has sufficient governance control to pass member modification proposals, the cost is minimal (just transaction fees), while the benefit of manipulating critical proposals (e.g., treasury allocations, security parameters) could be substantial.

## Recommendation

Implement a membership snapshot mechanism that captures the organization's member list at proposal creation time:

1. **Add Snapshot to ProposalInfo**: Store a snapshot of `OrganizationMemberList` in the `ProposalInfo` structure at proposal creation time.

2. **Modify Vote Counting**: Update `IsProposalRejected()`, `IsProposalAbstained()`, and `CheckEnoughVoteAndApprovals()` to count votes against the snapshot rather than the current member list.

3. **Alternative Approach**: Instead of storing full snapshots, record the proposal creation block height and implement time-based membership eligibility checks, allowing only members who joined before the proposal was created to vote on it.

4. **Vote Authorization Update**: Modify `AssertIsAuthorizedOrganizationMember()` to verify membership against the snapshot for voting operations while still using current membership for proposal creation authorization.

This ensures that governance outcomes are determined by the electorate as it existed at proposal creation time, maintaining the fundamental integrity of the voting system.

## Proof of Concept

```csharp
[Fact]
public async Task MidVotingMemberAddition_RetroactiveVoteManipulation_Test()
{
    // Setup: Create organization with 5 members and thresholds
    // MinimalApprovalThreshold=3, MaximalRejectionThreshold=2
    var minimalApprovalThreshold = 3;
    var minimalVoteThreshold = 5;
    var maximalRejectionThreshold = 2;
    var maximalAbstentionThreshold = 0;
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 
        minimalVoteThreshold,
        maximalAbstentionThreshold, 
        maximalRejectionThreshold, 
        Reviewer1);
    
    // Step 1: Create Proposal P1
    var proposalP1 = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Step 2: P1 receives 3 approvals (meets threshold)
    await ApproveAsync(Reviewer1KeyPair, proposalP1);
    await ApproveAsync(Reviewer2KeyPair, proposalP1);
    await ApproveAsync(Reviewer3KeyPair, proposalP1);
    
    // Verify P1 can be released
    var proposalBeforeAddition = await AssociationContractStub.GetProposal.CallAsync(proposalP1);
    proposalBeforeAddition.ToBeReleased.ShouldBeTrue();
    
    // Step 3: Create and approve proposal to add 3 new members
    var newMember1 = Accounts[4].Address;
    var newMember2 = Accounts[5].Address;
    var newMember3 = Accounts[6].Address;
    
    var addMemberProposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair,
        newMember1,
        nameof(AssociationContractStub.AddMember),
        organizationAddress);
    
    await ApproveAsync(Reviewer1KeyPair, addMemberProposal);
    await ApproveAsync(Reviewer2KeyPair, addMemberProposal);
    await ApproveAsync(Reviewer3KeyPair, addMemberProposal);
    
    // Release to add members
    var stub = GetAssociationContractTester(Reviewer1KeyPair);
    await stub.Release.SendAsync(addMemberProposal);
    
    // Step 4: New members reject P1
    await RejectAsync(Accounts[4].KeyPair, proposalP1);
    await RejectAsync(Accounts[5].KeyPair, proposalP1);
    await RejectAsync(Accounts[6].KeyPair, proposalP1);
    
    // Step 5: Verify P1 is now blocked (3 rejections > MaximalRejectionThreshold of 2)
    var proposalAfterRejections = await AssociationContractStub.GetProposal.CallAsync(proposalP1);
    proposalAfterRejections.ToBeReleased.ShouldBeFalse(); // VULNERABILITY: P1 blocked by retroactive votes
    proposalAfterRejections.RejectionCount.ShouldBe(3);
}
```

## Notes

This vulnerability represents a fundamental flaw in the Association governance design where the temporal aspect of membership is not properly enforced. The issue affects vote counting rather than vote casting authorization, making it particularly insidious - new members can legitimately vote (they are members), but their votes retroactively affect proposals that existed before they joined. The same issue affects member removal in reverse, where removing members invalidates their previously cast votes.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L42-44)
```csharp
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-51)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```
