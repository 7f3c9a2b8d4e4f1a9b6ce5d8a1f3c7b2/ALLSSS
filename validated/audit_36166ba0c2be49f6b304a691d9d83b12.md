# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass via RecoverFromUpdateValue Timing Issue

## Summary
A critical validation bypass exists in the AEDPoS consensus mechanism where `RecoverFromUpdateValue` modifies the `baseRound` object before validation occurs, causing the `LibInformationValidationProvider` to compare a malicious `ImpliedIrreversibleBlockHeight` value against itself. This allows any miner to inject arbitrarily low implied LIB heights into consensus state, compromising blockchain finality guarantees.

## Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior, where the order of operations defeats the security check.

**The Flawed Execution Sequence:**

1. **Premature State Recovery**: When validating UpdateValue behavior, `RecoverFromUpdateValue` is called on `baseRound` before any validation occurs [1](#0-0) 

2. **Value Corruption**: The recovery method copies `ImpliedIrreversibleBlockHeight` from the provided round directly into `baseRound` for the sender's pubkey [2](#0-1) 

3. **Ineffective Validation**: The validator attempts to check if the base round's value exceeds the provided round's value, but after recovery these are now identical [3](#0-2) 

4. **Unvalidated Persistence**: The malicious `ImpliedIrreversibleBlockHeight` from the input is written directly to state without effective validation [4](#0-3) 

**Attack Execution:**

A miner can provide any `implied_irreversible_block_height` value in their `UpdateValueInput` message [5](#0-4) . The validation that should prevent decreasing values becomes a tautology, comparing the malicious value against itself after recovery has already corrupted the reference point.

**Impact on LIB Calculation:**

The corrupted `ImpliedIrreversibleBlockHeight` values are used in subsequent rounds to calculate the Last Irreversible Block height. The calculation collects these values from miners, sorts them, and selects the value at position `(count-1)/3` to ensure 2/3 consensus [6](#0-5) 

## Impact Explanation

**Severity: HIGH - Consensus Integrity Breach**

This vulnerability directly compromises the blockchain's finality mechanism. The `ImpliedIrreversibleBlockHeight` is a critical consensus parameter that determines which blocks are considered irreversible. By injecting fraudulently low values:

1. **Finality Degradation**: Malicious miners can prevent the LIB from advancing properly, leaving the chain in an uncertain state where blocks remain reversible longer than intended

2. **2/3 Threshold Attack**: While a single miner's impact is limited by the 2/3 consensus mechanism, repeated attacks over multiple rounds or collusion among multiple miners can significantly lower the calculated LIB

3. **Cross-Chain Implications**: Systems relying on LIB heights for cross-chain operations or irreversible confirmations will be affected by the manipulated values

4. **Security Guarantee Violation**: The fundamental security guarantee that `ImpliedIrreversibleBlockHeight` can only increase is violated, breaking a core consensus invariant

## Likelihood Explanation

**Probability: HIGH - Trivially Exploitable**

**Attacker Profile:**
- Must be an elected miner (realistic in any DPoS system)
- No special privileges beyond normal mining rights required
- Can execute during their regular time slot

**Attack Complexity:**
- **LOW**: Simply requires providing a lower-than-legitimate value in the `implied_irreversible_block_height` field of `UpdateValueInput`
- The validation bypass is automatic due to the code flow - no timing windows or race conditions to exploit
- No sophisticated techniques required

**Detection Difficulty:**
- The malicious value appears legitimate to all validation logic
- No automatic detection mechanism exists in the current codebase
- Would only be noticed through manual state inspection or observing abnormal LIB progression patterns

**Operational Feasibility:**
- Occurs during normal UpdateValue behavior (every block production)
- No additional preconditions or setup required
- Fully within the capabilities of any standard mining node

## Recommendation

**Fix the Validation Order:**

The validation must occur BEFORE state recovery. Move the validation to use the unmodified `baseRound`:

```csharp
// In AEDPoSContract_Validation.cs - ValidateBeforeExecution method
// DO NOT call RecoverFromUpdateValue before validation
// Remove lines 46-50 that recover state prematurely

var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound, // Use unmodified baseRound
    // ... other fields
};

// Perform validation FIRST
var validationResult = service.ValidateInformation(validationContext);

// ONLY AFTER validation passes, recover state
if (validationResult.Success && extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**Alternative: Preserve Original State for Validation:**

If state recovery is needed for other validators, preserve a separate copy for LIB validation:

```csharp
var originalBaseRound = baseRound.Clone();
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

var validationContext = new ConsensusValidationContext
{
    BaseRound = originalBaseRound, // Use unmodified copy for validation
    ProvidedRound = extraData.Round,
    // ... other fields
};
```

## Proof of Concept

**Test Setup:** Deploy a test network with multiple miners.

**Attack Execution:**

1. Attacker miner waits for their mining slot
2. Instead of setting `ImpliedIrreversibleBlockHeight` to the current block height (as done honestly in line 118 of `AEDPoSContract_GetConsensusBlockExtraData.cs`), they manually craft an `UpdateValueInput` with a fraudulently low value (e.g., 100 when current height is 1000)
3. Submit the UpdateValue transaction
4. The validation in `LibInformationValidationProvider` passes because it compares the malicious value against itself
5. The malicious value is persisted to state
6. In the next round, when LIB is calculated, this fraudulent value enters the sorted list, potentially lowering the consensus LIB

**Expected vs Actual Behavior:**

- **Expected**: Validation rejects any `ImpliedIrreversibleBlockHeight` value lower than the previously recorded value
- **Actual**: Validation always passes because `RecoverFromUpdateValue` copies the attacker's value into the reference point before comparison

**Verification:**

Check the state after the attack - `State.Rounds[currentRound].RealTimeMinersInformation[attackerPubkey].ImpliedIrreversibleBlockHeight` will contain the fraudulently low value, and subsequent LIB calculations will incorporate this corrupted data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** protobuf/aedpos_contract.proto (L217-218)
```text
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
