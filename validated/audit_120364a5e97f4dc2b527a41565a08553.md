# Audit Report

## Title
Clock Skew Enables Premature Round Transitions Causing Chain Reorganizations on Side Chains

## Summary
The AEDPoS side chain consensus allows any miner to trigger round transitions based solely on their local clock time, without validation of whether the round should actually terminate. Combined with tolerated clock skew of up to 1 second, miners with different system clocks will independently produce competing NextRound blocks, creating chain forks that require reorganization to resolve.

## Finding Description

The vulnerability exists in the side chain round transition mechanism through multiple interconnected weaknesses:

**Root Cause: Unconditional NextRound Return**

The side chain consensus behavior provider unconditionally returns `NextRound` when determining how to terminate the current round, without any synchronization checks or timing validation: [1](#0-0) 

This method is invoked when the consensus behavior provider determines a miner's time slot has passed: [2](#0-1) 

**Time Slot Determination Based on Local Clock**

Each miner independently determines if their time slot has passed by comparing their expected mining time plus the mining interval against their local `currentBlockTime`: [3](#0-2) 

The `currentBlockTime` parameter represents the miner's local system clock. The consensus service obtains this from the local system time and sets it as the block time used throughout consensus command generation: [4](#0-3) 

With clock skew, different miners reach the time slot passed condition at different real-world times.

**Insufficient Validation of NextRound Blocks**

When validating NextRound blocks, the system only checks structural correctness - whether the round number increments correctly and whether InValues are null - but does NOT validate whether it's actually time to advance rounds: [5](#0-4) 

The `CheckRoundTimeSlots()` method called during validation only verifies evenly-spaced time slots, not whether the timing of the round transition is appropriate: [6](#0-5) 

**No Extra Block Producer Enforcement**

While the system designates an extra block producer for each round: [7](#0-6) 

There is no validation that enforces only this designated producer can create NextRound blocks. The permission check only verifies the sender is in the miner list: [8](#0-7) 

Any miner in the current or previous round can produce NextRound blocks once their local clock indicates their time slot has passed.

**Clock Synchronization Limitations**

The system tolerates NTP clock drift up to 1000 milliseconds: [9](#0-8) 

This drift is checked only periodically (every 60 seconds by default): [10](#0-9) 

And only logs a warning without preventing operation: [11](#0-10) 

## Impact Explanation

**Consensus Integrity Degradation**

The vulnerability breaks the fundamental consensus guarantee that all honest miners agree on round transitions. Instead of coordinated round advancement, miners independently decide based on their local clocks, creating multiple competing versions of the chain state.

**Chain Reorganization Consequences**
- Transactions in discarded blocks must be re-executed or are temporarily lost
- Users experience uncertainty about transaction finality
- Cross-chain operations indexing the side chain may observe inconsistent state
- System reliability and predictability are significantly degraded

**Frequency and Severity**

The 1-second clock skew window is significant relative to typical mining intervals of 4-8 seconds (12.5% to 25% of interval). This creates frequent opportunities for disagreement, particularly on side chains with:
- Shorter round times
- Fewer miners (larger impact per reorganization)
- Higher network latency between miners

The impact is **Medium to High** as it affects consensus integrity and transaction finality without direct fund loss.

## Likelihood Explanation

**Natural Occurrence Without Attack**

This vulnerability manifests through normal operation:
- Miners run consensus honestly with independent system clocks
- Clock skew within the 1000ms NTP tolerance is expected and normal
- No malicious behavior is required

**Highly Feasible Preconditions**
- Multiple miners on a side chain (standard configuration)
- Clock skew approaching NTP threshold (realistic with normal NTP synchronization quality)
- Mining intervals of 4-8 seconds (typical configuration)
- Miners near the end of a round (occurs every round)

**Execution Path**
1. Any miner who has mined in the current round
2. Whose local clock indicates their time slot has passed
3. Will automatically attempt to produce NextRound
4. The NextRound block will pass all validations
5. Creates competing blocks with other miners still in current round

The likelihood is **Medium to High** depending on actual NTP synchronization quality in the deployment environment.

## Recommendation

Implement timing validation for NextRound blocks by enforcing that:

1. **Add Timestamp Validation**: The `RoundTerminateValidationProvider` should validate that the round transition is happening at an appropriate time relative to the expected end of the round, not just checking structural correctness.

2. **Enforce Extra Block Producer**: Modify `MiningPermissionValidationProvider` to verify that NextRound blocks can only be produced by the designated extra block producer of the current round, preventing premature transitions from other miners.

3. **Add Consensus Timestamp Tolerance**: Implement a consensus mechanism that uses timestamps from multiple miners to determine round transition timing, rather than relying solely on individual local clocks.

4. **Stricter NTP Synchronization**: Reduce the acceptable clock drift threshold from 1000ms to a smaller value (e.g., 200-500ms) and enforce continuous monitoring rather than periodic checks.

## Proof of Concept

A proof of concept would require:
1. Set up a side chain with at least 2 miners
2. Configure Miner A's system clock to +500ms
3. Configure Miner B's system clock to -500ms  
4. Observe near the end of a round that both miners produce competing blocks (NextRound from Miner A, UpdateValue from Miner B)
5. Verify both blocks pass validation
6. Confirm network experiences fork and reorganization

The vulnerability is demonstrable in a test environment by manipulating system clocks to simulate the natural clock skew that occurs in production deployments.

## Notes

This vulnerability specifically affects side chains due to the unconditional NextRound return in `SideChainConsensusBehaviourProvider`. The main chain uses `MainChainConsensusBehaviourProvider` which has different round termination logic. The issue stems from the architectural assumption that all miners would have sufficiently synchronized clocks, but the 1000ms tolerance window is too large relative to typical mining intervals, allowing legitimate clock skew to cause consensus disagreements.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-22)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L61-62)
```csharp
        var now = TimestampHelper.GetUtcNow();
        _blockTimeProvider.SetBlockTime(now, chainContext.BlockHash);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** src/AElf.OS.Core/Network/NetworkConstants.cs (L38-38)
```csharp
    public const int DefaultPeerReconnectionPeriod = 60_000; // 1 min
```

**File:** src/AElf.OS.Core/Network/NetworkConstants.cs (L44-44)
```csharp
    public const int DefaultNtpDriftThreshold = 1_000;
```

**File:** src/AElf.OS.Network.Grpc/GrpcNetworkServer.cs (L86-88)
```csharp
        if (offset.Duration().TotalMilliseconds > NetworkConstants.DefaultNtpDriftThreshold)
            Logger.LogWarning($"NTP clock drift is more that {NetworkConstants.DefaultNtpDriftThreshold} ms : " +
                              $"{offset.Duration().TotalMilliseconds} ms");
```
