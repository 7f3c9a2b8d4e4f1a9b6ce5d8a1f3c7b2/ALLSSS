# Audit Report

## Title
Insufficient Validation of OutValue Allows Secret-Sharing Protocol Violation and Mining Order Manipulation

## Summary
The `UpdateValueValidationProvider` in the AEDPoS consensus mechanism fails to cryptographically validate that submitted `OutValue` and `Signature` fields correspond to legitimate secret commitments. This allows miners to submit arbitrary values that violate the secret-sharing protocol and manipulate their mining order in subsequent rounds.

## Finding Description

The AEDPoS consensus uses a secret-sharing protocol where miners commit to a secret `InValue` by publishing `Hash(InValue)` as their `OutValue`. The validation logic has two critical weaknesses:

**Weakness 1: Missing Cryptographic Validation of OutValue and Signature**

The `NewConsensusInformationFilled` method only performs existence checks without cryptographic verification: [1](#0-0) 

This validation does not verify that:
- `OutValue` equals `Hash(InValue)` for a legitimate InValue
- `Signature` was computed using the proper `CalculateSignature` method

In contrast, legitimate values should be computed as shown in the proper generation logic: [2](#0-1) 

And the signature should use the round's calculation method: [3](#0-2) 

Which relies on the cryptographic computation: [4](#0-3) 

**Weakness 2: Optional PreviousInValue Disclosure**

Miners can bypass revelation of their previous InValue by providing `Hash.Empty`, which is explicitly permitted: [5](#0-4) 

This is also permitted in processing with an explicit comment: [6](#0-5) 

**Direct Processing Without Re-validation**

The provided values are directly assigned without cryptographic verification: [7](#0-6) 

**Mining Order Manipulation**

The `Signature` value directly determines the miner's position in the next round through modulo arithmetic: [8](#0-7) 

Additionally, the first miner's signature determines the extra block producer: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Compromise:**
The secret-sharing protocol is designed to provide verifiable randomness through cryptographic commitments (`OutValue = Hash(InValue)`) and subsequent revelation (`PreviousInValue`). By allowing arbitrary `OutValue` and `Signature` values without cryptographic validation, the protocol's fundamental security guarantee is violated.

**Mining Order Manipulation:**
A malicious miner can:
1. Calculate different `Signature` values offline
2. Determine which signature gives them a favorable `SupposedOrderOfNextRound` position
3. Submit that signature to gain strategic advantages (e.g., becoming the extra block producer or avoiding unfavorable slots)

**Protocol-Wide Impact:**
- All miners are affected by the degraded randomness
- The unpredictability guarantee of miner ordering is compromised
- Coordinated manipulation by multiple colluding miners could amplify the effect

**Severity:** HIGH - Directly violates critical consensus invariants and enables strategic manipulation of block production order, affecting the fairness and security of the entire consensus mechanism.

## Likelihood Explanation

**Attacker Capabilities:**
Any elected miner can exploit this vulnerability. The only requirement is being in the active miner list, which is a normal precondition for block production.

**Attack Complexity:**
LOW - The attack requires minimal technical sophistication:
1. Modify node software to generate arbitrary `OutValue` and `Signature` values instead of computing them properly
2. Submit consensus extra data with chosen values
3. Provide `Hash.Empty` for `PreviousInValue` in subsequent rounds to avoid detection

**Detection Difficulty:**
The validation logic explicitly permits these behaviors, making detection extremely difficult:
- No cryptographic verification occurs during validation
- The comment indicates omitting `PreviousInValue` is expected behavior
- Secret sharing reconstruction could theoretically detect mismatches, but only if 2/3+ miners participate and collect sufficient decrypted pieces

**Probability:** HIGH - Any rational miner seeking competitive advantage could exploit this with minimal risk and effort.

## Recommendation

Implement cryptographic validation of `OutValue` and `Signature` in the `UpdateValueValidationProvider`:

1. **Validate OutValue against InValue**: When a miner reveals their `PreviousInValue` in the next round, verify that `Hash(PreviousInValue) == previousRound.OutValue`. If validation fails, reject the block or penalize the miner.

2. **Validate Signature computation**: Store expected signature values and verify they match the submitted values, or implement a mechanism to retroactively verify signatures once InValues are revealed.

3. **Enforce PreviousInValue disclosure**: Make `PreviousInValue` revelation mandatory (remove the `Hash.Empty` bypass) and penalize miners who fail to reveal their InValues properly.

4. **Add post-revelation verification**: When InValues are revealed through secret sharing reconstruction, compare them against previously submitted OutValues and apply penalties for mismatches.

## Proof of Concept

A malicious miner can exploit this by:

1. Computing multiple signature values offline to find a favorable `SupposedOrderOfNextRound`
2. Submitting arbitrary `OutValue` and chosen `Signature` during block production
3. Providing `Hash.Empty` for `PreviousInValue` in the next round to avoid cryptographic verification

The vulnerability is confirmed by the absence of cryptographic validation in the validation provider and the explicit permission to omit `PreviousInValue` disclosure.

## Notes

The secret sharing reconstruction mechanism (`RevealSharedInValues`) is not a sufficient defense because:
1. It only runs during `NextRound` behavior, after mining order is already determined
2. It requires 2/3+ miner participation with full encrypted/decrypted piece sets
3. It doesn't retroactively correct mining orders or penalize malicious miners
4. It only fills in missing `PreviousInValue` fields but doesn't validate submitted `OutValue` and `Signature` fields

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-122)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```
