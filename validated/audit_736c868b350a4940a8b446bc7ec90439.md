# Audit Report

## Title
Election Deposit Misrouted to Wrong Address After Pubkey Replacement in Self-Announce Scenario

## Summary
When a candidate self-announces election, the `CandidateSponsorMap` is not populated. If the candidate's pubkey is subsequently replaced via `ReplaceCandidatePubkey`, the 100,000 token deposit is incorrectly sent to the new pubkey's address instead of the original depositor's address when quitting election, resulting in permanent fund loss for the original depositor.

## Finding Description

The vulnerability stems from inconsistent sponsor tracking between two election announcement paths and a flawed fallback mechanism in the refund logic.

**Root Cause Analysis:**

When a candidate self-announces via `AnnounceElection`, the method locks 100,000 tokens from `Context.Sender` but does **not** record this payer in `CandidateSponsorMap`. [1](#0-0) 

In contrast, when using `AnnounceElectionFor`, the sponsor is explicitly recorded. [2](#0-1) 

The deposit is locked from `Context.Sender` in both cases. [3](#0-2) 

When a pubkey is replaced via `ReplaceCandidatePubkey`, the sponsor mapping (including null values) is transferred from the old pubkey to the new pubkey. [4](#0-3) 

The critical flaw occurs in `QuitElection`, which uses a fallback mechanism when no sponsor is recorded. When `CandidateSponsorMap[input.Value]` is null, tokens are refunded to `Address.FromPublicKey(pubkeyBytes)` where `pubkeyBytes` is derived from the **current** pubkey (the input parameter). [5](#0-4) 

After a pubkey replacement, this fallback address points to the new pubkey's address, not the original depositor's address.

**Execution Path:**

1. **Initial State:** Alice owns keypair A (pubkey_A, private_key_A)
2. **Self-Announce:** Alice calls `AnnounceElection` with pubkey_A as admin address
   - 100,000 tokens locked from `Address.FromPublicKey(pubkey_A)`
   - `CandidateSponsorMap[pubkey_A]` remains null
3. **Pubkey Replacement:** Alice's admin calls `ReplaceCandidatePubkey(pubkey_A, pubkey_B)`
   - `CandidateSponsorMap[pubkey_B] = CandidateSponsorMap[pubkey_A]` (null = null)
   - Original mapping removed
4. **Quit Election:** Admin calls `QuitElection` with pubkey_B
   - Refund recipient: `CandidateSponsorMap[pubkey_B] ?? Address.FromPublicKey(pubkey_B)`
   - Since sponsor is null, tokens sent to `Address.FromPublicKey(pubkey_B)`
   - **Original depositor at `Address.FromPublicKey(pubkey_A)` loses 100,000 tokens**

The deposit amount is defined as 100,000 tokens with 8 decimals. [6](#0-5) 

The `GetSponsor` view method confirms this fallback design, showing it's intended behavior that becomes problematic after replacement. [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes direct, irreversible financial loss:

1. **Fund Misdirection:** 100,000 tokens are permanently transferred to an unintended recipient
2. **Original Depositor Loss:** The address that paid the deposit cannot recover their funds
3. **Unearned Gain:** The new pubkey's address receives tokens they never deposited
4. **Broken Contract Guarantee:** The fundamental principle that deposits should be refundable to the payer is violated

**Why HIGH Severity:**
- **Direct Fund Loss:** Unlike vulnerabilities requiring specific economic conditions, this causes immediate 100,000 token loss
- **Irreversibility:** Once the tokens are transferred, they cannot be recovered through contract mechanisms
- **Design Inconsistency:** The `AnnounceElectionFor` path correctly tracks sponsors through replacements, proving the contract intends to preserve deposit ownership but fails to do so for self-announce cases
- **Protocol Invariant Break:** Deposits are a security guarantee that must be honored regardless of subsequent state changes

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability is exploitable through standard contract operations:

**Attack Prerequisites:**
- Candidate uses self-announce method (`AnnounceElection`) rather than sponsored method
- Candidate's admin performs a pubkey replacement
- Admin (legitimately or maliciously) quits election

**Attack Complexity:** LOW
- All three methods are public contract operations
- No special privileges beyond normal candidate admin rights
- Simple linear execution path with no timing or state dependencies

**Realistic Scenarios:**

1. **Admin Compromise Attack:**
   - Alice announces election with pubkey_A, delegates admin to Bob for operational convenience
   - Bob's credentials are compromised
   - Attacker replaces pubkey_A with attacker-controlled pubkey_Attack
   - Attacker quits election and receives Alice's 100,000 tokens

2. **Legitimate Key Rotation Gone Wrong:**
   - Candidate loses access to private_key_A
   - Admin legitimately rotates to pubkey_B owned by candidate
   - Upon quitting, deposit goes to new address
   - If old address contained other assets or was an organization address, original stakeholders lose access to the refund

3. **Insider Threat:**
   - Malicious admin deliberately performs replacement to their own pubkey
   - Quits election to steal the deposit

**Why MEDIUM (not HIGH) Likelihood:**
- Requires specific sequence: self-announce → pubkey replacement → quit
- Admin compromise or malicious admin is a prerequisite
- However, pubkey replacement is a documented feature, not an edge case
- The contract's own design (sponsor tracking in `AnnounceElectionFor`) shows this scenario was considered but incompletely implemented

## Recommendation

**Solution:** Track the original depositor separately from the current pubkey to ensure refunds always go to the correct address.

**Implementation Options:**

1. **Option A - Record Sponsor for Self-Announce:**
   In `AnnounceElection`, explicitly set the sponsor mapping:
   ```csharp
   public override Empty AnnounceElection(Address input)
   {
       var recoveredPublicKey = Context.RecoverPublicKey();
       AnnounceElection(recoveredPublicKey);
       
       var pubkey = recoveredPublicKey.ToHex();
       var address = Address.FromPublicKey(recoveredPublicKey);
       
       // ... existing admin setup code ...
       
       // FIX: Record the sponsor for self-announce cases
       State.CandidateSponsorMap[pubkey] = Context.Sender;
       
       LockCandidateNativeToken();
       // ... rest of method ...
   }
   ```

2. **Option B - Store Original Depositor Address:**
   Create a new state mapping `OriginalDepositorMap` that is never transferred during pubkey replacement, and use this in `QuitElection` for refunds.

**Recommended Approach:** Option A is simpler and maintains consistency with the `AnnounceElectionFor` path. The sponsor mapping already exists and is properly transferred during replacements; it just needs to be populated for self-announce cases.

## Proof of Concept

```csharp
[Fact]
public async Task ElectionContract_SelfAnnounce_Replace_Quit_FundMisrouting_Test()
{
    // Setup: Get keypairs for original candidate and replacement
    var originalKeyPair = ValidationDataCenterKeyPairs.First();
    var replacementKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    
    // Record original depositor's balance (address derived from originalKeyPair)
    var originalAddress = Address.FromPublicKey(originalKeyPair.PublicKey);
    var originalBalanceBefore = await GetNativeTokenBalance(originalKeyPair.PublicKey);
    
    // Record replacement address's balance
    var replacementAddress = Address.FromPublicKey(replacementKeyPair.PublicKey);
    var replacementBalanceBefore = await GetNativeTokenBalance(replacementKeyPair.PublicKey);
    
    // Step 1: Self-announce election (no sponsor recorded)
    await AnnounceElectionAsync(originalKeyPair, Address.FromPublicKey(candidateAdmin.PublicKey));
    
    // Verify deposit was locked from original address
    var originalBalanceAfterAnnounce = await GetNativeTokenBalance(originalKeyPair.PublicKey);
    originalBalanceAfterAnnounce.ShouldBe(originalBalanceBefore - ElectionContractConstants.LockTokenForElection);
    
    // Verify no sponsor was recorded (returns fallback address)
    var sponsor = await ElectionContractStub.GetSponsor.CallAsync(new StringValue { Value = originalKeyPair.PublicKey.ToHex() });
    sponsor.ShouldBe(originalAddress); // Fallback to candidate address
    
    // Step 2: Replace pubkey
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress, candidateAdmin);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = originalKeyPair.PublicKey.ToHex(),
        NewPubkey = replacementKeyPair.PublicKey.ToHex()
    });
    
    // Step 3: Quit election
    await adminStub.QuitElection.SendAsync(new StringValue { Value = replacementKeyPair.PublicKey.ToHex() });
    
    // Verify the vulnerability: tokens went to replacement address, not original depositor
    var originalBalanceFinal = await GetNativeTokenBalance(originalKeyPair.PublicKey);
    var replacementBalanceFinal = await GetNativeTokenBalance(replacementKeyPair.PublicKey);
    
    // VULNERABILITY: Original depositor did NOT receive refund
    originalBalanceFinal.ShouldBe(originalBalanceAfterAnnounce); // No change - funds NOT returned
    
    // VULNERABILITY: Replacement address received the deposit they didn't pay for
    replacementBalanceFinal.ShouldBe(replacementBalanceBefore + ElectionContractConstants.LockTokenForElection);
    
    // This proves 100,000 tokens were misrouted from original depositor to replacement address
}
```

**Notes:**

1. **State Mapping Design Flaw:** The `CandidateSponsorMap` is defined to track "who will pay announce election fee for this pubkey" [8](#0-7)  but is only populated in the `AnnounceElectionFor` path, creating an inconsistency between the two announcement methods.

2. **Scope Clarification:** This vulnerability affects production contract code in `ElectionContract_Candidate.cs` and `ElectionContract_Maintainence.cs`, both explicitly listed in the scope files. It does not rely on test code or off-chain components.

3. **Admin Role Context:** While the vulnerability requires admin privileges to execute replacement and quit operations, this does not make it invalid. The contract should protect user funds even against compromised or malicious admins where possible. The existence of the sponsor tracking mechanism in `AnnounceElectionFor` demonstrates the contract's design intent to preserve deposit ownership regardless of admin actions.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L421-425)
```csharp
    public override Address GetSponsor(StringValue input)
    {
        return State.CandidateSponsorMap[input.Value] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L92-95)
```csharp
    /// <summary>
    ///     Pubkey -> Sponsor address (who will pay announce election fee for this pubkey)
    /// </summary>
    public MappedState<string, Address> CandidateSponsorMap { get; set; }
```
