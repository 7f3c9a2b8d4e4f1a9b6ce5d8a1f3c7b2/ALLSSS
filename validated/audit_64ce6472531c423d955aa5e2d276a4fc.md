# Audit Report

## Title
Unvalidated Other Miners' PreviousInValues Allow Cryptographic Commit-Reveal Bypass in Secret Sharing

## Summary
The AEDPoS consensus contract fails to validate `PreviousInValue` entries for other miners during secret sharing, allowing a malicious block producer to set arbitrary values that violate the fundamental commit-reveal cryptographic invariant. While the sender's own `PreviousInValue` is validated against their previous `OutValue` commitment, values for other miners are applied directly to consensus state without cryptographic verification, leading to signature corruption and mining order manipulation.

## Finding Description

The AEDPoS consensus protocol relies on a commit-reveal scheme where miners commit to random values via `OutValue = Hash(InValue)` in round N, then reveal the preimage as `PreviousInValue` in round N+1. The invariant `Hash(PreviousInValue) == OutValue_from_previous_round` MUST hold for all miners to ensure consensus integrity.

**Vulnerability Flow:**

1. During off-chain block production, `UpdateLatestSecretPieces()` sets `PreviousInValue` for other miners from `triggerInformation.RevealedInValues` without any cryptographic validation. The method only checks if the miner key exists and if the current value is empty, then blindly applies the provided hash. [1](#0-0) 

2. These unvalidated values are later extracted into `MinersPreviousInValues` during transaction input construction. [2](#0-1) 

3. On-chain validation explicitly checks ONLY the sender's `PreviousInValue` using `validationContext.SenderPubkey` and verifies it against their previous `OutValue`. There is no loop or validation mechanism for other miners' entries in the round state. [3](#0-2) 

4. During transaction execution, `PerformSecretSharing()` blindly applies all values from `input.MinersPreviousInValues` to consensus state without any validation. [4](#0-3) 

5. The incorrectly set `PreviousInValue` entries persist in blockchain state and are consumed during round transitions. When `SupplyCurrentRoundInformation()` fills in information for miners who didn't produce blocks, it reads the potentially malicious `PreviousInValue` from state. [5](#0-4) 

6. This incorrect `PreviousInValue` is then used to calculate the miner's signature, which directly affects `SupposedOrderOfNextRound` calculation via modulo arithmetic. [6](#0-5) 

## Impact Explanation

**Severity: HIGH - Consensus Integrity Violation**

This vulnerability breaks the fundamental security guarantee of the AEDPoS commit-reveal mechanism:

1. **Signature Calculation Corruption**: Incorrect `PreviousInValue` entries stored in state are read back during `SupplyCurrentRoundInformation()` and used in `CalculateSignature()`. The signature is computed by XORing the incorrect value with all miners' signatures, producing a corrupted signature for the affected miner. [7](#0-6) 

2. **Mining Order Manipulation**: The corrupted signature directly determines `SupposedOrderOfNextRound` through modulo arithmetic (`GetAbsModulus(sigNum, minersCount) + 1`), allowing an attacker to influence mining schedules for the next round by manipulating other miners' PreviousInValue entries.

3. **Consensus Randomness Compromise**: The commit-reveal scheme ensures unpredictable randomness for mining schedules. Bypassing cryptographic verification allows manipulation of this randomness, undermining consensus fairness.

4. **State Integrity**: Incorrect values are permanently committed to blockchain state and propagate through subsequent rounds until overwritten, affecting consensus calculations network-wide.

**Affected Parties**: All miners whose `PreviousInValue` is incorrectly set by the attacker, impacting mining order fairness and consensus randomness for the entire network.

## Likelihood Explanation

**Likelihood: HIGH (for motivated miner attacker)**

**Attacker Requirements:**
- Must be in the current miner list with valid block production rights (checked in `PreCheck()`)
- Must have secret sharing enabled (verified via `IsSecretSharingEnabled()`) [8](#0-7) 

**Attack Complexity: LOW**
- Attacker modifies `RevealedInValues` in their `AElfConsensusTriggerInformation` during off-chain block production
- Provides arbitrary hash values instead of cryptographically correct reconstructed InValues
- No sophisticated cryptographic attacks, race conditions, or timing requirements

**Detection Difficulty: HIGH**
- Malicious values appear format-valid (correct Hash type)
- On-chain validation ensures internal state consistency but not cryptographic correctness
- Other nodes would need to maintain and compare against their own records of previous round `OutValues` to detect the manipulation

## Recommendation

Add cryptographic validation for all entries in `MinersPreviousInValues` during the validation phase:

```csharp
// In UpdateValueValidationProvider or new validation provider
private bool ValidateAllMinersPreviousInValues(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var previousRound = validationContext.PreviousRound;
    
    foreach (var minerInfo in extraData.Round.RealTimeMinersInformation)
    {
        var pubkey = minerInfo.Key;
        var previousInValue = minerInfo.Value.PreviousInValue;
        
        if (previousInValue == null || previousInValue == Hash.Empty)
            continue;
            
        if (!previousRound.RealTimeMinersInformation.ContainsKey(pubkey))
            continue;
            
        var previousOutValue = previousRound.RealTimeMinersInformation[pubkey].OutValue;
        if (HashHelper.ComputeFrom(previousInValue) != previousOutValue)
            return false;
    }
    
    return true;
}
```

Additionally, add validation in `UpdateLatestSecretPieces` before applying `RevealedInValues`:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        // Validate against previous round's OutValue
        if (TryToGetPreviousRoundInformation(out var prevRound) &&
            prevRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = prevRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
                continue; // Skip invalid revealed value
        }
        
        if (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
            updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null)
            updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
}
```

## Proof of Concept

A malicious miner can exploit this vulnerability through the following scenario:

1. **Setup**: Miner A and Miner B are in the active miner set. In round N, Miner B publishes `OutValue_B = Hash(InValue_B)`.

2. **Attack Execution**: In round N+1, Miner A produces a block and modifies their off-chain consensus engine to provide `RevealedInValues[B] = fake_hash` where `Hash(fake_hash) â‰  OutValue_B`.

3. **State Corruption**: The fake `PreviousInValue` is applied to state without validation via `UpdateLatestSecretPieces()`.

4. **Impact Materialization**: When transitioning to round N+2, if Miner B hasn't produced blocks, `SupplyCurrentRoundInformation()` reads the fake `PreviousInValue` from state and calculates an incorrect signature, affecting Miner B's mining order in the next round.

5. **Verification**: Other nodes accept the block because validation only checks Miner A's own `PreviousInValue`, not the values Miner A provided for other miners.

The cryptographic invariant `Hash(PreviousInValue) == OutValue` is violated for Miner B, and the incorrect value propagates through consensus calculations, demonstrating a complete bypass of the commit-reveal security mechanism.

## Notes

This vulnerability is particularly severe because it violates a fundamental cryptographic invariant that underpins the security model of AEDPoS consensus. The commit-reveal scheme is designed to prevent miners from adaptively choosing their random contributions after seeing others' values. By allowing unvalidated `PreviousInValue` entries to be injected, the protocol loses this security guarantee, enabling potential mining order manipulation and consensus randomness attacks.

The vulnerability exists in production code paths (`contract/AElf.Contracts.Consensus.AEDPoS/`) and affects the core consensus mechanism when secret sharing is enabled. The attack is feasible for any malicious miner and requires no external resources beyond modifying their own off-chain block production logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-48)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L188-200)
```csharp
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
