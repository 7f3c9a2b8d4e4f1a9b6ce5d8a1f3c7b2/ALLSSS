# Audit Report

## Title
NFT Contract Burn Function Allows Unauthorized Token Minting via Negative Amount Input

## Summary
The NFT contract's `Burn()` function lacks input validation to ensure amounts are positive. When minters pass negative amounts, SafeMath `.Sub()` operations mathematically add tokens instead of removing them, bypassing all mint authorization checks and supply limits. This breaks the core invariant that burning reduces supply.

## Finding Description

The `Burn()` function accepts user-supplied amounts without validation that they are positive. [1](#0-0) 

The vulnerability exists in the permission check at lines 91-92, which validates `State.BalanceMap[tokenHash][Context.Sender] >= input.Amount`. When `input.Amount` is negative (e.g., -1000), any positive balance satisfies this check since `balance >= -1000` always evaluates to true.

The subsequent SafeMath operations at lines 94-96 then perform subtraction with the negative amount:
- `balance.Sub(-1000)` becomes `balance - (-1000)` = `balance + 1000`
- `Supply.Sub(-1000)` becomes `Supply + 1000`  
- `Quantity.Sub(-1000)` becomes `Quantity + 1000`

This behavior is mathematically correct for SafeMath's implementation, which uses checked arithmetic to prevent overflow but does not validate business logic. [2](#0-1) 

The test suite explicitly demonstrates this behavior. [3](#0-2) 

The protobuf definition allows negative values through the `int64` type. [4](#0-3) 

**Contrast with correct implementation:**
The MultiToken contract properly validates amounts before burning. [5](#0-4) 

It calls `AssertValidToken()` which performs the missing validation. [6](#0-5) 

Interestingly, the NFT contract's own `DoTransfer()` function correctly validates against negative amounts. [7](#0-6) 

## Impact Explanation

**Critical Supply Invariant Violation:**
The legitimate `Mint()` function enforces supply caps through a check that `protocolInfo.Issued <= protocolInfo.TotalSupply`. [8](#0-7) 

By exploiting the negative amount vulnerability in `Burn()`, a minter can bypass this enforcement entirely, allowing:
- Supply to exceed TotalSupply limits set by protocol creators
- Unlimited token creation without proper authorization
- Complete subversion of the supply cap mechanism

**Economic Impact:**
- **Protocol creators** who set TotalSupply expecting enforcement suffer loss of supply control
- **Existing token holders** experience dilution as unauthorized tokens enter circulation
- **Market integrity** is compromised as supply data becomes unreliable

**Severity Rationale:**
This constitutes privilege escalation from "authorized minter with limits" to "unlimited minting capability," breaking the fundamental security guarantee that burning decreases supply.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be in the protocol's minter list (verified at line 92)
- Protocol must have `IsBurnable = true` (verified at lines 87-88)

While minter status is privileged, it is a protocol-level permission (not a system-level trusted role like genesis/Parliament). Protocol creators routinely assign minters expecting they will operate within supply constraints via the normal `Mint()` function.

**Attack Execution:**
The attack is trivial to execute:
1. Minter calls `Burn(BurnInput { Symbol = "TARGET", TokenId = 1, Amount = -1000 })`
2. Transaction executes successfully
3. Balance, Supply, and Quantity all increase by 1000

**Practicality:**
- Zero complexity - single transaction
- No timing constraints or state dependencies
- No blockchain-level restrictions prevent negative protobuf `int64` values
- Fully reproducible under AElf runtime semantics

**Detection:**
The `Burned` event fires with the negative amount value, which would appear anomalous in logs but provides no prevention mechanism.

## Recommendation

Add explicit input validation before the balance check in the `Burn()` function:

```csharp
public override Empty Burn(BurnInput input)
{
    Assert(input.Amount > 0, "Invalid burn amount.");
    
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    // ... rest of existing logic
}
```

This mirrors the validation pattern used in:
- MultiToken's `AssertValidSymbolAndAmount()` helper
- NFT's own `DoTransfer()` function

## Proof of Concept

```csharp
[Fact]
public async Task BurnWithNegativeAmountInflatesSupply()
{
    // Setup: Create NFT protocol with burnable flag and supply limit
    var symbol = await CreateTest(); // Creates protocol with TotalSupply=1,000,000,000
    await AddMinterAsync(symbol);
    
    // Mint initial token
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Quantity = 100,
        TokenId = 1
    });
    
    // Verify initial state
    var initialBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    initialBalance.ShouldBe(100);
    
    var initialProtocol = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    var initialSupply = initialProtocol.Supply;
    initialSupply.ShouldBe(100);
    
    // EXPLOIT: Burn with negative amount
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = -1000 // Negative amount
    });
    
    // Verify exploit success: balance and supply INCREASED instead of decreased
    var finalBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    finalBalance.ShouldBe(1100); // 100 + 1000 = 1100 (INCREASED!)
    
    var finalProtocol = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    finalProtocol.Supply.ShouldBe(1100); // 100 + 1000 = 1100 (INCREASED!)
    
    // Attacker successfully minted 1000 tokens bypassing all supply checks
}
```

**Notes:**
- This vulnerability exists because the NFT contract lacks the input validation present in the MultiToken contract
- The SafeMath library correctly prevents arithmetic overflow but cannot prevent business logic errors from negative inputs
- Minters are protocol-level privileges, not system-level trusted roles, making this a valid privilege escalation vulnerability
- The vulnerability is directly reachable through the public `Burn()` method with no additional preconditions beyond normal minter status

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-406)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L24-24)
```csharp
        10.Sub(-5).ShouldBe(15);
```

**File:** protobuf/nft_contract.proto (L182-186)
```text
message BurnInput {
    string symbol = 1;
    int64 token_id = 2;
    int64 amount = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
