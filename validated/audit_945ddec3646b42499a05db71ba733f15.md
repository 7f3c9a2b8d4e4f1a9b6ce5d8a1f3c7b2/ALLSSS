# Audit Report

## Title
Insufficient Miner Selection in GetVictories() Leads to Undersized Consensus Round

## Summary
The `GetVictories()` function in the Election contract incorrectly limits backup miner selection to `currentMiners.Count` instead of `backups.Count`, causing consensus rounds to be generated with fewer miners than configured when the target miner count increases but valid candidates are insufficient.

## Finding Description

The vulnerability exists in the private `GetVictories(List<string> currentMiners)` method within the Election contract. [1](#0-0) 

When valid candidates (those with votes > 0) are insufficient to meet the target miner count, the function builds a backup list from current miners excluding valid candidates, then adds initial miners to this backup list. [2](#0-1) 

However, when selecting from these backups, the code incorrectly limits the selection to `Math.Min(diff, currentMiners.Count)` instead of `Math.Min(diff, backups.Count)`. [3](#0-2) 

Since `backups.Count` can exceed `currentMiners.Count` after adding initial miners, this causes fewer miners to be selected than both available and needed.

**Execution Path**:

1. The target miner count `State.MinersCount.Value` increases automatically over time via `GetAutoIncreasedMinersCount()` which adds 2 miners per `MinerIncreaseInterval`. [4](#0-3) 

2. During term transitions, `GenerateFirstRoundOfNextTerm()` calls `TryToGetVictories()` to fetch elected miners. [5](#0-4) 

3. `TryToGetVictories()` invokes the Election contract's `GetVictories()`. [6](#0-5) 

4. The undersized miner list is used to generate the new consensus round without validation. [7](#0-6) 

No validation exists to ensure the returned miner count matches the configured `State.MinersCount.Value`.

## Impact Explanation

This vulnerability causes **consensus degradation** through protocol invariant violation:

- **Undersized Consensus Rounds**: The blockchain operates with fewer block producers than configured, reducing decentralization and network security
- **State Inconsistency**: `State.MinersCount.Value` indicates N miners should participate, but actual rounds contain < N miners
- **Broken Protocol Invariant**: The fundamental assumption that consensus rounds contain exactly `State.MinersCount.Value` miners is violated

**Quantified Example**: If `State.MinersCount.Value = 10`, `validCandidates = 2`, `currentMiners.Count = 5`, and initial miners provide 5 additional backups (total `backups.Count = 8`), the function returns only 7 miners (2 valid + min(8,5) = 5 backups) instead of the required 10, leaving 3 miner slots unfilled.

The severity is **MEDIUM** because while it degrades consensus quality and violates protocol invariants, the chain continues to function and no funds are directly lost.

## Likelihood Explanation

This vulnerability has **MEDIUM-HIGH** likelihood:

**Triggering Conditions** (all realistic):
1. `State.MinersCount.Value` automatically increases by 2 miners every `MinerIncreaseInterval` seconds (default 1 year) [4](#0-3) 
2. Low voter participation results in `validCandidates.Count < State.MinersCount.Value`
3. Previous term had fewer miners than the new target count

**No Attack Required**: This is a logic bug that triggers under natural protocol operation during network growth phases with insufficient candidate onboarding or voter engagement. The default `SupposedMinersCount` starts at 17. [8](#0-7) 

The bug is logged but not prevented - debug statements show the incorrect count but no assertion validates it. [9](#0-8) 

## Recommendation

Change line 72 in `ViewMethods.cs` from:
```csharp
.Take(Math.Min(diff, currentMiners.Count))
```

To:
```csharp
.Take(Math.Min(diff, backups.Count))
```

This ensures all available backup miners are considered when filling the remaining miner slots, up to the required difference.

## Proof of Concept

The following test demonstrates the vulnerability by setting up a scenario where:
- Target miner count is 10 (via UpdateMinersCount)
- Only 2 valid candidates with votes exist
- Current miners count is 5
- Initial miners provide additional backups

The test verifies that GetVictories returns fewer than 10 miners (the bug), when it should return exactly 10.

```csharp
[Fact]
public async Task GetVictories_ReturnsInsufficientMiners_WhenBackupsExceedCurrentMiners()
{
    // Initialize contracts
    InitializeContracts();
    
    // Set target miner count to 10
    await AEDPoSContractStub.UpdateValue.SendAsync(new UpdateValueInput
    {
        Key = "MinersCount",
        Value = new Int64Value { Value = 10 }
    });
    
    // Update election contract with new miner count
    await ElectionContractStub.UpdateMinersCount.SendAsync(new UpdateMinersCountInput
    {
        MinersCount = 10
    });
    
    // Announce 7 candidates
    for (int i = 0; i < 7; i++)
    {
        await ElectionContractStub.AnnounceElection.SendAsync(new Empty());
    }
    
    // Only 2 candidates get votes (valid candidates)
    var validCandidates = ValidationDataCenterKeyPairs.Take(2).ToList();
    foreach (var candidate in validCandidates)
    {
        await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
        {
            CandidatePubkey = candidate.PublicKey.ToHex(),
            Amount = 100,
            EndTimestamp = TimestampHelper.GetUtcNow().AddDays(90)
        });
    }
    
    // Get victories
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // Bug: Should return 10 miners but returns fewer
    // Expected: 2 valid + 8 backups = 10 total
    // Actual: 2 valid + min(8, 5 currentMiners) = 7 total
    victories.Value.Count.ShouldBeLessThan(10); // Demonstrates the bug
    victories.Value.Count.ShouldBe(7); // Actual incorrect count
    
    // The correct behavior should be:
    // victories.Value.Count.ShouldBe(10);
}
```

**Notes**

The vulnerability is a protocol-level logic error that degrades consensus security during network growth. While the chain continues operating, running with fewer miners than configured violates the protocol's decentralization guarantees. The bug is deterministic and triggers under realistic conditions when miner count increases faster than candidate onboarding, requiring only normal protocol operations without any malicious actors.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-282)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
