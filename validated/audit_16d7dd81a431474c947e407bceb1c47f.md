# Audit Report

## Title
Integer Rounding in Fee Calculation Allows Fee Avoidance Through Transaction Splitting

## Summary
The TokenConverter contract's fee calculation uses `Convert.ToInt64()` on the product of transaction amount and fee rate, causing fees to round to zero for small transactions. With the standard 0.5% fee rate, any transaction paying ≤100 base tokens incurs zero fees. Users can exploit this by splitting large trades into sub-threshold chunks, completely avoiding Treasury donations and token burns. [1](#0-0) 

## Finding Description
The vulnerability exists in the fee calculation logic used by both trading functions. The `Buy()` function calculates fees using integer conversion that rounds decimal results. [2](#0-1)  The `Sell()` function uses identical rounding logic. [3](#0-2) 

**Root Cause**: C#'s `Convert.ToInt64()` performs banker's rounding (round to nearest integer, with 0.5 rounding to nearest even). When `amountToPay * GetFeeRate()` produces a value less than 0.5, the result rounds to 0. The fee rate is stored as a decimal string validated to be between 0 and 1. [4](#0-3)  It is parsed back as decimal for calculations. [5](#0-4) 

**Why Protections Fail**: The contract enforces no minimum transaction amount. The BancorHelper only validates amounts are positive (>0), not any minimum threshold. [6](#0-5)  The `PayLimit` parameter in Buy() only serves as maximum cost protection for buyers. [7](#0-6) 

**Fee Handling**: When fees are collected, they are split equally - half donated to Treasury, half burned. [8](#0-7)  However, fee handling only executes when `fee > 0`. [9](#0-8) 

**Exploitation**: With the standard fee rate of 0.005 (0.5%) used in tests [10](#0-9) , any transaction where `amountToPay * 0.005 < 0.5` (i.e., `amountToPay <= 100`) results in zero fees. A user can split any large transaction into chunks of 100 tokens or less to completely avoid all fees.

## Impact Explanation
**Direct Financial Loss:**
- For a 10,000 token transaction: normal fee = 50 tokens (10,000 × 0.005)
- Same transaction split into 100 × 100-token trades = 0 total fees
- 100% fee avoidance achieved through simple transaction splitting

**Protocol Damage:**
- Treasury loses donation revenue (50% of fees) that funds protocol operations and dividends
- Token burn mechanism fails to execute (other 50% of fees), failing to reduce circulating supply
- Economic model assumes fee collection; systematic exploitation undermines tokenomics
- Creates unfair advantage for sophisticated traders and bots

**Severity Justification (Medium):**
- Direct, quantifiable financial loss to protocol treasury and token supply management
- Does not compromise token security, consensus mechanisms, or user funds
- Requires deliberate action but is trivially automatable
- Impact scales linearly with trading volume exploiting the pattern

## Likelihood Explanation
**Attacker Profile:** Any user with tokens can exploit this - no special permissions or elevated privileges required.

**Attack Complexity:** Extremely simple:
1. Read fee rate via `GetFeeRate()` (publicly accessible view method)
2. Calculate zero-fee threshold: `0.5 / feeRate` (equals 100 for 0.5% fee)
3. Split desired transaction amount into sub-threshold chunks
4. Execute multiple `Buy()` or `Sell()` calls sequentially

**Economic Feasibility:**
- AElf transaction gas fees are typically minimal compared to fee savings on large amounts
- Break-even point is low - profitable for any transaction above ~1,000 tokens
- Arbitrage bots can automatically implement this pattern
- No detection or prevention mechanism exists on-chain

**Probability: High** - The exploit is trivial to execute, economically rational for significant transaction sizes, and has no effective countermeasures.

## Recommendation
Implement one of the following fixes:

1. **Use integer arithmetic throughout** (Recommended):
   - Store fee rate as basis points (e.g., 50 for 0.5%)
   - Calculate: `fee = (amountToPay * feeRateBasisPoints) / 10000`
   - This eliminates decimal rounding entirely

2. **Enforce minimum transaction amount**:
   - Add validation: `Assert(amountToPay >= MIN_TRANSACTION, "Transaction too small")`
   - Set MIN_TRANSACTION high enough that fees always round to at least 1

3. **Round up instead of banker's rounding**:
   - Replace: `Convert.ToInt64(amountToPay * GetFeeRate())`
   - With: `(long)Math.Ceiling(amountToPay * GetFeeRate())`
   - Ensures any fractional fee rounds to at least 1

## Proof of Concept

```csharp
[Fact]
public async Task FeeRoundingExploit_ZeroFeesOnSmallTransactions()
{
    // Setup: Initialize contract with 0.5% fee rate
    await CreateWriteToken();
    await InitializeTreasuryContractAsync();
    await InitializeTokenConverterContract(); // Uses 0.005 fee rate
    await PrepareToBuyAndSell();

    // Calculate expected behavior for amount paying exactly 100 base tokens
    var fromConnectorBalance = ELFConnector.VirtualBalance;
    var fromConnectorWeight = decimal.Parse(ELFConnector.Weight);
    var toConnectorBalance = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
    var toConnectorWeight = decimal.Parse(WriteConnector.Weight);
    
    // Find an amount that results in amountToPay ≤ 100
    long buyAmount = 95L; // Adjust based on Bancor calculation
    var amountToPay = BancorHelper.GetAmountToPayFromReturn(
        fromConnectorBalance, fromConnectorWeight,
        toConnectorBalance, toConnectorWeight, buyAmount);
    
    // Ensure amountToPay is in exploitable range
    amountToPay.ShouldBeLessThanOrEqualTo(100L);
    
    // Calculate expected fee: should round to 0
    var calculatedFee = Convert.ToInt64(amountToPay * 0.005m);
    calculatedFee.ShouldBe(0L); // Fee rounds to zero!
    
    var treasuryBalanceBefore = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
    var initialTreasuryBalance = treasuryBalanceBefore.Value.ContainsKey(NativeSymbol) 
        ? treasuryBalanceBefore.Value[NativeSymbol] : 0L;

    // Execute small transaction - should pay ZERO fees
    var buyResult = await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = WriteConnector.Symbol,
        Amount = buyAmount,
        PayLimit = 0 // No limit
    });
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Verify NO fees were collected
    var treasuryBalanceAfter = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
    var finalTreasuryBalance = treasuryBalanceAfter.Value.ContainsKey(NativeSymbol)
        ? treasuryBalanceAfter.Value[NativeSymbol] : 0L;
    
    // Treasury should receive NOTHING (fee was 0)
    (finalTreasuryBalance - initialTreasuryBalance).ShouldBe(0L);
    
    // Demonstrate exploit: Split large transaction to avoid fees
    // Normal: 10,000 token purchase with 1,000 amountToPay = 5 token fee
    // Exploited: 10 × 1,000 token purchases with 100 amountToPay each = 0 total fees
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L36-38)
```csharp
        var feeRate = AssertedDecimal(input.FeeRate);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-127)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L130-130)
```csharp
        if (fee > 0) HandleFee(fee);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-180)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L214-258)
```csharp
    private void HandleFee(long fee)
    {
        var donateFee = fee.Div(2);
        var burnFee = fee.Sub(donateFee);

        // Donate 0.5% fees to Treasury
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = donateFee
            });
        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Spender = State.DividendPoolContract.Value,
            Amount = donateFee
        });
        State.DividendPoolContract.Donate.Send(new DonateInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Amount = donateFee
        });

        // Transfer to self contract then burn
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = burnFee
            });
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L369-372)
```csharp
    private decimal GetFeeRate()
    {
        return decimal.Parse(State.FeeRate.Value);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-73)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConverterContractTests.cs (L359-359)
```csharp
            FeeRate = "0.005",
```
