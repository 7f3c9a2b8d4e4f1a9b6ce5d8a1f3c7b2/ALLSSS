# Audit Report

## Title
Insufficient Taylor Series Convergence in Ln() Causes Incorrect Bancor Pricing on Large Trades

## Summary
The `Ln()` function in BancorHelper uses a fixed 20-iteration Taylor series approximation that provides insufficient convergence when inputs approach the domain boundary (a near 2). This causes `GetAmountToPayFromReturn()` to underestimate payment requirements for large buy operations, allowing users to purchase tokens at a discount compared to correct Bancor pricing, resulting in direct protocol value leakage. [1](#0-0) 

## Finding Description

The vulnerability stems from a mathematical precision issue in the natural logarithm approximation used for Bancor price calculations.

The `Ln()` function implements the Taylor series expansion where `x = 1-a` and requires `0 < a < 2`. The implementation uses exactly 20 iterations regardless of input value. [2](#0-1)  The convergence constraint validates that `Math.Abs(x) >= 1` throws an exception [3](#0-2) , but this still allows values approaching the boundary where convergence is slowest (e.g., x = -0.988).

When users attempt to buy large amounts of tokens (approaching 50% of available connector balance), the formula in `GetAmountToPayFromReturn()` calculates `x = bt / (bt - a)`. [4](#0-3)  For example, when `a = 0.497 * bt`, this yields `x â‰ˆ 1.988`, placing it dangerously close to the convergence boundary.

This error propagates through the pricing formula. [5](#0-4)  The underestimated `Ln(x)` causes `Exp(y * Ln(x))` to be underestimated, resulting in a lower calculated payment amount.

The TokenConverter's `Buy()` method calls `GetAmountToPayFromReturn()` directly without any validation on maximum purchase percentage. [6](#0-5)  The only protection is the user-controlled `PayLimit` parameter [7](#0-6) , which an attacker would set sufficiently high or to 0 to bypass.

## Impact Explanation

**Direct Fund Loss:** The protocol loses a percentage of transaction value on large buy operations where users purchase 40-49% of available connector balance. On sufficiently large trades, this represents direct value leakage per transaction.

**Affected Parties:**
- **Protocol/Treasury**: Loses funds through systematically underpriced token sales
- **Token holders**: Experience value dilution as tokens are sold below market rate
- **Legitimate traders**: Face unfavorable pricing due to artificially depleted reserves

The mathematical error in the logarithm calculation propagates through the exponential function to produce underestimated payment requirements. Since the Buy() function transfers the calculated (underestimated) amount from users [8](#0-7)  while transferring the full requested token amount to them [9](#0-8) , the protocol's connector balance grows by less than the correct Bancor formula would require, breaking the pricing invariant.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Capital to execute large buy transactions (40-50% of connector balance)
- No special permissions, contract access, or governance control needed
- Single-transaction exploit via public `Buy()` method

**Attack Complexity:** Low - attacker simply calls `Buy()` with:
- `Symbol`: target token symbol
- `Amount`: calculated as ~49.7% of available connector balance (queryable via `GetDepositConnectorBalance` [10](#0-9) )
- `PayLimit`: set to 0 or sufficiently high value to bypass the check

**Feasibility Conditions:**
- Connectors must have sufficient liquidity (realistic for production TokenConverter deployments)
- No maximum trade size restrictions exist in the contract - inspection of the Buy() method confirms no such validation [11](#0-10) 
- No rate limiting prevents repeated exploitation
- Transactions appear legitimate and indistinguishable from normal large trades

**Detection Difficulty:** High - transactions emit standard `TokenBought` events with no anomaly indicators. The pricing error is only detectable through off-chain recalculation of expected Bancor prices.

## Recommendation

1. **Increase iteration count** in the Ln() function from 20 to a higher value (e.g., 50-100) to improve convergence near domain boundaries
2. **Add maximum purchase size validation** in the Buy() method to prevent purchases exceeding a certain percentage (e.g., 30-40%) of available connector balance
3. **Implement adaptive iteration count** based on the input value's distance from the convergence boundary
4. **Add stricter domain validation** to reject inputs that would produce x values with |x| > 0.95

Example fix for maximum purchase size:
```csharp
public override Empty Buy(BuyInput input)
{
    var toConnector = State.Connectors[input.Symbol];
    Assert(toConnector != null, "[Buy]Can't find to connector.");
    Assert(toConnector.IsPurchaseEnabled, "can't purchase");
    
    var toConnectorBalance = GetSelfBalance(toConnector);
    var maxPurchaseAmount = toConnectorBalance.Mul(40).Div(100); // 40% max
    Assert(input.Amount <= maxPurchaseAmount, "Purchase amount exceeds maximum allowed percentage");
    
    // ... rest of implementation
}
```

## Proof of Concept

A proof of concept test would:
1. Set up a connector pair with known balances (e.g., 1,000,000 tokens)
2. Calculate the exact payment required using high-precision logarithm calculations outside the contract
3. Call Buy() with Amount = 497,000 tokens (49.7% of balance)
4. Compare the actual payment transferred with the expected payment
5. Demonstrate that the actual payment is 1-3% less than expected, confirming the protocol loss

The test would demonstrate that for trades approaching 50% of connector balance, the 20-term Taylor series produces materially incorrect pricing that benefits the buyer at the protocol's expense.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-91)
```csharp
        var x = bt / (bt - a);
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L93-93)
```csharp
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```
