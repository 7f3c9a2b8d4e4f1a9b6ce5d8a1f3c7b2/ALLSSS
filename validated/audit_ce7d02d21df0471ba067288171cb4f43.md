# Audit Report

## Title
Conflict Resolution Failure in ApplyNormalConsensusData Leads to Duplicate Mining Orders

## Summary
When `supposedOrderOfNextRound` equals `minersCount`, the conflict resolution loop in `ApplyNormalConsensusData` fails to check order `minersCount` as a reassignment candidate. If all orders 1 through `minersCount-1` are occupied, the conflicted miner cannot be reassigned, resulting in two miners being assigned the same `FinalOrderOfNextRound` and identical mining time slots in the next round. [1](#0-0) 

## Finding Description

The vulnerability exists in the conflict resolution logic that determines next-round mining orders. When a miner produces a block, their `supposedOrderOfNextRound` is calculated as `GetAbsModulus(sigNum, minersCount) + 1`, yielding values from 1 to `minersCount`. [2](#0-1) [3](#0-2) 

If this order conflicts with an existing miner's `FinalOrderOfNextRound`, the system attempts to reassign the conflicted miner to an available order through the conflict resolution loop. [4](#0-3) 

**Root Cause**: When `supposedOrderOfNextRound = minersCount`, the loop iterates from `minersCount + 1` to `minersCount * 2 - 1`. The modulus operation `i % minersCount` produces values 1, 2, 3, ..., `minersCount-1`, completely skipping order `minersCount`. For example, with `minersCount = 5` and `supposedOrderOfNextRound = 5`:
- i=6: `maybeNewOrder = 6 % 5 = 1`
- i=7: `maybeNewOrder = 7 % 5 = 2`
- i=8: `maybeNewOrder = 8 % 5 = 3`
- i=9: `maybeNewOrder = 9 % 5 = 4`

The loop never checks order 5, only orders 1-4. If all these orders are occupied, the conflict cannot be resolved. The conflicted miner retains their original `FinalOrderOfNextRound`, and the current miner is also assigned the same order, creating a duplicate. [5](#0-4) 

## Impact Explanation

**Consensus Integrity Violation**: When next round generation occurs, both miners with identical `FinalOrderOfNextRound` values are assigned the same `Order` in the next round's miner information. [6](#0-5) 

This causes:

1. **Identical ExpectedMiningTime**: Both miners calculate the same mining timestamp based on their order, attempting to produce blocks simultaneously
2. **Fork Risk**: Two valid blocks produced at the same height/timestamp create blockchain forks
3. **Consensus Disruption**: Time-slot scheduling breaks down when multiple miners target the same slot
4. **Reward Misallocation**: One miner's block may be rejected or overridden, causing them to lose legitimate mining rewards

The existing validation does not catch this issue because `Distinct()` is called on `MinerInRound` objects (which compares all fields including pubkey), not on the `FinalOrderOfNextRound` values themselves. Two miners with the same order but different pubkeys pass validation. [7](#0-6) 

**Severity**: High - violates fundamental consensus invariant that each mining order must be unique, potentially causing network-wide fork events and disrupting block production.

## Likelihood Explanation

**Entry Point**: The vulnerability is triggered through standard `UpdateValue` consensus behavior when miners produce blocks. [8](#0-7) 

**Preconditions** (realistic):
1. All orders 1 through `minersCount-1` are occupied by miners who have produced blocks
2. One miner already has `FinalOrderOfNextRound = minersCount`
3. Another miner produces a block with a signature that hashes to `supposedOrderOfNextRound = minersCount`

**Execution Practicality**:
- No special permissions required - any authorized miner producing a block triggers this code path
- Near the end of each round, as miners produce blocks, all orders naturally become occupied
- Collision probability is `1/minersCount` per block (e.g., 20% with 5 miners)
- Common in smaller networks (5-7 miners typical for testnets/sidechains)

**Likelihood**: Medium to High - preconditions are naturally occurring as rounds progress and become increasingly probable with smaller miner counts.

## Recommendation

Fix the conflict resolution loop to include order `minersCount` in the search space. Change the loop condition or adjust the modulus calculation:

```csharp
for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
{
    var maybeNewOrder = i > minersCount ? (i % minersCount == 0 ? minersCount : i % minersCount) : i;
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
        break;
    }
}
```

Alternatively, iterate through all valid orders `1` to `minersCount` starting after `supposedOrderOfNextRound`:

```csharp
for (var offset = 1; offset < minersCount; offset++)
{
    var maybeNewOrder = ((supposedOrderOfNextRound + offset - 1) % minersCount) + 1;
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
        break;
    }
}
```

## Proof of Concept

```csharp
[Fact]
public void DuplicateFinalOrderOfNextRound_WhenOrderEqualsMinersCount()
{
    // Setup: 5 miners
    var minersCount = 5;
    var round = GenerateRoundWithMiners(minersCount);
    
    // Precondition: Occupy orders 1-4 and assign one miner order 5
    round.RealTimeMinersInformation["miner1"].FinalOrderOfNextRound = 1;
    round.RealTimeMinersInformation["miner2"].FinalOrderOfNextRound = 2;
    round.RealTimeMinersInformation["miner3"].FinalOrderOfNextRound = 3;
    round.RealTimeMinersInformation["miner4"].FinalOrderOfNextRound = 4;
    round.RealTimeMinersInformation["miner5"].FinalOrderOfNextRound = 5;
    
    // Trigger: miner6 produces block with signature hashing to order 5
    var signature = CreateSignatureHashingToOrder(5, minersCount);
    var updatedRound = round.ApplyNormalConsensusData(
        "miner6", Hash.Empty, Hash.Empty, signature);
    
    // Verify vulnerability: Both miner5 and miner6 have FinalOrderOfNextRound = 5
    Assert.Equal(5, updatedRound.RealTimeMinersInformation["miner5"].FinalOrderOfNextRound);
    Assert.Equal(5, updatedRound.RealTimeMinersInformation["miner6"].FinalOrderOfNextRound);
    
    // Impact: Next round generation assigns same Order and ExpectedMiningTime
    updatedRound.GenerateNextRoundInformation(
        Timestamp.FromDateTime(DateTime.UtcNow),
        Timestamp.FromDateTime(DateTime.UtcNow.AddDays(-1)),
        out var nextRound);
    
    var miner5NextRound = nextRound.RealTimeMinersInformation["miner5"];
    var miner6NextRound = nextRound.RealTimeMinersInformation["miner6"];
    
    // Consensus violation: identical mining slots
    Assert.Equal(miner5NextRound.Order, miner6NextRound.Order);
    Assert.Equal(miner5NextRound.ExpectedMiningTime, miner6NextRound.ExpectedMiningTime);
}
```

**Notes:**
- The vulnerability is mathematically certain when the preconditions are met
- The modulus operation `6 % 5 = 1, 7 % 5 = 2, 8 % 5 = 3, 9 % 5 = 4` definitively skips checking order 5
- This breaks the fundamental consensus invariant requiring unique mining orders per round
- The validation in `NextRoundMiningOrderValidationProvider` uses `Distinct()` on full `MinerInRound` objects, not just `FinalOrderOfNextRound`, allowing duplicates to pass

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
