# Audit Report

## Title
Auto-Distribution Break Statement Prevents Multiple Token Threshold Checks in TokenHolder Contract

## Summary
The `RegisterForProfits` function contains an unconditional `break` statement that exits the auto-distribution threshold checking loop after processing only the first qualifying token. This prevents subsequent tokens from being evaluated and distributed, causing partial auto-distribution failures in multi-token profit schemes.

## Finding Description

The TokenHolder contract's `RegisterForProfits` function implements auto-distribution logic to trigger profit distribution when token balances exceed configured thresholds. The function iterates through the `AutoDistributeThreshold` map to check each token's balance. [1](#0-0) 

The critical flaw occurs after adding the first qualifying token to `distributedInput.AmountsMap` - an unconditional `break` statement immediately exits the foreach loop, preventing evaluation of remaining tokens. [2](#0-1) 

The `AutoDistributeThreshold` field is explicitly defined as `map<string, int64>` in the protobuf schema, designed to support multiple token symbols with different threshold values. [3](#0-2) 

The downstream `DistributeProfits` function in the Profit contract only processes tokens explicitly listed in the `AmountsMap` parameter. When `AmountsMap` contains entries, the function iterates through them and fetches balances only for those specific tokens. [4](#0-3) 

This means tokens not added to `AmountsMap` due to the premature loop exit will not be distributed, even when their balances exceed configured thresholds.

## Impact Explanation

**Reward Misallocation:**
When multiple token types accumulate in a profit scheme's virtual address and multiple thresholds are simultaneously met, only the first token encountered in the dictionary iteration will be auto-distributed. Other qualifying tokens remain locked in the virtual address, unable to be automatically distributed to beneficiaries.

**Affected Scenarios:**
Multi-token profit schemes are a standard feature demonstrated in the test suite, where schemes are configured with multiple token thresholds (ELF and secondary tokens). [5](#0-4) 

The test expects both tokens to be distributed and verifies that the profit map contains 2 tokens after auto-distribution. [6](#0-5) 

**Severity - Medium:**
This issue breaks intended profit distribution functionality and requires manual intervention to distribute stuck profits. While funds are not stolen or permanently lost, the auto-distribution mechanism fails to perform its intended purpose, causing operational disruption and requiring scheme managers to manually trigger distributions for the remaining tokens.

## Likelihood Explanation

**Reachable Entry Point:**
The `RegisterForProfits` method is a public function callable by any user who wants to lock tokens and register for profit distribution. [7](#0-6) 

**Feasible Preconditions:**
1. A profit scheme is created with multiple token symbols in `AutoDistributeThreshold`
2. Multiple token types are contributed to the scheme
3. Multiple tokens simultaneously exceed their configured thresholds
4. Any user calls `RegisterForProfits`

These conditions represent standard production usage. The test suite explicitly demonstrates multi-token schemes with multiple thresholds (native token and "JUN" token), confirming this is an expected and realistic scenario. [8](#0-7) 

**Execution Practicality:**
The bug triggers automatically during normal operation without requiring special manipulation. When any user calls `RegisterForProfits` and multiple threshold conditions are met, only the first qualifying token is distributed while others remain stuck.

## Recommendation

Remove the unconditional `break` statement to allow the loop to continue evaluating all tokens in the `AutoDistributeThreshold` map. The corrected logic should:

1. Continue iterating through all thresholds
2. Add each qualifying token to `distributedInput.AmountsMap`
3. Only exit the loop naturally after checking all tokens

The fix involves removing line 199 from the TokenHolderContract.cs file, allowing the foreach loop to evaluate all configured thresholds before proceeding with distribution.

## Proof of Concept

The existing test `RegisterForProfits_With_Auto_Distribute_Test` demonstrates the expected behavior but would fail to verify the second token distribution if the test checked the virtual address balances. The test at lines 358-419 creates a scheme with two token thresholds, contributes both tokens at the threshold amount, then calls `RegisterForProfits`. With the current bug, only the first token (determined by dictionary iteration order) would be distributed, leaving the second token stuck in the virtual address despite meeting its threshold. [9](#0-8) 

## Notes

The vulnerability is confirmed through code analysis showing the break statement at line 199 prevents multi-token evaluation, the protobuf definition explicitly supporting multiple tokens in the map, the downstream Profit contract only processing tokens in AmountsMap, and test evidence demonstrating multi-token scenarios are intended functionality. The impact is real but contained - funds are not lost, but the auto-distribution mechanism fails partially, requiring manual intervention for affected tokens.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-149)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** protobuf/token_holder_contract.proto (L125-126)
```text
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 5;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-446)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L358-419)
```csharp
    [Fact]
    public async Task RegisterForProfits_With_Auto_Distribute_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        var tokenA = "JUN";
        await StarterCreateIssueAndApproveTokenAsync(tokenA, 1000000L, 100000L);
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol,
            AutoDistributeThreshold =
            {
                { nativeTokenSymbol, amount },
                { tokenA, amount }
            }
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = tokenA
        });
        var beforeLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var afterLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        beforeLockBalance.ShouldBe(afterLockBalance.Add(amount));
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds.First();
        var profitMap = await ProfitContractStub.GetProfitsMap.CallAsync(new Profit.ClaimProfitsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitMap.Value.Count.ShouldBe(2);
        profitMap.Value.ContainsKey(nativeTokenSymbol).ShouldBeTrue();
        profitMap.Value[nativeTokenSymbol].ShouldBe(amount);
        var schemeInfoInProfit = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var schemeInfoInTokenHolder = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
        schemeInfoInProfit.CurrentPeriod.ShouldBe(2);
        schemeInfoInTokenHolder.Period.ShouldBe(2);
    }
```
