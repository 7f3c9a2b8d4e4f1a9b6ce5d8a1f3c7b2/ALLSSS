# Audit Report

## Title
Continuous Blocks Validation Bypasses Severe Status Limit Due to Stale IrreversibleBlockHeight-Based Threshold

## Summary
The `ContinuousBlocksValidationProvider` validates blocks using a stale `LatestPubkeyToTinyBlocksCount` value from the previous block's execution, rather than considering the current blockchain status. When the network transitions from Normal to Severe status (due to LIB lagging significantly), miners can produce up to 8 consecutive blocks instead of being limited to 1 block as intended, violating the consensus safety mechanism designed to force frequent miner rotation during critical network conditions.

## Finding Description

The vulnerability exists in the timing mismatch between validation and state updates during block processing.

**Validation Phase (Pre-Execution):**
The validation context retrieves `LatestPubkeyToTinyBlocksCount` from state, which was set during the previous block's post-execution phase. [1](#0-0) 

The `ContinuousBlocksValidationProvider` only checks if `BlocksCount < 0`, without considering the current blockchain status or LIB position. [2](#0-1) 

**State Update Phase (Post-Execution):**
After block execution, `GetMaximumBlocksCount()` is called to determine the appropriate limit based on current LIB status. When the blockchain is in Severe status (R >= R_LIB + 8), the limit should be 1 consecutive block per miner. [3](#0-2) 

The blockchain status is determined by comparing current round number with LIB round number. [4](#0-3) 

**Critical Flaw:**
When the same miner produces consecutive blocks, `ResetLatestProviderToTinyBlocksCount()` only decrements the existing `BlocksCount` by 1, regardless of the current blockchain status. [5](#0-4) 

Additionally, the maximum blocks count constant is set to 8. [6](#0-5) 

**Attack Scenario:**
1. Miner A starts producing blocks in Normal status with `BlocksCount = 7`
2. Network conditions cause LIB to lag, transitioning to Severe status
3. Validation still uses the stale `BlocksCount = 7`, which passes (7 >= 0)
4. Post-execution calls `GetMaximumBlocksCount()` which returns 1, but then `ResetLatestProviderToTinyBlocksCount()` decrements to 6
5. Next block validation uses `BlocksCount = 6`, still passes
6. This continues: 6→5→4→3→2→1→0→-1, allowing 8 total consecutive blocks
7. Only when `BlocksCount` becomes -1 does validation finally fail

This allows miners to produce up to 8 consecutive blocks in Severe status, when the protocol explicitly limits them to 1 block to force rotation and help achieve consensus.

## Impact Explanation

**Critical Consensus Safety Violation:**
The Severe blockchain status is triggered when LIB falls dangerously behind (8+ rounds). During this critical period, the consensus protocol is designed to force frequent miner rotation by limiting each miner to producing only 1 consecutive block before another miner must take over. This mechanism helps the network achieve consensus and advance LIB during periods of network stress, partitions, or slow block propagation.

This vulnerability defeats that safety mechanism entirely. A miner who began producing blocks before the Severe status transition can continue producing up to 8 consecutive blocks, representing an 8x violation of the intended safety limit.

**Quantified Damage:**
- Instead of 1 block per miner in Severe status, miners can produce up to 8 blocks
- The extra 7 blocks occur during the most critical network conditions
- This prolongs the period where a single miner controls block production
- Increases fork risk and worsens network split conditions when consensus is already struggling
- Defeats the fork-prevention mechanism at precisely the time it's most needed

**Affected Parties:**
All network participants suffer from prolonged consensus instability, increased fork probability, and delayed LIB advancement during critical network conditions.

## Likelihood Explanation

**Attack Complexity: Low**
This vulnerability triggers automatically during normal network operations without requiring any malicious intent or special capabilities. It occurs naturally when:
1. Network stress causes LIB to lag by 8+ rounds (common during partitions or slow propagation)
2. Blockchain status transitions from Normal to Severe
3. A miner happens to be producing consecutive blocks at the time of transition

**Attacker Capabilities: None Required**
No special permissions, collusion, or attack infrastructure needed. Any miner producing consecutive blocks when the status transition occurs will automatically exceed the Severe limit.

**Preconditions: Realistic**
Network conditions causing LIB lag occur regularly in distributed consensus systems. Status transitions are part of normal protocol operation during network stress. Miners naturally produce consecutive blocks during their assigned time slots.

**Detection Difficulty: High**
The extra blocks are validly signed, properly timestamped, and pass all other consensus checks. They appear as legitimate block production, making the violation difficult to detect without specifically monitoring BlocksCount against current blockchain status.

**Probability: High**
Status transitions occur frequently during network stress periods, and miners routinely produce multiple consecutive blocks. The vulnerability triggers deterministically whenever these common conditions align.

## Recommendation

Modify `ResetLatestProviderToTinyBlocksCount()` to respect the current blockchain status when updating the blocks counter. When the blockchain is in Severe status and a miner is continuing production, the counter should be reset to enforce the new limit immediately, rather than simply decrementing by 1.

Specifically, change the logic to:
- If same miner AND new limit (`minersCountInTheory`) is lower than current `BlocksCount`, reset to the new limit minus 1 (or even 0 to enforce immediate rotation)
- This ensures that status transitions immediately enforce the new consecutive blocks limit

Alternatively, add blockchain status awareness to the validation phase by checking the current LIB position during `ContinuousBlocksValidationProvider.ValidateHeaderInformation()`, not just the stale counter value.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a test network with miners producing blocks normally
2. Artificially delaying LIB advancement to trigger Severe status
3. Observing that a miner who started with `BlocksCount = 7` continues producing 8 consecutive blocks
4. Verifying that the protocol intended limit of 1 block in Severe status is violated

The code evidence clearly shows this flow is possible based on the validation logic using stale state and the decrement-only update logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L58-58)
```csharp
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
