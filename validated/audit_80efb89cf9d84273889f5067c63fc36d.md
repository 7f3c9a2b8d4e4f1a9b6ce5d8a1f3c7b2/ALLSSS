# Audit Report

## Title
TokenHolder RemoveBeneficiary Allows Profit Rights Revocation While Tokens Remain Locked

## Summary
The `RemoveBeneficiary` function in TokenHolderContract allows scheme managers to remove a user's beneficiary status from the profit scheme while their tokens remain locked in the MultiToken contract. This creates a critical state inconsistency where users have tokens forcibly locked without receiving any profit distributions until the minimum lock period expires, violating the fundamental economic invariant that locked tokens should always entitle holders to profits.

## Finding Description

The vulnerability exists in the `RemoveBeneficiary` function which only removes beneficiary status from the Profit contract but fails to check for or unlock the corresponding locked tokens. [1](#0-0) 

When a user calls `RegisterForProfits`, three interconnected state changes occur atomically: (1) tokens are locked via MultiToken contract, (2) the lockId is stored in `State.LockIds[schemeManager][user]`, and (3) the user is added as a beneficiary with shares equal to the locked amount. [2](#0-1) 

However, `RemoveBeneficiary` only reverses step 3 by removing the beneficiary from the Profit contract, leaving the tokens locked and the lockId in state. The function retrieves the profit details, calls `State.ProfitContract.RemoveBeneficiary.Send()`, and conditionally re-adds the beneficiary with reduced shares, but never validates lock state or performs any unlock operation. [1](#0-0) 

**Why Protections Fail:**

The only function that removes lockIds from state is `Withdraw`, which users cannot call until the minimum lock period expires. [3](#0-2) 

Users cannot directly unlock their tokens from the MultiToken contract because the virtual address for locking is computed as `HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value).Concat(input.LockId.Value).ToArray())` where `Context.Sender` is the TokenHolder contract address. [4](#0-3) 

The unlock operation requires `IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address`, but even if the user satisfies the origin check, the virtual address computation would differ when called directly by the user versus when called through TokenHolder, making direct unlock impossible. [5](#0-4) 

When `Withdraw` is eventually called, it attempts to remove the beneficiary again, but the Profit contract's `RemoveBeneficiary` gracefully handles non-existent beneficiaries by returning early without error. [6](#0-5) 

TokenHolder schemes are always created with `CanRemoveBeneficiaryDirectly = true`, enabling this vulnerability. [7](#0-6) 

## Impact Explanation

This vulnerability causes direct financial harm to users in multiple ways:

1. **Profit Loss**: Users' locked tokens no longer generate any profit rights. During the lock period, all profits that should be distributed to the affected user are instead redistributed proportionally to remaining beneficiaries, effectively stealing the user's rightful share.

2. **Forced Lock Without Benefit**: Users cannot access their locked tokens until the minimum lock period expires (configurable per scheme), creating a situation where capital is locked without any return.

3. **Economic Invariant Violation**: The scheme design explicitly creates locked tokens and beneficiary status together as an atomic operation, establishing the reasonable expectation that these states remain synchronized. Breaking this invariant undermines the fundamental economics of the profit-sharing mechanism.

**Quantified Example**: If a user locks 1,000 tokens representing 10% of total locked amount, and 10,000 tokens are distributed as profits after the manager removes their beneficiary status, the user receives 0 tokens instead of the expected 1,000 tokens. The remaining beneficiaries receive this 1,000 tokens as additional profit.

This is CRITICAL severity because it enables theft of profit rights while tokens remain forcibly locked, directly impacting user funds and protocol economic guarantees.

## Likelihood Explanation

The likelihood is HIGH due to the following factors:

**Attacker Profile**: The attacker must be the scheme manager, which is set when `CreateScheme` is called. This is not a trusted system role but rather any user who creates a profit scheme. Realistic threat scenarios include:
- A scheme manager turning malicious after users have locked tokens
- A compromised scheme manager account
- An honest mistake by a manager not realizing tokens remain locked
- A multi-signature scheme manager with one malicious member

**Attack Complexity**: The attack requires only a single transaction calling `RemoveBeneficiary` with `amount = 0` to completely remove the user's beneficiary status while leaving tokens locked. [8](#0-7) 

**Economic Incentive**: Scheme managers have a direct financial incentive to remove other beneficiaries because it increases their own proportional share of distributed profits. This creates a strong motivation for exploitation.

**Detection Difficulty**: The operation appears as legitimate beneficiary management, with no audit trail or warning indicating that tokens remain locked without profit rights.

**Preconditions**: Only requires that users have called `RegisterForProfits` (normal operation) and the attacker is the scheme manager (privileged but realistic role).

## Recommendation

Add a check in `RemoveBeneficiary` to verify whether the beneficiary has an active lock, and if so, either:

**Option 1 (Recommended)**: Prevent removal of beneficiaries who have locked tokens:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if user has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary with active locked tokens. User must withdraw first.");
    
    var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details.Single();
    var lockedAmount = detail.Shares;
    
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    
    if (lockedAmount > input.Amount && input.Amount != 0)
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = lockedAmount.Sub(input.Amount)
            }
        });
    
    return new Empty();
}
```

**Option 2**: Automatically unlock tokens when removing beneficiary:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if user has locked tokens and unlock them
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    if (lockId != null)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value = 
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        
        var lockedAmount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
        
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Amount = lockedAmount,
            Symbol = scheme.Symbol
        });
        
        State.LockIds[Context.Sender].Remove(input.Beneficiary);
    }
    
    var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details.Single();
    var lockedAmount = detail.Shares;
    
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    
    if (lockedAmount > input.Amount && input.Amount != 0)
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = lockedAmount.Sub(input.Amount)
            }
        });
    
    return new Empty();
}
```

Option 1 is recommended as it maintains the invariant that locked tokens always have beneficiary rights by preventing the desynchronization.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_LeavesTokensLocked_WithoutProfitRights()
{
    // Setup: Create scheme and register user with locked tokens
    var schemeManager = Accounts[0].Address;
    var user = Accounts[1].Address;
    var lockAmount = 1000;
    
    // Create scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100 // 100 minutes minimum lock
    });
    
    // User registers and locks tokens
    await TokenHolderContractUser.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = lockAmount
    });
    
    // Verify user has locked tokens and beneficiary status
    var lockId = await TokenHolderContractStub.GetScheme.CallAsync(schemeManager);
    var userLockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        LockId = lockId.LockId,
        Symbol = "ELF"
    });
    Assert.Equal(lockAmount, userLockedAmount.Amount);
    
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = lockId.SchemeId,
        Beneficiary = user
    });
    Assert.Equal(lockAmount, profitDetails.Details[0].Shares);
    
    // Manager removes beneficiary
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = user,
        Amount = 0 // Complete removal
    });
    
    // Verify user still has locked tokens
    userLockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        LockId = lockId.LockId,
        Symbol = "ELF"
    });
    Assert.Equal(lockAmount, userLockedAmount.Amount); // Tokens still locked!
    
    // Verify user no longer has beneficiary status
    profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = lockId.SchemeId,
        Beneficiary = user
    });
    Assert.Empty(profitDetails.Details); // No beneficiary rights!
    
    // Verify user cannot withdraw yet (minimum lock period not elapsed)
    var result = await TokenHolderContractUser.Withdraw.SendWithExceptionAsync(schemeManager);
    Assert.Contains("Cannot withdraw", result.TransactionResult.Error);
    
    // This proves: tokens locked + no profit rights + cannot withdraw = vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-210)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L230-235)
```csharp
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```
