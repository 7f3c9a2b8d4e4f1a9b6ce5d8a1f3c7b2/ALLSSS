# Audit Report

## Title
Large ByteString DoS via Unconstrained OutValue and Signature Fields in Consensus Validation

## Summary
The AEDPoS consensus validation pipeline fails to enforce size constraints on `OutValue` and `Signature` hash fields, validating only non-emptiness via `.Any()` instead of the expected 32-byte hash size. A malicious elected miner can exploit this to produce blocks containing arbitrarily large ByteStrings (up to the 100MB gRPC limit), causing resource exhaustion across all validating nodes through expensive protobuf deserialization and state bloat.

## Finding Description

The vulnerability exists in the consensus validation logic where `OutValue` and `Signature` fields undergo insufficient validation. The `NewConsensusInformationFilled` method only verifies that these ByteStrings are non-empty, without enforcing the canonical 32-byte SHA256 hash size: [1](#0-0) 

The protobuf `Hash` type itself imposes no size constraint, defining only an unconstrained `bytes` field: [2](#0-1) 

While `Hash.LoadFromByteArray()` enforces strict 32-byte validation, this method is never invoked during the validation flow: [3](#0-2) 

**Attack Execution Path:**

1. **Entry Point**: `ValidateConsensusBeforeExecution` parses consensus data via protobuf deserialization without size checks: [4](#0-3) 

2. **Validation Pipeline**: The validation invokes `UpdateValueValidationProvider` for `UpdateValue` behavior: [5](#0-4) 

3. **Value Assignment**: `RecoverFromUpdateValue` directly assigns oversized values without validation: [6](#0-5) 

4. **State Persistence**: If validation passes, `ProcessUpdateValue` persists oversized values to state: [7](#0-6) 

The network layer permits messages up to 100MB, enabling significant resource consumption: [8](#0-7) 

## Impact Explanation

**Medium Severity - Consensus Resource Exhaustion DoS**

This vulnerability enables a resource consumption attack with the following impacts:

1. **Memory Exhaustion**: Protobuf `Parser.ParseFrom()` allocates memory proportional to ByteString size. A malicious miner could embed 10-20MB in each field within the 100MB gRPC limit, causing significant memory consumption during deserialization.

2. **CPU Waste**: Expensive deserialization and subsequent `GetHash()` operations (which call `ToByteArray()` on the round) scale linearly with data size, wasting CPU cycles on invalid data.

3. **Network Amplification**: The malicious block propagates to all validators via P2P gossip. Each validator independently parses and processes the same oversized data, multiplying resource consumption network-wide.

4. **State Bloat**: If validation passes and execution proceeds, oversized values are permanently stored in `State.Rounds`, causing long-term state storage pollution.

The severity is Medium rather than High because:
- Requires a compromised elected miner (high privilege threshold)
- Impact limited to resource consumption, not fund theft or permanent consensus halt
- Rate-limited by the malicious miner's block production schedule
- Eventually detectable through monitoring and potential governance intervention

However, this violates the critical security principle that validation should be cheap and fail-fast on malformed input.

## Likelihood Explanation

**Medium Likelihood**

**Attacker Prerequisites:**
- Must be an elected block producer through the standard AElf election mechanism
- Miners are elected participants, not inherently trusted roles
- Compromise vectors include key theft, malicious post-election behavior, or coordinated multi-miner attacks

**Attack Complexity:**
Once miner status is achieved, execution is trivial:
1. Generate standard consensus trigger information
2. Modify `OutValue.Value` and `Signature.Value` ByteStrings to oversized values (e.g., 10MB each)
3. Produce and broadcast the block

The `.Any()` check passes for any non-empty ByteString regardless of size, providing zero protection against this attack vector.

**Detection:**
Resource exhaustion manifests immediately across all validators during block propagation and validation, before any post-execution checks can reject the block.

## Recommendation

Enforce strict 32-byte size validation for `OutValue` and `Signature` fields in the `NewConsensusInformationFilled` method:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound =
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Enforce 32-byte hash size constraint
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Length == AElfConstants.HashByteArrayLength &&
           minerInRound.Signature.Value.Length == AElfConstants.HashByteArrayLength;
}
```

This ensures validation fails fast on malformed input before expensive deserialization and state operations occur.

## Proof of Concept

```csharp
[Fact]
public async Task UpdateValue_WithOversizedOutValueAndSignature_ShouldFailValidation()
{
    // Arrange: Create oversized ByteStrings (10MB each)
    var oversizedValue = ByteString.CopyFrom(new byte[10 * 1024 * 1024]);
    
    var updateValueInput = new UpdateValueInput
    {
        OutValue = new Hash { Value = oversizedValue },
        Signature = new Hash { Value = oversizedValue },
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        // ... other required fields
    };
    
    // Act: Attempt to process the update
    var result = await AEDPoSContractStub.UpdateValue.SendAsync(updateValueInput);
    
    // Assert: Should fail validation due to oversized hashes
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Incorrect new Out Value");
}
```

This test demonstrates that oversized hash values currently bypass validation and cause resource exhaustion. With the recommended fix, the validation should fail immediately with appropriate error messaging.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** protobuf/aelf/core.proto (L140-143)
```text
message Hash
{
    bytes value = 1;
}
```

**File:** src/AElf.Types/Types/Hash.cs (L49-58)
```csharp
        public static Hash LoadFromByteArray(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.HashByteArrayLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Hash
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** src/AElf.OS.Network.Grpc/GrpcConstants.cs (L28-29)
```csharp
    public const int DefaultMaxReceiveMessageLength = 100 * 1024 * 1024;
    public const int DefaultMaxSendMessageLength = 100 * 1024 * 1024;
```
