# Audit Report

## Title
Seed NFT Expiration Time Overflow Enables Permanent Symbol Monopolization

## Summary
The `ExtendSeedExpirationTime` method lacks input validation on the expiration time parameter, allowing seed NFT owners to set expiration times to extreme values like `long.MaxValue`. This breaks critical expiration validation logic, permanently blocking new seed creation for affected symbols and enabling indefinite seed validity.

## Finding Description

The vulnerability exists in the `ExtendSeedExpirationTime` method which updates a seed NFT's expiration time without any bounds validation. [1](#0-0) 

The method only verifies that the caller is the seed owner but performs no validation on `input.ExpirationTime`, allowing arbitrary values including `long.MaxValue` (9223372036854775807) to be stored directly in the seed's external information.

This breaks two critical expiration validation mechanisms:

**1. CheckSymbolSeed - Blocks New Seed Creation:**

When creating a new SEED NFT, the system validates that any existing seed for the same symbol has expired by checking `Context.CurrentBlockTime.Seconds > symbolSeedExpireTime`. [2](#0-1) 

With `symbolSeedExpireTime = long.MaxValue` (representing year ~292 billion), this condition never becomes true, causing the assertion to permanently fail with "OwnedSymbol has been created", preventing any new seeds from being created for that symbol.

**2. CheckSeedNFT - Enables Indefinite Validity:**

When using a seed to create a token, the system validates the seed hasn't expired by checking `Context.CurrentBlockTime.Seconds <= expirationTimeLong`. [3](#0-2) 

With `expirationTimeLong = long.MaxValue`, this check always passes, allowing the seed to be used indefinitely without expiration.

The attack requires only:
1. Acquiring/creating a SEED NFT for a target symbol
2. Calling `ExtendSeedExpirationTime` with `ExpirationTime = long.MaxValue`
3. The symbol becomes permanently monopolized with no on-chain recovery mechanism

## Impact Explanation

This constitutes a **permanent denial of service attack** on the symbol namespace, a critical and finite protocol resource. The impact includes:

- **Permanent Monopolization**: Valuable symbol names can be indefinitely reserved, blocking legitimate token creation for those symbols
- **No Recovery Mechanism**: Once set to extreme values, there is no administrative function to force-expire or reclaim symbols without a contract upgrade
- **Symbol Namespace Fragmentation**: Creates a polluted namespace with reserved but potentially unused symbols
- **Ecosystem Degradation**: Hinders project launches and token creation across the AElf ecosystem

While this doesn't result in direct fund theft or supply inflation, it breaks the critical protocol invariant that expired seeds should be replaceable and permanently damages availability of a finite protocol resource.

## Likelihood Explanation

The vulnerability has **high likelihood** of exploitation due to:

**Minimal Prerequisites:**
- Attacker only needs to own a SEED NFT (acquirable through normal creation or secondary market)
- No special privileges or governance control required
- `ExtendSeedExpirationTime` is a public RPC function accessible to any seed owner [4](#0-3) 

**Trivial Attack Complexity:**
- Single transaction with arbitrary expiration time value
- No complex state manipulation or timing requirements
- 100% attack reliability
- No rate limiting or cooldown mechanisms

**Economic Rationality:**
- Minimal attack cost (transaction fee + seed acquisition)
- High value for desirable symbols (common words, brand names, ticker symbols)
- Rational for symbol squatting or competitive advantage
- Difficult to detect until new seed creation is attempted

## Recommendation

Add input validation to `ExtendSeedExpirationTime` to enforce reasonable upper bounds on expiration times:

```csharp
public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
{
    var tokenInfo = GetTokenInfo(input.Symbol);
    if (tokenInfo == null)
    {
        throw new AssertionException("Seed NFT does not exist.");
    }

    Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
    
    // Add validation: expiration time must be reasonable
    var maxAllowedExpiration = Context.CurrentBlockTime.Seconds + (365L * 24 * 60 * 60 * 10); // 10 years max
    Assert(input.ExpirationTime > Context.CurrentBlockTime.Seconds, "Expiration time must be in the future.");
    Assert(input.ExpirationTime <= maxAllowedExpiration, "Expiration time exceeds maximum allowed period.");
    
    var oldExpireTimeLong = 0L;
    if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
            out var oldExpireTime))
    {
        long.TryParse(oldExpireTime, out oldExpireTimeLong);
    }

    tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
        input.ExpirationTime.ToString();
    State.TokenInfos[input.Symbol] = tokenInfo;
    Context.Fire(new SeedExpirationTimeUpdated
    {
        ChainId = tokenInfo.IssueChainId,
        Symbol = input.Symbol,
        OldExpirationTime = oldExpireTimeLong,
        NewExpirationTime = input.ExpirationTime
    });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ExtendSeedExpirationTime_Overflow_Monopolization_Test()
{
    // Setup: Create a SEED NFT for symbol "TEST"
    var symbol = "TEST";
    var seedSymbol = "SEED-1";
    var expirationTime = TimestampHelper.GetUtcNow().AddDays(1).Seconds;
    
    // Create SEED NFT
    await CreateSeedCollection();
    await CreateSeed(seedSymbol, symbol, expirationTime);
    
    // Attack: Extend expiration to long.MaxValue
    await TokenContractStub.ExtendSeedExpirationTime.SendAsync(new ExtendSeedExpirationTimeInput
    {
        Symbol = seedSymbol,
        ExpirationTime = long.MaxValue
    });
    
    // Verify: Seed never expires - can still use seed to create token even after original expiration
    await BlockTimeProvider.SetBlockTime(TimestampHelper.GetUtcNow().AddYears(100).Seconds);
    
    // This should succeed (seed still valid)
    var result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true,
        Owner = DefaultAddress
    });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Cannot create new seed for same symbol (permanent monopolization)
    var newSeedResult = await TokenContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        Symbol = "SEED-2",
        TokenName = "SEED-2",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                [TokenContractConstants.SeedOwnedSymbolExternalInfoKey] = symbol,
                [TokenContractConstants.SeedExpireTimeExternalInfoKey] = TimestampHelper.GetUtcNow().AddDays(1).Seconds.ToString()
            }
        }
    });
    newSeedResult.TransactionResult.Error.ShouldContain("OwnedSymbol has been created");
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L57-67)
```csharp
    private void CheckSymbolSeed(string ownedSymbol)
    {
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];

        Assert(oldSymbolSeed == null || !GetTokenInfo(oldSymbolSeed).ExternalInfo.Value
                   .TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var oldSymbolSeedExpireTime) ||
               !long.TryParse(oldSymbolSeedExpireTime, out var symbolSeedExpireTime)
               || Context.CurrentBlockTime.Seconds > symbolSeedExpireTime,
            "OwnedSymbol has been created");
    }
```

**File:** protobuf/token_contract_impl.proto (L195-196)
```text
    rpc ExtendSeedExpirationTime (ExtendSeedExpirationTimeInput) returns (google.protobuf.Empty) {
    }
```
