# Audit Report

## Title
Precision Loss in Individual Beneficiary Profit Claims Locks Tokens Permanently

## Summary
The Profit Contract's `SafeCalculateProfits()` function performs decimal-to-long conversion with truncation when calculating individual beneficiary shares. When multiple beneficiaries claim from the same period, the sum of their truncated claims is less than the total distributed amount, permanently locking the remainder in period-specific virtual addresses with no recovery mechanism.

## Finding Description

The root cause lies in the `SafeCalculateProfits()` function which converts long integers to decimal, performs division, and casts back to long with truncation: [1](#0-0) 

This function is used in two contexts with different security outcomes:

**1. Sub-scheme distribution (safe):** When distributing to sub-schemes via `DistributeProfitsForSubSchemes()`, the code tracks `remainAmount` after each truncated calculation: [2](#0-1) 

The remainder is then transferred to the period virtual address: [3](#0-2) 

**2. Individual beneficiary claims (vulnerable):** When beneficiaries claim their profits via `ProfitAllPeriods()`, each claim is calculated independently without any remainder tracking: [4](#0-3) 

At line 873, each beneficiary's amount is calculated using `SafeCalculateProfits` with truncation, and at lines 887-895, this truncated amount is transferred from the period's virtual address. There is no mechanism to aggregate claims or verify that the sum equals the distributed total.

**Why tokens become permanently locked:**

Each period has a unique virtual address generated cryptographically: [5](#0-4) 

Once all beneficiaries have claimed, any remainder due to truncation stays locked in the period's virtual address permanently because:

1. **No new beneficiaries can be added to past periods** - beneficiaries are added with a start period that is at minimum the current period: [6](#0-5) 

2. **No admin rescue function exists** - verified by examining all public methods in the Profit Contract protobuf definition. No function allows extracting funds from period virtual addresses.

3. **Cannot contribute to past periods** - the `ContributeProfits` function explicitly prevents this: [7](#0-6) 

4. **Beneficiaries cannot claim multiple times from the same period** - the `LastProfitPeriod` is updated after each claim, preventing double-claiming: [8](#0-7) 

## Impact Explanation

**Direct Fund Loss:**
Tokens are permanently locked and removed from circulation. For example, with 3 beneficiaries holding 1 share each (total 3 shares) claiming from a period that distributed 100 tokens:
- Each beneficiary receives: `(long)(100 * 1 / 3)` = `(long)(33.333...)` = 33 tokens
- Total claimed: 99 tokens
- **Permanently locked: 1 token in the period's virtual address**

**Systemic Scale:**
- Occurs in every distribution period where `(totalAmount * shares / totalShares)` produces a remainder
- Common scenarios: odd numbers of equal beneficiaries, any shares that don't evenly divide amounts
- Affects most profit schemes in practice
- Accumulates across hundreds of schemes over thousands of periods
- Could lock millions of tokens protocol-wide over time

**Affected Parties:**
- All beneficiaries collectively lose the locked remainder (distributed loss, not theft by any party)
- Protocol loses economic efficiency as tokens are removed from circulation
- Token utility degrades as effective supply decreases

## Likelihood Explanation

**Probability: HIGH**

This vulnerability triggers automatically during normal profit distribution operations without any attacker action:

1. **Entry point:** Any beneficiary calling `ClaimProfits()` via the public method: [9](#0-8) 

2. **Mathematical certainty:** Occurs whenever shares don't evenly divide amounts, which is common in typical profit distribution scenarios

3. **No special privileges required:** All beneficiaries can claim their profits normally through standard operations

4. **Frequency:** Affects every profit distribution period where division produces a non-zero remainder after truncation

## Recommendation

Implement remainder tracking for individual beneficiary claims similar to how it's handled for sub-schemes. Specifically:

1. Track the cumulative amount claimed by all beneficiaries within a period
2. Allocate any remaining dust to the last claimer or distribute proportionally
3. Alternatively, use higher precision arithmetic (e.g., fixed-point with larger denominators) to minimize truncation losses

**Proposed fix approach:**
- Modify the `DistributedProfitsInfo` to include a `ClaimedAmount` field
- During `ProfitAllPeriods`, track cumulative claims
- For the last beneficiary or when the period expires, transfer any remaining balance

## Proof of Concept

```csharp
// Scenario: 3 beneficiaries with equal shares claim from a period with 100 tokens distributed

// Setup: Scheme with 3 beneficiaries, each with 1 share (totalShares = 3)
// Period distributes 100 tokens

// When each beneficiary calls ClaimProfits():
// Beneficiary 1: amount = (long)(100 * 1 / 3) = (long)(33.333...) = 33
// Beneficiary 2: amount = (long)(100 * 1 / 3) = (long)(33.333...) = 33  
// Beneficiary 3: amount = (long)(100 * 1 / 3) = (long)(33.333...) = 33

// Total claimed: 33 + 33 + 33 = 99 tokens
// Remaining in period virtual address: 100 - 99 = 1 token (permanently locked)

// This 1 token cannot be recovered because:
// - No function can transfer from past period virtual addresses
// - No new beneficiaries can be added to past periods
// - Existing beneficiaries cannot claim again from the same period
```

## Notes

This is a precision loss vulnerability that causes gradual, permanent token locking rather than theft. The locked tokens are not stolen by any party but become genuinely inaccessible due to the cryptographic nature of period virtual addresses and the absence of recovery mechanisms. While individual losses per period may be small (typically single-digit tokens), the cumulative effect across all schemes and periods over time could result in significant protocol-wide token lockup.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L592-603)
```csharp
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-809)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }

        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-912)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-60)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```
