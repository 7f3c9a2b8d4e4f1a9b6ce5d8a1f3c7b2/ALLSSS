# Audit Report

## Title
Consensus Signature Manipulation via Missing Verification Allows Mining Order Control

## Summary
The AEDPoS consensus contract fails to verify that submitted signature values in `UpdateValue` transactions match the expected calculated signature. This allows any miner to provide arbitrary signature values that directly determine their mining position in the next round, completely bypassing the consensus randomness mechanism.

## Finding Description

The vulnerability exists in the consensus data processing flow where honest miners calculate signatures but validators never verify their correctness.

**Honest Signature Calculation:**
When honest miners produce blocks, the system correctly calculates signatures by aggregating previous round signatures with the previous in-value: [1](#0-0) 

The `CalculateSignature` method performs XOR aggregation: [2](#0-1) 

**Vulnerability: Direct Assignment Without Verification:**
When processing `UpdateValue` transactions, the signature and order values are directly assigned from user input without any verification: [3](#0-2) 

**Missing Validation:**
The `UpdateValueValidationProvider` only checks that the signature field is non-null and non-empty, but never recalculates or verifies the expected signature value: [4](#0-3) 

**Direct Impact on Mining Order:**
The signature value directly determines the miner's position in the next round through modulo arithmetic: [5](#0-4) 

**Order Used Without Verification:**
During next round generation, miners are ordered by their `FinalOrderOfNextRound` values (which originated from unverified user input) without any recalculation: [6](#0-5) 

**No Detection Mechanism:**
The evil miner detection only checks for missed time slots, not for incorrect consensus data: [7](#0-6) 

## Impact Explanation

This vulnerability directly breaks consensus integrity with HIGH severity impact:

**Consensus Schedule Manipulation:**
- Attackers can choose position 1 to mine first in each round, gaining MEV opportunities and timing advantages
- Attackers can choose the last position to become extra block producer, controlling round transitions
- The randomness mechanism that ensures fair turn-taking is completely bypassed

**Network-Wide Effects:**
- Unfair distribution of block production opportunities
- Concentration of MEV extraction to malicious miners
- Degradation of consensus security assumptions
- Loss of fairness guarantees that AEDPoS is designed to provide

**Protocol Invariant Violation:**
This directly violates the consensus miner schedule integrity invariant. The protocol assumes signature-based randomness prevents predictable mining order manipulation, but this assumption is not enforced.

## Likelihood Explanation

**HIGH likelihood** - the attack is practical and cost-free:

**Attacker Capabilities:**
Any miner in the validator set can execute this attack. The entry point is the public `UpdateValue` method: [8](#0-7) 

**Attack Complexity: LOW**
- Calculate desired position (e.g., 1 for first position)
- Reverse-calculate signature value: `signature_value = (desired_position - 1) + k * miner_count` for any integer k
- Provide this signature in `UpdateValueInput` with matching `SupposedOrderOfNextRound`
- No cryptographic challenges, no economic costs

**Feasibility:**
- Miners control consensus data generation
- All previous round signatures are publicly available on-chain
- Simple integer arithmetic determines position mapping
- No verification mechanism exists to detect the manipulation

**Detection:**
The attack is completely undetectable because no validator recalculates the expected signature or compares it to the submitted value.

## Recommendation

Add signature verification in the `UpdateValueValidationProvider`:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Get previous round
    if (!TryToGetPreviousRoundInformation(out var previousRound))
        return true; // First round or first term
    
    // Calculate expected signature
    var previousInValue = minerInRound.PreviousInValue;
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // No previous in value available
    
    var expectedSignature = previousRound.CalculateSignature(previousInValue);
    
    // Verify submitted signature matches expected
    if (minerInRound.Signature != expectedSignature)
        return false;
    
    return true;
}
```

Additionally, verify that `SupposedOrderOfNextRound` matches the calculated order from the signature:

```csharp
// In UpdateValueValidationProvider
var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
var sigNum = minerInRound.Signature.ToInt64();
var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;

if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
    return new ValidationResult { Message = "Invalid supposed order of next round." };
```

## Proof of Concept

```csharp
[Fact]
public async Task SignatureManipulation_AllowsMiningOrderControl()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = new[] { "miner1", "miner2", "miner3", "miner4", "miner5" };
    await InitializeConsensus(initialMiners);
    
    // Attacker is miner1 who wants position 1 in next round
    var attackerPubkey = "miner1";
    var desiredPosition = 1;
    var minersCount = 5;
    
    // Calculate crafted signature that yields desired position
    // Since supposedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1
    // For position 1: signature should give modulo 0
    var craftedSignatureValue = 0; // or minersCount, 2*minersCount, etc.
    var craftedSignature = Hash.FromRawBytes(BitConverter.GetBytes(craftedSignatureValue));
    
    // Create UpdateValue input with crafted signature
    var updateValueInput = new UpdateValueInput
    {
        OutValue = Hash.FromString("attacker_out_value"),
        Signature = craftedSignature, // Crafted signature
        SupposedOrderOfNextRound = desiredPosition, // Desired position
        PreviousInValue = Hash.Empty,
        ActualMiningTime = Timestamp.Now(),
        RoundId = currentRound.RoundId
    };
    
    // Submit transaction - should be accepted despite incorrect signature
    var result = await ConsensusStub.UpdateValue.SendAsync(updateValueInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Check next round generation uses manipulated order
    var nextRound = await GenerateNextRound();
    var attackerOrder = nextRound.RealTimeMinersInformation[attackerPubkey].Order;
    
    // Attack succeeds: attacker controls their position
    attackerOrder.ShouldBe(desiredPosition);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```
