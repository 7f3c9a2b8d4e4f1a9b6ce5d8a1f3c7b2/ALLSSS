# Audit Report

## Title
Incomplete Evil Miner Replacement Due to Insufficient Alternative Candidates

## Summary
The AEDPoS consensus contract contains a critical logic flaw in its miner replacement mechanism where the replacement loop only iterates for the count of available alternative candidates rather than the count of evil miners requiring replacement. When fewer alternatives than evil miners exist, unreplaced evil miners persist in the active consensus round, degrading network liveness and block production capacity.

## Finding Description

The vulnerability exists in the interaction between the Election and Consensus contracts during mid-term evil miner replacement.

**Evil Miner Detection**: The system identifies evil miners as those who have missed at least 4320 time slots (3 days at 1 slot/minute). [1](#0-0) 

The detection logic filters miners based on this threshold. [2](#0-1) 

**Replacement Candidate Selection**: The Election contract's `GetMinerReplacementInformation` method attempts to find replacements from election snapshot candidates and initial miners as fallback. [3](#0-2) 

The function returns `MinerReplacementInformation` containing `EvilMinerPubkeys` (all banned miners) and `AlternativeCandidatePubkeys` (available replacements). These lists can have different counts when candidate pools are exhausted. [4](#0-3) 

**The Core Vulnerability**: In the consensus contract's `GenerateNextRoundInformation` method, the replacement loop only iterates `AlternativeCandidatePubkeys.Count` times. [5](#0-4) 

When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, only the first N evil miners (where N equals the alternative count) are removed from `currentRound.RealTimeMinersInformation`. The remaining evil miners persist in the dictionary and are carried forward to the next round. [6](#0-5) 

The unreplaced evil miners receive time slots in subsequent rounds but cannot produce blocks, as they continue incrementing their `MissedTimeSlots` counter. [7](#0-6) 

## Impact Explanation

**Consensus Integrity Degradation**: Unreplaced evil miners remain in the active miner schedule but cannot produce blocks. In a typical 21-miner AEDPoS network, if 10 miners become evil but only 3 get replaced, 7 unreliable miners occupy consensus slots, representing a ~33% reduction in effective block production capacity. This causes increased block times as the network waits for unresponsive miners, potential consensus stalls if too many time slots are wasted, and degraded transaction throughput affecting all users.

**Network Liveness Risk**: With sufficient unreplaced evil miners, the network may fail to meet the 2/3+ threshold needed for block finalization in BFT-style consensus, creating an operational denial-of-service condition where the blockchain cannot process transactions or advance state.

**Affected Parties**: All network participants including validators, end users, dApps, treasury operations, profit distributions, and cross-chain indexing mechanisms that depend on stable consensus.

**Severity Assessment**: HIGH - This directly compromises the core consensus mechanism's integrity. While no funds are immediately stolen, the network's ability to function is severely impaired, potentially leading to complete service disruption.

## Likelihood Explanation

**Trigger Conditions**: The vulnerability activates under realistic network stress scenarios when multiple miners simultaneously fail or go offline for 3+ days (infrastructure outages, coordinated attacks, or natural disasters), the election candidate pool becomes depleted because most eligible candidates are already serving as miners or have been previously banned, and the initial miner fallback list is exhausted.

**Feasibility**: MEDIUM-HIGH probability because the condition occurs automatically without requiring attacker privileges, mature blockchain networks naturally develop stable miner sets reducing the available candidate pool over time, infrastructure failures affecting multiple data centers can cause simultaneous miner outages, and an adversary could accelerate the condition through sustained DDoS attacks against active miners.

**Detection Difficulty**: The degradation is observable through monitoring but may not trigger immediate alarms since the network continues operating at reduced capacity rather than failing completely. This subtle degradation can persist unnoticed until it reaches critical thresholds.

## Recommendation

Modify the replacement loop in `GenerateNextRoundInformation` to iterate over all evil miners, replacing only those with available alternatives:

```csharp
if (minerReplacementInformation.EvilMinerPubkeys.Count > 0)
{
    var replacementCount = Math.Min(
        minerReplacementInformation.EvilMinerPubkeys.Count,
        minerReplacementInformation.AlternativeCandidatePubkeys.Count);
    
    // Replace evil miners that have alternatives
    for (var i = 0; i < replacementCount; i++)
    {
        var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
        var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
        
        // ... existing replacement logic ...
        
        currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
        currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
    }
    
    // Remove remaining evil miners without replacements
    for (var i = replacementCount; i < minerReplacementInformation.EvilMinerPubkeys.Count; i++)
    {
        var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
        UpdateCandidateInformation(evilMinerPubkey,
            currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
            currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);
        currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
    }
    
    isMinerListChanged = true;
}
```

This ensures all detected evil miners are removed from the consensus set, even when insufficient alternatives exist, preventing the network from carrying non-functional miners forward.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize a network with initial miners
2. Simulate multiple miners failing by incrementing their `MissedTimeSlots` beyond 4320
3. Deplete the candidate pool by ensuring most eligible candidates are already active miners or banned
4. Trigger round generation via `GenerateNextRoundInformation`
5. Verify that evil miners without corresponding alternatives remain in `nextRound.RealTimeMinersInformation`
6. Confirm these unreplaced miners continue receiving time slots in subsequent rounds despite being non-functional

The existing test framework in `EvilNodeRelatedTests.cs` provides the foundation for this test, though the current `MarkEvilNodeTest` is marked as "Need fix", potentially indicating awareness of related issues. [8](#0-7)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** test/AElf.Contracts.Economic.AEDPoSExtension.Tests/EvilNodeRelatedTests.cs (L22-66)
```csharp
    [Fact(Skip = "Need fix.")]
    internal async Task MarkEvilNodeTest()
    {
        UpdateParliamentStubs(MissionedECKeyPairs.InitialKeyPairs);
        var newCandidates = MissionedECKeyPairs.ValidationDataCenterKeyPairs.Take(18).ToList();
        await NodesAnnounceElection(newCandidates);
        await BlockMiningService.MineBlockToNextTermAsync();

        var miners = newCandidates.Take(17).ToList();
        //UpdateParliamentStubs(miners);

        await BlockMiningService.MineBlockToNextRoundAsync();

        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ParliamentSmartContractAddressNameProvider.Name],
            ContractMethodName = "CreateEmergencyResponseOrganization",
            Params = new Empty().ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        var eroAddress =
            await ParliamentStubs.First().GetEmergencyResponseOrganizationAddress.CallAsync(new Empty());
        var evilNodePubkey = MissionedECKeyPairs.ValidationDataCenterKeyPairs.First().PublicKey.ToHex();
        await EmergencyResponseOrganizationReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ElectionSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ElectionStub.RemoveEvilNode),
            Params = new StringValue
            {
                Value = evilNodePubkey
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = eroAddress
        });
        await BlockMiningService.MineBlockToNextRoundAsync();
        miners.Remove(MissionedECKeyPairs.ValidationDataCenterKeyPairs.First());
        miners.Add(MissionedECKeyPairs.ValidationDataCenterKeyPairs.Skip(17).Take(1).First());
        UpdateParliamentStubs(miners);

        var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
        currentRound.RealTimeMinersInformation.Keys.ShouldNotContain(evilNodePubkey);
    }
```
