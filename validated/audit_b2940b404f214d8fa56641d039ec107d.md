# Audit Report

## Title
Consensus Behavior Spoofing Enables Bypass of UpdateValue Validation Requirements

## Summary
A malicious miner can falsely claim `TinyBlock` behavior in their block header when consensus rules require `UpdateValue` behavior. The validation logic blindly trusts the claimed behavior without verifying it matches the expected behavior calculated from consensus state, allowing miners to bypass OutValue and Signature validation requirements while still receiving block production rewards.

## Finding Description

The AEDPoS consensus mechanism calculates the expected behavior for each miner based on their state in the current round. When a miner has `OutValue == null` and their time slot has not passed, the expected behavior is `UpdateValue`. [1](#0-0) [2](#0-1) 

However, the validation code in `ValidateBeforeExecution` never verifies that the behavior claimed in `extraData.Behaviour` matches this expected behavior. Instead, it blindly trusts the claimed behavior to determine which recovery method to use and which validation providers to apply. [3](#0-2) [4](#0-3) 

The two recovery methods handle data differently: `RecoverFromUpdateValue` restores OutValue, Signature, PreviousInValue, ImpliedIrreversibleBlockHeight, ActualMiningTimes, and order information, [5](#0-4)  while `RecoverFromTinyBlock` only restores ImpliedIrreversibleBlockHeight and ActualMiningTimes. [6](#0-5) 

Critically, the `UpdateValueValidationProvider` that validates OutValue and Signature presence is only added when `extraData.Behaviour == UpdateValue`. [7](#0-6) [8](#0-7) 

When the malicious miner claims `TinyBlock` behavior, transaction generation creates an `UpdateTinyBlockInformation` transaction instead of `UpdateValue`, [9](#0-8)  which calls `ProcessTinyBlock` that increments `ProducedBlocks` but does NOT set OutValue or Signature. [10](#0-9) 

The miner still receives rewards because reward calculation is based on `GetMinedBlocks()` which simply sums all `ProducedBlocks` values without checking OutValue presence. [11](#0-10) [12](#0-11) 

## Impact Explanation

**Consensus Integrity Compromise:**
This vulnerability breaks critical consensus security properties. The random number generation chain relies on miners providing OutValue commitments, which hash to form an unpredictable randomness source. When miners can bypass OutValue requirements, the randomness chain is broken, potentially enabling manipulation of outcomes dependent on random numbers.

Additionally, Signature-based accountability allows the network to cryptographically prove which miner produced each consensus commitment. Bypassing Signature requirements eliminates this verifiable audit trail, reducing miner accountability.

**Economic Unfairness:**
Miners who exploit this vulnerability receive full block production rewards while avoiding cryptographic commitments that honest miners must provide. This creates an unfair advantage where malicious miners reduce their computational/cryptographic overhead while honest miners bear full costs.

**Protocol Invariant Violation:**
The fundamental assumption is that all blocks with `ProducedBlocks > 0` have corresponding OutValue and Signature commitments. This vulnerability breaks that invariant, creating inconsistent state where miners have produced blocks but lack required consensus data.

The severity is **Medium** because while it doesn't directly steal funds, it undermines core consensus integrity, enables selective protocol violation, and degrades the security guarantees that applications depend on.

## Likelihood Explanation

**Attacker Prerequisites:**
The attacker must be an elected miner in the current round, which is achievable through normal election mechanisms. No special privileges beyond standard miner role are required.

**Attack Execution:**
The attack is trivially simple - when generating a block that should use `UpdateValue` behavior, the miner simply sets `Behaviour = TinyBlock` in the consensus extra data. The data generation uses the claimed behavior, [13](#0-12)  so `GetTinyBlockRound` creates simplified data without OutValue/Signature. [14](#0-13) 

**Detection Constraints:**
While other nodes can observe that a miner's OutValue remains null despite producing blocks, there is no automatic rejection or penalty mechanism. The `CountMissedTimeSlots` logic checks for null OutValue, [15](#0-14)  but this runs at term transitions, not during block validation, and the miner has already received rewards for those blocks. Detection requires manual monitoring and governance intervention.

The likelihood is **Medium** - technically simple for any miner to execute, but observable through state monitoring. The lack of automated validation makes exploitation practical, though reputational risk and eventual detection may deter some rational actors.

## Recommendation

Add a validation check in `ValidateBeforeExecution` to verify that the claimed behavior matches the expected behavior calculated from consensus state:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // NEW: Calculate expected behavior and validate it matches claimed behavior
    var pubkey = extraData.SenderPubkey.ToHex();
    var expectedBehaviour = GetExpectedBehaviour(baseRound, pubkey);
    if (expectedBehaviour != extraData.Behaviour)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"Claimed behaviour {extraData.Behaviour} does not match expected behaviour {expectedBehaviour}." 
        };
    }

    // Continue with existing validation logic...
}

private AElfConsensusBehaviour GetExpectedBehaviour(Round currentRound, string pubkey)
{
    var behaviourProvider = IsMainChain
        ? new MainChainConsensusBehaviourProvider(currentRound, pubkey, 
            GetMaximumBlocksCount(), Context.CurrentBlockTime, 
            GetBlockchainStartTimestamp(), State.PeriodSeconds.Value)
        : new SideChainConsensusBehaviourProvider(currentRound, pubkey, 
            GetMaximumBlocksCount(), Context.CurrentBlockTime);
    
    return behaviourProvider.GetConsensusBehaviour();
}
```

## Proof of Concept

This vulnerability can be demonstrated by creating a test where a miner with null OutValue and unexpired time slot claims TinyBlock behavior instead of UpdateValue:

1. Set up a round with a miner who has `OutValue == null`
2. Ensure current time is within the miner's time slot
3. Create consensus extra data with `Behaviour = TinyBlock` (instead of expected UpdateValue)
4. Call `ValidateConsensusBeforeExecution` - it should reject but doesn't
5. Generate transactions - creates `UpdateTinyBlockInformation` instead of `UpdateValue`
6. Process the block - `ProducedBlocks` increments without setting OutValue/Signature
7. Verify miner receives rewards despite missing OutValue/Signature commitments

The test would demonstrate that validation passes when it should fail, and the miner receives full rewards without providing required cryptographic commitments.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-51)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L16-30)
```csharp
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L43-44)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L148-163)
```csharp
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L251-251)
```csharp
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L303-306)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L91-93)
```csharp
        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L119-120)
```csharp
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-38)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```
