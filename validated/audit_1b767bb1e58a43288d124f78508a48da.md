# Audit Report

## Title
Continuous Block Limit Bypass via Public Key Replacement

## Summary
A miner can bypass the continuous block production limit by strategically replacing their public key. The `RecordCandidateReplacement` method updates the round's miner information but fails to update `State.LatestPubkeyToTinyBlocksCount`, causing a pubkey mismatch that bypasses validation checks and resets the block counter instead of decrementing it. This allows a miner to produce significantly more continuous blocks than the intended limit of 8 blocks.

## Finding Description

The vulnerability exists in the interaction between key replacement and continuous block tracking in the AEDPoS consensus contract.

**Core Mechanism**: The consensus system tracks continuous block production to prevent any single miner from dominating block production. The counter starts at 7 and decrements with each block produced by the same miner. When it reaches -1, validation fails and prevents further continuous block production. [1](#0-0) 

**The Vulnerability Chain:**

1. **Missing State Update**: When a candidate's key is replaced via `ReplaceCandidatePubkey` in the Election contract, it triggers `RecordCandidateReplacement` in the consensus contract. This method updates the round's `RealTimeMinersInformation` with the new pubkey but critically fails to update `State.LatestPubkeyToTinyBlocksCount`: [2](#0-1) 

2. **Validation Bypass**: The `ContinuousBlocksValidationProvider` checks if a miner has exceeded the limit by comparing the stored pubkey with the current sender's pubkey. After key replacement, these don't match (old key vs new key), so the validation check is skipped: [3](#0-2) 

3. **Counter Reset**: In `ResetLatestProviderToTinyBlocksCount`, when the stored pubkey doesn't match the current miner's pubkey, the system resets the counter to `minersCountInTheory.Sub(1)` (typically 7) instead of decrementing: [1](#0-0) 

4. **Entry Point**: The attack starts from `ReplaceCandidatePubkey` which requires candidate admin permission - a role miners typically control for their own candidates: [4](#0-3) [5](#0-4) 

5. **Maximum Blocks Count**: Under normal mining conditions, `GetMaximumBlocksCount` returns 8: [6](#0-5) 

**Attack Flow**:
- Miner produces blocks with key_1: counter goes 7→6→5→4→3→2→1→0
- Before the next block (which would make counter = -1 and fail validation), miner calls `ReplaceCandidatePubkey(key_1, key_2)`
- Miner produces next block with key_2
- Counter resets to 7 instead of going to -1
- Miner can produce ~7 more continuous blocks
- Process repeats with key_3, key_4, etc.

## Impact Explanation

This vulnerability breaks a fundamental consensus rule designed to ensure fair block production distribution and prevent centralization.

**Consensus Integrity Violation**: The continuous block limit exists to prevent any single miner from producing too many consecutive blocks, which could lead to centralization and increased fork risk. The limit was specifically implemented to address fork risks (as noted in the code comment referencing GitHub PR #1952): [7](#0-6) 

**Quantified Harm**:
- **Unfair Economic Advantage**: Each key replacement grants ~7 additional continuous blocks. With 10 prepared keypairs, an attacker could produce ~70 continuous blocks instead of the intended 8, capturing ~9x more mining rewards than legitimate miners.
- **Centralization Risk**: Single miner can dominate block production during their time slot, defeating the distributed consensus model.
- **Network Fork Risk**: The limit was specifically designed to reduce fork risk; bypassing it increases network instability.
- **Affected Parties**: All honest miners suffer reduced mining opportunities and rewards proportional to the attacker's excess block production.

## Likelihood Explanation

**Entry Point Accessibility**: The `ReplaceCandidatePubkey` method requires candidate admin permission. Miners typically control their own candidate admin addresses (set during `AnnounceElection`), making this a realistic attacker capability: [8](#0-7) [9](#0-8) 

**Attacker Requirements**:
1. Control of candidate admin address (standard for miners)
2. Multiple fresh keypairs (trivial to generate)
3. Timing of key replacement transactions (feasible during mining window)

**Execution Feasibility**:
- No cooldown or rate limiting on `ReplaceCandidatePubkey` calls
- Old keys are banned after replacement to prevent reuse, but there's no limit on fresh keys
- Key replacements are legitimate operations that may not trigger immediate scrutiny
- The attack provides clear economic incentive (additional block rewards)

**Probability Assessment**: Medium likelihood - requires preparation of multiple keypairs and careful timing, but is technically straightforward with significant financial incentive and no technical barriers preventing execution.

## Recommendation

The fix requires updating `State.LatestPubkeyToTinyBlocksCount` when a candidate's public key is replaced. Modify the `RecordCandidateReplacement` method to update the tracking state:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // If this candidate is current miner, need to modify current round information.
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // FIX: Update LatestPubkeyToTinyBlocksCount to maintain counter continuity
    var latestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value;
    if (latestPubkeyToTinyBlocksCount != null && latestPubkeyToTinyBlocksCount.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = latestPubkeyToTinyBlocksCount.BlocksCount
        };
    }

    // Notify Treasury Contract to update replacement information. (Update from old record.)
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimitBypass_ViaKeyReplacement_Test()
{
    // Setup: Initialize consensus with a miner
    var minerKeyPair1 = CryptoHelper.GenerateKeyPair();
    var minerKeyPair2 = CryptoHelper.GenerateKeyPair();
    var candidateAdmin = Accounts[0].Address;
    
    // Miner announces election with admin
    await ElectionContractStub.AnnounceElection.SendAsync(candidateAdmin);
    
    // Miner produces blocks until counter reaches 0 (8 blocks total)
    for (int i = 0; i < 8; i++)
    {
        await ConsensusContractStub.TinyBlock.SendAsync(new TinyBlockInput { /* ... */ });
    }
    
    // Verify counter is at 0 (next block would fail)
    var counterBefore = await ConsensusContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    countertBefore.BlocksCount.ShouldBe(0);
    
    // ATTACK: Replace public key
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair1.PublicKey.ToHex(),
        NewPubkey = minerKeyPair2.PublicKey.ToHex()
    });
    
    // Miner produces block with NEW key
    await ConsensusContractStub.TinyBlock.SendAsync(new TinyBlockInput { /* ... */ });
    
    // VULNERABILITY: Counter should be -1 but gets reset to 7
    var counterAfter = await ConsensusContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    counterAfter.BlocksCount.ShouldBe(7); // Should have been -1 and failed validation
    counterAfter.Pubkey.ShouldBe(minerKeyPair1.PublicKey.ToHex()); // Still has OLD key (not updated)
    
    // Attacker can now produce 7+ more continuous blocks
    await ConsensusContractStub.TinyBlock.SendAsync(new TinyBlockInput { /* ... */ });
    // This should have failed but succeeds due to bypass
}
```

## Notes

The vulnerability is confirmed by examining the code paths:

1. **Missing Update**: `RecordCandidateReplacement` at lines 131-157 in AEDPoSContract.cs clearly does not update `State.LatestPubkeyToTinyBlocksCount`

2. **Counter Logic**: `ResetLatestProviderToTinyBlocksCount` at line 352 checks pubkey equality and resets counter to 7 when they don't match (line 359-363)

3. **Validation Skip**: `ContinuousBlocksValidationProvider` at line 18 only validates when pubkeys match, skipping validation after key replacement

4. **No Rate Limiting**: Search of the codebase confirmed no cooldown or rate limiting on `ReplaceCandidatePubkey` calls

This is a consensus-level vulnerability that breaks the fundamental fairness guarantee of distributed block production in AEDPoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-256)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-16)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
    public const long TimeToReduceMiningRewardByHalf = 126144000; // 60 * 60 * 24 * 365 * 4
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
    public const string SecretSharingEnabledConfigurationKey = "SecretSharingEnabled";
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-21)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
```
