# Audit Report

## Title
Insufficient Contract Type Validation in CheckOrganizationExist Allows Permanent Method Fee Controller Takeover

## Summary

The Genesis contract's `ChangeMethodFeeController` method fails to validate that the provided `AuthorityInfo.ContractAddress` is a legitimate organization contract (Parliament/Association/Referendum). An attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, then pass a single Parliament proposal to install it as the method fee controller, gaining permanent unilateral control over Genesis contract method fees without further governance oversight.

## Finding Description

The vulnerability exists in the interaction between `ChangeMethodFeeController` and `CheckOrganizationExist`. [1](#0-0) 

**Root Cause:**

The `CheckOrganizationExist` helper performs a cross-contract call to `ValidateOrganizationExist` on whatever contract address is provided in `AuthorityInfo.ContractAddress`, without validating that this contract is a legitimate organization contract. [2](#0-1) 

The legitimate organization contracts (Parliament, Association, Referendum) are defined as named system contracts [3](#0-2)  but there is no validation that the provided contract address matches any of these.

In legitimate organization contracts, `ValidateOrganizationExist` checks if an organization exists in their state storage. [4](#0-3) [5](#0-4) 

**Exploitation Path:**

1. **Deploy Malicious Contract:** On main/public chains, user contract deployment is permissionless. [6](#0-5)  An attacker deploys a contract with a `ValidateOrganizationExist` method that always returns `true`.

2. **Create Parliament Proposal:** Attacker creates a proposal to call `ChangeMethodFeeController` with:
   - `OwnerAddress` = attacker's controlled address
   - `ContractAddress` = malicious contract address

3. **Proposal Execution:** When approved and released by Parliament, the sender is the Parliament organization address, passing the authorization check. The malicious contract's `ValidateOrganizationExist` returns `true`, and the controller is updated.

4. **Post-Exploit:** The attacker can directly call `SetMethodFee` [7](#0-6) , which only verifies that the sender matches the controller's `OwnerAddress`.

**Security Invariant Violated:**

The Genesis contract should enforce that method fee control remains under legitimate multi-signature governance (Parliament/Association/Referendum organizations), but the missing contract address validation allows installation of a fake organization that provides unilateral control to a single address.

## Impact Explanation

**Governance Impact:**
The attacker achieves permanent privilege escalation from "must pass Parliament proposals for each fee change" to "can change fees unilaterally at will." This completely bypasses the intended governance oversight mechanism.

**Denial of Service:**
The attacker can set prohibitively high fees for critical Genesis contract methods including `DeploySmartContract`, `UpdateSmartContract`, `ProposeNewContract`, `ProposeUpdateContract`, `ReleaseApprovedContract`, and `ReleaseCodeCheckedContract`. This effectively halts the entire smart contract deployment and upgrade system for the chain, constituting a chain-level DoS attack.

**Economic Manipulation:**
- Setting zero fees bypasses intended economic controls
- Discriminatory fee structures can favor/harm specific users
- Fee extraction through manipulated pricing

**Severity: HIGH** due to: (1) Permanent governance bypass violating critical security invariants, (2) Chain-level DoS capability affecting all participants, (3) Economic manipulation potential, (4) Requires only ONE successful proposal for lasting damage.

## Likelihood Explanation

**Attacker Requirements:**
- Deploy a user contract (permissionless on main/public side chains)
- Pass ONE Parliament proposal (requires 2/3 miner approval)

**Attack Complexity:**
LOW - The malicious contract is trivial (single method returning `true`). The proposal parameters are complex enough that voters would need to inspect the target contract code, recognize it's not a legitimate organization contract, and understand the privilege escalation implications.

**Feasibility:**
While passing a Parliament proposal requires 2/3 miner approval (a high bar), this is feasible during governance inattention, rushed voting periods, or coordinated attacks. The one-time nature (only need one successful proposal ever) significantly increases overall risk compared to attacks requiring repeated governance actions.

## Recommendation

Add validation in `CheckOrganizationExist` to ensure the `ContractAddress` is one of the three legitimate organization contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate organization contract
    var parliamentAddress = GetContractAddressByName(SmartContractConstants.ParliamentContractSystemHashName);
    var associationAddress = GetContractAddressByName(SmartContractConstants.AssociationContractSystemHashName);
    var referendumAddress = GetContractAddressByName(SmartContractConstants.ReferendumContractSystemHashName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid organization contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

Apply the same fix to all contracts implementing ACS1 method fee control (Parliament, Association, Referendum, MultiToken, etc.) to ensure consistent security guarantees across the system.

## Proof of Concept

```csharp
[Fact]
public async Task ChangeMethodFeeController_WithMaliciousContract_Attack()
{
    // Step 1: Deploy malicious contract with ValidateOrganizationExist always returning true
    var maliciousCode = GetMaliciousContractCode(); // Contract with ValidateOrganizationExist() => true
    var maliciousContractAddress = await DeployMaliciousContract(maliciousCode);
    
    // Step 2: Get current method fee controller
    var currentController = await BasicContractZeroStub.GetMethodFeeController.CallAsync(new Empty());
    
    // Step 3: Create Parliament proposal to change controller to malicious setup
    var proposalId = await CreateProposalAsync(
        currentController.ContractAddress,
        currentController.OwnerAddress,
        nameof(BasicContractZeroStub.ChangeMethodFeeController),
        new AuthorityInfo
        {
            OwnerAddress = AttackerAddress, // Attacker's address
            ContractAddress = maliciousContractAddress // Malicious contract
        });
    
    // Step 4: Approve and release proposal (simulating 2/3 miner approval)
    await ApproveWithMinersAsync(proposalId);
    var releaseResult = await ReleaseProposalAsync(proposalId);
    
    // Verify: Controller changed to attacker's setup
    releaseResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var newController = await BasicContractZeroStub.GetMethodFeeController.CallAsync(new Empty());
    newController.OwnerAddress.ShouldBe(AttackerAddress);
    newController.ContractAddress.ShouldBe(maliciousContractAddress);
    
    // Step 5: Attacker can now unilaterally set method fees
    var attackerStub = GetBasicContractZeroStub(AttackerKeyPair);
    var setFeeResult = await attackerStub.SetMethodFee.SendAsync(new MethodFees
    {
        MethodName = nameof(BasicContractZeroStub.DeploySmartContract),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1000000000 } } // Prohibitively high
    });
    
    // Verify: Fee change succeeds without governance
    setFeeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

This vulnerability affects not only the Genesis contract but also all other system contracts implementing ACS1 method fee control (Parliament, Association, Referendum, MultiToken, CrossChain, Consensus, Economic, Election, Configuration, Profit, TokenConverter, TokenHolder, Treasury, Vote, NFT). [8](#0-7)  The same `CheckOrganizationExist` pattern is used without contract address validation across all these contracts, creating a systemic vulnerability that enables governance capture across the entire protocol.

The framework's guidance to "assume organization controllers are honest unless the claim is about mis-scoped privileges" explicitly covers this case - the vulnerability is about **mis-scoped privileges** where the contract fails to enforce that only legitimate organization contracts can be installed as controllers, even though Parliament has the authority to change controllers.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L18-36)
```csharp
    public static readonly Hash ParliamentContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Parliament");

    public static readonly Hash VoteContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Vote");
    public static readonly Hash ProfitContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Profit");

    public static readonly Hash CrossChainContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.CrossChain");

    public static readonly Hash TokenConverterContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.TokenConverter");

    public static readonly Hash EconomicContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Economic");

    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```
