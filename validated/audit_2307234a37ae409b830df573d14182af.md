# Audit Report

## Title
Unvalidated Miner Order Assignment Enables Consensus DoS via Duplicate and Invalid Orders

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract accepts user-provided mining order values without validating they are within the valid range [1, minersCount]. This allows malicious miners to assign invalid orders (e.g., 0 or values exceeding minersCount), which propagate to subsequent rounds and cause critical consensus functions to throw exceptions, permanently halting block production.

## Finding Description

The vulnerability exists in the order assignment flow where user-provided values are directly assigned to state without bounds validation.

**Missing Validation in ProcessUpdateValue:** The code directly assigns `SupposedOrderOfNextRound` and values from `TuneOrderInformation` to `FinalOrderOfNextRound` without any validation that they are within the valid range [1, minersCount]. [1](#0-0) [2](#0-1) 

**Insufficient Validation Provider:** The validation only checks `OutValue`, `Signature`, and `PreviousInValue` fields - order values are never validated. [3](#0-2) 

**Input Definition Without Constraints:** The proto definition shows these are unconstrained int32 fields that accept any value. [4](#0-3) 

**Propagation to Next Round:** When generating the next round, miners who successfully mined use their `FinalOrderOfNextRound` values (which may be invalid) directly as their `Order` in the next round. [5](#0-4) 

**Critical Failure Point 1 - GetMiningInterval:** This function expects at least two miners with `Order == 1` and `Order == 2`. If these orders don't exist due to invalid assignments, accessing `firstTwoMiners[1]` throws an `IndexOutOfRangeException`. [6](#0-5) 

**Critical Failure Point 2 - BreakContinuousMining:** These lines use `First()` to find miners with specific orders. If these orders don't exist, `First()` throws an `InvalidOperationException`. [7](#0-6) [8](#0-7) [9](#0-8) 

**GetMiningInterval Called in Critical Paths:** GetMiningInterval is called during next round generation and time slot validation. [10](#0-9) [11](#0-10) 

**Attack Flow:**
1. Malicious miner crafts block with consensus extra data containing invalid `SupposedOrderOfNextRound` or `TuneOrderInformation` values
2. Calls public `UpdateValue` method [12](#0-11) 
3. Passes `PreCheck` authorization (only requires being in miner list) [13](#0-12) 
4. Invalid orders are assigned to round state during block header validation via RecoverFromUpdateValue [14](#0-13) 
5. Next round is generated with miners having invalid orders
6. When `GetMiningInterval()` or `BreakContinuousMining()` is called, exceptions are thrown
7. Consensus halts permanently

## Impact Explanation

**Critical Severity - Consensus DoS:**

The impact is a complete and permanent halt of consensus progression:

1. **Block Production Halts:** `GetMiningInterval()` is called during block validation and time slot checking. If it throws an exception, no blocks can be validated or produced.

2. **Round Generation Fails:** `GenerateNextRoundInformation()` calls both `GetMiningInterval()` and `BreakContinuousMining()`. If either throws an exception, new rounds cannot be generated. [15](#0-14) 

3. **Protocol-Wide Freeze:** All nodes are affected simultaneously since they all execute the same corrupted round state. The chain becomes completely unresponsive.

4. **Cascading Effects:**
   - Mining rewards cannot be distributed
   - Cross-chain operations depending on round progression are blocked
   - Governance actions requiring new blocks cannot be executed
   - All transaction processing stops

5. **Recovery Difficulty:** Recovery requires either a hard fork or emergency governance intervention with manual state correction, both requiring significant coordination.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attacker Requirements:**
   - Only requires being an elected miner (achievable through normal staking/election process)
   - No special privileges or compromised keys needed
   - Any of the 2N+1 active miners can execute the attack

2. **Trivial Attack Complexity:**
   - Single block production with crafted consensus extra data
   - No timing dependencies or race conditions
   - No need for multiple coordinated transactions
   - Immediate effect in the next round

3. **No Technical Barriers:**
   - UpdateValue is a public method accessible during block production
   - Only validation is miner list membership (which attacker satisfies)
   - No economic cost beyond normal transaction fees

4. **High Success Rate:**
   - Attack is deterministic - always succeeds if executed
   - No randomness or probabilistic elements
   - Effect is immediate and observable

5. **Detection vs Prevention Gap:**
   - Attack is visible on-chain but by the time it's detected, damage is done
   - No preventive mechanisms exist in the current code
   - Consensus is already halted before any response can be coordinated

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all order values are within the valid range [1, minersCount]:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound is in valid range
    Assert(updateValueInput.SupposedOrderOfNextRound >= 1 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid supposed order of next round.");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    minerInRound.Signature = updateValueInput.Signature;
    minerInRound.OutValue = updateValueInput.OutValue;
    minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
    
    // Validate TuneOrderInformation values are in valid range
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
               $"Invalid tune order {tuneOrder.Value} for miner {tuneOrder.Key}.");
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }
    
    // ... rest of the function
}
```

Additionally, add validation in `UpdateValueValidationProvider` to check order values during consensus validation.

## Proof of Concept

A malicious miner can execute this attack by producing a block with consensus extra data containing an invalid order value (e.g., 0 or greater than minersCount). When the next round is generated using `GenerateNextRoundInformation()`, it will call `GetMiningInterval()` which will attempt to access miners with Order 1 and 2. If these orders don't exist due to the invalid assignment, an `IndexOutOfRangeException` will be thrown, halting consensus.

The vulnerability can be demonstrated by:
1. An elected miner crafting consensus extra data with `SupposedOrderOfNextRound = 0`
2. Producing a block with this data
3. The block executes successfully, updating the round state with the invalid order
4. When the next round attempts to generate via `GenerateNextRoundInformation()`, it calls `GetMiningInterval()` at line 20
5. `GetMiningInterval()` filters for miners with Order 1 or 2, finds none or only one
6. Accessing `firstTwoMiners[1]` throws `IndexOutOfRangeException`
7. Round generation fails, halting all consensus progression

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** protobuf/aedpos_contract.proto (L206-208)
```text
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L67-67)
```csharp
        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L84-84)
```csharp
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L101-101)
```csharp
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L85-85)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```
