# Audit Report

## Title
Solitary Miner Detection Bypass via Unvalidated SupposedOrderOfNextRound Manipulation

## Summary
The AEDPoS consensus contract's `SolitaryMinerDetection()` safety mechanism can be bypassed by malicious miners who manipulate the `SupposedOrderOfNextRound` field to zero. This field is calculated correctly by honest node software but is never validated during block processing, allowing attackers to exclude themselves from the mined miners list and circumvent the detection logic designed to prevent consensus monopolization.

## Finding Description

The vulnerability exists in the consensus validation and processing flow for the `UpdateValue` behavior. The attack exploits a missing validation step that should verify the `SupposedOrderOfNextRound` field matches its deterministic calculation.

**Attack Flow:**

1. During block production, `ApplyNormalConsensusData()` correctly calculates `SupposedOrderOfNextRound = GetAbsModulus(signature.ToInt64(), minersCount) + 1` [1](#0-0) 

2. However, the malicious miner controls their node software and can modify this value to 0 in both the consensus header's Round object and the `UpdateValueInput` transaction before broadcasting. The honest extraction happens in `ExtractInformationToUpdateConsensus` [2](#0-1) , but node software can modify this afterward.

3. During validation, `UpdateValueValidationProvider` only checks `OutValue`, `Signature`, and `PreviousInValue` fields [3](#0-2) , with **no validation** of `SupposedOrderOfNextRound`. The validation providers for UpdateValue behavior are explicitly listed [4](#0-3) .

4. The value is blindly copied during `RecoverFromUpdateValue()` [5](#0-4)  and stored directly in contract state during `ProcessUpdateValue()` [6](#0-5) .

5. The `SolitaryMinerDetection()` function relies on `GetMinedMiners()` which filters miners where `SupposedOrderOfNextRound != 0` [7](#0-6) .

6. When the detection logic executes [8](#0-7) , it checks previous rounds using `GetMinedMiners()`. Since the malicious miner set their value to 0, they're excluded from the list, causing the check `minedMiners.Count == 1` to fail (count is 0), and `isAlone` becomes FALSE, bypassing the detection.

## Impact Explanation

**HIGH severity** - This vulnerability breaks a critical consensus safety mechanism:

- **Consensus Monopolization:** A malicious miner can continue producing blocks indefinitely even when they should stop, centralizing block production to a single entity.

- **Safety Mechanism Failure:** The `SolitaryMinerDetection()` is specifically designed to prevent single-miner control during temporary network partitions or miner outages. Bypassing it eliminates this safety guarantee.

- **Network Recovery Prevention:** When legitimate miners return online, the malicious miner continues blocking them from participating, preventing natural network recovery.

- **Decentralization Compromise:** The fundamental AEDPoS assumption of distributed block production is violated, degrading network security to a single point of failure.

## Likelihood Explanation

**MEDIUM-HIGH likelihood:**

- **Attacker Capabilities:** Requires being an existing miner in the miner list, which is achievable through the election process. No special privileges beyond normal miner status are needed.

- **Attack Complexity:** LOW - The attacker only needs to modify their node software to set `SupposedOrderOfNextRound = 0` after the legitimate calculation but before broadcasting. No complex timing, cryptographic attacks, or economic costs are involved.

- **Preconditions:** The attack is most effective when other miners are temporarily offline, which is precisely the scenario the solitary miner detection is designed to protect against, making this a realistic attack surface.

- **Detection:** The manipulation is undetectable through normal consensus validation since no validator checks the field's correctness.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that the provided `SupposedOrderOfNextRound` matches the deterministic calculation:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var publicKey = validationContext.SenderPubkey;
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[publicKey];
    var signature = minerInRound.Signature;
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}
```

Then add this check to the `ValidateHeaderInformation` method in `UpdateValueValidationProvider` before returning success.

## Proof of Concept

A proof of concept would require:
1. Setting up a test network with multiple miners
2. Modifying one miner's node software to set `SupposedOrderOfNextRound = 0` in UpdateValueInput
3. Broadcasting blocks with this manipulated value
4. Observing that validation passes and the value is stored
5. Taking other miners offline
6. Verifying that SolitaryMinerDetection returns false instead of true
7. Confirming the malicious miner continues producing blocks

The vulnerability is confirmed through code analysis showing the missing validation path, where `UpdateValueValidationProvider` [9](#0-8)  contains no check for `SupposedOrderOfNextRound` correctness.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L43-43)
```csharp
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```
