# Audit Report

## Title
Consensus Denial-of-Service via Unvalidated TuneOrderInformation Leading to GetMiningInterval Crash

## Summary
A malicious miner can inject invalid `FinalOrderOfNextRound` values through the unvalidated `TuneOrderInformation` field in `UpdateValueInput`, creating a corrupted round where no miners have Order 1 or 2. This causes `GetMiningInterval()` to crash with an `ArgumentOutOfRangeException` when any miner attempts to retrieve consensus commands, permanently halting block production.

## Finding Description

The AEDPoS consensus system contains a critical vulnerability where `TuneOrderInformation` values are applied to `FinalOrderOfNextRound` without validating that miner Order values form a complete sequence [1, 2, ..., N]. This breaks the core assumption in `GetMiningInterval()` that Orders 1 and 2 always exist.

**Root Cause 1: Unvalidated TuneOrderInformation Application**

In `ProcessUpdateValue`, the `TuneOrderInformation` dictionary is directly applied without any validation: [1](#0-0) 

This allows arbitrary Order values like {Miner1→3, Miner2→4, Miner3→5, Miner4→6} that exclude Orders 1 and 2.

**Root Cause 2: GetMiningInterval Assumes Order 1 and 2 Exist**

The `GetMiningInterval()` method filters miners by Order 1 or 2 and unconditionally accesses the second element: [2](#0-1) 

When no miners have Order 1 or 2, `firstTwoMiners` contains 0 elements, and accessing `firstTwoMiners[1]` throws `ArgumentOutOfRangeException`.

**Root Cause 3: GenerateNextRoundInformation Propagates Corrupted Values**

When transitioning to the next round, `FinalOrderOfNextRound` becomes the `Order` field: [3](#0-2) 

Invalid `FinalOrderOfNextRound` values propagate directly to become invalid Order values in the new round.

**Root Cause 4: Validation Gaps**

The existing validators fail to catch this:

`NextRoundMiningOrderValidationProvider` only validates count equality, not actual order values: [4](#0-3) 

This passes as long as the distinct count of `FinalOrderOfNextRound > 0` equals miners who mined, regardless of whether orders are [1,2,3,4] or [3,4,5,6].

`CheckRoundTimeSlots` only validates time intervals: [5](#0-4) 

It sorts by Order but never verifies Order values are sequential starting from 1.

`UpdateValueValidationProvider` doesn't validate `TuneOrderInformation`: [6](#0-5) 

**Attack Execution:**

1. Malicious miner produces UpdateValue with `TuneOrderInformation = {Miner1→3, Miner2→4, Miner3→5, Miner4→6}`
2. `ProcessUpdateValue` applies these without validation
3. Next miner transitions to NextRound
4. `GenerateNextRoundInformation` creates round with Order values [3,4,5,6]
5. Validation providers pass (count matches, time intervals valid)
6. Any miner calls `GetConsensusCommand` to produce next block
7. Command strategy accesses `MiningInterval` property: [7](#0-6) 

8. `GetMiningInterval()` crashes - no miners have Order 1 or 2
9. All miners unable to produce blocks - consensus halted

## Impact Explanation

**Severity: HIGH** - Complete Consensus Denial-of-Service

This vulnerability causes catastrophic operational failure:

- **Total Block Production Halt**: All miners crash when retrieving consensus commands, stopping block production entirely
- **Network-Wide Impact**: Affects every node, not isolated to individual miners
- **Persistent Failure**: Corrupted round remains in state; automatic recovery impossible
- **Manual Intervention Required**: Chain operators must manually fork or patch to restore functionality
- **State Integrity Violation**: Breaks the fundamental invariant that miner Order values must be [1, N]

While no funds are directly stolen, this represents complete breakdown of blockchain operational integrity - the most severe availability impact in a consensus system.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH** - Single Malicious Miner Can Execute

The attack has low barriers:

**Attacker Requirements:**
- Must be an authorized miner in current round (passes PreCheck): [8](#0-7) 

- Can produce valid blocks with consensus transactions

**Attack Simplicity:**
- Single `UpdateValue` transaction with malicious `TuneOrderInformation`
- No complex timing or race conditions
- Deterministic and immediately effective
- No economic cost beyond normal block production

**Realistic Scenarios:**
- Compromised miner node
- Malicious election winner
- Insider threat from mining pool operator

Given miners rotate regularly through election and any single miner can execute this with one transaction, the probability is substantial in adversarial scenarios.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure `TuneOrderInformation` values form a valid sequence:

```csharp
// Before applying TuneOrderInformation
var allOrders = new HashSet<int>();
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= currentRound.RealTimeMinersInformation.Count,
        "Invalid order value in TuneOrderInformation");
    allOrders.Add(tuneOrder.Value);
}

// Verify miners who didn't tune also have valid orders
foreach (var miner in currentRound.RealTimeMinersInformation)
{
    if (!updateValueInput.TuneOrderInformation.ContainsKey(miner.Key))
    {
        allOrders.Add(miner.Value.FinalOrderOfNextRound);
    }
}

// Ensure all orders from 1 to N are present
var minersCount = currentRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null);
for (int i = 1; i <= minersCount; i++)
{
    Assert(allOrders.Contains(i), 
        $"TuneOrderInformation creates invalid order sequence - missing order {i}");
}

// Now safe to apply
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

Additionally, add defensive check in `GetMiningInterval()`:

```csharp
var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2).ToList();
Assert(firstTwoMiners.Count >= 2, "Invalid round state: missing Order 1 or 2");
return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime).Milliseconds());
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousTuneOrderInformation_CausesConsensusHalt()
{
    // Setup: 4 miners in current round
    var miners = new[] { "Miner1", "Miner2", "Miner3", "Miner4" };
    
    // Malicious miner sends UpdateValue with invalid TuneOrderInformation
    var maliciousUpdateValue = new UpdateValueInput
    {
        // Other required fields...
        TuneOrderInformation = 
        {
            { "Miner1", 3 },  // Skip Order 1
            { "Miner2", 4 },  // Skip Order 2
            { "Miner3", 5 },
            { "Miner4", 6 }
        }
    };
    
    // Execute UpdateValue - should apply without validation
    await ConsensusContract.UpdateValue(maliciousUpdateValue);
    
    // Transition to NextRound
    await ConsensusContract.NextRound(nextRoundInput);
    
    // Any miner tries to get consensus command
    var exception = await Assert.ThrowsAsync<ArgumentOutOfRangeException>(
        async () => await ConsensusContract.GetConsensusCommand(minerPubkey)
    );
    
    // Verify consensus is halted - GetMiningInterval crashed
    Assert.Contains("Index was out of range", exception.Message);
}
```

## Notes

This vulnerability exists because the consensus system assumes honest behavior in `TuneOrderInformation` construction. While the legitimate helper method `ExtractInformationToUpdateConsensus` correctly populates this field: [9](#0-8) 

A malicious miner can bypass this helper and construct `UpdateValueInput` manually with arbitrary values. The validation before execution checks the transaction structure but not the semantic correctness of Order values, allowing the corrupted state to persist until `GetMiningInterval()` is called in the next round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-54)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L38-38)
```csharp
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
