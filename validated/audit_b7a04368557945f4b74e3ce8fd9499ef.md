# Audit Report

## Title
Insufficient Recharge Validation Allows Side Chain to Immediately Fall Back Into Debt

## Summary
The `Recharge` function contains a critical mathematical error in its validation logic that double-counts the recharge amount. This allows side chains to be recharged with insufficient funds (as little as `arrears + indexingPrice/2` instead of the required `arrears + indexingPrice`), causing the chain to immediately fall back into `IndexingFeeDebt` status upon the next block indexing operation. This results in direct fund loss for rechargers and prevents proper chain reactivation.

## Finding Description

The vulnerability exists in the recharge validation assertion within the `Recharge` function. [1](#0-0) 

The execution flow is as follows:

1. **Transfer recharge amount to chain's virtual address**: The function transfers `input.Amount` tokens from the sender to the chain's virtual address. [2](#0-1) 

2. **Pay all arrears from chain balance**: If the chain is in debt, all arrears are paid out from the chain's virtual address to the creditors. [3](#0-2) 

3. **Fetch remaining balance**: The `originBalance` is fetched AFTER arrears have been paid. [4](#0-3) 

4. **Flawed validation**: The assertion validates `input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice`. [5](#0-4) 

**Mathematical Analysis:**

Let R = recharge amount, A = total arrears, P = IndexingPrice, B = initial balance.

After step 1: balance = B + R  
After step 2: balance = B + R - A  
At step 3: originBalance = B + R - A  
At step 4: Assert R + (B + R - A) >= A + P  

Simplifying: 2R + B - A >= A + P → 2R + B >= 2A + P

For a fully drained chain (B = 0): R >= A + P/2

**Correct Requirement:**

After paying arrears, the remaining balance must cover at least one indexing operation:
- (B + R - A) >= P
- R >= A + P - B
- For B = 0: R >= A + P

The flawed assertion allows recharges with only half the required indexing fee.

**Exploitation in IndexSideChainBlockData:**

The `IndexSideChainBlockData` function determines the locked token amount based on chain status. [6](#0-5) 

Since `Recharge` sets the status to `Active` [7](#0-6) , the next indexing operation fetches the actual balance (P/2 in our scenario).

When indexing a block, the indexing price is deducted from locked tokens. [8](#0-7) 

If the result is negative, new arrears are created and the chain status reverts to `IndexingFeeDebt`. [9](#0-8) 

## Impact Explanation

This vulnerability has **HIGH** severity impact:

**Direct Financial Loss:**
- Rechargers lose funds without achieving chain reactivation
- With IndexingPrice = 10 and arrears = 100, a user recharging with 105 tokens (the minimum allowed by the flawed assertion) will pay 100 to clear arrears, leaving only 5 tokens. The next indexing requiring 10 tokens will create 5 new tokens of arrears, making the 105-token recharge effectively worthless.

**Operational Disruption:**
- Side chains cannot be properly reactivated from debt status
- Cross-chain indexing functionality remains broken
- Miners/proposers don't receive payment for indexing work, accumulating more debt

**System Integrity:**
- Breaks the invariant that a successful recharge should enable at least one indexing operation
- Undermines trust in the side chain fee system

**Affected Parties:**
- Side chain operators attempting to recharge
- Block proposers/miners who index but aren't paid
- Users relying on cross-chain functionality

## Likelihood Explanation

This vulnerability has **HIGH** likelihood:

**Accessibility:**
- The `Recharge` function is publicly accessible to any user
- No special permissions required beyond token allowance

**Preconditions:**
- Side chain in `IndexingFeeDebt` status (common operational state when chains run low on funds)
- `IndexingPrice >= 2` (typical in production environments; the test suite uses `indexingPrice = 1` which masks the bug) [10](#0-9) 

**Triggering:**
- Occurs naturally when operators attempt minimal recharges to minimize costs
- No malicious intent required - legitimate users will encounter this
- Deterministic mathematical error that always triggers under the specified conditions

**Detection Difficulty:**
- The transaction succeeds without error
- Only subsequent indexing reveals the problem
- Users may repeatedly attempt recharges, losing funds each time

## Recommendation

Fix the validation logic to check the remaining balance AFTER arrears payment, not the sum of recharge and post-payment balance:

```csharp
// Current (INCORRECT):
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");

// Fixed (CORRECT):
var remainingBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(remainingBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

This ensures that after paying all arrears, at least one full `IndexingPrice` remains in the chain's balance, preventing immediate return to debt status.

## Proof of Concept

```csharp
[Fact]
public async Task RechargeWithInsufficientFunds_ChainReturnsToDebt()
{
    // Setup: Create side chain with IndexingPrice = 10
    long indexingPrice = 10;
    long lockedToken = 30; // Enough for 3 blocks
    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation: 10,
        parentChainId: 123,
        lockedToken,
        indexingPrice,
        AnotherKeyPair);

    // Index 3 blocks to drain balance to 0, creating debt
    var crossChainBlockData = new CrossChainBlockData();
    for (int i = 1; i <= 4; i++)
    {
        crossChainBlockData.SideChainBlockDataList.Add(
            CreateSideChainBlockData(
                HashHelper.ComputeFrom("hash"),
                i,
                sideChainId,
                HashHelper.ComputeFrom("root")));
    }
    await DoIndexAsync(crossChainBlockData, new[] { sideChainId });
    
    // Chain should be in debt with 10 tokens arrears
    var status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.IndexingFeeDebt);
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt
        .CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(10);

    // Recharge with only 15 tokens (arrears + indexingPrice/2)
    // This SHOULD fail but WILL succeed due to the bug
    await ApproveBalanceAsync(15);
    await CrossChainContractStub.Recharge.SendAsync(new RechargeInput
    {
        ChainId = sideChainId,
        Amount = 15
    });

    // Status is now Active with balance = 5 (insufficient!)
    status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.Active);
    var balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(5); // Only 5 tokens left, but need 10

    // Index one more block - chain IMMEDIATELY returns to debt
    crossChainBlockData = new CrossChainBlockData
    {
        SideChainBlockDataList = 
        {
            CreateSideChainBlockData(
                HashHelper.ComputeFrom("hash"),
                5,
                sideChainId,
                HashHelper.ComputeFrom("root"))
        }
    };
    await DoIndexAsync(crossChainBlockData, new[] { sideChainId });

    // Chain is back in debt - recharge was wasted!
    status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.IndexingFeeDebt); // ❌ Bug confirmed
    debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt
        .CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(5); // New arrears created
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L828-830)
```csharp
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L844-844)
```csharp
                lockedToken -= indexingPrice;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L846-851)
```csharp
                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L1243-1243)
```csharp
                    IndexingPrice = 1,
```
