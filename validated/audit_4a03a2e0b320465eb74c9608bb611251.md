# Audit Report

## Title
Unvalidated Decrypted Secret Pieces Enable Secret Sharing Corruption in AEDPoS Consensus

## Summary
The AEDPoS consensus contract accepts and stores decrypted secret pieces from miners without cryptographic validation, allowing any malicious miner to inject arbitrary data that corrupts the Shamir's Secret Sharing reconstruction mechanism. This breaks the Byzantine fault tolerance guarantees of the threshold secret sharing scheme and compromises consensus randomness.

## Finding Description

The vulnerability exists in the secret sharing mechanism where decrypted pieces are accepted without validation. When a miner produces a block, they provide trigger information containing `DecryptedPieces` that claim to be decryptions of other miners' encrypted secret shares.

**Root Cause:**

In `UpdateLatestSecretPieces()`, the contract stores decrypted pieces with only a basic existence check: [1](#0-0) 

The function only verifies that the target miner exists in `RealTimeMinersInformation`, but performs NO cryptographic validation that:
1. The decrypted piece is a legitimate decryption of an encrypted piece
2. The submitting miner actually received an encrypted piece from the target miner
3. The decrypted value corresponds to any previously submitted encrypted piece

**Exploitation Flow:**

1. During block production, `GetConsensusExtraDataToPublishOutValue()` is called, which invokes `UpdateLatestSecretPieces()`: [2](#0-1) 

2. A malicious miner with modified node software injects arbitrary `DecryptedPieces` in the trigger information, claiming they are decryptions of other miners' secret shares.

3. During the next round transition, `RevealSharedInValues()` reconstructs InValues using ALL submitted decrypted pieces: [3](#0-2) 

The function uses `SecretSharingHelper.DecodeSecret()` with the corrupted pieces, producing wrong reconstructed InValues that are set as `PreviousInValue` without validation against the original `OutValue`.

**Why Existing Protections Fail:**

The only validation that exists is in `UpdateValueValidationProvider`, which validates when a miner submits their OWN `PreviousInValue`: [4](#0-3) 

This validation does NOT apply to `PreviousInValues` revealed through secret sharing reconstruction in `RevealSharedInValues()`.

Similarly, in `PerformSecretSharing()` which processes the transaction-based secret sharing, decrypted pieces are stored without validation: [5](#0-4) 

## Impact Explanation

**Consensus Integrity Violation:**

The `PreviousInValue` is used in signature calculations for consensus randomness: [6](#0-5) 

The signature determines the mining order for the next round: [7](#0-6) 

Corrupted `PreviousInValue` leads to manipulated signatures, allowing attackers to influence:
- Miner ordering for subsequent rounds
- The consensus randomness beacon
- Overall fairness of the consensus mechanism

**Secret Sharing Security Break:**

The threshold secret sharing scheme is designed to tolerate up to 1/3 Byzantine miners. However, this vulnerability allows a SINGLE malicious miner to inject fake pieces that corrupt reconstruction for ALL target miners, completely breaking the Byzantine fault tolerance guarantee.

**Denial of Service:**

When secret sharing is enabled, legitimate miners' InValues cannot be properly revealed, causing the consensus mechanism to degrade. This affects network-wide consensus operation.

**Severity: Critical** - Breaks fundamental consensus security properties with minimal attack complexity.

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the consensus set (feasible - miners exist by design)
- No special privileges required beyond normal mining rights
- Attacker controls their own node software

**Attack Complexity: LOW**
- Simply inject arbitrary data in `triggerInformation.DecryptedPieces` during block production
- The trigger information is created off-chain by the miner's node software
- No cryptographic operations needed by attacker
- No coordination with other actors required

**Feasibility Conditions:**
- Secret sharing must be enabled (checked via configuration contract): [8](#0-7) 

- Attacker produces at least one block in the round (normal miner operation)

**Detection Difficulty: HIGH**
- No on-chain validation to detect malicious pieces
- Off-chain services decrypt pieces correctly but cannot prevent on-chain corruption
- Requires analyzing revealed InValues against original OutValues to detect manipulation

**Economic Rationality:**
- Near-zero cost (part of normal block production)
- High impact (disrupts consensus for entire network)
- Risk/reward heavily favors attack

## Recommendation

Implement cryptographic validation of decrypted pieces by verifying that each decrypted piece correctly corresponds to a previously submitted encrypted piece. The validation should ensure:

1. **Encrypted Piece Existence**: Verify that an encrypted piece was previously submitted by the target miner for the submitting miner
2. **Decryption Correctness**: Use zero-knowledge proofs or other cryptographic techniques to verify the decryption is correct
3. **Reconstruction Validation**: After revealing InValues through secret sharing, validate that `Hash(reconstructed_InValue) == original_OutValue`

Example fix for `RevealSharedInValues()`:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    var revealedInValue = 
        HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
    
    // ADD VALIDATION: Check if reconstructed InValue matches the original OutValue
    var expectedOutValue = previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
    if (expectedOutValue != null && expectedOutValue != Hash.Empty)
    {
        var reconstructedOutValue = HashHelper.ComputeFrom(revealedInValue);
        if (reconstructedOutValue != expectedOutValue)
        {
            Context.LogDebug(() => $"Invalid revealed InValue for {publicKeyOfAnotherMiner}");
            continue; // Skip invalid reconstruction
        }
    }
    
    currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
}
```

Additionally, consider implementing proof-of-correct-decryption schemes where miners must provide cryptographic proof that their decrypted pieces are valid decryptions of the encrypted pieces they received.

## Proof of Concept

A malicious miner can exploit this vulnerability with the following attack sequence:

1. Modify node software to inject fake `DecryptedPieces` in `AElfConsensusTriggerInformation`
2. During block production in round N, submit trigger information with:
   - Legitimate `EncryptedPieces` for own InValue
   - Fake `DecryptedPieces` with arbitrary byte arrays for other miners
3. The contract accepts and stores these fake pieces via `UpdateLatestSecretPieces()`
4. In round N+1, the extra block producer calls `RevealSharedInValues()`
5. The function reconstructs wrong InValues using the fake pieces
6. These corrupted InValues are set as `PreviousInValue` and affect subsequent signature calculations
7. Consensus randomness is now compromised

The attack succeeds because:
- No validation in `UpdateLatestSecretPieces()` (only checks target miner existence)
- No validation in `RevealSharedInValues()` (blindly trusts all pieces)
- `UpdateValueValidationProvider` only validates self-submitted PreviousInValue, not revealed ones

**Notes**

This vulnerability demonstrates a critical trust boundary violation where off-chain data (DecryptedPieces from trigger information) is accepted on-chain without cryptographic verification. The trigger information is created by each miner's node software, and a malicious miner can modify their node to inject arbitrary data. The contract must not trust this data without validation, especially for security-critical operations like secret sharing that underpin consensus randomness.

The threshold secret sharing scheme is designed to tolerate Byzantine failures, but this implementation flaw allows a single malicious miner to completely bypass the threshold requirement by injecting fake pieces. This breaks the fundamental security assumption that at least 2/3 honest miners are needed to reveal secrets.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-21)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
