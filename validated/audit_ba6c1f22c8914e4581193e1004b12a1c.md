# Audit Report

## Title 
Arithmetic Overflow in PayRental Calculation Causes Permanent DoS of Side Chain Resource Fee Collection

## Summary
The `PayRental()` method in the MultiToken contract performs unbounded multiplication of `duration × ResourceAmount × Rental` using checked arithmetic, where duration grows based on elapsed time since last payment. When side chains experience extended downtime with moderate rental parameters, arithmetic overflow triggers `OverflowException`, causing permanent DoS of the automatic resource rental collection system until governance intervention.

## Finding Description

The vulnerability exists in the side chain rental fee calculation that executes automatically on every block. The `PayRental()` method calculates rental charges using checked arithmetic multiplication: [1](#0-0) 

Where `duration` is the unbounded time difference in minutes since the last payment: [2](#0-1) 

The `.Mul()` extension method uses C#'s `checked` keyword that throws `OverflowException` when multiplication exceeds `long.MaxValue`: [3](#0-2) 

The root cause is that governance-controlled rental parameters lack upper bound validation. The `UpdateRental` method only validates non-negativity: [4](#0-3) 

Similarly, `UpdateRentedResources` has the same insufficient validation: [5](#0-4) 

The execution path is automatic and unavoidable. `PayRental()` is called from `DonateResourceToken()` on all side chains: [6](#0-5) 

And `DonateResourceToken()` is automatically invoked by miners each block via the system transaction generator: [7](#0-6) 

When overflow occurs, the entire system transaction fails with `OverflowException`, preventing all subsequent rental collection attempts until governance reduces the parameters.

## Impact Explanation

**Severity: HIGH**

The impact is complete operational failure of a critical side chain economic mechanism:

1. **Permanent DoS**: `DonateResourceToken()` fails on every block attempt, completely breaking the resource rental collection system
2. **Economic disruption**: Side chain creators stop paying rental fees for resources (CPU, RAM, DISK, NET), violating the economic model where side chains pay for exclusive resource usage
3. **Consensus impact**: The consensus contract stops receiving rental payments that should fund validator rewards [8](#0-7) 

Overflow timing analysis (where `long.MaxValue = 9,223,372,036,854,775,807`):
- **Moderate parameters** (ResourceAmount=1000, Rental=10,000,000,000): Overflow after ~922,337 minutes (~640 days) of downtime
- **High parameters** (ResourceAmount=10,000, Rental=100,000,000,000): Overflow after ~92,233 minutes (~64 days) of downtime  
- **Very high parameters** (ResourceAmount=100,000, Rental=1,000,000,000,000): Overflow after ~9,223 minutes (~6.4 days) of downtime

The only recovery path is emergency governance intervention to reduce `Rental` or `ResourceAmount` values through proposal creation, approval, and execution—a multi-step, time-consuming process during which the DoS persists.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability has high likelihood because:

1. **No attacker required**: The vulnerability triggers automatically based on time passage—no malicious action needed
2. **Realistic preconditions**: Side chains can experience extended downtime due to:
   - Network partitions separating validators from each other or the main chain
   - All validators going offline simultaneously due to infrastructure issues
   - Critical consensus bugs requiring emergency fixes and chain halts
   - Economic attacks causing validator departures
3. **Legitimate parameter values**: Governance may legitimately set moderate-to-high rental rates for resource pricing based on market conditions, unknowingly creating overflow risk with downtime
4. **Automatic trigger**: Once the overflow threshold is reached, the next miner's automatic `DonateResourceToken()` call immediately triggers the exception
5. **No safeguards**: The state variables are typed as `int` (ResourceAmount) and `long` (Rental) with no upper bounds, and duration calculation is unbounded [9](#0-8) 

The combination of realistic downtime scenarios, legitimate parameter choices, and automatic triggering makes this vulnerability highly likely to occur in production side chains.

## Recommendation

Implement upper bound validation for rental parameters to prevent overflow conditions:

```csharp
public override Empty UpdateRental(UpdateRentalInput input)
{
    AssertControllerForSideChainRental();
    const long maxRental = long.MaxValue / (365 * 24 * 60 * 100000); // Safe for 1 year with ResourceAmount=100000
    
    foreach (var pair in input.Rental)
    {
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
            "Invalid symbol.");
        Assert(pair.Value >= 0, "Invalid amount.");
        Assert(pair.Value <= maxRental, "Rental exceeds maximum safe value.");
        State.Rental[pair.Key] = pair.Value;
    }
    
    return new Empty();
}
```

Additionally, add overflow protection in `PayRental()`:

```csharp
// Cap duration to prevent overflow
var maxSafeDuration = long.MaxValue / (State.ResourceAmount[symbol] * State.Rental[symbol]);
var actualDuration = duration > maxSafeDuration ? maxSafeDuration : duration;
var rental = actualDuration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

Or use try-catch to handle overflow gracefully:

```csharp
try
{
    var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
    // ... existing logic
}
catch (OverflowException)
{
    // Pay maximum safe amount or emit event for governance intervention
    Context.Fire(new RentalCalculationOverflow { Symbol = symbol });
    continue;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task PayRental_ArithmeticOverflow_CausesDoS()
{
    // Initialize side chain with rental parameters
    await InitialTokenContractAsync();
    
    // Set high rental parameters via governance
    var updateRentalInput = new UpdateRentalInput
    {
        Rental =
        {
            { "CPU", 100_000_000_000L }, // 100 billion tokens per minute
            { "RAM", 100_000_000_000L },
            { "DISK", 100_000_000_000L },
            { "NET", 100_000_000_000L }
        }
    };
    await UpdateSideChainRentalDefaultProposalAsync(
        nameof(TokenContractImplContainer.TokenContractImplStub.UpdateRental), 
        updateRentalInput);
    
    var updateResourceInput = new UpdateRentedResourcesInput
    {
        ResourceAmount =
        {
            { "CPU", 10000 },
            { "RAM", 10000 },
            { "DISK", 10000 },
            { "NET", 10000 }
        }
    };
    await UpdateSideChainRentalDefaultProposalAsync(
        nameof(TokenContractImplContainer.TokenContractImplStub.UpdateRentedResources), 
        updateResourceInput);
    
    // Simulate extended downtime by advancing time ~100 days (overflow threshold)
    // duration = 100 days * 24 hours * 60 minutes = 144,000 minutes
    // rental = 144,000 * 10,000 * 100,000,000,000 = 144,000,000,000,000,000,000
    // This exceeds long.MaxValue (9,223,372,036,854,775,807)
    
    for (int i = 0; i < 14400; i++) // Simulate 100 days (10 minutes per iteration)
    {
        await BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(10));
    }
    
    // Attempt to call DonateResourceToken (happens automatically on side chains)
    var result = await TokenContractStub.DonateResourceToken.SendWithExceptionAsync(
        new TotalResourceTokensMaps());
    
    // Verify the transaction fails with overflow exception
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("OverflowException");
    
    // Verify rental collection is permanently broken - all subsequent attempts fail
    await BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(1));
    var secondAttempt = await TokenContractStub.DonateResourceToken.SendWithExceptionAsync(
        new TotalResourceTokensMaps());
    secondAttempt.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

## Notes

This vulnerability demonstrates a critical flaw in the side chain economic model where legitimate governance parameter choices combined with realistic operational scenarios (extended downtime) can cause permanent system failure. The automatic execution nature of the rental collection mechanism means there is no manual intervention possible once the overflow condition is reached—only governance can fix it by reducing parameters, which is a slow multi-step process.

The vulnerability is particularly severe because:
1. It affects production-critical functionality (rental collection)
2. It can occur with legitimate parameter values (not just extreme edge cases)
3. Recovery requires time-consuming governance procedures during which the DoS persists
4. Side chain operators may not immediately understand why rental collection stopped working

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L947-950)
```csharp
        if (!isMainChain)
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1031-1031)
```csharp
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1085-1087)
```csharp
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1107-1107)
```csharp
            Assert(pair.Value >= 0, "Invalid amount.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1122-1122)
```csharp
            Assert(pair.Value >= 0, "Invalid amount.");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L60-71)
```csharp
        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L26-31)
```csharp
    public MappedState<string, int> ResourceAmount { get; set; }

    /// <summary>
    /// Symbol -> Amount (Tokens per minute)
    /// </summary>
    public MappedState<string, long> Rental { get; set; }
```
