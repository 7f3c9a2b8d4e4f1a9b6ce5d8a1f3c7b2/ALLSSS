# Audit Report

## Title
Unvalidated Extra Block Producer Invariant Enables Consensus DoS via Single() Exception

## Summary
The `IsCurrentMiner` function enforces that exactly one miner has `IsExtraBlockProducer=true` by using `.Single()`, which throws `InvalidOperationException` if this invariant is violated. Byzantine miners can submit `NextRoundInput` with corrupted round data (zero or multiple extra block producers) that bypasses all validation checks, causing denial of service for cross-chain indexing and other consensus operations.

## Finding Description

The vulnerability exists because the extra block producer invariant is not validated when miners submit next round information, yet operations assume this invariant holds.

**Root Cause - Unsafe Direct Copy:**

When miners submit `NextRound`, the input is converted via `ToRound()` which directly copies all fields including the `RealTimeMinersInformation` dictionary with all `IsExtraBlockProducer` flags, without any validation: [1](#0-0) 

The converted round is then stored directly into state via `ProcessNextRound`: [2](#0-1) 

**Missing Validation:**

The validation logic for `NextRound` behavior includes only basic checks (round number, InValue nullness, mining order consistency) but does NOT validate the extra block producer count: [3](#0-2) [4](#0-3) [5](#0-4) 

**Dangerous Assumption:**

The `IsCurrentMiner` function assumes exactly one extra block producer exists and uses `.Single()` which throws `InvalidOperationException` if zero or multiple miners have the flag set: [6](#0-5) 

Similarly, `GetExtraBlockProducerInformation()` uses `.First()` which throws on empty sequences: [7](#0-6) 

**Impact - Cross-Chain Operations Blocked:**

Cross-chain indexing operations are completely blocked because they require the `IsCurrentMiner` check: [8](#0-7) [9](#0-8) [10](#0-9) [11](#0-10) 

## Impact Explanation

**Severity: HIGH - Complete Operational DoS**

The vulnerability causes complete denial of service for critical protocol operations:

1. **Cross-Chain Communication Halted**: Miners cannot propose or release cross-chain indexing data, completely blocking parent-child chain communication until the corrupted round ages out (up to 40,960 rounds as defined by `AEDPoSContractConstants.KeepRounds`) [12](#0-11) 

2. **Consensus Operations Disrupted**: Any operation depending on `IsCurrentMiner` or `GetExtraBlockProducerInformation` fails with exceptions, including abnormal mining time arrangement and miner identification

3. **No Fund Loss but Severe Protocol Disruption**: While no funds are directly at risk, the inability to perform cross-chain operations and consensus coordination represents a critical protocol failure that breaks the fundamental interoperability guarantees of the AElf ecosystem

4. **Extended Recovery Time**: The corrupted round data persists in state until it naturally ages out over thousands of rounds, or requires governance intervention to resolve

## Likelihood Explanation

**Probability: MEDIUM**

**Attacker Requirements:**
- Must be an active miner in the consensus set (high barrier but explicitly within the Byzantine fault tolerance threat model)
- Must wait for their scheduled mining turn (timing constraint)

**Attack Complexity: TRIVIAL**
- No cryptographic bypasses required
- Simple modification of `IsExtraBlockProducer` flags in `NextRoundInput` structure
- Attack is immediately executable once the attacker has miner status and timing conditions are met

**Economic Considerations:**
- Economically irrational for long-term honest miners (reputation damage, potential slashing through governance)
- Feasible for compromised nodes or attackers willing to sacrifice miner stake for temporary disruption
- Attack is immediately visible and traceable to the malicious miner's public key

**Realistic Threat Scenario:**
The Byzantine fault tolerance model explicitly assumes that some percentage of miners may be compromised or malicious. This attack is trivially executable by any such miner during their turn, making it a realistic threat within the protocol's security assumptions.

## Recommendation

Add validation in the `NextRound` processing to enforce the extra block producer invariant:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Validate extra block producer invariant
    var extraBlockProducerCount = nextRound.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    Assert(extraBlockProducerCount == 1, 
        "Exactly one miner must be designated as extra block producer.");
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of the method
}
```

Alternatively, add a dedicated validation provider in `AEDPoSContract_Validation.cs` for `NextRound` behavior that checks this invariant before the round data is stored.

## Proof of Concept

The proof of concept would involve:
1. Setting up a test environment with multiple miners
2. Obtaining miner privileges 
3. Constructing a `NextRoundInput` with zero or multiple miners having `IsExtraBlockProducer = true`
4. Calling `NextRound()` during the attacker's mining turn
5. Demonstrating that subsequent calls to `ProposeCrossChainIndexing` or other operations using `IsCurrentMiner` throw `InvalidOperationException`

Due to the complexity of setting up a full consensus test environment and the need for miner privileges, a complete executable test is beyond the scope of this report. However, the vulnerability is clearly demonstrable through code inspection showing the missing validation and the `.Single()` usage that will throw on invariant violation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
