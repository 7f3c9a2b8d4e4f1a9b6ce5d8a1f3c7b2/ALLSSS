# Audit Report

## Title
MissedTimeSlots Counter Reset at Term Boundaries Allows Malicious Miners to Evade Evil Node Detection

## Summary
The AEDPoS consensus contract resets the `MissedTimeSlots` counter to 0 during term transitions without performing evil miner detection, while detection only occurs during normal round transitions. This allows malicious miners to strategically miss blocks below the 4320-slot threshold and have their counters reset every 7-day term, enabling indefinite evasion of punishment.

## Finding Description

The consensus contract defines a tolerance threshold of 4320 missed time slots (representing 3 days at 1 slot per minute) for detecting evil miners. [1](#0-0) 

The detection mechanism `TryToDetectEvilMiners()` identifies miners whose `MissedTimeSlots` exceeds this threshold and returns their public keys. [2](#0-1) 

**Critical Flaw:** Evil miner detection is ONLY performed during normal round transitions in `ProcessNextRound`, where the consensus contract checks for evil miners on the main chain and marks them by calling the Election contract with `IsEvilNode = true`. [3](#0-2) 

When detected, evil miners are permanently banned by the Election contract, which removes them from the candidate list, zeros their data center ranking, fires an `EvilMinerDetected` event, and removes them as beneficiaries from profit schemes. [4](#0-3) 

However, during term transitions in `ProcessNextTerm`, the contract counts any final missed time slots via `CountMissedTimeSlots()` [5](#0-4) , then **unconditionally resets ALL miners' `MissedTimeSlots` and `ProducedBlocks` to 0** [6](#0-5) , sends statistics to the Election contract (informational only) [7](#0-6) , but **does NOT call `TryToDetectEvilMiners()` before the reset**.

The `MissedTimeSlots` counter is incremented by 1 when miners fail to produce blocks during round generation. [8](#0-7) 

**Attack Scenario:** With term duration configured as 604800 seconds (7 days) [9](#0-8) , a malicious miner can:
- Miss up to 4319 time slots during each 7-day term period
- Avoid detection since they stay below the 4320 threshold
- Have their counter reset to 0 at the term boundary
- Repeat this pattern indefinitely across multiple terms

## Impact Explanation

This vulnerability has severe consensus integrity implications:

**Consensus Reliability Compromise:** With a 7-day term containing approximately 10,080 time slots (1 slot per minute), a miner can miss 4319 slots (~42.8% of their obligations) per term without punishment, significantly reducing network block production capacity.

**Protocol Invariant Violation:** The system's fundamental security guarantee—that miners exceeding the 4320 missed-slot threshold will be removed—is completely bypassed through this cross-term evasion mechanism. The Election contract maintains cumulative statistics but these are never checked for evil node detection. [10](#0-9) 

**Persistent Attacker Advantage:** Malicious miners can remain in the active miner set indefinitely despite consistently poor performance, while honest miners who happen to exceed the threshold in a single term are permanently banned.

**No Economic Penalty:** The attacker maintains their miner status and potential rewards despite reduced participation, creating an unfair advantage and undermining the incentive structure designed to ensure reliable block production.

## Likelihood Explanation

**Attack Complexity:** Trivial - the attacker simply needs to control their own mining node's block production behavior.

**Preconditions:** 
- Attacker must be an elected miner (achievable through normal election process)
- No special permissions required beyond standard miner status
- Term transitions occur automatically every 7 days as configured in the system

**Execution Practicality:**
- The attack is fully deterministic and risk-free
- No coordination with other parties needed
- Term boundary reset is automatic and unavoidable
- The cumulative counter in Election contract is purely informational and not used for evil node detection

**Detection Difficulty:** The current implementation provides no way to detect this pattern since evil node checks only examine the per-term counter, which resets at term boundaries before any detection logic runs.

## Recommendation

Perform evil miner detection before resetting the counters during term transitions. Modify `ProcessNextTerm` to call `TryToDetectEvilMiners()` on the current round before the reset:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();

    // Count missed time slot of current round.
    CountMissedTimeSlots();
    
    // NEW: Detect evil miners before resetting counters
    if (!TryToGetCurrentRoundInformation(out var currentRound)) 
        Assert(false, "Failed to get current round information.");
        
    if (State.IsMainChain.Value && currentRound.TryToDetectEvilMiners(out var evilMiners))
    {
        Context.LogDebug(() => "Evil miners detected during term transition.");
        foreach (var evilMiner in evilMiners)
        {
            Context.LogDebug(() =>
                $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = evilMiner,
                IsEvilNode = true
            });
        }
    }

    Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");
    // ... rest of existing code
}
```

This ensures evil miners are detected and removed regardless of whether the threshold is exceeded during normal round transitions or at term boundaries.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Initialize a consensus contract with multiple miners
2. Have one miner miss 4319 time slots over multiple rounds within a term
3. Verify no evil node detection occurs during `ProcessNextRound` calls
4. Trigger a term transition via `ProcessNextTerm`
5. Verify the miner's `MissedTimeSlots` counter is reset to 0
6. Confirm the miner remains in the active miner set
7. Repeat for multiple terms to show indefinite evasion

The vulnerability is demonstrated by the fact that the counter reset occurs without any evil miner check, allowing the pattern to repeat indefinitely across term boundaries.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-118)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L87-96)
```csharp
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-56)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L12-12)
```csharp
    public long PeriodSeconds { get; set; } = 604800;
```
