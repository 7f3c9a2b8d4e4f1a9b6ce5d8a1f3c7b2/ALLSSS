# Audit Report

## Title
Permanent Token Lock When CandidateSponsorMap Is Null and Candidate Key Is Lost

## Summary
When candidates announce election via `AnnounceElection` (self-sponsored flow), the `CandidateSponsorMap` is never initialized. If the candidate subsequently loses their private key, the 100,000 token deposit becomes permanently inaccessible because `QuitElection` defaults to transferring funds to the candidate's own address, with no mechanism to redirect to a recoverable address.

## Finding Description

The vulnerability stems from an asymmetry in how two election announcement methods handle sponsor tracking:

**Missing Sponsor Initialization in Self-Announcement:**

When using `AnnounceElection`, tokens are locked from the sender but `State.CandidateSponsorMap` is never initialized (remains null). [1](#0-0) 

In contrast, `AnnounceElectionFor` explicitly sets the sponsor mapping to the transaction sender. [2](#0-1) 

**Irrecoverable Token Destination:**

During `QuitElection`, tokens are transferred to `State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes)`. When the sponsor map is null, the fallback destination is the candidate's own address derived from their public key. [3](#0-2) 

**Insufficient Administrative Recovery:**

While Parliament can change the admin via `SetCandidateAdmin` to enable a new admin to call `QuitElection` [4](#0-3) , this doesn't help because the token destination is hardcoded based on `CandidateSponsorMap`, not the admin address. The admin authorization check only controls WHO can call `QuitElection` [5](#0-4) , but doesn't affect WHERE the tokens are sent.

**No Setter Mechanism:**

The codebase contains no method to set or update `CandidateSponsorMap` after announcement. The mapping is only assigned in `AnnounceElectionFor`, transferred during `ReplaceCandidatePubkey` [6](#0-5) , and removed during `QuitElection` [7](#0-6) . The state variable definition confirms it's a simple mapping with no additional setters. [8](#0-7) 

The locked amount is 100,000 tokens per candidate. [9](#0-8) 

## Impact Explanation

**Quantified Loss:** Each affected candidate permanently loses 100,000 tokens (100_000_00000000 with 8 decimals).

**Affected Parties:**
- Candidates who announced via `AnnounceElection` and subsequently lost their private key
- Cannot recover their election deposit despite having an admin with authorization
- Tokens remain locked in virtual addresses with no recovery path

**Protocol Impact:**
- Violates the protocol invariant that locked deposits should be recoverable through administrative mechanisms
- Creates operational risk for candidates using the legitimate `AnnounceElection` method
- No governance intervention mechanism exists to recover these funds since Parliament can only change the admin, not the token destination

The severity is Medium because while the impact is significant (100,000 tokens permanently lost), it requires both the use of a specific announcement method and key loss to manifest.

## Likelihood Explanation

**Realistic Preconditions:**
1. Using `AnnounceElection` is a documented, public method that candidates legitimately choose for self-sponsorship
2. Private key loss is a well-documented occurrence in blockchain systems (hardware failure, operational errors, security breaches)
3. Both conditions are realistic operational scenarios rather than malicious attacks

**Feasibility:**
- Entry point: Public `AnnounceElection` method accessible to any candidate
- No special privileges required to enter the vulnerable state
- The issue manifests naturally through normal contract usage combined with key loss

**Probability:**
The likelihood is Medium because it requires both conditions: (1) choosing `AnnounceElection` over `AnnounceElectionFor` AND (2) experiencing key loss. However, both are realistic scenarios that can occur in production environments.

## Recommendation

Add a method to set or update `CandidateSponsorMap` for existing candidates, callable by Parliament or the candidate's admin:

```csharp
public override Empty SetCandidateSponsor(SetCandidateSponsorInput input)
{
    Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey), 
        "Pubkey is neither a current candidate nor an initial miner.");
    
    var initialPubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
    
    // Allow Parliament or candidate admin to set sponsor
    Assert(Context.Sender == GetParliamentDefaultAddress() || 
           Context.Sender == State.CandidateAdmins[initialPubkey], 
           "No permission.");
    
    State.CandidateSponsorMap[input.Pubkey] = input.SponsorAddress;
    
    return new Empty();
}
```

Alternatively, modify `QuitElection` to send tokens to the admin address when `CandidateSponsorMap` is null, providing a recovery path for candidates who used `AnnounceElection`.

## Proof of Concept

```csharp
[Fact]
public async Task PermanentTokenLock_WhenCandidateSponsorMapNull_AndKeyLost()
{
    // Candidate announces election using AnnounceElection (self-sponsored)
    var candidateKeyPair = SampleECKeyPairs.KeyPairs[0];
    var candidateAddress = Address.FromPublicKey(candidateKeyPair.PublicKey);
    var adminAddress = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey);
    
    // Fund candidate and approve deposit
    await TransferAndApproveForElection(candidateAddress);
    
    // Announce election with admin
    var result = await CandidateStub.AnnounceElection.SendAsync(adminAddress);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify CandidateSponsorMap is null
    var sponsor = await ElectionContractStub.GetSponsor.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    sponsor.ShouldBe(candidateAddress); // Falls back to candidate address
    
    // Simulate key loss: Parliament sets new admin
    var newAdminAddress = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey);
    await ParliamentSetCandidateAdmin(candidateKeyPair.PublicKey.ToHex(), newAdminAddress);
    
    // New admin attempts to quit election
    var newAdminStub = GetElectionContractStub(SampleECKeyPairs.KeyPairs[2]);
    var quitResult = await newAdminStub.QuitElection.SendAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    quitResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Tokens sent to inaccessible candidate address, not admin address
    var candidateBalance = await GetBalance(candidateAddress);
    candidateBalance.ShouldBe(100_000_00000000); // Tokens returned to lost address
    
    var adminBalance = await GetBalance(newAdminAddress);
    adminBalance.ShouldBe(0); // Admin cannot access tokens
}
```

## Notes

The Election contract is whitelisted for token transfers from virtual addresses [10](#0-9) , so the `TransferFrom` operation in `QuitElection` executes successfully via the whitelist mechanism [11](#0-10) . The vulnerability is not about execution failure, but rather that tokens are sent to the wrong (inaccessible) destination when `CandidateSponsorMap` is null.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-42)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L277-277)
```csharp
        State.CandidateSponsorMap.Remove(pubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L92-95)
```csharp
    /// <summary>
    ///     Pubkey -> Sponsor address (who will pay announce election fee for this pubkey)
    /// </summary>
    public MappedState<string, Address> CandidateSponsorMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L44-53)
```csharp
        var lockWhiteListBackups = new List<Address>
        {
            Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName)
        };
        var lockWhiteList = lockWhiteListBackups.Where(address => address != null).ToList();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L74-84)
```csharp
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }
```
