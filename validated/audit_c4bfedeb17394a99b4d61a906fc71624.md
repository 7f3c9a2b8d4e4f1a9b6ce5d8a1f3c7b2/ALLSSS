# Audit Report

## Title
Missing Mining Interval Validation in Next Round Consensus Transition

## Summary
The AEDPoS consensus validation logic fails to verify that the mining interval in submitted next round data matches the configured `State.MiningInterval.Value` parameter. Any active miner can submit next round information with arbitrarily modified mining intervals, causing permanent consensus timing disruption that persists indefinitely across all subsequent rounds.

## Finding Description

The AEDPoS consensus contract stores a fixed mining interval parameter set during initialization. [1](#0-0)  This value is initialized once during the first round. [2](#0-1) 

However, when validating next round transitions, the `ValidationForNextRound()` function only performs two checks: verifying the round number increments by exactly one, and ensuring InValue fields are null. [3](#0-2)  Critically, there is no validation comparing the mining interval derived from the next round data against `State.MiningInterval.Value`.

The only time-related validation is `CheckRoundTimeSlots()`, which verifies the mining interval is positive and that time slots between consecutive miners are internally consistent. [4](#0-3)  This validation checks relative consistency but does not enforce conformance to the configured parameter.

When generating next round information, the system calculates the mining interval from the current round's timing data rather than using the immutable state value. [5](#0-4)  This calculated interval is then used to set all expected mining times in the next round. [6](#0-5) 

**Attack Scenario**: A malicious miner producing an extra block can modify all `ExpectedMiningTime` values in their next round data to use any interval (e.g., 8000ms instead of 4000ms). As long as these modified times maintain internal proportional consistency, `CheckRoundTimeSlots()` passes. Since `ValidationForNextRound()` never compares against `State.MiningInterval.Value`, the validation succeeds. The corrupted round data is stored, and because `GetMiningInterval()` calculates from stored round data, the manipulated interval propagates to all future rounds indefinitely.

## Impact Explanation

**Consensus Timing Disruption**: The mining interval is a fundamental consensus parameter determining block production rate and round duration. Changing it from 4000ms to 8000ms halves network throughput, while changing it to 2000ms doubles the rate. This affects all network participants' expectations about block timing and consensus progression.

**Permanent Cumulative Drift**: Since `GetMiningInterval()` calculates from stored round data rather than `State.MiningInterval.Value`, the manipulated interval persists indefinitely. Each subsequent round inherits the corrupted timing through the generation process, creating permanent protocol deviation from the initialized configuration.

**Protocol Invariant Violation**: The mining interval should remain immutably fixed per the initialization configuration. This vulnerability allows arbitrary runtime modification of a core consensus parameter, breaking the fundamental assumption that consensus timing parameters are immutable constants set during genesis or first round initialization.

**Network-Wide Impact**: All validators, block producers, and dependent systems are affected when consensus timing deviates from expected parameters. External applications and indexers relying on predictable block timing may malfunction or produce incorrect results.

## Likelihood Explanation

**Direct Entry Point**: Any active miner can produce blocks containing consensus extra data with NextRound behavior during their extra block time slot. The validation pipeline automatically executes for all submitted consensus information. [7](#0-6) 

**Low Attack Complexity**: The attacker only needs to:
1. Wait for their turn to produce an extra block (triggering NextRound behavior)
2. Generate legitimate next round data via the standard consensus mechanism
3. Proportionally modify all `ExpectedMiningTime` values to establish a different interval
4. Submit the modified data in their block's consensus extra data

**Standard Preconditions**: The attacker must be an active miner in the current round, which is a standard participant role obtained through the election process. This does not require system compromise or privileged accessâ€”it is the normal operating role for consensus participants.

**Subtle Detection**: The attack produces internally consistent round data that passes all existing validations. Without explicit comparison against `State.MiningInterval.Value`, the manipulation is completely undetectable by the validation logic. The divergence only becomes apparent over time as consensus timing drifts from expected values.

## Recommendation

Add explicit mining interval validation in the `ValidationForNextRound()` method:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing validations
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
        
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate mining interval matches configured value
    var nextRoundInterval = extraData.Round.GetMiningInterval();
    if (nextRoundInterval != State.MiningInterval.Value)
        return new ValidationResult { 
            Message = $"Mining interval mismatch. Expected: {State.MiningInterval.Value}, Got: {nextRoundInterval}" 
        };
    
    return new ValidationResult { Success = true };
}
```

This ensures that the next round's mining interval must match the immutable configuration, preventing any runtime modification of this critical consensus parameter.

## Proof of Concept

```csharp
[Fact]
public async Task MiningInterval_CanBeManipulated_InNextRound()
{
    // Setup: Initialize consensus with 4000ms mining interval
    await InitializeConsensus();
    var initialRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var configuredInterval = State.MiningInterval.Value; // Should be 4000
    
    // Progress through first round normally
    await ProduceNormalBlocks(initialRound);
    
    // Malicious miner produces extra block with manipulated next round
    var maliciousMiner = InitialCoreDataCenterKeyPairs[0];
    KeyPairProvider.SetKeyPair(maliciousMiner);
    BlockTimeProvider.SetBlockTime(initialRound.GetExtraBlockMiningTime());
    
    // Generate next round with DOUBLED mining interval (8000ms instead of 4000ms)
    var nextRoundData = GenerateManipulatedNextRound(initialRound, 8000);
    var nextRoundInput = new NextRoundInput();
    nextRoundInput.MergeFrom(nextRoundData.ToByteArray());
    nextRoundInput.RandomNumber = await GenerateRandomProofAsync(maliciousMiner);
    
    // Submit manipulated next round - should fail but currently passes
    var result = await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // PASSES!
    
    // Verify: Next round has corrupted interval that will propagate
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var actualInterval = corruptedRound.GetMiningInterval();
    
    // This assertion FAILS - proving the vulnerability
    actualInterval.ShouldBe(configuredInterval); // Expected 4000, Got 8000
}

private Round GenerateManipulatedNextRound(Round currentRound, int maliciousInterval)
{
    currentRound.GenerateNextRoundInformation(
        Context.CurrentBlockTime, 
        BlockchainStartTimestamp, 
        out var nextRound);
    
    // Maliciously modify all ExpectedMiningTime values with new interval
    var baseTime = Context.CurrentBlockTime;
    foreach (var miner in nextRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        miner.ExpectedMiningTime = baseTime.AddMilliseconds(maliciousInterval * miner.Order);
    }
    
    return nextRound; // Internally consistent but wrong interval
}
```

**Notes**

This vulnerability represents a critical consensus invariant violation. The mining interval is intended as an immutable configuration parameter, analogous to block size limits or gas limits in other blockchain systems. Allowing any miner to arbitrarily modify it at runtime fundamentally breaks the consensus timing assumptions that all network participants rely upon.

The root cause is the architectural decision to calculate mining intervals from stored round data rather than validating against the authoritative `State.MiningInterval.Value`. While this approach provides flexibility, it creates a vulnerability where malicious data can corrupt this critical parameter permanently once it enters the state.

The fix is straightforward: add explicit validation that the calculated mining interval from submitted round data matches the configured value. This ensures the immutability guarantee is enforced at validation time, preventing the attack entirely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L28-28)
```csharp
    public ReadonlyState<int> MiningInterval { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L83-83)
```csharp
        State.MiningInterval.Value = input.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-33)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```
