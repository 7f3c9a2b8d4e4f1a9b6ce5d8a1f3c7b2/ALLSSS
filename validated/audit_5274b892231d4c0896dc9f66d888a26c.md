# Audit Report

## Title
Insufficient Order Validation Allows Duplicate Mining Orders to Break Secret Sharing Reconstruction

## Summary
The AEDPoS consensus mechanism contains three interconnected validation failures that allow a malicious miner to create duplicate `FinalOrderOfNextRound` values through crafted `TuneOrderInformation`. These duplicate orders propagate to subsequent rounds and cause the Shamir's Secret Sharing reconstruction to produce incorrect results due to division by zero in Lagrange interpolation, compromising the consensus secret sharing verification mechanism.

## Finding Description

The vulnerability exists due to three interconnected validation failures:

**Root Cause #1 - Flawed Duplicate Detection:**

The `NextRoundMiningOrderValidationProvider` attempts to validate mining order uniqueness but the implementation is incorrect. [1](#0-0) 

The `Distinct()` method operates on `MinerInRound` objects rather than extracting and checking the `FinalOrderOfNextRound` property values themselves. Since each miner has a unique `MinerInRound` instance, the distinctness check always passes regardless of whether the actual `FinalOrderOfNextRound` values are duplicates.

**Root Cause #2 - Unvalidated TuneOrderInformation:**

When processing `UpdateValue`, the contract blindly applies whatever `TuneOrderInformation` is provided without validating uniqueness or range. [2](#0-1) 

A malicious miner can craft an `UpdateValueInput` with duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation` [3](#0-2) , and these will be directly applied to the round state. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`. [4](#0-3) 

Additionally, the validation framework only applies `NextRoundMiningOrderValidationProvider` for `NextRound` behavior, not for `UpdateValue` behavior. [5](#0-4) 

**Root Cause #3 - Missing Duplicate Order Validation in DecodeSecret:**

When a new round is generated, the `FinalOrderOfNextRound` values from the current round become the `Order` values in the next round. [6](#0-5) 

Subsequently, `RevealSharedInValues` extracts order values from the previous round's miner information and passes them to `DecodeSecret`. [7](#0-6) 

The `DecodeSecret` function performs Shamir's Secret Sharing reconstruction using Lagrange interpolation but does not validate that the `orders` parameter contains unique values. [8](#0-7) 

When duplicate orders exist (e.g., `orders[j] == orders[i]` for `j != i`), the denominator calculation `orders[j] - orders[i]` becomes zero. [9](#0-8) 

This zero denominator flows through `MultiplyRational` [10](#0-9) , then `RationalToWhole` calls `Inverse(0)` [11](#0-10) . The `Inverse` function with input 0 returns 0 through the Extended Euclidean Algorithm [12](#0-11) , causing the Lagrange basis polynomial term to evaluate incorrectly, resulting in incorrect secret reconstruction.

**Attack Sequence:**

1. Round N: Malicious miner (who must be in the active miner set) submits `UpdateValue` with duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation`
2. `ProcessUpdateValue` applies these duplicate values without validation
3. Round N+1: When `NextRound` is called, `GenerateNextRoundInformation` sets the `Order` values in the new round based on `FinalOrderOfNextRound` from Round N, creating duplicate `Order` values
4. Round N+1: Miners perform secret sharing with `DecryptedPieces`
5. Round N+2: When `RevealSharedInValues` is called [13](#0-12) , it extracts the duplicate `Order` values and passes them to `DecodeSecret`
6. `DecodeSecret` produces incorrect results due to division by zero, setting wrong `PreviousInValue` hashes

## Impact Explanation

**Consensus Integrity Compromise:**

The secret sharing mechanism is a critical component of AEDPoS consensus designed to reconstruct and verify miners' `PreviousInValue` through Lagrange interpolation. This ensures miners cannot cheat on their random value commitments, which are fundamental to consensus security and random number generation.

When `DecodeSecret` produces incorrect results due to duplicate orders:
- Miners' `PreviousInValue` fields are set to wrong hash values in the current round
- The cryptographic integrity of the random number generation chain is broken
- The consensus validation mechanism for miner behavior becomes unreliable
- Subsequent rounds may fail validation or accept invalid consensus states
- The network may experience consensus disruption requiring manual intervention

**Affected Parties:**
- All consensus participants are affected as the secret sharing verification becomes unreliable
- The entire network's consensus security is degraded when this mechanism fails
- Honest miners may be falsely flagged or malicious behavior may go undetected

**Severity Assessment: Medium**
- Does not directly result in fund theft or unauthorized token minting
- Compromises consensus integrity and random number generation security
- Could enable secondary attacks by breaking miner behavior verification
- May cause consensus disruption but does not permanently halt the chain

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the consensus set (requires winning election through governance)
- No special privileges beyond normal miner capabilities required
- Can craft malicious `UpdateValueInput` with duplicate `TuneOrderInformation` values

**Attack Complexity:**
- Low technical complexity: Simply requires modifying the `TuneOrderInformation` field when calling `UpdateValue`
- No sophisticated cryptographic attacks or precise timing manipulation needed
- Can be executed in a single transaction during the attacker's designated mining slot
- The flawed validation allows the attack to succeed on-chain

**Feasibility Conditions:**
- Requires the attacker to be selected as a miner through the election process
- Secret sharing must be enabled (checked via configuration contract) [14](#0-13) 
- The malicious round must successfully transition through `NextRound` to propagate duplicate orders
- Effects manifest two rounds later when `RevealSharedInValues` is called

**Detection Constraints:**
- The incorrect `PreviousInValue` values would be detectable through off-chain monitoring
- However, the flawed validation allows the attack to succeed on-chain before detection
- May cause observable consensus anomalies that alert network operators

**Likelihood Assessment: Medium**
- Requires compromised miner position, but miners are elected through governance mechanisms
- Easy to execute once in position with low technical barriers
- Detectable through monitoring but may cause temporary disruption before remediation

## Recommendation

Implement three layers of validation to prevent duplicate mining orders:

1. **Fix NextRoundMiningOrderValidationProvider**: Apply `Distinct()` to the `FinalOrderOfNextRound` values themselves, not the `MinerInRound` objects:
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

2. **Validate TuneOrderInformation in ProcessUpdateValue**: Add validation before applying tuned orders to ensure uniqueness and valid range:
```csharp
// Before applying TuneOrderInformation
var tuneOrderValues = updateValueInput.TuneOrderInformation.Values.ToList();
Assert(tuneOrderValues.Distinct().Count() == tuneOrderValues.Count, 
    "Duplicate orders in TuneOrderInformation");
```

3. **Add duplicate check in DecodeSecret or RevealSharedInValues**: Validate order uniqueness before calling `DecodeSecret`:
```csharp
Assert(orders.Distinct().Count() == orders.Count, 
    "Duplicate orders detected in secret sharing reconstruction");
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateOrdersBreakSecretSharing_Test()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = GenerateInitialMiners(7);
    await InitializeConsensus(initialMiners);
    
    // Round 1: Advance to first real round
    await ProduceNormalBlocks(initialMiners);
    
    // Round 2: Malicious miner submits UpdateValue with duplicate orders
    var maliciousMiner = initialMiners[0];
    var updateInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("sig"),
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        // Intentionally set duplicate orders for two miners
        TuneOrderInformation =
        {
            { initialMiners[1].PublicKey.ToHex(), 5 },
            { initialMiners[2].PublicKey.ToHex(), 5 } // Duplicate!
        }
    };
    
    // Execute UpdateValue - should apply duplicates without validation
    await ConsensusStub.UpdateValue.SendAsync(updateInput);
    
    // Round 3: Transition to next round
    await ProduceNextRound();
    
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Verify: Two miners have the same Order value
    var orders = currentRound.RealTimeMinersInformation.Values
        .Select(m => m.Order)
        .ToList();
    var distinctOrders = orders.Distinct().Count();
    
    // This proves the vulnerability: duplicate orders exist
    Assert.True(distinctOrders < orders.Count, 
        "Duplicate orders were created through TuneOrderInformation");
    
    // Round 4: When RevealSharedInValues is called, DecodeSecret will fail
    // with division by zero, producing incorrect PreviousInValue
    await ProduceNextRound();
    
    // The consensus state is now corrupted
}
```

## Notes

This vulnerability represents a critical weakness in the AEDPoS consensus validation framework. While it requires the attacker to be an elected miner (a significant barrier), the attack is trivial to execute once in position and directly compromises the secret sharing mechanism that underpins the consensus random number generation and miner behavior verification.

The three-layer defense approach in the recommendation ensures redundancy: even if one validation layer fails, the others will catch the attack. The most critical fix is #1 (correcting the `Distinct()` usage) as it addresses the root cause in the validation provider that should catch this during `NextRound` transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-92)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L67-70)
```csharp
        private static BigInteger RationalToWhole(BigInteger numerator, BigInteger denominator)
        {
            return numerator * Inverse(denominator) % SecretSharingConsts.FieldPrime;
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L93-96)
```csharp
        private static BigInteger Inverse(BigInteger integer)
        {
            return GetGreatestCommonDivisor2(SecretSharingConsts.FieldPrime, integer).invB.Abs();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L98-106)
```csharp
        private static (BigInteger numerator, BigInteger denominator) MultiplyRational(
            BigInteger numeratorLhs, BigInteger denominatorLhs,
            BigInteger numeratorRhs, BigInteger denominatorRhs)
        {
            var numerator = numeratorLhs * numeratorRhs % SecretSharingConsts.FieldPrime;
            var denominator = denominatorLhs * denominatorRhs % SecretSharingConsts.FieldPrime;
            var gcd = GetGreatestCommonDivisor(numerator, denominator);
            return (numerator / gcd, denominator / gcd);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```
