# Audit Report

## Title
Miners Can Manipulate Mining Order by Providing Arbitrary SupposedOrderOfNextRound Values

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` values from miners without validating they match the signature-based calculation, allowing miners to arbitrarily choose their mining position in subsequent rounds and breaking consensus fairness guarantees.

## Finding Description

The AEDPoS consensus mechanism is designed to calculate each miner's position in the next round based on their cryptographic signature to ensure unpredictability and fairness. The calculation formula exists in `ApplyNormalConsensusData`: [1](#0-0) 

This calculation only occurs when `GetConsensusBlockExtraData` (a view function) calls `ApplyNormalConsensusData`: [2](#0-1) 

The critical vulnerability is in `ProcessUpdateValue`, which directly assigns the `SupposedOrderOfNextRound` value from the transaction input without any recalculation or validation: [3](#0-2) 

The validation phase only checks that `OutValue` and `Signature` are non-null and validates the `PreviousInValue` hash relationship, but completely omits validation of `SupposedOrderOfNextRound`: [4](#0-3)  and [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` that could validate mining orders is only applied for `NextRound` behavior, not for `UpdateValue`: [6](#0-5) 

This validator only checks counts, not individual value correctness: [7](#0-6) 

The manipulated `SupposedOrderOfNextRound` becomes `FinalOrderOfNextRound` and is used by `GenerateNextRoundInformation` to determine mining positions: [8](#0-7) 

## Impact Explanation

This vulnerability fundamentally breaks the fairness and unpredictability guarantees of the AEDPoS consensus mechanism:

1. **Consensus Manipulation**: A malicious miner can consistently position themselves first in mining order, giving them priority access to block production and extra block rewards.

2. **Economic Advantage**: The first miner produces extra blocks if subsequent miners are offline or late, earning disproportionate rewards. They also have priority in transaction inclusion and potential MEV extraction.

3. **Random Number Influence**: Mining order affects the sequence of random number generation in the consensus mechanism, potentially enabling manipulation of consensus randomness for other protocol operations.

4. **Systemic Risk**: If multiple colluding miners exploit this, they could coordinate their positions to dominate consensus, destabilize round transitions, or create predictable mining patterns that undermine the security model.

The impact is **CRITICAL** because it breaks a core invariant: that mining order must be cryptographically unpredictable and derived from signatures, not arbitrarily chosen by miners.

## Likelihood Explanation

The attack is **HIGHLY LIKELY** with minimal complexity:

**Attacker Capabilities**: Any active miner in the consensus set can execute this attack. The `UpdateValue` method is publicly callable: [9](#0-8) 

**Attack Steps**:
1. Miner calls `GetConsensusBlockExtraData` (view function) to obtain valid `OutValue` and `Signature` values
2. Miner constructs a modified `UpdateValueInput` with valid cryptographic values but replaces `SupposedOrderOfNextRound` with desired value (e.g., 1 for first position)
3. Miner submits this modified transaction, which passes all validation checks since no validator examines `SupposedOrderOfNextRound`
4. The contract accepts the arbitrary order value and uses it for next round generation

**Feasibility**: The attack requires no special conditionsâ€”just normal participation in consensus. The cost is minimal (standard transaction gas), while the benefit is continuous preferential mining positions and increased block rewards.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that the provided `SupposedOrderOfNextRound` matches the signature-based calculation:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var signature = minerInRound.Signature;
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}
```

And call this validation in `ValidateHeaderInformation` before returning success.

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateMiningOrder()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Attacker miner gets valid consensus data
    var attackerPubkey = miners[2]; // Middle position miner
    var consensusData = await ConsensusContract.GetConsensusBlockExtraData.CallAsync(
        new BytesValue { Value = CreateTriggerInformation(attackerPubkey) });
    
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusData.Value);
    var attackerInfo = headerInfo.Round.RealTimeMinersInformation[attackerPubkey.ToHex()];
    
    // Verify attacker would normally get a middle position (e.g., 3)
    var originalOrder = attackerInfo.SupposedOrderOfNextRound;
    originalOrder.ShouldBe(3);
    
    // Attack: Modify SupposedOrderOfNextRound to 1 (first position)
    var maliciousInput = new UpdateValueInput
    {
        OutValue = attackerInfo.OutValue,
        Signature = attackerInfo.Signature,
        PreviousInValue = attackerInfo.PreviousInValue,
        SupposedOrderOfNextRound = 1, // Manipulated value
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        RoundId = headerInfo.Round.RoundId
    };
    
    // Submit malicious transaction
    await ConsensusContract.UpdateValue.SendAsync(maliciousInput);
    
    // Verify attack succeeded: attacker now has order 1 for next round
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var updatedInfo = currentRound.RealTimeMinersInformation[attackerPubkey.ToHex()];
    
    updatedInfo.FinalOrderOfNextRound.ShouldBe(1); // Attack successful!
    
    // Generate next round to confirm attacker mines first
    await TriggerNextRound();
    var nextRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var nextRoundInfo = nextRound.RealTimeMinersInformation[attackerPubkey.ToHex()];
    
    nextRoundInfo.Order.ShouldBe(1); // Attacker is now first miner
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L13-17)
```csharp
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
