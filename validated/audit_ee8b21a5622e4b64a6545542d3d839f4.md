# Audit Report

## Title
Missing Miner List Validation in NextRound Transitions Allows Consensus Disruption via Inflated Miner Count

## Summary
The AEDPoS consensus validation logic fails to verify that the miner list in a provided NextRound matches the current round's authorized miners. A malicious miner can inject fake entries into the next round's `RealTimeMinersInformation` dictionary, causing consensus disruption through inflated miner counts, incorrect order assignments, and persistent operational degradation.

## Finding Description

**Root Cause - Missing Miner Set Validation:**

When validating a NextRound consensus block, the system performs multiple consistency checks but critically fails to verify that the provided round's miner list matches the trusted base round's miner list.

The validation flow for NextRound behavior applies these providers: [1](#0-0) 

The `NextRoundMiningOrderValidationProvider` only checks internal consistency by verifying that miners with `FinalOrderOfNextRound > 0` equals miners with `OutValue != null`. For a freshly generated next round where all fields are null/zero, this check trivially passes as `0 == 0`: [2](#0-1) 

The `RoundTerminateValidationProvider` only validates that the round number increments correctly and that all `InValue` fields are null, which fake miners with default values would also satisfy: [3](#0-2) 

The `MiningPermissionValidationProvider` only checks that the **sender** is in the base round's miner list, not that the entire provided round's miner set is valid: [4](#0-3) 

**Critical Gap:** The validation context provides both `BaseRound` (trusted state) and `ProvidedRound` (from block header): [5](#0-4) 

However, no validator performs a membership check comparing `ProvidedRound.RealTimeMinersInformation.Keys` against `BaseRound.RealTimeMinersInformation.Keys`.

**Exploitation Path:**

1. A malicious miner generates a legitimate next round via the contract method: [6](#0-5) 

2. Before including the round in their block, the attacker modifies the `RealTimeMinersInformation` dictionary to add fake miner entries with default field values

3. The corrupted round passes all validation checks enumerated above

4. The corrupted round is stored to state: [7](#0-6) 

5. When generating subsequent rounds, the inflated miner count from `RealTimeMinersInformation.Count` is used: [8](#0-7) 

6. All miners (including fake ones) are propagated to the next round and assigned orders/time slots: [9](#0-8) 

7. The inflated count corrupts the deterministic extra block producer calculation: [10](#0-9) 

## Impact Explanation

**Consensus Integrity Breach:**
The inflated `minersCount` directly affects the extra block producer selection algorithm through the modulus operation `GetAbsModulus(sigNum, blockProducerCount) + 1`, causing legitimate miners to receive incorrect assignments.

**Operational Disruption:**
Fake miners are assigned time slots through the round generation logic but cannot produce blocks. Each fake miner represents a guaranteed missed time slot that delays block production and degrades network throughput.

**Persistent Corruption:**
The `GenerateNextRoundInformation` method propagates the entire `RealTimeMinersInformation` dictionary from the current round to the next round. Once injected, fake miners persist through all subsequent NextRound transitions until a NextTerm transition occurs (which rebuilds the miner list from election results).

**Severity:** High - A single malicious miner can persistently disrupt consensus for all validators, degrade block production reliability, and potentially manipulate block producer selection order.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an elected/authorized miner (moderate barrier)
- Must be producing the NextRound transition block (occurs every round for each miner)
- Must modify node software to inject fake miners before block submission (low technical complexity)

**Attack Feasibility:**
The attack requires only adding entries to the `RealTimeMinersInformation` dictionary with default field values before including the round in the block header. The consensus extra data is generated by the contract but included in the block by node software, providing an interception point for modification.

**Detection Difficulty:**
The corrupted state appears valid to all validation logic. Fake miners manifest as persistent missed time slots, which could be attributed to network issues rather than recognized as an attack.

**Probability:** High if any current miner is compromised or malicious, as the validation gap makes the attack straightforward to execute and difficult to detect.

## Recommendation

Add a miner list validation provider for NextRound behavior that verifies the provided round's miner set matches the base round's miner set:

```csharp
public class NextRoundMinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var providedMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        if (baseMiners.Count != providedMiners.Count || !baseMiners.SequenceEqual(providedMiners))
        {
            return new ValidationResult 
            { 
                Message = "NextRound miner list does not match current round's authorized miners." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this validator to the NextRound validation providers list: [1](#0-0) 

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanInjectFakeMinersIntoNextRound()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiners = new[] { "miner1", "miner2", "miner3" };
    var currentRound = GenerateRoundWithMiners(legitimateMiners);
    
    // Malicious miner generates next round normally
    currentRound.GenerateNextRoundInformation(
        Context.CurrentBlockTime, 
        GetBlockchainStartTimestamp(), 
        out var nextRound
    );
    
    // Attack: Inject fake miner entries with default values
    var fakeMiner = "fakeMiner123";
    nextRound.RealTimeMinersInformation[fakeMiner] = new MinerInRound
    {
        Pubkey = fakeMiner,
        Order = legitimateMiners.Length + 1,
        ExpectedMiningTime = nextRound.GetExpectedMiningTime(legitimateMiners[0])
    };
    
    // Create validation context
    var validationContext = new ConsensusValidationContext
    {
        BaseRound = currentRound,
        ExtraData = new AElfConsensusHeaderInformation
        {
            Round = nextRound,
            Behaviour = AElfConsensusBehaviour.NextRound
        }
    };
    
    // Verify: All current validators pass despite fake miner
    var validators = new List<IHeaderInformationValidationProvider>
    {
        new NextRoundMiningOrderValidationProvider(),
        new RoundTerminateValidationProvider()
    };
    
    foreach (var validator in validators)
    {
        var result = validator.ValidateHeaderInformation(validationContext);
        Assert.True(result.Success); // Validates incorrectly!
    }
    
    // Impact: Fake miner count corrupts subsequent operations
    Assert.Equal(legitimateMiners.Length + 1, nextRound.RealTimeMinersInformation.Count);
    Assert.True(nextRound.RealTimeMinersInformation.ContainsKey(fakeMiner));
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L20-27)
```csharp
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-177)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L18-18)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L119-122)
```csharp
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```
