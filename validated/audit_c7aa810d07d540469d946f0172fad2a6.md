# Audit Report

## Title
NFT Collection ExternalInfo Poisoning Enables Permanent Symbol Squatting and DoS

## Summary
An attacker can create NFT collections with malicious `__nft_create_chain_id` values in the ExternalInfo field, permanently blocking NFT item creation for those collections. Since collection symbols are unique and ExternalInfo cannot be updated post-creation, this enables irrevocable symbol squatting attacks on valuable NFT collection names.

## Finding Description

The vulnerability exists in the NFT collection creation flow where ExternalInfo is accepted without validation, then later enforced during NFT item creation.

**Unvalidated Collection Creation:**

During NFT collection creation, the input ExternalInfo is directly assigned to the token without validation of its keys or values. [1](#0-0) 

The validation method `AssertValidCreateInput` does not check ExternalInfo contents at all. [2](#0-1) 

The constant `NftCreateChainIdExternalInfoKey` is defined as `"__nft_create_chain_id"` and used to restrict NFT creation. [3](#0-2) 

Critically, this key is NOT included in the reserved external info key list that would prevent users from setting it. The reserved list only contains callback and event-related keys. [4](#0-3) 

**Enforced Chain ID Check:**

When creating NFT items, the system retrieves and enforces the `__nft_create_chain_id` value from the collection's ExternalInfo. If an attacker set this to a non-existent chain ID (e.g., 999999), the assertion permanently fails. [5](#0-4) 

**No Recovery Mechanism:**

The only method that can update ExternalInfo post-creation is `ExtendSeedExpirationTime`, which is restricted to updating only the `__seed_exp_time` key for Seed NFTs and cannot modify other keys like `__nft_create_chain_id`. [6](#0-5) 

**Symbol Uniqueness:**

Collection symbols must be unique and cannot be recreated once they exist, as enforced by the case-insensitive token existence check. [7](#0-6) 

## Impact Explanation

**Direct Operational Impact:**
- Permanent DoS of NFT item creation for poisoned collections
- Valuable collection symbols (obtainable via SEED NFTs) can be permanently blocked
- Legitimate projects lose access to their intended collection names
- No recovery mechanism existsâ€”the poisoning is irreversible

**Ecosystem Harm:**
- Symbol squatting enables extortion scenarios
- Griefing attacks can target specific competitors or projects
- Erodes trust in the NFT ecosystem as desirable symbols become permanently unavailable
- Creates artificial scarcity through malicious blocking rather than legitimate use

**Severity: HIGH** - This vulnerability enables permanent, unrecoverable DoS attacks on critical NFT protocol functionality with widespread ecosystem impact.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must acquire a SEED NFT for the target symbol (publicly available mechanism)
- Requires only basic knowledge of the ExternalInfo structure
- No special privileges or insider access needed

**Attack Simplicity:**
- Single transaction: Call `TokenContract.Create` with symbol ending in "-0" and crafted ExternalInfo containing `{"__nft_create_chain_id": "999999"}`
- No timing requirements, race conditions, or complex state manipulation
- Deterministic and repeatable

**Economic Feasibility:**
- Cost: One SEED NFT per collection symbol (limited but achievable)
- Benefit: Permanent control/blocking of valuable collection names
- Strategic value: Block competitors from desirable brand-related symbols

**Detection Difficulty:**
- Attack appears as legitimate collection creation
- Malicious ExternalInfo values are not detectable until NFT item creation is attempted
- No inherent red flags in the transaction

**Likelihood: HIGH** - The attack is straightforward, economically rational for valuable symbols, and has no significant technical barriers.

## Recommendation

Add validation during collection creation to prevent users from setting security-critical ExternalInfo keys:

1. **Create a reserved keys list for NFT collections** that includes `__nft_create_chain_id` alongside existing reserved keys
2. **Add validation in `AssertValidCreateInput` or `CreateToken`** to reject creation attempts that include reserved keys in user-provided ExternalInfo
3. **Alternatively, validate the chain ID value** if present - ensure it matches an actual registered chain ID or is omitted entirely

The fix should prevent users from setting `__nft_create_chain_id` during collection creation, while allowing the system or authorized contracts to set it when needed for legitimate cross-chain NFT scenarios.

## Proof of Concept

```csharp
[Fact(DisplayName = "[MultiToken_NFT] Symbol Squatting via Malicious Chain ID")]
public async Task NFT_Collection_ChainId_Poisoning_Attack_Test()
{
    // Step 1: Attacker creates a SEED NFT for a valuable symbol
    var targetSymbol = "PREMIUM";
    var seedInput = BuildSeedCreateInput(new CreateInput { Symbol = $"{targetSymbol}-" });
    await TokenContractStub.Create.SendAsync(seedInput);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = seedInput.Symbol,
        Amount = 1,
        To = DefaultAddress
    });

    // Step 2: Attacker creates NFT collection with malicious chain ID
    var poisonedCollectionResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = $"{targetSymbol}-0",
        TokenName = "Poisoned Collection",
        TotalSupply = 1000000,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "__nft_create_chain_id", "999999" } // Invalid chain ID
            }
        }
    });
    
    // Collection creation succeeds - no validation blocks this
    poisonedCollectionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 3: Any attempt to create NFT items permanently fails
    var nftCreationResult = await TokenContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        Symbol = $"{targetSymbol}-1",
        TokenName = "NFT Item",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId,
        IsBurnable = true
    });

    // NFT creation fails permanently
    nftCreationResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    nftCreationResult.TransactionResult.Error.ShouldContain("NFT create ChainId must be collection's NFT create chainId");

    // Step 4: Symbol is now permanently blocked - cannot recreate collection
    // The symbol "PREMIUM-0" is permanently registered and unusable
}
```

This test demonstrates that:
1. An attacker can successfully create an NFT collection with an invalid `__nft_create_chain_id` value
2. All subsequent NFT item creation attempts fail permanently with a chain ID mismatch error
3. The collection symbol is permanently occupied and cannot be reused, achieving permanent symbol squatting

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L26-26)
```csharp
    public const string NftCreateChainIdExternalInfoKey = "__nft_create_chain_id";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L22-28)
```csharp
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
```
