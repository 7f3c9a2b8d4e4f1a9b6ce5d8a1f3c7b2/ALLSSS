# Audit Report

## Title
Governance Bypass via Malicious Contract Validation in Method Fee Controller

## Summary
The `ChangeMethodFeeController` function across all ACS1 implementations accepts arbitrary contract addresses without validating they are legitimate governance contracts (Parliament, Association, or Referendum). An attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, then leverage a single approved governance proposal to permanently seize control of the method fee controller, bypassing all future governance requirements.

## Finding Description

The vulnerability exists in the `CheckOrganizationExist` validation function that is called when changing the method fee controller. This function performs a cross-contract call to `ValidateOrganizationExist` on the address provided in `authorityInfo.ContractAddress` without any verification that this address corresponds to a trusted governance contract. [1](#0-0) 

The `ChangeMethodFeeController` function uses this flawed validation mechanism: [2](#0-1) 

While the authorization check requires the sender to be the current controller's owner address, this protection is circumvented during governance proposal execution. When Parliament releases a proposal, it uses `SendVirtualInlineBySystemContract` which sets the inline transaction's `From` address to the organization's virtual address: [3](#0-2) [4](#0-3) 

This means during proposal execution, `Context.Sender` equals the Parliament organization's virtual address, which is also the current `MethodFeeController.Value.OwnerAddress`, thus passing the authorization check. The organization address is calculated using the same virtual address conversion: [5](#0-4) 

The only remaining protection is the `CheckOrganizationExist` validation, which merely verifies that calling `ValidateOrganizationExist` on the provided contract address returns true. Legitimate governance contracts implement `ValidateOrganizationExist` by checking if an organization exists in their state storage: [6](#0-5) 

However, there is no mechanism to ensure the `ContractAddress` field in the `AuthorityInfo` actually points to one of the three legitimate governance contracts. An attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`.

**Attack Execution Path:**
1. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` to always return `true`
2. Attacker creates a Parliament proposal to call `ChangeMethodFeeController` with `AuthorityInfo{OwnerAddress: attacker_address, ContractAddress: malicious_contract_address}`
3. The proposal appears legitimate to reviewers who focus on the `OwnerAddress` field
4. Miners approve the proposal through standard governance
5. Upon release, `Context.Sender` becomes the Parliament organization's virtual address
6. Authorization check passes
7. Organization validation calls the malicious contract which returns `true`
8. Controller is permanently changed to attacker's `AuthorityInfo`
9. Attacker gains permanent control over method fees

This same vulnerability pattern exists in all ACS1 implementations: [7](#0-6) [8](#0-7) [9](#0-8) 

## Impact Explanation

**Critical Governance Bypass:**
- Complete and permanent circumvention of governance controls for method fee management across all system contracts
- Once the initial malicious proposal is approved, the attacker gains irreversible control over the method fee controller
- Attacker can arbitrarily set method fees to zero (destroying fee economics and protocol sustainability) or excessively high values (denial-of-service attack preventing users from transacting)
- Attacker can subsequently change the controller to any address they control, permanently locking out legitimate governance with no recovery mechanism

**Systemic Risk:**
The vulnerability affects ALL ACS1 implementations across the entire protocol infrastructure including: MultiToken, Parliament, Association, Referendum, Consensus, Election, Treasury, Profit, TokenConverter, TokenHolder, Vote, Configuration, Genesis, CrossChain, and Economic contracts.

**Affected Parties:**
- All users paying transaction fees lose protection against arbitrary fee manipulation
- Protocol economics becomes vulnerable to destruction
- Governance participants permanently lose control over method fee configuration
- Chain operators lose ability to adjust fees in response to network conditions
- The entire protocol's fee mechanism can be captured by a single malicious actor

## Likelihood Explanation

**Attack Complexity: Medium**
The attacker must:
1. Deploy a malicious smart contract implementing the `ValidateOrganizationExist` interface (achievable through standard contract deployment process)
2. Craft a governance proposal to change the controller with the malicious `ContractAddress`
3. Obtain proposal approval through legitimate governance (requires miner/organization votes)

**Feasibility: High**
- The proposal can be crafted to appear legitimate by using a real-looking organization address as `OwnerAddress`
- Governance reviewers typically scrutinize the `OwnerAddress` but may not examine the `ContractAddress` field or understand its significance
- No on-chain validation exists to prevent this attack - the code blindly trusts any contract address provided
- Once successfully executed, the attack grants permanent control with no reversion mechanism
- The attack requires only a single approved proposal to succeed

**Detection Difficulty: Low**
- The malicious `ContractAddress` is not immediately recognizable during standard proposal review processes
- The vulnerability is only detectable through manual code review of the contract at the proposed `ContractAddress`
- By the time the attack is discovered, the damage is already permanent

## Recommendation

Add validation to ensure the `ContractAddress` in `AuthorityInfo` is one of the three legitimate governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address."
    );
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

This validation should be applied to all `CheckOrganizationExist` implementations across all system contracts implementing ACS1.

## Proof of Concept

The test would involve:
1. Deploy a malicious contract with `ValidateOrganizationExist` returning `true`
2. Create a Parliament proposal calling `ChangeMethodFeeController` with the malicious contract address
3. Approve and release the proposal
4. Verify the method fee controller is now controlled by the attacker's address
5. Demonstrate the attacker can call `SetMethodFee` with arbitrary values
6. Demonstrate legitimate governance can no longer change the controller

The vulnerability is confirmed through code analysis showing no validation exists on the `ContractAddress` field, allowing any contract to be specified as long as it returns `true` for `ValidateOrganizationExist`.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L293-312)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress =
            Context.ConvertVirtualAddressToContractAddressWithContractHashName(
                CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));
        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
    }

    private Hash CalculateVirtualHash(Hash organizationHash, Hash creationToken)
    {
        return creationToken == null
            ? organizationHash
            : HashHelper.ConcatAndCompute(organizationHash, creationToken);
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L21-29)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-382)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```
