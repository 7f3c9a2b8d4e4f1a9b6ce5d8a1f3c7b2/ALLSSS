# Audit Report

## Title
Missing Access Control and Input Validation in EnableConnector Allows Connector State Corruption and Permanent Denial of Service

## Summary
The `EnableConnector` function lacks authorization checks and accepts negative `AmountToTokenConvert` values, enabling any address to corrupt connector reserve balances through arithmetic manipulation. This results in permanent protocol dysfunction where all buy and sell operations for the affected token pair become inoperative.

## Finding Description

The vulnerability stems from two critical flaws in the TokenConverter contract's `EnableConnector` function:

**Flaw 1: Missing Authorization**
The `EnableConnector` function has no access control check [1](#0-0) , unlike other administrative functions which enforce `AssertPerformedByConnectorController()` [2](#0-1) . This is confirmed by test behavior where `EnableConnector` is called directly without governance approval [3](#0-2) .

**Flaw 2: Arithmetic Manipulation via Negative Input**
The `AmountToTokenConvert` field is defined as `int64` [4](#0-3) , allowing negative values. In `GetNeededDeposit`, the calculation lacks validation [5](#0-4) . When a negative value is provided (e.g., -100), the subtraction becomes addition: `TotalSupply - balance - (-100) = TotalSupply - balance + 100`, artificially inflating `amountOutOfTokenConvert`.

**Attack Execution Flow:**
1. Attacker calls `EnableConnector` with negative `AmountToTokenConvert`
2. `GetNeededDeposit` calculates inflated deposit requirement due to arithmetic manipulation [6](#0-5) 
3. Contract transfers inflated base tokens from attacker [7](#0-6) 
4. Resource token transfer is skipped due to negative value check [8](#0-7) 
5. `DepositBalance` is set to inflated amount despite mismatched reserves [9](#0-8) 
6. Both connectors are enabled with corrupted state [10](#0-9) 

## Impact Explanation

**Permanent State Corruption:** The `GetSelfBalance` helper uses `DepositBalance` for deposit connectors [11](#0-10) , meaning all Bancor pricing calculations will use the inflated, incorrect reserve amount instead of actual token holdings.

**Denial of Service on Buy Operations:** When users attempt to buy resource tokens, the Buy function will calculate prices based on corrupted reserves and attempt to transfer tokens the contract doesn't possess [12](#0-11) , causing transaction failures.

**Denial of Service on Sell Operations:** The Bancor formula requires positive connector balances [13](#0-12) . With mismatched reserves, sell operations will either fail validation or produce incorrect pricing, rendering the connector unusable.

**Irreversible Protocol Damage:** Once `DepositBalance` is corrupted and connectors are enabled, there is no administrative function to recalculate or reset these values. The `UpdateConnector` function explicitly prevents updates after activation [14](#0-13) , making the corruption permanent.

## Likelihood Explanation

**No Access Control:** The vulnerability is directly exploitable because `EnableConnector` lacks the authorization check present in all other administrative functions. Any address can invoke this function.

**Trivial Attack Vector:** An attacker only needs to call `EnableConnector` with a negative `AmountToTokenConvert` value and sufficient base tokens to cover the inflated deposit. No complex preconditions or privileged access is required.

**Normal Operational State:** The attack requires only that a connector pair exists (added through governance) but is not yet enabledâ€”a standard state during new token launch preparation phases.

**Silent Failure:** The malicious transaction executes successfully without reverting. The state corruption only manifests when legitimate users attempt to trade, making detection difficult until damage is done.

## Recommendation

**Fix 1: Add Authorization Check**
Add `AssertPerformedByConnectorController()` at the start of the `EnableConnector` function:
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController(); // ADD THIS LINE
    var fromConnector = State.Connectors[input.TokenSymbol];
    // ... rest of function
}
```

**Fix 2: Validate Non-Negative Input**
Add validation in `GetNeededDeposit`:
```csharp
public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
{
    Assert(input.AmountToTokenConvert >= 0, "AmountToTokenConvert must be non-negative.");
    // ... rest of function
}
```

**Fix 3: Add Input Validation in EnableConnector**
Add explicit check:
```csharp
Assert(input.AmountToTokenConvert >= 0, "AmountToTokenConvert must be non-negative.");
```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_NegativeAmount_CorruptsState()
{
    // Setup: Add connector pair
    var tokenSymbol = "VULN";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 1000_0000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // Attack: Call EnableConnector with negative AmountToTokenConvert
    var maliciousInput = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = -500_0000 // NEGATIVE VALUE
    };
    
    // Get deposit requirement (will be inflated due to arithmetic bug)
    var deposit = await DefaultStub.GetNeededDeposit.CallAsync(maliciousInput);
    deposit.AmountOutOfTokenConvert.ShouldBeGreaterThan(1000_0000); // Inflated!
    
    // Enable connector with corrupted state
    await DefaultStub.EnableConnector.SendAsync(maliciousInput);
    
    // Verify corruption: DepositBalance is inflated but actual reserves are mismatched
    var depositBalance = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    var actualContractBalance = await GetBalanceAsync(tokenSymbol, TokenConverterContractAddress);
    
    // Contract has fewer tokens than DepositBalance claims
    actualContractBalance.ShouldBeLessThan(depositBalance.Value);
    
    // Attempt buy - will fail due to insufficient actual reserves
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 1000
    });
    buyResult.TransactionResult.Error.ShouldContain("Insufficient"); // DoS confirmed
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L143-149)
```csharp
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L377-399)
```csharp
    public async Task EnableConnector_Success_Test()
    {
        await DefaultStub.Initialize.SendAsync(new InitializeInput
        {
            FeeRate = "0.005"
        });
        var tokenSymbol = "NETT";
        await CreateTokenAsync(tokenSymbol);
        await AddPairConnectorAsync(tokenSymbol);
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Amount = 99_9999_0000,
            To = DefaultSender,
            Symbol = tokenSymbol
        });
        var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 99_9999_0000
        };
        var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
        deposit.NeedAmount.ShouldBe(100);
        await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
```

**File:** protobuf/token_converter_contract.proto (L179-184)
```text
message ToBeConnectedTokenInfo{
    // The token symbol.
    string token_symbol = 1;
    // Specifies the number of tokens to convert to the TokenConvert contract.
    int64 amount_to_token_convert = 2;
}
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```
