# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTermInput Allows Reward Manipulation

## Summary
The AEDPoS consensus contract fails to validate the `ExtraBlockProducerOfPreviousRound` field during term transitions, allowing a malicious miner producing a NextTerm block to grant arbitrary miners extra tiny block production privileges before the round starts, thereby inflating their `ProducedBlocks` count and manipulating reward distribution.

## Finding Description

The vulnerability exists across multiple consensus validation layers that collectively fail to ensure the integrity of the `ExtraBlockProducerOfPreviousRound` field during term transitions.

**Lack of Validation in Data Flow:**

The `NextTermInput.Create()` method blindly copies `ExtraBlockProducerOfPreviousRound` from the input Round without any validation that it matches the actual block producer's pubkey. [1](#0-0) 

The `RoundTerminateValidationProvider` validation for NextTerm transitions only validates round number increment, term number increment, and that InValues are null - it completely omits validation of `ExtraBlockProducerOfPreviousRound`. [2](#0-1) 

The validation provider setup for NextTerm behavior only includes basic validators (MiningPermission, TimeSlot, ContinuousBlocks) and RoundTerminateValidationProvider, with no validator checking the `ExtraBlockProducerOfPreviousRound` field. [3](#0-2) 

**Field Excluded from Integrity Checks:**

The `GetCheckableRound()` method used for hash-based validation only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`, explicitly excluding `ExtraBlockProducerOfPreviousRound`. [4](#0-3) 

**Field Grants Special Mining Privileges:**

When `ExtraBlockProducerOfPreviousRound` matches a miner's pubkey and the current time is before the round start time, that miner is granted permission to produce tiny blocks, bypassing normal time slot restrictions. [5](#0-4) 

**ProducedBlocks Counter Manipulation:**

Each tiny block produced increments the miner's `ProducedBlocks` count. [6](#0-5) 

**Expected vs Actual Value Gap:**

While `GenerateFirstRoundOfNextTerm()` correctly sets `ExtraBlockProducerOfPreviousRound` to the sender's pubkey, there is no enforcement that the actual NextTermInput received matches this expected value. [7](#0-6) [8](#0-7) 

**Manipulated Data Persisted:**

The `ProcessNextTerm` method converts the input to a Round object and stores it without validating `ExtraBlockProducerOfPreviousRound`, allowing the manipulated value to be persisted. [9](#0-8) [10](#0-9) 

**ProducedBlocks Affects Rewards:**

The total mined blocks (sum of all miners' `ProducedBlocks`) is used to calculate mining rewards donated to Treasury. [11](#0-10) 

Individual `ProducedBlocks` counts are reported to the Election contract where they influence reward distribution, reputation, and voting weights. [12](#0-11) 

## Impact Explanation

This vulnerability enables direct manipulation of the consensus reward system through the following attack chain:

1. **Privilege Grant**: A malicious miner producing a NextTerm block modifies `ExtraBlockProducerOfPreviousRound` to any miner's pubkey in the new term's miner list (including themselves or a colluding party)

2. **Extra Mining Window**: The beneficiary miner gains the ability to produce tiny blocks before the round officially starts - a privilege they should not have

3. **Inflated Block Count**: Each tiny block produced during this illegitimate window increments the beneficiary's `ProducedBlocks` counter, artificially inflating their mining contribution

4. **Reward Misallocation**: The inflated `ProducedBlocks` count directly affects:
   - Total mining rewards calculated for Treasury donation
   - Individual miner statistics reported to Election contract
   - Proportional reward distribution based on mining contribution
   - Miner reputation and governance voting weight

This breaks the fundamental consensus guarantee that mining rewards should reflect actual work performed. Honest miners receive proportionally reduced rewards while the attacker or their colluding party gains unfair advantage in both immediate rewards and long-term governance influence.

## Likelihood Explanation

**Attack Prerequisites:**
The attacker must be selected to produce the NextTerm block, which is a standard consensus role that rotates among miners during term transitions - not an exceptional privilege but a regular operational occurrence.

**Execution Steps:**
1. Attacker's turn to produce NextTerm block arrives
2. Attacker calls `GetConsensusExtraData` which returns properly formatted Round data with `ExtraBlockProducerOfPreviousRound` set to their pubkey
3. Before signing the block, attacker modifies `ExtraBlockProducerOfPreviousRound` field to target miner's pubkey
4. Modified block passes all validation layers - none check this specific field
5. `ProcessNextTerm` executes, storing manipulated Round to state
6. Target miner exploits extra mining privileges, producing additional tiny blocks before round starts

**Detection Difficulty:**
The manipulation is virtually undetectable because:
- Validation doesn't regenerate expected Round data to compare against submitted data
- The field is explicitly excluded from hash-based integrity checks
- Block appears valid to all consensus validators
- No on-chain evidence exists of the expected vs. actual value

**Economic Rationality:**
- **Cost**: Negligible (single field modification before block signing)
- **Benefit**: Direct increase in mining rewards and governance influence
- **Risk**: Low detection probability due to validation gaps
- **Frequency**: Every term transition provides an attack opportunity

The attack is highly feasible with low barriers to execution and significant economic incentives.

## Recommendation

Add validation in `RoundTerminateValidationProvider.ValidationForNextTerm()` to verify that `ExtraBlockProducerOfPreviousRound` matches the sender's pubkey:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate ExtraBlockProducerOfPreviousRound matches sender
    var senderPubkey = extraData.SenderPubkey.ToHex();
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != senderPubkey)
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match sender pubkey." };

    return new ValidationResult { Success = true };
}
```

Alternatively, include `ExtraBlockProducerOfPreviousRound` in the `GetCheckableRound()` method to ensure it's covered by hash-based validation.

## Proof of Concept

Due to the complexity of setting up a full AEDPoS consensus test environment with term transitions, a complete executable PoC would require substantial test infrastructure. However, the vulnerability can be demonstrated by:

1. Monitoring NextTerm blocks on a live network
2. Checking if `ExtraBlockProducerOfPreviousRound` always equals the block producer's pubkey
3. Observing that validation does not reject blocks where these values differ

The code analysis clearly shows the validation gap exists and the field affects mining privileges and rewards as described.

## Notes

**Scope Limitations:**
The beneficiary miner must be in the new term's miner list for the attack to work (otherwise `CurrentRound.RealTimeMinersInformation[_pubkey]` would throw). However, with typical miner set sizes (e.g., 21 miners), this still provides significant attack surface.

**Additional Attack Vector:**
The same validation gap exists in `NextRoundInput` for round transitions within a term, though the impact window is smaller (between rounds vs. between terms).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L249-256)
```csharp
        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-50)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
