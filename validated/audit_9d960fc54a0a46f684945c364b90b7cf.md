# Audit Report

## Title
Banned Candidates Can Become Miners Through Incomplete Duplicate Prevention in Snapshot Processing

## Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function contains a critical flaw in its duplicate prevention logic that allows banned candidates to remain in election snapshots when multiple banned pubkeys resolve to the same replacement pubkey. These banned candidates can subsequently become active miners through the consensus contract's miner replacement mechanism, directly violating the protocol's security guarantee that banned/evil nodes cannot participate in consensus.

## Finding Description

The vulnerability exists in the snapshot processing logic where the Election Contract attempts to replace banned candidates with their newest pubkeys through replacement chains.

**The Core Bug:**

In `GetPreviousTermSnapshotWithNewestPubkey()`, when processing banned candidates that map to the same newest pubkey (e.g., replacement chain A→B→C where both A and B are banned), the duplicate prevention check causes incomplete removal: [1](#0-0) 

When processing the first banned candidate (A):
- `GetNewestPubkey(A)` returns C
- Check `snapshot.ElectionResult.ContainsKey(C)` returns false
- C is added with A's votes
- A is removed from the snapshot

When processing the second banned candidate (B):
- `GetNewestPubkey(B)` also returns C  
- Check `snapshot.ElectionResult.ContainsKey(C)` returns **true** (C was just added)
- Execution hits `continue` statement at line 154
- **The removal at line 157 is skipped - B remains in the snapshot despite being banned**

**Replacement Chain Mechanism:**

The replacement chain is established through `PerformReplacement` which maintains the mapping structure: [2](#0-1) 

When candidates are replaced, they are marked as banned: [3](#0-2) 

The `GetNewestPubkey` helper correctly resolves replacement chains: [4](#0-3) 

**Missing Protection in Alternative Candidate Selection:**

The `GetMinerReplacementInformation` method retrieves the processed snapshot but does not filter banned candidates when selecting alternatives from the election result: [5](#0-4) 

Note that lines 370-374 filter out initial miners and current miners, but there is **no banned status check** (no `.Where(k => !State.BannedPubkeyMap[k])` filter). This protection only exists when adding initial miners as fallbacks at line 389.

**Consensus Contract Integration:**

The consensus contract directly uses these alternative candidates without any banned status validation: [6](#0-5) 

The alternative candidate (which could be banned pubkey B) is directly added to the current round's miner information and will participate in block production.

**Banned Status Check Exists But Not Used:**

The `IsPubkeyBanned` method exists and correctly checks banned status: [7](#0-6) 

However, this check is never invoked in the snapshot processing path (line 145 of ViewMethods.cs) or in the alternative candidate selection logic.

## Impact Explanation

This vulnerability allows banned candidates—explicitly marked as evil nodes through `UpdateCandidateInformation` with `IsEvilNode=true`—to become active miners and participate in block production: [8](#0-7) 

**Consensus Security Breach:** Candidates banned for malicious behavior can regain miner status through the alternative candidate mechanism and continue producing blocks, potentially attacking the network or refusing to include valid transactions.

**Reward Misallocation:** Banned candidates receive mining rewards they are not entitled to, directly stealing value from legitimate miners and diluting the reward pool.

**Protocol Integrity Violation:** This completely undermines the fundamental security mechanism (`BannedPubkeyMap`) designed to permanently remove compromised or misbehaving nodes from the active miner set. The consensus contract assumes that alternative candidates provided by the Election Contract are valid and authorized.

## Likelihood Explanation

This vulnerability has **Medium-to-High** likelihood:

**Attack Complexity:** Low. Replacement chains occur naturally during normal operations when candidates rotate keys for security or administrative purposes. No special setup or timing is required.

**Preconditions:**
1. Multiple candidates exist in the same replacement chain (common during key rotation by organizations managing multiple nodes)
2. A snapshot is taken before replacements occur (happens automatically each term via `TakeSnapshot`)
3. Evil miner detection or replacement mechanism triggers (part of normal consensus operation)

**Attacker Capabilities:** Minimal. Any candidate admin can call the public `ReplaceCandidatePubkey` method: [9](#0-8) 

**Economic Rationale:** Cost is minimal (standard transaction fees for key rotation), while potential gains include substantial mining rewards and ability to influence consensus decisions. A malicious node operator could intentionally create replacement chains to exploit this vulnerability.

**Unintentional Triggering:** The vulnerability is particularly concerning because it can be triggered unintentionally through legitimate operational practices (key rotation), meaning the security breach can occur without any malicious intent.

## Recommendation

Add a banned status check when filtering snapshot candidates for alternative miner selection. Modify the `GetMinerReplacementInformation` method:

```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    // Except initial miners.
    .Where(cs =>
        !State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    // Except current miners.
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    // ADD THIS: Except banned candidates
    .Where(cs => !State.BannedPubkeyMap[cs.Key])
    .OrderByDescending(s => s.Value).ToList();
```

Additionally, consider fixing the root cause in `GetPreviousTermSnapshotWithNewestPubkey()` by removing the banned candidate BEFORE checking if the newest pubkey already exists:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    // Remove banned candidate first
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) 
        snapshot.ElectionResult.Remove(bannedCandidate);
    
    // Then add newest pubkey if not already present
    if (newestPubkey == null || newestPubkey == bannedCandidate ||
        snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
    
    var electionResult = snapshot.ElectionResult[bannedCandidate]; // This would now be 0, needs to be saved before removal
    snapshot.ElectionResult.Add(newestPubkey, electionResult);
}
```

Better approach - save votes before removal:
```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    var votes = snapshot.ElectionResult[bannedCandidate];
    
    // Always remove banned candidate
    snapshot.ElectionResult.Remove(bannedCandidate);
    
    // Add to newest pubkey only if valid and not duplicate
    if (newestPubkey != null && newestPubkey != bannedCandidate &&
        !snapshot.ElectionResult.ContainsKey(newestPubkey))
    {
        snapshot.ElectionResult.Add(newestPubkey, votes);
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BannedCandidatesCanBecomeMinersThroughIncompleteSnapshotProcessing()
{
    // Setup: Create three candidates A, B, C
    var candidateA = ValidationDataCenterKeyPairs[0];
    var candidateB = ValidationDataCenterKeyPairs[1];
    var candidateC = ValidationDataCenterKeyPairs[2];
    var adminKeyPair = ValidationDataCenterKeyPairs.Last();
    var admin = Address.FromPublicKey(adminKeyPair.PublicKey);
    
    // Announce A and B as candidates
    await AnnounceElectionAsync(candidateA, admin);
    await AnnounceElectionAsync(candidateB, admin);
    
    // Vote for both to get them in the snapshot
    await VoteToCandidate(BootMinerKeyPair, candidateA.PublicKey.ToHex(), 100_00000000);
    await VoteToCandidate(BootMinerKeyPair, candidateB.PublicKey.ToHex(), 100_00000000);
    
    // Take snapshot (happens automatically during term transition)
    await NextTerm(BootMinerKeyPair);
    
    // Create replacement chain: A->C (A becomes banned)
    var adminStub = GetElectionContractTester(adminKeyPair);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = candidateA.PublicKey.ToHex(),
        NewPubkey = candidateC.PublicKey.ToHex()
    });
    
    // Create replacement chain: B->C (B becomes banned, both A and B resolve to C)
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = candidateB.PublicKey.ToHex(),
        NewPubkey = candidateC.PublicKey.ToHex()
    });
    
    // Verify both A and B are banned
    var bannedA = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = candidateA.PublicKey.ToHex() });
    var bannedB = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = candidateB.PublicKey.ToHex() });
    bannedA.Value.ShouldBeTrue();
    bannedB.Value.ShouldBeTrue();
    
    // Get the processed snapshot
    var snapshot = await ElectionContractStub.GetPreviousTermSnapshotWithNewestPubkey.CallAsync(new Empty());
    
    // BUG: B remains in snapshot despite being banned!
    snapshot.ElectionResult.Keys.ShouldContain(candidateB.PublicKey.ToHex());
    
    // Get alternative candidates for miner replacement
    var minerReplacement = await ElectionContractStub.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput
        {
            CurrentMinerList = { InitialCoreDataCenterKeyPairs.Select(k => k.PublicKey.ToHex()) }
        });
    
    // VULNERABILITY: Banned candidate B can be selected as alternative miner
    minerReplacement.AlternativeCandidatePubkeys.ShouldContain(candidateB.PublicKey.ToHex());
}
```

## Notes

This vulnerability represents a critical consensus security failure where the Election Contract's snapshot processing inadvertently allows banned candidates to bypass the security mechanism designed to exclude them from mining. The issue stems from an implementation oversight where duplicate prevention logic interferes with banned candidate removal, creating a pathway for malicious or compromised nodes to regain mining privileges. The defense-in-depth principle is violated as neither the Election Contract nor the Consensus Contract validates banned status before promoting alternative candidates to active miners.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-338)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```
