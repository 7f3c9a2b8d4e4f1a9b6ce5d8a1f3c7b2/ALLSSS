# Audit Report

## Title
Consensus Order Manipulation via Selective PreviousInValue Disclosure

## Summary
Miners can manipulate their block production order in subsequent rounds by strategically choosing whether to reveal their `previousInValue` or withhold it. Since the signature used for order calculation depends on this value and is never recalculated after secret sharing recovery, miners can pre-compute both scenarios offline and select the more favorable mining position.

## Finding Description

The vulnerability exists in the AEDPoS consensus mechanism where miners can influence their position in future rounds through selective disclosure of their `previousInValue`.

**Vulnerable Flow:**

When a miner produces a block via `UpdateValue` behavior, the consensus extra data generation initializes `previousInValue` to `Hash.Empty`: [1](#0-0) 

If the miner does not provide a valid `previousInValue`, the contract generates a synthetic fallback value based on the miner's public key and current block height: [2](#0-1) 

The signature is calculated using either the provided `previousInValue` or the synthetic fallback, which XORs it with all previous round signatures: [3](#0-2) 

This signature directly determines the miner's order in the next round through modulo arithmetic: [4](#0-3) 

**Critical Failure Points:**

1. **Validation explicitly permits Hash.Empty**: [5](#0-4) 

2. **Protocol acknowledges miners can withhold values** - The code explicitly states this is permissible: [6](#0-5) 

3. **Signature never recalculated after recovery** - While secret sharing can recover `previousInValue` later, it only updates the `PreviousInValue` field but never recalculates the signature that was already stored: [7](#0-6) 

The signature is locked in during `ApplyNormalConsensusData`: [8](#0-7) 

4. **Miners control trigger information** - The node-side code retrieves `previousInValue` from a cache that miners control: [9](#0-8) 

The cache returns `Hash.Empty` if the value is not found: [10](#0-9) 

**Attack Execution:**

A miner in Round N+1 can:
1. Know their secret `previousInValue` X from Round N
2. Read all public signatures from the previous round (publicly available on-chain data)
3. Pre-compute offline: `SignatureA = CalculateSignature(actualPreviousInValue)` → Order A
4. Pre-compute offline: `SignatureB = CalculateSignature(Hash(pubkey + expectedHeight))` → Order B
5. Modify their node's `IInValueCache` to return either the actual value or `Hash.Empty` based on which order is more favorable
6. Execute the chosen path, and the contract will calculate the signature accordingly

The mining order for the next round is then determined based on the `FinalOrderOfNextRound` value: [11](#0-10) 

## Impact Explanation

**Consensus Integrity Compromise:**
This vulnerability fundamentally breaks the unpredictability guarantee of the AEDPoS consensus mechanism. The mining order is designed to be cryptographically random based on secret values that are revealed sequentially. By allowing miners to choose between revealing or withholding their `previousInValue`, the protocol enables strategic position manipulation that undermines fair consensus participation.

**Economic Advantage:**
Block production order directly correlates with mining rewards:
- Earlier positions in the mining schedule have priority in producing blocks
- Miners with better positions can maximize their block production and associated rewards
- The advantage compounds over time as the same miner can repeatedly choose favorable positions
- This creates an unfair competitive advantage over honest miners who always reveal their values

**Cumulative & Undetectable:**
The attack can be executed every round without detection since:
- Both code paths (revealing vs. withholding) are explicitly permitted by validation logic
- No on-chain metric can differentiate intentional manipulation from legitimate edge cases
- The protocol comment explicitly states "It is permissible for miners not publish their in values"
- Transaction structure remains identical regardless of the path chosen

**Affected Parties:**
- Honest miners face unfair competition and reduced rewards
- Network decentralization degrades as manipulating miners gain disproportionate influence
- Users may face censorship if manipulators dominate transaction ordering

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active consensus miner (requires staking and election, which is the target role)
- Access to previous round state data (publicly available on-chain)
- Basic computational capability to perform XOR and modulo operations

**Attack Complexity: LOW**
The attack requires minimal sophistication:
1. Query on-chain round state for previous signatures
2. Locally compute two possible signatures with different `previousInValue` inputs
3. Compare resulting order positions
4. Modify node's `InValueCache` implementation to return preferred value

**Feasibility: HIGH**
All preconditions are satisfied:
- Entry point is the standard `UpdateValue` consensus method
- No special permissions beyond being an elected miner
- No economic cost or penalty for withholding values
- Both code paths are explicitly valid per contract logic
- Miners control their own node implementations

**Detection: IMPOSSIBLE**
The attack is indistinguishable from legitimate behavior since the protocol explicitly allows miners to not publish their in-values, and `Hash.Empty` is a valid input.

## Recommendation

1. **Recalculate signatures after secret sharing recovery**: When secret sharing successfully recovers a miner's actual `previousInValue`, recalculate their signature and `FinalOrderOfNextRound` to match what it should have been with the correct value.

2. **Add validation to detect manipulation**: Compare the signature calculated from the recovered `previousInValue` with the originally submitted signature. If they differ significantly, penalize the miner.

3. **Mandatory previousInValue disclosure with penalties**: Require miners to provide their `previousInValue` when producing blocks. Implement slashing for miners who consistently fail to provide valid values.

4. **Use deterministic fallback based on previous round data**: Instead of allowing miners to influence the fake value through timing (block height), use only immutable data from the previous round for fallback signature calculation.

## Proof of Concept

A proof of concept would demonstrate:
1. Miner retrieves previous round signatures from chain state
2. Miner computes: `order1 = (CalculateSignature(actualPreviousInValue).ToInt64() % minersCount) + 1`
3. Miner computes: `order2 = (CalculateSignature(Hash(pubkey + height)).ToInt64() % minersCount) + 1`
4. Miner modifies `InValueCache.GetInValue()` to return `Hash.Empty` if `order2 < order1`, otherwise return actual value
5. Verify the miner receives the better order position in the next round
6. Confirm no penalty or detection occurs despite the manipulation

**Notes:**
- This vulnerability affects the core consensus mechanism's fairness guarantees
- The exploitation is undetectable under current protocol design since both paths are explicitly permitted
- The issue stems from allowing miners control over trigger information while simultaneously using it for unpredictable randomness generation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L70-70)
```csharp
        var previousInValue = Hash.Empty; // Just initial previous in value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-108)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-16)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L56-56)
```csharp
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L31-32)
```csharp
        _inValues.TryGetValue(roundId, out var inValue);
        return inValue ?? Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
