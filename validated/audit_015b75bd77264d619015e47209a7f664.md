# Audit Report

## Title
Unvalidated DecryptedPieces Allow Manipulation of Revealed InValues in Secret Sharing Consensus

## Summary
The AEDPoS consensus contract's secret sharing mechanism lacks cryptographic validation when reconstructing InValues from DecryptedPieces. Malicious miners can provide corrupted decrypted pieces that cause incorrect InValue reconstruction for offline miners, compromising consensus randomness and miner ordering.

## Finding Description

The AEDPoS consensus uses Shamir's Secret Sharing to reveal InValues for miners who fail to produce blocks. However, the protocol does not validate that reconstructed InValues match the original miner's committed OutValues, creating an exploitable vulnerability.

**Vulnerable Flow:**

1. **Unvalidated Collection**: The `ExtractInformationToUpdateConsensus()` method collects DecryptedPieces from round state without cryptographic verification. [1](#0-0) 

2. **Unvalidated Storage**: The `PerformSecretSharing()` method directly stores attacker-provided DecryptedPieces into other miners' records without validation. [2](#0-1) 

3. **Unvalidated Reconstruction**: The `RevealSharedInValues()` method reconstructs InValues using `SecretSharingHelper.DecodeSecret()` but never validates the result against the original miner's OutValue from the previous round. [3](#0-2) 

The critical missing check is: `HashHelper.ComputeFrom(revealedInValue) == previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue`

The `SecretSharingHelper.DecodeSecret` method performs pure mathematical Lagrange interpolation without any cryptographic validation of input correctness. [4](#0-3) 

4. **Usage Without Validation**: The `SupplyCurrentRoundInformation()` method uses these potentially corrupted PreviousInValues to calculate signatures for offline miners. [5](#0-4) 

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` validates self-provided PreviousInValues by checking the hash matches the previous OutValue. [6](#0-5) 

However, this validator is only invoked for UpdateValue transactions when miners provide their own PreviousInValue. It does NOT validate InValues reconstructed via secret sharing during NextRound transitions. [7](#0-6) 

The NextRound validation providers (`NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`) do not validate reconstructed PreviousInValues. [8](#0-7) [9](#0-8) 

## Impact Explanation

**HIGH Severity** - This vulnerability breaks fundamental consensus invariants:

1. **Signature Manipulation**: Corrupted InValues lead to incorrect signature calculations via `previousRound.CalculateSignature(previousInValue)`, which XORs the InValue with all miners' signatures. This pollutes the consensus randomness pool. [10](#0-9) 

2. **Mining Order Manipulation**: Signatures determine `SupposedOrderOfNextRound` through modulus operations, allowing attackers to influence miner scheduling. [11](#0-10) 

3. **Consensus Integrity**: The attack violates the cryptographic chain where each round's InValue must hash to the previous round's OutValue. This breaks the verifiable randomness property essential for fair consensus.

**Affected Components:**
- Offline miners whose InValues are reconstructed
- All participants depending on consensus randomness  
- LIB (Last Irreversible Block) calculations relying on correct round progression

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** - The attack is feasible under realistic conditions:

**Attacker Requirements:**
- Must be an active miner in the current or previous mining set (verified by `PreCheck()`) [12](#0-11) 

- Can call the public `UpdateValue()` method with arbitrary DecryptedPieces [13](#0-12) 

**Preconditions:**
- Target miner must miss their time slot (common due to network issues, downtime, or maintenance)
- Secret sharing must be enabled via configuration [14](#0-13) 

- The reconstruction requires sufficient DecryptedPieces (2/3 threshold), which includes the attacker's corrupted piece [15](#0-14) 

**Attack Complexity:** LOW - Simply provide corrupted byte arrays as DecryptedPieces with no technical barriers since validation is absent.

## Recommendation

Add cryptographic validation in `RevealSharedInValues()` to verify that reconstructed InValues match the original miner's OutValue from the previous round:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Add validation check
var previousOutValue = previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
if (HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount)) != previousOutValue)
{
    Context.LogDebug(() => $"Failed to verify reconstructed InValue for {publicKeyOfAnotherMiner}");
    continue; // Skip this reconstruction
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures the cryptographic chain integrity: `Hash(InValue_round_N) == OutValue_round_N-1`

## Proof of Concept

The vulnerability can be demonstrated by:

1. Having a test miner miss their time slot (set OutValue to null)
2. Having an attacker miner call `UpdateValue()` with corrupted DecryptedPieces in the input
3. During `NextRound`, observing that `RevealSharedInValues()` reconstructs an incorrect InValue using the corrupted pieces
4. Verifying that `SupplyCurrentRoundInformation()` uses this corrupted InValue to calculate an incorrect signature
5. Confirming the corrupted signature affects the `SupposedOrderOfNextRound` calculation

The test would verify that no validation occurs at any step and that the corrupted InValue propagates through to consensus calculations, demonstrating the lack of cryptographic validation in the secret sharing reconstruction process.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-36)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
