# Audit Report

## Title
Pending Proposals from Removed Proposers Can Still Be Executed After Whitelist Changes

## Summary
The governance contracts (Parliament, Association, and Referendum) validate proposer authorization only at proposal creation time, not at release time. This allows proposers who are removed from the whitelist to still execute their previously created proposals, undermining the whitelist security control mechanism.

## Finding Description

The vulnerability exists in the proposal lifecycle across all three governance contracts. When a proposal is created, the system validates that the proposer is authorized via the `AssertIsAuthorizedProposer` function:

- **Parliament**: [1](#0-0) 
- **Association**: [2](#0-1) 
- **Referendum**: [3](#0-2) 

The authorization validation logic checks whitelist membership:

- **Parliament Helper**: [4](#0-3) 
- **Association Helper**: [5](#0-4) 
- **Referendum Helper**: [6](#0-5) 

However, when releasing a proposal, the `Release` function only verifies that the caller is the original proposer, **without re-validating their current authorization status**:

- **Parliament Release**: [7](#0-6) 
- **Association Release**: [8](#0-7) 
- **Referendum Release**: [9](#0-8) 

All three implementations only check `Context.Sender.Equals(proposalInfo.Proposer)` without calling `AssertIsAuthorizedProposer` or checking the current whitelist.

The `ChangeOrganizationProposerWhiteList` function can remove addresses from the whitelist:

- **Parliament**: [10](#0-9) 
- **Association**: [11](#0-10) 
- **Referendum**: [12](#0-11) 

**Attack Scenario:**
1. Authorized proposer creates a proposal (passes `AssertIsAuthorizedProposer` check)
2. Malicious behavior is detected, organization votes to remove proposer from whitelist via `ChangeOrganizationProposerWhiteList`
3. The proposal continues to collect votes from organization members
4. Removed proposer successfully calls `Release()` once approval threshold is reached (only requires `Context.Sender.Equals(proposalInfo.Proposer)`)
5. Proposal executes despite proposer no longer being authorized

**Test Coverage Gap**: Existing tests confirm removed proposers cannot create NEW proposals [13](#0-12)  and [14](#0-13) , but do not test whether they can release OLD proposals.

## Impact Explanation

This is a **HIGH severity** governance security bypass:

1. **Security Control Circumvention**: When a proposer is removed from the whitelist (typically due to malicious behavior, key compromise, or loss of trust), the clear intent is to revoke their governance powers completely. However, the implementation allows them to retain the ability to execute any proposals created while authorized, defeating the purpose of the whitelist control.

2. **Concrete Harm**: Proposals can execute arbitrary contract calls through the organization's virtual address, leading to:
   - Unauthorized fund transfers or token movements
   - Unauthorized contract upgrades or deployments
   - Unauthorized system parameter modifications
   - Unauthorized configuration changes

3. **Scope**: Affects all three governance contract types:
   - Parliament contract (manages core system governance including the default organization)
   - Association contract (multi-signature governance)
   - Referendum contract (token-weighted voting governance)

4. **Time-of-Check-Time-of-Use (TOCTOU) Vulnerability**: Authorization is validated at proposal creation time but not at execution time, creating a critical security gap.

## Likelihood Explanation

**HIGH likelihood** due to:

1. **Low Attack Complexity**: The attack sequence is straightforward with no special blockchain manipulation required:
   - Create proposal while authorized (normal operation)
   - Get removed from whitelist (governance decision or trigger removal)
   - Wait for proposal to reach approval threshold
   - Call `Release()` (only checks proposer identity, not current authorization)

2. **Realistic Attacker Profiles**: 
   - Insider threat: Initially authorized proposer who becomes malicious
   - Compromised key: Proposer's private key compromised after creating proposal
   - No special permissions needed beyond initial proposer rights

3. **Economic Rationality**: Zero cost to maintain a pending proposalâ€”attacker simply waits for votes to accumulate while removed from the whitelist.

4. **Extended Time Window**: Proposals can have long expiration periods (days or weeks), giving attackers ample time to execute after removal.

5. **Real-World Scenarios**:
   - Proposer creates malicious proposal that isn't immediately detected
   - Organization discovers threat and removes proposer
   - Malicious proposal already has accumulated votes
   - Attacker executes despite being removed

## Recommendation

Add authorization re-validation in the `Release` method for all three governance contracts. The fix should call `AssertIsAuthorizedProposer` before executing the proposal:

**For Parliament.cs:**
```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    // ADD THIS LINE:
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, Context.Sender);
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of the method
}
```

Apply the same pattern to Association.cs and Referendum.cs Release methods.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_Can_Still_Release_Old_Proposal_Test()
{
    // 1. Create organization with Proposer1 in whitelist
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 1,
        minimalVoteThreshold: 1,
        maximalAbstentionThreshold: 1,
        maximalRejectionThreshold: 1,
        proposer: Proposer1);

    // 2. Proposer1 creates a malicious proposal
    var maliciousProposalId = await CreateProposalAsync(
        Proposer1KeyPair,
        organizationAddress,
        targetMethod: "TransferFunds",
        targetAddress: TokenContractAddress);

    // 3. Proposal gets approved by members
    await ApproveAsync(Member1KeyPair, maliciousProposalId);
    
    // 4. Organization detects malicious behavior and removes Proposer1
    var newWhitelist = new ProposerWhiteList { Proposers = { Proposer2 } };
    var changeWhitelistProposalId = await CreateProposalAsync(
        Proposer1KeyPair,
        organizationAddress,
        nameof(ChangeOrganizationProposerWhiteList),
        newWhitelist);
    await ApproveAsync(Member1KeyPair, changeWhitelistProposalId);
    await ReleaseAsync(Proposer1KeyPair, changeWhitelistProposalId);

    // 5. Verify Proposer1 cannot create NEW proposals
    var result = await CreateProposalAsync_WithException(Proposer1KeyPair, organizationAddress);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");

    // 6. BUT Proposer1 CAN STILL release the old malicious proposal
    var releaseResult = await ReleaseAsync(Proposer1KeyPair, maliciousProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    // ^ This should FAIL but currently SUCCEEDS - proving the vulnerability
}
```

## Notes

This vulnerability represents a fundamental gap in the governance security model where authorization is treated as a one-time check rather than a continuous requirement. The whitelist mechanism is designed as a security boundary, but its effectiveness is undermined when removed proposers can still execute proposals they created while authorized.

The issue affects critical system governance operations and could allow a compromised or malicious proposer to execute harmful proposals even after the organization has taken defensive action to revoke their privileges. This is particularly severe because proposals can perform arbitrary operations including fund transfers, contract upgrades, and system parameter changes through the organization's virtual address.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L827-829)
```csharp
        var result = await associationContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L845-847)
```csharp
        var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
```
