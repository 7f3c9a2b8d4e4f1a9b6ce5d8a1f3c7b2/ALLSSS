# Audit Report

## Title
Consensus Transaction Signer Mismatch Enables Continuous Block Limit Bypass

## Summary
The AEDPoS consensus contract contains a critical architectural flaw where block validation uses the block signer's public key while state updates use the transaction signer's public key. This mismatch allows two colluding miners to bypass the continuous block limit by alternating transaction signatures while one miner produces all blocks, breaking a fundamental consensus security guarantee.

## Finding Description

The vulnerability stems from inconsistent public key sources across validation and execution phases of consensus block processing.

**Validation Phase**: The `ContinuousBlocksValidationProvider` validates blocks using `validationContext.SenderPubkey`, which represents the block signer's public key extracted from consensus extra data [1](#0-0) . This pubkey is sourced from `ExtraData.SenderPubkey` [2](#0-1) , which is cryptographically validated to match the block header signature [3](#0-2) .

**Execution Phase**: During consensus transaction execution, the contract recovers the public key from the transaction signature using `Context.RecoverPublicKey()` [4](#0-3) . This transaction-derived pubkey is then used to update the continuous block counter state in `ResetLatestProviderToTinyBlocksCount` [5](#0-4) .

**Missing Validation**: The `PreCheck()` method only verifies the transaction signer is in the current or previous miner list [6](#0-5) . Critically, there is no enforcement that the transaction signer must equal the block signer.

**Attack Mechanism**: With `MaximumTinyBlocksCount = 8` [7](#0-6) , when colluding miners A and B alternate transaction signers while A produces all blocks:

1. Block N: A signs block, B signs transaction → Validation checks A against stored state (passes if different or counter ≥ 0), execution updates state with B's pubkey, counter resets to 7
2. Block N+1: A signs block, A signs transaction → Validation checks A ≠ B (passes), execution updates with A, counter resets to 7
3. Block N+2: A signs block, B signs transaction → Validation checks A == A but counter is 7 ≥ 0 (passes), execution updates with B, counter resets to 7

This pattern repeats indefinitely. The validation fails only when stored pubkey equals block signer AND counter < 0 [8](#0-7) , but alternating prevents this condition from ever occurring.

## Impact Explanation

This vulnerability breaks a fundamental consensus security mechanism designed to prevent single-miner dominance. The continuous block limit serves as a critical decentralization protection in the AEDPoS consensus design.

Bypassing this protection enables:

1. **Consensus Centralization**: One miner achieves monopolistic control over block production, directly undermining AEDPoS's decentralization guarantees
2. **Transaction Censorship**: Extended block production control enables systematic censorship of specific transactions or addresses  
3. **MEV Extraction**: Prolonged mining monopoly maximizes extractable value across consecutive blocks
4. **Reward Misallocation**: Unfair concentration of mining rewards to colluding parties
5. **Chain Instability**: Extended single-producer sequences increase reorganization risks and reduce network resilience

The impact is severe because it compromises the integrity of the entire consensus mechanism, not just individual blocks.

## Likelihood Explanation

The attack is highly feasible:

1. **Direct Entry Points**: Consensus methods `UpdateValue`, `UpdateTinyBlockInformation`, `NextRound`, and `NextTerm` are public and directly accessible [9](#0-8) [10](#0-9) [11](#0-10) [12](#0-11) 

2. **Minimal Collusion Requirements**: Only 2 out of approximately 17 miners need to collude, which is realistic given that miner coordination already occurs for legitimate consensus operations

3. **No Technical Barriers**: The block producer can include any transaction signed by another miner as long as both are in the active miner list. Each signature is independently cryptographically valid

4. **Economic Incentives**: Block production rewards and MEV opportunities provide strong financial motivation

5. **Low Detection Probability**: The attack appears as normal alternating mining when examining individual components; detection requires cross-referencing block signers with transaction signers across multiple blocks

## Recommendation

Add validation in the `PreCheck()` method or before `ResetLatestProviderToTinyBlocksCount()` to enforce that the transaction signer must equal the block signer for all consensus transactions:

```csharp
private bool PreCheck()
{
    TryToGetCurrentRoundInformation(out var currentRound);
    TryToGetPreviousRoundInformation(out var previousRound);

    _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

    // NEW: Verify transaction signer matches block signer
    var blockSigner = /* Get block signer from consensus extra data */;
    if (_processingBlockMinerPubkey != blockSigner)
        return false;

    if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
        !previousRound.IsInMinerList(_processingBlockMinerPubkey))
        return false;

    return true;
}
```

Alternatively, use the block signer's pubkey (from consensus extra data) instead of the transaction signer's pubkey when updating the continuous block counter state.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimitBypass_TwoColludingMiners()
{
    // Setup: Initialize consensus with miners A and B
    var minerA = SampleAccount.Accounts[0].KeyPair;
    var minerB = SampleAccount.Accounts[1].KeyPair;
    
    // Round with both miners
    var initialRound = GenerateFirstRound(new[] { minerA.PublicKey, minerB.PublicKey });
    await InitializeConsensus(initialRound);
    
    // Produce 20 consecutive blocks - all signed by A (block), alternating A/B (transaction)
    for (int i = 0; i < 20; i++)
    {
        var useTransactionSignerB = (i % 2 == 0);
        var txSigner = useTransactionSignerB ? minerB : minerA;
        
        // A produces the block (block signature)
        var block = await ProduceBlock(minerA);
        
        // But transaction is signed by alternating miner (transaction signature)
        var consensusTx = await CreateConsensusTransaction(txSigner);
        
        // Both signatures are valid, validation passes, but counter keeps resetting
        var result = await ExecuteConsensusTransaction(block, consensusTx);
        
        // Should fail after 8 blocks, but doesn't due to alternating tx signers
        result.Status.ShouldBe(TransactionResultStatus.Mined);
    }
    
    // Vulnerability: A produced 20 consecutive blocks bypassing the 8-block limit
    var producedByA = await GetProducedBlockCount(minerA.PublicKey);
    producedByA.ShouldBe(20); // Should be capped at 8, but isn't
}
```

## Notes

This vulnerability requires access to the consensus extra data extraction logic in `src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs`, which validates that `ExtraData.SenderPubkey` matches the block header signature. The contract-level code cannot directly access the block signer, only the transaction signer via `Context.RecoverPublicKey()`, creating the architectural mismatch.

The fix requires either:
1. Passing the block signer pubkey to the contract through the consensus extra data and validating equality, or
2. Redesigning the continuous block counter to track by block signatures rather than transaction signatures

The vulnerability affects all four consensus behaviors: UpdateValue, TinyBlock, NextRound, and NextTerm.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L17-23)
```csharp
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L32-32)
```csharp
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L321-321)
```csharp
        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
