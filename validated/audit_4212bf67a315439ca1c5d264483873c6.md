# Audit Report

## Title
Unprotected Dictionary Access in UpdateValueValidationProvider Causes KeyNotFoundException During Consensus Validation

## Summary
The `UpdateValueValidationProvider` performs unprotected dictionary accesses on attacker-controlled consensus data (`ProvidedRound.RealTimeMinersInformation`) without verifying key existence. Any valid miner can craft malicious block headers that trigger `KeyNotFoundException` during validation, disrupting consensus validation across all network nodes.

## Finding Description

The vulnerability exists in the consensus validation flow where block headers are validated before execution. The entry point is the public method `ValidateConsensusBeforeExecution` [1](#0-0)  which calls `ValidateBeforeExecution`.

During validation of `UpdateValue` behavior blocks, the `UpdateValueValidationProvider` is invoked [2](#0-1) . The provider's `NewConsensusInformationFilled` method directly accesses the dictionary without checking key existence: [3](#0-2) 

The `ProvidedRound` comes from attacker-controlled block header data [4](#0-3) , while `SenderPubkey` is extracted from the same block header [5](#0-4) .

Additional unprotected accesses exist in `ValidatePreviousInValue` where lines 42 and 45 access `extraData.Round.RealTimeMinersInformation[publicKey]` after only checking `PreviousRound`, not the `ProvidedRound` being accessed: [6](#0-5) 

**Why existing protections fail:**

The `MiningPermissionValidationProvider` validates the sender is a miner, but only checks against `BaseRound` (from state), not `ProvidedRound` (from block data): [7](#0-6) 

The `RecoverFromUpdateValue` method has protection [8](#0-7)  but this is called before validation providers run [9](#0-8)  and only returns early without enforcing that `ProvidedRound` must contain the sender's pubkey.

The validation service stops on first failure [10](#0-9) , but `MiningPermissionValidationProvider` passes before reaching the vulnerable `UpdateValueValidationProvider`.

## Impact Explanation

**Operational DoS Impact:**
- Any valid miner can produce a block with `Behaviour = AElfConsensusBehaviour.UpdateValue` where the consensus extra data (`ExtraData.Round`) excludes their own pubkey from `RealTimeMinersInformation`
- When other nodes validate this block, an unhandled `KeyNotFoundException` is thrown during the validation phase
- This disrupts block validation across all nodes receiving the malicious block
- Repeated attacks can cause consensus delays or validation failures network-wide

**Affected Parties:**
- All validating nodes in the network (not just the attacker)
- Consensus integrity and block production continuity

**Severity Justification:**
- High severity due to ability to disrupt consensus validation operations
- Any current miner can exploit (low attacker privilege requirement)
- Causes unhandled exceptions that could crash or hang validation processes
- Can be repeated to create sustained denial of service
- Affects critical consensus infrastructure

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a valid miner in the current round (achievable through normal election process)
- Can craft arbitrary consensus extra data in produced blocks
- No economic cost beyond normal block production

**Attack Complexity:**
- Low complexity: Simply craft a `Round` object that omits the producer's own pubkey from `RealTimeMinersInformation`
- The provided round structure is not validated to ensure it contains the sender's pubkey
- Attack is deterministic and requires no special timing or race conditions

**Feasibility Conditions:**
- Entry point is public and called by blockchain infrastructure during block validation
- No special permissions needed beyond being an active miner
- Attack is immediately repeatable

**Detection:**
- Would appear as `KeyNotFoundException` in node validation logs
- Network would see blocks rejected during validation
- Determining malicious intent vs. implementation bugs may be difficult initially

**Probability:**
High likelihood - the vulnerability is trivially exploitable by any active miner with no validation preventing the malicious data structure. The attack surface is exposed through normal consensus operations.

## Recommendation

Add key existence checks before accessing `ProvidedRound.RealTimeMinersInformation` dictionary:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    // Validate sender pubkey exists in ProvidedRound
    if (!validationContext.ProvidedRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
        return false;
        
    var minerInRound =
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}

private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
    
    // Add check for ProvidedRound
    if (!extraData.Round.RealTimeMinersInformation.ContainsKey(publicKey)) return false;

    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == Hash.Empty) return true;

    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

Alternatively, add a validation provider that runs before `UpdateValueValidationProvider` to ensure `ProvidedRound` contains the sender's pubkey.

## Proof of Concept

The following test demonstrates the vulnerability by creating a valid miner who produces an UpdateValue block where `ProvidedRound` excludes their own pubkey:

```csharp
[Fact]
public async Task ValidateConsensusBeforeExecution_MissingMinerInProvidedRound_ThrowsKeyNotFoundException()
{
    // Setup: Initialize consensus contract with a valid miner
    var minerKeyPair = CryptoHelper.GenerateKeyPair();
    var minerPubkey = minerKeyPair.PublicKey.ToHex();
    
    // Create initial round with the miner
    var initialRound = GenerateFirstRound(new[] { minerPubkey });
    await InitializeConsensusContract(initialRound);
    
    // Create malicious consensus extra data with UpdateValue behavior
    // but ProvidedRound excludes the sender's pubkey
    var maliciousRound = new Round
    {
        RoundNumber = initialRound.RoundNumber,
        RealTimeMinersInformation = { } // Empty - missing sender's pubkey!
    };
    
    var headerInfo = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        Round = maliciousRound
    };
    
    // This should throw KeyNotFoundException
    var exception = await Assert.ThrowsAsync<KeyNotFoundException>(async () =>
    {
        await ConsensusContract.ValidateConsensusBeforeExecution.CallAsync(
            new BytesValue { Value = headerInfo.ToByteString() });
    });
    
    Assert.Contains("RealTimeMinersInformation", exception.Message);
}
```

This test proves that when a valid miner produces a block with consensus data that omits their own pubkey from `RealTimeMinersInformation`, the validation throws an unhandled `KeyNotFoundException`, disrupting the validation process.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-80)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L29-30)
```csharp
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-45)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-17)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L18-23)
```csharp
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }
```
