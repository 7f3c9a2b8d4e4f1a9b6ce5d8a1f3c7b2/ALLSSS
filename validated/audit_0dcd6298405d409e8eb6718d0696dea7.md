# Audit Report

## Title
Consensus Behavior Spoofing Enables Bypass of UpdateValue Validation Requirements

## Summary
The AEDPoS consensus validation logic blindly trusts the `Behaviour` field in block headers without verifying it matches the expected behavior determined by consensus state. A malicious miner can claim `TinyBlock` behavior when they should provide `UpdateValue`, bypassing OutValue and Signature validation requirements, thereby evading cryptographic consensus commitments while still receiving block rewards.

## Finding Description

The vulnerability exists because the validation flow trusts the miner-supplied `Behaviour` field without cross-checking it against what the consensus rules mandate.

**Expected Behavior Determination:**
The `GetConsensusBehaviour()` method calculates what behavior a miner SHOULD exhibit based on consensus state. When a miner has `OutValue == null` and their time slot hasn't passed, the method returns `AElfConsensusBehaviour.UpdateValue` [1](#0-0) 

**Validation Bypass:**
However, the `ValidateBeforeExecution` method uses `extraData.Behaviour` directly from the block header to determine which recovery method to use and which validation providers to apply, without ever verifying this matches the expected behavior [2](#0-1) 

**Differential Recovery:**
The system uses different recovery methods based on the claimed behavior. `RecoverFromUpdateValue` restores OutValue, Signature, PreviousInValue, and other critical fields [3](#0-2)  while `RecoverFromTinyBlock` only restores ImpliedIrreversibleBlockHeight and ActualMiningTimes, omitting OutValue and Signature [4](#0-3) 

**Validation Provider Selection:**
The `UpdateValueValidationProvider`, which validates OutValue and Signature presence, is ONLY added when `extraData.Behaviour == UpdateValue`. For TinyBlock behavior, this critical validator is skipped [5](#0-4)  The validator itself checks that OutValue and Signature are properly filled [6](#0-5) 

**Transaction Routing:**
The transaction generation uses the claimed behavior to decide which method to call - `UpdateValue` versus `UpdateTinyBlockInformation` [7](#0-6) 

**State Update Divergence:**
`ProcessUpdateValue` updates OutValue, Signature, PreviousInValue, and ProducedBlocks [8](#0-7)  while `ProcessTinyBlock` only updates ActualMiningTimes and ProducedBlocks, NOT OutValue or Signature [9](#0-8) 

**Attack Path:**
A malicious miner whose OutValue is null (should use UpdateValue) modifies their node to set `Behaviour = TinyBlock` in block headers. The header information is created based on the trigger information's behavior field [10](#0-9)  During validation, other nodes call `RecoverFromTinyBlock` and skip the `UpdateValueValidationProvider`, allowing the block to pass validation. The resulting `UpdateTinyBlockInformation` transaction increments ProducedBlocks but leaves OutValue and Signature null, violating consensus obligations while claiming rewards.

## Impact Explanation

**Consensus Integrity Compromise:**
- The random number generation chain breaks as miners can skip providing OutValue, which is computed as the hash of their InValue and forms the basis for secure randomness in AEDPoS
- Signature-based accountability is eliminated since miners avoid publishing signatures that commit them to their consensus participation
- The secret sharing mechanism for random number generation degrades as fewer miners contribute their cryptographic commitments

**Protocol Fairness Violation:**
- Miners receive block production rewards (ProducedBlocks counter incremented) without fulfilling the complete consensus obligations required by the UpdateValue behavior
- This creates an asymmetric advantage for malicious miners who avoid cryptographic overhead while honest miners bear the full computational cost
- The consensus mechanism's security guarantees weaken proportionally to the number of miners exploiting this bypass

**Affected Parties:**
- All network participants relying on the security properties of AEDPoS consensus
- Applications depending on the quality of on-chain random numbers
- Honest miners who properly fulfill UpdateValue requirements face unfair competition

The severity is Medium because while this doesn't enable direct fund theft, it fundamentally undermines consensus integrity and enables selective protocol violation that degrades the security foundation of the entire chain.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must control a block producer node (requires becoming a miner through normal election mechanisms, achievable with sufficient staked tokens and votes)
- Needs full control over their node software to modify block header generation logic
- Must be in their assigned time slot when OutValue is null (occurs naturally on their first block in each round)

**Attack Complexity:**
The attack is technically straightforward - simply modify the node's block production logic to set `Behaviour = TinyBlock` instead of the correct `UpdateValue` when generating the `AElfConsensusHeaderInformation`. No complex cryptographic operations, state manipulation, or timing windows are required beyond normal block production.

**Detection Constraints:**
- The attack is observable by monitoring round state - other nodes can see that a miner's OutValue remains null after producing blocks
- However, there is no automatic validation or penalty mechanism in the validation code to reject such blocks or punish the offending miner. The evil miner detection only checks missed time slots [11](#0-10) 
- Detection requires manual monitoring and governance intervention, which may be slow or ineffective

**Feasibility Assessment:**
Medium likelihood - technically simple for any miner to execute with modified node software, but carries reputational risk if detected. The lack of automated prevention makes exploitation practical, though the visibility of missing OutValue fields in state provides some deterrent.

## Recommendation

Add a validation check in `ValidateBeforeExecution` that verifies the claimed `extraData.Behaviour` matches the expected behavior calculated by `GetConsensusBehaviour()`. This should be implemented before the differential recovery logic:

1. Calculate the expected behavior using the same logic as `GetConsensusBehaviour()`
2. Compare `extraData.Behaviour` with the expected behavior
3. Reject the block if they don't match

This ensures miners cannot misrepresent their consensus obligations and must fulfill all cryptographic commitments required by their actual consensus state.

## Proof of Concept

A malicious miner can demonstrate this vulnerability by:

1. Becoming an elected miner through normal election mechanisms
2. Waiting for their first block in a round (when OutValue is null and UpdateValue is expected)
3. Modifying their node to create `AElfConsensusTriggerInformation` with `Behaviour = TinyBlock` instead of `UpdateValue`
4. Producing a block with this forged behavior in the header
5. Observing that the block is accepted by other validators
6. Confirming that their ProducedBlocks counter incremented but OutValue and Signature remain null
7. Verifying they received block rewards without fulfilling the cryptographic consensus obligations

The test would verify that after such a block is produced, the miner's state shows `ProducedBlocks > 0` but `OutValue == null` and `Signature == null`, confirming the consensus integrity violation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-114)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }

        /// <summary>
        ///     If this miner come to a new round, normally, there are three possible behaviour:
        ///     UPDATE_VALUE (most common)
        ///     TINY_BLOCK (happens if this miner is mining blocks for extra block time slot of previous round)
        ///     NEXT_ROUND (only happens in first round)
        /// </summary>
        /// <returns></returns>
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-92)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L135-163)
```csharp
        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-265)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
