# Audit Report

## Title
Lock/Unlock Whitelist Bypass via Non-Whitelisted System Contracts

## Summary
The `Lock` and `Unlock` methods use flawed authorization logic that allows ANY system contract to lock tokens when users initiate transactions, effectively bypassing the token-specific lock whitelist configured by token creators during token creation.

## Finding Description

The vulnerability exists in the authorization logic combining two checks in the `Lock` and `Unlock` methods. [1](#0-0) 

The first check calls `AssertSystemContractOrLockWhiteListAddress` which uses OR logic: [2](#0-1) 

This passes if `Context.Sender` is EITHER in the token-specific whitelist (`State.LockWhiteLists[symbol][Context.Sender]`) OR is ANY system contract. The second authorization check uses `IsInLockWhiteList` (which only returns true for Election/Vote contracts) OR verifies `Context.Origin == input.Address`: [3](#0-2) 

When a user calls a system contract (e.g., TokenHolder, Vote) that subsequently calls `Lock`, both checks pass even if that system contract is NOT in the token's specific whitelist:

**Check 1:** System contract check passes (OR logic allows ANY system contract)  
**Check 2:** Origin check passes (user is locking their own tokens)

Token creators explicitly set lock whitelists during token creation with validation requiring only system contract addresses: [4](#0-3) 

This design suggests token creators should be able to restrict which system contracts can lock their tokens. However, the OR logic in `AssertSystemContractOrLockWhiteListAddress` defeats this purpose.

**Real-world trigger:** TokenHolderContract calls Lock during `RegisterForProfits`: [5](#0-4) 

VoteContract calls Lock during voting: [6](#0-5) 

## Impact Explanation

This vulnerability breaks the token creator's intended access control policy. When creating a token, creators explicitly specify which contracts can lock tokens (e.g., `LockWhiteList = [TreasuryContract, ProfitContract]`), expecting this restriction to be enforced. However, ANY system contract can lock user tokens when users interact with them, including TokenHolder, Vote, or any other system contract not in the whitelist.

**Operational Impact:**
- Users' tokens can be locked by contracts the token creator did not authorize
- Potential disruption if the token has specific business logic incompatible with certain locking mechanisms
- Violation of documented access control policy undermines trust in the whitelist feature

**Affected Parties:**
- Token creators who set restricted whitelists expecting enforcement
- Token holders whose tokens can be locked by non-whitelisted system contracts  
- Protocols integrating tokens with specific lock whitelist requirements

**Severity Consideration:** The impact is limited to self-locking scenarios (when `Context.Origin == input.Address`). System contracts cannot lock arbitrary third parties' tokens without being Election/Vote or explicitly whitelisted. However, this still violates the stated security guarantee.

## Likelihood Explanation

**Reachable Entry Point:** Yes - `Lock` and `Unlock` are public methods accessible to all contracts.

**Feasible Preconditions:**
- Token exists with a restricted lock whitelist (e.g., only Treasury and Profit)
- User interacts with a different system contract (TokenHolder, Vote, etc.)
- That system contract calls Lock/Unlock as part of its normal operation

**Execution Practicality:** HIGH - This occurs during normal protocol operations. Users regularly call TokenHolder's `RegisterForProfits` or Vote's voting methods, which internally call Lock. Test evidence shows this pattern: [7](#0-6) 

The test creates tokens with specific whitelists and demonstrates system contracts calling Lock: [8](#0-7) 

**Attack Complexity:** None required - normal user behavior triggers this bypass.

## Recommendation

Modify `AssertSystemContractOrLockWhiteListAddress` to enforce the token-specific whitelist even for system contracts, or explicitly document that the whitelist only applies to non-system contracts. 

**Option 1 - Strict Enforcement (Recommended):**
Remove the system contract bypass entirely, requiring all contracts (including system contracts) to be explicitly whitelisted:

```csharp
private void AssertSystemContractOrLockWhiteListAddress(string symbol)
{
    var symbolState = State.LockWhiteLists[symbol];
    var isInWhiteList = symbolState != null && symbolState[Context.Sender];
    Assert(isInWhiteList, "No Permission.");
}
```

**Option 2 - Separate Check:**
Create distinct authorization paths for system contracts vs. token-specific whitelist, making the design intent explicit.

## Proof of Concept

```csharp
[Fact]
public async Task Lock_Whitelist_Bypass_Via_NonWhitelisted_SystemContract_Test()
{
    // Create token with restricted whitelist (only Treasury)
    await CreateTokenAndIssue(new List<Address> { TreasuryContractAddress });
    
    // TokenHolder is a system contract but NOT in the token's whitelist
    // User calls TokenHolder.RegisterForProfits
    // TokenHolder internally calls Token.Lock(user_address, amount, symbol)
    // Expected: Should fail because TokenHolder not in whitelist
    // Actual: Passes due to OR logic allowing ANY system contract
    
    var lockResult = await TokenHolderContractStub.RegisterForProfits.SendAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = DefaultAddress,
            Amount = 1000
        });
    
    // Vulnerability: Lock succeeds even though TokenHolder not in token's whitelist
    lockResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = DefaultAddress, Symbol = SymbolForTest });
    lockedAmount.Balance.ShouldBeLessThan(InitialBalance);
}
```

**Notes:**
- This vulnerability only affects self-locking scenarios where `Context.Origin == input.Address`
- Election and Vote contracts can lock arbitrary addresses due to the hardcoded `IsInLockWhiteList` check
- The whitelist validation during token creation requires only system contracts, suggesting the design intends selective authorization among system contracts
- Current implementation makes the token-specific whitelist effectively meaningless for user-initiated locking through system contracts

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L95-98)
```csharp
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Select(m => m.Value);
        var isSystemContractAddress = input.LockWhiteList.All(l => systemContractAddresses.Contains(l));
        Assert(isSystemContractAddress, "Addresses in lock white list should be system contract addresses");
        foreach (var address in input.LockWhiteList) State.LockWhiteLists[input.Symbol][address] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-202)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L378-381)
```csharp
    private bool IsInLockWhiteList(Address address)
    {
        return address == GetElectionContractAddress() || address == GetVoteContractAddress();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L124-130)
```csharp
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L958-988)
```csharp
    private async Task CreateTokenAndIssue(List<Address> whitelist = null, Address issueTo = null)
    {
        if (whitelist == null)
            whitelist = new List<Address>
            {
                BasicFunctionContractAddress,
                OtherBasicFunctionContractAddress,
                TreasuryContractAddress
            };
        await CreateMutiTokenAsync(TokenContractStub,new CreateInput
        {
            Symbol = SymbolForTest,
            Decimals = 2,
            IsBurnable = true,
            Issuer = DefaultAddress,
            Owner = DefaultAddress,
            TokenName = "elf test token",
            TotalSupply = DPoSContractConsts.LockTokenForElection * 1000000,
            LockWhiteList =
            {
                whitelist
            }
        });
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = SymbolForTest,
            Amount = DPoSContractConsts.LockTokenForElection * 200000,
            To = issueTo == null ? DefaultAddress : issueTo,
            Memo = "Issue"
        });
    }
```

**File:** test/AElf.Contracts.TestContract.BasicFunction/BasicContract_Action.cs (L65-80)
```csharp
    public override Empty LockToken(LockTokenInput input)
    {
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.Lock.Send(new LockInput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            Amount = input.Amount,
            LockId = input.LockId,
            Usage = input.Usage
        });

        return new Empty();
    }
```
