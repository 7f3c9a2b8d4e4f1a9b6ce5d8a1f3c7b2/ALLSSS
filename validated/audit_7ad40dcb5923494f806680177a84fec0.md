# Audit Report

## Title
Beneficiaries with EndPeriod=long.MaxValue Cannot Be Removed from Schemes with CanRemoveBeneficiaryDirectly=false

## Summary
When a profit scheme has `CanRemoveBeneficiaryDirectly = false` (the default setting) and a beneficiary is added with `EndPeriod = long.MaxValue` (automatically set when EndPeriod is not specified), the scheme manager cannot effectively remove the beneficiary using `RemoveBeneficiary` without providing the `profitDetailId`. This allows the "removed" beneficiary to continue claiming profits indefinitely, permanently diluting legitimate beneficiaries' shares and causing unauthorized fund drainage from the profit scheme.

## Finding Description

The vulnerability exists in the `RemoveProfitDetails` helper method called by `RemoveBeneficiary`. [1](#0-0) 

When a manager calls `RemoveBeneficiary`, the method invokes `RemoveProfitDetails` to identify which profit details can be removed. [2](#0-1) 

The critical flaw exists at the filtering logic: when `CanRemoveBeneficiaryDirectly = false`, only details where `d.EndPeriod < scheme.CurrentPeriod` are eligible for removal. [3](#0-2)  Since `long.MaxValue` is always greater than or equal to `CurrentPeriod`, beneficiaries with `EndPeriod = long.MaxValue` are NEVER included in `detailsCanBeRemoved`.

The default `EndPeriod` assignment occurs in `AddBeneficiary` where unspecified EndPeriod (value 0) defaults to `long.MaxValue`. [4](#0-3) 

The default value for `CanRemoveBeneficiaryDirectly` is `false` per proto3 specification for boolean fields. [5](#0-4) 

Consequently, when the beneficiary detail is not in `detailsCanBeRemoved`, the removal loop never executes, and `removedDetails.Values.Sum()` returns 0, so nothing is subtracted from `TotalShares`. [6](#0-5) 

A workaround exists where providing a `profitDetailId` can bypass the filter. [7](#0-6)  However, this is non-obvious, undocumented, and requires knowledge of the internal profit detail ID.

The removed beneficiary can continue claiming profits because the claim logic only checks if `EndPeriod >= LastProfitPeriod`, which is always satisfied for `long.MaxValue`. [8](#0-7) 

## Impact Explanation

**Direct Fund Impact:**

1. **Unauthorized Continuous Profit Claims**: After the manager attempts to remove a beneficiary, that beneficiary can continue claiming profits indefinitely because their `ProfitDetail` remains in `ProfitDetailsMap` with `EndPeriod = long.MaxValue`.

2. **Permanent Share Dilution**: The "removed" beneficiary's shares remain in the scheme's `TotalShares`, permanently diluting the profit share of all legitimate beneficiaries. For example, if 1000 tokens are distributed and the removed beneficiary had 100 shares out of 1000 total, they continue receiving 10% of all future distributions.

3. **Manager Authorization Bypass**: The scheme manager's explicit intent to remove a beneficiary is silently ignored by the contract, violating the authorization model where only managers control beneficiary membership.

4. **Undetected Exploitation**: Since `RemoveBeneficiary` returns successfully without error [9](#0-8) , the manager has no indication that the removal failed, making this issue difficult to detect without querying contract state post-removal.

**Affected Parties**: All schemes created with `CanRemoveBeneficiaryDirectly = false` (the default) where beneficiaries are added without explicitly specifying `EndPeriod`. This includes third-party dApp profit schemes and potentially future system contract upgrades.

## Likelihood Explanation

**Reachable Entry Point**: The vulnerability requires no special privileges beyond normal beneficiary status. The manager unknowingly enables the vulnerability through common usage patterns:
1. Creating a scheme without setting `CanRemoveBeneficiaryDirectly = true`
2. Adding beneficiaries without specifying `EndPeriod`

**Feasible Preconditions**: 
- Default scheme configuration (`CanRemoveBeneficiaryDirectly = false`)
- Common beneficiary addition pattern where EndPeriod is not specified. Tests confirm that EndPeriod defaults to `long.MaxValue` when not explicitly set. [10](#0-9) [11](#0-10) 

**Execution Practicality**: 
1. Manager creates scheme with default settings
2. Manager adds beneficiary without EndPeriod (defaults to long.MaxValue)
3. Manager later calls RemoveBeneficiary (without profitDetailId)
4. Removal silently fails, beneficiary continues claiming profits

**Detection Constraints**: The vulnerability is silent - `RemoveBeneficiary` succeeds without error, making it undetectable without querying `ProfitDetailsMap` and `TotalShares` post-removal.

**Current System Status**: The Treasury contract creates schemes including the Welfare scheme with `CanRemoveBeneficiaryDirectly = false`. [12](#0-11)  However, the Election contract mitigates this by always specifying explicit EndPeriod values via `GetEndPeriod(lockSeconds)`. [13](#0-12)  This protection is not enforced by the Profit contract itself, leaving third-party dApps vulnerable.

**Probability**: MEDIUM-HIGH for third-party schemes and future system contracts that don't explicitly set `CanRemoveBeneficiaryDirectly = true` or always specify EndPeriod values.

## Recommendation

Implement one or more of the following fixes:

1. **Enforce EndPeriod Specification**: Reject `AddBeneficiary` calls that don't specify an explicit `EndPeriod` when `CanRemoveBeneficiaryDirectly = false`, or require schemes to explicitly opt-in to allowing `long.MaxValue` EndPeriods.

2. **Fix Removal Logic**: Modify `RemoveProfitDetails` to handle `EndPeriod = long.MaxValue` specially when `CanRemoveBeneficiaryDirectly = false`. Add them to `detailsCanBeRemoved` if the manager explicitly calls `RemoveBeneficiary`.

3. **Add Validation**: Throw an error in `RemoveBeneficiary` if no details were actually removed (i.e., `removedDetails.Values.Sum() == 0`), rather than silently succeeding.

4. **Emit Warning Event**: Fire an event when removal partially or completely fails, alerting managers to check the state.

5. **Documentation**: Clearly document that third-party schemes should either set `CanRemoveBeneficiaryDirectly = true` or always specify explicit `EndPeriod` values when adding beneficiaries.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_RemoveBeneficiary_Vulnerability_Test()
{
    const int shares = 100;
    var creator = Creators[0];
    var beneficiary = Normal[0];
    var receiverAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);

    // Create scheme with default CanRemoveBeneficiaryDirectly = false
    var schemeId = await CreateSchemeAsync();

    // Add beneficiary WITHOUT specifying EndPeriod (defaults to long.MaxValue)
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = receiverAddress, Shares = shares },
        SchemeId = schemeId
        // EndPeriod NOT specified - defaults to long.MaxValue
    });

    // Verify beneficiary was added with long.MaxValue EndPeriod
    var profitDetailsBeforeRemoval = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = receiverAddress
    });
    profitDetailsBeforeRemoval.Details.Count.ShouldBe(1);
    profitDetailsBeforeRemoval.Details.First().EndPeriod.ShouldBe(long.MaxValue);

    // Check TotalShares before removal
    var schemeBeforeRemoval = await creator.GetScheme.CallAsync(schemeId);
    schemeBeforeRemoval.TotalShares.ShouldBe(shares);

    // Manager attempts to remove beneficiary WITHOUT profitDetailId
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        Beneficiary = receiverAddress,
        SchemeId = schemeId
        // ProfitDetailId NOT provided
    });

    // VULNERABILITY: Beneficiary was NOT actually removed
    var profitDetailsAfterRemoval = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = receiverAddress
    });
    profitDetailsAfterRemoval.Details.Count.ShouldBe(1); // Still there!

    // VULNERABILITY: TotalShares unchanged
    var schemeAfterRemoval = await creator.GetScheme.CallAsync(schemeId);
    schemeAfterRemoval.TotalShares.ShouldBe(shares); // Not reduced to 0!

    // VULNERABILITY: Beneficiary can still claim profits
    await ContributeProfits(schemeId);
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 1000 } }
    });
    
    var balanceBeforeClaim = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = receiverAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });

    // Beneficiary can still claim even though "removed"
    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });

    var balanceAfterClaim = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = receiverAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    (balanceAfterClaim.Balance - balanceBeforeClaim.Balance).ShouldBeGreaterThan(0); // Claimed profits successfully!
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L161-163)
```csharp
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L241-241)
```csharp
        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L262-262)
```csharp
        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L308-308)
```csharp
    private RemovedDetails RemoveProfitDetails(Scheme scheme, Address beneficiary, Hash profitDetailId = null)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L334-338)
```csharp
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** protobuf/profit_contract.proto (L130-130)
```text
    bool can_remove_beneficiary_directly = 5;
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L134-134)
```csharp
        profitDetails1.Details.First().EndPeriod.ShouldBe(long.MaxValue);
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L159-159)
```csharp
        profitDetails2.Details.First().EndPeriod.ShouldBe(long.MaxValue);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L66-66)
```csharp
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L379-379)
```csharp
            EndPeriod = GetEndPeriod(lockSeconds),
```
