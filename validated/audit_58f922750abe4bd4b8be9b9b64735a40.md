# Audit Report

## Title
Unfair Extra Block Producer Selection Due to Non-Deterministic Fallback Logic and Validation Bypass

## Summary
The AEDPoS consensus contract contains a critical vulnerability where miners can manipulate extra block producer selection by submitting unvalidated order tuning values. This combines with a validation bug that fails to detect duplicate orders, leading to a deterministic fallback mechanism that systematically favors miners with lower order positions, violating consensus fairness guarantees.

## Finding Description

The vulnerability exists across three interconnected components that together enable manipulation of the extra block producer selection process:

**Component 1: Unvalidated Order Tuning**

The `UpdateValueValidationProvider` performs validation when miners submit consensus updates, but it only checks three fields and completely ignores `TuneOrderInformation`: [1](#0-0) 

Meanwhile, `ProcessUpdateValue` blindly applies whatever tuning values are provided, directly setting other miners' `FinalOrderOfNextRound` without any validation: [2](#0-1) 

This means a malicious miner can set arbitrary order values for any other miner in the round.

**Component 2: Broken Duplicate Detection**

The `NextRoundMiningOrderValidationProvider` attempts to validate that miners have unique orders, but contains a critical bug - it calls `.Distinct()` on `MinerInRound` objects rather than on the order values themselves: [3](#0-2) 

Since `MinerInRound` is a protobuf-generated class without custom equality implementation, `.Distinct()` uses reference equality. This means the validation counts each miner object as distinct regardless of whether they have duplicate `FinalOrderOfNextRound` values. If three miners all have order value 1, `.Distinct().Count()` returns 3 instead of detecting the duplication.

**Component 3: Deterministic Fallback Bias**

During next round generation, miners are inserted in ascending order of their `FinalOrderOfNextRound` values: [4](#0-3) 

When selecting the extra block producer, if the calculated order position has no corresponding miner (due to gaps created by duplicates), the code falls back to selecting the first miner in the collection: [5](#0-4) 

Since miners were inserted in ascending order, `.First()` deterministically returns a miner with the lowest order value, bypassing the intended pseudo-random selection mechanism.

**Attack Execution:**

1. Malicious Miner A crafts `UpdateValueInput` with `TuneOrderInformation = {MinerB: 1, MinerC: 1, MinerD: 1}`
2. `UpdateValueValidationProvider` validates the transaction but ignores `TuneOrderInformation`
3. `ProcessUpdateValue` applies the malicious tuning, setting three miners to order 1
4. When `NextRound` is called, `NextRoundMiningOrderValidationProvider` fails to detect duplicates due to reference equality check
5. `GenerateNextRoundInformation` creates a round with three miners at order 1, leaving gaps (e.g., no miner at order 2 or 3)
6. If `CalculateNextExtraBlockProducerOrder()` returns 2, no miner matches
7. `.FirstOrDefault()` returns `null`, triggering `.First()` fallback
8. One of the miners with order 1 becomes extra block producer deterministically

## Impact Explanation

**Consensus Fairness Violation**: The extra block producer selection is designed to be pseudo-random through `CalculateNextExtraBlockProducerOrder()`, which derives a value from miner signatures. The `.First()` fallback completely bypasses this randomness mechanism, creating a systematic bias toward miners positioned at lower order values.

**Economic Impact - Reward Misallocation**: Extra block producers receive additional block production rewards beyond normal miners. By manipulating order assignments to create gaps that trigger the deterministic fallback, malicious miners can increase their probability of being selected as extra block producer, effectively stealing rewards that should be distributed fairly according to the intended randomness-based selection.

**Protocol Integrity**: The vulnerability violates the core consensus guarantee that all miners have equal opportunity to become extra block producer based on cryptographic randomness. This breaks the economic security assumptions of the AEDPoS consensus mechanism.

## Likelihood Explanation

**High Feasibility**: Any miner can exploit this vulnerability by submitting an `UpdateValue` transaction with arbitrary `TuneOrderInformation` values. The attack requires no special privileges beyond being in the current miner set, which is the normal precondition for calling `UpdateValue`.

**No Protective Barriers**: The vulnerability passes all validation checks because:
- `UpdateValueValidationProvider` explicitly does not validate `TuneOrderInformation` 
- `NextRoundMiningOrderValidationProvider` has a logic bug that prevents it from detecting duplicate order values
- No other validation provider in the chain checks order uniqueness

**Practical Constraints**: The attacker cannot directly control which order value `CalculateNextExtraBlockProducerOrder()` returns, as this depends on the first miner's signature. However, by creating multiple duplicate orders and gaps, the attacker increases the probability that the calculated value falls into a gap, triggering the favorable fallback. If the attacker is among the last miners to call `UpdateValue` in a round, their malicious tuning values will persist (later updates can overwrite earlier ones).

## Recommendation

**Fix 1: Validate TuneOrderInformation**

Add validation in `UpdateValueValidationProvider` to ensure `TuneOrderInformation` only contains legitimate conflict resolutions from `ApplyNormalConsensusData`. One approach is to reconstruct what the tuning values should be based on the current round state and verify they match:

```csharp
private bool ValidateTuneOrderInformation(ConsensusValidationContext validationContext)
{
    var expectedTuning = validationContext.BaseRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
        .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
    
    var providedTuning = validationContext.ExtraData.Round
        .RealTimeMinersInformation[validationContext.SenderPubkey]
        .TuneOrderInformation;
    
    return expectedTuning.OrderBy(kv => kv.Key)
        .SequenceEqual(providedTuning.OrderBy(kv => kv.Key));
}
```

**Fix 2: Correct Duplicate Detection**

Fix `NextRoundMiningOrderValidationProvider` to check for duplicate order values, not duplicate miner objects:

```csharp
var orderValues = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();

var distinctOrderCount = orderValues.Distinct().Count();

if (distinctOrderCount != orderValues.Count)
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}

if (distinctOrderCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound count.";
    return validationResult;
}
```

**Fix 3: Remove Fallback or Make It Explicit**

Either eliminate the `.First()` fallback entirely (assert that a miner must exist at the calculated order), or if a fallback is necessary for edge cases, select randomly rather than deterministically:

```csharp
var expectedExtraBlockProducer = nextRound.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.Order == extraBlockProducerOrder);

if (expectedExtraBlockProducer == null)
{
    // Should never happen with proper validation - assert instead of fallback
    throw new InvalidOperationException(
        $"No miner found at calculated order {extraBlockProducerOrder}");
}
else
{
    expectedExtraBlockProducer.IsExtraBlockProducer = true;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ExploitExtraBlockProducerSelection_ViaMaliciousTuneOrderInformation()
{
    // Setup: Initialize consensus with 5 miners
    var miners = await InitializeFiveMiners();
    var maliciousMiner = miners[0]; // Miner A
    
    // Step 1: Malicious miner crafts UpdateValueInput with duplicate order assignments
    var maliciousUpdateInput = new UpdateValueInput
    {
        OutValue = Hash.FromString("test_out_value"),
        Signature = Hash.FromString("test_signature"),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            { miners[1], 1 }, // Miner B -> order 1
            { miners[2], 1 }, // Miner C -> order 1  
            { miners[3], 1 }  // Miner D -> order 1 (creates duplicates)
        },
        // ... other required fields
    };
    
    // Step 2: Submit malicious UpdateValue - should pass validation but contains exploit
    await maliciousMiner.UpdateValue(maliciousUpdateInput);
    
    // Step 3: Trigger NextRound
    var nextRoundResult = await miners[0].NextRound();
    
    // Step 4: Verify exploitation - multiple miners have same order creating gaps
    var currentRound = await GetCurrentRoundInformation();
    var minersAtOrder1 = currentRound.RealTimeMinersInformation.Values
        .Where(m => m.Order == 1).Count();
    
    Assert.True(minersAtOrder1 >= 3, "Duplicate orders should exist");
    
    // Step 5: Verify biased extra block producer selection
    // Due to gaps, if calculated order falls in gap, .First() is used
    var extraBlockProducer = currentRound.RealTimeMinersInformation.Values
        .First(m => m.IsExtraBlockProducer);
    
    // Extra block producer should be one of the miners with lowest order (order 1)
    Assert.Equal(1, extraBlockProducer.Order);
    
    // This demonstrates deterministic bias instead of random selection
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
