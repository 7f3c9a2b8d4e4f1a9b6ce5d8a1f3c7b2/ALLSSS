# Audit Report

## Title
Consensus Signature Forgery Allows Mining Order Manipulation in AEDPoS UpdateValue

## Summary
The AEDPoS consensus mechanism fails to validate that the `Signature` field in `UpdateValueInput` matches the expected deterministic calculation, allowing miners to forge signatures and manipulate their mining order in subsequent rounds. The signature directly determines position via modulus operation but is only checked for null/empty, not correctness.

## Finding Description

The AEDPoS consensus uses a signature value to determine each miner's position in the next round through a deterministic calculation. The signature should be calculated as `XOR(previousInValue, XOR(all signatures from previous round))` [1](#0-0) , but when miners submit blocks with `UpdateValueInput`, there is no validation that the provided signature matches this expected calculation.

**Vulnerability Flow:**

1. During block production, miners generate consensus extra data via `GetConsensusExtraDataToPublishOutValue`, which correctly calculates the signature [2](#0-1) 

2. However, miners control the consensus extra data placed in the block header and can modify the signature field before block submission

3. During validation, `UpdateValueValidationProvider` only checks that signature is not null/empty [3](#0-2) , with no verification against the expected `CalculateSignature` result

4. The unverified signature is copied directly via `RecoverFromUpdateValue` [4](#0-3) 

5. In `ProcessUpdateValue`, this forged signature is stored to state without verification [5](#0-4) 

6. The forged signature determines the miner's order in the next round through `ApplyNormalConsensusData`, which converts the signature to int64 and applies modulus to determine position [6](#0-5) 

The post-execution validation in `ValidateConsensusAfterExecution` only verifies that the state matches the header hash [7](#0-6) , but since both include the same forged signature after state update, this check passes.

## Impact Explanation

This vulnerability breaks the fundamental fairness and randomness guarantees of the AEDPoS consensus mechanism:

**Direct Impact:**
- Miners can calculate and submit forged signatures to obtain desired positions (e.g., position #1) in subsequent rounds by reverse-engineering the modulus calculation
- Systematic manipulation allows miners to maintain favorable positions across multiple rounds
- The extra block producer selection, which depends on miner signatures, can be influenced

**Consensus Integrity:**
- Violates the invariant that mining order must be determined by unpredictable randomness based on previous round data
- Undermines the security assumption that miners cannot predict or control their future positions
- Enables unfair advantage in block production scheduling and associated rewards

**Severity: HIGH** - This breaks a critical consensus mechanism property where all miners should have equal probabilistic access to favorable mining positions. The deterministic signature calculation exists specifically to prevent position manipulation through unpredictable randomness.

## Likelihood Explanation

**Attacker Profile:**
- Must be an authorized miner (in the miner list)
- This is a realistic threat model - protecting against malicious miners is the primary purpose of consensus validation

**Attack Execution:**
1. Miner calculates which signature value yields desired next-round position: `targetSig = Hash.FromInt64((desiredOrder - 1) + k * minersCount)` for chosen k
2. Miner modifies the signature field in consensus extra data before block submission
3. Block validation accepts the forged signature (only null/empty check exists)
4. State is updated with forged signature
5. Next round miner order reflects the manipulated position

**Feasibility:**
- No special privileges beyond authorized miner status
- Trivial computational effort (single hash calculation)
- No economic cost (standard transaction fees)
- Undetectable - no validation exists to catch the forgery
- Repeatable every round

**Likelihood: HIGH** - Any authorized miner can exploit this with guaranteed success on every block they produce.

## Recommendation

Add signature validation in `UpdateValueValidationProvider` to verify the provided signature matches the expected calculation:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
        return true;
    
    var providedSignature = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].Signature;
    var previousInValue = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true;
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    
    return providedSignature == expectedSignature;
}
```

This validation should be added to the `UpdateValueValidationProvider.ValidateHeaderInformation` method after the existing checks.

## Proof of Concept

```csharp
[Fact]
public async Task Test_SignatureForgery_AllowsMiningOrderManipulation()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeAEDPoSContract();
    await BootMinerChangeRoundAsync();
    
    // Get current round information
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var previousRound = await AEDPoSContractStub.GetPreviousRoundInformation.CallAsync(new Empty());
    
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var attackerPubkey = attackerKeyPair.PublicKey.ToHex();
    
    // Calculate what signature would give us position #1 in next round
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    var targetPosition = 1;
    var forgedSignature = Hash.FromInt64(targetPosition - 1); // Simplified for demonstration
    
    // Generate consensus extra data with correctly calculated signature
    var triggerInfo = TriggerInformationProvider.GetTriggerInformationForBlockHeaderExtraData(consensusCommand.ToBytesValue());
    var extraData = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggerInfo);
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(extraData.Value);
    
    // ATTACK: Replace the correctly calculated signature with our forged one
    headerInfo.Round.RealTimeMinersInformation[attackerPubkey].Signature = forgedSignature;
    
    // Validation should fail but currently passes - only checks null/empty
    var validationResult = await AEDPoSContractStub.ValidateConsensusBeforeExecution.CallAsync(headerInfo.ToBytesValue());
    validationResult.Success.ShouldBeTrue(); // This passes - VULNERABILITY
    
    // Execute UpdateValue with forged signature
    var updateInput = headerInfo.Round.ExtractInformationToUpdateConsensus(attackerPubkey, randomNumber);
    await AEDPoSContractStub.UpdateValue.SendAsync(updateInput);
    
    // Verify: Check that next round mining order reflects our forged signature
    await ProduceBlocks(attackerKeyPair, minersCount);
    var nextRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var actualPosition = nextRound.RealTimeMinersInformation[attackerPubkey].Order;
    
    // The forged signature successfully manipulated the mining order
    actualPosition.ShouldBe(targetPosition);
}
```

## Notes

The vulnerability exists because the signature validation only checks for null/empty values but never verifies correctness against the expected `CalculateSignature` result. The `CalculateSignature` method is called during consensus extra data generation [2](#0-1) , indicating this is the expected signature value. However, no validation provider compares the provided signature against this calculation, allowing miners to forge arbitrary signatures and manipulate their mining positions in subsequent rounds.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
