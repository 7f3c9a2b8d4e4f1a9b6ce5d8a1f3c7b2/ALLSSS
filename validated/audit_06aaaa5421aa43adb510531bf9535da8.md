# Audit Report

## Title
Permanent Token Lock via Scheme Symbol Overwrite in TokenHolderContract

## Summary
The `CreateScheme` function in TokenHolderContract lacks validation to prevent multiple invocations by the same manager, allowing the scheme symbol to be overwritten. Users who registered under the original scheme will have their tokens permanently locked because the `Withdraw` function attempts to unlock tokens using the new scheme symbol instead of the original symbol used during registration.

## Finding Description

The vulnerability exists because `CreateScheme` has no protection against being called multiple times by the same manager. [1](#0-0) 

When `CreateScheme` is invoked, it unconditionally overwrites the `TokenHolderProfitScheme` mapping, replacing the existing scheme (including its symbol) with new values. [2](#0-1) 

Each invocation creates a distinct scheme in the ProfitContract with a different `schemeId`. The ProfitContract maintains a list of all schemes for each manager and adds new schemes to this list. [3](#0-2) 

During `RegisterForProfits`, tokens are locked using the scheme's symbol at that point in time. [4](#0-3) 

The lock mechanism in MultiToken transfers tokens to a virtual address computed from the sender, user address, and lockId - but NOT the symbol. [5](#0-4) 

When `GetValidScheme` is called after the scheme symbol has changed, it retrieves the scheme from state (with the new symbol) and calls `UpdateTokenHolderProfitScheme`. [6](#0-5) 

The `UpdateTokenHolderProfitScheme` method fetches the FIRST scheme from ProfitContract using `FirstOrDefault()`, but preserves the Symbol from the current state. [7](#0-6) 

This creates a mismatch: the scheme has the SchemeId from the first `CreateScheme` call but the Symbol from the latest `CreateScheme` call.

When `Withdraw` is called, it uses `GetLockedAmount` with this mismatched scheme's symbol. [8](#0-7) 

The `GetLockedAmount` function queries the balance of the specified symbol at the virtual address. [9](#0-8) 

Since the virtual address is the same (computed without symbol), but the balance query is symbol-specific, it returns zero for the new symbol when tokens were locked with the original symbol. The unlock proceeds with zero amount, and the lockId mapping is deleted. [10](#0-9) 

This leaves the original tokens permanently locked at the virtual address with no recovery mechanism.

## Impact Explanation

**Direct Fund Impact:** Users lose complete access to their locked tokens permanently. If a manager creates a scheme with symbol "ELF" and users lock 10,000 ELF tokens, then the manager calls `CreateScheme` again with symbol "USDT", those 10,000 ELF tokens become permanently irrecoverable.

**Who is Affected:** All users who registered for profits under the original scheme before `CreateScheme` was called again. This could affect hundreds or thousands of users depending on the scheme's popularity.

**Severity Justification:** HIGH severity because:
1. Results in permanent and complete loss of user funds (not temporary or partial)
2. No recovery mechanism exists - the lockId mapping is deleted after withdrawal attempt
3. Affects potentially large amounts across multiple users
4. The virtual address holding the locked tokens becomes orphaned with no contract reference to the original symbol

## Likelihood Explanation

**Attacker Capabilities:** The scheme manager (who calls `CreateScheme`) could be:
- Malicious: Intentionally locks user funds to prevent withdrawals
- Negligent: Accidentally calls `CreateScheme` again thinking they're updating the scheme
- Compromised: Has their keys stolen by an attacker who executes this attack

**Attack Complexity:** Low - requires only two transactions:
1. Initial `CreateScheme` with Symbol A
2. Second `CreateScheme` with Symbol B (after users have registered)

**Feasibility Conditions:**
- No special permissions required beyond being the scheme manager
- No timing constraints or complex state dependencies
- Works regardless of how many users have registered
- No economic cost to execute (only gas fees)

**Detection Constraints:** The contract provides no events or warnings when `CreateScheme` overwrites an existing scheme. Users would only discover the issue when attempting to withdraw and receiving zero tokens.

**Probability Assessment:** Medium-to-High likelihood because:
- No UI or contract-level warnings prevent duplicate calls
- Managers may legitimately think they can "update" their scheme
- The function signature gives no indication it should only be called once

## Recommendation

Add a validation check in `CreateScheme` to prevent multiple invocations:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager.");
    
    // Rest of the function remains unchanged
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    // ...
}
```

Alternatively, if scheme updates are intended functionality, implement a proper `UpdateScheme` function that validates users have no locked tokens before allowing symbol changes, or provide a migration mechanism that properly handles locked tokens.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task CreateScheme_MultipleCallsCausePermanentTokenLock()
{
    // 1. Manager creates scheme with ELF symbol
    var manager = Accounts[0];
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // 2. User registers and locks 10000 ELF tokens
    var user = Accounts[1];
    var lockAmount = 10000_00000000;
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = lockAmount
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager.Address,
        Amount = lockAmount
    });
    
    // 3. Manager calls CreateScheme again with USDT symbol (overwrites scheme)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 1
    });
    
    // 4. User tries to withdraw after lock period
    // This will unlock 0 tokens because GetLockedAmount queries USDT balance
    // but tokens were locked as ELF
    var balanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user.Address,
        Symbol = "ELF"
    });
    
    await TokenHolderContractStub.Withdraw.SendAsync(manager.Address);
    
    var balanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user.Address,
        Symbol = "ELF"
    });
    
    // Balance should increase by lockAmount, but it doesn't (vulnerability)
    Assert.Equal(balanceBefore.Balance, balanceAfter.Balance); // Still locked!
    
    // LockId mapping is deleted, so user cannot retry withdrawal
    // Tokens are permanently lost
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L230-238)
```csharp
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-298)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
