# Audit Report

## Title
Side Chain Donation Tracking Overwrites Multi-Symbol Donations in Same Block

## Summary
The `Donate()` function in both the AEDPoS side chain dividends pool and Treasury contract contains a critical logic error where donation records are overwritten when multiple different token symbols are donated within the same block. The flawed conditional logic creates a new `Dividends` object instead of adding to the existing one, resulting in permanent loss of previously recorded donations for that block.

## Finding Description

The vulnerability exists in the donation tracking logic of both contracts. The root cause lies in the conditional statement that has two negation paths leading to the else block:

1. When no prior donation exists at the current height (correct behavior)
2. When a prior donation exists but with a different symbol (BUG - overwrites existing data)

**AEDPoS Contract Bug:**
The condition checks if the current symbol already exists in the record. [1](#0-0) 

When scenario 2 occurs (record exists but doesn't contain the new symbol), the else block creates a completely new `Dividends` object containing only the current donation symbol, then writes it to state, effectively erasing all other symbol donations recorded for that block height.

**Treasury Contract Bug:**
The Treasury contract has an even more restrictive condition that only updates amounts when donating the native symbol to an existing native symbol record. [2](#0-1) 

The `Dividends` message type is designed as a map structure specifically to support multiple token symbols. [3](#0-2) 

**Concrete Exploit Scenario:**
- Block 1000, Transaction 1: User A donates 1000 ELF → State stores `{ELF: 1000}`
- Block 1000, Transaction 2: User B donates 500 USDT → Condition evaluates to false (record exists but doesn't contain USDT) → Else block executes → State overwrites to `{USDT: 500}` → **ELF donation record is permanently lost**

Both `Donate()` methods are public and implement the ACS10 standard interface. [4](#0-3) [5](#0-4) 

## Impact Explanation

**Critical State Corruption:**
- Donation records for entire token symbols are permanently erased from blockchain state
- The `GetDividends` view function returns incorrect historical data for affected block heights [6](#0-5) 
- TokenHolder profit distribution calculations may reference corrupted dividend data
- Economic analytics and governance metrics become unreliable

**Direct Financial Impact:**
- Donors lose recognition of their contributions in the permanent blockchain record
- Historical queries for donation amounts return incomplete and incorrect data
- Side chain operators and main chain treasury lose accurate tracking for economic decisions
- No on-chain detection or recovery mechanism exists

**Severity Justification:** 
This is CRITICAL because:
1. The bug destroys permanent state data that cannot be recovered
2. It occurs deterministically under normal multi-token usage patterns
3. Lost donation records affect historical accuracy and potential downstream calculations
4. The bug affects both side chain dividends and main chain treasury
5. Events fire correctly, masking the underlying state corruption [7](#0-6) 

## Likelihood Explanation

**Reachable Entry Point:**
The `Donate()` methods are public functions implementing the ACS10 standard, accessible to any user with token balance and approval.

**Trivial Preconditions:**
- Any two users call `Donate()` with different token symbols in the same block
- Only requires token balance, approval, and passing the `IsTokenAvailableForMethodFee` check [8](#0-7) 
- No special permissions, timing requirements, or complex setup needed

**Execution Practicality:**
- On moderately active side chains, multiple donations per block is expected behavior
- AEDPoS block times (~4 seconds) make concurrent transactions highly probable  
- The bug triggers automatically without any malicious intent required
- Normal users performing legitimate donations will unknowingly trigger data loss

**Attack Complexity:** VERY LOW
- No sophisticated manipulation needed
- Occurs naturally through normal protocol usage
- Can be accidentally triggered or deliberately exploited
- No way for users to prevent or detect the issue before it occurs

**Probability Assessment:** HIGH - This will occur regularly on any production side chain or main chain treasury with multi-token support and moderate transaction volume.

## Recommendation

Fix the conditional logic to properly add new symbols to the existing `Dividends` object instead of creating a new one:

**For AEDPoS Contract:**
```csharp
var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
if (currentReceivedDividends == null)
{
    currentReceivedDividends = new Dividends();
}

if (currentReceivedDividends.Value.ContainsKey(input.Symbol))
{
    currentReceivedDividends.Value[input.Symbol] = 
        currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
}
else
{
    currentReceivedDividends.Value[input.Symbol] = input.Amount;
}

State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;
```

**For Treasury Contract:**
Apply the same fix pattern, removing the restrictive native symbol check.

## Proof of Concept

```csharp
[Fact]
public async Task Donate_MultipleSymbolsSameBlock_ShouldNotOverwrite()
{
    // Setup: Create two different token symbols
    const string symbol1 = "ELF";
    const string symbol2 = "USDT";
    const long amount1 = 1000;
    const long amount2 = 500;
    
    // Donate first symbol
    await ConsensusStub.Donate.SendAsync(new DonateInput
    {
        Symbol = symbol1,
        Amount = amount1
    });
    
    var currentHeight = await GetCurrentBlockHeight();
    
    // Verify first donation recorded
    var dividends1 = await ConsensusStub.GetDividends.CallAsync(new Int64Value { Value = currentHeight });
    Assert.True(dividends1.Value.ContainsKey(symbol1));
    Assert.Equal(amount1, dividends1.Value[symbol1]);
    
    // Donate second symbol in same block (simulate by not mining)
    await ConsensusStub.Donate.SendAsync(new DonateInput
    {
        Symbol = symbol2,
        Amount = amount2
    });
    
    // Get dividends again
    var dividends2 = await ConsensusStub.GetDividends.CallAsync(new Int64Value { Value = currentHeight });
    
    // BUG: First symbol donation is lost, only second symbol remains
    Assert.True(dividends2.Value.ContainsKey(symbol2)); // Passes
    Assert.Equal(amount2, dividends2.Value[symbol2]); // Passes
    Assert.True(dividends2.Value.ContainsKey(symbol1)); // FAILS - ELF record lost!
}
```

## Notes

This vulnerability affects both production contracts and will trigger naturally in normal operation. The Treasury contract variant is even more severe due to its restrictive native-symbol-only update condition. Immediate patching is recommended before deploying to any multi-token environment.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-37)
```csharp
    public override Empty Donate(DonateInput input)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L41-42)
```csharp
        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L66-72)
```csharp
        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L74-89)
```csharp
        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L130-134)
```csharp
    public override Dividends GetDividends(Int64Value input)
    {
        Assert(Context.CurrentHeight > input.Value, "Cannot query dividends of a future block.");
        return State.SideChainReceivedDividends[input.Value];
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-174)
```csharp
    public override Empty Donate(DonateInput input)
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L225-239)
```csharp
            var donatesOfCurrentBlock = State.DonatedDividends[Context.CurrentHeight];
            if (donatesOfCurrentBlock != null && Context.Variables.NativeSymbol == input.Symbol &&
                donatesOfCurrentBlock.Value.ContainsKey(Context.Variables.NativeSymbol))
                donatesOfCurrentBlock.Value[Context.Variables.NativeSymbol] = donatesOfCurrentBlock
                    .Value[Context.Variables.NativeSymbol].Add(input.Amount);
            else
                donatesOfCurrentBlock = new Dividends
                {
                    Value =
                    {
                        { input.Symbol, input.Amount }
                    }
                };

            State.DonatedDividends[Context.CurrentHeight] = donatesOfCurrentBlock;
```

**File:** protobuf/acs10.proto (L65-68)
```text
message Dividends {
    // The dividends, symbol -> amount.
    map<string, int64> value = 1;
}
```
