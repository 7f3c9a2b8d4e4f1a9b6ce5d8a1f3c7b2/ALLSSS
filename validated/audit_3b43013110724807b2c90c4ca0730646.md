# Audit Report

## Title
Case Sensitivity in ReplaceCandidatePubkey Causes Vote Data Loss and Incorrect Miner Selection

## Summary
The `ReplaceCandidatePubkey` function in the Election Contract lacks case normalization for pubkey string inputs, causing it to fail migrating vote data when pubkeys with different casing are provided. This creates inconsistent state where `State.CandidateVotes` retains orphaned entries while `State.Candidates` is updated, leading to incorrect miner selection in `GetVictories()` and potential consensus corruption.

## Finding Description

The vulnerability stems from the interaction between case-sensitive dictionary lookups and the absence of input normalization in the `ReplaceCandidatePubkey` function.

**Root Cause Analysis:**

The `ToHex()` extension method deterministically produces lowercase hex strings from byte arrays. [1](#0-0)  The formula `b + 0x37 + 0x20` produces lowercase ASCII characters 'a' through 'f' for hexadecimal digits.

During normal candidate registration via `AnnounceElection`, pubkey bytes are converted to lowercase strings using `ToHex()` before storing in `State.CandidateInformationMap`. [2](#0-1) 

When voters cast votes, the `Vote` function stores vote data in `State.CandidateVotes` using the candidate pubkey string directly as the key. [3](#0-2)  Since voters must provide pubkeys matching the keys in `CandidateInformationMap` (which are lowercase for regular candidates), vote data is typically stored with lowercase keys.

**The Critical Flaw:**

The `ReplaceCandidatePubkey` function uses input strings directly without normalization. When an admin provides pubkeys with different casing (e.g., uppercase) than the stored keys (lowercase): [4](#0-3) 

At line 229, `State.CandidateVotes[input.OldPubkey]` attempts to retrieve vote data using the input string directly. If the input is uppercase but the actual data is stored at a lowercase key, this returns `null`, causing the if block to not execute. The vote data migration fails, and the old entry remains orphaned.

Meanwhile, the `State.Candidates` update at lines 192-196 works correctly because it uses byte comparison, which is case-insensitive. [5](#0-4) 

**Why Validation Passes:**

The validation check at line 175 calls `IsCurrentCandidateOrInitialMiner`, which for initial miners uses byte equality checking. [6](#0-5) 

The check converts hex strings to bytes using `ByteArrayHelper.HexStringToByteArray`, which is case-insensitive. [7](#0-6)  The `Convert.ToByte` method treats "ABC" and "abc" identically, allowing validation to pass with mismatched cases.

**Impact on GetVictories():**

The `GetValidCandidates` method iterates through `State.Candidates` and converts pubkey bytes to lowercase using `ToHex()` to look up vote counts. [8](#0-7) 

After a failed migration:
- `State.Candidates` contains the new pubkey bytes
- `GetValidCandidates` converts to lowercase and queries `State.CandidateVotes["newpubkey_lowercase"]`
- This entry doesn't exist (migration failed)
- The candidate is incorrectly excluded from valid candidates despite having legitimate votes
- The orphaned old entry at `State.CandidateVotes["oldpubkey_lowercase"]` becomes unreachable

## Impact Explanation

**Consensus Integrity Compromise:**
Candidates with legitimate votes are incorrectly excluded from `GetVictories()` results, corrupting the miner selection for consensus rounds. The AEDPoS consensus mechanism depends on accurate victory calculations to determine the validator set.

**Vote Data Loss:**
Vote tokens locked by electors become associated with orphaned state entries that are no longer accessible. The accumulated voting power for a candidate is effectively nullified, violating the fundamental invariant that vote weight must accurately reflect in candidate selection.

**State Inconsistency:**
The contract state becomes internally inconsistent with `State.Candidates` reflecting the new pubkey while `State.CandidateVotes` still references the old pubkey. This breaks the relationship between candidate registration and vote tracking.

**Operational Impact:**
This disrupts the election mechanism's core function of determining block producers and could lead to governance disputes if legitimate high-vote candidates are excluded from consensus participation.

Severity is assessed as **Medium** because while it compromises consensus integrity and causes data loss, it requires admin-level access and only affects candidates undergoing pubkey replacement.

## Likelihood Explanation

**Preconditions:**
- Requires admin or candidate admin role with permissions to call `ReplaceCandidatePubkey` [9](#0-8) 
- Candidate must have existing vote data to cause measurable impact
- Admin must provide input strings with different casing than stored keys

**Execution Simplicity:**
The vulnerability can be triggered with a single transaction calling `ReplaceCandidatePubkey` with uppercase pubkey strings. No complex transaction sequences or precise timing is required.

**Realistic Scenario:**
This can occur unintentionally if an admin uses uppercase hex strings, not realizing the case sensitivity of the state dictionary keys. The lack of input validation or documentation about case requirements makes this a realistic mistake. Existing tests only use lowercase strings via `ToHex()`, failing to catch this edge case. [10](#0-9) 

The probability is medium - while requiring privileged access, the absence of input validation and the non-obvious case sensitivity requirement make honest mistakes feasible.

## Recommendation

Add input normalization to `ReplaceCandidatePubkey` to ensure consistent case handling:

```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    // Normalize inputs to lowercase to match ToHex() output
    var oldPubkeyNormalized = input.OldPubkey.ToLower();
    var newPubkeyNormalized = input.NewPubkey.ToLower();
    
    Assert(IsCurrentCandidateOrInitialMiner(oldPubkeyNormalized),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(oldPubkeyNormalized) && !IsPubkeyBanned(newPubkeyNormalized),
        "Pubkey is in already banned.");

    // Permission check using normalized key
    Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = oldPubkeyNormalized }), "No permission.");

    // Use normalized keys throughout the rest of the function
    PerformReplacement(oldPubkeyNormalized, newPubkeyNormalized);
    
    // ... rest of implementation using normalized keys
}
```

Alternatively, use `ByteArrayHelper.HexStringToByteArray` to convert strings to bytes, then convert back to lowercase using `ToHex()` at the beginning of the function to ensure consistency.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseInput_LosesVoteData()
{
    // Setup: Announce election with lowercase pubkey
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    await AnnounceElectionAsync(candidateKeyPair, candidateAdminAddress);
    
    var lowercasePubkey = candidateKeyPair.PublicKey.ToHex(); // lowercase
    
    // Vote for the candidate to create vote data
    var voterKeyPair = ValidationDataCenterKeyPairs[2];
    var voterStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, voterKeyPair);
    await voterStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = lowercasePubkey,
        Amount = 100_00000000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(100)
    });
    
    // Verify vote data exists at lowercase key
    var votesBefore = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = lowercasePubkey });
    votesBefore.ObtainedActiveVotedVotesAmount.ShouldBe(100_00000000);
    
    // Replace candidate with UPPERCASE pubkey strings
    var newKeyPair = ValidationDataCenterKeyPairs[3];
    var uppercaseOldPubkey = lowercasePubkey.ToUpper(); // UPPERCASE
    var uppercaseNewPubkey = newKeyPair.PublicKey.ToHex().ToUpper(); // UPPERCASE
    
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = uppercaseOldPubkey,
        NewPubkey = uppercaseNewPubkey
    });
    
    // VULNERABILITY: Vote data NOT migrated to new pubkey
    var newPubkeyLowercase = newKeyPair.PublicKey.ToHex();
    var votesAfter = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = newPubkeyLowercase });
    votesAfter.ObtainedActiveVotedVotesAmount.ShouldBe(0); // Expected 100_00000000, got 0!
    
    // Old vote data orphaned at lowercase key
    var orphanedVotes = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = lowercasePubkey });
    orphanedVotes.ObtainedActiveVotedVotesAmount.ShouldBe(100_00000000); // Still there but unreachable
    
    // GetVictories incorrectly excludes candidate despite votes
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    victories.Value.ShouldNotContain(ByteString.CopyFrom(newKeyPair.PublicKey)); // Excluded!
}
```

This test demonstrates that when `ReplaceCandidatePubkey` is called with uppercase pubkey strings, the vote data fails to migrate to the new pubkey, resulting in vote data loss and incorrect candidate exclusion from victory calculations.

### Citations

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L79-80)
```csharp
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L146-146)
```csharp
        var pubkey = pubkeyBytes.ToHex();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L548-568)
```csharp
        var candidateVotes = State.CandidateVotes[candidatePublicKey];
        if (candidateVotes == null)
        {
            candidateVotes = new CandidateVote
            {
                Pubkey = ByteStringHelper.FromHexString(candidatePublicKey),
                ObtainedActiveVotingRecordIds = { voteId },
                ObtainedActiveVotedVotesAmount = amount,
                AllObtainedVotedVotesAmount = amount
            };
        }
        else
        {
            candidateVotes.ObtainedActiveVotingRecordIds.Add(voteId);
            candidateVotes.ObtainedActiveVotedVotesAmount =
                candidateVotes.ObtainedActiveVotedVotesAmount.Add(amount);
            candidateVotes.AllObtainedVotedVotesAmount =
                candidateVotes.AllObtainedVotedVotesAmount.Add(amount);
        }

        State.CandidateVotes[candidatePublicKey] = candidateVotes;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-196)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L229-235)
```csharp
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L16-16)
```csharp
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L90-94)
```csharp
        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L40-41)
```csharp
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
```
