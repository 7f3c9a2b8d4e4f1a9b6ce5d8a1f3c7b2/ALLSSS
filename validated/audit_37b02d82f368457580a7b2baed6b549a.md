# Audit Report

## Title
ImpliedIrreversibleBlockHeight Monotonicity Violation Due to Pre-Validation Mutation

## Summary
The `RecoverFromUpdateValue()` function overwrites `ImpliedIrreversibleBlockHeight` before validation occurs, causing the `LibInformationValidationProvider` to compare the provided value against itself rather than against the original state value. This allows malicious miners to decrease the `ImpliedIrreversibleBlockHeight`, potentially causing the Last Irreversible Block (LIB) height to move backwards and violating blockchain finality guarantees.

## Finding Description

The vulnerability exists in the consensus validation flow where state mutation occurs before security validation.

**Root Cause - Pre-Validation Mutation:**

In `ValidateBeforeExecution`, the contract retrieves the current round from state, then immediately mutates it by calling `RecoverFromUpdateValue` before any validation checks occur: [1](#0-0) [2](#0-1) 

The `RecoverFromUpdateValue` method directly overwrites the `ImpliedIrreversibleBlockHeight` field in the base round without any validation: [3](#0-2) 

This means that if the original state had `ImpliedIrreversibleBlockHeight = 1000` and the attacker provides `ImpliedIrreversibleBlockHeight = 500`, after line 19 of `Round_Recover.cs` executes, `baseRound[pubkey].ImpliedIrreversibleBlockHeight` is now `500`.

**Broken Validation Logic:**

After the mutation, the validation context is created with the already-modified `baseRound`: [4](#0-3) 

The `LibInformationValidationProvider` is then added to validate LIB information: [5](#0-4) 

However, the validator compares the modified `baseRound` against `providedRound`. Critically, `providedRound` is defined as `ExtraData.Round`: [6](#0-5) 

The validation check attempts to detect if the `ImpliedIrreversibleBlockHeight` decreased: [7](#0-6) 

Since `baseRound[pubkey].ImpliedIrreversibleBlockHeight` was already set to the provided value (500) during recovery, the check becomes: `500 > 500`, which is always `false`. The validation can never detect a decrease.

**State Persistence:**

If validation passes (which it always will), the malicious value is persisted to state during transaction execution: [8](#0-7) 

**LIB Impact:**

The corrupted `ImpliedIrreversibleBlockHeight` values are used to calculate the Last Irreversible Block: [9](#0-8) 

The LIB calculator retrieves sorted heights from all miners and selects the value at position `(count-1)/3` for Byzantine fault tolerance: [10](#0-9) [11](#0-10) 

By providing lower values, malicious miners can cause the calculated LIB to decrease, violating finality.

## Impact Explanation

**Critical Consensus Integrity Violation:**

The `ImpliedIrreversibleBlockHeight` directly determines the Last Irreversible Block (LIB), which is the foundation of blockchain finality. When the LIB moves backwards:

1. **Finality Guarantee Broken**: Blocks previously considered finalized can become reversible
2. **Double-Spend Risk**: Transactions thought to be irreversible can be reorganized
3. **Cross-Chain Security Impact**: Sidechains and bridges rely on parent chain LIB heights for security decisions
4. **Consensus Trust Violation**: The fundamental assumption that finalized blocks remain finalized is broken

**Affected Parties:**
- All network participants trusting in block finality
- Cross-chain protocols depending on LIB verification
- Exchanges and payment processors using LIB for transaction finality
- DApps that consider transactions final based on LIB status

**Severity:** CRITICAL - This violates a core blockchain invariant (monotonically increasing finality) and enables potential double-spend attacks.

## Likelihood Explanation

**Access Requirements:**

The only access control is verification that the sender is in the miner list: [12](#0-11) 

Any active miner can exploit this vulnerability.

**Attack Complexity:** LOW
- Attacker must be an active miner in the consensus set
- No complex state setup or timing requirements
- Simply submit an `UpdateValue` transaction with a lower `ImpliedIrreversibleBlockHeight`
- The broken validation logic will not detect the decrease
- The malicious value will be persisted to state

**Feasibility:** HIGH
- Exploitable through normal consensus operations
- No special conditions required beyond being a miner
- Can be executed in any round during block production

**Detection:** The validation mechanism that should prevent this is completely bypassed due to the pre-validation mutation, making the attack undetectable by the current security controls.

## Recommendation

**Fix: Preserve Original State for Validation**

The validation must compare against the original state value, not the mutated value. The fix should:

1. **Option 1 - Deep Copy Before Mutation**: Create a deep copy of the original `ImpliedIrreversibleBlockHeight` before calling `RecoverFromUpdateValue`, then use this original value in validation.

2. **Option 2 - Validate Before Recovery**: Perform the monotonicity check before mutating `baseRound`:

```csharp
// In ValidateBeforeExecution, before line 46:
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    // Validate BEFORE mutation
    var pubkey = extraData.SenderPubkey.ToHex();
    if (extraData.Round.RealTimeMinersInformation.ContainsKey(pubkey) &&
        extraData.Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
        baseRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
        baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
        extraData.Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "ImpliedIrreversibleBlockHeight cannot decrease." 
        };
    }
    
    // Now safe to mutate
    baseRound.RecoverFromUpdateValue(extraData.Round, pubkey);
}
```

**Option 2 is preferred** as it validates against the true original state before any mutation occurs, ensuring the monotonicity check functions correctly.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. **Initial State**: Miner has `ImpliedIrreversibleBlockHeight = 1000` in state
2. **Attack**: Miner submits `UpdateValue` with `ImpliedIrreversibleBlockHeight = 500`
3. **Expected Behavior**: Validation should reject (500 < 1000)
4. **Actual Behavior**: 
   - Line 47 of `AEDPoSContract_Validation.cs` calls `RecoverFromUpdateValue`
   - Line 19 of `Round_Recover.cs` sets `baseRound[pubkey].ImpliedIrreversibleBlockHeight = 500`
   - Line 25-26 of `LibInformationValidationProvider.cs` checks: `500 > 500` = `false`
   - Validation passes incorrectly
   - State is updated with the malicious value 500
5. **Result**: LIB can move backwards from 1000 to 500, breaking finality

The test should verify that:
- The original state value was 1000
- The provided value is 500  
- Validation incorrectly passes
- State is updated to 500
- LIB calculation uses the corrupted value

This demonstrates a direct violation of the monotonicity invariant for `ImpliedIrreversibleBlockHeight`.

## Notes

This vulnerability exists because the validation architecture assumes `baseRound` contains original state values, but the code mutates `baseRound` before validation executes. The fix must ensure validation compares provided values against true original state, not against already-mutated state.

The severity is CRITICAL because this directly breaks blockchain finality guarantees - a fundamental security property that all blockchain users depend on.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-19)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-19)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
