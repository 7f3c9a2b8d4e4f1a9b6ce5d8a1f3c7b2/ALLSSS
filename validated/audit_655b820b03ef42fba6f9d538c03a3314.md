# Audit Report

## Title
Vote Counting Inconsistency Allows Governance Bypass via Strategic Member Removal

## Summary
The Association contract's `CheckEnoughVoteAndApprovals` function contains a critical logic inconsistency where approval, rejection, and abstention vote counts are filtered by current organization membership, but the total vote threshold check counts ALL votes including those from removed members. This allows attackers with majority control to manipulate governance by removing dissenting voters after votes are cast, enabling malicious proposals to pass despite legitimate rejection.

## Finding Description

The vulnerability exists in the vote counting logic that determines proposal release eligibility. The system performs inconsistent membership filtering across four vote count checks:

**Filtered Checks:**
Approval counting filters by current membership at [1](#0-0) 

Rejection counting filters by current membership at [2](#0-1) 

Abstention counting filters by current membership at [3](#0-2) 

**Unfiltered Check (Vulnerability):**
The MinimalVoteThreshold check counts ALL votes without filtering by current membership at [4](#0-3) 

This inconsistency is exploitable because organizations can remove members via `RemoveMember` [5](#0-4) , callable by the organization itself through proposal execution.

The `Release` method validates proposals using `IsReleaseThresholdReached` [6](#0-5) , which calls the vulnerable `CheckEnoughVoteAndApprovals` function [7](#0-6) .

**Attack Execution:**
1. Organization has 10 members with thresholds: MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=3
2. Malicious proposal P1 receives 5 approvals and 4 rejections (9 total votes)
3. P1 is blocked because 4 rejections > 3 (MaximalRejectionThreshold)
4. Attackers pass proposal via `ChangeOrganizationThreshold` [8](#0-7)  to reduce MinimalVoteThreshold from 8 to 5
5. Attackers pass proposals to remove 4 rejecting members via `RemoveMember`
6. Organization now has 6 members; validation at [9](#0-8)  passes (5 ≤ 6)
7. P1 re-evaluation: rejections filtered=0, approvals filtered=5≥5, total votes unfiltered=9≥5
8. P1 passes and executes despite legitimate rejection

## Impact Explanation

**Governance Integrity Violation:** This vulnerability fundamentally breaks the rejection mechanism in Association-based governance. Removed members' votes artificially inflate participation counts while their rejections are ignored, allowing legitimately failed proposals to pass.

**Concrete Impacts:**
- **Unauthorized Proposal Execution:** Attackers can execute arbitrary contract calls that were properly rejected by organization members
- **Treasury Theft:** Organizations controlling funds can have assets stolen via malicious transfer proposals
- **Configuration Hijacking:** Critical system configurations governed by Association contracts can be maliciously modified
- **Governance Capture:** Once attackers achieve initial control to remove dissenters, they can maintain indefinite control by removing any new opposing members

**Affected Systems:**
- All Association-governed organizations including multi-signature wallets, DAOs, and committee-based governance structures
- Cross-chain governance if Association contracts control bridge operations
- Treasury and economic contracts managed by Association organizations
- System upgrades and configuration changes requiring Association approval

## Likelihood Explanation

**Attacker Prerequisites:**
- Control of sufficient members to meet MinimalApprovalThreshold (typically ~50% of organization)
- Membership in ProposerWhiteList (standard for organization members)
- Coordination to pass sequential proposals

**Attack Complexity:** MEDIUM - Requires multiple sequential steps using only standard contract functions without special permissions beyond normal organization membership.

**Feasibility:** HIGH for valuable organizations
- Organizations with significant treasury holdings present strong economic incentives
- Insider threats or coordinated attacks can achieve the required ~50% initial control
- No on-chain detection mechanisms exist for this attack pattern
- Attack appears as normal governance activity until malicious proposal executes

**Economic Rationality:**
- Cost: Minimal (only gas fees for proposals and voting)
- Benefit: Complete governance control, access to treasury, arbitrary contract execution
- Risk/Reward: Extremely favorable for high-value targets

## Recommendation

Modify `CheckEnoughVoteAndApprovals` to filter total vote counts by current membership, ensuring consistency with other vote counting logic:

The total vote threshold check should filter votes by current membership similar to the approval, rejection, and abstention checks. Change the unfiltered concatenation count to filter by organization membership:

Replace the unfiltered total vote count with filtered counting that only includes votes from current organization members, ensuring removed members' votes do not contribute to MinimalVoteThreshold satisfaction.

## Proof of Concept

A proof of concept test would demonstrate:
1. Create organization with 10 members, set thresholds: MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=3
2. Create malicious proposal P1, receive 5 approvals and 4 rejections
3. Verify P1 is blocked (4 rejections > 3 MaximalRejectionThreshold)
4. Create and pass proposal P2 to call ChangeOrganizationThreshold reducing MinimalVoteThreshold to 5
5. Create and pass 4 proposals (P3-P6) to call RemoveMember on the 4 rejecting members
6. Verify organization now has 6 members
7. Call Release on P1
8. Verify P1 successfully releases and executes despite original rejection

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L31-31)
```csharp
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-72)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
