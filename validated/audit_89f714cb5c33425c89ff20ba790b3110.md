# Audit Report

## Title
InValue Grinding Attack Enables Mining Order Manipulation in AEDPoS Consensus

## Summary
The AEDPoS consensus contract fails to cryptographically verify that InValues are generated using the legitimate algorithm. Miners can substitute arbitrary hash values as InValues to predetermine their mining order in future rounds, violating the fairness guarantees of the commit-reveal randomness scheme.

## Finding Description

The AEDPoS consensus uses a commit-reveal scheme where miners commit to `OutValue = Hash(InValue)` and later reveal the InValue. The revealed InValue is used to calculate a signature via XOR with previous round signatures, which determines the miner's position in the next round through modulo arithmetic. [1](#0-0) [2](#0-1) 

**Critical Vulnerability:** The validation logic only verifies that `Hash(previousInValue) == previousOutValue` but does not verify HOW the InValue was generated: [3](#0-2) 

While honest nodes generate InValues by signing round data deterministically, the contract accepts ANY 32-byte hash value that satisfies the hash relationship. A malicious miner can exploit this by:

1. Modifying their node to bypass the legitimate InValue generation algorithm
2. Trying thousands of random hash values as InValue candidates
3. For each candidate, calculating: `signature = XOR(InValue, known_round_signatures)` and `order = (signature.ToInt64() % minersCount) + 1`
4. Selecting an InValue that yields a favorable position (e.g., order 1-2)
5. Committing `OutValue = Hash(chosen_InValue)` when producing their block
6. Later revealing the chosen InValue, which passes validation

The off-chain InValue generation happens in SecretSharingService but is not enforced on-chain: [4](#0-3) 

When blocks are produced, OutValue and Signature are calculated and published: [5](#0-4) 

The contract processes these values and determines the next round order: [6](#0-5) 

Round orders for the next round are assigned based on the ground signatures: [7](#0-6) 

## Impact Explanation

**Economic Harm:** Miners with early positions (order 1-2) process transactions first in each round, likely collecting more transaction fees. Over time, grinding miners accumulate significantly more rewards than honest miners.

**Consensus Integrity:** The commit-reveal scheme is designed to ensure unpredictable, fair order selection. This vulnerability allows systematic manipulation, breaking the core security assumption.

**Centralization Risk:** Grinding creates a "rich get richer" dynamic where technically sophisticated miners gain persistent advantages, threatening network decentralization.

**Detection Impossibility:** The on-chain contract cannot distinguish ground InValues from legitimate ones since both satisfy `Hash(InValue) == OutValue`. There is no VRF or cryptographic proof of correct generation.

## Likelihood Explanation

**Attacker Profile:** Any active miner running their own node software.

**Technical Barriers:** LOW - SHA256 hashing is extremely fast (millions of hashes per second on consumer hardware). A miner can try thousands of InValue candidates in milliseconds before committing.

**Economic Incentive:** HIGH - Increased transaction fees with zero risk of detection or penalty.

**Operational Constraints:** NONE - The attack is entirely off-chain. The contract validation cannot detect grinding since it only checks hash consistency, not generation method.

**Feasibility:** The attack is most effective for miners producing blocks late in a round (when most signatures are already visible), but provides advantage even with partial signature knowledge.

## Recommendation

Implement cryptographic proof of correct InValue generation using Verifiable Random Functions (VRF). The contract should verify that InValue was derived from a VRF proof over the round data:

1. Replace `InValue = Hash(Sign(round_data))` with VRF-based generation
2. Add VRF proof validation in `UpdateValueValidationProvider.ValidatePreviousInValue`
3. Verify the proof on-chain before accepting the InValue
4. This makes it cryptographically impossible to grind InValues while maintaining verifiability

The AElf codebase already has VRF infrastructure (`ECVrfProve`, `ECVrfVerify`) that could be adapted for this purpose.

## Proof of Concept

A malicious miner would modify their node with code similar to:

```csharp
// Instead of legitimate GenerateInValueAsync, use grinding:
private Hash GrindFavorableInValue(Round previousRound, int desiredOrder) {
    var knownSignatures = previousRound.RealTimeMinersInformation.Values
        .Select(m => m.Signature)
        .Aggregate(Hash.Empty, (curr, sig) => HashHelper.XorAndCompute(curr, sig));
    
    for (int i = 0; i < 1000000; i++) {
        var candidateInValue = HashHelper.ComputeFrom(Guid.NewGuid().ToByteArray());
        var resultingSignature = HashHelper.XorAndCompute(candidateInValue, knownSignatures);
        var resultingOrder = Math.Abs(resultingSignature.ToInt64() % minersCount) + 1;
        
        if (resultingOrder == desiredOrder) {
            return candidateInValue; // Found favorable InValue
        }
    }
    return candidateInValue; // Fallback
}
```

The contract would accept this ground InValue because validation only checks `Hash(InValue) == OutValue`, not the generation process.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-21)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L65-93)
```csharp
        Assert(triggerInformation.InValue != null, "In value should not be null.");

        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
        var previousInValue = Hash.Empty; // Just initial previous in value.

        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-264)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-37)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```
