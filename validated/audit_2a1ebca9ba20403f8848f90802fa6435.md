# Audit Report

## Title
Quadratic Voting Results Corruption Due to Inconsistent Amount Tracking

## Summary
The Vote contract contains a critical accounting mismatch in quadratic voting that causes vote tallies to become negative. During voting, `Results[option]` is incremented by 1, but during withdrawal, it is decremented by the full token amount, completely corrupting voting results.

## Finding Description

The vulnerability exists in how the Vote contract handles quadratic voting across the vote and withdrawal operations.

**During Voting:** When a user votes with quadratic voting enabled, the contract calculates the token amount as `ticketCost * currentVotesCount` and stores this in the voting record. [1](#0-0) 

However, when updating the voting results, the contract conditionally passes either `1` (for quadratic voting) or `amount` (for regular voting) to the `UpdateVotingResult` function. [2](#0-1) 

The `UpdateVotingResult` function then increments `Results[option]` by whatever value was passed - which is `1` for quadratic voting. [3](#0-2) 

**During Withdrawal:** The withdrawal logic retrieves the voting record and decrements `Results[option]` by `votingRecord.Amount`, which contains the full token amount that was locked. [4](#0-3) 

**The Critical Mismatch:** For quadratic voting:
- Vote operation: Increments `Results[option]` by **1**
- Withdraw operation: Decrements `Results[option]` by **token amount** (e.g., 100, 200, 300...)
- Result: Vote counts become negative after withdrawals

The `Sub` method uses checked arithmetic but only prevents underflow beyond `long.MinValue`, not negative values within the valid range. [5](#0-4) 

## Impact Explanation

This vulnerability has critical impact on voting system integrity:

1. **Negative Vote Counts**: After withdrawals, `Results[option]` becomes negative (e.g., if 2 votes were cast incrementing by 1 each, withdrawing one with 200 tokens locked results in 2 - 200 = -198)

2. **Corrupted Voting Results**: Vote tallies no longer represent actual voting preferences, making the results completely meaningless

3. **Broken Governance**: Any governance decisions based on these vote results will be made using corrupted data, potentially leading to incorrect policy decisions

4. **Feature Unusable**: The entire quadratic voting feature is non-functional, as any withdrawal immediately corrupts the results

This affects all participants in quadratic voting activities, sponsors who rely on accurate vote counts for decision-making, and any downstream governance systems that consume these voting results.

## Likelihood Explanation

The likelihood is **Very High**:

1. **No Privileges Required**: Any regular user can trigger this by participating in quadratic voting
2. **Normal Operations**: Triggered through standard vote and withdraw operations that users are expected to perform
3. **Simple Setup**: Only requires a voting item with `IsQuadratic = true`
4. **Immediate Observable**: The bug manifests immediately upon the first withdrawal in any quadratic voting session
5. **No Existing Tests**: Code search reveals no tests for quadratic voting functionality, suggesting this feature was never properly validated

The vulnerability will trigger automatically whenever any user exercises their legitimate right to withdraw votes in a quadratic voting scenario.

## Recommendation

The fix should ensure consistent accounting between voting and withdrawal operations. Modify line 119 in the `Vote` method to pass the actual token amount for both quadratic and non-quadratic voting:

```csharp
UpdateVotingResult(votingItem, input.Option, amount);
```

This ensures that both `Results[option]` and `VotesAmount` are incremented by the token amount during voting, matching the decrement logic in withdrawal.

Alternatively, if the design intent is to count votes (not token amounts) in `Results[option]` for quadratic voting, then the withdrawal logic must be updated to decrement by `1` for quadratic voting items instead of by the token amount.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_Withdrawal_Corrupts_Results()
{
    // Register a quadratic voting item with ticket cost of 100
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { "OptionA", "OptionB" },
        AcceptedCurrency = "ELF",
        IsLockToken = true,
        IsQuadratic = true,
        TicketCost = 100
    };
    await VoteContractStub.Register.SendAsync(input);
    input.Options.Clear();
    var votingItemId = HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(DefaultSender));

    // User casts two votes (first locks 100 tokens, second locks 200 tokens)
    var user = Accounts[1];
    var voterStub = GetVoteContractTester(user.KeyPair);
    
    await voterStub.Vote.SendAsync(new VoteInput { VotingItemId = votingItemId, Option = "OptionA", Amount = 0 });
    await voterStub.Vote.SendAsync(new VoteInput { VotingItemId = votingItemId, Option = "OptionA", Amount = 0 });

    // Check results after voting - should be 2 (two votes cast)
    var resultAfterVote = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 });
    resultAfterVote.Results["OptionA"].ShouldBe(2); // Incremented by 1 twice

    // Get vote IDs and withdraw the second vote
    var voteIds = await voterStub.GetVotingIds.CallAsync(new GetVotingIdsInput { Voter = Address.FromPublicKey(user.KeyPair.PublicKey), VotingItemId = votingItemId });
    await voterStub.Withdraw.SendAsync(new WithdrawInput { VoteId = voteIds.ActiveVotes[1] });

    // Check results after withdrawal - VULNERABILITY: becomes negative!
    var resultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 });
    // Expected: 1 (one vote remaining)
    // Actual: 2 - 200 = -198 (decremented by token amount instead of vote count)
    resultAfterWithdraw.Results["OptionA"].ShouldBeLessThan(0); // This proves the vulnerability
}
```

**Notes:**
- The vulnerability is present in the production Vote contract code
- It specifically affects quadratic voting (when `IsQuadratic = true`)
- Regular voting is not affected as it passes `amount` in both operations
- No tests exist for quadratic voting in the codebase, which allowed this bug to go undetected
- The SafeMath `Sub` operation allows negative results within the `long` range, so no exception is thrown

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-108)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }

        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L176-177)
```csharp
        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L215-216)
```csharp
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
