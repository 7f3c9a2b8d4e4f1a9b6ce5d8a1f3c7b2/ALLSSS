# Audit Report

## Title
Pre-Validation State Corruption in UpdateValue Consensus Validation Allows Bypassing Last Irreversible Block Height Checks

## Summary
The `ValidateBeforeExecution` method in the AEDPoS consensus contract modifies the trusted `baseRound` object with untrusted attacker-provided data before validation occurs. This causes the `LibInformationValidationProvider` to compare the corrupted value against itself, making the Last Irreversible Block (LIB) height monotonicity check ineffective and allowing miners to set arbitrary backwards LIB heights, violating a critical consensus invariant.

## Finding Description

The vulnerability exists in the consensus validation flow where the order of operations corrupts the validation baseline before checks are performed.

In `ValidateBeforeExecution`, the current round information is retrieved from state: [1](#0-0) 

For `UpdateValue` behavior, the method then immediately modifies this `baseRound` object in-place with untrusted data from the block header BEFORE any validation checks: [2](#0-1) 

The `RecoverFromUpdateValue` method directly overwrites critical fields including `ImpliedIrreversibleBlockHeight` in the `baseRound` object: [3](#0-2) 

Since `MappedState` returns a reference to the cached protobuf object rather than a copy: [4](#0-3) 

The validation context is then created with this already-corrupted `baseRound`: [5](#0-4) 

For `UpdateValue` behavior, the `LibInformationValidationProvider` is added to validate LIB information: [6](#0-5) 

The provider attempts to ensure `ImpliedIrreversibleBlockHeight` doesn't decrease, but because `baseRound` was already corrupted, it compares the attacker-provided value against itself: [7](#0-6) 

After validation incorrectly passes, the execution phase persists the malicious value to state: [8](#0-7) 

The flaw is that the intended check should compare the ORIGINAL stored value (e.g., 1000) against the NEW attacker-provided value (e.g., 500) to detect backwards movement. However, because the modification happens before validation, the check compares 500 > 500, which is false, causing validation to pass even when the LIB height moves backwards.

## Impact Explanation

This vulnerability allows any malicious miner to set their `ImpliedIrreversibleBlockHeight` to arbitrary values, including moving it backwards, which directly violates the consensus invariant that LIB heights must be monotonically increasing.

**Concrete Harms:**

1. **Consensus State Corruption**: Individual miners' `ImpliedIrreversibleBlockHeight` values in the stored consensus state can move backwards (e.g., from height 1000 to 500), corrupting the protocol's consensus records.

2. **LIB Calculation Disruption**: The confirmed LIB is calculated using miners' implied heights. While `ProcessUpdateValue` has a safeguard preventing the confirmed LIB from decreasing, malicious miners reporting backwards heights can prevent the LIB from advancing properly. If multiple miners coordinate this attack, the calculated LIB value could stagnate: [9](#0-8) 

3. **Protocol Invariant Violation**: The fundamental guarantee that finality markers monotonically increase is broken, undermining trust in the consensus mechanism.

4. **Potential DoS of Finality**: If enough miners report low implied heights, the Byzantine fault-tolerant LIB calculation could be compromised, potentially halting finality advancement across the network.

The severity is **High** because it directly violates a critical consensus invariant and allows miners to corrupt consensus state, though immediate double-spend attacks require additional conditions.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the current round (verified by `MiningPermissionValidationProvider`) [10](#0-9) 
- Can craft consensus header information when producing blocks
- No special privileges beyond scheduled mining rights

**Attack Complexity:**
The attack is straightforward:
1. Malicious miner waits for their scheduled time slot
2. Crafts a block with `extraData.Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` set to a value lower than their current stored value
3. Includes valid `OutValue` and `Signature` to pass other validation checks
4. The corrupted LIB validation passes because it compares the same value against itself
5. Block is accepted and the backwards LIB height is persisted to state

**Probability:** High - Any compromised or malicious miner can execute this during their normal mining slot without detection. The validation appears to pass normally, making the attack difficult to detect until consensus issues manifest.

## Recommendation

The fix requires preserving the original `baseRound` value for validation purposes. The recommended solution is to perform the `RecoverFromUpdateValue` operation AFTER validation, or create a copy for validation:

**Option 1: Reorder operations (Recommended)**
```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // Create validation context BEFORE modifying baseRound
    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,  // Unmodified original
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData
    };

    // Run validation with UNMODIFIED baseRound
    var service = new HeaderInformationValidationService(validationProviders);
    var validationResult = service.ValidateInformation(validationContext);
    
    return validationResult;
}
```

**Option 2: Clone for validation**
```csharp
// Clone baseRound before modification
var baseRoundForValidation = baseRound.Clone();

if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRoundForValidation,  // Use unmodified clone
    // ... rest of context
};
```

## Proof of Concept

The following test demonstrates that a miner can successfully set their `ImpliedIrreversibleBlockHeight` backwards by exploiting the pre-validation state corruption:

```csharp
[Fact]
public async Task Exploit_BackwardsLIBHeight_BypassesValidation()
{
    // Setup: Create initial state with miner having ImpliedIrreversibleBlockHeight = 1000
    var miner = GetMinerKeyPair();
    var currentRound = await SetupRoundWithLIBHeight(miner.PublicKey, 1000);
    
    // Attacker action: Craft block with backwards LIB height = 500
    var maliciousExtraData = new AElfConsensusHeaderInformation
    {
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        SenderPubkey = miner.PublicKey.ToByteString(),
        Round = new Round
        {
            RealTimeMinersInformation =
            {
                {
                    miner.PublicKey.ToHex(),
                    new MinerInRound
                    {
                        ImpliedIrreversibleBlockHeight = 500, // Backwards!
                        OutValue = Hash.FromString("test"),
                        Signature = Hash.FromString("sig")
                    }
                }
            }
        }
    };
    
    // Execute: Validation should reject but actually passes
    var validationResult = await ConsensusStub.ValidateConsensusBeforeExecution.CallAsync(
        maliciousExtraData.ToPendingBlockHeader()
    );
    
    // Verify: Validation incorrectly passes
    Assert.True(validationResult.Success); // BUG: Should be false but is true
    
    // Verify: Malicious value persists to state
    var updateInput = ExtractUpdateValueInput(maliciousExtraData);
    await ConsensusStub.UpdateValue.SendAsync(updateInput);
    
    var updatedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var storedHeight = updatedRound.RealTimeMinersInformation[miner.PublicKey.ToHex()].ImpliedIrreversibleBlockHeight;
    
    Assert.Equal(500, storedHeight); // Backwards LIB height successfully persisted
    Assert.True(storedHeight < 1000); // Invariant violated: LIB moved backwards
}
```

This test confirms that the validation incorrectly allows backwards LIB heights and persists the corrupted value to state, violating the consensus invariant.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L240-249)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-21)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```
