# Audit Report

## Title
Missing Round ID Validation Allows Stale Consensus Transactions to Corrupt Future Rounds

## Summary
The `UpdateValue` and `UpdateTinyBlockInformation` methods fail to validate that incoming transactions belong to the current round before applying state updates. This missing validation allows stale consensus transactions from previous rounds to corrupt future round state, breaking the cryptographic signature chain and compromising consensus integrity.

## Finding Description

The vulnerability exists in the consensus transaction execution flow. The protobuf definition includes a `round_id` field in both `UpdateValueInput` and `TinyBlockInput` with the explicit purpose "To ensure the values to update will be apply to correct round by comparing round id": [1](#0-0) 

When consensus transactions are generated, they correctly populate this field by extracting it from the current round: [2](#0-1) 

For tiny blocks, the field is also populated correctly: [3](#0-2) 

However, when these transactions execute, the `round_id` is never validated. The `ProcessUpdateValue` method retrieves the current round from state and directly applies updates without checking if the input's round matches: [4](#0-3) 

Similarly, `ProcessTinyBlock` lacks any round validation: [5](#0-4) 

The `PreCheck` method only validates miner list membership, not round number: [6](#0-5) 

While `ValidateConsensusBeforeExecution` validates block headers, it operates on the header's `extraData.Round` object, not on individual transaction input fields: [7](#0-6) 

This creates a critical gap where block header validation passes (checking Round N+1 header via the `extraData.Round.RoundId` field), but transaction execution corrupts state (applying Round N data from the transaction's `input.RoundId` to Round N+1 state).

## Impact Explanation

**Consensus State Corruption**: When a stale UpdateValue transaction executes against the wrong round, it writes incorrect consensus data including `OutValue`, `Signature`, `PreviousInValue`, `ImpliedIrreversibleBlockHeight`, `ProducedBlocks`, `SupposedOrderOfNextRound`, and tuning information into the wrong round's miner information. This breaks the VRF signature chain required for random number generation and corrupts the LIB calculation mechanism.

**Random Number Compromise**: The consensus system relies on a chain of VRF signatures for randomness. The signature validation checks occur during consensus processing: [8](#0-7) 

Applying signatures from the wrong round breaks this cryptographic chain and compromises the random number generation that other protocol components depend on.

**LIB Height Corruption**: The Last Irreversible Block calculation depends on accurate round data from miners' `ImpliedIrreversibleBlockHeight` values: [9](#0-8) 

Corrupted `ImpliedIrreversibleBlockHeight` values lead to incorrect finality determinations, potentially causing chain reorganization issues or finality failures.

**Severity**: Medium - causes consensus state corruption compromising protocol integrity. While there is no direct fund theft, the corruption of consensus state, VRF randomness, and LIB calculations could cascade into consensus failures and chain instability.

## Likelihood Explanation

**Feasibility**: A malicious block producer in Round N+1 could include a captured UpdateValue or TinyBlock transaction from Round N in their block. Since `UpdateValue` and `UpdateTinyBlockInformation` are public methods and `PreCheck` only validates miner list membership (not round number), the transaction would execute and corrupt Round N+1 state with Round N data.

**Attack Vector**: 
1. Miner generates UpdateValue transaction during Round N with `input.RoundId = N`
2. Round transitions to N+1 via NextRound transaction which updates the round number in state
3. Malicious block producer in Round N+1 includes the stale transaction in their block
4. Block header validation passes because it validates the Round N+1 object in `extraData`
5. Transaction execution applies Round N consensus data to Round N+1 without validating `input.RoundId`

**Probability**: Medium - requires either network delays causing transaction reordering, malicious block producer behavior, or network partitions during round transitions. This is realistic in distributed consensus systems, especially under adverse network conditions or when a single malicious miner attempts to disrupt consensus.

## Recommendation

Add round ID validation in both `ProcessUpdateValue` and `ProcessTinyBlock` methods to ensure the input's `round_id` matches the current round's `RoundIdForValidation`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Add round ID validation
    Assert(updateValueInput.RoundId == currentRound.RoundIdForValidation, 
        "Round ID mismatch: transaction belongs to a different round.");

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ... rest of the method
}

private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Add round ID validation
    Assert(tinyBlockInput.RoundId == currentRound.RoundIdForValidation,
        "Round ID mismatch: transaction belongs to a different round.");

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ... rest of the method
}
```

This ensures that the explicit purpose stated in the protobuf definition ("To ensure the values to update will be apply to correct round by comparing round id") is actually enforced during transaction execution.

## Proof of Concept

A proof of concept would require:
1. Setting up an AElf test chain with multiple miners
2. Capturing an `UpdateValue` transaction generated in Round N
3. Forcing a round transition to Round N+1
4. Having a malicious miner include the stale Round N transaction in a Round N+1 block
5. Observing that the transaction executes successfully and corrupts Round N+1 state with Round N data

The test would verify that `State.Rounds[N+1]` contains data from the Round N transaction after execution, demonstrating the state corruption.

### Citations

**File:** protobuf/aedpos_contract.proto (L199-200)
```text
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L40-40)
```csharp
            RoundId = RoundIdForValidation,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L159-159)
```csharp
                                RoundId = round.RoundIdForValidation,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L76-81)
```csharp
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```
