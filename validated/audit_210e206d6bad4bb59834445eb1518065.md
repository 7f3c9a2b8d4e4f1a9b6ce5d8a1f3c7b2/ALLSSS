# Audit Report

## Title
Incomplete Token Distribution Due to Outdated SymbolList in TakeSnapshot Causing Permanent Reward Loss

## Summary
The `TakeSnapshot()` function in the Election contract retrieves Treasury's `SymbolList` and passes it to `DistributeProfits()` for SubsidyHash and WelfareHash schemes. The `DistributeProfits()` method contains a critical design flaw: when `AmountsMap` has ANY entries, it processes ONLY those symbols and ignores all other tokens in the scheme's `ReceivedTokenSymbols`. This causes permanent loss of rewards when `SymbolList` is incomplete, as the distribution period increments regardless, preventing future redistribution of missed tokens.

## Finding Description

The vulnerability exists in a three-component interaction that breaks the invariant that all contributed tokens should be distributed:

**Component 1 - Entry Point:** The Election contract's `TakeSnapshot()` method retrieves the symbol list from Treasury and creates an amounts map for distribution. [1](#0-0) 

The symbol list is obtained from Treasury's `GetSymbolList()`, which returns a manually configured list that may not include all tokens present in the system. [2](#0-1) 

**Component 2 - Root Cause:** The `DistributeProfits()` method has a critical conditional that processes ONLY the symbols explicitly provided in `AmountsMap` when it contains ANY entries. The fallback to `ReceivedTokenSymbols` (which tracks ALL tokens ever contributed to the scheme) is in an `else` block that NEVER executes when `AmountsMap` is non-empty. [3](#0-2) 

This design flaw means that even though schemes are initialized with `IsReleaseAllBalanceEveryTimeByDefault = true`, this flag is completely bypassed when `AmountsMap` contains any entries. [4](#0-3) 

**Component 3 - Irreversible Period Increment:** After distribution completes (regardless of whether all tokens were distributed), the `CurrentPeriod` is always incremented. [5](#0-4) 

**Component 4 - Prevention of Retry:** The period validation enforces that only the current period can be processed, making it impossible to retry distribution for a past period. [6](#0-5) 

**Why Protections Fail:**

Treasury's `SymbolList` is initialized with only the native token and must be manually updated via governance. [7](#0-6) [8](#0-7) 

When tokens are contributed to schemes through Treasury donations, they are tracked in `ReceivedTokenSymbols` but there is no validation that Treasury's `SymbolList` includes all these tokens. [9](#0-8) 

When Treasury distributes to sub-schemes (SubsidyHash, WelfareHash), these tokens are transferred and tracked in the sub-scheme's `ReceivedTokenSymbols` as well. [10](#0-9) 

## Impact Explanation

**Direct Financial Harm:**
When Treasury supports multiple tokens (e.g., ELF, USDT) that have been donated and propagated to SubsidyHash and WelfareHash schemes, but Treasury's `SymbolList` only contains `["ELF"]`, the following occurs:

1. Only ELF rewards are distributed to backup candidates and voters
2. USDT and other tokens remain locked in the schemes' virtual addresses
3. These tokens cannot be distributed for that specific period due to the period validation
4. The distribution period advances, making the loss permanent for that term
5. Beneficiaries lose rewards they are entitled to based on their shares

**Affected Parties:**
- Backup node operators expecting subsidy rewards from SubsidyHash
- Token holders/voters expecting welfare dividends from WelfareHash  
- All beneficiaries of profit schemes managed by this distribution mechanism

**Severity Justification:**
- **High Impact**: Permanent loss of rewards for an entire period; funds become effectively locked
- **No Recovery Mechanism**: The period-based distribution model with strict period validation prevents any retroactive fixes
- **Cumulative Effect**: Each term with an incomplete symbol list causes additional, compounding loss
- **Trust Damage**: Users lose confidence in the reward distribution system when entitled rewards are not received

## Likelihood Explanation

**Realistic Scenario:**
1. Treasury is initialized with `SymbolList = ["ELF"]` (as shown in initialization code)
2. Governance later adds new tokens to the ecosystem (e.g., USDT as method fee token)
3. These tokens start flowing through Treasury `Donate()` calls to SubsidyHash/WelfareHash schemes
4. Governance fails to update Treasury's `SymbolList` to include the new token (operational oversight during rapid expansion)
5. The next `TakeSnapshot()` is automatically called by the consensus contract at term end (approximately weekly)
6. Incomplete distribution occurs, locking non-ELF tokens for that period

**Feasibility:**
- **No Attacker Required**: This is an operational failure triggered by normal system operations, not a malicious exploit
- **Automatic Trigger**: `TakeSnapshot()` is called automatically every term by the consensus contract
- **No Safeguards**: The contract lacks any validation to detect that `SymbolList` is incomplete relative to `ReceivedTokenSymbols`
- **Governance Dependency**: Requires perfect coordination between token additions and `SymbolList` updates across multiple governance actions

**Probability:**
Medium to High - As the AElf ecosystem grows and new tokens are integrated, the coordination overhead increases significantly. A single oversight in the multi-step process (add token → enable for fees → update SymbolList) causes immediate, permanent loss for that term.

## Recommendation

**Fix Option 1 - Modify DistributeProfits Logic (Recommended):**
Change the conditional logic to use `ReceivedTokenSymbols` as the authoritative source when `AmountsMap` values are all zero (the current pattern used by TakeSnapshot). This respects the `IsReleaseAllBalanceEveryTimeByDefault` flag:

```csharp
if (input.AmountsMap.Any() && input.AmountsMap.Any(a => a.Value != 0))
{
    // Process explicit amounts
    foreach (var amount in input.AmountsMap)
    {
        var actualAmount = amount.Value;
        profitsMap.Add(amount.Key, actualAmount);
    }
}
else
{
    if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
    {
        // Distribute ALL tokens from ReceivedTokenSymbols
        foreach (var symbol in scheme.ReceivedTokenSymbols)
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            }).Balance;
            profitsMap.Add(symbol, balance);
        }
    }
}
```

**Fix Option 2 - Validation in TakeSnapshot:**
Add validation in `TakeSnapshot()` to ensure `SymbolList` contains all tokens in `ReceivedTokenSymbols` before proceeding with distribution. This prevents the issue but may cause distribution failures requiring governance intervention.

**Fix Option 3 - Remove SymbolList Dependency:**
Modify `TakeSnapshot()` to pass an empty `AmountsMap`, allowing `DistributeProfits()` to use the existing fallback logic that correctly processes all `ReceivedTokenSymbols`.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task IncompleteTokenDistribution_Test()
{
    // 1. Setup: Initialize system with ELF only in SymbolList
    await InitializeTreasuryWithElfOnly();
    
    // 2. Add USDT to system and donate to Treasury
    await CreateAndDonateUSDT();
    
    // 3. Verify USDT flowed to SubsidyHash scheme (tracked in ReceivedTokenSymbols)
    var subsidyScheme = await ProfitContractStub.GetScheme.CallAsync(SubsidySchemeId);
    subsidyScheme.ReceivedTokenSymbols.Contains("USDT").ShouldBeTrue();
    
    // 4. Check USDT balance in scheme's virtual address
    var usdtBalanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = subsidyScheme.VirtualAddress,
        Symbol = "USDT"
    });
    usdtBalanceBefore.Balance.ShouldBeGreaterThan(0);
    
    // 5. Trigger TakeSnapshot (simulating consensus contract call)
    await AEDPoSContractStub.TakeSnapshot.SendAsync(new TakeElectionSnapshotInput
    {
        TermNumber = 1,
        MinedBlocks = 1000,
        RoundNumber = 100
    });
    
    // 6. VULNERABILITY: USDT was NOT distributed (still in virtual address)
    // ELF was distributed, but USDT remains locked
    var usdtBalanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = subsidyScheme.VirtualAddress,
        Symbol = "USDT"
    });
    usdtBalanceAfter.Balance.ShouldBe(usdtBalanceBefore.Balance); // USDT still there!
    
    // 7. Period has advanced, making this permanent for term 1
    var schemeAfter = await ProfitContractStub.GetScheme.CallAsync(SubsidySchemeId);
    schemeAfter.CurrentPeriod.ShouldBe(2); // Period incremented
    
    // 8. Cannot retry period 1 distribution (validation fails)
    var retryResult = await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = SubsidySchemeId,
        Period = 1, // Try to retry period 1
        AmountsMap = { { "USDT", 0 } }
    });
    retryResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    retryResult.TransactionResult.Error.ShouldContain("Invalid period");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L440-454)
```csharp
        var symbolList = State.DividendPoolContract.GetSymbolList.Call(new Empty());
        var amountsMap = symbolList.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L72-75)
```csharp
        State.SymbolList.Value = new SymbolList
        {
            Value = { Context.Variables.NativeSymbol }
        };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-310)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L394-397)
```csharp
    public override SymbolList GetSymbolList(Empty input)
    {
        return State.SymbolList.Value;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-460)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L640-645)
```csharp
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L715-717)
```csharp
        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

```
