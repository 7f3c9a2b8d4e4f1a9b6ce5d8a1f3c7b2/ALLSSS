# Audit Report

## Title
Missing Range Validation for FinalOrderOfNextRound Enables Consensus Disruption via Order Manipulation

## Summary
The AEDPoS consensus contract fails to validate that `FinalOrderOfNextRound` values provided in `TuneOrderInformation` are within the valid range [1, minerCount]. A malicious current miner can submit an `UpdateValue` transaction with out-of-range order values (e.g., 1000 in a 5-miner round), which bypasses validation and corrupts the next round's mining schedule, causing targeted denial-of-service against specific miners and failure of continuous mining prevention mechanisms.

## Finding Description

The vulnerability exists in the validation and processing flow of mining order information for the next round.

**Root Cause - Insufficient Validation:**

The `NextRoundMiningOrderValidationProvider` only validates the count of miners with assigned orders, but does not verify that order values are within the valid range. [1](#0-0) 

This check ensures the count matches, but allows `FinalOrderOfNextRound` to be any value (e.g., 1000, -5, etc.). Moreover, this validation is only applied during `NextRound` behavior, NOT during `UpdateValue` behavior where the corruption occurs. [2](#0-1) 

**Attack Vector - Unchecked Input:**

The `UpdateValueInput` message defines `tune_order_information` as an unrestricted `map<string, int32>`. [3](#0-2) 

**Vulnerable Processing:**

In `ProcessUpdateValue()`, these arbitrary values are directly applied to `FinalOrderOfNextRound` without any range validation. [4](#0-3) 

The `UpdateValueValidationProvider` does not validate the order values at all. [5](#0-4) 

**Impact Propagation:**

When `GenerateNextRoundInformation()` executes, it uses these invalid `FinalOrderOfNextRound` values directly to calculate `ExpectedMiningTime`. [6](#0-5) 

For a miner with order=1000, `miningInterval.Mul(1000)` produces an expected mining time thousands of intervals in the future, making the time slot unreachable within the round duration.

**Order Sequence Corruption:**

The `ableOrders` calculation creates a range [1, minersCount] excluding occupied orders. [7](#0-6) 

With out-of-range orders (e.g., 1000), the order sequence becomes non-contiguous. If more miners didn't mine than available orders remain, this causes an index out of bounds error.

**Continuous Mining Prevention Failure:**

The `BreakContinuousMining()` logic looks for specific order values. When `lastMinerOfNextRound` lookup for `Order == minersCount` returns null due to corrupted orders, the logic returns early. [8](#0-7) 

**Access Control:**

Only current miners can submit `UpdateValue` transactions. [9](#0-8) 

However, this does not prevent a malicious current miner from exploiting the validation gap.

## Impact Explanation

**HIGH Severity Impact:**

1. **Consensus Integrity Violation:** The miner schedule order sequence becomes non-contiguous, breaking the fundamental invariant that orders should be sequential [1, minerCount]. This corrupts the core consensus mechanism's time-slot allocation.

2. **Targeted Denial of Service:** An attacker can assign any target miner an unreachable time slot. With order=1000 in a 5-miner round with 4-second intervals, the victim's `ExpectedMiningTime` would be ~4000 seconds in the future, far beyond the round duration, effectively denying them mining rights.

3. **Safety Mechanism Bypass:** The `BreakContinuousMining()` function ensures proper miner rotation by preventing continuous mining. When expected orders don't exist due to corruption, this critical safety check fails silently, potentially allowing continuous mining attacks.

4. **Potential Round Generation Failure:** If the corruption creates more non-miners than available orders, the next round generation could fail with an index out of bounds exception, causing consensus halt.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Attacker Prerequisites:** The attacker must be a current miner, which is realistic as miners are selected through the election/consensus process. No additional special privileges are required.

2. **Attack Complexity:** The attack is trivial to execute - a single `UpdateValue` transaction with malicious `TuneOrderInformation` (e.g., `{"victim_pubkey": 1000}`). No complex timing, race conditions, or coordination needed.

3. **Success Probability:** The attack succeeds deterministically if the transaction is included in a block. The validation gap ensures the transaction passes all checks.

4. **Economic Rationality:** Only requires transaction fee cost. The high impact (disrupting consensus, denying competitors' mining rights) makes this economically rational for a malicious miner seeking competitive advantage.

5. **Detection:** While the attack leaves evidence in the round state, the damage to that round is already done by the time it's detected.

## Recommendation

Add range validation in `ProcessUpdateValue()` to ensure all `FinalOrderOfNextRound` values are within [1, minersCount]:

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= currentRound.RealTimeMinersInformation.Count, 
           $"Invalid FinalOrderOfNextRound: {tuneOrder.Value}. Must be in range [1, {currentRound.RealTimeMinersInformation.Count}]");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

Additionally, strengthen `NextRoundMiningOrderValidationProvider` to validate the actual order values, not just their count.

## Proof of Concept

A proof of concept would involve:
1. Deploy a test chain with 5 miners
2. Have one malicious miner submit an `UpdateValue` transaction with `TuneOrderInformation = {"victim_pubkey": 1000}`
3. Observe that the transaction is accepted without validation error
4. When `NextRound` is called, verify that the victim miner's `ExpectedMiningTime` is set far in the future (4000+ seconds)
5. Observe that `BreakContinuousMining()` returns early when looking for `Order == 5` (minersCount)
6. Verify the victim miner cannot produce blocks in their assigned unreachable time slot

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-56)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L93-95)
```csharp
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;
```
