# Audit Report

## Title
Off-By-One Error in Continuous Block Production Limit Allows Miners to Exceed Maximum Consecutive Blocks

## Summary
The AEDPoS consensus contract contains an off-by-one error in the continuous block production limit validation. The check uses `BlocksCount < 0` instead of `BlocksCount <= 0`, allowing miners to produce 9 consecutive blocks instead of the intended maximum of 8, providing a 12.5% unfair advantage in block production and mining rewards.

## Finding Description

The vulnerability exists in the validation logic that enforces the maximum number of continuous blocks a miner can produce. The protocol defines `MaximumTinyBlocksCount = 8` [1](#0-0) , which is documented as a mechanism "to avoid too many forks" [2](#0-1)  and "to prevent one miner produced too many continuous blocks" [3](#0-2) .

**Flawed Validation Check:**
The validation provider only rejects when `BlocksCount < 0`, allowing `BlocksCount == 0` to pass [4](#0-3) .

**Flawed Command Generation:**
Similarly, the consensus command generation only forces `NextRound` behavior when `BlocksCount < 0` [5](#0-4) .

**Root Cause Mechanism:**
When a miner produces their first block, `BlocksCount` is initialized to `MaximumTinyBlocksCount - 1 = 7` [6](#0-5) . For each subsequent consecutive block by the same miner, `BlocksCount` is decremented by 1 [7](#0-6) .

**Execution Sequence:**
1. Block 1: Initialize `BlocksCount = 7`
2. Blocks 2-8: `BlocksCount` decrements from 7→6→5→4→3→2→1, all checks pass (not < 0)
3. **Block 9: `BlocksCount = 0`, check `0 < 0` is FALSE, validation PASSES (BUG)**
4. After Block 9: `BlocksCount` decrements to -1
5. Block 10: `BlocksCount = -1`, check `-1 < 0` is TRUE, validation FAILS

The validation occurs before block execution [8](#0-7) , confirming the timing of these checks.

## Impact Explanation

**Consensus Integrity Violation:**
This breaks the core protocol invariant that limits consecutive block production to 8 blocks. The limit is explicitly designed to prevent blockchain centralization and excessive fork creation.

**Unfair Competitive Advantage:**
Any miner can produce 9 consecutive blocks instead of 8, representing a 12.5% excess over the intended limit. This provides:
- Additional mining reward for the 9th block
- Greater influence over consensus compared to compliant miners
- Cumulative advantage as this occurs repeatedly

**Reward Misallocation:**
The extra block production translates directly to extra block rewards, creating systematic unfairness in the reward distribution mechanism that accumulates over time.

**Severity Assessment: Medium**
While this does not enable direct fund theft or complete consensus takeover, it provides measurable unfair advantage in block production power and mining rewards, and violates a documented security invariant.

## Likelihood Explanation

**Automatic Triggering:**
This vulnerability triggers automatically during normal consensus operations - no special actions required beyond producing consecutive blocks.

**Universal Access:**
Any valid miner in the consensus pool can reach this code path. The preconditions are:
- Miner must be in current consensus round (standard for all miners)
- No special permissions or governance actions required

**Deterministic Exploitation:**
The bug occurs deterministically whenever any miner produces maximum consecutive blocks. The flawed check always allows the 9th block when `BlocksCount = 0`.

**Zero Detection Risk:**
The 9th block appears as legitimate according to the validation logic. No monitoring exists to flag this behavior as anomalous.

**Probability Assessment: High**
This will occur naturally in normal operation whenever miners produce consecutive blocks up to the limit.

## Recommendation

Change both validation checks from `BlocksCount < 0` to `BlocksCount <= 0`:

1. In `ContinuousBlocksValidationProvider.cs` line 19:
```csharp
if (latestPubkeyToTinyBlocksCount.BlocksCount <= 0)
```

2. In `AEDPoSContract_ACS4_ConsensusInformationProvider.cs` line 33:
```csharp
State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount <= 0)
```

This ensures that when `BlocksCount` reaches 0 (after 8 blocks), the validation fails and forces the miner to transition to `NextRound` behavior, preventing the 9th block from being produced.

## Proof of Concept

The vulnerability can be demonstrated by tracing the state transitions:

**Test Scenario:** Miner A produces consecutive blocks
- **Block 1:** `BlocksCount = 7` (initialized), validation: N/A (first block)
- **Block 2:** Before: `BlocksCount = 7`, Check: `7 < 0 = FALSE` ✓, After: `BlocksCount = 6`
- **Block 3:** Before: `BlocksCount = 6`, Check: `6 < 0 = FALSE` ✓, After: `BlocksCount = 5`
- **Block 4:** Before: `BlocksCount = 5`, Check: `5 < 0 = FALSE` ✓, After: `BlocksCount = 4`
- **Block 5:** Before: `BlocksCount = 4`, Check: `4 < 0 = FALSE` ✓, After: `BlocksCount = 3`
- **Block 6:** Before: `BlocksCount = 3`, Check: `3 < 0 = FALSE` ✓, After: `BlocksCount = 2`
- **Block 7:** Before: `BlocksCount = 2`, Check: `2 < 0 = FALSE` ✓, After: `BlocksCount = 1`
- **Block 8:** Before: `BlocksCount = 1`, Check: `1 < 0 = FALSE` ✓, After: `BlocksCount = 0`
- **Block 9:** Before: `BlocksCount = 0`, Check: `0 < 0 = FALSE` ✓ **BUG!**, After: `BlocksCount = -1`
- **Block 10:** Before: `BlocksCount = -1`, Check: `-1 < 0 = TRUE` ✗ (Rejected)

**Expected Behavior:** Miner should be stopped at Block 9
**Actual Behavior:** Miner can produce Block 9, exceeding the 8-block limit

---

## Notes

The vulnerability is confirmed through code analysis showing the off-by-one error in both validation [4](#0-3)  and command generation [5](#0-4)  logic. The counter management in `ResetLatestProviderToTinyBlocksCount` [9](#0-8)  confirms the initialization and decrement behavior that leads to this vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L19-19)
```csharp
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L334-334)
```csharp
    ///     To prevent one miner produced too many continuous blocks.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L19-19)
```csharp
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L33-33)
```csharp
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L12-12)
```csharp
    ///     This method will be executed before executing a block.
```
