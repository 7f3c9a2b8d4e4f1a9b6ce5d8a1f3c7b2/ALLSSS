# Audit Report

## Title
Stale Continuous Block Counter Bypasses Severe Status Emergency Limit

## Summary
The AEDPoS consensus contract's validation system contains a Time-Of-Check-Time-Of-Use (TOCTOU) vulnerability where the `LatestPubkeyToTinyBlocksCount` counter is read from stale state during validation (before execution) but only updated after validation passes. This allows miners to produce up to 8 blocks during Severe emergency status instead of the intended 1 block limit, completely undermining the emergency brake mechanism designed to prevent the chain from advancing dangerously far ahead of the Last Irreversible Block (LIB).

## Finding Description

The AEDPoS consensus implements an emergency brake where `GetMaximumBlocksCount()` returns 1 when the blockchain enters Severe status (current round number ≥ LIB round number + 8). [1](#0-0) [2](#0-1) 

However, the validation and execution flow creates a TOCTOU vulnerability:

**Validation Phase (Before Execution):**
When `ValidateConsensusBeforeExecution` is called, it invokes `ValidateBeforeExecution` which creates a `ConsensusValidationContext` containing the **stale** `LatestPubkeyToTinyBlocksCount` value from state. [3](#0-2) 

The `ContinuousBlocksValidationProvider` validates this counter but only rejects blocks when `BlocksCount < 0`. [4](#0-3) 

**Execution Phase (After Validation):**
After validation passes, the consensus transaction (`UpdateValue`, `UpdateTinyBlockInformation`, or `NextRound`) calls `ProcessConsensusInformation`. [5](#0-4) [6](#0-5) 

Inside `ProcessConsensusInformation`, the system calls `GetMaximumBlocksCount()` (which NOW evaluates the current blockchain status and returns 1 for Severe status), then calls `ResetLatestProviderToTinyBlocksCount(1)`. [7](#0-6) 

**The Critical Flaw:**
When `ResetLatestProviderToTinyBlocksCount` is called with the new emergency limit (1), it only **decrements** the existing counter if the same miner continues producing blocks. [8](#0-7) 

The new limit is only properly applied when a **different** miner takes over. [9](#0-8) 

**Concrete Exploit Scenario:**
1. Normal operation: Miner A produces consecutive blocks, accumulating `LatestPubkeyToTinyBlocksCount = {Pubkey: A, BlocksCount: 7}` (maximum normal value). [10](#0-9) [11](#0-10) 

2. System enters Severe status due to LIB lag (R ≥ R_LIB + 8).

3. Miner A produces blocks N through N+7:
   - Each validation reads the current `BlocksCount` value from state (7, 6, 5, 4, 3, 2, 1, 0) - all pass validation since ≥ 0
   - Each execution calls `GetMaximumBlocksCount()` returning 1, then decrements counter

4. Block N+8: Validation reads `BlocksCount = -1` and FINALLY FAILS

**Result:** Miner A produces 8 blocks during Severe emergency status instead of the intended 1 block limit.

## Impact Explanation

The Severe status is a critical safety mechanism triggered when the current round number is at least 8 rounds ahead of the Last Irreversible Block round. The system fires an `IrreversibleBlockHeightUnacceptable` event and sets `IsPreviousBlockInSevereStatus` to true, clearly indicating an emergency condition. [12](#0-11) 

**Concrete Harm:**

1. **Chain Safety Compromised:** The emergency limit prevents the chain from advancing too far ahead of the LIB. When bypassed, the chain continues advancing 8x faster than intended during this critical period, increasing fork risk and chain reorganization vulnerability.

2. **Emergency Response Ineffective:** The system correctly detects the dangerous condition and attempts to limit block production to 1, but the stale counter allows miners to ignore this limit.

3. **Quantified Violation:** With maximum pre-emergency `BlocksCount = 7`, a miner produces 8 blocks instead of 1 block during Severe status - an **8x violation** of the emergency safety limit.

4. **Protocol Integrity:** This breaks the consensus safety guarantees, affecting finality and irreversibility for all network participants.

## Likelihood Explanation

**Preconditions (All Realistic):**

1. **Miner Producing Consecutive Blocks:** This is normal consensus behavior. Any miner naturally accumulates non-zero `BlocksCount` values (up to 7) by producing consecutive blocks during normal operation.

2. **System Enters Severe Status:** This occurs when network conditions cause LIB to lag behind the current round by 8+ rounds - common during network partitions, connectivity issues, or consensus delays.

3. **Same Miner Continues:** The miner producing blocks when Severe status triggers naturally continues attempting to produce blocks as part of expected consensus behavior.

**No Special Permissions Required:**
The vulnerability affects legitimate miners operating normally within consensus rules. No malicious intent or manipulation is needed - the issue triggers automatically during normal consensus operation when timing conditions align.

**Probability: HIGH**
This vulnerability triggers naturally whenever a miner is producing consecutive blocks and network conditions cause LIB lag triggering Severe status. The issue is architectural and cannot be avoided through operational procedures.

## Recommendation

Modify `ResetLatestProviderToTinyBlocksCount` to enforce the new `minersCountInTheory` limit immediately for the same miner, rather than just decrementing:

```csharp
private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
{
    LatestPubkeyToTinyBlocksCount currentValue;
    if (State.LatestPubkeyToTinyBlocksCount.Value == null)
    {
        currentValue = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = _processingBlockMinerPubkey,
            BlocksCount = minersCountInTheory.Sub(1)
        };
        State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
    }
    else
    {
        currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
        if (currentValue.Pubkey == _processingBlockMinerPubkey)
        {
            // FIX: Enforce the new limit immediately by taking minimum
            var newCount = Math.Min(currentValue.BlocksCount.Sub(1), minersCountInTheory.Sub(1));
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = newCount
            };
        }
        else
        {
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = minersCountInTheory.Sub(1)
            };
        }
    }
}
```

This ensures that when Severe status is detected and `minersCountInTheory = 1`, the counter is immediately capped at `1 - 1 = 0`, causing the next validation to fail (since 0 - 1 = -1 < 0), thus limiting production to only 1 additional block as intended.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a consensus scenario where a miner has `BlocksCount = 7`
2. Triggering Severe status (advancing current round to R_LIB + 8)
3. Having the same miner continue producing blocks
4. Observing that 8 blocks are produced before validation fails

The test would verify that `GetMaximumBlocksCount()` returns 1 during Severe status, yet the miner successfully produces 8 blocks by decrementing from 7 to -1 before validation finally fails.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-66)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-112)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }

    #endregion

    #region UpdateTinyBlockInformation

    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L342-347)
```csharp
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
