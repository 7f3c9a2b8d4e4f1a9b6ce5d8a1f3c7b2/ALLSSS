# Audit Report

## Title
Consensus Transaction Signer Mismatch Enables Continuous Block Limit Bypass

## Summary
A critical security flaw exists in the AEDPoS consensus mechanism where the continuous block limit validation checks the block signer's public key, but the state update uses the transaction signer's public key. This mismatch allows two colluding miners to bypass the consecutive block production limit, enabling a single miner to produce unlimited consecutive blocks.

## Finding Description

The continuous block limit mechanism is designed to prevent any single miner from producing too many consecutive blocks. However, a fundamental public key source mismatch exists between validation and execution:

**Validation Phase:** The `ContinuousBlocksValidationProvider` validates the limit by comparing `latestPubkeyToTinyBlocksCount.Pubkey` against `validationContext.SenderPubkey`, where `SenderPubkey` comes from the consensus extra data. [1](#0-0) 

The `SenderPubkey` is extracted from `ExtraData.SenderPubkey` in the consensus header. [2](#0-1) 

The system validates that `ExtraData.SenderPubkey` matches the block's `SignerPubkey`. [3](#0-2) 

**Execution Phase:** When processing consensus transactions, `PreCheck()` recovers the public key from the transaction signature using `Context.RecoverPublicKey()`. [4](#0-3) 

The `RecoverPublicKey()` method recovers the public key from the transaction's cryptographic signature, not the block header. [5](#0-4) 

The state update uses this transaction-recovered public key to manage the continuous block counter. [6](#0-5) 

**Missing Critical Validation:** While `ExtraData.SenderPubkey` must match the block signer, there is no validation that the transaction signer (`Context.RecoverPublicKey()`) must match `ExtraData.SenderPubkey`. The consensus methods `UpdateValue` and `UpdateTinyBlockInformation` are public. [7](#0-6) 

The `PreCheck()` method only validates that the recovered public key is in the current or previous miner list, not that it matches the block signer. [8](#0-7) 

**Attack Scenario:**
1. Miner A creates block N with `BlockHeader.SignerPubkey = A` and `ExtraData.SenderPubkey = A`
2. Miner B signs a consensus transaction (UpdateValue/UpdateTinyBlockInformation) with their private key
3. Miner A includes Miner B's signed transaction in the block
4. Validation checks the continuous block limit against A (from ExtraData) ✓
5. Execution recovers B's public key from the transaction signature
6. State updates using B's public key
7. Counter resets because B ≠ A, bypassing the limit

## Impact Explanation

This vulnerability breaks a core consensus protection mechanism with severe consequences:

1. **Consensus Centralization**: A single miner can produce unlimited consecutive blocks by alternating transaction signers with a colluding miner, completely defeating the continuous block limit protection. [9](#0-8) 

2. **Transaction Censorship**: Extended control over block production enables systematic censorship of specific transactions.

3. **MEV Extraction**: Monopoly on consecutive block production enables maximum extractable value across many blocks.

4. **Reward Misallocation**: Colluding miners unfairly monopolize block production rewards.

5. **Chain Stability Risk**: Long sequences from a single producer increase reorganization vulnerability.

The mechanism to detect and force `NextRound` when limits are exceeded is completely bypassed. [10](#0-9) 

## Likelihood Explanation

This vulnerability is **highly feasible** to exploit:

1. **Public Entry Points**: The consensus methods are public and callable by any authorized miner without additional permissions.

2. **Realistic Preconditions**: Only requires two colluding miners in the active miner list—a realistic scenario since miners already coordinate for legitimate consensus operations.

3. **No Technical Barriers**: Transaction signatures are independently validated. [11](#0-10)  Block signatures are separately validated. [12](#0-11)  However, there is no check that they must be from the same miner.

4. **Cryptographic Validity**: Each signature (block and transaction) is independently valid; the missing check is their equality.

5. **Detection Difficulty**: The attack is not obvious from individual block inspection; it requires correlating block signers with transaction signers across blocks.

## Recommendation

Add validation in `PreCheck()` to ensure the transaction signer matches the block signer:

```csharp
private bool PreCheck()
{
    TryToGetCurrentRoundInformation(out var currentRound);
    TryToGetPreviousRoundInformation(out var previousRound);

    _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();
    
    // NEW: Validate transaction signer matches block signer
    var blockSignerPubkey = Context.Transaction.To == Context.Self 
        ? Context.Transaction.From.ToBase58() // For system transactions
        : _processingBlockMinerPubkey;
    
    // Get the expected block producer from consensus extra data
    // This should match _processingBlockMinerPubkey
    Assert(_processingBlockMinerPubkey == GetExpectedBlockProducer(), 
        "Transaction signer must match block producer");

    if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
        !previousRound.IsInMinerList(_processingBlockMinerPubkey))
        return false;

    return true;
}
```

Alternatively, validate in `ContinuousBlocksValidationProvider` or add a new validation provider that checks the transaction signer matches `ExtraData.SenderPubkey` during the validation phase.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task ContinuousBlockLimit_CanBypass_WithDifferentTransactionSigner()
{
    // Setup: Two miners A and B in active miner list
    var minerA = Accounts[0].KeyPair;
    var minerB = Accounts[1].KeyPair;
    
    // Produce blocks up to the limit with Miner A
    for (int i = 0; i < MaximumTinyBlocksCount - 1; i++)
    {
        // Normal flow: transaction signed by Miner A, block signed by Miner A
        var block = await ProduceBlockAsync(minerA, minerA);
        Assert.True(block != null);
    }
    
    // Now at the limit. Next block by Miner A should be rejected normally.
    // Attack: Miner A includes transaction signed by Miner B
    var attackBlock = await ProduceBlockWithDifferentSigner(
        blockSigner: minerA,    // Block signed by A, ExtraData.SenderPubkey = A
        txSigner: minerB);      // Transaction signed by B
    
    // Vulnerability: Block is accepted because validation checks A,
    // but state update uses B, resetting the counter
    Assert.True(attackBlock != null); // Should fail but passes
    
    // Miner A can now continue producing blocks indefinitely
    for (int i = 0; i < 10; i++)
    {
        var continuedBlock = await ProduceBlockWithDifferentSigner(
            blockSigner: minerA,
            txSigner: minerB);
        Assert.True(continuedBlock != null); // Bypassed limit
    }
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L17-19)
```csharp
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L32-32)
```csharp
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L321-321)
```csharp
        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L333-335)
```csharp
    /// <summary>
    ///     To prevent one miner produced too many continuous blocks.
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L193-196)
```csharp
    public byte[] RecoverPublicKey()
    {
        return RecoverPublicKey(TransactionContext.Transaction.Signature.ToByteArray(),
            TransactionContext.Transaction.GetHash().ToByteArray());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L31-35)
```csharp
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionExtensions.cs (L22-25)
```csharp
        var recovered = CryptoHelper.RecoverPublicKey(transaction.Signature.ToByteArray(),
            transaction.GetHash().ToByteArray(), out var publicKey);

        return recovered && Address.FromPublicKey(publicKey) == transaction.From;
```

**File:** src/AElf.OS/BlockSync/Application/BlockSyncValidationService.cs (L61-64)
```csharp
        if (blockWithTransactions.Header.SignerPubkey.ToHex() != senderPubKey)
        {
            Logger.LogDebug($"Sender {senderPubKey} of block {blockWithTransactions} is incorrect.");
            return Task.FromResult(false);
```
