# Audit Report

## Title
Assembled NFTs Can Be Burned Directly, Permanently Locking Component NFTs

## Summary
The NFT contract's `Burn` method can destroy assembled NFTs without returning their locked component assets. When protocol minters burn assembled NFTs instead of using `Disassemble`, the component NFTs and fungible tokens remain permanently trapped in the contract with no recovery mechanism, violating the fundamental invariant that locked assets must be retrievable.

## Finding Description

The NFT contract implements an assembly mechanism where NFTs and fungible tokens can be locked into composite "assembled" NFTs. The `Assemble` method transfers component NFTs to the contract itself and stores the mapping for later retrieval. [1](#0-0) 

The locked components are recorded in state variables `AssembledNftsMap` and `AssembledFtsMap`: [2](#0-1) [3](#0-2) 

The intended flow for retrieving locked assets is through `Disassemble`, which burns the assembled NFT and transfers components back to the receiver: [4](#0-3) 

**Root Cause:** The `Burn` method validates caller permissions and balance, but does NOT check if the NFT being burned has locked components in `AssembledNftsMap` or `AssembledFtsMap`: [5](#0-4) 

The `Burn` method performs no check for assembled NFTs, does not return locked assets, and does not clean up the state map entries. When a protocol minter calls `Burn` on an assembled NFT:
- The assembled NFT is destroyed (balance reduced, quantity decreased)
- The `AssembledNftsMap[tokenHash]` and `AssembledFtsMap[tokenHash]` entries remain orphaned
- Component NFTs/FTs stay locked in the contract forever at address `Context.Self`
- No mechanism exists to recover these assets

**Attack Vector:** Any user can create their own NFT protocol and become its minter automatically: [6](#0-5) 

They can then assemble NFTs from any protocol into their own protocol (the assembly accepts any token hash with only balance validation): [7](#0-6) 

Finally, they can burn their protocol's assembled NFT to permanently lock the components.

## Impact Explanation

**Severity: HIGH**

**Direct Fund Loss:** Component NFTs and fungible tokens locked during assembly become permanently inaccessible. The locked assets remain in the contract's balance but cannot be retrieved by anyone, including the contract owner or governance. The value depends on what was assembled but could include rare NFTs or significant fungible token amounts.

**Broken Invariants:** The assembly/disassembly mechanism creates an explicit expectation that locked assets can be retrieved through the `Disassemble` method. This vulnerability violates that core guarantee, as burning assembled NFTs bypasses the retrieval flow entirely and leaves orphaned state map entries with no cleanup mechanism.

**Affected Parties:**
- Users who accidentally call `Burn` instead of `Disassemble` (user error scenario)
- Victims of malicious actors who intentionally burn assembled NFTs after locking valuable components (griefing/theft scenario)
- The protocol itself, which accumulates unrecoverable locked assets in perpetuity

**No Recovery Path:** Code analysis confirms that `AssembledNftsMap` and `AssembledFtsMap` are only accessed in the `Assemble` and `Disassemble` methods. There is no admin function, governance mechanism, or emergency procedure to rescue locked assets from orphaned map entries. The loss is permanent and irreversible.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Entry Point:** The `Burn` method is publicly accessible to any protocol minter with sufficient balance of the NFT being burned.

**Preconditions:**
1. Attacker creates an NFT protocol via `Create` (any user can do this)
2. Attacker is automatically added as protocol minter upon creation
3. Attacker assembles NFTs from other protocols into their protocol  
4. Protocol must be set as burnable during creation (attacker-controlled parameter)

**Attack Complexity:** LOW - The attack requires only standard protocol operations:
- Create a burnable protocol (single transaction)
- Assemble valuable NFTs into the protocol (single transaction)
- Burn the assembled NFT (single transaction)

**Real-World Scenarios:**
1. **User Error:** Users may confuse `Burn` and `Disassemble` methods, especially if wallet interfaces don't clearly distinguish them or if users are unfamiliar with the assembly mechanism
2. **Malicious Griefing:** Attackers can intentionally burn assembled NFTs to cause permanent fund loss at minimal cost (only transaction fees required)
3. **Integration Bugs:** External dApps or contracts that incorrectly call `Burn` on assembled NFTs without understanding the assembly state

**Economic Rationality:** While there's no direct profit motive for attackers, the attack is extremely cheap to execute and causes permanent, irreversible harm to victims, making it attractive for griefing purposes or to damage protocol reputation.

## Recommendation

Add a check in the `Burn` method to prevent burning assembled NFTs. The method should verify that neither `AssembledNftsMap` nor `AssembledFtsMap` contain entries for the token being burned:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add this check to prevent burning assembled NFTs
    Assert(State.AssembledNftsMap[tokenHash] == null, 
        "Cannot burn assembled NFT directly. Use Disassemble method instead.");
    Assert(State.AssembledFtsMap[tokenHash] == null,
        "Cannot burn assembled NFT directly. Use Disassemble method instead.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
    Assert(nftProtocolInfo.IsBurnable,
        $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
    // ... rest of burn logic
}
```

Alternatively, implement an emergency recovery function that allows governance to rescue locked assets from orphaned state map entries, though prevention is the better solution.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_LocksComponentsPermanently()
{
    // Setup: Create a burnable protocol and mint NFTs
    var symbol = await CreateProtocolAsync(isBurnable: true);
    var (componentSymbol, componentHash) = await MintComponentNFT();
    
    // Step 1: Assemble component NFT into new assembled NFT
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = long.MaxValue
    });
    
    var assembleResult = await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledNfts = new AssembledNfts { Value = { [componentHash.ToHex()] = 1 } },
        AssembledFts = new AssembledFts { Value = { ["ELF"] = 100 } }
    });
    
    var assembledTokenId = assembleResult.Output.ToInt64();
    
    // Verify component is locked in contract
    var componentBalance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = NFTContractAddress,
        Symbol = componentSymbol,
        TokenId = 1
    });
    componentBalance.Balance.ShouldBe(1); // Locked in contract
    
    // Step 2: Burn the assembled NFT directly (bypassing Disassemble)
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = assembledTokenId,
        Amount = 1
    });
    
    // Step 3: Verify assembled NFT is destroyed
    var assembledBalance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = symbol,
        TokenId = assembledTokenId
    });
    assembledBalance.Balance.ShouldBe(0); // Assembled NFT burned
    
    // Step 4: Verify component NFT is permanently locked
    componentBalance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = NFTContractAddress,
        Symbol = componentSymbol,
        TokenId = 1
    });
    componentBalance.Balance.ShouldBe(1); // Still locked, cannot be retrieved
    
    // Step 5: Verify Disassemble cannot recover (assembled NFT no longer exists)
    var disassembleException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.Disassemble.SendAsync(new DisassembleInput
        {
            Symbol = symbol,
            TokenId = assembledTokenId
        });
    });
    // Disassemble will fail because Burn is called first and balance is 0
    
    // RESULT: Component NFT permanently locked with no recovery mechanism
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L120-131)
```csharp
        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-178)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-225)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```
