# Audit Report

## Title
Unhandled KeyNotFoundException in IsCurrentMiner During Term Transitions Causes DoS of Critical Authorization Checks

## Summary
The `IsCurrentMiner` function contains a logic error that causes unhandled exceptions during term transitions. When `IsMinerListJustChanged = true`, the function skips key existence validation but then directly accesses the dictionary with pubkeys that may only exist in the previous round, throwing `KeyNotFoundException` and causing transaction failures for fee claims, cross-chain indexing, and other miner-authenticated operations.

## Finding Description

The vulnerability exists in the interaction between `ConvertAddressToPubkey` and `IsCurrentMiner` functions in the AEDPoS consensus contract.

**Root Cause:** The `ConvertAddressToPubkey` function combines miners from both current and previous rounds by adding keys from both `currentRound.RealTimeMinersInformation` and `previousRound.RealTimeMinersInformation` to the possible keys list, meaning it can return a pubkey that exists only in the previous round's miner list. [1](#0-0) 

The `IsCurrentMiner(string pubkey)` function has a critical flaw: when `IsMinerListJustChanged = true`, it skips the `ContainsKey` check that validates whether the pubkey exists in the current round. [2](#0-1) 

However, the function then directly accesses the dictionary without any guard at line 158, causing a `KeyNotFoundException` if the pubkey doesn't exist in the current round. [3](#0-2) 

During term transitions, `GenerateFirstRoundOfNewTerm` sets `IsMinerListJustChanged = true`. [4](#0-3) 

**Flawed Protection:** The special case check only handles `ExtraBlockProducerOfPreviousRound`, but doesn't protect against other removed miners attempting to access the system. [5](#0-4) 

**Attack Scenario:**
1. Term N has miners [A, B, C, D, E]
2. Term N+1 transitions with miners [A, B, C, F, G] (D and E removed)
3. `GenerateFirstRoundOfNewTerm` sets `IsMinerListJustChanged = true`
4. Removed miner D attempts to call `ClaimTransactionFees` or `ProposeCrossChainIndexing`
5. `ConvertAddressToPubkey(D's address)` returns D's pubkey (found in previous round)
6. `IsCurrentMiner` skips the `ContainsKey` check because `IsMinerListJustChanged = true`
7. Line 158 attempts to access `currentRound.RealTimeMinersInformation[D's pubkey]`
8. `KeyNotFoundException` thrown, transaction reverts with unhandled exception

## Impact Explanation

This vulnerability causes **Denial of Service** during term transitions affecting multiple critical operations:

1. **Token Fee Claims**: The `ClaimTransactionFees` method uses `AssertSenderIsCurrentMiner()` at its entry point, which calls `IsCurrentMiner` through the consensus contract to verify authorization. [6](#0-5) [7](#0-6) 

2. **Cross-Chain Indexing**: The `CheckCrossChainIndexingPermission` method directly calls `IsCurrentMiner`, and is used by cross-chain operations to validate miner permissions. [8](#0-7) [9](#0-8) 

3. **Any authorization check** using `IsCurrentMiner` during the vulnerable window fails with unhandled exceptions instead of graceful permission denial.

**Quantified Impact**: All removed miners and anyone querying their status during the first round of each new term will trigger unhandled exceptions, disrupting protocol operations. While not causing fund loss, this creates operational disruption during each term transition, affecting fee distribution and cross-chain communication.

## Likelihood Explanation

**Attacker Capabilities**: 
- Any user can trigger this by calling public methods like `ProposeCrossChainIndexing` or `ReleaseCrossChainIndexingProposal` during term transitions
- Removed miners legitimately attempting to claim fees or perform operations will automatically trigger this

**Attack Complexity**: Low
- Requires only knowing an address from the previous miner list
- No special permissions needed
- Public methods like `ProposeCrossChainIndexing` accept calls from any address [9](#0-8) 

**Feasibility Conditions**:
- Term transition must have occurred (happens periodically in AEDPoS based on election results)
- `IsMinerListJustChanged = true` (first round of new term)
- Address belongs to a miner removed in the transition (not the extra block producer)

**Probability**: Moderate to High - Term transitions with miner list changes happen regularly based on election voting. The vulnerable state persists for the entire first round of each new term, and removed miners may legitimately attempt to claim fees or perform operations during this window.

## Recommendation

Add a key existence check before the dictionary access, regardless of the `IsMinerListJustChanged` flag value. The fix should ensure that the function gracefully returns `false` instead of throwing an exception when a pubkey doesn't exist in the current round.

**Recommended Fix:**
```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;

    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

    // Always check if the key exists before accessing
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // Special case: allow extra block producer of previous round
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            return true;
        }
        return false;
    }

    // Rest of the existing logic...
    var miningInterval = currentRound.GetMiningInterval();
    var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
    // ... continue with normal checks
}
```

## Proof of Concept

```csharp
[Fact]
public async Task IsCurrentMiner_ThrowsKeyNotFoundException_WhenRemovedMinerDuringTermTransition()
{
    // Setup: Initialize consensus with 5 miners [A, B, C, D, E]
    var initialMiners = GenerateMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Transition to new term with different miner list [A, B, C, F, G] - D and E removed
    var newMiners = new List<string> { initialMiners[0], initialMiners[1], initialMiners[2] };
    newMiners.AddRange(GenerateMiners(2)); // Add F and G
    
    await TransitionToNewTerm(newMiners);
    
    // Verify IsMinerListJustChanged = true
    var currentRound = await GetCurrentRound();
    Assert.True(currentRound.IsMinerListJustChanged);
    
    // Attempt: Removed miner D tries to call IsCurrentMiner
    var removedMinerAddress = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(initialMiners[3]));
    
    // Expected: Should throw KeyNotFoundException at line 158
    await Assert.ThrowsAsync<KeyNotFoundException>(async () => 
    {
        await ConsensusStub.IsCurrentMiner.CallAsync(removedMinerAddress);
    });
}
```

## Notes

This vulnerability demonstrates a critical logic error in the authorization flow. The code conditionally skips the safety check (`ContainsKey`) based on `IsMinerListJustChanged`, but then unconditionally performs an unsafe dictionary access. The special case handling for `ExtraBlockProducerOfPreviousRound` suggests the developers were aware that previous round miners need special handling during transitions, but this protection is incomplete - it only covers one specific miner, not all removed miners.

The impact is limited to DoS (not fund loss), but it affects critical protocol operations including fee distribution and cross-chain communication during every term transition, making this a valid Medium severity finding.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-159)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-44)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```
