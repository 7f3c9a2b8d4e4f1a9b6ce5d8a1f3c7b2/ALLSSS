# Audit Report

## Title
Permanent Token Lock Due to State Corruption Bug and Manager Transfer

## Summary
A critical state corruption bug in the TokenHolder contract's `UpdateTokenHolderProfitScheme` method stores scheme updates to the wrong address, causing permanent token lock when scheme managers transfer ownership via the Profit contract's `ResetManager` method.

## Finding Description

The `UpdateTokenHolderProfitScheme` method contains a state corruption bug where it incorrectly stores the updated scheme to `Context.Sender` instead of the `manager` parameter. [1](#0-0) 

When a manager creates a TokenHolder scheme via `CreateScheme`, the scheme is stored with an unpopulated `SchemeId` (null by default). [2](#0-1) 

During user registration via `RegisterForProfits`, the `GetValidScheme` helper retrieves the manager's scheme and calls `UpdateTokenHolderProfitScheme` to populate the `SchemeId` from the Profit contract. [3](#0-2) 

The bug occurs when the updated scheme with the populated `SchemeId` is stored to the **caller's** address (`Context.Sender`) rather than the **manager's** address, leaving the manager's scheme state with `SchemeId = null`. While auto-distribute logic can correct this, [4](#0-3)  it only triggers when specific threshold conditions are met, making the bug exploitable in many scenarios.

When a manager transfers ownership via `ResetManager` in the Profit contract, [5](#0-4)  the scheme is removed from the old manager's `ManagingSchemeIds` list and added to the new manager's list.

Subsequently, when users attempt to withdraw their locked tokens via the `Withdraw` method, [6](#0-5)  the transaction fails because:
1. `GetValidScheme` retrieves the manager's scheme which still has `SchemeId = null`
2. `UpdateTokenHolderProfitScheme` attempts to fetch the scheme ID by querying `GetManagingSchemeIds` for the original manager
3. The query returns an empty list (scheme was transferred to new manager)
4. The assertion at line 294 fails with "Origin scheme not found"

This breaks the fundamental invariant that users who lock tokens can unlock them after the minimum lock period. The `Unlock` call at line 230 is the **only** mechanism to unlock tokens in the TokenHolder contract, [7](#0-6)  and no administrative recovery function exists.

## Impact Explanation

This vulnerability causes **permanent and irreversible loss of user funds**:

- Users' locked tokens become completely inaccessible with no recovery mechanism
- The impact affects all users who registered for profits before the manager transferred ownership, unless auto-distribute happened to trigger during their registration
- The total locked amount equals the sum of all user token locks for the affected scheme
- The lock ID mapping is based on the original manager address, [8](#0-7)  preventing any alternative withdrawal path

The only theoretical recovery would require the new manager to cooperate by transferring ownership back to the original manager, but this:
- Depends on external party cooperation with no guarantee
- May not be feasible if the new manager is unaware of the issue
- Requires users to wait indefinitely for resolution

## Likelihood Explanation

The likelihood is **medium-to-high** because:

1. **Low Complexity**: Exploitation requires only a single legitimate call to `ResetManager` by the scheme manager [9](#0-8) 

2. **Realistic Trigger Conditions**:
   - Managers may transfer ownership for legitimate operational reasons (e.g., organizational restructuring, account migration)
   - Auto-distribute protection only activates when threshold conditions are met [10](#0-9)  and may not be configured or triggered

3. **No Safeguards**: 
   - No warnings prevent managers from calling `ResetManager`
   - Users have zero visibility or control over manager actions
   - The contract provides no checks to detect or prevent this scenario

4. **Normal Operations**: The bug manifests during completely normal protocol usage without requiring any malicious intent

## Recommendation

Fix the state corruption bug in `UpdateTokenHolderProfitScheme` by changing line 298 to store the scheme at the manager's address:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId != null && !updateSchemePeriod) return;
    var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
    {
        Manager = manager
    }).SchemeIds.FirstOrDefault();
    Assert(originSchemeId != null, "Origin scheme not found.");
    var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
    scheme.SchemeId = originScheme.SchemeId;
    scheme.Period = originScheme.CurrentPeriod;
    State.TokenHolderProfitSchemes[manager] = scheme; // FIX: Changed from Context.Sender to manager
}
```

Additionally, consider implementing safeguards:
1. Add a check in `ResetManager` to prevent transfers when active locks exist
2. Provide an emergency unlock mechanism for stuck tokens
3. Implement a migration function to update lock mappings when ownership transfers

## Proof of Concept

```csharp
[Fact]
public async Task PermanentTokenLock_AfterManagerTransfer()
{
    // Setup: Manager creates scheme
    var manager = Accounts[0].Address;
    var user = Accounts[1].Address;
    var newManager = Accounts[2].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // User registers and locks 100 tokens (without auto-distribute triggering)
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 100
    });
    
    // Manager transfers ownership to newManager
    var schemeId = await GetSchemeId(manager);
    await ProfitContractStub.ResetManager.SendAsync(new ResetManagerInput
    {
        SchemeId = schemeId,
        NewManager = newManager
    });
    
    // Fast forward past minimum lock period
    await AdvanceTime(2);
    
    // User attempts withdrawal - THIS WILL FAIL with "Origin scheme not found"
    var result = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(manager);
    result.TransactionResult.Error.ShouldContain("Origin scheme not found");
    
    // Tokens are permanently locked - user cannot withdraw
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L179-202)
```csharp
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L204-205)
```csharp
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L723-743)
```csharp
    public override Empty ResetManager(ResetManagerInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");

        // Transfer managing scheme id.
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;

        scheme.Manager = input.NewManager;
        State.SchemeInfos[input.SchemeId] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-15)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }
```
