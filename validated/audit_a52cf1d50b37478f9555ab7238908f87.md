# Audit Report

## Title
Incomplete Auto-Distribution Logic Causes Profit Misallocation Across Multiple Token Types

## Summary
The `RegisterForProfits()` method contains a premature `break` statement in its auto-distribution loop that processes only the first qualifying token from `AutoDistributeThreshold`, causing subsequent qualifying tokens to be distributed in different periods with different beneficiary sets. This results in unfair reward allocation where early registrants receive disproportionately higher profits than later participants with equal shares.

## Finding Description

The auto-distribution logic in `RegisterForProfits()` iterates through configured tokens in `AutoDistributeThreshold` but exits prematurely after finding the first qualifying token. [1](#0-0) 

The problematic sequence occurs as follows:

1. When a user registers, they are added as a beneficiary with `StartPeriod` set to the scheme's `CurrentPeriod` [2](#0-1) 

2. The auto-distribution check iterates through `AutoDistributeThreshold` entries, but after finding the first token meeting its threshold, it adds only that token to `distributedInput.AmountsMap` and immediately breaks from the loop, preventing other qualifying tokens from being processed in the same distribution cycle

3. The `DistributeProfits()` method in the Profit contract only processes tokens present in the input's `AmountsMap` [3](#0-2) 

4. After distribution, the period increments [4](#0-3) 

5. Remaining qualifying tokens stay undistributed in the scheme's general ledger (virtual address) until the next registration event triggers their distribution to a different period with a potentially different beneficiary set

This breaks the core invariant that beneficiaries with equal shares should receive proportionally equal rewards from tokens contributed during the same timeframe.

## Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

In a concrete scenario where a scheme is configured with `AutoDistributeThreshold = {ELF: 1000, JUN: 1000}` and both tokens have 1000 balance in the general ledger:

- **User A registers first** with 100 shares:
  - Added as beneficiary for Period 1
  - Auto-distribution triggers: only ELF (first in iteration) is added to `AmountsMap`
  - Loop breaks, JUN is not processed
  - ELF distributed to Period 1
  - Period increments to 2
  - JUN remains in general ledger

- **User B registers second** with 100 shares:
  - Added as beneficiary for Period 2 (cannot claim Period 1 due to `StartPeriod = 2`)
  - Auto-distribution triggers: JUN is now processed and distributed to Period 2
  - Period increments to 3

**Financial Result:**
- User A claims: 100% of ELF (1000) from Period 1 + 50% of JUN (500) from Period 2 = **1500 total value**
- User B claims: 0% of ELF + 50% of JUN (500) from Period 2 = **500 total value**

Despite identical 100-share contributions, User A receives 3x the value of User B. This violates the fundamental fairness guarantee that equal stakes should yield proportionally equal rewards from the same profit pool.

**Affected Parties:** All TokenHolder schemes using multi-token auto-distribution configurations, which is a common pattern for DApps distributing multiple reward token types as dividends.

## Likelihood Explanation

**Occurrence Probability:** HIGH

The vulnerability triggers deterministically whenever:
1. A scheme configures multiple tokens in `AutoDistributeThreshold` (standard for multi-reward systems)
2. Multiple tokens simultaneously meet their distribution thresholds (realistic when contributions arrive in batches or at similar rates)
3. Users register sequentially via the public `RegisterForProfits()` method (normal operation)

**Attack Complexity:** TRIVIAL
- No special permissions required - `RegisterForProfits()` is a publicly accessible method
- Attacker simply monitors the general ledger balances to detect when multiple thresholds are met
- First registration automatically captures exclusive distribution of the first qualifying token
- Subsequent registrants are systematically disadvantaged without any ability to prevent it

**Detection Difficulty:** The vulnerability manifests as normal contract behavior with no transaction failures or events indicating anomalous operation. Victims discover the misallocation only when claiming profits and comparing actual payouts against expected proportional distributions.

## Recommendation

Remove the `break` statement on line 199 to allow all qualifying tokens to be added to the distribution input:

```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Remove: break;  <- Delete this line
}
```

This ensures all tokens meeting their thresholds are distributed atomically in the same period, maintaining proportional fairness across all reward token types.

## Proof of Concept

```csharp
[Fact]
public async Task MultiTokenAutoDistribution_PrematureBreak_CausesUnfairAllocation()
{
    // Setup: Create scheme with multi-token auto-distribution
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "SHARE",
        MinimumLockMinutes = 0,
        AutoDistributeThreshold = 
        {
            { "ELF", 1000 },
            { "JUN", 1000 }
        }
    });
    
    var schemeManager = DefaultSender;
    
    // Contribute both tokens to general ledger
    await TokenStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    await TokenStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderAddress,
        Symbol = "JUN",
        Amount = 1000
    });
    
    await TokenHolderStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = schemeManager,
        Symbol = "ELF",
        Amount = 1000
    });
    await TokenHolderStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = schemeManager,
        Symbol = "JUN",
        Amount = 1000
    });
    
    // User A registers - triggers auto-distribution
    await TokenHolderStubUserA.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = 100
    });
    
    // User B registers - triggers second auto-distribution
    await TokenHolderStubUserB.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = 100
    });
    
    // Claim profits for both users
    await TokenHolderStubUserA.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager
    });
    await TokenHolderStubUserB.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager
    });
    
    // Verify unfair allocation
    var userAElfBalance = (await TokenStubUserA.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAAddress,
        Symbol = "ELF"
    })).Balance;
    
    var userAJunBalance = (await TokenStubUserA.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAAddress,
        Symbol = "JUN"
    })).Balance;
    
    var userBElfBalance = (await TokenStubUserB.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserBAddress,
        Symbol = "ELF"
    })).Balance;
    
    var userBJunBalance = (await TokenStubUserB.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserBAddress,
        Symbol = "JUN"
    })).Balance;
    
    // User A received 1000 ELF + 500 JUN = 1500 total
    userAElfBalance.ShouldBe(1000);
    userAJunBalance.ShouldBe(500);
    
    // User B received 0 ELF + 500 JUN = 500 total
    userBElfBalance.ShouldBe(0); // Unfair: User B gets no ELF despite equal shares
    userBJunBalance.ShouldBe(500);
    
    // Despite equal 100-share stakes, User A receives 3x the value
    var userATotalValue = userAElfBalance + userAJunBalance; // 1500
    var userBTotalValue = userBElfBalance + userBJunBalance; // 500
    (userATotalValue / userBTotalValue).ShouldBe(3); // Proves unfair 3:1 ratio
}
```

## Notes

This vulnerability is a clear implementation bug where the `break` statement violates the intended behavior of multi-token auto-distribution. The fix is straightforward - removing the break allows the loop to complete its iteration and include all qualifying tokens in a single atomic distribution event, ensuring all beneficiaries registered in the same period receive proportionally fair rewards across all token types. The issue affects any scheme using multiple reward tokens with auto-distribution thresholds, which is a common pattern in DeFi dividend distribution systems.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-199)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L203-205)
```csharp
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-446)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
```
