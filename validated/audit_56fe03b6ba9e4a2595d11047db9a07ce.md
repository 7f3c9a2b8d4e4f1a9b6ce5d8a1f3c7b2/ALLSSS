# Audit Report

## Title
Missing Upper and Lower Bound Validation for ImpliedIrreversibleBlockHeight in LIB Validation

## Summary
The `LibInformationValidationProvider` lacks critical bound checks on `ImpliedIrreversibleBlockHeight` values submitted by miners during block production. This allows malicious miners to submit values exceeding the current block height or below the confirmed LIB, potentially corrupting the consensus state and firing invalid events, though actual chain LIB setting is partially mitigated.

## Finding Description

The validation logic in `LibInformationValidationProvider` performs incomplete validation of `ImpliedIrreversibleBlockHeight` values. The validator only checks that the value doesn't decrease relative to the miner's previous value, but fails to enforce two critical bounds:

1. **Upper bound violation**: No check exists to ensure `ImpliedIrreversibleBlockHeight <= Context.CurrentHeight`
2. **Lower bound violation**: No check exists to ensure `ImpliedIrreversibleBlockHeight >= ConfirmedIrreversibleBlockHeight` [1](#0-0) 

The first validation check is ineffective for `UpdateValue` behavior because the simplified round created by `GetUpdateValueRound` does not copy the `ConfirmedIrreversibleBlockHeight` or `ConfirmedIrreversibleBlockRoundNumber` fields, causing these fields to default to 0. [2](#0-1) 

During honest block production, miners set `ImpliedIrreversibleBlockHeight` to the current height: [3](#0-2) 

However, malicious miners can modify their node software to submit arbitrary values. When `UpdateValue` transactions are processed, the value is stored directly without bounds checking: [4](#0-3) 

The LIB calculation then uses these potentially invalid values from miners in the previous round to compute the new confirmed LIB height: [5](#0-4) 

If the calculated `libHeight` exceeds the current chain height or contains corrupted values, it is still stored in the consensus state and invalid `IrreversibleBlockFound` events are fired: [6](#0-5) 

## Impact Explanation

**Consensus State Corruption:**
- If 1/3+ malicious miners collude and submit `ImpliedIrreversibleBlockHeight` values with strategic values, the LIB calculation (which takes the value at position `(count-1)/3` in the sorted list) could produce corrupted results
- The `ConfirmedIrreversibleBlockHeight` field in the consensus contract's state becomes corrupted with invalid heights
- `IrreversibleBlockFound` events fire with invalid heights, potentially misleading downstream systems that consume these events

**Cross-Chain and Finality Issues:**
- Cross-chain verification mechanisms may rely on accurate LIB heights for parent/side-chain indexing
- External systems consuming LIB data without independent validation could be affected by the invalid event data
- Artificially manipulated values could interfere with finality advancement

**Partial Mitigation:**
The `IrreversibleBlockFoundLogEventProcessor` includes a safety check that prevents the actual chain's LIB from being set to non-existent blocks: [7](#0-6) 

However, this is defense-in-depth only. The primary validation layer should enforce bounds, and the corrupted state values remain stored in the consensus contract even with this mitigation.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized miner in the consensus miner set (semi-trusted role)
- Requires modifying node software to submit invalid `ImpliedIrreversibleBlockHeight` values
- Strategic manipulation could impact LIB calculation depending on collusion

**Attack Feasibility:**
- Low technical complexity once miner access is obtained - simply modify the value before submission
- The validation gap is directly reachable through normal `UpdateValue` consensus transactions
- No additional authentication bypass or privilege escalation needed beyond being an authorized miner
- Miners are semi-trusted parties, and compromise or collusion is within the threat model for consensus security analysis

**Detection Challenges:**
- Invalid LIB values stored in consensus state might not be immediately apparent
- The corrupted state persists even though the actual chain LIB is protected by the event processor
- Invalid events could mislead monitoring systems

## Recommendation

Add bounds validation in `LibInformationValidationProvider` to check:

1. **Upper bound check**: Ensure `ImpliedIrreversibleBlockHeight` does not exceed a reasonable maximum (ideally validated against the block height, though this requires access to Context)
2. **Lower bound check**: Pass `ConfirmedIrreversibleBlockHeight` to the validation context from the base round and validate that provided values don't go below it

Additionally, modify `GetUpdateValueRound` to copy the `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields so the existing validation check becomes effective: [8](#0-7) 

## Proof of Concept

A malicious miner can exploit this by:

1. Modifying their node software to set `ImpliedIrreversibleBlockHeight` to an arbitrary value (e.g., `999999999`) in their `UpdateValueInput`
2. Submitting the `UpdateValue` transaction during their mining slot
3. The validation passes because:
   - The `ConfirmedIrreversibleBlockHeight` check at lines 14-21 is bypassed (values are 0 in providedRound)
   - The only active check (lines 23-30) only ensures the value doesn't decrease from the miner's previous value
4. The invalid value is stored in the contract state
5. In subsequent rounds, when other miners call `UpdateValue`, the LIB calculation uses these corrupted values
6. An `IrreversibleBlockFound` event fires with an invalid height
7. The `ConfirmedIrreversibleBlockHeight` in the consensus contract state becomes corrupted

**Notes:**
The validation providers do not have access to `Context.CurrentHeight`, making it impossible to validate the upper bound within the current architecture. The validation context would need to be extended to include the current block height, or alternatively, the bounds checking should be performed in `ProcessUpdateValue` where Context is available.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-280)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L63-65)
```csharp
            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;
```
