# Audit Report

## Title
Insufficient Miner Count Enforcement Allows Network to Operate Below Security Threshold

## Summary
The Election contract's `GetVictories()` function can return fewer miners than the configured `MinersCount` due to a coding bug that artificially limits the backup pool size and complete absence of minimum miner count validation. This allows the consensus system to operate with reduced Byzantine fault tolerance, violating the security guarantees encoded in `MinersCount`.

## Finding Description

The vulnerability exists in the miner selection logic that determines which nodes participate in consensus for each term. The security property being violated is that `MinersCount` represents the minimum number of miners required to maintain the network's Byzantine fault tolerance threshold.

**Root Cause 1 - Artificial Backup Pool Limitation:**

When there are insufficient valid candidates (candidates with votes), the system attempts to fill the gap using backup miners from `currentMiners` and `InitialMiners`. [1](#0-0) 

The bug occurs where the code takes `Math.Min(diff, currentMiners.Count)` backups instead of `Math.Min(diff, backups.Count)`. [2](#0-1)  Since `backups` includes both current miners AND initial miners (after filtering), `backups.Count` can exceed `currentMiners.Count`. This artificial cap prevents the system from using all available backup miners.

**Root Cause 2 - No Minimum Enforcement:**

The `GetVictories()` function returns whatever miners it can gather without validating that the count meets `MinersCount`. [3](#0-2) 

The consensus contract calls this during term transitions via `TryToGetVictories()`, which only checks if any miners are returned (`victories.Pubkeys.Any()`), not whether enough miners are returned. [4](#0-3) 

The returned miner list is directly used to generate the new consensus round without minimum validation. [5](#0-4) 

**Why Existing Protections Fail:**

The `SolitaryMinerDetection` mechanism only catches extreme cases where a single miner operates alone for 2+ consecutive rounds. [6](#0-5) 

This does not protect against scenarios where the network operates with multiple miners but still fewer than `MinersCount`.

## Impact Explanation

The impact is **critical** because it directly undermines Byzantine fault tolerance, the fundamental security property of the consensus mechanism.

**Security Model Violation:**
Byzantine fault tolerance requires that the system can tolerate up to `f` malicious nodes when there are `3f + 1` total nodes (or `2f + 1` for a 2/3 majority). If `MinersCount = 17` (designed to tolerate 5 Byzantine nodes with 2/3 majority = 12/17), but the system operates with only 14 miners, the tolerance drops to 4 Byzantine nodes (2/3 majority = 10/14). This represents a 20% reduction in security margin.

**Affected Parties:**
- The entire network operates with degraded security
- Token holders and stakeholders who voted expecting `MinersCount`-level security guarantees
- Applications relying on consensus finality are exposed to increased attack risk
- The `MinersCount` configuration becomes meaningless if not enforced

**Consensus Vulnerability:**
Critical consensus operations like term transitions and secret sharing that require 2/3 majority become more vulnerable to failure or manipulation when the actual miner count is below the designed threshold.

## Likelihood Explanation

The likelihood is **medium to high** over the blockchain's lifetime due to the following factors:

**Automatic Trigger:**
The `MinersCount` value automatically increases over time based on blockchain age through the auto-increment mechanism. [7](#0-6) 

The consensus contract calls `UpdateMinersCountToElectionContract()` during term transitions to keep the Election contract's `MinersCount` synchronized with the auto-incremented value. [8](#0-7) 

**Realistic Preconditions:**
1. As blockchain ages, `MinersCount` increases automatically (2 miners per configured interval)
2. Candidate participation depends on economic incentives and may not keep pace
3. If `validCandidates + availableBackups < MinersCount`, the vulnerability triggers
4. No active attack is required - this occurs through natural system progression

**Detection Difficulty:**
The network continues operating normally, making this security degradation difficult to detect without explicitly monitoring actual vs. expected miner counts.

## Recommendation

1. **Fix the backup pool bug** in `GetVictories()`:
   - Change line 72 from `.Take(Math.Min(diff, currentMiners.Count))` to `.Take(Math.Min(diff, backups.Count))`

2. **Add minimum validation** in `GetVictories()`:
   - Before returning at line 76, assert that `victories.Count >= State.MinersCount.Value`

3. **Add minimum validation** in `TryToGetVictories()`:
   - Change line 282 from `return victories.Pubkeys.Any()` to check against minimum: `return victories.Pubkeys.Count >= GetMinersCount(currentRound)`

4. **Add validation** in `GenerateFirstRoundOfNewTerm()`:
   - Assert that `Pubkeys.Count` meets the minimum required miner count before generating the round

5. **Consider decoupling** the auto-increment mechanism from actual candidate availability, or add governance controls to pause auto-increment when candidate participation is low.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Set up a blockchain with `MinersCount = 17` and only 15 total available nodes (valid candidates + backups)
2. Due to the bug at line 72, only `min(2, currentMiners.Count)` backups are taken instead of the full 2 needed
3. The system returns 15 miners instead of the required 17
4. No assertion fails, and consensus proceeds with degraded Byzantine fault tolerance
5. The network now tolerates only 4 Byzantine nodes instead of the designed 5

A complete test would require:
- Setting up Election and Consensus contracts with controlled candidate/miner counts
- Advancing blockchain time to trigger auto-increment
- Calling term transition with insufficient candidates
- Verifying that GetVictories returns fewer miners than MinersCount
- Confirming that no validation prevents this condition

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L66-69)
```csharp
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L71-72)
```csharp
            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L76-76)
```csharp
            return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L282-282)
```csharp
        return victories.Pubkeys.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-23)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-92)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-94)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```
