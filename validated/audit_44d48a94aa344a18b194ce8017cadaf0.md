# Audit Report

## Title
Integer Overflow in RoundId Calculation Enables Consensus Denial of Service

## Summary
The `RoundId` property in the AEDPoS consensus contract computes the sum of all miners' `ExpectedMiningTime.Seconds` values without bounds validation. A malicious miner can submit a `NextRound` transaction with `ExpectedMiningTime` values near `long.MaxValue`, causing an `OverflowException` during pre-execution validation, which results in block rejection and consensus disruption.

## Finding Description

The vulnerability exists in the `RoundId` property getter that calculates a sum without validating individual input values: [1](#0-0) 

When a `NextRound` transaction is submitted, the consensus validation framework calls `ValidateConsensusBeforeExecution` as part of the ACS4 interface: [2](#0-1) 

This triggers `ValidateBeforeExecution` which uses multiple validation providers including `TimeSlotValidationProvider`: [3](#0-2) 

The `TimeSlotValidationProvider` accesses the `RoundId` property to determine if a new round is being proposed: [4](#0-3) 

The `CheckRoundTimeSlots()` validation method only verifies that mining intervals between consecutive miners are consistent and positive, but does NOT validate that `ExpectedMiningTime` values themselves are reasonable or bounded: [5](#0-4) 

The AEDPoS contract has overflow checking explicitly enabled in both Debug and Release configurations: [6](#0-5) 

When `CheckForOverflowUnderflow=true`, LINQ's `Sum()` operation throws an `OverflowException` if the result exceeds `long.MaxValue`. With 17 miners each having `ExpectedMiningTime.Seconds = long.MaxValue - 1000`, the sum would be approximately `1.57E20`, which massively exceeds `long.MaxValue` (9.22E18).

The access control check allows any miner in the current or previous round to submit `NextRound` transactions: [7](#0-6) 

## Impact Explanation

**Consensus Denial of Service**: A malicious miner can craft a `NextRoundInput` with `ExpectedMiningTime.Seconds` values set to extremely large numbers (near `long.MaxValue`). When other nodes attempt to validate the block containing this transaction:

1. The pre-execution validation accesses the `RoundId` property
2. The `Sum()` operation attempts to add values exceeding `long.MaxValue`
3. An `OverflowException` is thrown due to enabled overflow checking
4. Block validation fails catastrophically (exception rather than clean rejection)
5. All nodes reject the block

This creates a consensus disruption where:
- The malicious miner can repeatedly produce invalid blocks
- Round progression is blocked until a valid NextRound transaction is accepted
- If the attacker is the designated extra block producer or in a critical position for round transition, they can significantly delay or halt consensus progression

The severity is High because:
- It's a critical consensus layer vulnerability
- Any miner can trigger it (low barrier to entry)
- The cost is minimal (only transaction fees)
- It breaks the availability guarantee of the consensus system

## Likelihood Explanation

**Attack Feasibility**: HIGH

The attack is highly feasible because:

1. **Reachable Entry Point**: The `NextRound` method is a public consensus method accessible to any miner in the current or previous round

2. **Attacker Capabilities**: Becoming a miner is achievable through the normal election process, and once elected, the attacker can construct arbitrary `NextRoundInput` messages with malicious `ExpectedMiningTime` values

3. **Validation Bypass**: The time slot validation logic only checks relative intervals between miners, not absolute timestamp values, allowing malicious values to pass initial validation until the overflow occurs during `RoundId` calculation

4. **No Input Bounds Checking**: There is no validation that `ExpectedMiningTime.Seconds` values are reasonable, within expected ranges, or based on actual current time

5. **Economic Rationality**: The attack cost is negligible (only transaction fees), while the impact is significant consensus disruption, making it economically rational for malicious actors

## Recommendation

Add input validation to ensure `ExpectedMiningTime` values are reasonable before calculating `RoundId`:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // NEW: Validate absolute timestamp bounds
    var currentTime = Context.CurrentBlockTime.Seconds;
    var maxReasonableTime = currentTime + (miners.Count * 8); // Allow reasonable future window
    if (miners.Any(m => m.ExpectedMiningTime.Seconds > maxReasonableTime || 
                        m.ExpectedMiningTime.Seconds < currentTime - 60))
        return new ValidationResult { Message = "ExpectedMiningTime values are out of reasonable bounds." };

    var baseMiningInterval = (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
    
    // ... rest of validation
}
```

Additionally, consider using checked arithmetic explicitly or implementing safe summation:

```csharp
public long RoundId
{
    get
    {
        if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
        {
            try
            {
                return RealTimeMinersInformation.Values
                    .Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds)
                    .Aggregate(0L, (acc, val) => checked(acc + val));
            }
            catch (OverflowException)
            {
                // Log and return error indicator
                return -1;
            }
        }
        return RoundIdForValidation;
    }
}
```

## Proof of Concept

A proof of concept would demonstrate:
1. Creating a test miner account and getting it elected to the miner list
2. Constructing a malicious `NextRoundInput` with all miners having `ExpectedMiningTime.Seconds = long.MaxValue - 1000`
3. Ensuring the intervals between consecutive miners are consistent (e.g., 4 seconds)
4. Submitting the `NextRound` transaction
5. Observing that `ValidateConsensusBeforeExecution` throws an `OverflowException` when accessing `RoundId`
6. Confirming that the block is rejected by all validating nodes

The test would verify that the overflow occurs during the `Sum()` operation in the `RoundId` property getter when processing the malicious round information, causing validation to fail with an exception rather than cleanly rejecting invalid input.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElf.Contracts.Consensus.AEDPoS.csproj (L11-17)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
