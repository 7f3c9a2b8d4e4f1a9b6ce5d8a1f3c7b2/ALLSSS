# Audit Report

## Title
Chain ID Spoofing in Cross-Chain Verification Enables Unlimited Token Minting via Compromised Side Chains

## Summary
The cross-chain token verification system accepts a user-controlled chain ID parameter without validating it corresponds to the legitimate source chain for the token transfer. An attacker controlling any indexed side chain can exploit this to mint unlimited tokens by providing merkle proofs from their compromised chain instead of the actual source chain.

## Finding Description

The vulnerability exists in the cross-chain verification flow where the `CrossChainReceiveToken` method accepts user-controlled `input.FromChainId` and passes it directly to the verification system without validating it represents the authorized source chain for the token transfer. [1](#0-0) 

The `CrossChainVerify` helper method constructs a `VerifyTransactionInput` using the user-provided `chainId` as `VerifiedChainId` and calls the CrossChain contract's verification. [2](#0-1) 

The `VerifyTransaction` method then uses this user-controlled `VerifiedChainId` to fetch the merkle root for verification, without any validation that this chain ID is the correct or authorized chain for the verification context. [3](#0-2) 

The `GetMerkleTreeRoot` method returns different merkle roots based on the chain ID: parent chain if it matches `State.ParentChainId.Value`, side chain if it exists in `State.SideChainInfo`, or cousin chain otherwise. Critically, there is no check that the provided chain ID is the expected chain for this specific verification. [4](#0-3) 

**Attack Scenario:**
1. Attacker controls Side Chain B (compromised through consensus control)
2. Attacker creates fake `CrossChainTransfer` transactions on Side Chain B showing arbitrary token amounts
3. These blocks get indexed on the main chain through normal cross-chain indexing
4. Attacker calls `CrossChainReceiveToken` on the main chain with `FromChainId = Side Chain B`
5. The verification checks against Side Chain B's merkle root (which the attacker controls)
6. Verification passes, and tokens are minted on the main chain

The only validation performed is that the chain is registered in the whitelist and the transaction is to the registered token contract address. However, since the attacker controls the entire side chain, they control what transactions exist and can create any merkle proofs they want. [5](#0-4) 

After verification passes, tokens are minted by increasing the supply and crediting the receiver's balance. [6](#0-5) 

## Impact Explanation

This vulnerability has CRITICAL impact because it enables unlimited token minting if ANY single side chain in the entire AElf ecosystem is compromised:

**Direct Financial Impact:**
- Attacker can mint unlimited tokens of any symbol without burning anything on any legitimate chain
- This causes massive token supply inflation, destroying the economic value of all existing token holders
- Complete breakdown of the cross-chain token integrity model

**Systemic Risk:**
- The security of the entire cross-chain token system depends on the WEAKEST indexed side chain
- One compromised side chain breaks the security model for ALL chains in the ecosystem
- No isolation between side chains - compromise of one affects all

**Violated Security Invariant:**
The fundamental invariant that "tokens should only be minted when legitimately burned on an authorized chain" is completely broken. The user, not the protocol, decides which chain to verify against.

## Likelihood Explanation

The likelihood is HIGH due to several factors:

**Attack Feasibility:**
- Attacker only needs to compromise ONE indexed side chain (not the main chain)
- Side chains may have varying security levels - experimental or lower-value chains may be easier targets
- Attack is straightforward once chain is compromised: create fake transactions, get them indexed, call `CrossChainReceiveToken`

**No Complex Prerequisites:**
- No cryptographic attacks needed
- No race conditions or timing dependencies  
- Simple parameter substitution attack
- Direct exploitation path with immediate results

**Increasing Probability:**
As the AElf ecosystem grows and more side chains are added, the probability that at least one is compromised increases significantly. The attack surface expands with each new side chain.

**No Detection Mechanisms:**
There are no built-in mechanisms to detect chain ID substitution attacks or validate that the provided chain ID is the expected one for a given transfer.

## Recommendation

Add validation to ensure the `FromChainId` parameter matches the expected source chain for the token transfer. Possible approaches:

1. **Remove User Control:** Don't accept `FromChainId` as a user input. Instead, derive it from the transaction content or require the original burn transaction to include metadata about which chains are authorized to mint.

2. **Bidirectional Registration:** Require explicit bidirectional registration where chains must mutually authorize each other for token transfers. Maintain a mapping of authorized chain pairs.

3. **Transfer Context Validation:** Store the source chain ID when tokens are burned in `CrossChainTransfer` and validate that `CrossChainReceiveToken` is called with the matching chain ID.

4. **Chain Trust Levels:** Implement a trust level system where only explicitly trusted chains can be used for token minting, rather than allowing any indexed chain.

Example fix for option 3:
```csharp
// In CrossChainTransfer, include source chain in the event
Context.Fire(new CrossChainTransferred
{
    From = Context.Sender,
    To = input.To,
    Symbol = tokenInfo.Symbol,
    Amount = input.Amount,
    FromChainId = Context.ChainId, // Source chain
    ToChainId = input.ToChainId,
    // ... other fields
});

// In CrossChainReceiveToken, validate FromChainId matches the burn transaction
var crossChainTransferInput = CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
var expectedSourceChain = /* derive from transaction or embedded in transfer event */;
Assert(input.FromChainId == expectedSourceChain, "FromChainId does not match the actual source chain of the transfer.");
```

## Proof of Concept

```csharp
[Fact]
public async Task ChainIdSpoofing_UnauthorizedTokenMinting_Test()
{
    // Setup: Create two side chains - Chain A (legitimate) and Chain B (compromised)
    var legitimateChainId = await GenerateSideChainAsync(); // Chain A
    var compromisedChainId = await GenerateSideChainAsync(); // Chain B
    
    // Register both chains' token contracts
    await RegisterSideChainContractAddressOnMainChainAsync();
    
    // Attacker controls Chain B and creates a fake CrossChainTransfer transaction
    // This transaction shows tokens being "transferred" from Chain B to Main Chain
    // but no actual tokens were burned on any legitimate chain
    var fakeTransferTx = /* Create malicious CrossChainTransfer transaction on compromised chain */;
    
    // Get merkle proof from compromised Chain B
    var maliciousMerklePath = /* Merkle path from compromised chain */;
    var blockHeight = /* Height where fake transaction was indexed */;
    
    // Attacker calls CrossChainReceiveToken with FromChainId = compromised chain
    var result = await MainChainTokenContractStub.CrossChainReceiveToken.SendAsync(
        new CrossChainReceiveTokenInput
        {
            FromChainId = compromisedChainId, // Attacker specifies their controlled chain
            ParentChainHeight = blockHeight,
            TransferTransactionBytes = fakeTransferTx.ToByteString(),
            MerklePath = maliciousMerklePath
        });
    
    // Vulnerability: Verification passes because it checks against compromised chain's merkle root
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Tokens are minted without any legitimate burn on any authorized chain
    var balance = await MainChainTokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = AttackerAddress,
        Symbol = NativeToken
    });
    
    // Attack succeeds: attacker receives minted tokens
    balance.Balance.ShouldBeGreaterThan(0); // Tokens minted from thin air
}
```

**Notes:**
The vulnerability is valid because the `VerifiedChainId` parameter in the cross-chain verification system is user-controlled and not validated against the expected source chain. This violates the fundamental security principle that users should not control which chain's merkle root is used for security-critical verification. The attack is feasible because compromising any single indexed side chain (which may have lower security than the main chain) is sufficient to break the security of the entire token system across all chains.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-617)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L620-623)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```
