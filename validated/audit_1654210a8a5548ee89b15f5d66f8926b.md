# Audit Report

## Title
Missing LIB Monotonicity Validation in NextRound Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockHeight` (LIB) maintains its monotonically increasing invariant when processing `NextRound` transitions. A malicious miner can submit a `NextRound` transaction with decreased LIB values, bypassing validation and corrupting the consensus state stored on-chain.

## Finding Description

The vulnerability exists in the consensus validation pipeline where different validation providers are conditionally applied based on the consensus behavior type.

**Root Cause:**

The `ValidateBeforeExecution` method applies different validation providers based on consensus behavior: [1](#0-0) 

For `UpdateValue` behavior, the validation includes `LibInformationValidationProvider` which enforces LIB monotonicity. However, for `NextRound` behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied - the critical `LibInformationValidationProvider` is omitted.

The `LibInformationValidationProvider` contains the only check that prevents LIB from decreasing: [2](#0-1) 

**Attack Path:**

1. A miner with active mining rights calls the public `NextRound` method: [3](#0-2) 

2. The attacker crafts a `NextRoundInput` with `ConfirmedIrreversibleBlockHeight` set to a value lower than the current consensus state's LIB.

3. Validation occurs via `ValidateConsensusBeforeExecution`: [4](#0-3) 

4. Since `LibInformationValidationProvider` is not in the validation pipeline for `NextRound`, the malicious LIB values pass validation.

5. The `RoundTerminateValidationProvider` that IS applied only checks round number and InValue fields: [5](#0-4) 

6. Execution proceeds through `ProcessNextRound`: [6](#0-5) 

7. The input is converted to a Round object via `ToRound()`, which preserves the malicious LIB values: [7](#0-6) 

8. The corrupted round is stored to state via `AddRoundInformation`: [8](#0-7) 

9. The consensus state now contains a decreased LIB value, violating the monotonicity invariant.

## Impact Explanation

**Critical Severity** - This vulnerability breaks a fundamental consensus invariant with protocol-wide implications:

**Consensus Integrity Violation:**
- The Last Irreversible Block (LIB) height is a core finality indicator - once a block reaches LIB status, it should never become reversible
- Decreasing the LIB effectively reverts finality decisions, creating uncertainty about transaction permanence
- All nodes rely on consensus state for block confirmation and chain progression

**Cross-Chain Impact:**
- Cross-chain operations depend on LIB for indexing parent-chain blocks and validating cross-chain proofs
- A corrupted LIB can cause cross-chain transfer verification failures between main chain and side chains
- Side chain synchronization with main chain relies on accurate LIB values [9](#0-8) 

**Protocol-Wide State Corruption:**
- When generating the next round, the corrupted LIB is propagated forward
- Other system contracts may query the consensus LIB for critical operations
- Election contract snapshots and treasury releases may execute based on corrupted round information

## Likelihood Explanation

**High Likelihood** - The attack is straightforward and accessible to any active miner:

**Attacker Prerequisites:**
- Must be an active miner in the current miner list (obtainable through election)
- No special privileges beyond standard mining rights required
- No economic cost beyond normal block production

**Attack Complexity:**
- Low complexity - attacker simply modifies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields in the `NextRoundInput` parameter
- The transaction generation flow shows how miners create NextRound transactions: [10](#0-9) 

- Miners control the transaction parameters when producing their NextRound block

**Detection Difficulty:**
- The malicious transaction passes all validation checks normally
- No validation after execution catches the discrepancy: [11](#0-10) 

- State corruption manifests only when dependent systems query the corrupted LIB values

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` and `NextTerm` behaviors, ensuring LIB monotonicity is enforced for all consensus transitions.

**Fix in `AEDPoSContract_Validation.cs`:**

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // ADD THIS: Validate LIB monotonicity for NextRound
    validationProviders.Add(new LibInformationValidationProvider());
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    // ADD THIS: Validate LIB monotonicity for NextTerm
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

This ensures that any attempt to decrease `ConfirmedIrreversibleBlockHeight` or `ConfirmedIrreversibleBlockRoundNumber` during round transitions will be rejected with the validation error "Incorrect lib information."

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithDecreasedLIB_ShouldCorruptConsensusState()
{
    // Setup: Initialize consensus with normal LIB progression
    var initialRound = GenerateFirstRound();
    initialRound.ConfirmedIrreversibleBlockHeight = 1000;
    initialRound.ConfirmedIrreversibleBlockRoundNumber = 50;
    await InitializeConsensus(initialRound);
    
    // Advance to next round normally
    var currentRound = await GetCurrentRound();
    var minerPubkey = currentRound.RealTimeMinersInformation.Keys.First();
    
    // Attack: Create NextRound with DECREASED LIB values
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        ConfirmedIrreversibleBlockHeight = 900, // DECREASED from 1000
        ConfirmedIrreversibleBlockRoundNumber = 45, // DECREASED from 50
        RealTimeMinersInformation = { /* ... valid miner info ... */ }
    };
    
    // Execute: Call NextRound with malicious input
    var result = await ConsensusStub.NextRound.SendAsync(maliciousNextRoundInput);
    
    // Verify: Transaction succeeds (validation does not catch it)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Consensus state is corrupted with lower LIB
    var corruptedRound = await GetCurrentRound();
    corruptedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(900); // Decreased!
    corruptedRound.ConfirmedIrreversibleBlockRoundNumber.ShouldBe(45); // Decreased!
    
    // Impact: LIB monotonicity invariant is violated
    Assert.True(corruptedRound.ConfirmedIrreversibleBlockHeight < 1000, 
        "LIB height decreased - consensus state corrupted!");
}
```

## Notes

This vulnerability affects the core consensus mechanism and has been validated through complete code path analysis. The attack is feasible because:

1. The validation gap is confirmed in the source code - `LibInformationValidationProvider` is explicitly excluded from `NextRound` validation
2. The `NextRound` method is public and callable by any active miner
3. No other validation catches the LIB decrease
4. The corrupted state persists across subsequent rounds

The fix is straightforward and maintains consistency with the validation approach used for `UpdateValue` behavior. The same `LibInformationValidationProvider` that successfully prevents LIB decrease in `UpdateValue` should be applied to all consensus transition behaviors.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-71)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```
