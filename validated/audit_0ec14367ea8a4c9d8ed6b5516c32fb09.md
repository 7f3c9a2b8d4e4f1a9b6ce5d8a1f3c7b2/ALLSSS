# Audit Report

## Title
Unvalidated RevealedInValues Allow PreviousInValue Poisoning Leading to Miner DoS

## Summary
The AEDPoS consensus contract's `UpdateLatestSecretPieces()` function accepts `RevealedInValues` from block producer trigger information without cryptographic validation and uses them to set other miners' `PreviousInValue` fields. A malicious consensus miner can inject fake revealed values to poison victim miners' `PreviousInValue`, preventing them from successfully producing blocks due to validation failures. This enables targeted denial-of-service attacks against specific miners.

## Finding Description

The vulnerability stems from a missing validation check in the secret sharing mechanism. When a miner produces a block, they provide `RevealedInValues` for other miners in their trigger information. The contract blindly applies these values without verifying their correctness.

**Root Cause**: The `UpdateLatestSecretPieces()` function unconditionally applies `RevealedInValues` from trigger information to other miners' `PreviousInValue` fields when those fields are `Hash.Empty` or `null`: [1](#0-0) 

**Missing Validation**: The consensus validation only checks the block producer's own `PreviousInValue`, not the `RevealedInValues` they provide for other miners. The validation uses `validationContext.SenderPubkey` which refers only to the block producer: [2](#0-1) 

**Why Protection Fails**: Once a `PreviousInValue` is set (even to a fake value), the `Hash.Empty`/`null` check prevents legitimate updates: [3](#0-2) 

**Propagation Mechanism**: The poisoned values are propagated through the block header via `GetUpdateValueRound`, which includes all miners' `PreviousInValue` fields: [4](#0-3) 

These values are then recovered during validation before validation providers run: [5](#0-4) 

The poisoned values persist through state updates via `ExtractInformationToUpdateConsensus`: [6](#0-5) 

And are applied to contract state via `PerformSecretSharing`: [7](#0-6) 

**Attack Execution**:
1. Malicious Miner M modifies their node software to provide fake `RevealedInValues[Victim] = FakeHash`
2. M produces a block when Victim's `PreviousInValue` is `Hash.Empty` (victim missed previous mining)
3. `UpdateLatestSecretPieces` applies `FakeHash` to Victim's `PreviousInValue`
4. Block passes validation (only M's own data is validated)
5. When Victim tries to mine, their correct `PreviousInValue` cannot overwrite `FakeHash` due to the `Hash.Empty` check
6. Victim's block contains the poisoned value in the round data
7. Validation checks `hash(FakeHash)` against Victim's previous `OutValue`, which fails
8. Victim's block is rejected

## Impact Explanation

**Consensus Integrity Impact**: Malicious miners can arbitrarily prevent specific victim miners from producing blocks, directly violating consensus fairness guarantees. The attack enables targeted exclusion of competing miners from block production.

**Economic Impact**: Victim miners lose block production rewards for each rejected block. The `ProducedBlocks` count is not incremented while `MissedTimeSlots` increases, affecting reputation metrics and potentially future mining slot assignments.

**Operational Impact**: Network throughput can be reduced if multiple miners are targeted simultaneously. The attack creates unpredictability in consensus operations and can cascade across rounds as poisoned values remain in state until the next term change.

**Affected Parties**: Individual miners who missed mining in previous rounds become vulnerable. The network overall experiences reduced reliability, and token holders may experience delays in transaction finality.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must be an authorized consensus miner (high privilege but within the adversarial threat model for consensus systems). They must modify their node software to inject fake `RevealedInValues` - a simple code change with no cryptographic complexity.

**Attack Complexity**: LOW - The attacker only needs to modify trigger information generation before producing a block. No timing precision or multi-step coordination is required.

**Feasibility Conditions**: 
- Victim must have missed mining in a previous round (common due to network issues, maintenance, restarts, or previous attacks)
- Attacker must produce a block before victim in the subsequent round (probability inversely proportional to miner count)
- Secret sharing must be enabled, which is configuration-dependent: [8](#0-7) 

**Detection Constraints**: While the attack is theoretically detectable by comparing on-chain `RevealedInValues` with legitimate secret sharing reconstruction, detection is post-facto. No in-contract prevention mechanism exists, and victims have no recourse once poisoned.

**Probability**: MEDIUM-HIGH - Miners routinely miss rounds due to operational issues. Malicious miners in competitive scenarios have strong economic incentives to exclude competitors, with zero cost and direct benefit.

## Recommendation

Implement cryptographic validation of `RevealedInValues` before applying them to other miners' `PreviousInValue` fields. The validation should verify that the revealed value is consistent with the decrypted secret sharing pieces:

```csharp
private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
    AElfConsensusTriggerInformation triggerInformation)
{
    // ... existing encrypted/decrypted pieces logic ...

    foreach (var revealedInValue in triggerInformation.RevealedInValues)
    {
        if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
            continue;
            
        var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
        
        // Only apply if PreviousInValue is not set
        if (targetMiner.PreviousInValue != Hash.Empty && targetMiner.PreviousInValue != null)
            continue;
            
        // Validate the revealed value using secret sharing reconstruction
        if (!ValidateRevealedInValue(updatedRound, revealedInValue.Key, revealedInValue.Value))
        {
            Context.LogDebug(() => $"Invalid revealed in value for {revealedInValue.Key}, skipping");
            continue;
        }
        
        targetMiner.PreviousInValue = revealedInValue.Value;
    }
}

private bool ValidateRevealedInValue(Round round, string minerPubkey, Hash revealedValue)
{
    var minerInRound = round.RealTimeMinersInformation[minerPubkey];
    
    // Require minimum threshold of decrypted pieces
    var minersCount = round.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;
    
    if (minerInRound.DecryptedPieces.Count < minimumCount)
        return false;
        
    // Reconstruct the value from decrypted pieces
    var orders = minerInRound.DecryptedPieces.Select((t, i) =>
            round.RealTimeMinersInformation.Values
                .First(m => m.Pubkey == minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
        .ToList();

    var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
        .Select(s => s.ToByteArray()).ToList();

    var reconstructedValue = HashHelper.ComputeFrom(
        SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
    
    // Verify the revealed value matches reconstruction
    return reconstructedValue == revealedValue;
}
```

Additionally, add validation in `UpdateValueValidationProvider` to check all miners' `PreviousInValue` fields, not just the sender's.

## Proof of Concept

A proof of concept would require:

1. Deploy a test AEDPoS network with multiple miners
2. Have Miner A miss a round (set `PreviousInValue = Hash.Empty`)
3. Have Miner B (malicious) modify their node to inject fake `RevealedInValues[MinerA] = FakeHash` in trigger information
4. Miner B produces a block
5. Verify that Miner A's `PreviousInValue` is set to `FakeHash` in contract state
6. Have Miner A attempt to produce a block
7. Verify that Miner A's block is rejected due to validation failure on the poisoned `PreviousInValue`

The test would demonstrate that without cryptographic validation of `RevealedInValues`, malicious miners can poison victim miners' consensus state and prevent them from producing blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
