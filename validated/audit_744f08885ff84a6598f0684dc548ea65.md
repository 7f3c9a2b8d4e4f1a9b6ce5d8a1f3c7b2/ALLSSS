# Audit Report

## Title
Secret Sharing Threshold Validation Requires 100% Participation Instead of Configured 2/3 Threshold

## Summary
The AEDPoS consensus contract implements Shamir's t-of-n secret sharing with a 2/3 threshold but incorrectly validates that 100% of miners must participate before attempting secret reconstruction. This defeats the fault-tolerance purpose of threshold cryptography and enables any single miner to prevent all other miners from having their `PreviousInValue` revealed through a zero-cost griefing attack.

## Finding Description

The vulnerability stems from a fundamental mismatch between the cryptographic threshold configuration and the validation logic used before secret reconstruction.

**Threshold Configuration (2/3):**
The system correctly calculates the threshold as two-thirds of miners. [1](#0-0) 

**Incorrect Validation (100%):**
However, the validation logic requires 100% of miners to have submitted their decrypted pieces before attempting reconstruction. [2](#0-1) 

This check requires `DecryptedPieces.Count >= minersCount` (100%) even though `minimumCount` (2/3) was calculated earlier.

**Cryptographic Function Uses Correct Threshold:**
The actual secret reconstruction correctly uses the 2/3 threshold. [3](#0-2) 

This proves the cryptographic scheme only needs `minimumCount` shares, not `minersCount` shares.

**Attack Execution:**
When miners submit their consensus data via `UpdateValue`, the `PerformSecretSharing` method stores `DecryptedPieces` without validation. [4](#0-3) 

A malicious miner can simply omit their `DecryptedPieces` for target miners. When `RevealSharedInValues` later attempts to reconstruct secrets, it will skip any miner whose `DecryptedPieces.Count < minersCount`, even though reconstruction would succeed with `minimumCount` pieces.

**Data Collection Without Validation:**
The `ExtractInformationToUpdateConsensus` function collects decrypted pieces but performs no threshold validation. [5](#0-4) 

**Fallback Mechanism:**
When `PreviousInValue` cannot be revealed, the system allows null/empty values. [6](#0-5) 

The validation explicitly allows this. [7](#0-6) 

While this allows the system to continue operating, it undermines the commit-reveal randomness scheme's integrity.

**No Punishment Mechanism:**
Evil miner detection only checks `MissedTimeSlots`, not failure to submit `DecryptedPieces`. [8](#0-7) 

## Impact Explanation

**1. Defeats Threshold Cryptography Design:**
Shamir's Secret Sharing is specifically designed to provide fault tolerance - secrets can be reconstructed with only t-of-n shares. By requiring n-of-n participation, the implementation completely defeats this core property.

**2. Griefing Attack:**
Any single malicious miner can prevent ALL other miners from having their `PreviousInValue` revealed by simply not submitting their `DecryptedPiece` during their `UpdateValue` transaction. This is a powerful griefing vector with zero economic cost to the attacker.

**3. Consensus Randomness Manipulation:**
The commit-reveal scheme relies on miners committing to secret values (`InValue`) and later revealing them. When revelation fails, the system uses deterministic fallback values that are predictable and manipulable, weakening the randomness guarantees that secure block producer selection and mining order.

**4. No Detection or Punishment:**
Unlike missed time slots which trigger evil miner detection, failure to submit decrypted pieces goes undetected and unpunished, making this a risk-free attack.

**Severity: HIGH** - Breaks fundamental cryptographic assumptions, enables zero-cost griefing affecting entire miner set, and undermines consensus randomness security.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the consensus set (reachable privilege through normal election process)
- No special permissions beyond standard block production rights

**Attack Complexity:**
- Trivial - attacker simply omits `DecryptedPieces` from their `UpdateValue` input
- Passive attack (omission) rather than active manipulation
- No special timing or coordination required

**Feasibility:**
- Attack succeeds with just one malicious miner out of the entire set
- Works even if 99% of miners are honest (requires only n-1 pieces to fail the >= minersCount check)
- No economic cost or on-chain evidence of malicious intent

**Detection:**
- Indistinguishable from network issues or temporary unavailability
- No mechanism to prove deliberate withholding versus technical difficulties

**Incentive Compatibility:**
Miners are incentivized to execute this attack to:
- Prevent competitors from proper `PreviousInValue` verification
- Create consensus instability for their benefit
- Manipulate randomness for favorable mining order

**Probability: HIGH** - Any rational adversarial miner can and would exploit this to gain competitive advantage with zero risk.

## Recommendation

Change the validation logic in `RevealSharedInValues` to use the calculated `minimumCount` threshold instead of requiring `minersCount`:

```csharp
// Change line 36 in AEDPoSContract_SecretSharing.cs from:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// To:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This aligns the validation with the actual cryptographic requirement and restores the fault-tolerance property of Shamir's Secret Sharing scheme.

Additionally, consider adding detection and punishment for miners who consistently fail to provide their share of decrypted pieces, similar to the existing `MissedTimeSlots` mechanism.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public void SecretSharing_RequiresFullParticipation_Instead_Of_Threshold()
{
    // Setup: 5 miners, 2/3 threshold = 3 miners needed
    const int totalMiners = 5;
    const int minimumCount = 3; // 2/3 of 5
    
    // Simulate scenario where only 4 out of 5 miners provide DecryptedPieces
    var previousRound = CreateRoundWithMiners(totalMiners);
    var targetMiner = previousRound.RealTimeMinersInformation.First().Key;
    
    // Add EncryptedPieces (all 5 miners encrypted)
    previousRound.RealTimeMinersInformation[targetMiner].EncryptedPieces.Add(
        CreateEncryptedPieces(totalMiners));
    
    // Only 4 miners provide DecryptedPieces (one malicious miner withholds)
    AddDecryptedPieces(previousRound, targetMiner, 4); // Only 4 out of 5
    
    // Current implementation FAILS even though 4 > minimumCount (3)
    // Secret reconstruction is skipped due to line 36 check
    var currentRound = CreateNextRound(previousRound);
    
    // Verify vulnerability: PreviousInValue not revealed despite having enough shares
    Assert.True(previousRound.RealTimeMinersInformation[targetMiner].DecryptedPieces.Count >= minimumCount);
    Assert.True(previousRound.RealTimeMinersInformation[targetMiner].DecryptedPieces.Count < totalMiners);
    
    // After RevealSharedInValues, PreviousInValue should be null/empty
    // even though reconstruction would succeed with 4 pieces (> minimumCount of 3)
    Assert.Null(currentRound.RealTimeMinersInformation[targetMiner].PreviousInValue);
    
    // Demonstrates: Single miner can grief entire network by withholding one piece
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L263-264)
```csharp
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-42)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
