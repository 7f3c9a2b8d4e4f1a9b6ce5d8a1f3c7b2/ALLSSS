# Audit Report

## Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

## Summary
When a miner replaces their public key during a term via `ReplaceCandidatePubkey`, the Election Contract removes the old pubkey's `candidateInformation` and transfers it to the new pubkey. However, the Consensus Contract only updates the current round data, leaving previous rounds with the old pubkey. When `TakeSnapshot` is called at term end, it retrieves miners from stored previous round data (containing old pubkeys) and attempts to update `candidateInformation`, but silently fails due to an early return when the old pubkey's data is null. This causes miners to lose credit for terms where they successfully participated.

## Finding Description

The vulnerability stems from incomplete synchronization between the Election and Consensus contracts during pubkey replacement.

**Root Cause Flow:**

When `ReplaceCandidatePubkey` is called, the Election Contract transfers `candidateInformation` from old to new pubkey and removes the old entry: [1](#0-0) 

The Consensus Contract is notified via `RecordCandidateReplacement`, which only updates the **current round**: [2](#0-1) 

**Critical Gap:** Previous rounds stored in `State.Rounds[previousRoundNumbers]` are never updated and still contain the old pubkey.

**Failure Point at Term End:**

When `TakeSnapshot` is called, it retrieves previous term miners: [3](#0-2) 

`GetPreviousTermMinerPubkeyList` returns pubkeys directly from stored round data without applying any replacement mapping: [4](#0-3) 

The private `UpdateCandidateInformation` method has an early return when `candidateInformation` is null: [5](#0-4) 

Since the old pubkey's `candidateInformation` was removed during `ReplaceCandidatePubkey`, the update silently fails. The miner's `Terms` list (line 486) and `ContinualAppointmentCount` (line 488-490) are never updated for that term.

**Why Existing Protections Fail:**

The codebase has `GetNewestPubkey` specifically to handle pubkey replacements: [6](#0-5) 

This function is correctly used in other flows like vote withdrawal: [7](#0-6) 

And in view methods for snapshot retrieval: [8](#0-7) 

However, it is **not used** in the `TakeSnapshot` flow before calling `UpdateCandidateInformation`, causing the vulnerability.

## Impact Explanation

**Direct Impact:**
- Miners who replace their pubkeys lose historical credit for terms where they actively participated and produced blocks
- The `Terms` list in `candidateInformation` becomes incomplete, violating the documented invariant that it indicates "which terms the candidate participated in"
- `ContinualAppointmentCount` is incorrectly calculated, breaking continuity tracking for consecutive term participation

**Affected Parties:**
- Any miner who uses the legitimate pubkey replacement feature for key rotation
- Voters who rely on accurate candidate participation history for informed voting decisions
- Off-chain systems or UIs that display miner participation records

**Severity:** This is a **High** severity issue because it directly compromises the integrity of election system records, which are fundamental to transparency and accountability in the AEDPoS consensus mechanism. While it doesn't cause direct fund loss, it breaks critical protocol invariants and could affect future eligibility or reward calculations if the `Terms` list is used in such logic.

## Likelihood Explanation

**Trigger Conditions:**
- Any registered candidate/miner can call `ReplaceCandidatePubkey` (only requires candidate admin permission, which is legitimate)
- No special timing required - can happen at any point during a term
- The term credit loss occurs automatically when the term ends and `TakeSnapshot` is called by the consensus contract

**Attack Complexity:** Extremely simple - just use the legitimate pubkey replacement feature. No race conditions, no special setup, no suspicious behavior.

**Probability:** **High** - This will occur for every miner who replaces their pubkey before a term ends. The feature is specifically designed for key rotation scenarios in production environments, so usage is expected and encouraged for security best practices.

## Recommendation

Modify the `TakeSnapshot` method to resolve pubkey replacements before calling `UpdateCandidateInformation`. Specifically, in the loop at line 433-434, apply `GetNewestPubkey` to each pubkey retrieved from `previousTermMinerList`:

```csharp
foreach (var pubkey in previousTermMinerList)
{
    var newestPubkey = GetNewestPubkey(pubkey);
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

This mirrors the pattern already used successfully in the `Withdraw` flow and `GetPreviousTermSnapshotWithNewestPubkey` method, ensuring that term credits are correctly applied to the miner's current pubkey regardless of when the replacement occurred.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. A miner participates in term N and produces blocks successfully
2. During term N (before it ends), the miner calls `ReplaceCandidatePubkey` to change from OldPubkey to NewPubkey
3. The Election Contract moves `candidateInformation` to NewPubkey and removes OldPubkey's entry
4. The Consensus Contract updates only the current round, not previous rounds
5. Term N ends and `TakeSnapshot` is called
6. `GetPreviousTermMinerPubkeyList` returns OldPubkey from the stored previous round data
7. `UpdateCandidateInformation(OldPubkey, ...)` is called
8. The method returns early at line 485 because `State.CandidateInformationMap[OldPubkey]` is null
9. Result: The miner's `Terms` list at NewPubkey does not include term N, despite successful participation

The existing test suite in `test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs` validates the pubkey replacement mechanics but does not cover the interaction with term snapshots, which is why this vulnerability was not caught.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L430-434)
```csharp
        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L484-492)
```csharp
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-472)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L63-64)
```csharp
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
        var oldCandidateVotes = State.CandidateVotes[oldVoteOptionPublicKey];
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L151-151)
```csharp
            var newestPubkey = GetNewestPubkey(bannedCandidate);
```
