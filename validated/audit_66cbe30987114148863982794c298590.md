# Audit Report

## Title
Share Accounting Divergence via FixProfitDetail and AddBeneficiary Cleanup

## Summary
A critical accounting vulnerability in the Profit Contract allows `TotalShares` to become permanently inflated when `FixProfitDetail` sets `EndPeriod` to be less than or equal to `LastProfitPeriod`, followed by automatic cleanup in `AddBeneficiary` that removes the detail from `ProfitDetailsMap` without decrementing `TotalShares`. This causes all future profit distributions to be calculated with an inflated denominator, permanently diluting profits for all legitimate beneficiaries.

## Finding Description

The vulnerability exists due to an inconsistency between two cleanup mechanisms in the Profit Contract:

**Mechanism 1: AddBeneficiary Cleanup (Missing TotalShares Decrement)**

The cleanup logic in `AddBeneficiary` removes expired profit details but does NOT decrement `TotalShares`: [1](#0-0) 

This cleanup triggers when all three conditions are met:
1. `EndPeriod != long.MaxValue`
2. `LastProfitPeriod >= EndPeriod` (greater than or equal)
3. `EndPeriod + ProfitReceivingDuePeriodCount < CurrentPeriod`

**Mechanism 2: ClaimProfits Cleanup (Proper TotalShares Decrement)**

In contrast, `ClaimProfits` properly decrements `TotalShares` when removing expired details: [2](#0-1) 

However, it only removes details where `LastProfitPeriod > EndPeriod` (strictly greater than, not equal).

**The Problematic Entry Point: FixProfitDetail**

The `FixProfitDetail` method allows modifying `EndPeriod` without any validation or `TotalShares` adjustment: [3](#0-2) 

This method has authorization checks but no validation preventing `EndPeriod` from being set to values less than or equal to `LastProfitPeriod`: [4](#0-3) 

**The Edge Case Exploit Path:**

1. A beneficiary has a profit detail with `LastProfitPeriod = 10`, `EndPeriod = 20`, `Shares = 100`
2. Scheme manager or TokenHolder contract calls `FixProfitDetail` to set `EndPeriod = 5` (less than `LastProfitPeriod`)
3. Now the detail has `LastProfitPeriod = 10`, `EndPeriod = 5`
4. The detail becomes **unclaimable** because `ClaimProfits` checks `EndPeriod >= LastProfitPeriod` to determine availability: [5](#0-4) 
5. Since `5 >= 10` is FALSE, the detail is never added to `availableDetails` and cannot be claimed
6. After the due period expires (`ProfitReceivingDuePeriodCount` periods, default 10): [6](#0-5) 
7. Any subsequent `AddBeneficiary` call triggers the cleanup, which removes the detail from `ProfitDetailsMap` because `LastProfitPeriod (10) >= EndPeriod (5)` is TRUE and the time condition is met
8. The detail's shares (100) remain in `TotalShares`, causing permanent inflation

**Additional Issue: Missing IsWeightRemoved Check**

The `AddBeneficiary` cleanup also fails to check the `IsWeightRemoved` flag, which is used in `ClaimProfits` to prevent processing already-removed details: [7](#0-6) 

## Impact Explanation

**Direct Fund Impact - Permanent Profit Dilution:**

When `TotalShares` is inflated while the actual sum of shares in `ProfitDetailsMap` is correct, all future profit distributions are calculated incorrectly. The profit calculation uses the stored `TotalShares` as the denominator: [8](#0-7) [9](#0-8) 

This `TotalShares` value comes from the scheme during distribution: [10](#0-9) 

And is recorded in the distributed profits information: [11](#0-10) 

**Concrete Example:**
- Alice had 100 shares that were removed from `ProfitDetailsMap` but not from `TotalShares`
- Bob is the only real beneficiary with 50 shares
- `TotalShares` incorrectly remains at 150 (100 + 50)
- When 150 tokens are distributed:
  - **Intended**: Bob should receive 100% = 150 tokens
  - **Actual**: Bob receives `(150 * 50) / 150 = 50` tokens
  - **Lost**: 100 tokens (66.7%) remain permanently locked in the period's virtual address

**Affected Parties:**
All current and future beneficiaries of any affected profit scheme suffer permanent profit dilution proportional to the inflation ratio. The unclaimed profits cannot be recovered as they are locked in past period virtual addresses.

## Likelihood Explanation

**Medium Likelihood - Normal Operations Path:**

1. **Authorized Entry Point**: `FixProfitDetail` is callable by scheme manager or TokenHolder contract (trusted roles for normal operations): [12](#0-11) 

2. **Production Usage**: The method is actively used in the Election contract for voter welfare profit adjustments: [13](#0-12) 

3. **Realistic Triggering Scenarios:**
   - Vote lock period adjustments that result in shorter effective periods
   - Administrative corrections to profit periods
   - Edge cases in election mechanics where calculated `EndPeriod` becomes less than current `LastProfitPeriod`

4. **Automatic Cleanup**: The vulnerability doesn't require attacker action beyond the initial `FixProfitDetail` call - the cleanup happens automatically when any user calls `AddBeneficiary` after the due period expires

5. **No Input Validation**: There are no checks preventing `EndPeriod` from being set to invalid values relative to `LastProfitPeriod`: [14](#0-13) 

6. **Detection Difficulty**: The divergence is not immediately visible and only manifests as unexpectedly reduced profit distributions over multiple periods

## Recommendation

Add validation in `FixProfitDetail` to prevent setting `EndPeriod` less than `LastProfitPeriod`:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    // ... existing code ...
    
    var newDetail = fixingDetail.Clone();
    newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
    newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
    
    // Add validation
    Assert(newDetail.EndPeriod >= fixingDetail.LastProfitPeriod,
        $"Cannot set EndPeriod ({newDetail.EndPeriod}) less than LastProfitPeriod ({fixingDetail.LastProfitPeriod})");
    
    profitDetails.Details.Remove(fixingDetail);
    profitDetails.Details.Add(newDetail);
    State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
    return new Empty();
}
```

Additionally, fix the `AddBeneficiary` cleanup to either:
1. Decrement `TotalShares` when removing expired details
2. Add `!d.IsWeightRemoved` check to avoid removing already-processed details

## Proof of Concept

```csharp
[Fact]
public async Task TotalShares_InflationViaFixProfitDetail_Test()
{
    // 1. Create scheme and add beneficiary with shares
    var schemeId = await CreateScheme();
    await AddBeneficiary(schemeId, UserAddress, 100, endPeriod: 20);
    
    // Simulate some profit claiming to set LastProfitPeriod = 10
    await DistributeProfits(schemeId, period: 1);
    // ... (claim for periods 1-10)
    
    var scheme = await GetScheme(schemeId);
    Assert.Equal(100, scheme.TotalShares); // Initial state correct
    
    // 2. Call FixProfitDetail to set EndPeriod < LastProfitPeriod
    await FixProfitDetail(schemeId, UserAddress, shares: 100, endPeriod: 5);
    
    // 3. Advance time past due period and trigger AddBeneficiary cleanup
    await DistributeProfits(schemeId, period: 16); // CurrentPeriod = 17
    await AddBeneficiary(schemeId, OtherUserAddress, 50, endPeriod: long.MaxValue);
    
    // 4. Verify TotalShares is inflated (should be 50, but remains 150)
    scheme = await GetScheme(schemeId);
    Assert.Equal(150, scheme.TotalShares); // BUG: Should be 50!
    
    // 5. Verify profit dilution
    await DistributeProfits(schemeId, period: 17, amount: 150);
    await ClaimProfits(schemeId, OtherUserAddress);
    var balance = await GetBalance(OtherUserAddress);
    Assert.Equal(50, balance); // BUG: Should have received 150!
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-273)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L296-305)
```csharp
        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L462-462)
```csharp
        var totalShares = scheme.TotalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L567-567)
```csharp
        distributedProfitsInformation.TotalShares = totalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-798)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L6-6)
```csharp
    public const int DefaultProfitReceivingDuePeriodCount = 10;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L144-154)
```csharp
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```
