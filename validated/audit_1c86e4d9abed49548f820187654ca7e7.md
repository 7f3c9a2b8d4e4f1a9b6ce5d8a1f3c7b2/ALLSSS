# Audit Report

## Title
Missing Signature Verification Allows Miner Order Manipulation in Next Round

## Summary
The AEDPoS consensus mechanism fails to verify that the signature value provided by miners is correctly computed, allowing malicious miners to manipulate their mining order in the next round. The signature is used to deterministically calculate mining positions, but validation only checks for non-null values without recomputing and verifying correctness.

## Finding Description

The vulnerability exists in the consensus data application and validation flow. When a miner produces a block, their signature value should be deterministically calculated as `previousRound.CalculateSignature(PreviousInValue)` [1](#0-0) [2](#0-1) 

However, the `ApplyNormalConsensusData` function directly accepts and uses the signature parameter without verification, immediately converting it to calculate the mining order [3](#0-2) 

The validation flow through `UpdateValueValidationProvider` only performs a non-null check on the signature field [4](#0-3)  and validates that `PreviousInValue` hashes correctly to the previous round's `OutValue` [5](#0-4) , but never recomputes the signature to verify `CalculateSignature(PreviousInValue) == providedSignature`.

When the `UpdateValue` transaction executes, it directly assigns the unverified signature from the input [6](#0-5) 

**Attack Vector:**
Since `GetConsensusExtraData` and `GenerateConsensusTransactions` are view methods [7](#0-6) , a malicious miner can:
1. Call these methods locally to obtain correctly calculated consensus data
2. Modify the signature value before block creation to achieve a desired mining order
3. Submit the block with the manipulated signature
4. Pass validation since only non-null checks are performed

The manipulated signature becomes part of the round state and directly determines the miner's position in the next round through `FinalOrderOfNextRound`, which is used to schedule mining times [8](#0-7) 

## Impact Explanation

**Critical Consensus Integrity Violation:**
This vulnerability breaks a fundamental invariant of the AEDPoS consensus mechanism - that mining order is determined by cryptographically secure, unpredictable randomness. By allowing miners to choose their position in the next round, the system loses its fairness guarantees.

**Economic Impact:**
- Miners mining earlier in a round collect more transaction fees
- Strategic positioning enables MEV (Maximal Extractable Value) opportunities
- Earlier miners have higher influence on the Last Irreversible Block height calculations

**Randomness Pollution:**
The manipulated signature becomes part of the round state and is used by `CalculateSignature` in subsequent rounds [2](#0-1) , affecting randomness calculations for multiple future rounds and potentially compounding the attacker's advantage.

**Undetectable Attack:**
The manipulated signature appears valid in all respects (proper format, non-null) and leaves no trace in validation failures, making the attack impossible to detect without implementing signature recomputation.

## Likelihood Explanation

**High Likelihood:**
- Any miner in the consensus set can execute this attack
- Requires only modification of node software to alter consensus extra data before block submission
- No special privileges beyond normal mining rights required
- Zero additional cost beyond normal block production
- No risk of detection or penalty

**Low Complexity:**
The attacker simply needs to:
1. Intercept the consensus extra data generation
2. Calculate which signature values yield favorable orders via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. Replace the correct signature with the chosen value
4. Submit the block normally

**Economic Rationality:**
With zero cost and risk, rational miners are incentivized to exploit this for competitive advantage in fee collection and strategic block positioning.

## Recommendation

Add signature verification to the validation flow by recomputing the expected signature and comparing it to the provided value:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;
    
    var providedSignature = extraData.Round.RealTimeMinersInformation[publicKey].Signature;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    if (providedSignature == null || previousInValue == null) 
        return true;
    
    // Recompute and verify signature
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return expectedSignature == providedSignature;
}
```

Add this check to the `ValidateHeaderInformation` method before returning success.

## Proof of Concept

The vulnerability can be demonstrated through the following flow:

1. A miner's node calls `GetConsensusExtraData` which calculates: `signature = previousRound.CalculateSignature(previousInValue)` [1](#0-0) 

2. Before block creation, the miner modifies the signature to a chosen value that yields a favorable order

3. The block's consensus data passes validation because `UpdateValueValidationProvider` only checks non-null [9](#0-8) 

4. The manipulated signature is stored and used to calculate `FinalOrderOfNextRound` [10](#0-9) 

5. Next round generation uses this manipulated order to schedule the miner's position [8](#0-7) 

A test would create a modified miner node that intercepts consensus extra data generation, replaces the signature with a chosen value (e.g., one that yields order 1), submits the block, and verifies that: (1) the block is accepted, (2) the manipulated signature is stored in state, and (3) the next round schedules the miner at the chosen position.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-44)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-32)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** protobuf/acs4.proto (L25-34)
```text
    rpc GetConsensusExtraData (google.protobuf.BytesValue) returns (google.protobuf.BytesValue) {
        option (aelf.is_view) = true;
    }
    
    // Generate consensus system transactions when a block is generated. 
    // Each block will contain only one consensus transaction, which is used to write the latest consensus information 
    // to the State database.
    rpc GenerateConsensusTransactions (google.protobuf.BytesValue) returns (TransactionList) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```
