# Audit Report

## Title
Missing Authorization Check in MigrateConnectorTokens Allows Unauthorized Connector State Migration

## Summary
The `MigrateConnectorTokens()` function lacks the required authorization check that all other connector management operations enforce, allowing any user to trigger a one-time connector token naming migration. This breaks the established authorization pattern where connector controller approval is required for all connector management operations.

## Finding Description

The `MigrateConnectorTokens()` function is missing the authorization check that restricts access to the connector controller. [1](#0-0) 

All other connector management functions enforce authorization by calling `AssertPerformedByConnectorController()`:
- UpdateConnector [2](#0-1) 
- AddPairConnector [3](#0-2) 
- SetFeeRate [4](#0-3) 
- ChangeConnectorController [5](#0-4) 

The authorization helper validates that the sender is the connector controller's owner address. [6](#0-5) 

The function is exposed as a public RPC method. [7](#0-6) 

Test cases demonstrate the function can be called without authorization, with only a duplicate migration check. [8](#0-7) [9](#0-8) 

In contrast, other connector management functions have authorization tests verifying unauthorized calls are rejected. [10](#0-9) [11](#0-10) 

## Impact Explanation

This vulnerability allows unauthorized modification of connector state, breaking the fundamental security invariant that only the connector controller (defaulting to Parliament governance) should manage connector configurations.

The migration operation modifies critical connector state including `RelatedSymbol` fields and deposit balance mappings. [12](#0-11) 

While test evidence shows that Buy and Sell operations continue functioning correctly after migration [13](#0-12) [14](#0-13) , the unauthorized access represents an operational security risk where:

1. **Premature Migration**: An attacker could trigger migration before governance intends, disrupting planned operational timelines
2. **Governance Bypass**: Violates the authorization pattern that requires Parliament approval for connector management
3. **Operational Disruption**: Unexpected state changes could interfere with monitoring, tooling, or planned maintenance windows

The impact is primarily **unauthorized configuration change** rather than direct fund loss, as the migration itself is functionally correct when executed.

## Likelihood Explanation

The likelihood is **CERTAIN** because:
- Any account can call the public RPC method with no authorization required
- No special preconditions, state requirements, or economic costs beyond transaction fees
- The vulnerability is directly exploitable via a single transaction
- No compensating controls exist in the contract design

The only protection is a duplicate migration check preventing the operation from being called twice with the new prefix pattern. [15](#0-14) 

## Recommendation

Add the authorization check at the beginning of the `MigrateConnectorTokens` function to align with the established security pattern used by all other connector management operations:

```csharp
public override Empty MigrateConnectorTokens(Empty input)
{
    AssertPerformedByConnectorController();  // Add this line
    
    foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
                 .Union(Context.Variables.GetStringArray(PayRentalSymbolListName)))
    {
        // ... rest of the implementation
    }
    
    return new Empty();
}
```

This ensures that only the connector controller (Parliament governance by default) can trigger the migration, maintaining consistency with the authorization model for all connector management operations.

## Proof of Concept

The existing test suite demonstrates that `MigrateConnectorTokens` can be called by any account without authorization: [8](#0-7) 

Unlike other connector management operations which have tests verifying authorization enforcement, no such test exists for `MigrateConnectorTokens`, and the function executes successfully when called by `DefaultStub` (a regular unprivileged account).

## Notes

- This vulnerability represents a **governance control issue** rather than direct fund theft
- The migration operation itself is safe and deterministic, as confirmed by test cases showing continued functionality
- The primary risk is **unauthorized timing control** of a state-changing governance operation
- All other connector management functions consistently enforce authorization, making this omission a clear security pattern violation
- The connector controller defaults to Parliament's default organization address, requiring proposal approval for legitimate connector management operations

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-81)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-262)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-305)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L311-342)
```csharp
    public override Empty MigrateConnectorTokens(Empty input)
    {
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(PayRentalSymbolListName)))
        {
            var newConnectorTokenSymbol = NewNtTokenPrefix.Append(resourceTokenSymbol);

            if (State.Connectors[resourceTokenSymbol] == null)
            {
                continue;
            }

            var oldConnectorTokenSymbol = State.Connectors[resourceTokenSymbol].RelatedSymbol;

            Assert(!oldConnectorTokenSymbol.StartsWith(NewNtTokenPrefix), "Already migrated.");

            // Migrate

            State.Connectors[resourceTokenSymbol].RelatedSymbol = newConnectorTokenSymbol;

            if (State.Connectors[oldConnectorTokenSymbol] != null)
            {
                var connector = State.Connectors[oldConnectorTokenSymbol];
                connector.Symbol = newConnectorTokenSymbol;
                State.Connectors[newConnectorTokenSymbol] = connector;
            }

            State.DepositBalance[newConnectorTokenSymbol] = State.DepositBalance[oldConnectorTokenSymbol];
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** protobuf/token_converter_contract.proto (L55-56)
```text
    rpc MigrateConnectorTokens (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L14-71)
```csharp
    public async Task CanBuyResourceTokenAfterMigration()
    {
        await CreateWriteToken();
        await InitializeTreasuryContractAsync();
        await InitializeTokenConverterContract();
        await PrepareToBuyAndSell();

        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());

        //check the price and fee
        var fromConnectorBalance = ELFConnector.VirtualBalance;
        var fromConnectorWeight = decimal.Parse(ELFConnector.Weight);
        var toConnectorBalance = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
        var toConnectorWeight = decimal.Parse(WriteConnector.Weight);

        var amountToPay = BancorHelper.GetAmountToPayFromReturn(fromConnectorBalance, fromConnectorWeight,
            toConnectorBalance, toConnectorWeight, 1000L);
        var depositAmountBeforeBuy = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        var fee = Convert.ToInt64(amountToPay * 5 / 1000);

        var buyResult = (await DefaultStub.Buy.SendAsync(
            new BuyInput
            {
                Symbol = WriteConnector.Symbol,
                Amount = 1000L,
                PayLimit = amountToPay + fee + 10L
            })).TransactionResult;
        buyResult.Status.ShouldBe(TransactionResultStatus.Mined);

        //Verify the outcome of the transaction
        var depositAmountAfterBuy = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        depositAmountAfterBuy.Value.Sub(depositAmountBeforeBuy.Value).ShouldBe(amountToPay);
        var balanceOfTesterWrite = await GetBalanceAsync(WriteSymbol, DefaultSender);
        balanceOfTesterWrite.ShouldBe(1000L);

        var elfBalanceLoggedInTokenConvert = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        elfBalanceLoggedInTokenConvert.Value.ShouldBe(ELFConnector.VirtualBalance + amountToPay);
        var balanceOfElfToken = await GetBalanceAsync(NativeSymbol, TokenConverterContractAddress);
        balanceOfElfToken.ShouldBe(amountToPay);

        var donatedFee = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
        donatedFee.Value[NativeSymbol].ShouldBe(fee.Div(2));

        var balanceOfRamToken = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
        balanceOfRamToken.ShouldBe(100_0000L - 1000L);

        var balanceOfTesterToken = await GetBalanceAsync(NativeSymbol, DefaultSender);
        balanceOfTesterToken.ShouldBe(100_0000L - amountToPay - fee);
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L73-140)
```csharp
    [Fact]
    public async Task CanSellResourceTokenAfterMigration()
    {
        await CreateWriteToken();
        await InitializeTreasuryContractAsync();
        await InitializeTokenConverterContract();
        await PrepareToBuyAndSell();

        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());

        var buyResult = (await DefaultStub.Buy.SendAsync(
            new BuyInput
            {
                Symbol = WriteConnector.Symbol,
                Amount = 1000L,
                PayLimit = 1010L
            })).TransactionResult;
        buyResult.Status.ShouldBe(TransactionResultStatus.Mined);

        //Balance  before Sell
        var treasuryBeforeSell =
            (await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty())).Value[NativeSymbol];
        var balanceOfElfToken = await GetBalanceAsync(NativeSymbol, TokenConverterContractAddress);
        var balanceOfTesterToken = await GetBalanceAsync(NativeSymbol, DefaultSender);

        //check the price and fee
        var toConnectorBalance = ELFConnector.VirtualBalance + balanceOfElfToken;
        var toConnectorWeight = decimal.Parse(ELFConnector.Weight);
        var fromConnectorBalance = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
        var fromConnectorWeight = decimal.Parse(WriteConnector.Weight);

        var amountToReceive = BancorHelper.GetReturnFromPaid(fromConnectorBalance, fromConnectorWeight,
            toConnectorBalance, toConnectorWeight, 1000L);
        var depositAmountBeforeSell = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        var fee = Convert.ToInt64(amountToReceive * 5 / 1000);

        var sellResult = (await DefaultStub.Sell.SendAsync(new SellInput
        {
            Symbol = WriteConnector.Symbol,
            Amount = 1000L,
            ReceiveLimit = amountToReceive - fee - 10L
        })).TransactionResult;
        sellResult.Status.ShouldBe(TransactionResultStatus.Mined);

        //Verify the outcome of the transaction
        var depositAmountAfterSell = await DefaultStub.GetDepositConnectorBalance.CallAsync(new StringValue
        {
            Value = WriteConnector.Symbol
        });
        depositAmountBeforeSell.Value.Sub(depositAmountAfterSell.Value).ShouldBe(amountToReceive);
        var balanceOfTesterRam = await GetBalanceAsync(WriteSymbol, DefaultSender);
        balanceOfTesterRam.ShouldBe(0L);

        var treasuryAfterSell = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
        treasuryAfterSell.Value[NativeSymbol].ShouldBe(fee.Div(2) + treasuryBeforeSell);

        var balanceOfElfTokenAfterSell = await GetBalanceAsync(NativeSymbol, TokenConverterContractAddress);
        balanceOfElfTokenAfterSell.ShouldBe(balanceOfElfToken - amountToReceive);

        var balanceOfRamToken = await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress);
        balanceOfRamToken.ShouldBe(100_0000L);

        var balanceOfTesterTokenAfterSell = await GetBalanceAsync(NativeSymbol, DefaultSender);
        balanceOfTesterTokenAfterSell.ShouldBe(balanceOfTesterToken + amountToReceive - fee);
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L142-153)
```csharp
    [Fact]
    public async Task MigrateTwiceTest()
    {
        await CreateWriteToken();
        await InitializeTreasuryContractAsync();
        await InitializeTokenConverterContract();
        await PrepareToBuyAndSell();

        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());
        var result = await DefaultStub.MigrateConnectorTokens.SendWithExceptionAsync(new Empty());
        result.TransactionResult.Error.ShouldContain("Already migrated.");
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L116-125)
```csharp
    public async Task AddPairConnector_Without_Authority_Test()
    {
        var tokenSymbol = "NETT";
        var pairConnector = GetLegalPairConnectorParam(tokenSymbol);
        var addConnectorWithoutAuthorityRet =
            await DefaultStub.AddPairConnector.SendWithExceptionAsync(
                pairConnector);
        addConnectorWithoutAuthorityRet.TransactionResult.Error.ShouldContain(
            "Only manager can perform this action.");
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L146-159)
```csharp
    public async Task UpdateConnector_Without_Authority_Test()
    {
        var tokenSymbol = "CWJ";
        await AddPairConnectorAsync(tokenSymbol);
        var updateConnector = new Connector
        {
            Symbol = tokenSymbol,
            Weight = "0.3"
        };
        var updateRet =
            await DefaultStub.UpdateConnector.SendWithExceptionAsync(
                updateConnector);
        updateRet.TransactionResult.Error.ShouldContain("Only manager can perform this action.");
    }
```
