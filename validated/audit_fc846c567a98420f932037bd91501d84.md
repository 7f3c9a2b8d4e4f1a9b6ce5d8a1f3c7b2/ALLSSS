# Audit Report

## Title
Hex Case Mismatch in Pubkey Replacement Causes Miner Denial of Service

## Summary
The `RecordCandidateReplacement` method in the consensus contract stores replacement pubkeys as raw string dictionary keys without normalizing hex case. When the affected miner later requests consensus commands, their pubkey is converted to lowercase hex via `ToHex()`, causing a dictionary lookup failure due to case-sensitive string comparison. This prevents the miner from producing blocks.

## Finding Description

The vulnerability exists in the pubkey replacement flow across the Election and Consensus contracts:

**Root Cause:** The `RecordCandidateReplacement` method directly uses the raw `input.NewPubkey` string as a dictionary key in `RealTimeMinersInformation` without normalizing the hex case. [1](#0-0) 

The protobuf definition shows pubkeys are plain strings: [2](#0-1)  and [3](#0-2) 

**Entry Point:** Candidate admins call `ReplaceCandidatePubkey` which passes the raw user-provided strings to the consensus contract: [4](#0-3) 

**Failure Point:** When miners request consensus commands, the system converts their pubkey bytes to lowercase hex using `ToHex()`, then performs a case-sensitive dictionary lookup via `IsInMinerList()`: [5](#0-4)  and [6](#0-5) 

**Hex Conversion:** The `ToHex()` method always produces lowercase hex characters ('a'-'f') due to adding `0x20` to the base value: [7](#0-6) 

**Dictionary Lookup:** The `IsInMinerList` method performs case-sensitive string comparison: [8](#0-7) 

**Initial Miner Creation:** All initial pubkeys are normalized to lowercase via `ToHex()`, establishing the expected format: [9](#0-8)  and [10](#0-9) 

## Impact Explanation

**Direct Harm:**
- The affected miner cannot retrieve valid consensus commands, completely preventing block production
- Network consensus capacity is permanently reduced by one miner until remediation
- The miner loses all block rewards during the outage period
- If multiple miners are affected, network liveness and block production rate are significantly degraded

**Affected Parties:**
- The miner whose pubkey was replaced with non-lowercase hex cannot participate in consensus
- The blockchain network suffers from reduced consensus participation and potential performance degradation
- Token holders may experience slower transaction confirmations

**Severity Justification (Medium):**
- No direct fund theft or permanent token loss
- Operational disruption to critical consensus mechanism
- Can be remediated by replacing the pubkey again with correct lowercase format
- Requires candidate admin privileges to trigger, limiting attack surface
- Impact severity scales with the number of affected miners

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a candidate admin authorized to call `ReplaceCandidatePubkey` in the Election Contract
- Must provide new pubkey in non-lowercase format (uppercase or mixed case hex string)
- No special technical knowledge beyond basic hex string formatting

**Attack Complexity:**
- Very low complexity: Single transaction with uppercase hex string parameter
- No timing requirements, race conditions, or complex state dependencies
- Deterministic and reproducible outcome

**Feasibility Conditions:**
- All test cases use `.ToHex()` which produces lowercase, so this edge case is not tested: [11](#0-10) 
- The contract validation only checks hex string convertibility (case-insensitive), not case normalization: [12](#0-11) 
- Manual API calls, CLI tools, or UI inputs could easily provide uppercase hex strings
- Nothing in the contract enforces lowercase format

**Probability Assessment:**
- Moderate probability: More likely to occur as accidental admin error than malicious attack
- Would be immediately detected when the affected miner fails to produce blocks
- Natural testing patterns (using `.ToHex()`) mask this vulnerability

## Recommendation

Add case normalization in the `RecordCandidateReplacement` method before storing the new pubkey:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    // Normalize pubkey case to lowercase
    var normalizedNewPubkey = input.NewPubkey.ToLower();
    
    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = normalizedNewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(normalizedNewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = normalizedNewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = normalizedNewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Alternatively, add validation in `ReplaceCandidatePubkey` to reject non-lowercase hex strings, or normalize the input before forwarding to the consensus contract.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseHex_CausesConsensusDos()
{
    // Setup: Announce election and become a miner
    var minerKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    await AnnounceElectionAsync(minerKeyPair, Address.FromPublicKey(candidateAdmin.PublicKey));
    
    // Become a miner in the current round
    await InitializeTermAndBecomeMiners();
    
    // Verify miner can get consensus command before replacement
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(minerKeyPair.PublicKey) });
    consensusCommand.ShouldNotBe(ConsensusCommandProvider.InvalidConsensusCommand);
    
    // Replace pubkey with UPPERCASE hex
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var uppercaseNewPubkey = newKeyPair.PublicKey.ToHex().ToUpper();
    
    var candidateAdminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair.PublicKey.ToHex(),
        NewPubkey = uppercaseNewPubkey  // UPPERCASE
    });
    
    // Verify the new miner CANNOT get consensus command (DoS)
    var failedCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(newKeyPair.PublicKey) });
    failedCommand.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
    
    // Verify the pubkey exists in state but with wrong case
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation.Keys.ShouldContain(uppercaseNewPubkey);
    currentRound.RealTimeMinersInformation.Keys.ShouldNotContain(newKeyPair.PublicKey.ToHex());
}
```

## Notes

This vulnerability demonstrates a classic case-sensitivity issue where the storage path uses raw user input while the lookup path uses normalized lowercase hex. The issue is exacerbated by the fact that all standard testing uses `.ToHex()` which always produces lowercase, masking the edge case. The fix requires either input validation to enforce lowercase or normalization at storage time to match the lookup behavior.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L143-143)
```csharp
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** protobuf/aedpos_contract.proto (L452-455)
```text
message RecordCandidateReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-181)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L19-19)
```csharp
        _processingBlockMinerPubkey = input.Value.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L17-17)
```csharp
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L37-37)
```csharp
            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L40-41)
```csharp
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
```
