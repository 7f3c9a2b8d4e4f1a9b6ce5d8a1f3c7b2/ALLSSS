# Audit Report

## Title
Flawed Mining Order Validation Allows Duplicate FinalOrderOfNextRound Values in NextRound Consensus

## Summary
The `NextRoundMiningOrderValidationProvider` validation logic incorrectly calls `.Distinct()` on `MinerInRound` objects instead of on `FinalOrderOfNextRound` integer values, allowing multiple miners to have identical mining order assignments. This passes validation but corrupts the mining schedule, causing consensus disruption and chain liveness risks.

## Finding Description

The vulnerability exists in the NextRound validation logic where uniqueness of mining orders is checked. [1](#0-0) 

The code calls `.Distinct()` on an `IEnumerable<MinerInRound>` collection (the result of `.Values.Where(...)`), not on the `FinalOrderOfNextRound` integer values. Since `MinerInRound` is a protobuf-generated class [2](#0-1)  that compares all fields for equality (including the unique `Pubkey` field at line 284), two miners with identical `FinalOrderOfNextRound` but different pubkeys are counted as distinct objects.

The validation should verify that all `FinalOrderOfNextRound` **values** are unique, but instead only verifies that all `MinerInRound` **objects** are distinct—which they always are since each miner has a unique pubkey.

**Attack Execution Path:**

1. When the NextRound validation provider is added to the validation pipeline [3](#0-2) , it validates the `ProvidedRound` data from the block header's consensus extra data [4](#0-3) 

2. A malicious miner assigned to produce the NextRound block can craft consensus header information with duplicate `FinalOrderOfNextRound` values (e.g., Miner A and Miner B both assigned order 1)

3. The flawed validation passes because it counts distinct `MinerInRound` objects (all different due to unique pubkeys), not distinct order values

4. The corrupted round data gets stored in state [5](#0-4)  through `AddRoundInformation` [6](#0-5) 

5. When the next round is generated, `GenerateNextRoundInformation` [7](#0-6)  uses the corrupted data

6. The generation logic processes miners ordered by `FinalOrderOfNextRound` [8](#0-7) , assigning each their `FinalOrderOfNextRound` as their `Order` in the next round

7. Multiple miners receive the same `Order` value, and the `occupiedOrders` list [9](#0-8)  contains duplicates while missing some valid order positions, corrupting the mining schedule

The only other NextRound validation (`RoundTerminateValidationProvider`) [10](#0-9)  only checks round number increments and null InValues—it does not validate FinalOrderOfNextRound uniqueness.

## Impact Explanation

**Consensus Integrity Violation**: Multiple miners assigned to the same mining order slot means two or more miners expect to produce blocks at identical expected mining times, causing time slot collisions and block production conflicts. Some miners receive no valid time slots when their intended orders are incorrectly marked as occupied by duplicates.

**Chain Liveness Risk**: If critical miners (such as the extra block producer) are assigned duplicate orders or missing orders, the chain may fail to progress during affected rounds. The consensus mechanism's fundamental assumption of unique, sequential mining orders (1 through minersCount) is violated.

**Operational Disruption**: Validator nodes following the corrupted mining schedule will have inconsistent views of which miner should produce blocks at which times, potentially causing network disagreements or block proposal conflicts that persist across subsequent rounds.

**Widespread Attack Surface**: Any miner producing a NextRound block can inject this vulnerability. With typical miner rotation in AEDPoS, opportunities arise multiple times per term, and the attack requires zero additional resources beyond normal mining operations.

## Likelihood Explanation

**Reachable Entry Point**: The flawed validation is directly triggered during `ValidateBeforeExecution` for any block with `AElfConsensusBehaviour.NextRound` behavior, which occurs regularly during normal consensus operation.

**Attacker Capabilities**: Any consensus miner can construct a malicious block header when they are assigned to produce the NextRound (extra) block. The miner controls the `AElfConsensusHeaderInformation` structure containing the `Round` data with `FinalOrderOfNextRound` values—this is generated client-side by the node software before block submission.

**Execution Practicality**: The attacker runs modified node software to craft a block header where `ProvidedRound.RealTimeMinersInformation` contains duplicate `FinalOrderOfNextRound` values. The flawed validation logic counts distinct `MinerInRound` objects (which differ by pubkey), so the count equality check passes despite duplicate order values. The NextRound transaction then executes and stores the corrupted round data.

**Detection Difficulty**: The validation appears to succeed normally—the count equality check passes. Only manual inspection of actual `FinalOrderOfNextRound` values (not performed by any validator) would reveal the duplicates. Post-execution effects (mining schedule disruption) may be misattributed to network issues or other consensus problems.

**Economic Rationality**: Attack cost is zero beyond normal mining operations. Motivations include: griefing competing miners, disrupting consensus to delay unfavorable governance actions, creating strategic advantages during vote periods, or simply causing operational chaos for competitors.

## Recommendation

Fix the validation logic to check uniqueness of `FinalOrderOfNextRound` **values** rather than uniqueness of `MinerInRound` **objects**:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    // Select the FinalOrderOfNextRound values first, then count distinct values
    var distinctCount = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.FinalOrderOfNextRound)  // Extract the order values
        .Distinct()
        .Count();
        
    if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

Additionally, consider adding an explicit check that all `FinalOrderOfNextRound` values form a contiguous sequence from 1 to minersCount to ensure no gaps or out-of-range values exist.

## Proof of Concept

```csharp
[Fact]
public void NextRoundValidation_ShouldReject_DuplicateFinalOrderOfNextRound()
{
    // Create a round with duplicate FinalOrderOfNextRound values
    var maliciousRound = new Round
    {
        RoundNumber = 2,
        RealTimeMinersInformation =
        {
            ["miner1"] = new MinerInRound 
            { 
                Pubkey = "miner1",
                OutValue = Hash.FromString("value1"),
                FinalOrderOfNextRound = 1  // Duplicate order
            },
            ["miner2"] = new MinerInRound 
            { 
                Pubkey = "miner2",
                OutValue = Hash.FromString("value2"),
                FinalOrderOfNextRound = 1  // Duplicate order
            },
            ["miner3"] = new MinerInRound 
            { 
                Pubkey = "miner3",
                OutValue = Hash.FromString("value3"),
                FinalOrderOfNextRound = 3
            }
        }
    };

    var validationContext = new ConsensusValidationContext
    {
        BaseRound = new Round { RoundNumber = 1 },
        ExtraData = new AElfConsensusHeaderInformation
        {
            Round = maliciousRound,
            Behaviour = AElfConsensusBehaviour.NextRound
        }
    };

    var validator = new NextRoundMiningOrderValidationProvider();
    var result = validator.ValidateHeaderInformation(validationContext);

    // Current implementation: incorrectly returns Success = true
    // Expected: Should return Success = false with error message
    Assert.False(result.Success, "Validation should reject duplicate FinalOrderOfNextRound values");
    Assert.Contains("Invalid FinalOrderOfNextRound", result.Message);
}
```

## Notes

This vulnerability represents a critical consensus integrity issue where the validation incorrectly checks object distinctness rather than value uniqueness. The protobuf-generated `MinerInRound` class's equality comparison includes all fields (including the unique `Pubkey`), making every miner object distinct regardless of their `FinalOrderOfNextRound` values. This allows malicious miners to corrupt the mining schedule with zero detection, potentially causing chain liveness failures when multiple miners are assigned to the same time slot or critical miners receive no valid slots.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-300)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```
