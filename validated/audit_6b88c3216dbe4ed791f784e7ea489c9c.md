# Audit Report

## Title
Scheme Manager Can DOS Profit Claiming Through Unlimited Empty Period Creation

## Summary
A malicious scheme manager can repeatedly call `DistributeProfits` with an empty `AmountsMap`, causing period counters to increment indefinitely without distributing any actual profits. This forces beneficiaries to iterate through potentially millions of empty periods when claiming their legitimate profits, making the claiming process economically infeasible due to excessive gas costs and transaction requirements, effectively creating a permanent denial-of-service condition.

## Finding Description

The vulnerability exists in the TokenHolder contract's `DistributeProfits` function, which unconditionally increments the period counter regardless of whether any profits were actually distributed. [1](#0-0) 

The critical flaw is that `scheme.Period` is incremented unconditionally after calling the Profit contract. The only check is the conditional addition of `AmountsMap`, which simply doesn't add anything if the input is null or empty - but the period still increments regardless. [2](#0-1) 

The authorization check confirms that the scheme manager is explicitly authorized to call this function, making this an abuse of legitimate authority rather than a privilege escalation. [3](#0-2)  The scheme manager role is assigned during scheme creation where the creator becomes the manager. [4](#0-3) 

In the underlying Profit contract, the `DistributeProfits` function has a similar issue. The only protection is a check that burns profits if the period is negative OR totalShares is zero or less. [5](#0-4)  However, in the normal case where a scheme has beneficiaries (totalShares > 0), this check passes and the CurrentPeriod is unconditionally incremented, even when no actual profits were distributed. [6](#0-5) 

When the input AmountsMap is empty, the code still creates a DistributedProfitsInfo entry with IsReleased set to true but with no actual token amounts. [7](#0-6)  The period increments regardless because the UpdateDistributedProfits and PerformDistributeProfits functions can execute with empty profit maps. [8](#0-7) 

When beneficiaries attempt to claim profits, they must iterate through all periods from their `LastProfitPeriod` to the scheme's `CurrentPeriod - 1`. [9](#0-8)  While empty periods are skipped with a continue statement, they still consume gas during iteration because the loop executes, performs state reads, and evaluates conditions for each period.

The maximum number of periods that can be processed per claim transaction is limited by constants. [10](#0-9)  With a maximum of 10 profitable details and 100 total periods, approximately 10-100 periods can be processed per claim transaction depending on the configuration. If a malicious manager creates 1,000,000 empty periods, beneficiaries would need to make approximately 10,000 separate `ClaimProfits` transactions to traverse all empty periods and reach their actual profits.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables a complete economic denial-of-service attack on the profit claiming mechanism:

1. **All scheme beneficiaries are affected**: Every participant who has registered for profits in the scheme becomes a victim
2. **Profits become economically unclaimed**: The gas cost of making 10,000+ transactions would far exceed the value of small profit amounts, making them permanently inaccessible
3. **No recovery mechanism**: There is no way to skip empty periods or reset the period counter - the damage is permanent once periods are created
4. **Minimal attack cost**: The attacker only pays normal transaction fees for calling `DistributeProfits`, while victims must pay orders of magnitude more to claim
5. **Protocol reputation damage**: Users losing access to legitimate profits severely damages trust in the entire economic system

## Likelihood Explanation

**Likelihood: HIGH**

The attack has extremely high feasibility:

1. **Attacker capability**: The scheme manager role is obtained legitimately during scheme creation. Anyone can create a scheme and become its manager. This is not a privilege escalation vulnerability - it's abuse of intended functionality.

2. **Attack complexity**: Trivially low - the attacker simply calls `DistributeProfits` repeatedly with an empty `AmountsMap`. No complex conditions or timing requirements exist.

3. **Preconditions**: The only requirement is that the scheme has at least one beneficiary (totalShares > 0), which is the normal operational state for any active profit scheme.

4. **Detection**: While the attack is visible on-chain (period increments without corresponding profit distribution events), detection doesn't prevent the damage - once empty periods are created, they cannot be removed.

5. **No protections**: There are no rate limits, cooldown periods, or validation checks to prevent empty period creation.

## Recommendation

Add validation in both TokenHolder and Profit contracts to prevent empty profit distributions:

**In TokenHolderContract.DistributeProfits**:
```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // NEW: Require non-empty AmountsMap or actual balance to distribute
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), 
           "Cannot distribute without specifying amounts.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);
    
    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

**In ProfitContract.DistributeProfits**:
```csharp
// After building profitsMap, validate it's not empty
Assert(profitsMap.Any() && profitsMap.Values.Any(v => v > 0),
       "Cannot distribute period with zero profits.");
```

Alternatively, implement a mechanism to allow beneficiaries to skip over ranges of empty periods in a single transaction, or add a function to collapse empty periods.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousManager_CanDOS_ProfitClaiming()
{
    // Setup: Create scheme and add beneficiary
    var manager = Accounts[0].Address;
    var beneficiary = Accounts[1].Address;
    
    // Create token holder scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // Beneficiary registers with 100 tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 100
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 100
    });
    
    // Attack: Manager creates 10000 empty periods
    for (int i = 0; i < 10000; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = manager,
            AmountsMap = { } // Empty map - no profits distributed
        });
    }
    
    // Now distribute one legitimate period with actual profits
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = manager,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = manager,
        AmountsMap = { { "ELF", 0 } } // Distribute available balance
    });
    
    // Victim attempts to claim - must make ~100 transactions minimum
    // Each ClaimProfits processes max ~100 periods
    int claimAttempts = 0;
    while (claimAttempts < 150) // Would need 100+ attempts to reach real profits
    {
        await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
        {
            SchemeManager = manager,
            Beneficiary = beneficiary
        });
        claimAttempts++;
    }
    
    // Assert: Beneficiary still cannot claim due to gas exhaustion
    // In real scenario, transaction costs would exceed profit value
    Assert.True(claimAttempts > 100); // Proves DOS condition
}
```

## Notes

The vulnerability is particularly severe because:

1. **Permanent damage**: Once empty periods are created, there is no administrative function to remove or collapse them
2. **Affects existing schemes**: Even schemes created before the attack can be targeted if the manager becomes malicious
3. **Economic viability**: For small profit amounts, the cumulative gas cost of 10,000+ claim transactions makes recovery economically impossible
4. **No on-chain detection**: While visible in events, there's no way to distinguish between legitimate empty periods (during setup) and malicious ones

The recommended fix should require either non-empty AmountsMap or implement period skipping/collapsing functionality to allow beneficiaries to efficiently traverse empty periods.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-22)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L432-460)
```csharp
        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-604)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }

    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-9)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
