# Audit Report

## Title
Symbol Alias Shadowing via Direct Token Registration

## Summary
The `SetSymbolAlias` function lacks validation to check whether a proposed alias already exists as a direct token symbol in `State.TokenInfos`. This creates an exploitable race condition where an attacker can register a token with a simple symbol before an NFT collection owner sets that symbol as an alias, causing users to unknowingly interact with the attacker's token instead of the intended NFT.

## Finding Description

The vulnerability stems from an asymmetric validation pattern between token existence checks and alias setting.

When setting an alias, `SetSymbolAlias` only validates that the alias doesn't exist in `SymbolAliasMap`: [1](#0-0) 

This check does not verify whether `State.TokenInfos[input.Alias]` already contains a direct token with the same symbol. However, when tokens are created, `CheckTokenExists` uses `GetTokenInfo` to validate non-existence: [2](#0-1) 

The `GetTokenInfo` helper function prioritizes direct symbol lookups over alias resolution. If a direct token exists at `State.TokenInfos[symbolOrAlias]`, it returns immediately without checking the alias mapping: [3](#0-2) 

This design allows both storage locations to simultaneously contain entries for the same string identifier.

**Attack Prerequisites:**
- Symbol validation permits alphanumeric-only symbols (no dashes required for tokens): [4](#0-3) 

- SEED NFTs enable token creation with simple symbols matching NFT collection prefixes: [5](#0-4) 

- Alias rules enforce that the alias must match the NFT collection's symbol prefix: [6](#0-5) 

**Attack Execution:**
1. Attacker obtains SEED NFT with `__seed_owned_symbol` = "ABC" (created before or around when legitimate NFT collection is established)
2. NFT collection owner creates "ABC-0" (collection) and "ABC-123" (item)
3. Attacker front-runs the alias setting by calling `Create` with symbol "ABC", consuming the SEED NFT
4. Token "ABC" is registered at `State.TokenInfos["ABC"]`
5. NFT owner calls `SetSymbolAlias({Symbol: "ABC-123", Alias: "ABC"})`
   - Line 750 validation passes (SymbolAliasMap is empty)
   - Alias mapping is set: `State.SymbolAliasMap["ABC"] = "ABC-123"`
6. Users calling `GetTokenInfo("ABC")` receive the attacker's token due to prioritized direct lookup at lines 407-408

The system now has:
- `State.TokenInfos["ABC"]` → attacker's token
- `State.SymbolAliasMap["ABC"]` → "ABC-123" (legitimate NFT)

All queries for "ABC" resolve to the attacker's token, not the intended NFT.

## Impact Explanation

**Financial Impact:**
- Users attempting to interact with NFT "ABC-123" via its alias "ABC" will unknowingly transact with the attacker's malicious token
- Transfers to the attacker's token result in permanent loss of user funds
- Approvals granted to the attacker's token enable balance drainage through `TransferFrom` operations
- DApp integrations relying on alias-based lookups will execute transactions against the wrong token

**Protocol Integrity Impact:**
- The NFT collection's alias functionality becomes permanently compromised
- NFT collection owners lose their intended user-friendly access mechanism
- Brand identity confusion and potential reputation damage
- Market confusion in NFT marketplaces using alias-based token resolution

**Affected Parties:**
- End users who transfer funds or grant approvals using the alias
- NFT collection owners who lose alias functionality for their collections
- DApp developers whose applications malfunction due to token misdirection
- Protocol reputation due to user experience failures and fund losses

This represents a Medium severity issue: while it requires the attacker to acquire and burn a SEED NFT (non-trivial economic cost), it results in concrete financial losses for users and undermines a core protocol feature designed to improve NFT usability.

## Likelihood Explanation

**Attacker Requirements:**
1. Acquire SEED NFT with `__seed_owned_symbol` matching target alias (e.g., "ABC")
2. Monitor blockchain for NFT collection creation events
3. Front-run the `SetSymbolAlias` transaction with token creation

**Feasibility Assessment:**
- SEED NFTs are tradeable ERC-721-like assets available on secondary markets
- High-value or brand-name symbols have economic incentive for speculative SEED acquisition
- Blockchain event monitoring is standard for MEV-style attacks
- Transaction front-running is technically feasible on AElf
- Attack cost (SEED price + gas) can be recovered from misdirected user funds

**Economic Viability:**
- For valuable NFT collections with significant user adoption, victims may transfer substantial amounts
- Single-transaction attack execution after SEED acquisition
- No ongoing costs beyond initial SEED investment
- Additional value from brand impersonation opportunities

**Detection Difficulty:**
- Vulnerability window exists from collection creation until alias setting
- No protocol-level validation prevents the collision state
- Users typically won't detect the issue until funds are lost
- Blockchain explorers may not clearly distinguish between direct tokens and aliased NFTs

**Likelihood Assessment:** Medium - requires active attacker investment in SEED acquisition and timing coordination, but is economically rational for high-value NFT collections and technically straightforward once preconditions are met.

## Recommendation

Add validation in `SetSymbolAlias` to check if the proposed alias already exists as a direct token symbol:

```csharp
public override Empty SetSymbolAlias(SetSymbolAliasInput input)
{
    // Existing checks...
    Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");
    
    // Add this check:
    Assert(State.TokenInfos[input.Alias] == null, 
        $"Cannot set alias: token with symbol {input.Alias} already exists.");
    
    // Rest of the function...
}
```

This ensures mutual exclusion between direct token symbols and aliases, preventing the collision state entirely.

Additionally, consider:
1. Implementing bi-directional validation: when creating tokens, check if the symbol is already used as an alias
2. Emitting clear events that distinguish between direct token creation and alias registration
3. Providing view methods for users to verify whether a symbol is a direct token or an alias

## Proof of Concept

```csharp
[Fact]
public async Task SymbolAliasShadowing_Attack()
{
    // Setup: Create SEED collection and issue SEED NFT to attacker
    var seedSymbol = "SEED-1";
    var targetSymbol = "ABC";
    var collectionSymbol = "ABC-0";
    var nftSymbol = "ABC-123";
    
    // Step 1: Attacker obtains SEED NFT for "ABC"
    await CreateAndIssueSeedNFT(AttackerAddress, seedSymbol, targetSymbol);
    
    // Step 2: Legitimate owner creates NFT collection and item
    await CreateNFTCollection(NftOwnerAddress, collectionSymbol);
    await CreateNFTItem(NftOwnerAddress, nftSymbol);
    
    // Step 3: Attacker front-runs alias setting by creating token "ABC"
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = targetSymbol,
        TokenName = "Malicious Token",
        TotalSupply = 1000000,
        Issuer = AttackerAddress,
        Owner = AttackerAddress
    });
    
    // Step 4: NFT owner sets alias (succeeds due to missing validation)
    await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = nftSymbol,
        Alias = targetSymbol
    });
    
    // Step 5: Verify the vulnerability - GetTokenInfo returns attacker's token
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = targetSymbol  // User thinks this is the NFT
    });
    
    // Assert: User gets attacker's token instead of NFT
    tokenInfo.Owner.ShouldBe(AttackerAddress);  // Attacker's token
    tokenInfo.Symbol.ShouldBe(targetSymbol);    // "ABC"
    
    // The alias exists but is never used due to GetTokenInfo prioritization
    var aliasMapping = await TokenContractStub.GetSymbolByAlias.CallAsync(new StringValue 
    { 
        Value = targetSymbol 
    });
    aliasMapping.Value.ShouldBe(nftSymbol);  // Alias exists but is shadowed
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L750-750)
```csharp
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```
