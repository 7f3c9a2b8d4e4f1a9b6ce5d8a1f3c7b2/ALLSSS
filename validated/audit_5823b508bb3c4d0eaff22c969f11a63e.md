# Audit Report

## Title
Cross-Scheme State Confusion Due to One-to-One Mapping Limitation in TokenHolder Contract

## Summary
The TokenHolder contract enforces a one-to-one relationship between manager addresses and schemes while the Profit contract supports multiple schemes per manager. When `CreateScheme` is called multiple times, it creates new schemes in the Profit contract but overwrites TokenHolder metadata, causing `RegisterForProfits` to lock tokens using metadata from one scheme while registering beneficiaries to a different scheme.

## Finding Description

The vulnerability arises from an architectural mismatch between TokenHolder and Profit contracts in scheme management.

The TokenHolder contract uses a single-entry mapping to store scheme metadata per manager address. [1](#0-0) 

The `CreateScheme` method calls Profit contract to create a new scheme [2](#0-1)  and then unconditionally overwrites the TokenHolder storage [3](#0-2)  without any duplicate check.

The Profit contract explicitly supports multiple schemes per manager by storing them in a repeated list. [4](#0-3)  The protobuf definition confirms this design. [5](#0-4) 

When `UpdateTokenHolderProfitScheme` retrieves the SchemeId, it uses `FirstOrDefault()` to get only the first scheme. [6](#0-5) 

**Exploitation Flow:**

1. Manager creates first scheme with Symbol="ELF", MinimumLockMinutes=100
   - Profit creates SchemeId_A (at index 0 in manager's scheme list)
   - TokenHolder stores {Symbol:"ELF", MinimumLockMinutes:100}

2. Manager calls `CreateScheme` again with Symbol="USDT", MinimumLockMinutes=200
   - Profit creates SchemeId_B (added at index 1)
   - TokenHolder **overwrites** to {Symbol:"USDT", MinimumLockMinutes:200}

3. User calls `RegisterForProfits` with this manager:
   - `GetValidScheme` retrieves SchemeId_A (first scheme) via `FirstOrDefault()`
   - But reads metadata showing Symbol="USDT", MinimumLockMinutes=200
   - Locks USDT tokens [7](#0-6) 
   - Adds beneficiary to SchemeId_A (the ELF scheme) [8](#0-7) 

The user has now locked USDT tokens but is registered to receive ELF profits from SchemeId_A, breaking the fundamental invariant that locked tokens must match the profit distribution scheme.

## Impact Explanation

**Critical Security Invariant Broken:**
- Users lock incorrect token types that don't correspond to their registered profit scheme
- Wrong lock duration is enforced [9](#0-8) 
- The first scheme becomes orphaned and inaccessible through TokenHolder methods
- All subsequent operations (`Withdraw`, `ContributeProfits`, `DistributeProfits`) operate on corrupted mixed state

This breaks the core security guarantee that locked tokens correspond to the profit scheme they're registered to, potentially resulting in users locking valuable tokens while being unable to receive the intended profits, effectively making those funds stuck.

## Likelihood Explanation

**High Likelihood:**
- `CreateScheme` is a public method with no access restrictions [10](#0-9) 
- No assertion or check prevents calling it multiple times
- The Profit contract is explicitly designed to support multiple schemes per manager, as demonstrated in test cases [11](#0-10)  which show creating 5 schemes successfully
- No warning is issued on subsequent calls
- Users may legitimately attempt to create multiple schemes for different tokens or configurations without realizing it corrupts state

## Recommendation

Add a check in `CreateScheme` to prevent creating multiple schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this address.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, redesign to support multiple schemes by using a compound key (manager + schemeId) or by preventing the architectural mismatch between the two contracts.

## Proof of Concept

```csharp
[Fact]
public async Task CrossSchemeStateConfusion_PoC()
{
    // Setup: Create initial token for testing
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "USDT",
        Decimals = 8,
        IsBurnable = true,
        TokenName = "USDT Token",
        TotalSupply = 1000000_00000000,
        Issuer = Starter,
        Owner = Starter,
        LockWhiteList = { TokenHolderContractAddress }
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "USDT",
        Amount = 100000_00000000,
        To = Starter,
        Memo = "issue"
    });

    // Step 1: Create first scheme with ELF
    await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = 100
        });

    // Step 2: Create second scheme with USDT (this overwrites metadata)
    await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "USDT",
            MinimumLockMinutes = 200
        });

    // Verify: Manager now has 2 schemes in Profit contract
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    schemeIds.SchemeIds.Count.ShouldBe(2); // Two schemes exist

    // But TokenHolder only shows the last one
    var tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    tokenHolderScheme.Symbol.ShouldBe("USDT"); // Overwritten to USDT
    tokenHolderScheme.MinimumLockMinutes.ShouldBe(200);

    // Step 3: User registers for profits
    var userStub = GetTokenHolderContractTester(UserKeyPairs[0]);
    await GetTokenContractTester(UserKeyPairs[0]).Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "USDT",
        Amount = 1000_00000000
    });

    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000_00000000
    });

    // VULNERABILITY DEMONSTRATED:
    // User's USDT tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(
        new GetLockedAmountInput
        {
            Address = UserAddresses[0],
            Symbol = "USDT",
            LockId = HashHelper.ComputeFrom($"{Starter}{UserAddresses[0]}")
        });
    lockedAmount.Amount.ShouldBe(1000_00000000); // USDT is locked

    // But user is registered to the FIRST scheme (ELF scheme)
    var firstSchemeId = schemeIds.SchemeIds[0]; // This is the ELF scheme
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            SchemeId = firstSchemeId,
            Beneficiary = UserAddresses[0]
        });
    profitDetails.Details.Count.ShouldBePositive(); // User IS registered to ELF scheme
    
    // STATE CONFUSION: User locked USDT but is registered for ELF profits!
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** protobuf/profit_contract.proto (L288-291)
```text
message CreatedSchemeIds {
    // The scheme ids.
    repeated aelf.Hash scheme_ids = 1;
}
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L21-39)
```csharp
        const int createTimes = 5;

        var creator = Creators[0];
        var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

        for (var i = 0; i < createTimes; i++)
        {
            var executionResult = await creator.CreateScheme.SendAsync(new CreateSchemeInput
            {
            });
            executionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }

        var createdSchemeIds = await creator.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = creatorAddress
        });

        createdSchemeIds.SchemeIds.Count.ShouldBe(createTimes);
```
