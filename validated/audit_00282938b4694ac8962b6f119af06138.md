# Audit Report

## Title
Association Proposal Validation Allows Zero Address Leading to Permanent Proposal Failure

## Summary
The Association contract's proposal validation only checks for null addresses but does not validate against zero addresses (32 bytes of 0x00). A proposal with a zero address can pass validation and be approved, but will permanently fail during release because the inline transaction to a non-existent contract address causes the parent transaction to roll back, preventing the proposal removal from persisting in state.

## Finding Description

The validation function in the Association contract performs insufficient address validation. [1](#0-0) 

This validation only checks if `ToAddress` is null, but in AElf's type system, an Address is a protobuf-generated class that wraps a ByteString value. [2](#0-1) 

A zero address created via `Address.FromBytes(new byte[32])` produces a valid non-null Address object that passes the null check but points to no actual contract, as confirmed by the address length constant being 32 bytes. [3](#0-2) 

When such a proposal is released, the contract creates an inline transaction to the zero address. [4](#0-3) 

During inline transaction execution, the system attempts to retrieve the contract executive for the target address. When no contract exists at the address, a `SmartContractFindRegistrationException` is caught and the transaction trace is marked with `ExecutionStatus.ContractError`. [5](#0-4) 

In AElf's transaction execution model, a transaction is only considered successful if all its inline transactions succeed. [6](#0-5) 

When a transaction fails due to unsuccessful inline transactions, only pre-transaction and post-transaction plugin state changes are persisted; the main transaction's state changes are rolled back. [7](#0-6) 

This behavior is confirmed by test cases demonstrating that failed inline transactions result in zero state changes. [8](#0-7) 

As a result, the proposal removal statement never persists, leaving the proposal stuck in an approved but unreleasable state until expiration, at which point it can be cleared via the `ClearProposal` function. [9](#0-8) 

## Impact Explanation

**Operational Impact - Medium Severity:**

This vulnerability enables a governance denial-of-service attack with the following consequences:

1. **Stuck Proposals**: Approved proposals with zero addresses cannot be released and occupy state storage until expiration
2. **Gas Wastage**: Each Release attempt by the proposer consumes gas with guaranteed failure
3. **Organization DoS**: Multiple such proposals can clog an organization's proposal queue, especially if multiple proposers are compromised
4. **Resource Lock**: Proposal IDs and state entries remain locked until manual cleanup after expiration

The severity is Medium rather than High because:
- Only whitelisted proposers can create proposals (requires trust or account compromise)
- No direct fund theft or unauthorized state changes occur
- Proposals eventually expire and can be cleared through the public `ClearProposal` function
- The attack is detectable (zero address visible in proposal details)

## Likelihood Explanation

**Likelihood: Medium**

The likelihood is assessed as Medium based on:

**Attacker Requirements:**
- Must have proposer whitelist membership (trusted role or compromised account)
- Can construct proposals with arbitrary addresses

**Attack Complexity: Low**
- Creating a zero address is trivial: `Address.FromBytes(new byte[32])`
- No special knowledge or complex setup required
- Single transaction to create malicious proposal

**Feasibility:**
- Realistic for disgruntled insiders with proposer access
- Viable if proposer accounts are compromised
- Requires social engineering or legitimate-looking proposal content to get approval

**Economic Rationality:**
- Low cost to attacker (only CreateProposal gas)
- High cost to organization (repeated Release attempts, governance disruption)
- Rational for organizational sabotage scenarios

**Detection Constraints:**
- Zero address is visible in proposal details but may not be immediately recognized as invalid
- Could be disguised with legitimate-looking method names and parameters

## Recommendation

Add explicit validation in the `Validate(ProposalInfo proposal)` method to check for zero addresses:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    // Add zero address check
    if (proposal.ToAddress.Value.All(b => b == 0))
        return false;

    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

Alternatively, validate that the target address corresponds to a deployed contract by checking contract registration during proposal creation.

## Proof of Concept

```csharp
[Fact]
public async Task Test_ZeroAddress_Proposal_Fails_Release()
{
    // Create organization
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } },
        OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { DefaultSender } }
    };
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Create proposal with zero address
    var zeroAddress = Address.FromBytes(new byte[32]);
    var createProposalInput = new CreateProposalInput
    {
        ToAddress = zeroAddress,
        ContractMethodName = "SomeMethod",
        OrganizationAddress = organizationAddress.Output,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        Params = ByteString.Empty
    };
    
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(createProposalInput);
    
    // Approve proposal
    await AssociationContractStub.Approve.SendAsync(proposalId.Output);
    
    // Attempt to release - should fail
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    
    // Verify proposal still exists
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ProposalId.ShouldBe(proposalId.Output);
}
```

## Notes

This vulnerability affects all Association organizations and requires coordination with proposer whitelist members to prevent exploitation. The Parliament and Referendum contracts should also be reviewed for similar validation gaps. The zero address validation should be added at the earliest opportunity to prevent governance disruption attacks.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** src/AElf.Types/Types/Address.cs (L49-58)
```csharp
        public static Address FromBytes(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Address
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** src/AElf.Types/AElfConstants.cs (L8-8)
```csharp
        public const int AddressHashLength = 32;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L150-161)
```csharp
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```

**File:** test/AElf.Parallel.Tests/DeleteDataFromStateDbTest.cs (L2127-2140)
```csharp
        var transactionResult = await GetTransactionResultAsync(transaction.GetHash(), block.Header);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);

        value = await GetValueAsync(accountAddress, key, block.GetHash(), block.Height);
        CheckValueNotExisted(value);

        var blockStateSet = await _blockStateSetManger.GetBlockStateSetAsync(block.GetHash());
        blockStateSet.Changes.Count.ShouldBe(0);
        blockStateSet.Deletes.Count.ShouldBe(0);

        chain = await _blockchainService.GetChainAsync();
        await SetIrreversibleBlockAsync(chain);
        await CheckValueNotExistedInVersionStateAsync(key);
    }
```
