# Audit Report

## Title
Consensus Signature Manipulation via Unvalidated PreviousInValue Input

## Summary
The AEDPoS consensus contract contains a critical vulnerability where miners can manipulate their signature values by providing arbitrary `PreviousInValue` inputs. The signature calculation unconditionally uses miner-controlled input even when validation fails, allowing miners to bias their mining order in subsequent rounds and violate consensus fairness guarantees.

## Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue` function where signature calculation logic is inconsistent with the validation logic. [1](#0-0) 

The code performs a validation check to verify if the provided `PreviousInValue` hashes to the expected previous round `OutValue`. When validation fails (the hash doesn't match), it sets `previousInValue = Hash.Empty`. However, the critical bug occurs at line 92: the signature is **always** calculated using `triggerInformation.PreviousInValue` (the unvalidated, miner-controlled input), regardless of whether validation passed or failed. This line is positioned outside the if/else validation block, causing it to execute unconditionally.

This calculated signature directly determines the miner's position in the next round through the `SupposedOrderOfNextRound` calculation: [2](#0-1) 

The signature is then permanently stored in state during consensus information processing: [3](#0-2) 

The `UpdateValueValidationProvider` fails to detect this manipulation because it only validates that the signature is non-null/non-empty and that the **stored** `previousInValue` (which could be `Hash.Empty`) hashes correctly: [4](#0-3) 

Line 46 explicitly allows `Hash.Empty` as a valid `previousInValue`, and there is no check verifying that `signature == CalculateSignature(previousInValue)`.

The signature calculation uses XOR operations with previous round signatures: [5](#0-4) 

**Attack Scenario:**
1. Malicious miner wants to produce a block in round N
2. Offline, miner tries many arbitrary `PreviousInValue` candidates
3. For each candidate, computes `signature = previousRound.CalculateSignature(candidate)`
4. Calculates resulting mining order: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
5. Selects the candidate that gives the most favorable position (e.g., order 1 for earliest mining)
6. Submits block with this manipulated `PreviousInValue`
7. Validation fails, sets stored `previousInValue = Hash.Empty`
8. But signature was already calculated using manipulated value
9. Block passes validation because `Hash.Empty` is allowed and signature is non-null
10. Manipulated signature is stored and determines miner's next round position

## Impact Explanation

**Severity: High**

This vulnerability directly compromises a critical consensus invariant: the fairness and unpredictability of miner scheduling. The `SupposedOrderOfNextRound` determines when each miner can produce blocks in subsequent rounds. By manipulating their signature, miners can:

- Secure earlier positions in the mining schedule, giving more frequent block production opportunities
- Gain advantages in transaction ordering and inclusion decisions
- Potentially exploit timing-sensitive operations like cross-chain transactions or MEV opportunities
- Systematically bias the consensus mechanism in their favor over honest participants

While this does not lead to direct fund theft, it fundamentally undermines the consensus mechanism's integrity by breaking the randomness and fairness properties that AEDPoS is designed to guarantee. The mining schedule should be unpredictable and fair based on cryptographically-committed random values, not manipulable by individual miners.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly practical to exploit:

**Attacker Profile:** Any authorized miner in the consensus network. No special privileges beyond normal mining rights are required.

**Attack Complexity:** Low
- Miners control their node software and can modify the consensus trigger information provider to supply arbitrary `PreviousInValue` values
- Offline computation is inexpensive: try different values, compute signatures, calculate resulting orders
- Select the most favorable value before submitting the block
- No economic cost beyond normal block production

**Success Rate:** 100% - The miner has full control over the input, and the validation logic allows the attack to succeed. The manipulated block will be accepted by the network as valid consensus data.

**Detection Difficulty:** Very difficult - The manipulated values appear as valid consensus data. Other validators see `previousInValue = Hash.Empty` and a signature value, but have no mechanism to detect that the signature was calculated using an invalid input rather than the legitimate value.

## Recommendation

The fix requires ensuring that the signature is always calculated from the validated `previousInValue` variable, not from the unvalidated `triggerInformation.PreviousInValue`. Move line 92 inside the appropriate validation blocks:

```csharp
if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
    previousRound.RealTimeMinersInformation[pubkey].OutValue)
{
    Context.LogDebug(() => "Failed to produce block at previous round?");
    previousInValue = Hash.Empty;
    // Calculate signature with Hash.Empty when validation fails
    signature = previousRound.CalculateSignature(Hash.Empty);
}
else
{
    previousInValue = triggerInformation.PreviousInValue;
    // Calculate signature with validated previousInValue
    signature = previousRound.CalculateSignature(previousInValue);
}
```

Additionally, consider adding a validation check in `UpdateValueValidationProvider` to ensure the signature matches the expected calculation from the stored `previousInValue`.

## Proof of Concept

A proof of concept would involve:
1. Setting up a test with multiple miners in a consensus round
2. Creating a malicious miner that tries multiple `PreviousInValue` candidates offline
3. Calculating signatures for each candidate and determining the resulting `SupposedOrderOfNextRound`
4. Selecting the candidate that produces order 1 (earliest position)
5. Submitting a block with this manipulated value
6. Verifying the block is accepted with `previousInValue = Hash.Empty` in storage
7. Verifying the manipulated signature determines the miner's position in the next round
8. Comparing this to an honest miner who uses their legitimate `PreviousInValue`

The test would demonstrate that the malicious miner consistently achieves better positions than honest miners, proving the consensus fairness violation.

## Notes

This vulnerability represents a fundamental flaw in the consensus signature calculation logic. The inconsistency between what gets validated (the stored `previousInValue`) and what gets used for signature calculation (the unvalidated input) creates an exploitable gap. This is a design-level issue where the separation of validation and calculation logic was not properly coordinated, allowing miners to game the system for advantageous mining positions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-93)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-246)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
