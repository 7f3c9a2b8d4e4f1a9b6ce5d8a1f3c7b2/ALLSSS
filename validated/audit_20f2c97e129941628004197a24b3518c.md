# Audit Report

## Title
Period Desynchronization Causes DoS in RegisterForProfits Auto-Distribution

## Summary
The TokenHolderContract maintains a local period counter that becomes desynchronized from the authoritative ProfitContract when scheme managers distribute profits directly. This causes RegisterForProfits calls with auto-distribution to fail with "Invalid period" assertion errors, creating a denial-of-service condition for new user registrations.

## Finding Description

The TokenHolderContract caches a local period counter in `scheme.Period` that must match the ProfitContract's `CurrentPeriod` for distributions to succeed. However, period synchronization logic is inconsistent across code paths, creating a desynchronization vulnerability.

**Critical Code Paths:**

When `RegisterForProfits` is called with auto-distribution enabled, it invokes `GetValidScheme` with the default parameter `updateSchemePeriod = false`: [1](#0-0) 

The `UpdateTokenHolderProfitScheme` method returns early when `updateSchemePeriod = false`, completely bypassing period synchronization: [2](#0-1) 

RegisterForProfits then uses this potentially stale local period for auto-distribution: [3](#0-2) 

In contrast, manual `DistributeProfits` calls force synchronization by passing `updateSchemePeriod = true`: [4](#0-3) 

**Authorization Vulnerability:**

The ProfitContract explicitly authorizes BOTH the scheme manager AND the TokenHolderContract to call DistributeProfits: [5](#0-4) 

When the scheme manager calls `ProfitContract.DistributeProfits` directly (bypassing TokenHolder), the ProfitContract increments its authoritative `CurrentPeriod`: [6](#0-5) 

But TokenHolderContract's local `scheme.Period` remains unchanged, causing desynchronization.

**Strict Period Validation:**

The ProfitContract strictly validates that the input period matches its current period: [7](#0-6) 

When desynchronized, RegisterForProfits attempts auto-distribution with a stale period, triggering this assertion failure and reverting the entire transaction.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial-of-service for the RegisterForProfits function when auto-distribution is enabled:

1. **User Impact**: All new users attempting to register for profits are unable to complete their registration when the threshold triggers auto-distribution
2. **Permanence**: The scheme remains broken until manual intervention (calling TokenHolder.DistributeProfits) resyncs the period
3. **Scope**: Affects all schemes configured with `AutoDistributeThreshold`, which is a documented, intended feature
4. **Availability**: Core user-facing functionality becomes completely unavailable

The error message returned to users would be: "Invalid period. When release scheme {schemeId} of period {stalePeriod}. Current period is {actualPeriod}"

This is not a fund loss vulnerability, but it breaks a critical protocol invariant: users must be able to register for profit schemes without interference from scheme manager actions.

## Likelihood Explanation

**Likelihood: HIGH**

1. **No privilege escalation required**: The scheme manager has legitimate authorization to call ProfitContract.DistributeProfits directly as shown in the authorization check
2. **Simple trigger**: The manager simply calls `ProfitContract.DistributeProfits` instead of `TokenHolderContract.DistributeProfits`
3. **Accidental occurrence**: The dual authorization pattern suggests direct calls are an intended use case, making accidental desynchronization likely during normal operations
4. **No warnings**: There is no documentation or technical restriction preventing direct ProfitContract calls

The vulnerability requires:
- Scheme created with `AutoDistributeThreshold` set (common configuration)
- Manager calls ProfitContract directly at least once
- User attempts RegisterForProfits, triggering auto-distribution

All preconditions are realistic and achievable through normal protocol operations.

## Recommendation

The `RegisterForProfits` method should force period synchronization when auto-distribution is enabled. Modify the code to pass `updateSchemePeriod = true`:

```csharp
public override Empty RegisterForProfits(RegisterForProfitsInput input)
{
    Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
    
    // Force period sync if auto-distribution might trigger
    var scheme = GetValidScheme(input.SchemeManager, 
        scheme?.AutoDistributeThreshold?.Any() ?? false);
    
    // ... rest of the method
}
```

Alternatively, enforce that only TokenHolderContract can call ProfitContract.DistributeProfits for TokenHolder-managed schemes by removing the scheme manager from the authorization check in ProfitContract, but this would break existing functionality.

The recommended approach is to always synchronize periods in RegisterForProfits when auto-distribution thresholds are configured.

## Proof of Concept

```csharp
// Test demonstrating the DoS vulnerability
[Fact]
public async Task RegisterForProfits_AutoDistribution_FailsAfterDirectDistribution()
{
    // 1. Setup: Create TokenHolder scheme with auto-distribution
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = { { "ELF", 100 } }
    });
    
    // 2. User A registers successfully (period syncs to 1)
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = DefaultSender,
        Amount = 50
    });
    
    // 3. Scheme manager calls ProfitContract directly (bypassing TokenHolder)
    var schemeId = (await TokenHolderContractStub.GetScheme.CallAsync(DefaultSender)).SchemeId;
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1, // ProfitContract increments to period 2
        AmountsMap = { { "ELF", 0 } }
    });
    
    // 4. Contribute enough to trigger auto-distribution threshold
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 200
    });
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = DefaultSender,
        Symbol = "ELF",
        Amount = 200
    });
    
    // 5. User B attempts to register - should fail with "Invalid period"
    var result = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = DefaultSender,
            Amount = 50
        });
    
    // Assert: Transaction fails due to period desynchronization
    result.TransactionResult.Error.ShouldContain("Invalid period");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L133-133)
```csharp
        var scheme = GetValidScheme(input.SchemeManager, true);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-152)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L196-196)
```csharp
                        Period = scheme.Period
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L289-289)
```csharp
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L479-480)
```csharp
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
