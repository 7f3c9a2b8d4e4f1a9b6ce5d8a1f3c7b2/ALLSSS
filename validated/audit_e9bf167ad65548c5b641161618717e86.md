# Audit Report

## Title
Miner List Manipulation via Unvalidated NextRound Header Information

## Summary
The AEDPoS consensus validation mechanism fails to verify that the miner list in NextRound block headers matches the expected miner list derived from election results. This allows any current miner to arbitrarily manipulate the next round's miner list during round transitions, excluding legitimate miners and subverting the election-based consensus mechanism.

## Finding Description

The vulnerability exists in the three-stage validation flow for NextRound blocks, where none of the validation stages verify that the provided miner list matches the expected set of miners from the Election contract.

**Gap 1: Pre-Execution Validation Insufficiency**

The `ValidateBeforeExecution` method only validates that the block producer is in the current round's miner list, but never validates the provided next round's miner list composition. [1](#0-0) 

The validation context includes both `BaseRound` (current round from state) and `ProvidedRound` (next round from header), but the validators only check internal consistency.

The `MiningPermissionValidationProvider` checks if the sender exists in `BaseRound.RealTimeMinersInformation.Keys`, validating only that the sender is a legitimate current miner. [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` only validates internal consistency within the provided round - checking that miners with `FinalOrderOfNextRound > 0` match those with `OutValue != null`. [3](#0-2) 

The `RoundTerminateValidationProvider` only checks that the round number increments by 1 and that all `InValue` fields are null. [4](#0-3) 

**None of these validators check that the keys of `ProvidedRound.RealTimeMinersInformation` (the actual miner list) match the expected miners based on Election contract state.**

**Gap 2: Unvalidated Direct Storage**

During execution, `ProcessNextRound` directly converts the header input to a Round object and stores it without any validation of the miner list composition. [5](#0-4) 

The method calls `AddRoundInformation(nextRound)` which directly persists the round to state storage without validating that the miner list matches Election contract expectations. [6](#0-5) 

**Gap 3: Validation Tautology in Post-Execution**

After block execution, `ValidateAfterExecution` retrieves the current round from state and compares it with the header round. [7](#0-6) 

However, for NextRound behavior (unlike UpdateValue/TinyBlock which have recovery logic), the state round retrieved at line 87 is identical to the round just stored from the header during execution. The hash comparison at lines 100-101 always succeeds because it compares data with itself, creating a validation tautology. The miner replacement validation at lines 103-123 only triggers when hashes differ, which never happens for NextRound.

**Expected Behavior Not Enforced**

The proper miner list validation exists in `GenerateNextRoundInformation`, which correctly queries the Election contract for miner replacements. [8](#0-7) 

This method calls `State.ElectionContract.GetMinerReplacementInformation` and applies legitimate replacements based on evil miner detection. However, this validation is only executed during honest block **creation** (in the GetConsensusCommand flow), never during block **validation** of received blocks.

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant that "miner schedule integrity must be maintained based on election results." The impacts are:

1. **Consensus Centralization**: A malicious miner can exclude competing miners, reducing consensus participants from N miners to a smaller attacker-controlled set, potentially achieving >50% control without winning elections.

2. **Reward Theft**: Excluded legitimate miners lose block production rewards they were entitled to through the election process, directly causing financial harm proportional to the blocks they would have produced.

3. **Governance Subversion**: The Election contract's purpose is bypassed - miners elected by token holders can be arbitrarily excluded, violating the delegated proof-of-stake security model where governance power should be derived from elections.

4. **Persistent Attack Vector**: Once a manipulated round is accepted into consensus state, the attacker can repeat the manipulation in subsequent rounds, maintaining indefinite control as long as they remain in their manipulated miner set.

5. **Network Security Degradation**: As consensus becomes centralized under attacker control, the network becomes vulnerable to traditional centralized blockchain attacks including censorship, transaction reordering, and double-spend attempts.

This is a critical consensus integrity violation affecting the core security guarantees of the AEDPoS consensus mechanism.

## Likelihood Explanation

**Attack Prerequisites (All Easily Satisfied):**
- Attacker must be a current miner: Achievable through the normal election process
- Attacker must produce a NextRound block: Happens regularly during round transitions
- No special privileges required beyond being an elected miner

**Attack Complexity: LOW**
1. Query current round state (publicly available on-chain data)
2. Craft `NextRoundInput` with modified `RealTimeMinersInformation` keys (arbitrary miner list)
3. Ensure basic validation passes: round number +1, all `InValue` fields null, internal `FinalOrderOfNextRound` consistency
4. No cryptographic operations or complex state manipulation required

**Detection Difficulty: HIGH**
- Block passes all three validation stages (`ValidateBeforeExecution`, execution, `ValidateAfterExecution`)
- No events or logs indicate miner list manipulation
- All nodes accept the block as consensus-valid
- Only manual off-chain comparison of expected vs. actual miner lists would reveal the attack

**Probability: HIGH** - Any current miner can execute this attack whenever they produce a NextRound block, which occurs at every round transition (regularly in normal operation). There are no technical barriers preventing execution.

## Recommendation

Add explicit miner list validation during the `ValidateBeforeExecution` stage for NextRound behavior. The validation should:

1. Query the Election contract to determine the expected miner list (including any legitimate replacements)
2. Compare the provided round's miner list (`ProvidedRound.RealTimeMinersInformation.Keys`) against the expected set
3. Reject blocks where the miner lists don't match

Specifically, add a new validation provider in `ValidateBeforeExecution` for NextRound:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMinerListValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

The new `NextRoundMinerListValidationProvider` should call `GenerateNextRoundInformation` (or extract its validation logic) to determine the expected miner list and compare it against the provided round's miner list.

## Proof of Concept

A proof of concept would require:

1. Deploy a test network with multiple miners
2. One miner crafts a NextRound transaction with a manipulated miner list (e.g., excluding other legitimate miners)
3. Submit the block during the attacker's legitimate time slot
4. Observe that the block passes all validation and the manipulated miner list becomes consensus state
5. Verify that excluded miners cannot produce blocks in the next round despite being legitimately elected

The test would demonstrate that `ValidateConsensusBeforeExecution` and `ValidateConsensusAfterExecution` both return `Success = true` for the malicious block, and `State.Rounds[nextRoundNumber]` contains the attacker's arbitrary miner list rather than the expected miner list from Election contract results.

## Notes

This vulnerability specifically affects NextRound transitions. NextTerm transitions have different behavior as they explicitly retrieve victories from the Election contract. The vulnerability exists because NextRound validation assumes honest block producers will use `GenerateNextRoundInformation` during block creation, but malicious miners can bypass this by providing arbitrary data that passes the insufficient validation checks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```
