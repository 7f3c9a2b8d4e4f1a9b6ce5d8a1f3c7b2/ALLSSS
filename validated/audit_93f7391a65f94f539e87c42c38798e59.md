# Audit Report

## Title
Insufficient Secret Sharing State Validation Allows DoS and Consensus Corruption in Round Transitions

## Summary
The `RoundTerminateValidationProvider.ValidationForNextRound()` method only validates that `InValue` is null for miners in the next round, but fails to verify other secret sharing fields (`EncryptedPieces`, `DecryptedPieces`, `OutValue`, `Signature`). A malicious miner serving as extra block producer can pre-populate these fields with garbage data, causing legitimate miners' `UpdateValue` transactions to fail and corrupting the secret sharing recovery mechanism.

## Finding Description

The AEDPoS consensus contract validates round transitions through `RoundTerminateValidationProvider.ValidationForNextRound()`, which only checks that `InValue` fields are null: [1](#0-0) 

However, the `MinerInRound` protobuf structure contains additional secret sharing fields that should also be empty in a new round: [2](#0-1) 

When a new round is legitimately generated via `GenerateNextRoundInformation()`, only basic fields are initialized (Pubkey, Order, ExpectedMiningTime, ProducedBlocks, MissedTimeSlots), leaving all secret sharing fields in their default null/empty state: [3](#0-2) 

The `NextRoundInput.ToRound()` method directly copies all fields without sanitization: [4](#0-3) 

**Attack Execution:**

1. A malicious miner becomes the extra block producer through normal rotation
2. The attacker crafts a `NextRoundInput` with pre-populated secret sharing fields (e.g., `EncryptedPieces` with keys matching other miners' pubkeys)
3. The validation passes because it only checks `InValue == null`
4. The round is stored with pre-populated garbage data via `ProcessNextRound()`: [5](#0-4) 

5. When legitimate miners produce blocks via `UpdateValue`, the `PerformSecretSharing` method attempts to add encrypted pieces: [6](#0-5) 

6. The `MapField.Add()` operation throws `ArgumentException` when duplicate keys exist, causing the transaction to fail
7. For `DecryptedPieces`, pre-populated garbage data corrupts the secret recovery mechanism in `RevealSharedInValues`: [7](#0-6) 

The `SecretSharingHelper.DecodeSecret()` produces incorrect InValue recovery, corrupting consensus randomness.

## Impact Explanation

**Primary Impact - Denial of Service:**
- Legitimate miners cannot successfully produce blocks because their `UpdateValue` transactions fail with `ArgumentException` when attempting to add encrypted pieces to maps that already contain duplicate keys
- The attacker can selectively target specific miners by pre-populating their `EncryptedPieces` with keys corresponding to other miners' pubkeys
- If enough miners are blocked, consensus can stall completely as insufficient miners can produce blocks
- The round remains stuck until manual intervention or timeout mechanisms activate

**Secondary Impact - Secret Sharing Corruption:**
- Pre-populated garbage in `DecryptedPieces` causes `RevealSharedInValues` to compute incorrect previous InValues using corrupted input to Shamir's secret sharing reconstruction
- This corrupts the consensus signature calculation and random number generation chain
- Affects the integrity of randomness used for miner ordering and extra block producer selection in subsequent rounds

**Affected Parties:**
- All honest miners in the affected round lose mining rewards due to failed transactions
- The entire network suffers from reduced block production or complete consensus halt
- Cross-chain operations depending on timely block finalization are delayed

**Severity:** HIGH - Combines operational DoS with cryptographic security degradation affecting consensus integrity.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be selected as the extra block producer at the end of a round, which rotates among miners based on signatures: [8](#0-7) 

- Requires being part of the active miner set
- No additional privileges beyond normal miner role needed

**Attack Complexity:**
- LOW - Simply modify the `NextRoundInput` protobuf message before submission to include pre-populated secret sharing fields
- No cryptographic breaks or complex timing attacks required
- The validation explicitly does NOT check these fields, making exploitation straightforward

**Feasibility Conditions:**
- Attacker mines blocks normally to reach extra block producer position (happens periodically, approximately every N rounds where N is the number of miners)
- The secret sharing feature must be enabled, controlled by configuration: [9](#0-8) 

**Economic Rationality:**
- Attack cost: Normal mining operation costs until gaining extra block producer position
- Attack benefit: Can block specific competitors from mining, potentially increasing attacker's relative rewards and influence
- Detection: Likely detectable through blockchain analysis showing round with pre-populated fields, but damage is already done by that point

**Probability:** MEDIUM - Requires periodic opportunity (extra block producer rotation) but execution is trivial once positioned.

## Recommendation

Extend `RoundTerminateValidationProvider.ValidationForNextRound()` to validate all secret sharing fields are in their expected clean state:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    foreach (var miner in extraData.Round.RealTimeMinersInformation.Values)
    {
        // Validate all secret sharing fields are empty/null in new round
        if (miner.InValue != null)
            return new ValidationResult { Message = "Incorrect next round information: InValue must be null." };
        if (miner.OutValue != null)
            return new ValidationResult { Message = "Incorrect next round information: OutValue must be null." };
        if (miner.Signature != null)
            return new ValidationResult { Message = "Incorrect next round information: Signature must be null." };
        if (miner.EncryptedPieces.Count > 0)
            return new ValidationResult { Message = "Incorrect next round information: EncryptedPieces must be empty." };
        if (miner.DecryptedPieces.Count > 0)
            return new ValidationResult { Message = "Incorrect next round information: DecryptedPieces must be empty." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, add a sanitization step in `ToRound()` to explicitly clear all secret sharing fields before storing the round.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithPrePopulatedSecretSharingFields_CausesUpdateValueFailure()
{
    // Setup: Initialize consensus with miners
    var miners = GenerateMiners(3);
    await InitializeConsensus(miners);
    
    // Attacker becomes extra block producer
    var attackerMiner = miners[0];
    var victimMiner = miners[1];
    
    // Progress to round where attacker is extra block producer
    await ProgressToExtraBlockProducerPosition(attackerMiner);
    
    // Craft malicious NextRoundInput with pre-populated EncryptedPieces
    var maliciousNextRound = GenerateNextRoundInput();
    maliciousNextRound.RealTimeMinersInformation[victimMiner].EncryptedPieces.Add(
        attackerMiner, // key that victim will try to add
        ByteString.CopyFrom(new byte[] { 1, 2, 3 }) // garbage data
    );
    
    // Attacker submits malicious NextRound - should pass validation (only checks InValue)
    await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    
    // Victim tries to produce block via UpdateValue
    var updateInput = GenerateUpdateValueInput(victimMiner);
    updateInput.EncryptedPieces.Add(attackerMiner, ByteString.CopyFrom(new byte[] { 4, 5, 6 }));
    
    // This should throw ArgumentException due to duplicate key in EncryptedPieces.Add()
    var result = await ConsensusContract.UpdateValue.SendWithExceptionAsync(updateInput);
    
    // Verify DoS: UpdateValue fails due to duplicate key exception
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("ArgumentException");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-53)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
