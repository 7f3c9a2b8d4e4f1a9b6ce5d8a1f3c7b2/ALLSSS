# Audit Report

## Title
Incorrect Use of TotalSupply Instead of Supply in GetNeededDeposit Causes Inflated Deposit Requirements

## Summary
The `GetNeededDeposit` function incorrectly uses `tokenInfo.TotalSupply` instead of `tokenInfo.Supply` to calculate tokens in external circulation. Since `TotalSupply` remains constant while `Supply` decreases when tokens are burned, this causes deposit requirements to be inflated by the amount of burned or unissued tokens, forcing users to deposit excessive base tokens when enabling connectors.

## Finding Description
The vulnerability exists in the `GetNeededDeposit` function where `amountOutOfTokenConvert` is calculated using `TotalSupply`: [1](#0-0) 

The core issue is that `TotalSupply` and `Supply` represent fundamentally different values in the token system. `TotalSupply` is set at token creation and represents the maximum issuable amount [2](#0-1) , while `Supply` represents actual circulating tokens that increases on issuance [3](#0-2)  and decreases on burn [4](#0-3) .

When tokens are burned, only `Supply` decreases while `TotalSupply` remains constant. The TokenConverter itself burns tokens through the `HandleFee` function on every Buy/Sell operation [5](#0-4) .

The inflated `amountOutOfTokenConvert` value is then used in the Bancor formula to calculate the required deposit [6](#0-5) , and this deposit amount is enforced when users call `EnableConnector` [7](#0-6) .

The function should calculate tokens in external circulation as `Supply - balance - AmountToTokenConvert` because only `Supply` tokens actually exist. Using `TotalSupply` incorrectly counts burned and never-issued tokens as being "in external circulation" when they don't exist anywhere. The protobuf documentation confirms `amount_out_of_token_convert` should represent "How many tokens are not on the TokenConvert address" [8](#0-7) , which should only include actually existing tokens.

## Impact Explanation
Users enabling connectors must deposit `(TotalSupply - Supply)` more base tokens than economically necessary. This overcount grows as tokens are burned through fee mechanisms or remain unissued.

**Quantified Example**: For a token with `TotalSupply = 1,000`, `Supply = 600` (400 burned/unissued), contract `balance = 300`, and `AmountToTokenConvert = 200`:
- Current (wrong): `1000 - 300 - 200 = 500` tokens external → high deposit required
- Correct: `600 - 300 - 200 = 100` tokens external → 5x lower deposit required

**Affected Users**: Any user enabling a connector for tokens where `Supply < TotalSupply`, including tokens with burn mechanisms (especially ELF, which burns fees via `HandleFee`), tokens with gradual issuance schedules, or any token where the issuer hasn't issued up to `TotalSupply`.

If the `(TotalSupply - Supply)` gap is large enough, deposit requirements become prohibitively expensive, effectively preventing token listings and locking excess capital unnecessarily.

## Likelihood Explanation
The issue manifests automatically whenever `Supply < TotalSupply`, which occurs in two common scenarios: (1) tokens are burned via `HandleFee` during every Buy/Sell transaction, and (2) tokens remain unissued.

`EnableConnector` is publicly callable with no authorization checks [9](#0-8) . Any user enabling a connector is affected.

The gap widens naturally through normal protocol operations. Every Buy/Sell transaction burns tokens via the fee mechanism, many tokens intentionally use gradual issuance models with high initial `TotalSupply`, and ELF itself has burns, making this issue systemic.

## Recommendation
Change the calculation in `GetNeededDeposit` from using `tokenInfo.TotalSupply` to `tokenInfo.Supply`:

```csharp
var amountOutOfTokenConvert = tokenInfo.Supply - balance - input.AmountToTokenConvert;
```

This ensures only actually circulating tokens are counted when calculating deposit requirements.

## Proof of Concept
```csharp
[Fact]
public async Task GetNeededDeposit_InflatedByBurnedTokens_Test()
{
    // Create token with TotalSupply = 100,000
    await ExecuteProposalForParliamentTransaction(TokenContractAddress, nameof(TokenContractStub.Create),
        new CreateInput
        {
            Symbol = "TEST",
            Decimals = 2,
            IsBurnable = true,
            Issuer = DefaultSender,
            Owner = DefaultSender,
            TokenName = "Test Token",
            TotalSupply = 100_000L,
            LockWhiteList = { TokenContractAddress, TokenConverterContractAddress }
        });

    // Issue only 60,000 tokens (Supply = 60,000, 40,000 unissued)
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "TEST",
        Amount = 60_000L,
        To = DefaultSender,
        Memo = "Initial issue"
    });

    // Burn 20,000 tokens (Supply now = 40,000, gap = 60,000)
    await TokenContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = "TEST",
        Amount = 20_000L
    });

    // Add connector pair for TEST token
    await AddPairConnectorAsync("TEST");

    // Calculate needed deposit with AmountToTokenConvert = 20,000
    var depositInfo = await DefaultStub.GetNeededDeposit.CallAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = "TEST",
        AmountToTokenConvert = 20_000L
    });

    // Current (wrong): amountOutOfTokenConvert = 100,000 - 0 - 20,000 = 80,000
    // Correct would be: 40,000 - 0 - 20,000 = 20,000
    // The gap of 60,000 (burned + unissued) inflates the deposit requirement
    depositInfo.AmountOutOfTokenConvert.ShouldBe(80_000L); // Inflated by burned/unissued tokens
    
    // This demonstrates the vulnerability: deposit is calculated based on 80,000 tokens
    // when only 20,000 tokens actually exist externally
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L81-83)
```csharp
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L72-72)
```csharp
            TotalSupply = input.TotalSupply,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L164-164)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L328-328)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L252-257)
```csharp
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-269)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L276-285)
```csharp
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });
```

**File:** protobuf/token_converter_contract.proto (L188-189)
```text
    // How many tokens are not on the TokenConvert address.
    int64 amount_out_of_token_convert = 2;
```
