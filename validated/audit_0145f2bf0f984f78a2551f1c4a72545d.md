# Audit Report

## Title
Stale Beneficiaries Due to Custom Profits Receiver Address Changes in Treasury Reward Distribution

## Summary
The Treasury contract's reward weight update functions fail to properly remove old beneficiary addresses when miners change their custom profits receiver. The removal logic queries the current receiver address instead of the historical address that was actually added as a beneficiary, resulting in permanent stale beneficiaries that continuously drain mining rewards from all three major Treasury schemes.

## Finding Description

The vulnerability stems from a fundamental disconnect between how beneficiaries are added versus how they are removed in the Treasury contract's reward distribution system.

**The Root Cause:**

When a miner changes their custom profits receiver via `SetProfitsReceiver`, the function only updates `State.ProfitsReceiverMap[input.Pubkey]` and notifies the Election contract for the Subsidy scheme. [1](#0-0) 

Critically, it does NOT update the three Treasury reward schemes: BasicReward (`State.BasicRewardHash`), VotesWeightReward (`State.VotesWeightRewardHash`), and ReElectionReward (`State.ReElectionRewardHash`).

**The Flawed Removal Logic:**

At the end of each term, `UpdateBasicMinerRewardWeights` attempts to remove old beneficiaries using `GetAddressesFromCandidatePubkeys`. [2](#0-1) 

The `GetAddressesFromCandidatePubkeys` function returns addresses by calling `GetProfitsReceiver` for each pubkey. [3](#0-2) 

The `GetProfitsReceiver` function reads the CURRENT value from `State.ProfitsReceiverMap[pubkey]`. [4](#0-3) 

This means when a miner has changed their receiver from Address A to Address B, the removal logic will attempt to remove Address B (the new receiver) instead of Address A (the old receiver that was actually added as a beneficiary).

**Silent Failure:**

The Profit contract's `RemoveBeneficiary` function silently returns empty if the beneficiary doesn't exist in the profit details map, with no assertion or event indicating failure. [5](#0-4) 

**Pattern Replication:**

The same vulnerability exists in `UpdateWelcomeRewardWeights` [6](#0-5)  and `UpdateFlexibleRewardWeights`. [7](#0-6) 

**Attack Sequence:**

1. Miner sets custom receiver to Address A in term N
2. Term N+1: `UpdateBasicMinerRewardWeights` adds Address A as beneficiary with shares
3. Between terms: Miner changes receiver to Address B via `SetProfitsReceiver`
4. Term N+2: `UpdateBasicMinerRewardWeights` tries to remove Address B (fails silently), Address A remains
5. Address B is added as new beneficiary
6. Both Address A and B now receive rewards indefinitely
7. Repeat to accumulate more stale beneficiaries

## Impact Explanation

**Direct Financial Impact:**

This is a HIGH severity vulnerability enabling systematic theft of mining rewards. Stale beneficiaries permanently remain in three major Treasury reward schemes (BasicReward, VotesWeightReward, ReElectionReward), continuously receiving proportional shares of distributed profits. Each stale beneficiary dilutes the rewards of all legitimate current miners.

**Scale of Impact:**
- Affects all three primary Treasury reward distribution channels
- Cannot be recovered once rewards are distributed to stale addresses
- Compounds with multiple receiver changes, creating multiple permanent drains per miner
- No upper bound on accumulated stale beneficiaries

**Affected Parties:**
- **Active miners:** Receive reduced rewards due to inflated total shares
- **Treasury pool:** Systematically drained to addresses that are no longer active participants
- **Protocol integrity:** Reward distribution mechanism fundamentally broken

The vulnerability breaks the core security guarantee that only current, legitimate miners receive mining rewards proportional to their contributions.

## Likelihood Explanation

**Attacker Capabilities:**

Any registered candidate can exploit this vulnerability through their admin account. The authorization check in `SetProfitsReceiver` only validates that the sender is the candidate's admin. [8](#0-7) 

**Attack Complexity:**

Extremely low - requires only a single transaction to `SetProfitsReceiver` with a new address. No complex timing, race conditions, or special preconditions are needed. The attack is deterministic and works every time.

**Detection Difficulty:**
- Stale beneficiaries are indistinguishable from legitimate beneficiaries in the profit schemes
- No events or logs indicate when `RemoveBeneficiary` silently fails
- No monitoring mechanism exists to identify accumulating stale beneficiaries

**Realistic Preconditions:**
- Attacker must be a registered candidate (normal network participant role)
- No additional privileges or compromised keys required
- Term transitions provide natural opportunity windows

**Probability Assessment:**

HIGH - The attack is trivial to execute, costs nothing beyond standard transaction fees, provides direct financial benefit, and is extremely difficult to detect. Any economically rational adversarial candidate would exploit this vulnerability.

## Recommendation

**Solution: Track Historical Beneficiaries**

The Treasury contract should maintain a mapping of historical beneficiary addresses that were actually added to each scheme, rather than relying on the current `ProfitsReceiverMap` value during removal. 

**Implementation Approach:**

1. **Store Historical Beneficiaries:** When adding beneficiaries in `UpdateBasicMinerRewardWeights`, `UpdateWelcomeRewardWeights`, and `UpdateFlexibleRewardWeights`, store the actual address that was added in a state variable keyed by pubkey and term number.

2. **Use Historical Data for Removal:** When removing beneficiaries in the next term, read from this historical mapping instead of calling `GetProfitsReceiver` which returns the current value.

3. **Alternative: Update Schemes on Receiver Change:** Modify `SetProfitsReceiver` to immediately update all three reward schemes by removing the old beneficiary and adding the new one. This ensures the schemes stay synchronized with the current receiver.

4. **Add Failure Events:** Modify the Profit contract's `RemoveBeneficiary` to emit an event when removal fails due to non-existent beneficiary, enabling detection and monitoring.

## Proof of Concept

```csharp
[Fact]
public async Task StaleBeneficiaryVulnerability_Test()
{
    // Setup: Register candidate and become miner
    var candidateKeyPair = SampleECKeyPairs.KeyPairs[0];
    var candidatePubkey = candidateKeyPair.PublicKey.ToHex();
    var addressA = SampleAddress.AddressList[0];
    var addressB = SampleAddress.AddressList[1];
    
    // Term N: Set custom receiver to Address A
    await TreasuryContractStub.SetProfitsReceiver.SendAsync(new SetProfitsReceiverInput
    {
        Pubkey = candidatePubkey,
        ProfitsReceiverAddress = addressA
    });
    
    // Term N+1: Simulate term transition - Address A gets added as beneficiary
    await NextTerm(BlockMinerKeyPair);
    
    // Verify Address A is beneficiary in BasicReward scheme
    var schemeId = (await TreasuryContractStub.GetTreasurySchemeId.CallAsync(new Empty())).Value;
    var basicRewardId = /* get from GetMinerRewardWeightProportion */;
    var profitDetailsA = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = basicRewardId,
        Beneficiary = addressA
    });
    Assert.NotNull(profitDetailsA);
    
    // Between terms: Change receiver to Address B
    await TreasuryContractStub.SetProfitsReceiver.SendAsync(new SetProfitsReceiverInput
    {
        Pubkey = candidatePubkey,
        ProfitsReceiverAddress = addressB
    });
    
    // Term N+2: Simulate term transition - Address B gets added, but A remains
    await NextTerm(BlockMinerKeyPair);
    
    // VULNERABILITY: Both Address A and Address B are now beneficiaries
    var profitDetailsA_after = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = basicRewardId,
        Beneficiary = addressA
    });
    var profitDetailsB = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = basicRewardId,
        Beneficiary = addressB
    });
    
    // Both should NOT be beneficiaries, but they are
    Assert.NotNull(profitDetailsA_after); // STALE BENEFICIARY
    Assert.NotNull(profitDetailsB); // NEW BENEFICIARY
    
    // Both addresses will receive rewards, diluting legitimate miners
}
```

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L601-629)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");

        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L848-891)
```csharp
    private void UpdateWelcomeRewardWeights(Round previousTermInformation, List<string> newElectedMiners)
    {
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });

        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
        }
        else
        {
            Context.LogDebug(() => "Welcome reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L893-936)
```csharp
    private void UpdateFlexibleRewardWeights(Round previousTermInformation)
    {
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.WelfareHash.Value
        });
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
        if (State.ProfitContract.GetScheme.Call(State.ReElectionRewardHash.Value).TotalShares > 0)
        {
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
        }

        if (State.HasNewMiner[previousTermInformation.TermNumber])
        {
            Context.LogDebug(() => "Flexible reward will go to Welfare Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.WelfareHash.Value,
                SubSchemeShares = 1
            });
        }
        else
        {
            Context.LogDebug(() => "Flexible reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```
