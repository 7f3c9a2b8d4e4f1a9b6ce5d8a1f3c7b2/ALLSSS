# Audit Report

## Title
Resource Token Debt Accumulates Indefinitely Without Repayment Mechanism, Causing Eventual Overflow

## Summary
The `PayResourceTokens()` function in the MultiToken contract accumulates resource token debt in the `OwningResourceToken` state when contracts have insufficient balance, but unlike the parallel `OwningRental` system for side chain rentals, provides no mechanism to repay or clear this debt. This design flaw causes unbounded debt accumulation that will eventually exceed `long.MaxValue`, triggering an overflow exception in the `DonateResourceToken` system transaction and potentially disrupting block production.

## Finding Description

The vulnerability exists in the resource token payment mechanism where debt accumulation occurs without any corresponding repayment logic.

When `PayResourceTokens()` processes a contract that has insufficient balance to pay for consumed resources, it calculates the shortfall and adds it to the existing debt: [1](#0-0) 

A comprehensive grep search confirms that this is the **only location** in the codebase where `OwningResourceToken` state is modified - the state variable is only incremented, never decremented.

The `CheckResourceToken()` function verifies that balance exceeds debt but does not reduce the accumulated debt: [2](#0-1) 

**Root Cause:** Complete absence of debt repayment logic in the resource token system.

**Why Existing Protections Fail:** The `.Add()` operation uses checked arithmetic that throws `OverflowException` when the debt exceeds `long.MaxValue`: [3](#0-2) 

This means the overflow will cause a system transaction failure rather than silently wrapping around.

**Inconsistency with Similar Code:** The `PayRental()` function implements proper debt repayment for `OwningRental`, explicitly clearing debt when sufficient balance exists: [4](#0-3) 

This demonstrates the expected pattern that `PayResourceTokens()` fails to implement - when balance becomes sufficient, the debt should be paid down and cleared.

**Execution Path:** The `DonateResourceToken()` method is called as a system transaction at the end of each block: [5](#0-4) 

This system transaction then invokes `PayResourceTokens()`: [6](#0-5) 

## Impact Explanation

**Operational Harm:** When accumulated debt exceeds `long.MaxValue`, the overflow exception will cause the `DonateResourceToken` system transaction to fail. Since this transaction is automatically generated at the end of each block as part of the resource fee collection mechanism, its failure could disrupt block production and consensus operations.

**Accounting Integrity:** Once debt begins accumulating, it never clears even when contracts obtain sufficient balance. This violates the fundamental invariant that debts should be repayable. The debt tracking becomes meaningless as it can only increase, preventing accurate resource accounting and creating a permanent liability that has no resolution mechanism.

**Affected Parties:**
- Contracts that consume resources without maintaining sufficient balances accumulate permanent debt
- The entire chain when overflow causes system transaction failures
- Block producers who cannot process blocks due to system transaction failures

The severity is Medium due to the concrete DoS potential affecting critical system operations (block production), though the exploitation timeline is extended.

## Likelihood Explanation

**Attacker Capabilities:** Any deployed contract can contribute to debt accumulation by consuming resource tokens (CPU, RAM, DISK, NET) without maintaining sufficient balance. No special privileges or malicious intent required - normal operation of underfunded contracts causes this.

**Attack Complexity:** Low - passive accumulation through normal resource consumption when balance is insufficient.

**Feasibility Conditions:**
1. Contract consistently consumes resource tokens
2. Contract maintains insufficient balance relative to consumption
3. Accumulation continues until reaching `long.MaxValue`

**Timeline Constraints:** For a token with 8 decimals, reaching overflow requires accumulating approximately 92 billion tokens worth of debt. At 1,000 tokens per block, this would require approximately 92 million blocks (roughly 11.6 years at 4 seconds per block). However:
- Multiple contracts can contribute to the same symbol's debt
- Higher consumption rates accelerate accumulation
- The fundamental issue is that ANY debt is permanent

**Detection:** Debt accumulation is tracked via `ResourceTokenOwned` events: [7](#0-6) 

However, there is no mechanism to clear accumulated debt.

**Probability:** Low-to-Medium. While normal operations are unlikely to reach overflow quickly, the complete absence of any repayment mechanism means ANY debt accumulation is permanent and will eventually cause system failure over sufficient time.

## Recommendation

Implement debt repayment logic in `PayResourceTokens()` following the pattern established in `PayRental()`:

```csharp
private void PayResourceTokens(TotalResourceTokensMaps billMaps, bool isMainChain)
{
    foreach (var bill in billMaps.Value)
    {
        foreach (var feeMap in bill.TokensMap.Value)
        {
            var symbol = feeMap.Key;
            var amount = feeMap.Value;
            var existingBalance = GetBalance(bill.ContractAddress, symbol);
            
            // NEW: Check and repay existing debt first
            var owingResourceToken = State.OwningResourceToken[bill.ContractAddress][symbol];
            if (owingResourceToken > 0 && existingBalance > owingResourceToken)
            {
                // Pay debt first
                amount = amount.Add(owingResourceToken);
                existingBalance = existingBalance.Sub(owingResourceToken);
                State.OwningResourceToken[bill.ContractAddress][symbol] = 0;
            }
            
            // Original logic continues...
            if (amount > existingBalance)
            {
                var owned = amount.Sub(existingBalance);
                var currentOwning = State.OwningResourceToken[bill.ContractAddress][symbol].Add(owned);
                State.OwningResourceToken[bill.ContractAddress][symbol] = currentOwning;
                Context.Fire(new ResourceTokenOwned
                {
                    Symbol = symbol,
                    Amount = currentOwning,
                    ContractAddress = bill.ContractAddress
                });
                amount = existingBalance;
            }
            
            // Rest of payment logic...
        }
    }
}
```

## Proof of Concept

A test demonstrating this issue would:

1. Deploy a contract that consumes resource tokens
2. Execute `DonateResourceToken` when contract has insufficient balance (debt accumulates)
3. Fund the contract with sufficient balance
4. Execute `DonateResourceToken` again
5. Verify that debt remains unchanged (it should have been cleared but is not)
6. Repeat until approaching overflow to demonstrate the system transaction will fail

The test would confirm that unlike `OwningRental` (which has `PayDebtTest` demonstrating successful debt clearance), `OwningResourceToken` debt never decreases regardless of subsequent balance availability.

## Notes

This vulnerability is distinct from the side chain rental system (`OwningRental`) which correctly implements debt repayment. The inconsistency suggests this may be an oversight rather than intentional design. The state variable definition confirms the tracking structure exists: [8](#0-7) 

However, no corresponding repayment logic was implemented, creating a one-way debt accumulation system that will eventually cause system failure.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L602-614)
```csharp
    public override Empty CheckResourceToken(Empty input)
    {
        AssertTransactionGeneratedByPlugin();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName))
        {
            var balance = GetBalance(Context.Sender, symbol);
            var owningBalance = State.OwningResourceToken[Context.Sender][symbol];
            Assert(balance > owningBalance,
                $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L945-945)
```csharp
        PayResourceTokens(input, isMainChain);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L970-974)
```csharp
                if (amount > existingBalance)
                {
                    var owned = amount.Sub(existingBalance);
                    var currentOwning = State.OwningResourceToken[bill.ContractAddress][symbol].Add(owned);
                    State.OwningResourceToken[bill.ContractAddress][symbol] = currentOwning;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1047-1058)
```csharp
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L13-24)
```csharp
internal class DonateResourceTransactionGenerator : ISystemTransactionGenerator
{
    private readonly ISmartContractAddressService _smartContractAddressService;
    private readonly ITotalResourceTokensMapsProvider _totalResourceTokensMapsProvider;


    public DonateResourceTransactionGenerator(ISmartContractAddressService smartContractAddressService,
        ITotalResourceTokensMapsProvider totalResourceTokensMapsProvider)
    {
        _smartContractAddressService = smartContractAddressService;
        _totalResourceTokensMapsProvider = totalResourceTokensMapsProvider;
    }
```

**File:** protobuf/transaction_fee.proto (L41-46)
```text
message ResourceTokenOwned {
    option (aelf.is_event) = true;
    string symbol = 1;
    int64 amount = 2;
    aelf.Address contract_address = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L29-32)
```csharp
    /// <summary>
    ///     Contract Address -> (Owning) Resource Token Symbol -> Amount.
    /// </summary>
    public MappedState<Address, string, long> OwningResourceToken { get; set; }
```
