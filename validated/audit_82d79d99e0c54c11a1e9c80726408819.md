# Audit Report

## Title
Empty Pubkey Candidate Registration Causes Consensus Failure During Term Transition

## Summary
The Election Contract's `AnnounceElectionFor` method lacks validation to prevent registration of empty pubkey strings. When an empty pubkey candidate accumulates sufficient votes and is elected as a miner, the subsequent term transition fails with an `IndexOutOfRangeException` in `GenerateFirstRoundOfNewTerm`, causing complete blockchain consensus halt.

## Finding Description

The vulnerability exists in the candidate registration flow where pubkey strings are converted to byte arrays without length validation.

In `AnnounceElectionFor`, the input pubkey string is directly converted to a byte array: [1](#0-0) 

When the pubkey is an empty string, `ByteArrayHelper.HexStringToByteArray("")` returns an empty byte array. This empty byte array is then passed to the internal `AnnounceElection` method, which creates an empty `ByteString` and adds it to the candidates list: [2](#0-1) 

The validation checks in `AnnounceElection` verify initial miner status, banned status, and duplicate announcements, but critically omit pubkey length validation: [3](#0-2) 

During term transitions, the Consensus Contract queries for the new miner list via `GetVictories`. If the empty pubkey candidate has accumulated sufficient votes to rank in the top N candidates, it will be included in the returned victories: [4](#0-3) 

The Consensus Contract then calls `GenerateFirstRoundOfNewTerm` on the returned `MinerList`: [5](#0-4) 

This function attempts to sort miners by accessing the first byte of each pubkey: [6](#0-5) 

When `miner` is an empty `ByteString` (length = 0), the indexing operation `miner[0]` throws an `IndexOutOfRangeException`, crashing the term generation process and halting the blockchain's consensus mechanism.

## Impact Explanation

This vulnerability enables a complete denial of service of the blockchain's consensus mechanism with the following impacts:

**Direct Harm:**
- The blockchain cannot transition to new terms, preventing miner list updates
- Block production halts when the exception is thrown during term transition
- All consensus-dependent operations (block validation, finalization, cross-chain communication) become impossible

**Protocol Damage:**
- Indefinite blockchain freeze requiring emergency intervention or hard fork
- Loss of network liveness and availability for all users
- Economic losses from halted transactions and frozen funds
- Severe reputational damage to the blockchain network

**Affected Parties:**
- All network participants (users, dApps, validators)
- The entire AElf mainchain or affected sidechain

This is classified as **HIGH severity** because it completely disables the consensus mechanism, affects the entire network, and requires emergency measures to resolve.

## Likelihood Explanation

The attack has **MEDIUM likelihood** due to the following factors:

**Attacker Capabilities Required:**
1. Lock 100,000 ELF tokens as candidate registration deposit
2. Acquire or coordinate sufficient voting power to place the empty pubkey in the top N miners (typically requires millions of locked ELF tokens depending on network participation)

**Attack Complexity:**
- **Low technical complexity**: Single contract call to register empty pubkey, standard voting operations
- **High economic cost**: Requires substantial capital (100K ELF deposit + significant voting power)
- **Medium coordination**: Can be executed by a single wealthy actor or requires coordinating multiple voters

**Feasibility Conditions:**
- Entry point is publicly accessible via `AnnounceElectionFor`
- No technical barriers prevent the attack
- Economic barrier is high but feasible for well-funded attackers
- One-time cost can cause persistent DoS until fixed
- Attack becomes obvious only during term transition when blockchain halts

The combination of unrestricted entry point, lack of validation, and feasible economic requirements for sophisticated attackers justifies a MEDIUM likelihood assessment.

## Recommendation

Add pubkey length validation in the `AnnounceElectionFor` method to ensure non-empty pubkeys:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    Assert(!string.IsNullOrEmpty(pubkey), "Pubkey cannot be empty.");
    
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    Assert(pubkeyBytes.Length > 0, "Invalid pubkey length.");
    
    var address = Address.FromPublicKey(pubkeyBytes);
    AnnounceElection(pubkeyBytes);
    // ... rest of the method
}
```

Additionally, add a defensive check in the `AnnounceElection` internal method:

```csharp
private void AnnounceElection(byte[] pubkeyBytes)
{
    Assert(pubkeyBytes != null && pubkeyBytes.Length > 0, "Pubkey cannot be empty.");
    
    var pubkey = pubkeyBytes.ToHex();
    var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);
    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPubkey_CausesConsensusFailure_Test()
{
    // Step 1: Register empty pubkey candidate
    var registerResult = await ElectionContractStub.AnnounceElectionFor.SendAsync(
        new AnnounceElectionForInput
        {
            Pubkey = "", // Empty pubkey
            Admin = DefaultSender
        });
    
    // Step 2: Simulate voting for empty pubkey candidate
    // (Vote accumulation would happen over time in real scenario)
    
    // Step 3: Trigger term transition
    // The consensus contract will call GetVictories which returns the empty pubkey
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // Step 4: Attempt to generate first round of new term
    // This should throw IndexOutOfRangeException when accessing miner[0]
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        var minerList = new MinerList { Pubkeys = { victories.Value } };
        var round = minerList.GenerateFirstRoundOfNewTerm(
            miningInterval: 4000,
            currentBlockTime: TimestampHelper.GetUtcNow(),
            currentRoundNumber: 1,
            currentTermNumber: 1);
    });
    
    Assert.Contains("IndexOutOfRange", exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L123-126)
```csharp
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L146-174)
```csharp
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```
