# Audit Report

## Title
Missing Size Validation on Encrypted Pieces Allows State Bloat Attack

## Summary
The AEDPoS consensus contract's secret sharing mechanism stores encrypted pieces without size validation, allowing a malicious miner to submit grossly oversized data (up to ~4.5MB per transaction) that persists across 40,960 rounds, causing cumulative state bloat and network-wide degradation.

## Finding Description

The vulnerability exists in the consensus secret sharing mechanism where encrypted pieces are stored in round state without any size constraints.

**Entry Point:** A miner calls the public `UpdateValue()` method [1](#0-0) , which routes through `ProcessConsensusInformation()` [2](#0-1)  to `ProcessUpdateValue()`.

**Vulnerable Code Path:** When secret sharing is enabled, `ProcessUpdateValue()` calls `PerformSecretSharing()` [3](#0-2) , which directly adds the encrypted pieces to state without validation [4](#0-3) .

Similarly, `UpdateLatestSecretPieces()` iterates through trigger information and adds encrypted pieces directly to the round state without size checks [5](#0-4) .

**Missing Validation:** The `UpdateValueValidationProvider` only validates OutValue and PreviousInValue correctness, with no size validation on encrypted_pieces [6](#0-5) .

**Protobuf Definition:** The encrypted_pieces field is defined as `map<string, bytes>` with no size constraints in the protobuf specification [7](#0-6)  and [8](#0-7) .

**Only Protection:** The sole protection is the global transaction size limit of 5MB [9](#0-8) , which is insufficient as it permits ~4.5MB of bloated data per transaction.

**State Persistence:** The system retains 40,960 rounds in state before cleanup [10](#0-9) , with cleanup occurring in `AddRoundInformation()` [11](#0-10) .

## Impact Explanation

**State Bloat Severity:** Normal encrypted pieces total approximately 3KB per round. A malicious miner can inflate this to ~4.5MB per UpdateValue transaction, achieving a 1500x bloat factor.

**Cumulative Damage:** With 40,960 rounds kept in state, sustained attacks cause:
- 100 bloated rounds = 450MB of unnecessary state
- 1,000 bloated rounds = 4.5GB of unnecessary state
- Prolonged attacks could reach tens of gigabytes

**Network-Wide Impact:**
- All full nodes must store and synchronize bloated state
- New nodes experience significantly prolonged synchronization times
- State queries and consensus operations suffer performance degradation
- Storage infrastructure costs increase for all network participants
- Risk of chain instability if state size becomes unmanageable

This is a DoS attack vector affecting network availability and operational sustainability rather than direct fund theft.

## Likelihood Explanation

**Attacker Requirements:** The attacker must be a valid miner in the current or previous round, verified by PreCheck [12](#0-11) .

**Feasibility:** Miner status is achievable through the election process without extraordinary barriers. Once achieved, the attack requires only modifying node software to generate oversized encrypted_pieces when calling UpdateValue.

**Attack Complexity:** Low - no cryptographic bypasses or complex timing attacks required. The attacker simply populates the encrypted_pieces map with oversized byte arrays within the 5MB transaction limit.

**Detection and Remediation:** While monitoring could detect unusual transaction sizes, damage accumulates before governance can vote to exclude the malicious miner. During this remediation period, additional bloat accrues.

**Repeatability:** The attack can be executed repeatedly across multiple rounds during the attacker's mining tenure, and could be coordinated across multiple compromised miners for amplified impact.

## Recommendation

Implement size validation for encrypted_pieces in multiple layers:

1. **Add validation in `PerformSecretSharing()` and `UpdateLatestSecretPieces()`**: Check the total size of encrypted_pieces before adding them to state. Reject transactions that exceed a reasonable threshold (e.g., 10KB per miner).

2. **Enhance `UpdateValueValidationProvider`**: Add size validation as part of the consensus validation pipeline to reject oversized encrypted_pieces before execution.

3. **Add protobuf field validators**: Consider using protobuf validation annotations or custom validators to enforce size limits at the message level.

4. **Implement per-round monitoring**: Track cumulative encrypted_pieces size per round and reject updates that cause excessive growth.

## Proof of Concept

Due to the complexity of setting up a full AEDPoS consensus test environment with secret sharing enabled, a complete PoC would require:

1. Deploying the AEDPoS contract with secret sharing enabled
2. Setting up a miner node in the test network
3. Modifying the miner software to generate oversized encrypted_pieces (e.g., 4MB of random bytes)
4. Calling `UpdateValue()` with the bloated encrypted_pieces
5. Observing the state growth across multiple rounds
6. Verifying that all nodes must store and sync this bloated state

The vulnerability is confirmed through code analysis showing the complete absence of size validation in the execution paths identified above.

### Citations

**File:** protobuf/aedpos_contract.proto (L30-31)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L210-210)
```text
    map<string, bytes> encrypted_pieces = 8;
```

**File:** protobuf/aedpos_contract.proto (L294-294)
```text
    map<string, bytes> encrypted_pieces = 14;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L45-47)
```csharp
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-329)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L118-123)
```csharp
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
```
