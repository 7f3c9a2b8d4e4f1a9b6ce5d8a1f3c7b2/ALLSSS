# Audit Report

## Title
Insufficient Validation of ProducedBlocks in NextRound Allows Mining Reward Inflation

## Summary
The consensus contract's `NextRound` transaction processing accepts and stores `ProducedBlocks` values from miner-submitted input without validating them against the current round state. A malicious miner can inflate these values to multiply mining rewards, causing token supply inflation and corrupted election statistics.

## Finding Description

The vulnerability exists in the asymmetric treatment of `ProducedBlocks` validation between different consensus behaviors.

For `UpdateValue` transactions, the contract explicitly protects against manipulation by loading the current state and incrementing by 1, ignoring any submitted values. [1](#0-0) 

However, for `NextRound` transactions, the `ProcessNextRound` method accepts the input and stores it directly without validating the `ProducedBlocks` values. [2](#0-1) 

The `NextRoundInput` is converted to a `Round` object via the `ToRound()` method, which preserves all `ProducedBlocks` values from the input without validation. [3](#0-2) 

The validation system for `NextRound` only adds `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`, which check structural properties like round number incrementation and mining order correctness. [4](#0-3) 

The `RoundTerminateValidationProvider` only validates that the round number increments by 1 and that InValues are null. [5](#0-4) 

Critically, there is NO validation that reconstructs the expected `ProducedBlocks` values from the current round state and compares them against the submitted input.

While honest nodes generate next round information by copying `ProducedBlocks` from the current state [6](#0-5)  and [7](#0-6) , the contract does not enforce this invariant during validation. A malicious miner can modify their node to inflate these values before submitting the `NextRound` transaction.

## Impact Explanation

The inflated `ProducedBlocks` values directly impact mining reward calculations. During term changes, the `DonateMiningReward` method calculates total rewards by summing all miners' `ProducedBlocks` values. [8](#0-7) 

The `GetMinedBlocks()` method sums all `ProducedBlocks` values across all miners. [9](#0-8) 

An attacker inflating `ProducedBlocks` values (e.g., doubling all counts from [10, 15, 12] to [20, 30, 24]) would double the mining rewards donated to Treasury (from 37 to 74 blocks worth), causing significant token supply inflation over multiple terms.

Additionally, these inflated values are sent to the Election contract for candidate statistics via `UpdateCurrentMinerInformationToElectionContract`. [10](#0-9) 

The Election contract adds these values to each candidate's cumulative `ProducedBlocks` count. [11](#0-10) 

This corrupts governance metrics and impacts future reward distributions based on production history.

## Likelihood Explanation

**Attacker Capabilities:** Any miner who produces a block triggering `NextRound` behavior. This occurs naturally at the end of each round when the extra block producer mines.

**Attack Complexity:** Moderate. The attacker must:
1. Run a modified node that alters the consensus extra data generation logic
2. Inflate `ProducedBlocks` values in the generated `NextRoundInput`
3. Produce a block at the appropriate time slot to trigger `NextRound`

**Feasibility:** High. Miners regularly produce `NextRound` blocks as part of normal consensus operation. The validation system checks only structural properties (round number incrementation, InValue nullity, mining order) but does NOT reconstruct and compare the expected `ProducedBlocks` values from current state.

**Detection:** Difficult. The manipulation occurs within consensus data that legitimately varies between rounds. Without explicit validation comparing submitted values against state-derived expectations, other nodes cannot detect the inflation during block validation.

The `NextRound` entry point accepts the input and processes it. [12](#0-11) 

## Recommendation

Add a validation provider for `NextRound` behavior that:
1. Reconstructs the expected next round information from current state using the same logic as honest nodes
2. Compares the submitted `ProducedBlocks` values against the expected values
3. Rejects the block if any `ProducedBlocks` value doesn't match

Specifically, create a `ProducedBlocksValidationProvider` that:
- Loads the current round from state
- Iterates through each miner in the submitted next round
- Verifies their `ProducedBlocks` value matches the current round's value for that miner
- Accounts for the extra block producer adding +1 to their count

Add this provider to the validation pipeline in `ValidateBeforeExecution` for `NextRound` behavior, similar to how `UpdateValueValidationProvider` is added for `UpdateValue` behavior.

## Proof of Concept

A proof of concept would require:
1. Setting up a test AElf node environment with multiple miners
2. Modifying one miner's node software to inflate `ProducedBlocks` values in `GetConsensusExtraDataForNextRound`
3. Having that miner produce the extra block that triggers `NextRound`
4. Observing that the inflated values pass validation and are stored in state
5. Waiting for term change and observing inflated mining rewards in `DonateMiningReward`
6. Verifying the inflated values were also sent to the Election contract

The test would demonstrate that without validation of `ProducedBlocks` correctness in `NextRound` transactions, a malicious miner can arbitrarily inflate reward calculations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L250-251)
```csharp
        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-56)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-121)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-115)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```
