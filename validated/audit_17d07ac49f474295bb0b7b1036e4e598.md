# Audit Report

## Title
TokenHolder Scheme Configuration Overwrite Allows Lock Term Manipulation

## Summary
The `CreateScheme` function in the TokenHolder contract lacks duplicate prevention checks, allowing a scheme manager to overwrite the stored scheme configuration (`Symbol` and `MinimumLockMinutes`). This enables retroactive changes to lock terms after users have locked tokens, breaking withdrawal functionality and arbitrarily extending lock periods beyond the original agreement.

## Finding Description

The `CreateScheme` function directly overwrites the scheme configuration stored at `State.TokenHolderProfitSchemes[Context.Sender]` without any validation to prevent multiple invocations. [1](#0-0) 

Each invocation creates a new Profit scheme with a unique scheme ID, as the Profit contract generates scheme IDs based on the manager's existing scheme count. [2](#0-1)  The Profit contract does assert that each scheme ID must be unique, [3](#0-2)  but this only prevents duplicate IDs, not multiple schemes per manager.

When users register for profits, they lock tokens using the current scheme's `Symbol` value retrieved from state. [4](#0-3)  The lock operation creates a virtual address based on the contract address, user address, and lock ID, then transfers the specified token symbol to that virtual address. [5](#0-4) 

During withdrawal, the scheme is retrieved fresh from state, which may now contain different values if the manager called `CreateScheme` again. [6](#0-5)  The withdrawal process queries `GetLockedAmount` using the retrieved scheme's `Symbol`. [7](#0-6)  

The `GetLockedAmount` method returns the balance of the specified symbol at the lock's virtual address. [8](#0-7)  If the symbol changes from "ELF" to "APP", the query returns 0 since only "ELF" was locked at that virtual address. The subsequent unlock operation attempts to unlock 0 tokens, leaving the user's actual tokens permanently locked.

**Root Cause**: Missing existence check before scheme creation combined with symbol-specific lock/unlock semantics.

**Why Existing Protections Fail**: While `RegisterForProfits` prevents duplicate user registration [9](#0-8) , and the `UpdateTokenHolderProfitScheme` helper updates the SchemeId by selecting the first scheme, [10](#0-9)  it does not update or validate the Symbol or MinimumLockMinutes fields, allowing the overwritten values to persist.

## Impact Explanation

**Direct Fund Impact**: Users' locked tokens become permanently inaccessible when the symbol changes. If `Symbol` changes from "ELF" to "APP", `GetLockedAmount` queries for "APP" tokens at the virtual address but returns 0 since "ELF" was actually locked. The unlock operation then processes 0 tokens, leaving the user's ELF permanently inaccessible.

**Lock Period Manipulation**: If `MinimumLockMinutes` changes from 100 to 1,000,000, the time validation at withdrawal will fail. [11](#0-10)  Users expecting a ~1.6 hour lock face a nearly 2-year lock period with no alternative recovery mechanism.

**Affected Parties**: All users who registered for profits under the scheme before the manager's configuration change. TokenHolder schemes are designed for DApp profit-sharing scenarios where multiple users stake tokens for dividend distribution.

**Severity Justification**: HIGH - This breaks the fundamental lock/unlock invariant. Users lose access to their funds based on a unilateral change by the scheme manager, with no governance controls, time-locks, or recovery mechanisms.

## Likelihood Explanation

**Attacker Capabilities**: The scheme manager who legitimately created the scheme is the attacker. No additional privileges or vulnerability chaining is required beyond the manager's normal operational role.

**Attack Complexity**: Trivial - the manager simply calls `CreateScheme` again with different parameters. The function is public with no access control beyond standard transaction authentication.

**Feasibility Conditions**: 
- Manager must have created an initial scheme (normal operation)
- Users must have locked tokens via `RegisterForProfits` (normal operation)
- No additional preconditions or complex state requirements

**Detection/Operational Constraints**: No on-chain events distinguish a malicious scheme re-creation from legitimate operations. Users cannot detect the configuration change until they attempt withdrawal. No governance approval or time-lock mechanisms protect against configuration changes.

**Probability**: HIGH - The attack is economically rational for malicious managers in rug-pull scenarios. Zero marginal cost to execute beyond standard transaction fees.

## Recommendation

Add an existence check in the `CreateScheme` function to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists. Cannot overwrite existing scheme.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, implement a separate `UpdateScheme` function with proper validation to ensure existing locks are not affected, or require governance approval for scheme modifications.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwrite_LocksUserFunds_Test()
{
    var lockAmount = 1000L;
    var nativeTokenSymbol = "ELF";
    
    // Manager creates initial scheme with ELF and 0 minute lock
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = nativeTokenSymbol,
        MinimumLockMinutes = 0
    });
    
    // User registers and locks ELF tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });
    
    var balanceBeforeLock = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = nativeTokenSymbol,
        Owner = Starter
    })).Balance;
    
    // Manager overwrites scheme with different symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "APP", // Changed from ELF to APP
        MinimumLockMinutes = 0
    });
    
    // User attempts to withdraw - this will unlock 0 tokens
    await TokenHolderContractStub.Withdraw.SendAsync(Starter);
    
    var balanceAfterWithdraw = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = nativeTokenSymbol,
        Owner = Starter
    })).Balance;
    
    // Balance should have increased by lockAmount, but doesn't due to symbol mismatch
    balanceAfterWithdraw.ShouldBe(balanceBeforeLock); // Still locked!
    // Expected: balanceBeforeLock + lockAmount
    // Actual: balanceBeforeLock (tokens remain locked)
}
```

## Notes

This vulnerability represents a critical design flaw in the TokenHolder contract's state management. The attack leverages the contract's lack of immutability guarantees for scheme configurations that users have already committed funds to. The symbol-specific nature of the MultiToken lock/unlock mechanism amplifies the impact, as querying for a different symbol returns zero balance even when tokens are locked under the original symbol.

The helper function `UpdateTokenHolderProfitScheme` updates only the `SchemeId` and `Period` fields from the Profit contract but leaves `Symbol` and `MinimumLockMinutes` untouched in the TokenHolder state, creating a mismatch between the scheme configuration users locked under and the configuration used during withdrawal.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L151-151)
```csharp
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-165)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-213)
```csharp
        var scheme = GetValidScheme(input);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-71)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```
