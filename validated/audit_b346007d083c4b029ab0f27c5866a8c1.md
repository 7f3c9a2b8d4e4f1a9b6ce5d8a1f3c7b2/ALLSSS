# Audit Report

## Title
Double-Counting Vulnerability in RemoveBeneficiary Allows Artificial Deflation of TotalShares

## Summary
The `RemoveBeneficiary` function in the Profit contract contains a critical logic flaw that allows the same profit detail to be processed multiple times when called with the same `ProfitDetailId`. This causes shares to be subtracted from `TotalShares` repeatedly, violating the invariant that each beneficiary's shares should only be counted once during removal, leading to artificial deflation of `TotalShares` and inflated profit distributions to remaining beneficiaries.

## Finding Description

The vulnerability exists in the `RemoveProfitDetails` helper method called by `RemoveBeneficiary`. The primary protection against double-counting is implemented through filtering profit details using the `!d.IsWeightRemoved` condition to exclude already-processed details. [1](#0-0) 

However, subsequent logic explicitly bypasses this protection by adding a profit detail with a specific `profitDetailId` to `detailsCanBeRemoved` **without checking** if `IsWeightRemoved` is already set to true: [2](#0-1) 

The exploit sequence works as follows:

**First Call**: When `RemoveBeneficiary` is called with a `profitDetailId`:
1. The detail is added to `detailsCanBeRemoved`
2. `IsWeightRemoved = true` is set at line 345
3. If the detail's `LastProfitPeriod < CurrentPeriod`, it remains in persistent state rather than being removed: [3](#0-2) 

4. The detail's shares are added to `removedDetails`: [4](#0-3) 

5. State is saved with `IsWeightRemoved = true` at line 378
6. `TotalShares` is decremented: [5](#0-4) 

**Second Call**: When `RemoveBeneficiary` is called again with the SAME `profitDetailId`:
1. Lines 321-324 filter out the detail because `IsWeightRemoved = true`
2. Lines 333-338 check if the detail is NOT in `detailsCanBeRemoved` (condition passes because it was filtered out)
3. The detail is added to `detailsCanBeRemoved` AGAIN without checking `IsWeightRemoved`
4. The detail's shares are added to `removedDetails` AGAIN
5. `TotalShares` is decremented AGAIN

The `TryAdd()` method correctly accumulates shares within a single invocation, but does not prevent the vulnerability across multiple `RemoveBeneficiary` calls: [6](#0-5) 

## Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

When `TotalShares` is artificially deflated through repeated removal of the same profit detail, the profit distribution calculation becomes incorrect. The `SafeCalculateProfits` method uses the formula `(beneficiary_shares / TotalShares) * totalAmount`, causing remaining beneficiaries to receive larger profit percentages than entitled.

**Quantified Example:**
- Initial `TotalShares`: 10,000
- Beneficiary A has 1,000 shares to be removed
- After legitimate removal: `TotalShares` = 9,000 (correct)
- After malicious second removal: `TotalShares` = 8,000 (incorrect, 11.1% deviation)
- Remaining beneficiaries receive 12.5% more profit than they should (9000/8000 = 1.125x)

**Affected Parties:**
- Legitimate beneficiaries who receive inflated amounts at the expense of protocol integrity
- The scheme manager who may be held responsible for distribution errors
- The integrity of the entire profit distribution scheme
- Any sub-schemes relying on accurate total share calculations

This breaks the critical economic invariant that `TotalShares` must equal the sum of all active beneficiary shares.

## Likelihood Explanation

**Attacker Capabilities:**

The attacker must be either the scheme manager or control the TokenHolder contract, as enforced by the authorization check: [7](#0-6) 

While this requires privileged access, scheme managers are user-created roles, not trusted system entities. A malicious or compromised scheme manager can exploit this vulnerability.

**Attack Complexity:**
1. Attacker creates or controls a profit scheme
2. Adds beneficiaries with specific `ProfitDetailId` values
3. Calls `RemoveBeneficiary` with a `ProfitDetailId` where the detail's `LastProfitPeriod < CurrentPeriod`
4. Calls `RemoveBeneficiary` again with the same `ProfitDetailId`
5. Shares are subtracted from `TotalShares` twice

**Feasibility Conditions:**
- The profit detail must remain in the list after first removal (occurs when `LastProfitPeriod < CurrentPeriod`, which is the common case for details with unclaimed profits)
- No additional validation prevents duplicate removal requests
- The exploit is deterministic and requires only 2 transactions

**Detection/Operational Constraints:**
- No on-chain events distinguish legitimate from duplicate removals
- Off-chain monitoring would need to track all `RemoveBeneficiary` calls and their `ProfitDetailId` parameters
- The error could also occur **accidentally** if a manager mistakenly submits the same removal transaction twice

**Probability:** MEDIUM-HIGH for compromised/malicious managers; LOW-MEDIUM for accidental occurrence

## Recommendation

Add an `IsWeightRemoved` check to the condition at lines 334-335 before adding the detail to `detailsCanBeRemoved`:

```csharp
// remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    var detailToAdd = profitDetails.Details.Single(d => d.Id == profitDetailId);
    // FIX: Add check for IsWeightRemoved
    if (!detailToAdd.IsWeightRemoved)
    {
        detailsCanBeRemoved.Add(detailToAdd);
    }
}
```

This ensures that details already marked as removed cannot be processed again, maintaining the integrity of the `TotalShares` accounting.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_RemoveBeneficiary_DoubleRemoval_Test()
{
    var creator = Creators[0];
    var receiverAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);
    var profitDetailId = HashHelper.ComputeFrom("TestProfitDetail");
    
    // Create scheme
    var schemeId = await CreateSchemeAsync();
    
    // Add beneficiary with profitDetailId and 1000 shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = receiverAddress,
            Shares = 1000
        },
        SchemeId = schemeId,
        EndPeriod = 10,
        ProfitDetailId = profitDetailId
    });
    
    // Verify initial TotalShares
    var schemeInitial = await creator.GetScheme.CallAsync(schemeId);
    schemeInitial.TotalShares.ShouldBe(1000);
    
    // First removal - should work correctly
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        Beneficiary = receiverAddress,
        SchemeId = schemeId,
        ProfitDetailId = profitDetailId
    });
    
    var schemeAfterFirst = await creator.GetScheme.CallAsync(schemeId);
    schemeAfterFirst.TotalShares.ShouldBe(0); // Correctly decremented by 1000
    
    // Second removal with same profitDetailId - should NOT decrement again
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        Beneficiary = receiverAddress,
        SchemeId = schemeId,
        ProfitDetailId = profitDetailId
    });
    
    var schemeAfterSecond = await creator.GetScheme.CallAsync(schemeId);
    
    // VULNERABILITY: TotalShares becomes -1000 instead of staying at 0
    schemeAfterSecond.TotalShares.ShouldBe(-1000); // This proves the vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L333-338)
```csharp
        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-356)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L358-358)
```csharp
                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```
