# Audit Report

## Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

## Summary
The `CrossChainCreate()` function in the NFT contract completely lacks cross-chain verification mechanisms required by AElf's security model. Any address can call this function to create NFT protocols for tokens existing in the local TokenContract, bypassing both mainchain-only restrictions and cryptographic merkle proof validation that are standard for all other cross-chain operations.

## Finding Description

The vulnerability exists in the `CrossChainCreate()` function which accepts only a symbol parameter and performs no verification of cross-chain authenticity. [1](#0-0) 

The function's input message only accepts a symbol string, lacking all cross-chain verification parameters: [2](#0-1) 

This contrasts with the secure implementation in MultiToken's `CrossChainCreateToken()` which properly implements cross-chain verification: [3](#0-2) 

The MultiToken contract accepts comprehensive cross-chain verification parameters including merkle paths: [4](#0-3) 

And performs cryptographic validation via the `CrossChainVerify` helper: [5](#0-4) 

Which calls the CrossChain contract's merkle proof verification: [6](#0-5) 

The NFT contract has NO such verification. Additionally, while the regular `Create()` function enforces mainchain-only creation: [7](#0-6) 

The `CrossChainCreate()` function has no such chain ID validation, allowing it to be called on any chain.

## Impact Explanation

**Critical Security Violations:**

1. **Unauthorized Protocol Creation**: Any address can create NFT protocols for any token in the local TokenContract without authorization from the token creator or proper cross-chain validation. The function has no sender checks or role requirements.

2. **Bypass Mainchain-Only Invariant**: The system enforces that NFT protocols should only be created on the AELF mainchain (as evidenced by the regular `Create()` assertion), but `CrossChainCreate()` allows this security boundary to be bypassed on sidechains.

3. **Front-Running Attacks**: Attackers can monitor pending legitimate cross-chain NFT protocol registrations and front-run them by calling `CrossChainCreate()` first. The legitimate transaction will then fail at line 79 since the protocol already exists.

4. **Cross-Chain Integrity Violation**: This completely defeats AElf's cross-chain security model which requires cryptographic merkle proof verification for all cross-chain operations. The function accepts no merkle path, transaction bytes, or parent chain height parameters needed for verification.

**Affected Parties:**
- NFT protocol creators expecting secure cross-chain registration
- Token creators whose tokens can be converted to NFT protocols without consent
- The entire sidechain NFT infrastructure's integrity

The severity is **CRITICAL** because it breaks fundamental cross-chain security guarantees that the AElf blockchain relies upon for secure multi-chain operations.

## Likelihood Explanation

**Attacker Requirements:**
- Any address can call the function - it has no authorization checks whatsoever
- Only requires ability to send a transaction (standard capability)
- Function is publicly accessible as a standard RPC method in the service definition

**Attack Complexity:**
- Extremely Low - single function call with one parameter
- Precondition: A token with the target symbol must exist in the local TokenContract (very common on sidechains where tokens are cross-chain transferred through legitimate MultiToken mechanisms)

**Feasibility:**
- Standard gas costs only
- No timing requirements
- Easily reproducible
- Difficult to prevent or detect before execution
- No rate limiting or cooldown periods

The probability is **HIGH** - the attack is trivial to execute and economically rational for griefing, front-running, or exploiting protocol assumptions about NFT protocol creation authorization.

## Recommendation

The `CrossChainCreate` function should be completely redesigned to match the secure pattern used in MultiToken's `CrossChainCreateToken`:

1. **Update Input Message**: Change `CrossChainCreateInput` to include:
   - `int32 from_chain_id` 
   - `int64 parent_chain_height`
   - `bytes transaction_bytes`
   - `MerklePath merkle_path`

2. **Add Cross-Chain Verification**: Before creating the protocol, call the `CrossChainVerify` helper method (similar to TokenContract_Helper.cs) to validate:
   - The transaction ID matches the merkle path
   - The merkle proof validates against the parent chain height
   - The transaction came from a registered cross-chain token contract

3. **Parse and Validate Transaction**: Extract the original NFT protocol creation transaction from `transaction_bytes` and validate it was executed on the mainchain with proper authorization.

4. **Maintain Mainchain-Only Invariant**: Ensure the function can only be called on sidechains after proper mainchain protocol creation has been cryptographically verified.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task CrossChainCreate_Unauthorized_Success()
{
    // Setup: Create a token in the local TokenContract
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST-0",
        TokenName = "Test Token",
        TotalSupply = 1000000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                ["aelf_nft_type"] = "Art",
                ["aelf_nft_base_uri"] = "ipfs://test/",
                ["aelf_nft_token_id_reuse"] = "false"
            }
        }
    });
    
    // Attack: Any address (AttackerAddress) can create NFT protocol
    var result = await AttackerNFTContractStub.CrossChainCreate.SendAsync(
        new CrossChainCreateInput { Symbol = "TEST-0" }
    );
    
    // Verify: Protocol was created without authorization or cross-chain verification
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = "TEST-0" }
    );
    
    protocolInfo.Symbol.ShouldBe("TEST-0");
    // Protocol created without any authorization!
    // No merkle proof verification occurred
    // Attacker successfully front-ran legitimate cross-chain registration
}
```

## Notes

The absence of any tests for `CrossChainCreate` in the NFT contract test suite strongly suggests this function was never fully implemented or validated. The function appears to be a placeholder that was named for cross-chain functionality but never received the proper verification logic that makes cross-chain operations secure in AElf.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-17)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** protobuf/token_contract.proto (L571-580)
```text
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```
