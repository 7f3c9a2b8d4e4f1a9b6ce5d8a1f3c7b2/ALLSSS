# Audit Report

## Title
Missing Extra Block Producer Validation Allows Consensus DoS via InvalidOperationException

## Summary
The AEDPoS consensus contract fails to validate that Round objects submitted via `NextRound` or `NextTerm` transactions contain at least one miner designated as the extra block producer. A malicious miner can exploit this to store a malformed Round that causes critical consensus methods to throw `InvalidOperationException`, resulting in a complete chain halt.

## Finding Description

The consensus contract accepts externally-provided Round objects without validating a critical invariant: the presence of at least one miner with `IsExtraBlockProducer == true`.

**Vulnerable Code Locations:**

1. **GetNextMinerPubkey()** - The fallback logic uses `First(m => m.IsExtraBlockProducer)`, which throws `InvalidOperationException` if no miner has this flag set. [1](#0-0) 

2. **IsCurrentMiner()** - Unconditionally calls `Single(m => m.Value.IsExtraBlockProducer)` at line 170, which throws `InvalidOperationException` if zero or multiple miners have this flag set. This occurs even when checking normal time slots, causing ALL mining permission validations to fail. [2](#0-1) 

3. **GetExtraBlockProducerInformation()** - Called by `ArrangeAbnormalMiningTime`, uses `First(bp => bp.Value.IsExtraBlockProducer)`, which throws `InvalidOperationException` if no extra block producer exists. [3](#0-2) 

**Missing Validation:**

The entry point `NextRound` accepts user-provided input and processes it without validating the extra block producer invariant. [4](#0-3) 

The processing flow converts input to Round via `ToRound()` and stores it: [5](#0-4) 

The `ToRound()` conversion method simply copies fields without validation: [6](#0-5) 

The `RoundTerminateValidationProvider` only validates round numbers and `InValue` nullness, not the presence of an extra block producer: [7](#0-6) 

**Attack Path:**

1. Malicious miner crafts a `NextRoundInput` with valid round/term numbers and miner information, but sets all miners' `IsExtraBlockProducer` to `false`
2. Submits transaction via public `NextRound` method
3. `PreCheck()` validates only that sender is in current or previous miner list - passes: [8](#0-7) 
4. All validation providers check round numbers, but not extra block producer - passes
5. Malformed Round is stored via `AddRoundInformation()`: [9](#0-8) 
6. Subsequent calls to consensus methods throw `InvalidOperationException`, halting the chain

**Contrast with Normal Behavior:**

When rounds are generated legitimately via `GenerateNextRoundInformation()`, the code always sets exactly one miner as the extra block producer, demonstrating this is a required invariant: [10](#0-9) 

## Impact Explanation

**HIGH Severity - Complete Consensus Halt**

Once a malformed Round is stored, critical consensus operations fail with exceptions:

1. **Mining Permission Validation Failure**: `IsCurrentMiner()` unconditionally executes line 170 which calls `.Single(m => m.Value.IsExtraBlockProducer)` before any time slot checks. This causes ALL calls to `IsCurrentMiner` to throw, including from:
   - TokenContract.ClaimTransactionFees: [11](#0-10) 
   - Other system contracts requiring miner validation

2. **Consensus Command Generation Failure**: `TerminateRoundCommandStrategy` calls `ArrangeExtraBlockMiningTime` which calls `ArrangeAbnormalMiningTime`: [12](#0-11) 
   
   This internally calls `GetExtraBlockProducerInformation()` which throws, preventing round termination: [13](#0-12) 

3. **Block Propagation Failure**: `GetNextMinerPubkey` throws when attempting to determine the next miner after normal time slots pass.

All miners are blocked from validating their permission to mine, cannot receive consensus commands to terminate rounds, and the chain cannot progress past the malformed round. Recovery requires manual state intervention.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**

**Attacker Requirements:**
- Must be a current or previous round miner (verified by `PreCheck`)
- No special privileges beyond being an active miner
- Cost is only transaction fees

**Attack Complexity:** LOW
- Craft a `NextRoundInput` with correct round/term numbers
- Set all miners' `IsExtraBlockProducer` to `false`
- Submit via public `NextRound` transaction
- No complex timing or coordination required

**Feasibility:** 
- Any malicious miner can execute it
- No existing validation detects the malformed input before storage
- Single transaction causes permanent chain halt
- Attack surface exists on every round/term transition

## Recommendation

Add validation in `ProcessNextRound` and `ProcessNextTerm` to verify that exactly one miner has `IsExtraBlockProducer == true` before storing the Round:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Validate extra block producer invariant
    var extraBlockProducers = nextRound.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    Assert(extraBlockProducers == 1, 
        "Round must have exactly one extra block producer.");
    
    // Rest of the method...
}
```

Alternatively, add the validation to `RoundTerminateValidationProvider`: [7](#0-6) 

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextRound_WithNoExtraBlockProducer_CausesConsensusHalt()
{
    // Setup: Initialize consensus with normal first round
    await InitializeConsensusAsync();
    
    // Attack: Craft malicious NextRoundInput with no extra block producer
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    // Copy miners but set all IsExtraBlockProducer to false
    foreach (var miner in currentRound.RealTimeMinersInformation)
    {
        maliciousNextRound.RealTimeMinersInformation[miner.Key] = new MinerInRound
        {
            Pubkey = miner.Value.Pubkey,
            Order = miner.Value.Order,
            ExpectedMiningTime = BlockTimeProvider.GetBlockTime().AddSeconds(10),
            IsExtraBlockProducer = false // Malicious: no extra block producer
        };
    }
    
    // Submit malicious round - should succeed (no validation)
    await ConsensusStub.NextRound.SendAsync(maliciousNextRound);
    
    // Verify: IsCurrentMiner now throws InvalidOperationException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusStub.IsCurrentMiner.CallAsync(SampleAddress.AddressList[0]);
    });
    
    Assert.Contains("InvalidOperationException", exception.Message);
    
    // Chain is now halted - no miner can validate permission to mine
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L96-98)
```csharp
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-177)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-66)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```
