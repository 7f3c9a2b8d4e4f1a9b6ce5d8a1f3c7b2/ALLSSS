# Audit Report

## Title
Dictionary Access Without Key Validation in IsCurrentMiner During Miner List Changes Causes KeyNotFoundException

## Summary
The `IsCurrentMiner` private method in the AEDPoS consensus contract contains a conditional safety check that is bypassed when `IsMinerListJustChanged = true`, leading to unguarded dictionary accesses that throw `KeyNotFoundException` when removed miners attempt to call authorization-protected functions during term transitions or miner replacements.

## Finding Description

The vulnerability exists in the private `IsCurrentMiner(string pubkey)` method where a safety check only validates dictionary key existence when the miner list has NOT changed: [1](#0-0) 

When `IsMinerListJustChanged` is true, this check is completely bypassed, yet the code proceeds to directly access the `RealTimeMinersInformation` dictionary without validation: [2](#0-1) 

The vulnerability is triggered when `ConvertAddressToPubkey` returns a pubkey that exists in the previous round but not in the current round, because it searches BOTH rounds: [3](#0-2) 

The `IsMinerListJustChanged` flag is set to true when generating the first round of a new term: [4](#0-3) 

And when replacing evil miners within a term: [5](#0-4) 

Additional vulnerable dictionary accesses exist when calling `ArrangeAbnormalMiningTime`: [6](#0-5) 

And when using `.Single()` which throws if the key doesn't exist: [7](#0-6) 

The public entry points that internally invoke `IsCurrentMiner` include:

**ClaimTransactionFees:** [8](#0-7) [9](#0-8) 

**DonateResourceToken:** [10](#0-9) 

**ProposeCrossChainIndexing:** [11](#0-10) [12](#0-11) [13](#0-12) 

**ReleaseCrossChainIndexingProposal:** [14](#0-13) 

## Impact Explanation

**Operational Impact - Critical DoS:**
- Transaction failures via `KeyNotFoundException` during term transitions and miner replacements
- Affects critical system operations: `ClaimTransactionFees`, `DonateResourceToken`, `ProposeCrossChainIndexing`, `ReleaseCrossChainIndexingProposal`
- Removed miners cannot complete legitimate operations such as claiming accumulated transaction fees from their last blocks before removal
- System instability during consensus transitions, which are regularly occurring events in AEDPoS

**Affected Parties:**
- Removed/replaced miners who need to claim fees or perform cross-chain operations
- The broader network during term transitions when multiple miners may be replaced simultaneously
- Cross-chain indexing operations become unavailable if executed by recently removed miners

This is a Critical severity issue because it causes guaranteed transaction failures during normal protocol operation, affects multiple core system functions, and creates operational disruption without requiring any malicious intent.

## Likelihood Explanation

**Reachable Entry Point:**
Public methods are callable by any miner address and internally invoke `IsCurrentMiner`.

**Feasible Preconditions:**
- Term changes occur regularly in AEDPoS (every `PeriodSeconds` configured in the protocol)
- Miner replacements occur when miners miss too many time slots (evil node detection)
- No attacker capabilities required - happens during normal protocol operation

**Execution Practicality:**
1. Term transition or miner replacement occurs (natural protocol behavior) → `IsMinerListJustChanged = true`
2. Miner is removed from current round but was in previous round
3. As a removed miner, call `ClaimTransactionFees()` to claim legitimately earned fees
4. `IsCurrentMiner` receives pubkey from previous round via `ConvertAddressToPubkey`
5. Safety check is bypassed because `IsMinerListJustChanged = true`
6. Dictionary access throws `KeyNotFoundException` → Transaction fails

**Probability:**
High probability during every term transition or miner replacement event, affecting any removed miner who attempts to perform protected operations. Given that term transitions are regular events and miners legitimately want to claim earned fees, this vulnerability will be triggered frequently.

## Recommendation

Add key validation before all dictionary accesses in `IsCurrentMiner`, regardless of the `IsMinerListJustChanged` flag status:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;

    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

    // Always validate key existence before dictionary access
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;

    // Continue with existing logic...
}
```

Additionally, in `ArrangeAbnormalMiningTime`, validate the key before access:

```csharp
public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
    bool mustExceededCurrentRound = false)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey))
        return currentBlockTime; // Or appropriate default behavior
    
    var miningInterval = GetMiningInterval();
    var minerInRound = RealTimeMinersInformation[pubkey];
    // Continue with existing logic...
}
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Initialize a consensus round with multiple miners
2. Generate a new term with a changed miner list (`IsMinerListJustChanged = true`)
3. Have a removed miner (present in previous round, absent in current round) call `ClaimTransactionFees()`
4. Observe the `KeyNotFoundException` thrown at the dictionary access

The transaction will fail with an unhandled exception, preventing the removed miner from claiming legitimately earned fees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L127-134)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-158)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L204-205)
```csharp
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L341-341)
```csharp
                isMinerListChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L24-24)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L905-905)
```csharp
        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-915)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-286)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-297)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
