# Audit Report

## Title
Assembled NFTs Can Be Burned Directly, Causing Permanent Loss of Locked Fungible Tokens

## Summary
The `Burn` method in the NFT contract fails to verify whether an NFT contains assembled assets before destruction. When a minter burns an assembled NFT directly instead of using `Disassemble`, fungible tokens locked during assembly remain permanently trapped in the contract with no recovery mechanism, resulting in irreversible fund loss.

## Finding Description

The NFT contract implements an assembly mechanism where users lock fungible tokens (FTs) and other NFTs into a newly minted assembled NFT. During assembly, FTs are transferred from the user to the NFT contract address using `State.TokenContract.TransferFrom`, and the locked asset mapping is stored in `State.AssembledFtsMap[tokenHash]`. [1](#0-0) [2](#0-1) 

The intended recovery path is the `Disassemble` method, which first burns the assembled NFT, retrieves the locked assets from state mappings, transfers them back to the receiver, and removes the state entries. [3](#0-2) 

However, the `Burn` method can be called directly by any minter who owns the assembled NFT. [4](#0-3) 

**Root Cause:** The `Burn` method only verifies that the protocol is burnable, the caller is a minter, and the caller has sufficient balance. [5](#0-4)  It completely lacks any check to determine if the NFT being burned has entries in `AssembledFtsMap` or `AssembledNftsMap`. [6](#0-5) 

**Exploit Sequence:**
1. User calls `Assemble` with 1,000 ELF tokens, which are transferred to the NFT contract and stored in `AssembledFtsMap[tokenHash]`
2. The assembled NFT has balance = 1
3. Minter (who owns the NFT) calls `Burn` directly with amount = 1
4. `Burn` passes all checks (burnable, minter, balance ≥ 1) and executes successfully
5. Balance becomes 0, NFT is marked as burned [7](#0-6) 
6. **Critical**: `AssembledFtsMap[tokenHash]` entry remains in state, but is now orphaned
7. The 1,000 ELF tokens remain in the NFT contract address with no owner

**Recovery Impossibility:** After direct burn, `Disassemble` cannot recover the locked assets because it calls `Burn` first with amount=1. [8](#0-7)  Since the balance is already 0 from the direct burn, the assertion checking `balance >= amount` fails. [9](#0-8) 

Code analysis confirms that `AssembledFtsMap` is only accessed in three locations: setting during `Assemble`, reading during `Disassemble`, and removing during `Disassemble`. No admin or privileged method exists to rescue orphaned assembled assets.

## Impact Explanation

**Direct Asset Loss:** All fungible tokens locked in the assembled NFT become permanently trapped in the NFT contract address with zero possibility of recovery. For example, if 1,000 ELF tokens were locked during assembly, they become permanently inaccessible to all parties.

**Affected Parties:**
- NFT owners who assembled valuable FTs into NFTs lose their locked assets completely
- Any subsequent owner of an assembled NFT who receives it via transfer
- Protocol economic integrity is compromised as locked assets are removed from circulating supply permanently without any corresponding burn event in the token contract

**Severity Justification: HIGH** because:
1. Results in permanent, unrecoverable loss of user funds (not temporary DoS)
2. Can affect any assembled NFT with arbitrary value of locked FTs
3. Requires only normal operational permissions (minter role, not admin/governance)
4. No admin recovery mechanism exists anywhere in the contract
5. Violates the fundamental security guarantee that assembled assets can always be recovered through disassembly
6. Breaks protocol invariant: locked assets should be retrievable

## Likelihood Explanation

**Attacker Capabilities:** The vulnerability can be triggered by any minter who owns an assembled NFT. Minters are common operational roles in NFT ecosystems—they are explicitly added via the `AddMinters` method and often include the creator/assembler themselves. [10](#0-9) 

**Attack Complexity:** Extremely simple—requires only a single transaction calling the public `Burn` method with the symbol and token ID of the assembled NFT. No complex state manipulation or timing requirements.

**Feasibility Conditions:**
1. Protocol must be burnable (configured via `IsBurnable` flag during protocol creation)
2. Caller must be in the minter list for that protocol
3. Caller must own the assembled NFT (balance ≥ 1)

These conditions are commonly satisfied in normal operations. Many NFT protocols are intentionally designed as burnable to allow cleanup, and assemblers are typically minters themselves or can easily be added to the minter list by the protocol creator.

**Detection & Occurrence:** The vulnerability could occur accidentally (user mistakenly calls `Burn` instead of `Disassemble`) or intentionally. Once executed, the locked FTs cannot be recovered through any contract mechanism. The contract provides no warning or protection.

**Probability: MEDIUM to HIGH**—While this may not be a deliberate attack vector initially, the ease of accidentally calling the wrong method, combined with no validation or protection mechanism in the contract, makes this a realistic scenario in production use. Human error is inevitable at scale.

## Recommendation

Add a check in the `Burn` method to prevent burning assembled NFTs that contain locked assets:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add this check before burning
    Assert(State.AssembledFtsMap[tokenHash] == null && State.AssembledNftsMap[tokenHash] == null,
        "Cannot burn assembled NFT directly. Use Disassemble method to unlock assets first.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
    Assert(nftProtocolInfo.IsBurnable,
        $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
    // ... rest of existing code
}
```

Alternatively, implement an admin recovery function that can transfer orphaned assets out of the contract, though prevention is the preferred solution.

## Proof of Concept

```csharp
[Fact]
public async Task AssembledNFT_DirectBurn_CausesLockedFundsLoss()
{
    // Setup: Create NFT protocol and mint an NFT
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    var (_, tokenHash) = await MintTest();
    
    // Setup: Approve NFT contract to spend ELF tokens
    await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    // Get initial ELF balance
    var initialBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "ELF"
    })).Balance;
    
    // Step 1: Assemble NFT with 1000 ELF locked
    var assembleResult = await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledFts = new AssembledFts
        {
            Value = { ["ELF"] = 1000 }
        }
    });
    
    var assembledTokenHash = assembleResult.Output;
    
    // Verify ELF was transferred to NFT contract
    var balanceAfterAssemble = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "ELF"
    })).Balance;
    balanceAfterAssemble.ShouldBe(initialBalance - 1000);
    
    // Verify NFT contract holds the 1000 ELF
    var nftContractBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = NFTContractAddress,
        Symbol = "ELF"
    })).Balance;
    nftContractBalance.ShouldBeGreaterThanOrEqualTo(1000);
    
    // Step 2: VULNERABILITY - Burn the assembled NFT directly instead of Disassemble
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = GetTokenIdFromHash(assembledTokenHash),
        Amount = 1
    });
    
    // Step 3: Verify the vulnerability - Try to Disassemble (should fail)
    var disassembleException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.Disassemble.SendAsync(new DisassembleInput
        {
            Symbol = symbol,
            TokenId = GetTokenIdFromHash(assembledTokenHash)
        });
    });
    
    // Disassemble fails because balance is 0
    disassembleException.Message.ShouldContain("No permission");
    
    // Step 4: Verify PERMANENT LOSS - The 1000 ELF remains locked in NFT contract forever
    var finalUserBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "ELF"
    })).Balance;
    
    var finalContractBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = NFTContractAddress,
        Symbol = "ELF"
    })).Balance;
    
    // User never gets the 1000 ELF back
    finalUserBalance.ShouldBe(initialBalance - 1000);
    
    // NFT contract still holds the 1000 ELF with no way to retrieve it
    finalContractBalance.ShouldBeGreaterThanOrEqualTo(1000);
    
    // VULNERABILITY CONFIRMED: 1000 ELF permanently locked with no recovery mechanism
}
```

**Notes**

This vulnerability represents a critical flaw in the NFT contract's assembled asset management system. The core issue is that the `Burn` method operates independently of the assembly/disassembly mechanism, creating a state inconsistency where assets can be locked but the locking NFT destroyed. The lack of any recovery mechanism or admin intervention capability makes this a permanent fund loss scenario. The fix is straightforward—add an assertion to prevent burning assembled NFTs directly—and should be implemented immediately to protect user funds.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L155-161)
```csharp
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L178-178)
```csharp
        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```
