# Audit Report

## Title
Missing Validation for Empty Public Keys in Miner List Causes Consensus DoS

## Summary
The `MinerList.GenerateFirstRoundOfNewTerm` method accesses the first byte of miner public keys without validating that ByteStrings are non-empty. When an empty public key is present, the code throws an `IndexOutOfRangeException`, causing complete consensus failure. This can be exploited through malicious genesis configuration or by calling `ReplaceCandidatePubkey` with an empty string.

## Finding Description

The root cause lies in the public key sorting logic that accesses the first byte without validation. [1](#0-0) 

**Attack Vector 1: Genesis Configuration Bypass**

The genesis configuration validation only checks the first element of `InitialMinerList`, allowing empty strings at subsequent positions to bypass validation. [2](#0-1) 

Empty strings are converted to empty ByteStrings through the hex conversion utility, which returns a zero-length byte array for empty input. [3](#0-2)  The conversion is wrapped by ByteStringHelper. [4](#0-3) 

During initialization, these empty strings are passed through without length validation when converted to ByteStrings. [5](#0-4) 

**Attack Vector 2: Candidate Replacement**

The `ReplaceCandidatePubkey` method validates candidate status, ban status, permissions, and duplicate candidates, but critically does NOT validate that the new public key is non-empty. [6](#0-5) 

The method proceeds to call `PerformReplacement`, which notifies the consensus contract. [7](#0-6) 

The consensus contract's `RecordCandidateReplacement` method updates the current round information without validating the new pubkey length. [8](#0-7) 

**Propagation Through Term Transitions**

During term transitions when no new election victories exist, the system uses existing miners from the current round and converts their string public keys to ByteStrings. [9](#0-8) 

This conversion of an empty string produces an empty ByteString, which then triggers the exception when `GenerateFirstRoundOfNewTerm` attempts to access the first byte.

## Impact Explanation

This vulnerability causes complete consensus failure with catastrophic impact:

1. **Chain Initialization Failure**: If exploited during genesis through malicious configuration at positions [1], [2], etc., the chain cannot complete initialization
2. **Runtime Consensus DoS**: If exploited through candidate replacement while a candidate is an active miner, the chain cannot transition to new terms
3. **No Automatic Recovery**: The `IndexOutOfRangeException` prevents round generation, requiring emergency manual intervention
4. **Network-Wide Impact**: All validators cannot produce blocks, all users cannot submit transactions, and the entire network halts

The severity is **HIGH** as it represents complete operational failure of the consensus mechanism.

## Likelihood Explanation

**Genesis Attack Path (MEDIUM likelihood):**
- Requires: Access to chain configuration before deployment
- Complexity: LOW - simply add empty string at position [1] or higher in `InitialMinerList`
- Detection: None - validation only checks first element

**Runtime Attack Path (MEDIUM likelihood):**
- Requires: Candidate admin role for an active miner
- Complexity: LOW - call `ReplaceCandidatePubkey` with empty `new_pubkey` parameter
- Scenario: Malicious insider, compromised admin account, or accidental misconfiguration
- Detection: None - no validation prevents empty pubkey

The overall probability is **MEDIUM** because while genesis configuration is typically controlled, the runtime attack path is feasible through legitimate but malicious or compromised admin accounts.

## Recommendation

Add validation to prevent empty public keys at multiple layers:

1. **Genesis Configuration**: Validate all elements in `InitialMinerList`, not just the first:
```csharp
if (option.InitialMinerList == null || option.InitialMinerList.Count == 0 ||
    option.InitialMinerList.Any(string.IsNullOrWhiteSpace))
```

2. **ReplaceCandidatePubkey**: Add validation at the start of the method:
```csharp
Assert(!string.IsNullOrWhiteSpace(input.OldPubkey) && !string.IsNullOrWhiteSpace(input.NewPubkey),
    "Pubkey cannot be empty.");
```

3. **MinerList.GenerateFirstRoundOfNewTerm**: Add defensive check before accessing first byte:
```csharp
.ToDictionary<ByteString, string, int>(miner => miner.ToHex(), 
    miner => miner.Length > 0 ? miner[0] : throw new ArgumentException("Empty pubkey detected"))
```

## Proof of Concept

The following test demonstrates the vulnerability through the `ReplaceCandidatePubkey` attack vector:

```csharp
[Fact]
public async Task EmptyPubkey_Causes_Consensus_DoS()
{
    // Setup: Announce candidate and make them an active miner
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    var adminKeyPair = ValidationDataCenterKeyPairs.Last();
    var adminAddress = Address.FromPublicKey(adminKeyPair.PublicKey);
    
    await AnnounceElectionAsync(candidateKeyPair, adminAddress);
    
    // Wait for candidate to become active miner in current round
    await ProduceBlocks(ElectionContractStub, 1);
    
    // Attack: Replace candidate's pubkey with empty string
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, adminKeyPair);
    
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = candidateKeyPair.PublicKey.ToHex(),
        NewPubkey = "" // Empty pubkey - no validation!
    });
    
    // Trigger: Wait for term transition
    // This will call GenerateFirstRoundOfNextTerm which uses existing miners
    // and attempts to access miner[0] on the empty ByteString
    var result = await ConsensusContractStub.NextTerm.SendAsync(new NextTermInput 
    { 
        // Term transition parameters
    });
    
    // Expected: IndexOutOfRangeException crashes consensus
    // Chain cannot produce blocks, complete DoS
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("IndexOutOfRangeException");
}
```

## Notes

This is a critical consensus-level vulnerability that breaks the fundamental availability guarantee of the blockchain. The lack of validation at multiple layers (genesis configuration, election contract, and consensus contract) creates multiple attack surfaces. While genesis configuration attacks require deployment-time access, the runtime attack through `ReplaceCandidatePubkey` is particularly concerning as it can be triggered by any compromised or malicious candidate admin after the chain is live. The fix requires defense-in-depth validation at all entry points where public keys are accepted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/AEDPoSAElfModule.cs (L60-61)
```csharp
            if (option.InitialMinerList == null || option.InitialMinerList.Count == 0 ||
                string.IsNullOrWhiteSpace(option.InitialMinerList[0]))
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L12-13)
```csharp
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];
```

**File:** src/AElf.Types/Helper/ByteStringHelper.cs (L21-24)
```csharp
        public static ByteString FromHexString(string hexString)
        {
            return ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(hexString));
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-191)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-302)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L234-242)
```csharp
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```
