# Audit Report

## Title
Unvalidated MinersPreviousInValues Allows Consensus State Manipulation

## Summary
The AEDPoS consensus contract allows any miner to inject arbitrary `PreviousInValue` data for other miners through the `UpdateValue` transaction's `MinersPreviousInValues` field. These values are applied to the round state without validation, enabling manipulation of the consensus randomness chain and miner ordering for subsequent rounds.

## Finding Description

The vulnerability exists in the secret sharing mechanism of the consensus update flow when secret sharing is enabled.

**Collection Phase**: The `ExtractInformationToUpdateConsensus()` method collects all miners' `PreviousInValues` from the current round state and packages them into `UpdateValueInput.MinersPreviousInValues`. [1](#0-0) 

**Application Phase**: When the `UpdateValue` transaction executes, `PerformSecretSharing()` unconditionally applies all values from `MinersPreviousInValues` to the round state, directly overwriting each miner's `PreviousInValue` field without any validation. [2](#0-1) 

**Validation Gap**: The `UpdateValueValidationProvider` only validates the sender's own `PreviousInValue` by checking it against their previous round's `OutValue`. It retrieves the sender's public key and validates only that specific entry, never iterating through or validating the `MinersPreviousInValues` map containing other miners' values. [3](#0-2) 

**Critical Difference**: Unlike `UpdateLatestSecretPieces()` which only sets `PreviousInValue` when it's currently empty or null, [4](#0-3)  the `PerformSecretSharing()` method unconditionally overwrites existing values regardless of their state. [5](#0-4) 

**Attack Vector**: A malicious miner can modify their `UpdateValueInput` transaction parameter before signing to inject arbitrary `PreviousInValues` for other miners. Since miners control their own consensus nodes, they can intercept the transaction generation flow and manipulate the `MinersPreviousInValues` map before submitting their block.

## Impact Explanation

**Consensus Randomness Manipulation**: The `PreviousInValue` directly affects consensus ordering through the signature calculation mechanism. The signature is calculated by XORing the `previousInValue` with all miners' signatures in the round. [6](#0-5)  This signature is then used in `ApplyNormalConsensusData()` to calculate `SupposedOrderOfNextRound` via modulo arithmetic, which determines mining order for the next round. [7](#0-6) 

**State Overwrite Attack**: When `SupplyCurrentRoundInformation()` fills data for miners who didn't produce blocks, it uses the stored `PreviousInValue` from the current round state to calculate their signature. [8](#0-7)  If this value has been maliciously overwritten, it corrupts the signature calculation for absent miners.

**Secret Sharing Bypass**: The legitimate secret sharing mechanism in `RevealSharedInValues()` uses Shamir Secret Sharing to cryptographically reveal previous InValues through threshold-based decryption. [9](#0-8)  This vulnerability allows attackers to bypass this cryptographic guarantee by directly injecting fake values.

**Severity**: Medium-High. While this doesn't directly steal funds, it corrupts critical consensus invariants including randomness integrity, miner ordering fairness, and the cryptographic guarantees of the secret sharing mechanism. This can lead to consensus manipulation and unfair miner advantages.

## Likelihood Explanation

**Highly Exploitable**:
- **Entry Point**: Any active miner can trigger this through the public `UpdateValue` method during their normal block production. [10](#0-9) 
- **Attack Complexity**: Low. The attacker simply needs to modify the `UpdateValueInput.MinersPreviousInValues` map in their consensus transaction before signing it.
- **No Special Privileges**: Any miner in the current round can execute this attack. The `ProcessConsensusInformation` method only checks that the sender is in the miner list via `PreCheck()`, which any active miner satisfies. [11](#0-10) 
- **Precondition**: Only requires secret sharing to be enabled, which is a standard configuration for production networks. [12](#0-11) 

## Recommendation

Add validation for all entries in the `MinersPreviousInValues` map, similar to how the sender's own `PreviousInValue` is validated. The `PerformSecretSharing()` method should verify that each entry's hash matches the corresponding miner's `OutValue` from the previous round before applying the value.

Additionally, consider adding a conditional check similar to `UpdateLatestSecretPieces()` to only set `PreviousInValue` when it is currently empty or null, preventing overwrites of already-set values.

## Proof of Concept

A test would demonstrate:
1. Miner A generates a valid `UpdateValue` transaction
2. Before signing, Miner A modifies `MinersPreviousInValues` to inject an arbitrary hash for Miner B
3. The transaction passes validation (only Miner A's own `PreviousInValue` is checked)
4. `PerformSecretSharing()` unconditionally writes the fake value to Miner B's state
5. When Miner B doesn't produce a block, `SupplyCurrentRoundInformation()` uses the fake value
6. This corrupts Miner B's signature and affects ordering calculations

**Notes**

This vulnerability specifically affects the consensus integrity by allowing miners to manipulate the `PreviousInValue` fields of other miners. The impact is most severe when victim miners fail to produce blocks, as the corrupted values are then used in signature calculations that determine next-round ordering. While this doesn't directly result in fund theft, it undermines the fairness and randomness guarantees of the AEDPoS consensus mechanism and bypasses the cryptographic secret sharing protections designed to ensure honest revelation of InValues.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-53)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```
