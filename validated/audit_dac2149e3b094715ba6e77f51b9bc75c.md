# Audit Report

## Title
Integer Overflow in TokenHolder Withdraw Function Enables Permanent Token Lock via Malicious MinimumLockMinutes

## Summary
The `Withdraw()` function in TokenHolderContract contains a critical vulnerability where excessively large `MinimumLockMinutes` values cause an integer overflow during time validation, permanently trapping user funds. The overflow occurs in checked arithmetic operations, throwing an `OverflowException` that prevents withdrawal transactions from completing, leaving tokens locked indefinitely with no recovery mechanism.

## Finding Description

The vulnerability exists in the `Withdraw()` function's lock time validation. [1](#0-0) 

When this assertion evaluates, it calls `AddMinutes()` which internally performs multiplication by 60. [2](#0-1) 

The `Mul()` operation uses checked arithmetic that throws exceptions on overflow. [3](#0-2) 

The root cause is that `CreateScheme()` accepts `MinimumLockMinutes` without any validation or bounds checking. [4](#0-3) 

**Attack Execution Path:**
1. Attacker calls `CreateScheme()` with `MinimumLockMinutes = Int64.MaxValue` (or any value > 153,722,867,280,912,930)
2. Victim calls `RegisterForProfits()`, locking tokens via the Token contract [5](#0-4) 
3. When victim attempts `Withdraw()`, the calculation `Int64.MaxValue * 60` overflows
4. The checked arithmetic throws `OverflowException`, causing transaction revert
5. Tokens remain locked with no alternative unlock path

**Why Users Cannot Bypass:**
The Token contract's `Unlock()` function computes virtual addresses based on `Context.Sender`. [6](#0-5) 

Tokens are locked in a virtual address: `Hash(TokenHolderContract || userAddress || lockId)`. If users call `Unlock()` directly, it computes `Hash(userAddress || userAddress || lockId)` - a different address, making direct unlock impossible.

**Why Protections Fail:**
While checked arithmetic prevents silent overflow, it transforms the issue into a guaranteed DoS. The scheme manager's `RemoveBeneficiary()` function only removes beneficiaries from the profit scheme but does not unlock tokens. [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

**Direct Fund Impact:**
- Users lose 100% of tokens locked in malicious schemes permanently
- No recovery mechanism exists at contract level
- Each victim experiences complete, irrecoverable token loss

**Scope of Damage:**
- Any user who calls `RegisterForProfits` on a scheme with overflow-inducing `MinimumLockMinutes`
- The attacker does not gain direct access to funds but achieves permanent user fund denial
- Funds are not transferred to attacker but become permanently inaccessible

**Why HIGH Severity:**
1. **Permanence**: No time-based recovery or admin intervention possible
2. **Completeness**: 100% of locked amount is lost
3. **No Authorization Required**: Any address can create malicious schemes
4. **Simple Exploitation**: Single parameter manipulation in scheme creation
5. **Breaks Core Invariant**: Users should always be able to withdraw after lock period expires

## Likelihood Explanation

**Probability: HIGH**

**Attacker Capabilities:**
- `CreateScheme()` is publicly accessible with no authorization checks [4](#0-3) 
- No special privileges, governance approval, or system contract status required
- Single transaction execution to set malicious parameter

**Attack Complexity: LOW**
- Set one parameter (`MinimumLockMinutes`) to extreme value
- No complex transaction sequences or timing requirements
- No need to manipulate oracle data, governance votes, or consensus

**Feasibility Conditions:**
- Requires users to voluntarily register for profits in attacker's scheme
- `MinimumLockMinutes` value is queryable but users unlikely to validate before registration
- Attacker can make scheme appear legitimate with attractive profit-sharing terms
- Value like `Int64.MaxValue` converts to ~292 million years - may appear as display bug rather than malicious parameter

**Detection Constraints:**
- No automatic validation or warnings during scheme creation
- Users must manually query scheme parameters before registration
- No UI/UX layer protections (contract-level vulnerability)
- Malicious schemes would show pattern of failed withdrawal transactions only after exploitation

**Real-World Feasibility:**
Legitimate schemes use reasonable values (example from consensus contract uses `periodSeconds.Div(60)` for minutes conversion [8](#0-7) ). Extreme values are clearly anomalous but users may not check before participating.

## Recommendation

**Immediate Fix:**
Add input validation in `CreateScheme()` to enforce reasonable bounds on `MinimumLockMinutes`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Maximum reasonable lock period: ~100 years in minutes
    const long MaxMinimumLockMinutes = 52_560_000; // 100 years * 365.25 days * 24 hours * 60 minutes
    Assert(input.MinimumLockMinutes >= 0 && input.MinimumLockMinutes <= MaxMinimumLockMinutes, 
        "MinimumLockMinutes must be between 0 and 100 years in minutes.");
    
    // ... rest of existing code
}
```

**Alternative Approaches:**
1. Perform overflow-safe addition in `Withdraw()` by catching potential overflow before calling `AddMinutes()`
2. Use `AddSeconds(scheme.MinimumLockMinutes * 60)` with overflow check instead of `AddMinutes()`
3. Store lock duration in seconds rather than minutes to reduce overflow risk

**Additional Security:**
- Emit event when schemes are created with lock periods exceeding certain thresholds
- Consider implementing emergency withdrawal mechanism with governance approval for trapped funds
- Add view function to validate scheme parameters before user registration

## Proof of Concept

```csharp
[Fact]
public async Task Withdraw_WithOverflowingMinimumLockMinutes_PermanentlyLocksTokens()
{
    // Setup: Create scheme with malicious MinimumLockMinutes
    var attacker = Accounts[1].Address;
    var victim = Accounts[2].Address;
    var tokenSymbol = "ELF";
    var lockAmount = 1000;
    
    // Attacker creates malicious scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = tokenSymbol,
        MinimumLockMinutes = long.MaxValue // Malicious value
    });
    
    // Victim registers for profits (locks tokens)
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = attacker,
        Amount = lockAmount
    });
    
    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = victim,
        Symbol = tokenSymbol,
        LockId = GeneratedLockId(attacker, victim)
    });
    Assert.Equal(lockAmount, lockedAmount.Amount);
    
    // Time passes, victim attempts withdrawal
    // This MUST throw OverflowException due to long.MaxValue * 60 overflow
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(attacker);
    
    // Verify withdrawal failed with overflow
    Assert.True(withdrawResult.TransactionResult.Status == TransactionResultStatus.Failed);
    Assert.Contains("Overflow", withdrawResult.TransactionResult.Error);
    
    // Verify tokens remain locked - permanent loss
    var stillLockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = victim,
        Symbol = tokenSymbol,
        LockId = GeneratedLockId(attacker, victim)
    });
    Assert.Equal(lockAmount, stillLockedAmount.Amount); // Tokens still trapped
}
```

## Notes

This vulnerability represents a critical flaw in the TokenHolder contract's input validation. The checked arithmetic, while preventing silent overflow, inadvertently creates a DoS vector when combined with unvalidated user inputs. The permanent nature of the token loss and the lack of recovery mechanisms elevate this to a HIGH severity issue requiring immediate remediation.

The vulnerability exploits the interaction between three components:
1. Unvalidated scheme creation parameters
2. Token lock mechanism with virtual address computation
3. Checked arithmetic overflow behavior

All three must be considered when implementing the fix to ensure comprehensive protection against similar issues.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-242)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L28-32)
```csharp
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```
