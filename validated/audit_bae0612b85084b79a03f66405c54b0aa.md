# Audit Report

## Title
Sponsor Can Remove Voted Options During Active Voting, Causing DOS and Vote Manipulation

## Summary
The `RemoveOption()` function allows voting sponsors to remove options during active voting periods without validating whether votes have been cast or whether voting is ongoing. This creates a denial-of-service condition for new voters and enables sponsors to manipulate voting outcomes through tactical option removal and re-addition.

## Finding Description

The `RemoveOption()` function in the Vote contract performs only minimal validation before removing an option from a voting item. [1](#0-0) 

**Critical Missing Validations**:
1. No check against `StartTimestamp` or `EndTimestamp` to verify voting is inactive
2. No verification that the option has zero votes before removal
3. No snapshot activity validation

When users attempt to vote, the `AssertValidVoteInput()` method enforces that the option must exist in the voting item's options list. [2](#0-1) 

However, votes are stored separately in the `VotingResult.Results[option]` mapping via `UpdateVotingResult()`. [3](#0-2) 

When an option is removed, these votes persist in the results mapping while the option becomes unavailable for new votes. The voting item contains timestamp fields set during registration [4](#0-3)  but `RemoveOption()` never validates against these timestamps.

**Real-World Impact**: The Election contract actively uses this function when candidates quit elections, demonstrating this issue occurs in production. [5](#0-4) 

**Attack Scenario**:
1. Sponsor registers voting with options A, B, C and sets voting period
2. Voting period becomes active (CurrentBlockTime >= StartTimestamp)
3. Users cast 1000 votes for option A, stored in `VotingResult.Results["A"]`
4. Sponsor calls `RemoveOption()` to remove option A from `VotingItem.Options`
5. New voters attempting to vote for option A fail with "Option not found" assertion
6. The 1000 existing votes remain in results but option is unavailable
7. Sponsor can later re-add option A via `AddOption()`, maintaining the 1000 votes while manipulating the voting period

## Impact Explanation

**Governance Integrity Violation**: This breaks the fundamental invariant that voting options should remain stable during active voting periods. Sponsors gain the ability to manipulate outcomes by:
- Temporarily removing losing options to prevent them from gaining votes
- Creating DOS conditions for specific voter groups targeting removed options
- Re-adding options later with preserved vote counts, creating timing-based manipulation

**Direct Harms**:
- **Denial of Service**: Legitimate voters are blocked from voting on options with existing vote tallies, fragmenting participation
- **Result Inconsistency**: Voting results contain votes for options no longer in the option list, making result interpretation unreliable
- **Election Manipulation**: The Election contract's use of this function during active voting means candidate removal creates the same inconsistencies

**Severity**: Medium - While no funds are directly at risk, governance decisions can be manipulated, potentially affecting protocol parameters, fund allocations, and organizational direction. Sponsors who should not be trusted actors have excessive control over voting integrity.

## Likelihood Explanation

**Attacker Requirements**:
- Must be the sponsor of a voting item (obtainable by calling `Register()` - any address can become a sponsor)
- Single transaction via public `RemoveOption()` method
- No special permissions beyond sponsor role

**Attack Complexity**: Low
- Direct function call with voting item ID and option name
- No complex state manipulation required
- Can be executed repeatedly without cooldown or rate limiting

**Feasibility**: High
- The Election contract already demonstrates this behavior in production
- No technical barriers prevent execution
- Sponsors are not trusted roles according to the threat model, making abuse realistic

## Recommendation

Add validation in `RemoveOption()` to prevent option removal during active voting or when votes exist:

```csharp
public override Empty RemoveOption(RemoveOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // NEW: Prevent removal during active voting period
    Assert(Context.CurrentBlockTime < votingItem.StartTimestamp || 
           Context.CurrentBlockTime > votingItem.EndTimestamp,
           "Cannot remove options during active voting period.");
    
    // NEW: Prevent removal if option has votes
    var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
    var votingResult = State.VotingResults[votingResultHash];
    if (votingResult.Results.ContainsKey(input.Option))
    {
        Assert(votingResult.Results[input.Option] == 0, 
               "Cannot remove option that has received votes.");
    }
    
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
    votingItem.Options.Remove(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

Apply the same logic to `RemoveOptions()` for batch removal operations.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveOption_During_Active_Voting_Creates_DOS()
{
    // 1. Register voting with 3 options, 10-day period
    var votingItem = await RegisterVotingItemAsync(10, 3, true, DefaultSender, 1);
    
    // 2. Cast votes for first option
    var voter = Accounts[2].KeyPair;
    await Vote(voter, votingItem.VotingItemId, votingItem.Options[0], 1000L);
    
    // 3. Verify votes were recorded
    var resultBefore = await GetLatestVotingResult(votingItem.VotingItemId);
    resultBefore.Results[votingItem.Options[0]].ShouldBe(1000L);
    
    // 4. Sponsor removes the voted option during active voting
    var removeResult = await VoteContractStub.RemoveOption.SendAsync(new RemoveOptionInput
    {
        Option = votingItem.Options[0],
        VotingItemId = votingItem.VotingItemId
    });
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 5. Verify option is removed from voting item
    var updatedItem = await GetVoteItem(votingItem.VotingItemId);
    updatedItem.Options.Contains(votingItem.Options[0]).ShouldBeFalse();
    
    // 6. New voter attempts to vote for removed option - FAILS with DOS
    var newVoter = Accounts[3].KeyPair;
    var voteResult = await VoteWithException(newVoter, votingItem.VotingItemId, 
                                             votingItem.Options[0], 500L);
    voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.Error.ShouldContain("Option"); // "Option not found" assertion
    
    // 7. Verify existing votes remain orphaned in results
    var resultAfter = await GetLatestVotingResult(votingItem.VotingItemId);
    resultAfter.Results[votingItem.Options[0]].ShouldBe(1000L); // Votes still present
    
    // This demonstrates: option removed, new votes blocked, but old votes remain
}
```

## Notes

While the Election contract uses `RemoveOption()` when candidates quit, the Election contract is a trusted system contract. In general voting scenarios, sponsors are untrusted actors who can create voting items. The lack of timestamp and vote validation represents a mis-scoped privilege that allows governance manipulation by untrusted sponsors during active voting periods.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L46-47)
```csharp
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L381-381)
```csharp
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L257-261)
```csharp
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
```
