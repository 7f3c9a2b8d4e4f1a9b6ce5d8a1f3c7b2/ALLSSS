# Audit Report

## Title
Consensus Round Data Pollution via Unvalidated Cross-Miner State Injection

## Summary
A malicious miner can inject arbitrary mining order and VRF chain values for ALL miners in a consensus round, bypassing validation due to a critical flaw in `ValidateConsensusAfterExecution`. The vulnerability enables mining schedule manipulation and VRF random number corruption, threatening consensus integrity.

## Finding Description

The AEDPoS consensus contract contains a critical vulnerability where the `RecoverFromUpdateValue` function unconditionally overwrites consensus-critical fields for all miners from attacker-controlled block header data without validation. [1](#0-0) 

**Attack Execution Flow:**

1. **Block Production Phase**: When a malicious miner produces a block, their node calls `GetConsensusExtraDataToPublishOutValue` which generates a Round object via `ApplyNormalConsensusData`. The Round is then simplified for the block header via `GetUpdateValueRound`. [2](#0-1) 

The simplified Round includes `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` for ALL miners. A malicious miner can modify their node software to tamper with these values before the Round is included in the block header.

2. **Transaction Generation**: The corrupted Round data is extracted to create the `UpdateValueInput` transaction: [3](#0-2) 

The `TuneOrderInformation` dictionary captures malicious `FinalOrderOfNextRound` values, and `MinersPreviousInValues` captures malicious `PreviousInValue` values for all miners.

3. **Execution Without Cross-Miner Validation**: The `ProcessUpdateValue` function applies the attacker's values to ALL miners: [4](#0-3) [5](#0-4) 

The corrupted Round is then persisted to state: [6](#0-5) 

4. **Broken Validation Logic**: The post-execution validation in `ValidateConsensusAfterExecution` fails to detect the attack due to a critical implementation flaw: [7](#0-6) 

The issue: `RecoverFromUpdateValue` modifies `currentRound` in-place and returns `this` (the same object). When assigned to `headerInformation.Round`, both variables reference the SAME object. The subsequent hash comparison compares an object to itself, making the validation always pass.

Furthermore, the `UpdateValueValidationProvider` only validates the sender's data: [8](#0-7) 

It does NOT validate the order information or `PreviousInValue` for other miners, allowing the attacker's injected values to persist unchecked.

## Impact Explanation

**Critical Consensus Integrity Violation:**

1. **Mining Schedule Manipulation**: By setting arbitrary `FinalOrderOfNextRound` values, the attacker can assign themselves additional mining slots, demote competitors, or violate the deterministic order resolution logic: [9](#0-8) 

2. **VRF Random Number Chain Corruption**: By setting arbitrary `PreviousInValue` for other miners, the attacker breaks the cryptographic VRF chain used for consensus random number generation. This can:
   - Cause legitimate miners to fail validation when they produce blocks (their actual `PreviousInValue` won't match the corrupted stored value)
   - Enable prediction or manipulation of future random numbers
   - Compromise the randomness guarantees of the consensus mechanism

3. **Systemic Cascade**: Every malicious miner can corrupt ALL other miners' state in each block they produce, leading to widespread consensus failures and potential chain halts if multiple miners collude.

**Severity: CRITICAL** - Directly violates the core consensus invariant: "Miners cannot unilaterally modify other miners' consensus state."

## Likelihood Explanation

**High Exploitability:**

1. **Accessible Entry Point**: Any elected miner can execute this attack during their scheduled mining slot through the standard block production flow.

2. **Low Attack Complexity**: 
   - Attacker only needs to modify their node software to tamper with Round data after `ApplyNormalConsensusData` but before block creation
   - No cryptographic barriers (VRF signatures only authenticate the sender's random number contribution, not other miners' data)
   - No economic cost beyond normal block production

3. **Realistic Preconditions**: 
   - Attacker must be an elected miner (achievable through staking and election)
   - Must wait for their turn in the rotation (guaranteed for elected miners)

4. **Failed Detection**: 
   - The validation logic has a critical same-object comparison bug
   - Cross-miner data validation is completely absent
   - Corrupted state appears valid to honest nodes

5. **Economic Incentive**: 
   - Gain additional mining rewards by manipulating mining order
   - Disrupt competitors by corrupting their VRF chain state
   - Low risk of detection due to broken validation

**Probability: HIGH** - Practical attack executable by any malicious elected miner.

## Recommendation

**Fix 1: Prevent In-Place Modification in Validation**

In `ValidateConsensusAfterExecution`, create a proper copy of `currentRound` before calling `RecoverFromUpdateValue`:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Create a copy for comparison
        var roundForComparison = currentRound.Clone();
        
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            headerInformation.Round =
                roundForComparison.RecoverFromUpdateValue(headerInformation.Round,
                    headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            headerInformation.Round =
                roundForComparison.RecoverFromTinyBlock(headerInformation.Round,
                    headerInformation.SenderPubkey.ToHex());

        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        // Now comparing different objects
        if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
            currentRound.GetHash(isContainPreviousInValue))
        {
            // validation logic...
        }
    }
    return new ValidationResult { Success = true };
}
```

**Fix 2: Add Cross-Miner Data Validation**

Restrict `RecoverFromUpdateValue` to only update the sender's data from the provided Round, and validate that order/previous-in-value for other miners matches expected values:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return this;

    var minerInRound = RealTimeMinersInformation[pubkey];
    var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
    
    // Update only sender's data
    minerInRound.OutValue = providedInformation.OutValue;
    minerInRound.Signature = providedInformation.Signature;
    minerInRound.PreviousInValue = providedInformation.PreviousInValue;
    minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
    minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
    
    // ONLY update sender's order info
    minerInRound.SupposedOrderOfNextRound = providedInformation.SupposedOrderOfNextRound;
    minerInRound.FinalOrderOfNextRound = providedInformation.FinalOrderOfNextRound;

    // Validate (don't blindly copy) other miners' data
    foreach (var information in providedRound.RealTimeMinersInformation)
    {
        if (information.Key == pubkey) continue; // Skip sender
        
        // Verify other miners' order info matches current state
        if (RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound != 
            information.Value.SupposedOrderOfNextRound ||
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound != 
            information.Value.FinalOrderOfNextRound)
        {
            // Mismatch detected - potential attack
            return this; // Don't update
        }
    }

    return this;
}
```

**Fix 3: Validate TuneOrderInformation and MinersPreviousInValues**

Add validation in `ProcessUpdateValue` to ensure order tuning only affects legitimate order conflicts and that `PreviousInValue` updates are authentic:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // ... sender's data updates ...
    
    // Validate TuneOrderInformation against expected conflicts
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        // Verify the order change is justified by an actual conflict
        if (currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound == 
            minerInRound.SupposedOrderOfNextRound)
        {
            // Legitimate conflict resolution
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
        }
        // Otherwise reject the order change
    }
    
    // Only allow PreviousInValue updates for miners in secret sharing context
    if (IsSecretSharingEnabled())
    {
        PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
    }
    // Do NOT blindly apply MinersPreviousInValues outside secret sharing
    
    // ... rest of the function ...
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test that shows how a malicious miner can inject arbitrary `FinalOrderOfNextRound` values:

```csharp
[Fact]
public async Task MaliciousMiner_CanInjectArbitraryOrderValues()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Attacker (miner1) produces a block
    var currentRound = await GetCurrentRound();
    var maliciousRound = currentRound.Clone();
    
    // Attacker manipulates other miners' FinalOrderOfNextRound
    maliciousRound.RealTimeMinersInformation["miner2"].FinalOrderOfNextRound = 99;
    maliciousRound.RealTimeMinersInformation["miner3"].FinalOrderOfNextRound = 1;
    
    // Create UpdateValueInput with malicious TuneOrderInformation
    var maliciousInput = maliciousRound.ExtractInformationToUpdateConsensus("miner1", randomNumber);
    
    // Execute UpdateValue - should reject but doesn't
    var result = await ConsensusContract.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify corruption persisted
    var corruptedRound = await GetCurrentRound();
    corruptedRound.RealTimeMinersInformation["miner2"].FinalOrderOfNextRound.ShouldBe(99); // FAIL: Attack succeeded
    corruptedRound.RealTimeMinersInformation["miner3"].FinalOrderOfNextRound.ShouldBe(1);  // FAIL: Attack succeeded
}
```

The test demonstrates that arbitrary order values bypass all validation and persist to state, confirming the vulnerability.

---

**Notes:**

This vulnerability represents a fundamental breakdown in consensus trust assumptions. The AEDPoS protocol assumes miners cannot unilaterally modify other miners' consensus state, yet the current implementation allows exactly that through three compounding flaws:

1. Blind data copying in `RecoverFromUpdateValue`
2. Missing cross-miner validation in `UpdateValueValidationProvider`  
3. Same-object comparison bug in `ValidateConsensusAfterExecution`

The fix requires addressing all three layers to restore consensus integrity guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-33)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-44)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
