# Audit Report

## Title
Front-Running Denial-of-Service Attack on Contract Deployment Proposals

## Summary
An attacker can front-run legitimate contract deployment proposals by submitting an identical `ProposeNewContract` transaction first, blocking the legitimate deployer for 72 hours. The vulnerability arises because: (1) proposer authorization is not enforced, (2) proposal hashes are deterministic and predictable, (3) duplicate proposals are rejected, and (4) only the original proposer can advance approved proposals.

## Finding Description

The Genesis contract's `ProposeNewContract` method contains a critical design flaw that enables front-running denial-of-service attacks. The vulnerability combines several factors:

**Missing Authorization**: The proposer authority check is commented out in `ProposeNewContract`, allowing any address to submit deployment proposals. [1](#0-0) 

**Deterministic Hash Generation**: The proposal hash is computed deterministically using `HashHelper.ComputeFrom(input)`, making it trivially predictable for any public contract with known bytecode and parameters. [2](#0-1) [3](#0-2) 

**Duplicate Proposal Rejection**: The `RegisterContractProposingData` function blocks any proposal with an identical hash that hasn't expired, without verifying the proposer's authorization. [4](#0-3) 

**Proposer-Locked Release**: Only the address that originally submitted the proposal can call `ReleaseApprovedContract` to advance the deployment, as enforced by the proposer identity check. [5](#0-4) 

**72-Hour Lock Period**: The default expiration time is 259,200 seconds (72 hours), creating a substantial denial-of-service window. [6](#0-5) 

**Attack Execution Flow**:
1. Attacker monitors the mempool or predicts deployment parameters for a public/standard contract
2. Attacker submits `ProposeNewContract` with identical `ContractDeploymentInput` before the legitimate deployer
3. Attacker's proposal registers successfully with the attacker as the proposer
4. Legitimate deployer's transaction fails with "Already proposed" error
5. Even if Parliament approves the proposal, only the attacker can call `ReleaseApprovedContract`
6. If the attacker abandons the proposal, the legitimate deployment is blocked for 72 hours

The test suite confirms this behavior: duplicate proposals are rejected with "Already proposed" error, and different senders cannot release proposals they didn't create. [7](#0-6) [8](#0-7) 

## Impact Explanation

**Severity: Medium**

This vulnerability enables targeted denial-of-service attacks against contract deployment operations:

- **Operational Disruption**: Legitimate deployments are blocked for 72 hours per attack iteration, causing significant delays
- **Business Impact**: Protocol launches, system upgrades, and time-critical deployments can be strategically delayed by competitors or malicious actors
- **Repeated Griefing**: Attackers can repeatedly front-run to extend the denial-of-service indefinitely
- **No Direct Fund Loss**: While no funds are directly stolen, the operational and business impact is substantial

The attack is most effective against public or standard contract implementations (e.g., token contracts) where bytecode and parameters are known in advance or visible in the mempool.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is highly feasible with low barriers to execution:

**Technical Simplicity**: Requires only single-transaction execution using standard front-running techniques with no complex state manipulation.

**Attacker Capabilities**: Mempool monitoring is a standard blockchain capability, hash computation from public parameters is trivial, and gas costs are minimal (only standard transaction fees).

**Realistic Preconditions**: Target contract bytecode must be known (common for public/standard contracts), and attacker needs mempool visibility or advance knowledge of deployment plans.

**No Effective Countermeasures**: There is no on-chain cancellation mechanism for abandoned proposals, no automated cleanup for expired proposals, and legitimate deployers must wait the full 72-hour expiration period.

The likelihood is **Medium-High** for standard deployments, as the attack requires no privileged access and can be executed by any blockchain participant with mempool monitoring capabilities.

## Recommendation

Implement one or more of the following mitigations:

1. **Enforce Authorization**: Uncomment and implement the `AssertDeploymentProposerAuthority` check to restrict who can submit deployment proposals, or use a whitelist mechanism.

2. **Add Proposal Cancellation**: Allow the deployment controller (Parliament) to cancel malicious or abandoned proposals before expiration.

3. **Reduce Expiration Time**: Consider shortening the 72-hour expiration period to minimize the DoS window.

4. **Implement Nonce-Based Hashing**: Include a proposer-specific nonce or timestamp in the hash calculation to prevent hash collisions from different proposers.

5. **Allow Multiple Proposals**: Modify the logic to allow multiple proposals for the same contract from different proposers, with Parliament able to choose which to approve.

Example fix for authorization enforcement:
```csharp
public override Hash ProposeNewContract(ContractDeploymentInput input)
{
    AssertDeploymentProposerAuthority(Context.Sender); // Uncomment and enforce
    // ... rest of implementation
}
```

## Proof of Concept

The existing test suite demonstrates the vulnerability behavior:

**Test 1**: Duplicate proposal rejection at lines 986-1000 shows that attempting to propose the same contract twice fails with "Already proposed" error.

**Test 2**: Different sender restriction at lines 138-152 confirms that when a different sender attempts to call `ReleaseApprovedContract`, the transaction fails with "Invalid contract proposing status" because the proposer identity doesn't match.

A simplified proof of concept would be:
1. User A submits `ProposeNewContract` with specific `ContractDeploymentInput`
2. User B attempts to submit identical `ProposeNewContract` → Transaction fails with "Already proposed"
3. Parliament approves User A's proposal
4. User B attempts `ReleaseApprovedContract` → Transaction fails due to proposer check
5. If User A doesn't call `ReleaseApprovedContract`, User B must wait 72 hours

**Notes**

The report's claim about `ContractOperation` providing mitigation is questionable. While `ContractOperation` includes signature verification, an attacker can still copy the entire signed input from the mempool and submit it first. The signature validates successfully (as it was legitimately signed by the deployer), but the attacker becomes the registered proposer and retains exclusive release rights. Therefore, `ContractOperation` does not effectively prevent this front-running DoS attack.

The vulnerability is confirmed through multiple code locations and test evidence, demonstrating it is a real exploitable issue in the current implementation.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L124-124)
```csharp
        // AssertDeploymentProposerAuthority(Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L127-127)
```csharp
        var proposedContractInputHash = CalculateHashFromInput(input);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-290)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.Approved;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            input.ProposalId.ToByteString());
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L138-152)
```csharp
            // wrong sender
            var releaseApprovedContractWithWrongSenderTx = await Tester.GenerateTransactionAsync(
                BasicContractZeroAddress,
                nameof(BasicContractZero.ReleaseApprovedContract), AnotherMinerKeyPair, new ReleaseContractInput
                {
                    ProposalId = proposalId,
                    ProposedContractInputHash = proposedContractInputHash
                });
            var blockReturnSet = await Tester.MineAsync(new List<Transaction>
                { releaseApprovedContractWithWrongSenderTx });
            var noPermissionProposingTxResult =
                blockReturnSet.TransactionResultMap[releaseApprovedContractWithWrongSenderTx.GetHash()];
            noPermissionProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            noPermissionProposingTxResult.Error.ShouldContain("Invalid contract proposing status.");
        }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L986-1000)
```csharp
        {
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.Contains("Already proposed.").ShouldBeTrue();
        }

        {
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.Contains("Already proposed.").ShouldBeTrue();
        }
```
