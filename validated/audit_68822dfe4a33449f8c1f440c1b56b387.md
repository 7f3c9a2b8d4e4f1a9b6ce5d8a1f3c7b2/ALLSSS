# Audit Report

## Title
Continuous Blocks Validation Bypass via Manipulated Round Number in UpdateValue

## Summary
The `RecoverFromUpdateValue()` function fails to validate that `providedRound.RoundNumber` matches the current round number, checking only for pubkey existence. A malicious block producer can exploit this by setting `ProvidedRound.RoundNumber ≤ 2` while maintaining a correct `RoundIdForValidation`, thereby bypassing the `ContinuousBlocksValidationProvider` check and producing more consecutive blocks than consensus rules permit.

## Finding Description

**Root Cause - Insufficient Round Validation:**

The `RecoverFromUpdateValue()` function performs minimal validation on the provided round: [1](#0-0) 

It only verifies pubkey existence in both rounds without validating critical round identity fields like `RoundNumber` or `TermNumber`. The function then merges data from the provided round into the base round without checking round consistency.

**Validation Pipeline Vulnerability:**

During `ValidateBeforeExecution`, the consensus extra data's Round object is used to recover the base round before validation providers execute: [2](#0-1) 

The validation pipeline includes `ContinuousBlocksValidationProvider`, which uses `ProvidedRound.RoundNumber` to determine whether to enforce continuous blocks limits: [3](#0-2) 

The check `ProvidedRound.RoundNumber > 2` is intended to skip validation only during the first two rounds (bootstrap period). However, `ProvidedRound` comes directly from the attacker-controlled consensus header: [4](#0-3) 

**Bypassing Existing Protections:**

While `TimeSlotValidationProvider` validates that `ProvidedRound.RoundId` matches `BaseRound.RoundId`: [5](#0-4) 

The `RoundId` is computed from `ExpectedMiningTime` or falls back to `RoundIdForValidation`: [6](#0-5) 

In simplified UpdateValue rounds created by honest miners, `ExpectedMiningTime` is not populated for other miners: [7](#0-6) 

This means RoundId falls back to `RoundIdForValidation`. An attacker can independently set both `RoundIdForValidation` (to match the current round) and `RoundNumber` (to ≤ 2), passing the RoundId check while bypassing continuous blocks validation.

**Lack of Structure Validation:**

The only external validation on consensus header structure verifies signature match, not Round content: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Violation:**

The continuous blocks mechanism exists to prevent any single miner from dominating block production. The system tracks consecutive blocks via `LatestPubkeyToTinyBlocksCount`: [9](#0-8) 

By bypassing this check, a malicious miner can:
1. Continue producing blocks after exceeding the allowed consecutive block limit (BlocksCount becomes negative)
2. Monopolize block production and associated mining rewards
3. Cause denial-of-service by preventing other miners from producing blocks
4. Centralize consensus, undermining the distributed nature of AEDPoS

**Affected Parties:**
- Honest miners lose block production opportunities and mining rewards
- The entire network suffers from reduced decentralization
- Users experience degraded consensus security guarantees

**Severity Justification:**
High severity - directly violates core consensus invariants allowing manipulation of miner schedule integrity.

## Likelihood Explanation

**Attacker Capabilities:**
The attacker must be an active miner with block production rights, which is realistic in the AEDPoS consensus system.

**Attack Complexity:**
The attack is straightforward:
1. Miner produces blocks until `LatestPubkeyToTinyBlocksCount.BlocksCount` becomes negative
2. Instead of being forced to NextRound behavior, crafts a malicious consensus header
3. Sets `ProvidedRound.RoundNumber = 1` (or 2)
4. Sets `ProvidedRound.RoundIdForValidation` to the current round's RoundId
5. Submits the block with UpdateValue behavior
6. Validation passes because RoundNumber check is bypassed

**Feasibility:**
While honest miners use `GetUpdateValueRound` to set RoundNumber correctly: [10](#0-9) 

A malicious producer can construct their own consensus header with manipulated fields before block submission, as the consensus header is part of block extra data controlled by the producer.

**Detection Constraints:**
The attack leaves minimal traces beyond abnormal block production patterns, which may only be noticed after damage is done.

## Recommendation

Add explicit validation of `RoundNumber` in `RecoverFromUpdateValue()`:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return this;
    
    // Add validation for round identity fields
    if (providedRound.RoundNumber != RoundNumber)
        return this; // Reject mismatched round numbers
    
    if (providedRound.TermNumber != TermNumber)
        return this; // Reject mismatched term numbers
    
    // ... rest of the function
}
```

Additionally, in `ContinuousBlocksValidationProvider`, use `BaseRound.RoundNumber` instead of `ProvidedRound.RoundNumber`:

```csharp
if (validationContext.BaseRound.RoundNumber > 2 && // Use BaseRound instead of ProvidedRound
    validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
{
    // ... validation logic
}
```

## Proof of Concept

A malicious miner can execute the following attack:

1. Produce blocks normally until `State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount` becomes negative (after producing maximum allowed consecutive blocks)
2. Instead of switching to NextRound behavior, construct a malicious `AElfConsensusHeaderInformation` with:
   - `Round.RoundNumber = 1` (to bypass the > 2 check)
   - `Round.RoundIdForValidation = [current round's computed RoundId]` (to pass TimeSlotValidationProvider)
   - Valid `OutValue` and `Signature` for their pubkey (to pass UpdateValueValidationProvider)
   - No `ExpectedMiningTime` values (forcing RoundId fallback to RoundIdForValidation)
3. Submit the block with this malicious consensus header
4. The validation pipeline will:
   - Pass TimeSlotValidationProvider (RoundId matches via RoundIdForValidation)
   - Skip ContinuousBlocksValidationProvider (RoundNumber = 1 ≤ 2)
   - Pass UpdateValueValidationProvider (OutValue/Signature filled)
   - Pass RecoverFromUpdateValue (only checks pubkey existence)
5. The miner continues producing blocks beyond the allowed limit, monopolizing block production

The attack violates the consensus invariant that no miner should produce more than `MaximumTinyBlocksCount` consecutive blocks, allowing centralization of block production and reward monopolization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-12)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-14)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L14-17)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-53)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L333-365)
```csharp
    /// <summary>
    ///     To prevent one miner produced too many continuous blocks.
    /// </summary>
    /// <param name="minersCountInTheory"></param>
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
