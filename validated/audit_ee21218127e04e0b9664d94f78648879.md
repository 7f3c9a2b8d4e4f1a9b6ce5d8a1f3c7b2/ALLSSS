# Audit Report

## Title
Hash Collision in AssembledNftsMap Due to Unseparated String Concatenation in Token Hash Calculation

## Summary
The `CalculateTokenHash` function concatenates NFT symbol and tokenId without a separator, allowing different (symbol, tokenId) pairs to produce identical hash values. This causes hash collisions in `AssembledNftsMap`, where assembled NFT data from one NFT can overwrite another's, leading to permanent loss of assembled assets when users disassemble their NFTs.

## Finding Description

The root cause is in the `CalculateTokenHash` function which directly concatenates symbol and tokenId without any separator before hashing: [1](#0-0) 

NFT protocol symbols follow the format `{2-letter-prefix}{9+-digit-number}`: [2](#0-1) 

The minimum number length is 9 digits: [3](#0-2) 

As more protocols are created, the number length dynamically grows beyond 9 digits: [4](#0-3) 

**Collision Example:**
- NFT1: symbol="AR123456789" (9-digit), tokenId=10 → "AR123456789" + "10" = "AR12345678910"
- NFT2: symbol="AR1234567891" (10-digit), tokenId=0 → "AR1234567891" + "0" = "AR12345678910"

Both produce identical strings and thus identical hashes.

The `AssembledNftsMap` uses these hashes as keys: [5](#0-4) 

During assembly, the map entry is written: [6](#0-5) 

During disassembly, it's read and removed: [7](#0-6) 

**Attack Sequence:**
1. User A assembles NFT1 (AR123456789, tokenId=10), storing valuable assembled NFTs at hash H
2. User B assembles NFT2 (AR1234567891, tokenId=0) with same hash H, **overwriting** User A's data
3. User A disassembles NFT1, retrieves User B's assembled data instead of their own
4. User A permanently **loses** their original assembled NFTs

Minters can specify custom tokenIds when minting: [8](#0-7) 

With only uniqueness validation per symbol: [9](#0-8) 

No cross-symbol collision prevention exists.

## Impact Explanation

**Direct Asset Loss:** Users assembling NFTs with valuable components (rare NFTs or fungible tokens) will permanently lose these assets if a hash collision overwrites their `AssembledNftsMap` entry. When they disassemble, they receive the wrong assets or nothing at all.

**Affected Parties:** All users who assemble NFTs are at risk. As the protocol scales with more NFT protocols and minted NFTs, the collision probability increases according to the birthday paradox—with approximately 100,000 NFTs across all protocols, there's a ~50% chance of at least one collision occurring.

**Severity Justification:** HIGH severity due to:
- Permanent, unrecoverable asset loss
- No on-chain mechanism to detect or prevent collisions  
- Impact scales with protocol adoption
- Affects core NFT assembly functionality designed for valuable asset combinations

## Likelihood Explanation

**Natural Collision Probability:** Given the symbol space of approximately 10 prefixes × 10^9+ numbers = 10^10 possible combinations, and tokenIds being 64-bit integers, natural collisions become increasingly likely as the system scales. With the birthday paradox, collisions become probable around sqrt(10^10) ≈ 100,000 total NFTs.

**Attacker Capabilities:** An attacker can:
1. Monitor on-chain assembled NFTs to identify high-value targets
2. Create new NFT protocols repeatedly (costs protocol creation fees)  
3. Choose custom tokenIds when minting
4. Assemble with minimal value to overwrite victim's data

**Attack Complexity:** For targeted attacks, the attacker must create protocols until obtaining a symbol that produces a collision with the target. With random symbol generation, this requires on average ~10^9 attempts for a specific 10-digit suffix collision, making targeted attacks economically impractical. However, opportunistic attacks exploiting natural collisions or targeting multiple victims simultaneously are feasible.

**Likelihood Assessment:** MEDIUM-HIGH - While targeted attacks are impractical, natural collisions become increasingly likely with scale, and the lack of any collision detection or prevention makes exploitation inevitable as adoption grows.

## Recommendation

**Fix:** Add a separator between symbol and tokenId in the hash calculation to prevent ambiguity:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
}
```

Using a separator like `|` ensures that different (symbol, tokenId) pairs always produce different concatenated strings, eliminating the collision vulnerability. Any character that cannot appear in symbols would work as a separator.

**Alternative Fix:** Use structured hashing instead of string concatenation:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

## Proof of Concept

```csharp
[Fact]
public async Task HashCollision_AssembledNftsMap_CausesAssetLoss()
{
    // Setup: Create two NFT protocols that will collide
    // Protocol 1: AR123456789 (9-digit number)
    var symbol1 = "AR123456789";
    // Protocol 2: AR1234567891 (10-digit number)  
    var symbol2 = "AR1234567891";
    
    // Calculate hashes to demonstrate collision
    var hash1 = await NFTContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = symbol1, TokenId = 10 });
    var hash2 = await NFTContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = symbol2, TokenId = 0 });
    
    // Verify collision occurs
    hash1.ShouldBe(hash2); // Both produce Hash("AR12345678910")
    
    // This demonstrates that assembled NFT data for one NFT 
    // will overwrite another's in AssembledNftsMap, causing
    // permanent asset loss when users disassemble their NFTs
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Inevitable with scale**: The collision probability increases naturally as the protocol grows, without requiring any malicious action
2. **Silent data corruption**: Users won't know their `AssembledNftsMap` entry has been overwritten until they try to disassemble
3. **Irreversible loss**: Once overwritten, the original assembled NFT data is permanently lost with no recovery mechanism
4. **Affects high-value use case**: Assembly is specifically designed for combining valuable NFTs and tokens, making losses potentially severe

The fix is straightforward (add a separator), but the impact on existing deployed contracts would need careful migration planning to avoid breaking existing token hashes.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-176)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L202-209)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-393)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-32)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
```
