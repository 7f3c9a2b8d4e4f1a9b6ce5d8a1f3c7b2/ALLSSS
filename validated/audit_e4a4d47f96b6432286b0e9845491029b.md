# Audit Report

## Title
Malicious Miner Can Manipulate ConfirmedIrreversibleBlockRoundNumber in NextRound to Force Severe Status DoS

## Summary
A malicious miner can manipulate the `ConfirmedIrreversibleBlockRoundNumber` field when calling the `NextRound` method, artificially creating a gap between the current round number and the last irreversible block (LIB) round number. This manipulation forces the blockchain into "Severe" status, reducing maximum block production from 8 blocks to just 1 block per miner, causing a severe denial-of-service attack that throttles blockchain throughput by up to 87.5%.

## Finding Description

The AEDPoS consensus contract contains a critical validation gap in its `NextRound` transition logic. When a miner produces a block with a `NextRound` consensus transaction, the validation system applies different validators based on the consensus behavior type. [1](#0-0) 

For `NextRound` behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied. Critically, `LibInformationValidationProvider` is **excluded** from NextRound validation. [2](#0-1) 

The `LibInformationValidationProvider` is only applied to `UpdateValue` behavior, and it specifically validates that LIB-related fields do not decrease: [3](#0-2) 

Without this validation, the `ProcessNextRound` method directly converts the untrusted `NextRoundInput` to a `Round` object: [4](#0-3) 

The `ToRound()` method copies all fields including `ConfirmedIrreversibleBlockRoundNumber` without any validation: [5](#0-4) 

This manipulated data is stored directly into state: [6](#0-5) 

The manipulated `ConfirmedIrreversibleBlockRoundNumber` is then read by `GetMaximumBlocksCount()`: [7](#0-6) 

The `BlockchainMiningStatusEvaluator` calculates blockchain status based on the gap between current round and LIB round: [8](#0-7) 

The severe status threshold is set to 8 rounds: [9](#0-8) 

When Severe status is triggered, the maximum blocks count is reduced to 1: [10](#0-9) 

The normal maximum is 8 blocks: [11](#0-10) 

The only authorization check is `PreCheck()`, which verifies the caller is in the current or previous miner list: [12](#0-11) 

**Attack Flow:**
1. Malicious miner produces a block containing a NextRound consensus transaction
2. Modifies `ConfirmedIrreversibleBlockRoundNumber` to an artificially low value (e.g., `currentRoundNumber - 8`)
3. Block undergoes pre-execution validation via `ValidateConsensusBeforeExecution`
4. Validation applies only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`
5. Neither validator checks LIB fields, so validation passes
6. Transaction executes, manipulated round is stored in state
7. `GetMaximumBlocksCount()` reads the manipulated value and calculates a large gap
8. Blockchain enters Severe status
9. Maximum blocks per miner reduced from 8 to 1

## Impact Explanation

This vulnerability enables a **HIGH severity denial-of-service attack** on the AElf blockchain consensus system:

1. **Operational Impact**: Maximum block production is reduced from 8 blocks to 1 block per miner time slot, throttling blockchain throughput by 87.5%. This dramatically reduces the network's transaction processing capacity.

2. **Consensus Integrity**: The attack creates a false perception that the blockchain is in severe distress with stalled irreversible block confirmation, when in reality the LIB may be progressing normally. This violates the integrity guarantees of the consensus status monitoring system.

3. **Affected Parties**: All blockchain users experience dramatically reduced transaction processing capacity. The entire network's ability to process transactions is crippled, affecting dApp functionality, token transfers, and all on-chain operations.

4. **Attack Persistence**: The attacker can repeat this manipulation in subsequent rounds to maintain the DoS condition indefinitely, as there are no mechanisms to detect or prevent repeated manipulation.

5. **Low Attack Cost**: Unlike traditional DoS attacks requiring significant resources, this attack only requires being a miner and submitting a single manipulated consensus transaction per round.

## Likelihood Explanation

The attack is **highly likely** to be exploitable:

**Attacker Capabilities:**
- Attacker must be an active miner, verified by `PreCheck()`. This is a reasonable precondition as miners are legitimate consensus participants.

**Attack Complexity:**
- Very low: The attacker generates a valid `NextRoundInput` using standard consensus methods, modifies the `ConfirmedIrreversibleBlockRoundNumber` field to an artificially low value, and produces a block with this manipulated consensus data.
- No cryptographic bypasses or complex timing attacks required.

**Feasibility Conditions:**
- No special preconditions beyond being a miner
- No need for collusion with other miners
- Can be executed at any time during normal consensus operation

**Detection Constraints:**
- The attack is difficult to distinguish from legitimate network issues since Severe status is designed to trigger when consensus genuinely degrades
- No on-chain mechanism exists to verify that the provided `ConfirmedIrreversibleBlockRoundNumber` matches actual LIB progression

**Economic Rationality:**
- Attack cost is minimal (just block production cost)
- Potential motivations include griefing competitors, manipulating transaction fees during congestion, or disrupting network operations

## Recommendation

Add `LibInformationValidationProvider` to the validation providers for `NextRound` behavior in the `ValidateBeforeExecution` method:

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB validation to prevent manipulation
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

This ensures that the LIB-related fields (`ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber`) cannot be set to values lower than the current state, preventing the manipulation attack.

## Proof of Concept

A proof of concept would involve:

1. Setting up a test environment with multiple miners
2. Having one miner produce a block with a NextRound consensus transaction
3. In the NextRoundInput, setting `ConfirmedIrreversibleBlockRoundNumber` to `currentRoundNumber - 8`
4. Observing that the block validation passes
5. Verifying that `GetMaximumBlocksCount()` returns 1 instead of 8
6. Confirming that the blockchain enters Severe status despite normal LIB progression

The vulnerability exists because the validation logic explicitly excludes `LibInformationValidationProvider` for NextRound behavior, allowing miners to manipulate LIB tracking fields and trigger false Severe status conditions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-28)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-117)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-129)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
