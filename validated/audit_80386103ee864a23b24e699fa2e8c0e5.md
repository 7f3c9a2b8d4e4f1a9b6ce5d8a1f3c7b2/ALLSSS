# Audit Report

## Title
Cross-Chain NFT Type Synchronization DOS - Custom NFT Types Cause CrossChainCreate Failure

## Summary
Custom NFT types added via `AddNFTType` on one chain are stored in chain-local state and are not automatically synchronized to other chains. When `CrossChainCreate` attempts to create an NFT protocol on a destination chain using a custom type, it fails because the type mapping doesn't exist, creating a systematic DOS condition that requires manual parliament intervention on each chain.

## Finding Description

The NFT contract stores NFT type mappings in chain-local state variables `NFTTypeShortNameMap` and `NFTTypeFullNameMap`. [1](#0-0) 

When `InitialNFTTypeNameMap()` is called, it only initializes 10 predefined NFT types (XX, AR, MU, DN, VW, TC, CO, SP, UT, BA) and returns early if already initialized. [2](#0-1) 

Parliament can add custom NFT types via `AddNFTType`, which stores them in the chain-local state maps. [3](#0-2) 

The vulnerability manifests in `CrossChainCreate` when it attempts to create an NFT protocol on a sidechain. The function calls `InitialNFTTypeNameMap()` to populate default types, then extracts the 2-character type short name from the symbol and looks it up in `State.NFTTypeFullNameMap`. If the custom type doesn't exist on the destination chain, the function throws an exception, completely blocking the protocol creation. [4](#0-3) 

The root cause is that `CrossChainCreateToken` in the MultiToken contract only syncs token information (symbol, name, supply, decimals, issuer, external info) but does NOT sync the NFT type mappings from the NFT contract's separate state. [5](#0-4) 

**Attack Path:**
1. MainChain: Parliament adds custom type "GG" â†’ "Gaming" via `AddNFTType` (stored in mainchain NFT contract state)
2. MainChain: NFT protocol created with symbol "GG123456" 
3. MainChain: `CrossChainCreateToken` syncs token info to SideChain (but NOT the NFT type mapping)
4. SideChain: `CrossChainCreate("GG123456")` is called
5. SideChain: `InitialNFTTypeNameMap()` only populates 10 default types
6. SideChain: Lookup of "GG" in `State.NFTTypeFullNameMap` returns null
7. Transaction fails with "Full name of GG not found. Use AddNFTType to add this new pair."

## Impact Explanation

This vulnerability creates a **High-severity operational DOS** affecting cross-chain NFT functionality:

1. **Protocol Availability DOS**: NFT protocols using custom types cannot be created on sidechains, blocking legitimate cross-chain operations and preventing users from accessing their NFT assets across chains.

2. **Governance Coordination Burden**: Resolution requires parliament proposals on EVERY destination chain to manually add each custom type via `AddNFTType`, introducing significant delays and coordination overhead.

3. **Systematic Failure**: This is not an edge case but a fundamental design gap - ANY use of custom NFT types will trigger this DOS across ALL chains that haven't manually synchronized the type mappings.

4. **Potential Permanent Unavailability**: If a sidechain's parliament is inactive or uncooperative, NFT protocols remain permanently inaccessible on that chain.

The impact is concrete and measurable: cross-chain NFT protocol creation fails with a hard revert, completely blocking the intended functionality and affecting the availability of cross-chain token operations.

## Likelihood Explanation

**Likelihood: High**

This is not a theoretical vulnerability requiring malicious actors - it manifests during normal, legitimate protocol operations:

1. **No Attack Required**: The issue occurs when parliament performs its expected governance function (adding custom NFT types) and users attempt standard cross-chain operations.

2. **Minimal Preconditions**: 
   - Custom NFT type feature exists and is documented (`AddNFTType` function is available)
   - Cross-chain protocol synchronization is a core use case
   - No automatic synchronization mechanism exists for type mappings

3. **Immediate Trigger**: The DOS activates the moment someone attempts to call `CrossChainCreate` for any NFT protocol using a custom type that hasn't been manually added to the destination chain.

4. **Reproducible**: The execution path is deterministic and will fail consistently (100% reproducibility) for all NFT protocols using non-default types until manual synchronization occurs.

The probability is effectively 100% once a custom NFT type is used, making this a guaranteed operational failure rather than a probabilistic attack.

## Recommendation

**Fix 1: Use ExternalInfo Instead of Local Mapping**

Modify `CrossChainCreate` to extract the NFT type full name directly from the token's ExternalInfo rather than attempting to resolve it from the local state mapping:

```csharp
// Instead of:
var nftTypeShortName = input.Symbol.Substring(0, 2);
var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];

// Use:
var nftTypeFullName = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];
```

This leverages the fact that `CrossChainCreateToken` already syncs the NFT type full name in the token's ExternalInfo, eliminating the dependency on synchronized mappings.

**Fix 2: Automatic Type Synchronization**

Alternatively, enhance `CrossChainCreateToken` to automatically register missing NFT types on the destination chain by extracting the type mapping from the symbol prefix and full name in ExternalInfo, then calling an internal type registration function.

**Fix 3: Enhanced Validation**

Add pre-validation in `CrossChainCreate` that provides clearer guidance when type mappings are missing, and potentially auto-register types with appropriate governance controls.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_CustomNFTType_ShouldFail()
{
    // Step 1: On MainChain - Parliament adds custom NFT type "GG" -> "Gaming"
    await MainChainParliamentStub.AddNFTType.SendAsync(new AddNFTTypeInput
    {
        ShortName = "GG",
        FullName = "Gaming"
    });
    
    // Step 2: On MainChain - Create NFT protocol with custom type
    var createResult = await MainChainNFTStub.Create.SendAsync(new CreateInput
    {
        NftType = "Gaming",
        ProtocolName = "GameItems",
        TotalSupply = 1000000,
        BaseUri = "ipfs://gaming/",
        IsBurnable = true,
        IsTokenIdReuse = false
    });
    var symbol = createResult.Output.Value; // Should be "GG123456" or similar
    
    // Step 3: Sync token to SideChain via CrossChainCreateToken
    await SyncTokenToSideChain(symbol);
    
    // Step 4: On SideChain - Attempt CrossChainCreate
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await SideChainNFTStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    
    // Verify the expected error message
    exception.Message.ShouldContain("Full name of GG not found. Use AddNFTType to add this new pair.");
}
```

## Notes

This vulnerability represents a design flaw in the cross-chain synchronization architecture where NFT type metadata (stored in the NFT contract's state) is not automatically synchronized when token information (stored in the MultiToken contract's state) is propagated across chains. The issue is particularly problematic because the `CrossChainCreate` function unnecessarily attempts to resolve type mappings from local state instead of using the NFT type full name already available in the token's ExternalInfo that was synced by `CrossChainCreateToken`.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-36)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-93)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-149)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```
