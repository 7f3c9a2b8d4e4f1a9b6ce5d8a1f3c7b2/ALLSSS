# Audit Report

## Title
Incomplete Evil Miner Replacement Due to Incorrect Initial Miner Count Calculation

## Summary
The `GetMinerReplacementInformation()` function in the Election contract calculates `takeAmount` based on the total count of initial miners before applying filters, causing insufficient alternative candidates when the initial miner pool is depleted. This results in some banned evil miners remaining active in consensus rounds, violating the critical security invariant that all detected evil miners must be immediately replaced.

## Finding Description

**Location and Root Cause:**

The vulnerability exists in the Election contract's `GetMinerReplacementInformation()` method where `takeAmount` is calculated using the unfiltered initial miners count. [1](#0-0) 

The code calculates `takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count)` using the total initial miners count, then applies filters for banned miners and current miners. When the LINQ `.Take(takeAmount)` operation executes on the filtered collection, it returns only the available items if fewer than `takeAmount` exist after filtering. This causes `alternativeCandidates.Count` to be less than `evilMinersPubKeys.Count`.

**How Protections Fail:**

The consensus contract consumes this data assuming equal list sizes: [2](#0-1) 

The loop at line 311 iterates only `AlternativeCandidatePubkeys.Count` times and accesses both lists with the same index. When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, the remaining evil miners in the list are never processed. Only the processed evil miners are removed from `currentRound.RealTimeMinersInformation` at line 337, leaving unprocessed banned miners active in consensus.

**Evil Miner Detection:**

Evil miners are marked through the standard consensus security mechanism: [3](#0-2) 

When miners exhibit malicious behavior, `BannedPubkeyMap[input.Pubkey]` is set to true, and they should be immediately replaced in the next round. [4](#0-3) 

## Impact Explanation

**High Severity - Consensus Security Breach:**

This vulnerability directly compromises the consensus layer's security model. Evil miners who have been detected and banned for malicious behavior continue participating in block production and consensus decisions. The impact includes:

1. **Continued Malicious Participation**: Banned miners maintain their consensus rights, can produce blocks, and earn rewards despite being identified as compromised
2. **Security Model Violation**: The system's fundamental assumption that detected evil nodes are immediately removed is violated
3. **Honest Miner Displacement**: Legitimate alternative candidates are denied consensus slots that should be vacated by banned miners
4. **Cumulative Risk**: As more miners get banned over the network's lifetime without full replacement, the proportion of malicious nodes in consensus increases

The entire network's consensus integrity depends on this replacement mechanism functioning correctly. Partial replacement means the security guarantees of the consensus protocol are weakened.

## Likelihood Explanation

**High Likelihood - Occurs Through Normal Protocol Operations:**

This vulnerability triggers automatically without attacker action under realistic conditions:

**Scenario Prerequisites:**
1. Initial miners pool is limited (typically 3-7 configured at genesis)
2. Over network lifetime, some initial miners get banned for misbehavior  
3. Some initial miners are currently active in the miner list
4. Multiple evil miners are detected in the same round
5. Election snapshot doesn't provide enough alternative candidates (excluding initial miners)

**Concrete Example:**
- 21 active miners, 5 initial miners at genesis
- 3 current miners detected as evil and need replacement
- Of 5 initial miners: 2 banned, 2 in current active list, 1 available
- Election snapshot provides 1 alternative (after excluding initial miners)
- Result: Need 3 replacements, get only 2 (1 from snapshot + 1 from initial miners)
- 1 evil miner remains active

**Increasing Probability:**
The vulnerability becomes more likely over time as the initial miner pool gets depleted through normal operations. No special privileges or attack setup is required - it occurs during the standard consensus round generation flow called automatically by the protocol. [5](#0-4) 

## Recommendation

**Fix:** Calculate `takeAmount` AFTER applying filters to accurately determine available initial miners.

```csharp
// If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
if (diff > 0)
{
    var availableInitialMiners = State.InitialMiners.Value.Value
        .Select(k => k.ToHex())
        .Where(k => !State.BannedPubkeyMap[k])
        .Where(k => !input.CurrentMinerList.Contains(k))
        .ToList(); // Materialize filtered list first
    
    var takeAmount = Math.Min(diff, availableInitialMiners.Count); // Calculate after filtering
    alternativeCandidates.AddRange(availableInitialMiners.Take(takeAmount));
}
```

**Additional Safeguard:** Add validation in the consensus contract to ensure list count equality or handle mismatches appropriately:

```csharp
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
{
    Assert(minerReplacementInformation.AlternativeCandidatePubkeys.Count == 
           minerReplacementInformation.EvilMinerPubkeys.Count,
           "Insufficient alternative candidates for evil miner replacement");
    
    for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
    {
        // ... existing replacement logic
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task IncompleteEvilMinerReplacement_WhenInitialMinerPoolDepleted()
{
    // Setup: 5 initial miners, 21 active miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeElectionContract(initialMiners);
    
    // Ban 2 initial miners
    await BanMiners(new[] { initialMiners[0], initialMiners[1] });
    
    // Current active miner list includes 2 initial miners
    var currentMiners = GenerateMiners(21);
    currentMiners[0] = initialMiners[2]; // Initial miner in active list
    currentMiners[1] = initialMiners[3]; // Initial miner in active list
    
    // Mark 3 current miners as evil
    await MarkAsEvil(new[] { currentMiners[5], currentMiners[6], currentMiners[7] });
    
    // Election snapshot provides only 1 alternative candidate
    await SetupElectionSnapshot(1);
    
    // Execute: Get replacement information
    var replacementInfo = await ElectionContract.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput { CurrentMinerList = { currentMiners } });
    
    // Verify: Only 2 alternatives provided instead of 3 needed
    Assert.Equal(3, replacementInfo.EvilMinerPubkeys.Count);
    Assert.Equal(2, replacementInfo.AlternativeCandidatePubkeys.Count); // BUG: Should be 3
    
    // Execute: Generate next round using this info
    var nextRound = await ConsensusContract.GenerateNextRound.CallAsync();
    
    // Verify: 1 evil miner remains in consensus
    var evilMinerStillActive = nextRound.RealTimeMinersInformation
        .ContainsKey(replacementInfo.EvilMinerPubkeys[2]); // Third evil miner not replaced
    Assert.True(evilMinerStillActive); // BUG CONFIRMED: Evil miner remains active
}
```

## Notes

The vulnerability is rooted in a common programming pattern error: calculating a limit before applying filters. The initial miners pool serves as a fallback when election candidates are insufficient, but the code incorrectly assumes the pre-filtered count represents available candidates. The LINQ `.Take()` operation silently returns fewer items when the source is smaller than requested, masking the issue until it manifests as incomplete evil miner removal during consensus operations. This is a critical consensus security issue that naturally worsens over the network's lifetime as the initial miner pool gets depleted.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-392)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```
