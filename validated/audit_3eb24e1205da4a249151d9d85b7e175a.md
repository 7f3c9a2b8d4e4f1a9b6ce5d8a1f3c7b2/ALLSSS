# Audit Report

## Title
Inconsistent Vote Threshold Counting Allows Proposals to Pass with Fewer Current Members Than Required

## Summary
The Association contract's `CheckEnoughVoteAndApprovals` function applies inconsistent membership filtering when validating proposal thresholds. While approval, rejection, and abstention thresholds filter votes by current organization members, the minimal vote threshold counts all historical votes including those from removed members. This allows proposals to pass with fewer current member votes than the configured threshold requires, undermining governance quorum requirements.

## Finding Description

The vulnerability exists in the threshold validation logic within the Association contract. The function validates four distinct thresholds but applies different counting semantics:

**Approval Threshold** - Filters by current membership: [1](#0-0) 

**Rejection Threshold** - Filters by current membership: [2](#0-1) 

**Abstention Threshold** - Filters by current membership: [3](#0-2) 

**Vote Threshold** - Does NOT filter by membership: [4](#0-3) 

When members are removed via the `RemoveMember` function [5](#0-4) , their addresses remain in the proposal's vote lists. No cleanup mechanism exists to remove historical votes from removed members.

The validation constraint only prevents excessive member removal: [6](#0-5) 

This constraint ensures `MinimalVoteThreshold <= organizationMemberCount` but does NOT prevent counting votes from removed members.

**Critical Evidence**: The Parliament contract correctly implements this logic by filtering the total vote count by current members: [7](#0-6) 

This demonstrates the Association contract's implementation is incorrect.

## Impact Explanation

This vulnerability breaks the fundamental governance invariant that `MinimalVoteThreshold` represents the minimum number of current organization members who must participate in voting. 

**Concrete Attack Scenario:**
1. Organization has 10 members
2. Configuration: `MinimalVoteThreshold=8`, `MinimalApprovalThreshold=6`
3. 8 members vote: 6 approve, 2 reject
4. Organization releases a separate proposal to remove 1 rejecting member
5. After removal: 9 members remain (constraint 8≤9 satisfied)
6. Threshold validation for target proposal:
   - `approvedMemberCount` = 6 (current members only) ≥ 6 ✓
   - `rejectionMemberCount` = 1 (removed member excluded)
   - `totalVotes` = 8 (includes removed member's vote) ≥ 8 ✓
7. Proposal passes with only 7 current members voting instead of required 8

**Impact Severity:**
- Governance quorum can be systematically bypassed
- Proposals requiring broad organizational consensus can pass with minority current member participation
- Affects all Association-based governance including multi-signature wallets and organizational decision-making
- The semantic contract with users about threshold meanings is violated

## Likelihood Explanation

**Exploitability: MEDIUM**

The vulnerability requires coordination across multiple governance actions but uses only standard, permissionless operations:

1. Members vote on a target proposal using standard voting methods [8](#0-7) 
2. Organization creates and releases a proposal to remove selected members [5](#0-4) 
3. Target proposal now passes with fewer current member votes

**Feasibility:**
- No special permissions required beyond normal organization membership
- Member removal is a standard governance operation
- Timing is flexible (members vote, then removal happens, then release)
- No external dependencies or race conditions

**Detection Difficulty:**
- Member removal events are visible on-chain [9](#0-8) 
- However, the connection between removal and threshold manipulation is non-obvious
- No automated detection mechanism exists in the contract

The likelihood is realistic because organizations frequently adjust membership through legitimate governance, and this vulnerability can be triggered inadvertently or exploited deliberately.

## Recommendation

Modify the vote threshold check to filter by current organization membership, consistent with the other threshold checks:

Change the total vote count calculation to filter by current members:
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This matches the Parliament contract's correct implementation and ensures all threshold validations use consistent membership filtering semantics.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

```csharp
// Setup: Create organization with 10 members, MinimalVoteThreshold=8, MinimalApprovalThreshold=6
// Step 1: Create proposal for target action
// Step 2: 6 members approve, 2 members reject (8 total votes)
// Step 3: Create and release proposal to remove 1 rejecting member
// Step 4: Verify organization now has 9 members (8≤9 constraint satisfied)
// Step 5: Attempt to release target proposal
// Expected: Should fail (only 7 current members voted)
// Actual: Succeeds (counts removed member's vote in total)
```

The test demonstrates that `CheckEnoughVoteAndApprovals` returns true even though only 7 current members participated, violating the MinimalVoteThreshold=8 requirement for current member participation.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-44)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-51)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-73)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L97-101)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
```

**File:** protobuf/association_contract.proto (L132-138)
```text
message MemberRemoved{
    option (aelf.is_event) = true;
    // The removed member address.
    aelf.Address member = 1;
    // The organization address.
    aelf.Address organization_address = 2 [(aelf.is_indexed) = true];
}
```
