# Audit Report

## Title
Consensus DoS via Malformed Hex Keys in NextRound Input

## Summary
The AEDPoS consensus contract accepts miner public keys as unvalidated strings in `NextRound()` input, allowing a malicious miner to inject non-hex or odd-length keys that get stored in state. Subsequent consensus operations throw exceptions when attempting to convert these malformed keys to ByteString, causing permanent consensus halt.

## Finding Description

The vulnerability exists because the consensus contract stores round information with string-typed miner public keys but performs hex format validation only during ByteString conversion, not at input acceptance.

**Attack Execution Path:**

A malicious miner calls the public `NextRound()` method [1](#0-0)  with a crafted `NextRoundInput` protobuf message containing malformed keys (e.g., "ZZZZ", "invalid", or odd-length "abc") in the `RealTimeMinersInformation` map field.

The input passes `PreCheck()` authorization validation [2](#0-1)  which only verifies the caller is an authorized miner, not the format of keys in the input data.

Consensus validation providers [3](#0-2)  check round numbers, mining orders, and time slots, but do NOT validate hex format of the keys themselves.

`ProcessNextRound()` converts the input to a Round object via `ToRound()` [4](#0-3)  which simply copies all fields including the malformed keys without any validation.

The malformed round is then stored directly to contract state via `AddRoundInformation()` [5](#0-4)  at line 156 of ProcessNextRound, successfully corrupting the consensus state.

**DoS Trigger Mechanism:**

Once malformed keys are in state, any operation attempting hex conversion throws exceptions. The `ByteArrayHelper.HexStringToByteArray()` implementation [6](#0-5)  calls `Convert.ToByte(hex.Substring(i, 2), 16)` which throws `FormatException` for invalid hex characters or `ArgumentOutOfRangeException` for odd-length strings.

The `GetCurrentMinerList()` view method [7](#0-6)  attempts to convert all keys in the current round using `ByteStringHelper.FromHexString(k)`, causing all miner list queries to fail with exceptions.

Subsequent `NextRound()` calls fail in `RecordMinedMinerListOfCurrentRound()` [8](#0-7)  when attempting to convert the current round's (now malformed) miner keys at line 229.

Similarly, `NextTerm()` operations fail when attempting to build the miner list [9](#0-8)  at line 189, where it attempts `ByteStringHelper.FromHexString(k)` on the malformed keys.

## Impact Explanation

This vulnerability causes **critical consensus availability failure**. Once malformed keys are stored in state:

- All view methods querying miner lists throw exceptions and fail
- All `NextRound()` transactions throw exceptions during `RecordMinedMinerListOfCurrentRound()`, preventing round progression
- All `NextTerm()` transactions throw exceptions, preventing term transitions
- Mining reward distribution cannot proceed as it depends on miner list enumeration
- Cross-chain operations requiring miner list synchronization fail

The blockchain enters an **unrecoverable halted state** with no automatic recovery mechanism. The entire network consensus stops permanently, requiring manual intervention such as state rollback or emergency contract upgrade to recover. This breaks the fundamental availability guarantee of the consensus layer.

Unlike transient DoS attacks, this creates permanent state corruption that persists across all nodes, as the malformed data is replicated through the consensus mechanism itself.

## Likelihood Explanation

**Medium-High Probability of Exploitation:**

The attack requires:
- Attacker must be an authorized miner (insider access requirement)
- Single malicious transaction during a legitimate mining time slot
- No complex preconditions or multi-step attack sequences

Factors increasing likelihood:
- Any current miner can execute the attack (realistic insider threat model)
- A compromised miner node can automate the attack
- Attack complexity is trivial (simply craft a protobuf message with malformed string field)
- No detection mechanism exists before state corruption occurs
- Immediate and permanent impact with single transaction
- No hex format validation exists anywhere in the codebase

While requiring miner privileges elevates the trust requirement, the ease of execution and catastrophic impact with no recovery path makes this a severe threat. Blockchain consensus systems must be resilient to malicious participants, and this vulnerability shows a single malicious miner can permanently halt the entire network, which violates fundamental consensus fault tolerance guarantees.

## Recommendation

Implement hex format validation for all miner public keys before storing round information to state. Add validation in the `ProcessNextRound()` method before calling `AddRoundInformation()`:

**Validation Logic:**
1. Check that all keys in `nextRound.RealTimeMinersInformation` are valid hexadecimal strings
2. Verify each key has even length (required for byte conversion)
3. Reject the transaction if any key fails validation

**Implementation Location:**
Add validation in `AEDPoSContract_ProcessConsensusInformation.cs` in the `ProcessNextRound()` method before line 156 (before `AddRoundInformation(nextRound)` call).

**Alternative Defense:**
Additionally, implement try-catch blocks with graceful error handling in hex conversion operations to prevent uncaught exceptions from halting consensus, though input validation is the primary fix.

## Proof of Concept

Due to the complexity of setting up a full AEDPoS consensus environment with multiple miners and the requirement for integration testing infrastructure, a complete executable test demonstrating the vulnerability would require:

1. Deploy AEDPoS consensus contract in test environment
2. Initialize with valid miner list and establish first round
3. Authorize a test miner account
4. Craft `NextRoundInput` protobuf with malformed key (e.g., "ZZZZ") in `RealTimeMinersInformation`
5. Call `NextRound()` method with malformed input from authorized miner account
6. Verify transaction succeeds and corrupts state
7. Attempt to call `GetCurrentMinerList()` and observe `FormatException`
8. Attempt subsequent `NextRound()` call and observe failure in `RecordMinedMinerListOfCurrentRound()`

The vulnerability is confirmed by code analysis showing:
- No hex validation exists in the input processing path
- `ByteArrayHelper.HexStringToByteArray()` throws exceptions on invalid input without try-catch protection
- Multiple consensus operations depend on successful hex conversion

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-236)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });

        // Remove information out of date.
        var removeTargetRoundNumber = currentRound.RoundNumber.Sub(3);
        if (removeTargetRoundNumber > 0 && State.MinedMinerListMap[removeTargetRoundNumber] != null)
            State.MinedMinerListMap.Remove(removeTargetRoundNumber);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```
