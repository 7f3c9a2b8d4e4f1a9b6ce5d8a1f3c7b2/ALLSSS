# Audit Report

## Title
Missing Term Duration Validation Allows Premature Term Transitions

## Summary
The AEDPoS consensus validation logic fails to enforce term duration requirements during `NextTerm` transitions. While time validation logic exists in `NeedToChangeTerm()`, it is only used for honest behavior selection, not enforced during block validation. This allows any miner to force premature term transitions, violating the consensus invariant that terms must last for their configured duration (typically 7 days).

## Finding Description

The vulnerability stems from an architectural flaw where temporal validation is advisory rather than mandatory.

**Validation Only Checks Structural Correctness:**

The `ValidationForNextTerm()` method performs only incremental checks without time constraints: [1](#0-0) 

**Time Validation Exists But Is Not Enforced:**

The `NeedToChangeTerm()` method properly validates that at least 2/3 of miners have timestamps indicating the term period has elapsed: [2](#0-1) 

However, this check is ONLY called in the behavior provider for honest node behavior selection: [3](#0-2) 

**Attack Execution:**

1. Malicious miner modifies their node to bypass `NeedToChangeTerm()` and always return `NextTerm` behavior
2. Calls the public `NextTerm()` method: [4](#0-3) 

3. `PreCheck()` only validates miner list membership, not timing: [5](#0-4) 

4. Block validation adds only `RoundTerminateValidationProvider` for NextTerm: [6](#0-5) 

5. Transaction passes validation and executes `ProcessNextTerm()`: [7](#0-6) 

## Impact Explanation

This vulnerability violates a critical consensus invariant with cascading effects across the entire protocol:

**1. Mining Reward Timing Manipulation:**
Premature term changes trigger `DonateMiningReward()` and `UpdateMiningReward()` with incorrect timing, distorting the intended reward schedule and economic incentives.

**2. Treasury Release Disruption:**
The treasury release mechanism is tied to term numbers. Premature transitions cause treasury distributions at incorrect intervals, affecting all profit distribution schemes.

**3. Election Result Timing:**
Election snapshots are taken at term boundaries via `TakeSnapshot()`. Premature transitions apply election results before the intended voting period completes, undermining the democratic process.

**4. Miner List Schedule Corruption:**
New miners from elections are added prematurely, disrupting the consensus schedule and potentially excluding miners who should still be active.

**Affected Parties:**
- All miners (reward timing corruption)
- Token holders (treasury distribution timing)
- Governance participants (election integrity)
- Network integrity (consensus schedule disruption)

The impact is **HIGH** severity because it breaks a foundational consensus guarantee that affects economic incentives, governance timing, and network coordination across all participants.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the current or previous round
- Must control their mining node software
- No economic stake, collusion, or special resources required

**Attack Execution:**
The attack is trivially executable:
1. Modify the local node to bypass `NeedToChangeTerm()` check
2. Generate a `NextTermInput` with term+1 and round+1
3. Call `NextTerm()` during scheduled mining time slot
4. Transaction passes all validation checks

**Feasibility:**
Every miner gets guaranteed time slots in rotation. The validation pipeline provides zero defense against this attack. No coordination with other miners is needed.

**Detection:**
While monitoring could detect abnormal term durations, once the malicious transaction is validated and included in a block, the state corruption is permanent and all honest nodes will build on this invalid state.

The likelihood is **HIGH** because any miner can deterministically execute this attack during their time slot. The only barrier is node software modification, which is trivial for anyone running mining infrastructure.

## Recommendation

Add temporal validation to the `RoundTerminateValidationProvider.ValidationForNextTerm()` method by calling `NeedToChangeTerm()`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // ADD: Validate sufficient time has elapsed for term transition
    if (!validationContext.BaseRound.NeedToChangeTerm(
        blockchainStartTimestamp, 
        validationContext.CurrentTermNumber, 
        periodSeconds))
    {
        return new ValidationResult { Message = "Term duration requirement not met." };
    }

    return new ValidationResult { Success = true };
}
```

The `ValidationForNextTerm()` method needs access to `blockchainStartTimestamp` and `periodSeconds` parameters through the `ConsensusValidationContext`.

## Proof of Concept

A malicious miner can create a test that demonstrates the vulnerability:

```csharp
[Fact]
public async Task PrematureNextTerm_ShouldFail_ButCurrentlyPasses()
{
    // Setup: Initialize consensus with term duration = 7 days
    await InitializeConsensusAsync();
    
    // Advance only 1 day (much less than required 7 days)
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddDays(1));
    
    // Malicious miner constructs NextTermInput
    var currentRound = await GetCurrentRoundAsync();
    var nextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        // ... other fields
    };
    
    // Call NextTerm prematurely
    var result = await AEDPoSContractStub.NextTerm.SendAsync(nextTermInput);
    
    // BUG: This succeeds when it should fail due to insufficient time elapsed
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed); // Currently PASSES
}
```

This test would pass under the current vulnerable implementation, demonstrating that premature term transitions are not blocked by validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
