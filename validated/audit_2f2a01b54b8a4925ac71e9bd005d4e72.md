# Audit Report

## Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

## Summary
The `CrossChainCreate` method in the NFT contract lacks cross-chain verification, allowing attackers to create unauthorized NFT protocols on sidechains by exploiting legitimately synced tokens. This grants them Creator privileges and minting rights for protocols that never existed on the source chain, breaking cross-chain integrity guarantees.

## Finding Description

The NFT contract's `CrossChainCreate` method creates NFT protocols on sidechains without cryptographic verification that the protocol exists on the source chain. [1](#0-0) 

**Root Cause:**

The method only performs two local checks:
1. Whether the protocol already exists locally [2](#0-1) 
2. Whether the token exists in the local TokenContract state [3](#0-2) 

It then directly assigns the Creator from the token issuer and adds them to the MinterList without any cross-chain proof verification: [4](#0-3) 

**Contrast with Secure Implementation:**

The TokenContract's `CrossChainCreateToken` method properly validates cross-chain operations by calling `CrossChainVerify` with merkle path verification: [5](#0-4) 

The verification method calls the CrossChainContract's `VerifyTransaction` to cryptographically prove the transaction occurred on the source chain: [6](#0-5) 

The input structures demonstrate this disparity. `CrossChainCreateTokenInput` contains fields for source chain ID, parent chain height, transaction bytes, and merkle path: [7](#0-6) 

In contrast, `CrossChainCreateInput` only contains a symbol field with no verification data: [8](#0-7) 

**Attack Execution:**

1. Attacker creates a token on mainchain via `TokenContract.Create` with themselves as issuer, including NFT metadata in ExternalInfo [9](#0-8) 

2. Token is synced to sidechain via legitimate `CrossChainCreateToken` (with proper verification)

3. Attacker calls `NFTContract.CrossChainCreate` on sidechain with the token symbol

4. NFT protocol is created with attacker as Creator and sole minter, despite no corresponding NFT protocol existing on mainchain

The attacker then has full control over minting for that protocol, as the minter check verifies against the MinterList: [10](#0-9) 

Only the Creator can add or remove minters, cementing the attacker's control: [11](#0-10) 

## Impact Explanation

**Severity: High/Critical**

This vulnerability breaks the fundamental cross-chain security guarantee that sidechain NFT protocols are legitimate synchronizations from the mainchain. The `Create` method explicitly restricts NFT protocol creation to mainchain only: [12](#0-11) 

**Concrete Harms:**
1. **Unauthorized Minter Privileges**: Attackers gain exclusive minting rights for NFT protocols that shouldn't exist on sidechains
2. **Protocol Integrity Violation**: Sidechain NFT state diverges from mainchain without any legitimate cross-chain operation
3. **User Deception**: Sidechain users interact with fake NFT protocols believing they're authentic cross-chain synced assets
4. **Economic Losses**: Fake NFTs could be minted, traded, and cause financial harm to users who believe they're acquiring legitimate cross-chain assets
5. **Ecosystem Trust Damage**: Undermines confidence in the entire cross-chain NFT infrastructure

## Likelihood Explanation

**Probability: High**

**Attacker Requirements:**
- Ability to create a token on mainchain (requires seed NFT or whitelist status - seed NFTs are obtainable through normal market operations) [13](#0-12) 
- Ability to call public contract methods (no special privileges required) [14](#0-13) 

**Attack Complexity: Low**
The attack requires only two standard operations:
1. Create a token on mainchain with NFT metadata
2. Call `CrossChainCreate` on sidechain after token synchronization

**Detection Difficulty:**
The attack is difficult to detect because the transaction succeeds normally, events are fired as expected, and the token genuinely exists. Only off-chain comparison with mainchain state would reveal the discrepancy.

## Recommendation

Implement cross-chain verification in `CrossChainCreate` method following the same pattern as `CrossChainCreateToken`:

1. Modify `CrossChainCreateInput` to include verification fields (from_chain_id, parent_chain_height, transaction_bytes, merkle_path)
2. Verify the original NFT protocol creation transaction from the source chain using `CrossChainVerify`
3. Only create the NFT protocol locally after successful verification

This ensures that sidechain NFT protocols are genuine synchronizations from mainchain where the protocol was legitimately created.

## Proof of Concept

Due to the complexity of setting up a full cross-chain test environment, a complete PoC would require:
1. Mainchain setup with token creation
2. Sidechain setup with cross-chain indexing
3. Token synchronization via CrossChainCreateToken
4. Call to CrossChainCreate without corresponding mainchain NFT protocol

The vulnerability is evident from code inspection: `CrossChainCreate` performs no cryptographic verification while `CrossChainCreateToken` does, creating an exploitable security gap in the cross-chain NFT protocol creation flow.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L16-17)
```csharp
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-66)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** protobuf/token_contract.proto (L571-580)
```text
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** protobuf/nft_contract.proto (L25-26)
```text
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
