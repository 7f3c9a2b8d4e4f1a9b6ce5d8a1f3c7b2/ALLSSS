# Audit Report

## Title
Miner Can Manipulate Next Round Order by Setting Invalid SupposedOrderOfNextRound Without Validation

## Summary
The AEDPoS consensus contract allows miners to manipulate their position in the next round's mining order by providing an arbitrary `SupposedOrderOfNextRound` value without validation. The `ProcessUpdateValue` method directly trusts the miner-provided value, and the `NextRoundMiningOrderValidationProvider` validates the wrong round data, enabling miners to bypass deterministic order assignment based on cryptographic signatures.

## Finding Description

The vulnerability consists of two root causes working in combination:

**Root Cause 1: Missing Validation in ProcessUpdateValue**

The `ProcessUpdateValue` method directly assigns `SupposedOrderOfNextRound` from the miner-provided `UpdateValueInput` without validating that it matches the deterministic calculation. [1](#0-0) 

The correct calculation formula exists in `ApplyNormalConsensusData` where `SupposedOrderOfNextRound` should equal `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [2](#0-1) 

The calculation uses the `GetAbsModulus` helper method to ensure deterministic order. [3](#0-2) 

However, `UpdateValueValidationProvider` only checks that `OutValue` and `Signature` are non-empty, but never validates the `SupposedOrderOfNextRound` field matches the signature-derived calculation. [4](#0-3) 

**Root Cause 2: Broken NextRoundMiningOrderValidationProvider**

The `NextRoundMiningOrderValidationProvider` is supposed to validate mining order correctness, but it checks `providedRound` which represents the proposed NEXT round, not the current round. [5](#0-4) 

The `ProvidedRound` property returns the proposed next round from ExtraData. [6](#0-5) 

When `GenerateNextRoundInformation` creates the next round, it generates fresh `MinerInRound` objects that do not have `OutValue` or `FinalOrderOfNextRound` fields populated (they default to null/0). [7](#0-6) 

This causes both validation counts to be 0, making the validation always pass regardless of actual behavior in the current round.

**Exploitation Mechanism**

The attack exploits how `GetMinedMiners()` determines which miners successfully produced blocks by filtering miners with `SupposedOrderOfNextRound != 0`. [8](#0-7) 

Miners with `SupposedOrderOfNextRound == 0` are classified as "not mined" even if they produced blocks. [9](#0-8) 

These "not mined" miners get assigned to arbitrary available order slots and have their `MissedTimeSlots` incorrectly incremented. [10](#0-9) 

A malicious miner can:
1. Produce a valid block with correct `OutValue`, `Signature`, and other required fields
2. Set `SupposedOrderOfNextRound = 0` in their `UpdateValueInput` 
3. Pass all validations since `ProcessUpdateValue` doesn't validate this field
4. When `GenerateNextRoundInformation` is called, be classified as "not mined" despite producing a block
5. Get assigned to an arbitrary available order slot instead of their deterministic `FinalOrderOfNextRound`
6. Have `MissedTimeSlots` incorrectly incremented despite producing blocks

## Impact Explanation

**Consensus Integrity Compromise:**
- Breaks the fundamental guarantee that mining order is deterministically calculated from unpredictable cryptographic signatures
- Enables miners to manipulate their position in the next round, selecting favorable time slots for block production
- Allows coordination with other malicious miners to cluster blocks at advantageous positions
- Incorrectly increments `MissedTimeSlots` for miners who actually produced blocks, corrupting reward calculations and evil miner detection

**Protocol-Wide Effects:**
- Undermines the randomness of mining order assignment that is core to AEDPoS consensus fairness
- Can be used to manipulate Last Irreversible Block (LIB) calculation by controlling block production timing
- Affects evil miner detection mechanisms that rely on accurate `MissedTimeSlots` tracking
- Compromises cross-chain verification that assumes predictable consensus behavior

**Affected Parties:**
- Honest miners who follow deterministic ordering lose their guaranteed time slots
- Reward distribution mechanisms dependent on accurate mining statistics  
- Cross-chain indexing relying on predictable consensus patterns
- Overall network security through consensus manipulation

## Likelihood Explanation

**Trivially Reachable:**
The attack uses the standard `UpdateValue` public method that all miners must call during normal block production. [11](#0-10) 

No special privileges beyond being an active miner are required. The validation is triggered for UpdateValue behavior. [12](#0-11) 

**Low Execution Complexity:**
Exploitation requires only:
1. Modifying the consensus client to set `SupposedOrderOfNextRound = 0` in the `UpdateValueInput` structure (normally extracted from round data) [13](#0-12) 
2. Keeping all other fields valid (`OutValue`, `Signature`, `PreviousInValue`)
3. No timing coordination, no collusion, no economic cost beyond standard block production

**Difficult to Detect:**
- The `UpdateValue` transaction passes all existing validations
- The miner's block is accepted into the chain normally
- Only the next round generation treats them differently
- No error events or failed transactions signal the manipulation  
- The deviation only appears in round transition logic

**High Probability:**
The vulnerability is deterministic - it works every time. Any miner can execute it with minimal sophistication. The benefit (order manipulation) is clear while the risk is essentially zero, making exploitation highly likely once discovered.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that the provided `SupposedOrderOfNextRound` matches the signature-derived calculation:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (minerInRound.Signature == null || minerInRound.SupposedOrderOfNextRound == 0)
        return false;
        
    var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
    var sigNum = minerInRound.Signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}

private static int GetAbsModulus(long longValue, int intValue)
{
    return (int)Math.Abs(longValue % intValue);
}
```

Add this validation check in the `ValidateHeaderInformation` method before returning success.

Additionally, fix `NextRoundMiningOrderValidationProvider` to validate the current round (baseRound) instead of the proposed next round.

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateNextRoundOrderWithZeroSupposedOrder()
{
    // Setup: Initialize consensus with miners
    var miners = await InitializeConsensusAsync();
    var maliciousMiner = miners.First();
    
    // Produce blocks for first round
    await ProduceNormalBlockAsync(maliciousMiner);
    
    // Malicious miner constructs UpdateValue with SupposedOrderOfNextRound = 0
    var currentRound = await GetCurrentRoundInformationAsync();
    var maliciousUpdateInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("valid_out"),
        Signature = await GenerateSignatureAsync(maliciousMiner),
        PreviousInValue = Hash.Empty,
        SupposedOrderOfNextRound = 0, // MALICIOUS: Should be calculated from signature
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        RoundId = currentRound.RoundId
    };
    
    // UpdateValue succeeds despite invalid SupposedOrderOfNextRound
    var result = await maliciousMiner.UpdateValue.SendAsync(maliciousUpdateInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Generate next round
    var nextRoundInput = await GenerateNextRoundInputAsync();
    await miners.First().NextRound.SendAsync(nextRoundInput);
    
    // Verify: Malicious miner is treated as "not mined"
    var nextRound = await GetCurrentRoundInformationAsync();
    var minerInNextRound = nextRound.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()];
    
    // Miner's MissedTimeSlots incorrectly incremented despite producing block
    minerInNextRound.MissedTimeSlots.ShouldBe(1);
    
    // Miner got arbitrary order instead of deterministic order from signature
    var expectedOrder = CalculateExpectedOrder(maliciousUpdateInput.Signature, miners.Count);
    minerInNextRound.Order.ShouldNotBe(expectedOrder);
}
```

## Notes

This vulnerability represents a fundamental breach of the AEDPoS consensus mechanism's security guarantees. The deterministic calculation of mining order based on unpredictable cryptographic signatures is a core property that ensures fairness and prevents manipulation. By allowing miners to arbitrarily set their `SupposedOrderOfNextRound` value, the system loses this critical property.

The combination of missing validation in `ProcessUpdateValue` and the broken `NextRoundMiningOrderValidationProvider` creates a reliable attack vector that any miner can exploit without detection. The impact extends beyond simple order manipulation to affect reward calculations, evil miner detection, and potentially LIB calculation, making this a high-severity consensus vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L45-47)
```csharp
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-17)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L131-135)
```csharp
    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-80)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L43-43)
```csharp
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
```
