# Audit Report

## Title
Time Slot Validation Allows Malicious Round Crafting with Biased Mining Intervals

## Summary
The AEDPoS consensus contract's `CheckRoundTimeSlots()` validation uses a 100% tolerance check that permits mining intervals ranging from 0 to 2× the base interval. An elected miner serving as extra block producer can exploit this by submitting a crafted Round structure with manipulated `ExpectedMiningTime` values that pass validation but disrupt consensus through either DoS (impossibly short intervals) or severe slowdown (excessively long intervals).

## Finding Description

The consensus validation fails to verify that submitted Round information matches the deterministic output of `GenerateNextRoundInformation()`. Instead, validation relies solely on mathematical property checks through `CheckRoundTimeSlots()`. [1](#0-0) 

The tolerance check at line 53 allows any mining interval satisfying `|miningInterval - baseMiningInterval| <= baseMiningInterval`, meaning intervals can range from 0 to 2× the base value. Since `baseMiningInterval` is calculated directly from the first two miners' time difference in the provided Round (lines 43-44), an attacker has full control over this critical parameter.

**Attack Execution:**

1. Malicious miner becomes extra block producer through normal rotation [2](#0-1) 

2. Node legitimately generates Round via `GetConsensusExtraDataForNextRound()` [3](#0-2) 

3. Modified node software alters `ExpectedMiningTime` values before submission (e.g., setting first two miners 1ms apart)

4. During `ValidateBeforeExecution()`, the `TimeSlotValidationProvider` validates only via `CheckRoundTimeSlots()` [4](#0-3) 

5. No validation provider compares the provided Round against expected `GenerateNextRoundInformation()` output [5](#0-4) 

6. Malicious Round stored to state without semantic validation [6](#0-5) 

7. `ValidateAfterExecution()` creates circular validation by comparing header Round hash against state Round hash—but state was just set from the same malicious input during execution [7](#0-6) 

8. Manipulated mining interval propagates throughout consensus [8](#0-7) 

**Why Existing Protections Fail:**

- `MiningPermissionValidationProvider`: Only checks sender is in miner list, not authorization as extra block producer [9](#0-8) 

- `NextRoundMiningOrderValidationProvider`: Only validates `FinalOrderOfNextRound` consistency [10](#0-9) 

- `RoundTerminateValidationProvider`: Only validates round number increment and InValue nullness [11](#0-10) 

- No minimum/maximum bounds enforced on mining intervals [12](#0-11) 

## Impact Explanation

**Critical Consensus Disruption Scenarios:**

1. **DoS via Impossibly Short Intervals**: Setting first two miners 1ms apart creates `baseMiningInterval = 1ms`. CheckRoundTimeSlots allows intervals of 0-2ms. Network latency alone exceeds this threshold, making block production physically impossible and halting consensus entirely.

2. **Severe Slowdown via Extended Intervals**: Setting first two miners 8000ms apart allows intervals up to 16000ms per block (vs normal 4000ms), reducing throughput by 4× and severely degrading network performance.

The mining interval directly controls when miners' time slots expire via `IsTimeSlotPassed()`: [13](#0-12) 

**Affected Parties:**
- All network participants suffer consensus disruption
- Honest miners cannot produce blocks within impossible time windows, losing rewards
- Users experience severe transaction delays or complete service outage
- Network security and liveness guarantees violated

This constitutes **HIGH** severity as a single compromised miner can break consensus integrity for an entire round, affecting all participants.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an elected miner (achievable through legitimate voting)
- Must become extra block producer for a round (rotates deterministically based on signatures)

**Attack Feasibility:**
- **Complexity**: LOW - Attacker modifies node software to craft Round with manipulated `ExpectedMiningTime` values while staying within 100% tolerance
- **Frequency**: Occurs whenever malicious miner becomes extra block producer (regular rotation)
- **Detection**: DIFFICULT - No on-chain mechanism verifies semantic correctness against `GenerateNextRoundInformation()` output

The attack is **repeatable and deterministic**—any compromised miner eventually gains opportunity through normal protocol rotation.

**Likelihood Assessment**: MEDIUM-HIGH

## Recommendation

Implement semantic validation that regenerates expected Round information and compares it against provided data:

```csharp
// In TimeSlotValidationProvider.ValidateHeaderInformation or new dedicated provider
if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
{
    // Generate expected Round using same algorithm as GetConsensusExtraDataForNextRound
    validationContext.BaseRound.GenerateNextRoundInformation(
        validationContext.CurrentBlockTime,
        validationContext.BlockchainStartTimestamp,
        out var expectedRound);
    
    // Compare critical fields: ExpectedMiningTime for all miners
    foreach (var miner in expectedRound.RealTimeMinersInformation)
    {
        if (!validationContext.ProvidedRound.RealTimeMinersInformation.ContainsKey(miner.Key))
            return new ValidationResult { Message = "Missing miner in provided round" };
            
        var expectedTime = miner.Value.ExpectedMiningTime;
        var providedTime = validationContext.ProvidedRound.RealTimeMinersInformation[miner.Key].ExpectedMiningTime;
        
        if (expectedTime != providedTime)
            return new ValidationResult { Message = "ExpectedMiningTime mismatch detected" };
    }
}
```

Additionally, enforce minimum mining interval bounds in `AEDPoSContractConstants`:
```csharp
public const int MinimumMiningIntervalMs = 2000; // 2 seconds minimum
public const int MaximumMiningIntervalMs = 10000; // 10 seconds maximum
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousRound_WithManipulatedMiningInterval_PassesValidation()
{
    // Setup: Initialize consensus with normal miners
    await InitializeConsensus();
    var maliciousMiner = Miners[0]; // Assume becomes extra block producer
    
    // Attacker crafts malicious Round with 1ms mining interval
    var currentRound = await GetCurrentRound();
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    var baseTime = TimestampHelper.GetUtcNow();
    // Set first two miners only 1ms apart - creates baseMiningInterval = 1ms
    maliciousRound.RealTimeMinersInformation[Miners[0]] = new MinerInRound
    {
        Pubkey = Miners[0],
        Order = 1,
        ExpectedMiningTime = baseTime
    };
    maliciousRound.RealTimeMinersInformation[Miners[1]] = new MinerInRound
    {
        Pubkey = Miners[1],
        Order = 2,
        ExpectedMiningTime = baseTime.AddMilliseconds(1) // Only 1ms gap!
    };
    
    // Submit NextRound with malicious Round
    var result = await maliciousMiner.NextRound(new NextRoundInput
    {
        RoundNumber = maliciousRound.RoundNumber,
        RealTimeMinersInformation = { maliciousRound.RealTimeMinersInformation }
    });
    
    // Assertion: Transaction succeeds despite malicious interval
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify malicious interval is now in state
    var storedRound = await GetCurrentRound();
    var storedInterval = storedRound.GetMiningInterval();
    storedInterval.ShouldBe(1); // 1ms interval accepted - consensus DoS achieved
}
```

## Notes

The vulnerability exploits the gap between mathematical validation (CheckRoundTimeSlots tolerance checks) and semantic validation (verifying Round matches deterministic generation). The circular nature of ValidateAfterExecution—comparing state against header after state was already set from header—provides no protection. The attack requires only that a malicious actor become an elected miner and wait for their turn as extra block producer, making it realistic and repeatable.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-54)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-16)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
    public const long TimeToReduceMiningRewardByHalf = 126144000; // 60 * 60 * 24 * 365 * 4
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
    public const string SecretSharingEnabledConfigurationKey = "SecretSharingEnabled";
}
```
