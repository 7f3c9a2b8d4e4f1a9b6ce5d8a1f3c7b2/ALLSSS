# Audit Report

## Title
Unvalidated Decrypted Secret Pieces Enable Secret Sharing Corruption in AEDPoS Consensus

## Summary
The AEDPoS consensus contract accepts and stores decrypted secret pieces from miners without cryptographic validation, allowing any malicious miner to inject arbitrary data that corrupts the Shamir's Secret Sharing reconstruction mechanism. This breaks the Byzantine fault tolerance guarantees of the threshold secret sharing scheme and compromises consensus randomness.

## Finding Description

The vulnerability exists in the secret sharing mechanism where decrypted pieces are accepted without validation. When a miner produces a block, they provide trigger information containing `DecryptedPieces` that claim to be decryptions of other miners' encrypted secret shares.

**Root Cause:**

The `UpdateLatestSecretPieces()` method stores decrypted pieces with only a basic existence check: [1](#0-0) 

The function only verifies that the target miner exists in `RealTimeMinersInformation`, but performs NO cryptographic validation that:
1. The decrypted piece is a legitimate decryption of an encrypted piece
2. The submitting miner actually received an encrypted piece from the target miner
3. The decrypted value corresponds to any previously submitted encrypted piece

**Exploitation Flow:**

During block production, `GetConsensusExtraDataToPublishOutValue()` invokes `UpdateLatestSecretPieces()` when secret sharing is enabled: [2](#0-1) 

A malicious miner with modified node software can inject arbitrary `DecryptedPieces` in the trigger information. The trigger information structure contains a `decrypted_pieces` map with no cryptographic proof: [3](#0-2) 

During the next round transition, `RevealSharedInValues()` reconstructs InValues using ALL submitted decrypted pieces without validating they produce the correct result: [4](#0-3) 

The function uses `SecretSharingHelper.DecodeSecret()` with potentially corrupted pieces, producing wrong reconstructed InValues that are set as `PreviousInValue` without validation against the original `OutValue`.

**Why Existing Protections Fail:**

The only validation that exists is in `UpdateValueValidationProvider`, which validates when a miner submits their OWN `PreviousInValue`: [5](#0-4) 

However, this validation is ONLY applied during `UpdateValue` behavior: [6](#0-5) 

It does NOT apply to `PreviousInValues` revealed through secret sharing reconstruction in `RevealSharedInValues()`, which occurs during `NextRound` behavior: [7](#0-6) 

Similarly, in `PerformSecretSharing()` which processes the transaction-based secret sharing, decrypted pieces are stored without validation: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Violation:**

The `PreviousInValue` is used in signature calculations that determine the mining order for the next round. When a miner provides their own `PreviousInValue`, the signature is calculated: [9](#0-8) 

Corrupted `PreviousInValue` leads to manipulated signatures, allowing attackers to influence:
- Miner ordering for subsequent rounds
- The consensus randomness beacon
- Overall fairness of the consensus mechanism

**Secret Sharing Security Break:**

The threshold secret sharing scheme is designed to tolerate up to 1/3 Byzantine miners (minimum threshold is `minersCount * 2 / 3`): [10](#0-9) 

However, this vulnerability allows a SINGLE malicious miner to inject fake pieces that corrupt reconstruction for ALL target miners, completely breaking the Byzantine fault tolerance guarantee.

**Denial of Service:**

When secret sharing is enabled (checked via configuration): [11](#0-10) 

Legitimate miners' InValues cannot be properly revealed, causing the consensus mechanism to degrade. This affects network-wide consensus operation.

**Severity: Critical** - Breaks fundamental consensus security properties with minimal attack complexity.

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the consensus set (feasible - miners exist by design)
- No special privileges required beyond normal mining rights
- Attacker controls their own node software

**Attack Complexity: LOW**
- Simply inject arbitrary data in `triggerInformation.DecryptedPieces` during block production
- The trigger information is created off-chain by the miner's node software
- No cryptographic operations needed by attacker
- No coordination with other actors required

**Feasibility Conditions:**
- Secret sharing must be enabled (configuration check exists but is routinely enabled)
- Attacker produces at least one block in the round (normal miner operation)

**Detection Difficulty: HIGH**
- No on-chain validation to detect malicious pieces
- Off-chain services decrypt pieces correctly but cannot prevent on-chain corruption
- Requires analyzing revealed InValues against original OutValues to detect manipulation

**Economic Rationality:**
- Near-zero cost (part of normal block production)
- High impact (disrupts consensus for entire network)
- Risk/reward heavily favors attack

## Recommendation

Add cryptographic validation to ensure reconstructed InValues match the original OutValues. Modify `RevealSharedInValues()` to validate the reconstructed secret:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... existing checks ...
        
        var revealedInValue =
            HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
        
        // ADD VALIDATION: Verify Hash(reconstructed InValue) == OutValue
        if (HashHelper.ComputeFrom(revealedInValue) != anotherMinerInPreviousRound.OutValue)
        {
            Context.LogDebug(() => $"Invalid secret sharing reconstruction for {publicKeyOfAnotherMiner}");
            continue; // Skip invalid reconstruction
        }
        
        currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
    }
}
```

Additionally, consider adding validation in `UpdateLatestSecretPieces()` and `PerformSecretSharing()` to verify decrypted pieces correspond to previously stored encrypted pieces.

## Proof of Concept

A proof of concept would require:
1. Setting up an AEDPoS test environment with secret sharing enabled
2. Modifying miner node software to inject arbitrary `DecryptedPieces` in `AElfConsensusTriggerInformation`
3. Producing a block with the malicious trigger information
4. Observing during the next round transition that wrong `PreviousInValue` is set
5. Verifying that `HashHelper.ComputeFrom(PreviousInValue) != OutValue`, breaking the invariant
6. Demonstrating the impact on signature calculation and miner ordering

The test would demonstrate that the contract accepts and uses arbitrary decrypted pieces without validation, corrupting the secret sharing reconstruction mechanism.

## Notes

This vulnerability is particularly severe because:
1. The off-chain `SecretSharingService` performs legitimate encryption/decryption, but the on-chain contract trusts the submitted data without validation
2. The invariant `Hash(InValue) = OutValue` is critical for consensus security and is validated only when miners provide their own InValue, not when it's reconstructed via secret sharing
3. The attack requires no cryptographic expertise - simply modifying node software to inject arbitrary bytes
4. A single malicious miner can corrupt reconstruction for all other miners, defeating the Byzantine fault tolerance design of threshold secret sharing

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** protobuf/aedpos_contract.proto (L340-341)
```text
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 6;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```
