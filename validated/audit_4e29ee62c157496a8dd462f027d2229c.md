# Audit Report

## Title
Inconsistent Time Slot Validation Allows Consensus Disruption via Non-Uniform Mining Intervals

## Summary
The AEDPoS consensus contract contains a critical validation flaw where `CheckRoundTimeSlots` permits mining intervals up to 2x the base interval, while `GetMiningInterval` only examines the first two miners. This mismatch allows any miner to inject non-uniform round data that passes validation but causes consensus disruption by creating time windows where no miner is considered valid, halting block production.

## Finding Description

The vulnerability stems from three interconnected flaws in the consensus round validation and consumption logic:

**Root Cause 1: Overly Permissive Tolerance Check**

The `CheckRoundTimeSlots` method uses a tolerance check that allows intervals to deviate up to the base interval. [1](#0-0) 

The condition `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval` only fails when the absolute difference **exceeds** the base interval. An interval of exactly 2x the base (where difference equals the base) passes validation because the comparison uses `>` instead of `>=`.

**Root Cause 2: Limited Interval Calculation Scope**

The `GetMiningInterval` method only examines miners with `Order == 1 || Order == 2`. [2](#0-1) 

This creates a fundamental mismatch: validation checks all consecutive pairs, but the returned interval only reflects the first two miners' spacing.

**Root Cause 3: No Canonical Round Verification**

The `PreCheck` method only verifies the transaction sender is in the miner list. [3](#0-2) 

The validation providers for `NextRound` behavior include `TimeSlotValidationProvider`, `NextRoundMiningOrderValidationProvider`, and `RoundTerminateValidationProvider`. [4](#0-3) 

None verify that the submitted `NextRoundInput` matches the canonical output of `GenerateNextRoundInformation`, which always produces uniform intervals. [5](#0-4) 

**Exploitation Path:**

1. Attacker crafts `NextRoundInput` with non-uniform intervals (e.g., 4000ms, 8000ms pattern)
2. Validation via `TimeSlotValidationProvider` calls `CheckRoundTimeSlots` [6](#0-5) 
3. With baseMiningInterval=4000ms, an 8000ms interval passes: |8000-4000|=4000, and 4000>4000 is false
4. Round accepted via `ProcessNextRound` [7](#0-6) 

**Downstream Impact:**

Functions that depend on `GetMiningInterval()` break with non-uniform data:

1. **IsCurrentMiner** calculates time windows incorrectly [8](#0-7) 
   - For a miner with actual 8000ms interval, but `GetMiningInterval()` returning 4000ms
   - Creates time gaps where no miner is considered valid â†’ block production halts

2. **IsTimeSlotPassed** uses wrong interval [9](#0-8) 
   - Prematurely marks slots as passed

3. **ArrangeAbnormalMiningTime** calculates incorrect future times [10](#0-9) 
   - Wrong scheduling for recovery

## Impact Explanation

**Severity: High - Complete Consensus DoS**

The vulnerability enables a malicious miner to create time windows where the consensus system cannot identify any valid block producer, causing complete block production failure. This breaks the fundamental consensus guarantee that there is always exactly one valid miner for any given time slot.

The attack affects all network participants:
- Network-wide block production halt during gap periods
- Chain liveness violation - no new blocks produced
- Transaction processing stoppage
- Violation of consensus invariants: "uniform time slot" and "continuous miner schedule"

The impact is particularly severe because:
1. Attack is deterministic and repeatable every round
2. Affects ALL nodes simultaneously (consensus-level issue)
3. Requires only single malicious miner
4. No automatic recovery mechanism within affected round

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a valid miner (common - multiple miners exist)
- Can submit transactions to consensus contract (standard capability)

**Attack Complexity: Low**
- Exploitation is deterministic at exactly 2x base interval boundary
- No timing constraints or race conditions
- Single transaction execution
- No coordination needed

**Feasibility: High**
- Any miner can craft custom `NextRoundInput` via public `NextRound` method [11](#0-10) 
- No additional authorization beyond miner status
- Validation providers do not verify canonical generation

## Recommendation

Fix the three root causes:

1. **Strengthen tolerance check** - Change to `>=` to reject intervals at exactly 2x base:
```csharp
if (Math.Abs(miningInterval - baseMiningInterval) >= baseMiningInterval)
    return new ValidationResult { Message = "Time slots are so different." };
```

2. **Validate all intervals** - Ensure `GetMiningInterval` reflects actual round uniformity or validate separately

3. **Add canonical verification** - Create a validator that verifies submitted `NextRoundInput` matches the output of `GenerateNextRoundInformation` for the current state

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a consensus round with 3+ miners
2. Call `NextRound` with a malicious `NextRoundInput` containing intervals [4000ms, 4000ms, 8000ms]
3. Verify the round passes `CheckRoundTimeSlots` validation
4. Demonstrate `GetMiningInterval()` returns 4000ms
5. Show `IsCurrentMiner()` creates time gaps where it returns false for all miners during certain periods

The core issue is that the validation logic permits non-uniform intervals up to 2x the base, while consumption logic assumes uniformity based only on the first two miners, creating exploitable inconsistency.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L49-55)
```csharp
        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-36)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-167)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
