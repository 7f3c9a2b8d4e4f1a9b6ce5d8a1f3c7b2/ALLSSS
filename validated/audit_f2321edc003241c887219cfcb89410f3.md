# Audit Report

## Title
Hex String Case Sensitivity Bypass in Consensus Round Transitions Enables Complete Blockchain Halt

## Summary
The AEDPoS consensus contract fails to normalize hexadecimal string casing when processing `NextRoundInput`, allowing an authorized miner to inject uppercase public key strings into the round state. This causes a fatal mismatch with the lowercase keys produced by the `ToHex()` method, permanently blocking all subsequent miners from mining and halting consensus indefinitely.

## Finding Description

The vulnerability arises from a case sensitivity mismatch in the consensus round transition logic. The `ToHex()` extension method deterministically produces lowercase hexadecimal strings by adding `0x20` to convert uppercase ASCII values to lowercase. [1](#0-0) 

When miners produce blocks, their public keys are recovered and converted to hex strings using this method, guaranteeing lowercase output. [2](#0-1) 

The `NextRound` method is publicly accessible and accepts `NextRoundInput` containing a protobuf map of miner public keys to miner information. [3](#0-2) 

The `NextRoundInput.ToRound()` method performs a direct field copy without any case normalization. [4](#0-3) 

The authorization check in `PreCheck()` validates the sender's recovered public key (lowercase) against the **current** round's miner list, but does not validate the public key strings **within** the incoming `NextRoundInput`. [5](#0-4) 

After passing authorization, `ProcessNextRound` stores the new round directly without case normalization via `AddRoundInformation()`. [6](#0-5) [7](#0-6) 

### Attack Execution Path

1. **Attacker prerequisites**: Attacker controls a current miner (has a legitimate slot in the current round with lowercase pubkey)
2. **Malicious transaction**: Attacker crafts a `NextRoundInput` with uppercase public key strings instead of the standard lowercase format
3. **Authorization bypass**: `PreCheck()` validates the attacker's recovered pubkey (lowercase) against current round (lowercase) - passes âœ“
4. **Validation bypass**: No validator checks pubkey case in the incoming round data
5. **State corruption**: New round is stored with uppercase public keys via `AddRoundInformation()`
6. **Consensus failure**: All subsequent miners attempt to produce blocks, but their recovered pubkeys (lowercase via `ToHex()`) fail the `IsInMinerList()` check because the stored round has uppercase keys

The `IsInMinerList()` method performs case-sensitive dictionary key lookup. [8](#0-7) 

The mining permission validator also performs case-sensitive key lookup, causing all miners to be rejected. [9](#0-8) 

Additionally, `GetMinerReplacementInformation` in the Election contract uses case-sensitive `Contains()` checks that would fail to properly filter miners if case mismatches occur. [10](#0-9) 

## Impact Explanation

**Critical Severity - Complete Blockchain Halt**

This vulnerability enables a single malicious or compromised miner to permanently halt the entire blockchain. Once uppercase public keys are stored in a round:

1. **Immediate consensus DoS**: All miners (including the attacker) are locked out because their recovered public keys (lowercase) don't match the stored uppercase keys
2. **Irreversible without hard fork**: The corrupted round state is committed to the blockchain. Normal operations cannot recover since no miner can pass authorization
3. **No automatic recovery**: Unlike temporary network issues, this is a persistent state corruption that breaks the fundamental consensus mechanism
4. **Affects all chain operations**: Token transfers, contract calls, governance - everything stops when blocks stop being produced

The attack breaks the core security guarantee of consensus availability and violates the invariant that authorized miners in the current round can produce blocks in the next round.

## Likelihood Explanation

**High Likelihood of Exploitation**

**Attacker Requirements:**
- Must be an authorized miner in the current round (moderate barrier)
- Must be able to craft custom transactions (trivial for any miner)
- Must wait for their designated time slot (guaranteed in normal operation)

**Attack Complexity:** Very Low
- Requires only changing hex string casing in a single transaction
- No sophisticated cryptography, timing attacks, or race conditions
- Standard transaction submission through normal node RPC

**Feasibility Scenarios:**
1. **Compromised miner keys**: If an attacker gains control of any miner's private key, they can execute this attack
2. **Malicious insider**: A validator with malicious intent can trivially DOS their own chain
3. **Software bugs**: A buggy mining client that accidentally uses uppercase hex strings would trigger this
4. **Cross-chain incentive misalignment**: In multi-chain scenarios, attacking one chain might benefit another

**Detection:**
The attack would be immediately obvious (consensus stops), but by then it's too late - the corrupted state is already committed to the blockchain.

While the economic rationality of a miner attacking their own chain is questionable, the **defense-in-depth** principle mandates that the code should validate and normalize user inputs regardless of trust assumptions. The trivial attack complexity and catastrophic impact make this a critical vulnerability.

## Recommendation

Normalize all public key strings to lowercase when processing `NextRoundInput` and `NextTermInput`. Add validation in the `ToRound()` method or in `ProcessNextRound()` before storing:

```csharp
public Round ToRound()
{
    var normalizedMinersInfo = new Dictionary<string, MinerInRound>();
    foreach (var kvp in RealTimeMinersInformation)
    {
        // Normalize keys to lowercase
        var normalizedKey = kvp.Key.ToLower();
        normalizedMinersInfo[normalizedKey] = kvp.Value;
    }
    
    return new Round
    {
        RoundNumber = RoundNumber,
        RealTimeMinersInformation = { normalizedMinersInfo },
        // ... rest of fields
    };
}
```

Alternatively, add validation in `PreCheck()` to verify that all public keys in the incoming input match the expected lowercase format, rejecting the transaction if any uppercase characters are detected in the keys.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithUppercasePublicKeys_ShouldHaltConsensus()
{
    // Setup: Initialize consensus with legitimate lowercase miners
    var miners = new[] { "abc123...", "def456..." }; // lowercase
    await InitializeConsensusWithMiners(miners);
    
    // Attack: Craft NextRoundInput with UPPERCASE keys
    var maliciousInput = new NextRoundInput();
    foreach (var miner in miners)
    {
        maliciousInput.RealTimeMinersInformation["ABC123..."] = new MinerInRound(); // uppercase
    }
    
    // Execute attack as authorized miner
    await ConsensusContract.NextRound(maliciousInput);
    
    // Verify: All subsequent mining attempts should fail
    foreach (var miner in miners)
    {
        var canMine = await ConsensusContract.IsCurrentMiner(Address.FromPublicKey(miner));
        Assert.False(canMine); // All miners locked out due to case mismatch
    }
    
    // Consensus is now permanently halted
}
```

### Citations

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L25-28)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```
