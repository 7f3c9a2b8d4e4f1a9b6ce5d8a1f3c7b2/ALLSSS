# Audit Report

## Title
Consensus Permanent DoS via Unconstrained LIB Injection in NextTerm/NextRound Transactions

## Summary
The AEDPoS consensus contract lacks Last Irreversible Block (LIB) validation for `NextTerm` and `NextRound` transaction behaviors. A malicious miner can inject arbitrarily high `ConfirmedIrreversibleBlockHeight` values during term/round transitions, permanently corrupting consensus state and halting all block production until a hard fork is deployed.

## Finding Description

The AEDPoS consensus contract applies different validation providers based on transaction behavior. The critical security issue lies in the asymmetric validation applied to different consensus behaviors.

For `UpdateValue` behavior, the validation correctly includes `LibInformationValidationProvider` which ensures LIB values cannot decrease: [1](#0-0) 

However, for `NextTerm` behavior, only `RoundTerminateValidationProvider` is applied without LIB validation: [2](#0-1) 

Similarly, `NextRound` behavior only applies `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`: [3](#0-2) 

The `RoundTerminateValidationProvider` only validates round/term number increments and InValue nullness, completely omitting LIB validation: [4](#0-3) 

When processing `NextTerm`, the transaction input's LIB values are directly copied to the new round without any validation through the `ToRound()` method: [5](#0-4) 

This corrupted round is then persisted to blockchain state: [6](#0-5) 

The same vulnerability exists in `NextRound` processing where the input's LIB is copied without validation: [7](#0-6) 

Once the LIB is corrupted with an arbitrarily high value, all subsequent `UpdateValue` transactions fail validation because `LibInformationValidationProvider` explicitly rejects backward LIB movement: [8](#0-7) 

This creates a permanent consensus deadlock through the following mechanism:

When a miner's `OutValue` is `null` (first block in their time slot), the consensus behavior determination logic returns `UpdateValue` behavior: [9](#0-8) 

Specifically, `HandleMinerInNewRound()` returns `UpdateValue` if the time slot hasn't passed: [10](#0-9) 

The `UpdateValue` transaction fails validation because the corrupted baseRound LIB exceeds the real providedRound LIB. Without `UpdateValue` succeeding, `OutValue` remains `null`. Critically, `TinyBlock` production requires `OutValue != null`: [11](#0-10) 

With no path to set `OutValue` and no ability to produce `TinyBlock`, no blocks can be produced, resulting in complete consensus halt.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability enables a complete denial-of-service attack on the entire blockchain with permanent consequences:

- **Blockchain Halt:** All block production ceases immediately once miners attempt to produce blocks after the corrupted term/round transition
- **Transaction Impossibility:** No transactions can be included in blocks, effectively freezing all on-chain activity including token transfers, smart contract executions, and governance operations
- **Hard Fork Required:** The only recovery mechanism is deploying a hard fork with corrected state, requiring coordinated emergency response across all validators and node operators
- **Economic Damage:** All trading, DeFi operations, NFT transactions, and business operations dependent on the blockchain are halted indefinitely
- **No Automated Recovery:** Unlike temporary network issues, this corruption is permanent in the blockchain state with no self-healing mechanism

The attack breaks the fundamental consensus invariant that Last Irreversible Block height must monotonically increase. Once violated through state corruption rather than legitimate consensus progression, the system cannot self-recover because the validation logic that would normally prevent regression now prevents any forward progress.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible with minimal barriers:

**Attacker Prerequisites:**
- Must be an active miner in the current consensus round
- Miners are elected through governance voting, making this a realistic semi-privileged threat model
- Multiple miners typically exist in production deployments, increasing attack surface

**Attack Complexity: LOW**
1. Wait for legitimate term/round transition period (deterministic timing)
2. Call `GenerateConsensusTransactions` to obtain structurally valid `NextTermInput`/`NextRoundInput`
3. Modify the `ConfirmedIrreversibleBlockHeight` field to a very high value (e.g., `Int64.MaxValue - 1000`)
4. Sign and submit the modified transaction

**Technical Feasibility:**
- No cryptographic challenges or complex timing races required
- Validation gap is systematic and architectural, not a rare race condition
- Attack is deterministic and 100% reproducible
- Transaction structure appears valid during pre-execution validation
- Corruption only manifests when subsequent miners attempt block production
- No special network conditions or coordination required

**Economic Cost:** Minimal (only standard transaction gas fees, no staking or collateral loss)

**Detection Difficulty:** The malicious transaction may appear normal during validation since `RoundTerminateValidationProvider` only checks round/term numbers. Corruption becomes apparent only when all miners fail to produce blocks in the next round, by which point the corrupted state is already persisted on-chain.

## Recommendation

Add `LibInformationValidationProvider` to the validation providers for both `NextRound` and `NextTerm` behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

This ensures that LIB values in `NextTerm` and `NextRound` transactions are validated with the same monotonicity constraints as `UpdateValue` transactions, preventing malicious miners from injecting corrupted LIB values during term/round transitions.

Additionally, consider adding explicit bounds checking for LIB values to prevent injection of unrealistic values like `Int64.MaxValue`.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousLIBInjection_PermanentConsensusHalt()
{
    // Setup: Normal consensus operation with miner
    var miner = SampleAccount.Accounts.First().KeyPair;
    var currentRound = await GetCurrentRound();
    
    // Attack: Craft malicious NextTermInput with inflated LIB
    var maliciousInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        ConfirmedIrreversibleBlockHeight = long.MaxValue - 1000, // Malicious value
        ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber,
        // ... other valid fields
        RandomNumber = HashHelper.ComputeFrom("test").ToByteString()
    };
    
    // Execute malicious NextTerm (passes validation - no LIB check)
    await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    
    // Verify: Corrupted LIB persisted
    var newRound = await GetCurrentRound();
    newRound.ConfirmedIrreversibleBlockHeight.ShouldBe(long.MaxValue - 1000);
    
    // Attempt subsequent UpdateValue (should fail validation)
    var updateValueResult = await ConsensusStub.UpdateValue.SendWithExceptionAsync(new UpdateValueInput
    {
        // ... valid fields with real LIB
        ImpliedIrreversibleBlockHeight = 100000 // Real LIB << corrupted LIB
    });
    
    // Verify: Permanent consensus deadlock
    updateValueResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    updateValueResult.TransactionResult.Error.ShouldContain("Incorrect lib information");
    
    // All subsequent block production attempts will fail similarly
    // Consensus is permanently halted until hard fork
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-56)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-63)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L92-115)
```csharp
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
        }
```
