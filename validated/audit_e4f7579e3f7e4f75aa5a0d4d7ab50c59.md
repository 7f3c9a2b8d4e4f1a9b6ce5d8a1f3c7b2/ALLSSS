# Audit Report

## Title
Precision Loss in Individual Beneficiary Profit Claims Locks Tokens Permanently

## Summary
The Profit Contract's `SafeCalculateProfits()` function performs decimal-to-long conversion with truncation when calculating individual beneficiary shares. When multiple beneficiaries claim from the same period, the sum of their truncated claims is less than the total distributed amount, permanently locking the remainder in period-specific virtual addresses with no recovery mechanism.

## Finding Description

The root cause lies in the `SafeCalculateProfits()` function which converts long integers to decimal, performs division, and casts back to long with truncation: [1](#0-0) 

This function is used in two contexts with different security outcomes:

**1. Sub-scheme distribution (safe):** When distributing to sub-schemes via `DistributeProfitsForSubSchemes()`, the code tracks `remainAmount` after each truncated calculation and transfers any remainder to the period's virtual address for individual beneficiaries: [2](#0-1) 

The remainder is then transferred to the period virtual address: [3](#0-2) 

**2. Individual beneficiary claims (vulnerable):** When beneficiaries claim their profits via `ProfitAllPeriods()`, each claim is calculated independently without any remainder tracking. Each beneficiary receives their truncated share: [4](#0-3) 

Specifically, line 873 calculates the amount using the truncating function, and lines 887-895 transfer this amount from the period's virtual address to the beneficiary. There is no mechanism to aggregate claims or verify that the sum equals the distributed total.

**Why tokens become permanently locked:**

Each period has a unique virtual address generated by hashing the scheme ID and period number: [5](#0-4) 

When `DistributeProfits` is called, it creates a `DistributedProfitsInfo` containing the total amount and total shares for that period's virtual address. Each beneficiary then independently calculates their truncated share from these fixed values. Once all beneficiaries have claimed, any remainder due to truncation stays locked in the period's virtual address permanently because:

1. No new beneficiaries can be added to past periods (beneficiaries are added with `StartPeriod = CurrentPeriod + DelayDistributePeriodCount`)
2. No admin rescue function exists to recover funds from period virtual addresses
3. The virtual address is derived cryptographically with no private key
4. Beneficiaries cannot claim multiple times from the same period

## Impact Explanation

**Direct Fund Loss:**
Tokens are permanently locked and removed from circulation. For example, with 3 beneficiaries holding 1 share each (total 3 shares) claiming from a period that distributed 100 tokens:
- Each beneficiary receives: `(long)(100 * 1 / 3)` = `(long)(33.333...)` = 33 tokens
- Total claimed: 99 tokens
- **Permanently locked: 1 token in the period's virtual address**

**Systemic Scale:**
- Occurs in every distribution period where `(totalAmount * shares / totalShares)` produces a remainder
- Common scenarios: odd numbers of equal beneficiaries, any shares that don't evenly divide amounts
- Affects most profit schemes in practice
- Accumulates across hundreds of schemes over thousands of periods
- Could lock millions of tokens protocol-wide over time

**Affected Parties:**
- All beneficiaries collectively lose the locked remainder
- Protocol loses economic efficiency as tokens are removed from circulation
- Token utility degrades as supply effectively decreases

## Likelihood Explanation

**Probability: HIGH**

This vulnerability triggers automatically during normal profit distribution operations without any attacker action:

1. **Entry point:** Any beneficiary calling `ClaimProfits()` via the public method: [6](#0-5) 

2. **Mathematical certainty:** Occurs whenever shares don't evenly divide amounts, which is common in typical profit distribution scenarios

3. **No special privileges required:** All beneficiaries can claim their profits normally

4. **Frequency:** Affects every profit distribution period where division produces a non-zero remainder after truncation

## Recommendation

Implement one of the following solutions:

**Option 1: Accumulate remainder for last claimer**
Track claimed amounts for each period and award any remainder to the last beneficiary who claims:
- Store `totalClaimed` in `DistributedProfitsInfo`
- When last beneficiary claims, give them `totalAmount - totalClaimed` instead of truncated calculation
- Ensures all funds are distributed

**Option 2: Use higher precision arithmetic**
Use a larger integer type (e.g., multiply by 10^18 before division, then divide after) to minimize precision loss:
- Calculate: `(totalAmount * 10^18 * shares / totalShares) / 10^18`
- Reduces but doesn't eliminate rounding errors

**Option 3: Admin rescue function**
Add a governance-controlled function to rescue remaining tokens from period virtual addresses after a sufficient time delay to ensure all legitimate claims are complete.

**Recommended approach:** Option 1 provides complete protection with minimal gas overhead and ensures perfect distribution accuracy.

## Proof of Concept

```csharp
[Fact]
public async Task PrecisionLoss_LocksTokens_Test()
{
    const long totalAmount = 100;
    const long sharesPerBeneficiary = 1;
    const int beneficiaryCount = 3;
    
    var creator = Creators[0];
    var schemeId = await CreateSchemeAsync();
    
    // Add 3 beneficiaries with 1 share each
    for (int i = 0; i < beneficiaryCount; i++)
    {
        await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
        {
            SchemeId = schemeId,
            BeneficiaryShare = new BeneficiaryShare 
            { 
                Beneficiary = Accounts[i].Address, 
                Shares = sharesPerBeneficiary 
            }
        });
    }
    
    // Contribute and distribute profits
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = totalAmount,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, totalAmount } }
    });
    
    // All beneficiaries claim
    long totalClaimed = 0;
    for (int i = 0; i < beneficiaryCount; i++)
    {
        var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(
            new GetBalanceInput
            {
                Owner = Accounts[i].Address,
                Symbol = ProfitContractTestConstants.NativeTokenSymbol
            })).Balance;
            
        await ProfitStubs[i].ClaimProfits.SendAsync(new ClaimProfitsInput
        {
            SchemeId = schemeId,
            Beneficiary = Accounts[i].Address
        });
        
        var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(
            new GetBalanceInput
            {
                Owner = Accounts[i].Address,
                Symbol = ProfitContractTestConstants.NativeTokenSymbol
            })).Balance;
            
        totalClaimed += (balanceAfter - balanceBefore);
    }
    
    // Verify tokens are locked: totalClaimed should be 99, not 100
    totalClaimed.ShouldBe(99);
    
    // Check period virtual address still holds the locked token
    var periodVirtualAddress = await creator.GetSchemeAddress.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = 1 });
        
    var lockedBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput
        {
            Owner = periodVirtualAddress,
            Symbol = ProfitContractTestConstants.NativeTokenSymbol
        })).Balance;
        
    // 1 token permanently locked
    lockedBalance.ShouldBe(1);
}
```

**Notes:**
- This vulnerability affects the core economic distribution mechanism of AElf
- The precision loss is deterministic and occurs in normal operations
- No attacker is needed - it's an inherent flaw in the distribution math
- The locked tokens accumulate over time across all profit schemes
- The issue cannot be mitigated by beneficiaries or scheme managers without a contract upgrade

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-809)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }

        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```
