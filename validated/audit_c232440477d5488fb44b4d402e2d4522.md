# Audit Report

## Title
Reserved External Info Key Collision Enables Arbitrary Contract Execution During Token Operations

## Summary
The MultiToken contract accepts user-provided ExternalInfo during token creation without validating against reserved callback keys. Attackers can create tokens with malicious callbacks that execute automatically during transfer, lock, and unlock operations, enabling denial-of-service attacks, gas exhaustion, and potential reentrancy exploitation.

## Finding Description

The vulnerability exists in the token creation flow where user-provided ExternalInfo is accepted without validation. The `CreateToken` method directly assigns user input to the token's ExternalInfo without checking for reserved keys: [1](#0-0) 

The system defines four reserved callback keys intended for system use: [2](#0-1) 

A view function `GetReservedExternalInfoKeyList` exposes these keys, confirming they are considered special: [3](#0-2) 

However, no validation occurs during token creation to prevent users from setting these reserved keys. When tokens are transferred, the contract unconditionally executes any callback specified in ExternalInfo: [4](#0-3) 

Similar callback execution occurs during lock operations: [5](#0-4) 

And unlock operations: [6](#0-5) 

The CallbackInfo structure allows specifying arbitrary contract addresses and method names: [7](#0-6) 

The transfer flow demonstrates the vulnerability: [8](#0-7) 

## Impact Explanation

**Guaranteed Denial of Service (HIGH)**: An attacker can create a token with a callback that reverts. Any user attempting to transfer, lock, or unlock this malicious token will have their transaction fail. This is a straightforward, easily exploitable DoS that affects all holders of the malicious token.

**Gas Exhaustion (HIGH)**: Callbacks can contain expensive operations, forcing victims to pay excessive gas fees for attacker-controlled code execution during routine token operations.

**Reentrancy Risk (MEDIUM-HIGH)**: Callbacks execute via `Context.SendInline()` during the middle of token operations, creating a reentrancy vector. While direct fund theft requires additional conditions (such as victims having approved the attacker's contract), the reentrancy itself violates the non-reentrant execution model expected during token transfers.

**Event Log Pollution (MEDIUM)**: The `aelf_log_event` key allows injecting arbitrary events that appear to originate from the MultiToken contract, potentially misleading indexers and applications.

**Trust Model Breakdown**: The existence of `GetReservedExternalInfoKeyList` indicates these keys were intended to be system-controlled. Allowing user-set values breaks this security boundary.

## Likelihood Explanation

**Attack Prerequisites (LOW BARRIER)**:
- Attacker needs a SEED NFT to create the malicious token, obtainable through normal token creation mechanisms
- No special permissions or whitelist membership required beyond SEED ownership

**Attack Steps**:
1. Acquire SEED NFT for desired token symbol
2. Create malicious token with ExternalInfo containing reserved callback key (e.g., `"aelf_transfer_callback": "{\"contract_address\":\"<attacker_contract>\",\"method_name\":\"MaliciousCallback\"}"`)
3. Distribute tokens to victims via airdrops or legitimate-looking distributions
4. When victims transfer/lock/unlock the token, callbacks execute automatically

**No Detection or Prevention**:
- Malicious tokens are indistinguishable from legitimate ones at creation time
- No on-chain validation prevents setting reserved keys
- No mechanism exists to blacklist malicious callbacks after discovery

**High Probability**: The attack is straightforward, economically viable (low cost), requires no special privileges beyond SEED NFT ownership, and is difficult to detect until exploited.

## Recommendation

Add validation during token creation to prevent users from setting reserved callback keys:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    AssertValidCreateInput(input, symbolType);
    
    // Validate ExternalInfo does not contain reserved keys
    if (input.ExternalInfo != null && input.ExternalInfo.Value.Count > 0)
    {
        var reservedKeys = new[]
        {
            TokenContractConstants.TransferCallbackExternalInfoKey,
            TokenContractConstants.LockCallbackExternalInfoKey,
            TokenContractConstants.UnlockCallbackExternalInfoKey,
            TokenContractConstants.LogEventExternalInfoKey
        };
        
        foreach (var key in reservedKeys)
        {
            Assert(!input.ExternalInfo.Value.ContainsKey(key), 
                $"ExternalInfo key '{key}' is reserved for system use.");
        }
    }
    
    // ... rest of CreateToken logic
}
```

Alternatively, implement a whitelist mechanism where only trusted system contracts can set these reserved keys.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousCallbackDeniesService()
{
    // 1. Attacker creates malicious contract with reverting callback
    var attackerContract = await DeployMaliciousContract();
    
    // 2. Attacker obtains SEED NFT and creates token with malicious callback
    var maliciousToken = await CreateTokenWithCallback(
        symbol: "EVIL",
        callback: new CallbackInfo 
        { 
            ContractAddress = attackerContract,
            MethodName = "RevertingCallback"
        }
    );
    
    // 3. Distribute tokens to victim
    await IssueToken("EVIL", victimAddress, 1000);
    
    // 4. Victim attempts to transfer - transaction fails due to callback revert
    var result = await VictimTransferToken("EVIL", otherAddress, 100);
    
    // Assert: Transfer fails due to malicious callback
    result.Status.ShouldBe(TransactionResultStatus.Failed);
    result.Error.ShouldContain("Callback execution failed");
}
```

## Notes

This vulnerability is particularly severe because:

1. **No whitelist exists** - Any token creator can set these callback keys, not just trusted system contracts
2. **Unconditional execution** - The callbacks execute every time without permission checks
3. **Post-transfer timing** - Callbacks execute after balance updates but before transaction completion, enabling reentrancy
4. **Wide attack surface** - Affects Transfer, Lock, and Unlock operations across all tokens with malicious callbacks
5. **Irreversible** - Once a token is created with malicious callbacks, the ExternalInfo cannot be modified, permanently affecting all holders

The existence of `GetReservedExternalInfoKeyList` as a dedicated view method strongly suggests these keys were intended to be restricted, but the enforcement mechanism was never implemented.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-16)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```
