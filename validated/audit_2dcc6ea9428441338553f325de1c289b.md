# Audit Report

## Title
Vote Persistence After Member Removal Enables Governance Manipulation

## Summary
The Association contract's `RemoveMember()` function fails to clean up existing votes on pending proposals, creating a critical inconsistency in threshold calculations. Rejection and abstention counts filter votes by current membership, but the total vote threshold calculation does not, allowing organizations to bypass `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` protections by strategically removing dissenting members.

## Finding Description

The vulnerability stems from an inconsistency between how individual vote types are counted versus how total votes are counted when determining if a proposal can be released.

The `RemoveMember()` function only modifies the organization's member list without touching existing votes on pending proposals. [1](#0-0) 

When a proposal's release threshold is evaluated, the `IsProposalRejected()` method filters rejection votes by checking if voters are still in the current member list. [2](#0-1) 

Similarly, `IsProposalAbstained()` filters abstention votes by current membership. [3](#0-2) 

However, the `CheckEnoughVoteAndApprovals()` method contains a critical flaw. While it correctly filters approval votes by current membership, the total vote count concatenates all vote lists without any membership filtering. [4](#0-3) 

This inconsistency enables the following attack:
1. A proposal receives votes including rejections or abstentions
2. The organization (via another proposal) calls `RemoveMember()` to remove members who voted unfavorably
3. When the original proposal's `Release()` method evaluates `IsReleaseThresholdReached()`, removed members' rejection/abstention votes no longer count against the respective maximum thresholds [5](#0-4) 
4. However, their votes still count toward the `MinimalVoteThreshold` requirement
5. The proposal can now pass despite having exceeded rejection/abstention limits

## Impact Explanation

This vulnerability completely undermines the Association contract's governance safeguards:

**Direct Governance Bypass**: Organizations can circumvent `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` - two critical protections designed to prevent proposals from passing when too many members oppose or abstain. For example, with 10 members, `MinimalVoteThreshold=7`, `MaximalRejectionThreshold=2`, and `MinimalApprovalThreshold=5`, a proposal with 5 approvals and 3 rejections (8 total votes) would normally fail. By removing the 3 rejecting members, the rejection count becomes 0 while maintaining 8 total votes, allowing the proposal to pass.

**Affected Parties**: All Association organization members and stakeholders relying on Association-based governance for protocol decisions, fund management, or multi-sig operations. This includes token holders, DApp users, and any entities dependent on honest governance outcomes.

**Severity**: This is a critical governance integrity violation. The Association contract's threshold system is designed as a check-and-balance mechanism. By allowing threshold manipulation through membership changes rather than genuine consensus, the vulnerability enables minority factions to force through proposals, fundamentally breaking the governance model.

## Likelihood Explanation

**Attacker Capabilities**: The organization itself (acting through a passed proposal) has the authority to remove members. While this requires initial consensus, once a faction gains sufficient control to pass a single member removal proposal, they can leverage this vulnerability to manipulate subsequent proposals without proper scrutiny.

**Attack Complexity**: Low to medium complexity. The attack requires:
1. Achieving enough votes to pass an initial member removal proposal
2. Timing the removal to occur after unfavorable votes are cast on target proposals
3. Subsequently releasing the manipulated proposal

**Practical Feasibility**: The attack is realistic in organizations where a faction controls slightly above `MinimalApprovalThreshold` but faces opposition. The faction can pass one removal proposal, eliminate the opposition's voting power, then pass subsequent proposals that would have failed under normal circumstances.

**Detection Challenges**: The manipulation is not immediately obvious from on-chain activity and can appear as legitimate governance operations. Only careful analysis of the timing between member removals and proposal releases would reveal the exploitation pattern.

## Recommendation

Implement consistent filtering across all vote counting methods. The `CheckEnoughVoteAndApprovals()` method should filter the total vote count by current membership, matching the behavior of `IsProposalRejected()` and `IsProposalAbstained()`:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // Fix: Filter all votes by current membership
    var totalVoteCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains)
        + proposal.Approvals.Count(organization.OrganizationMemberList.Contains)
        + proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

Alternatively, consider implementing vote cleanup when members are removed, though this is more gas-intensive and complex to implement correctly.

## Proof of Concept

```csharp
[Fact]
public async Task VotePersistenceAfterMemberRemoval_GovernanceBypass_Test()
{
    // Setup: 10 member organization
    // MinimalVoteThreshold=7, MaximalRejectionThreshold=2, MinimalApprovalThreshold=5
    var organizationMembers = new[] { Reviewer1, Reviewer2, Reviewer3, 
        Accounts[4].Address, Accounts[5].Address, Accounts[6].Address,
        Accounts[7].Address, Accounts[8].Address, Accounts[9].Address, Accounts[10].Address };
    
    var organizationAddress = await CreateOrganizationWithCustomMembersAsync(
        minimalApprovalThreshold: 5,
        minimalVoteThreshold: 7,
        maximalAbstentionThreshold: 1,
        maximalRejectionThreshold: 2,
        members: organizationMembers);

    // Create a controversial proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // 5 members approve (meets MinimalApprovalThreshold=5)
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Accounts[4].KeyPair, proposalId);
    await ApproveAsync(Accounts[5].KeyPair, proposalId);
    await ApproveAsync(Accounts[6].KeyPair, proposalId);
    
    // 3 members reject (exceeds MaximalRejectionThreshold=2)
    await RejectAsync(Reviewer3KeyPair, proposalId);
    await RejectAsync(Accounts[7].KeyPair, proposalId);
    await RejectAsync(Accounts[8].KeyPair, proposalId);
    
    // Verify proposal cannot be released (3 rejections > 2 threshold)
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal1.ToBeReleased.ShouldBeFalse(); // Should fail due to rejection threshold
    
    // Attack: Remove the 3 rejecting members via organization authority
    var removalProposal1 = await CreateAssociationProposalAsync(Reviewer1KeyPair, 
        Reviewer3, nameof(AssociationContractStub.RemoveMember), organizationAddress);
    await ApproveRemovalProposal(removalProposal1, organizationAddress);
    
    var removalProposal2 = await CreateAssociationProposalAsync(Reviewer1KeyPair, 
        Accounts[7].Address, nameof(AssociationContractStub.RemoveMember), organizationAddress);
    await ApproveRemovalProposal(removalProposal2, organizationAddress);
    
    var removalProposal3 = await CreateAssociationProposalAsync(Reviewer1KeyPair, 
        Accounts[8].Address, nameof(AssociationContractStub.RemoveMember), organizationAddress);
    await ApproveRemovalProposal(removalProposal3, organizationAddress);
    
    // Vulnerability: Original proposal now bypasses rejection threshold
    var proposal2 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal2.ToBeReleased.ShouldBeTrue(); // Now passes! Rejections filtered but total votes not
    
    // Proposal can be released despite having exceeded rejection limits
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

**Notes**

This vulnerability exploits a fundamental design inconsistency in the Association contract's vote counting logic. The filtering of rejection and abstention votes by current membership was likely intended to handle scenarios where members leave or are removed legitimately. However, the failure to apply the same filtering to the total vote count creates an exploitable gap.

The attack is particularly insidious because it appears as legitimate governance operations - removing members and releasing proposals are both valid actions. The manipulation is only revealed through careful analysis of vote counts before and after member removal.

This vulnerability affects all Association organizations in the AElf ecosystem and should be prioritized for immediate remediation.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```
