# Audit Report

## Title
Inconsistent Null Handling in GetProfitDetails Causes DoS in TokenHolder and Election Contracts

## Summary
The `GetProfitDetails()` view method returns `null` for non-existent beneficiaries without null checking, while the similar `GetAllProfitsMap()` method explicitly handles null cases. This inconsistency causes `NullReferenceException` crashes in multiple critical callers, creating denial-of-service conditions that prevent legitimate profit distribution operations.

## Finding Description

The root cause lies in the Profit contract's `GetProfitDetails` method, which directly returns the nested dictionary lookup result without null validation: [1](#0-0) 

The `ProfitDetailsMap` is defined as a `MappedState<Hash, Address, ProfitDetails>`, which returns `null` for non-existent keys: [2](#0-1) 

In contrast, the similar `GetAllProfitsMap` method properly handles the null case: [3](#0-2) 

This inconsistency causes crashes in multiple critical callers:

**TokenHolderContract.AddBeneficiary** - The method retrieves profit details for a beneficiary and then directly accesses the `Details` property without null checking. When adding a NEW beneficiary (the normal use case), the beneficiary doesn't exist yet, causing a crash: [4](#0-3) 

**TokenHolderContract.RemoveBeneficiary** - Chains `.Details.Single()` directly on the result without null checking: [5](#0-4) 

**ElectionContract_Elector.GetProfitDetailByElectionVotingRecord** - Accesses `profitDetails.Details` without null checking, which is called during vote option changes: [6](#0-5) 

The Profit contract's own `AddBeneficiary` method demonstrates the correct pattern of checking for null before accessing properties: [7](#0-6) 

All affected methods are public RPC endpoints as confirmed by their protobuf definitions: [8](#0-7) 

## Impact Explanation

**Operational DoS Impact:**
- **TokenHolder schemes**: Scheme managers cannot add new beneficiaries to their profit schemes. The first `AddBeneficiary` call for any new address triggers a `NullReferenceException`, permanently blocking that operation until the code is fixed.
- **Election system**: Vote processing fails when `ChangeVotingOption` is called with `IsResetVotingTime=true` for voters whose profit details don't exist, disrupting the election reward distribution mechanism.
- **Profit scheme management**: Users cannot remove non-existent beneficiaries (less critical but still a DoS vector).

**Affected parties:**
- TokenHolder scheme managers attempting to add beneficiaries
- Election voters attempting to change voting options with time reset
- Any external contracts calling `GetProfitDetails` without defensive null guards

**Severity justification:** This breaks core economic functionality across multiple critical contracts. Profit distribution and staking rewards are fundamental to the AElf economic model, and this bug prevents legitimate users from participating in these incentive mechanisms during normal operations.

## Likelihood Explanation

**Reachable entry points:** All affected methods are public contract RPC methods callable by any user:
- `TokenHolderContract.AddBeneficiary` - callable by scheme managers
- `TokenHolderContract.RemoveBeneficiary` - callable by scheme managers  
- `ElectionContract.ChangeVotingOption` - callable by voters

**Preconditions:** Minimal - the vulnerability triggers during the NORMAL use case:
- For AddBeneficiary: Simply call it with a new beneficiary address that doesn't exist yet (the intended purpose of the method)
- For RemoveBeneficiary: Call it on a non-existent or already-removed beneficiary
- For Election: Call ChangeVotingOption with IsResetVotingTime=true for certain voting records

**Execution practicality:** The bug manifests during legitimate operations, not attack scenarios. Any scheme manager trying to add their first beneficiary will encounter this crash. No special attack construction is needed.

**Economic rationality:** Zero attack cost - this occurs naturally during normal protocol usage. While a malicious scheme manager could intentionally DoS their own scheme, the more significant issue is that ALL legitimate users will encounter this when performing the intended operations.

**Detection/constraints:** The bug is deterministic and 100% reproducible. Every `AddBeneficiary` call for a non-existent beneficiary will fail with a NullReferenceException.

## Recommendation

Add null checking in all vulnerable callers before accessing the `Details` property:

**For TokenHolderContract.AddBeneficiary:**
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    SchemeId = scheme.SchemeId,
    Beneficiary = input.Beneficiary
});
var shares = input.Shares;
if (detail != null && detail.Details.Any())  // Add null check
{
    // existing logic...
}
```

**For TokenHolderContract.RemoveBeneficiary:**
```csharp
var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = input.Beneficiary,
    SchemeId = scheme.SchemeId
});
Assert(profitDetails != null && profitDetails.Details.Any(), "Beneficiary not found.");
var detail = profitDetails.Details.Single();
```

**For ElectionContract_Elector.GetProfitDetailByElectionVotingRecord:**
```csharp
var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = electionVotingRecord.Voter,
    SchemeId = State.WelfareHash.Value
});

if (profitDetails == null) return null;  // Add null check

ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

Alternatively, fix the root cause by making `GetProfitDetails` return an empty `ProfitDetails` object instead of null, matching the pattern used in `GetAllProfitsMap`.

## Proof of Concept

A minimal test demonstrating the vulnerability:

```csharp
[Fact]
public async Task AddBeneficiary_NewBeneficiary_ShouldNotCrash()
{
    // Create a TokenHolder scheme
    var schemeManager = Accounts[0].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Try to add a NEW beneficiary (who doesn't exist in ProfitDetailsMap yet)
    var newBeneficiary = Accounts[1].Address;
    
    // This will crash with NullReferenceException at line 46 of TokenHolderContract.cs
    // when it tries to access detail.Details.Any() on a null detail
    var result = await TokenHolderContractStub.AddBeneficiary.SendAsync(
        new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = newBeneficiary,
            Shares = 100
        });
    
    // Expected: Transaction succeeds and beneficiary is added
    // Actual: Transaction fails with NullReferenceException
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L108-110)
```csharp
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L13-13)
```csharp
    public MappedState<Hash, Address, ProfitDetails> ProfitDetailsMap { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L40-46)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L170-177)
```csharp
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** protobuf/token_holder_contract.proto (L23-30)
```text
    // Add a beneficiary to a scheme.
    rpc AddBeneficiary (AddTokenHolderBeneficiaryInput) returns (google.protobuf.Empty) {
    }
    
    // Removes a beneficiary from a scheme.
    // Note: amount > 0: update the weight of the beneficiary, amount = 0: remove the beneficiary.
    rpc RemoveBeneficiary (RemoveTokenHolderBeneficiaryInput) returns (google.protobuf.Empty) {
    }
```
