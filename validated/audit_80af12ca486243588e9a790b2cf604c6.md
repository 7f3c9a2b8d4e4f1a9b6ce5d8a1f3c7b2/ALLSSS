# Audit Report

## Title
Token Deposit Loss Through Pubkey Replacement in Election Contract

## Summary
When a candidate self-registers via `AnnounceElection` and subsequently has their public key replaced via `ReplaceCandidatePubkey`, the 100,000 ELF deposit refund is incorrectly sent to an address derived from the NEW public key upon calling `QuitElection`, rather than being returned to the original depositor. This results in permanent loss of the candidate's deposit.

## Finding Description

The vulnerability exists in a critical discrepancy between how `AnnounceElection` and `AnnounceElectionFor` handle sponsor tracking, combined with flawed refund logic in `QuitElection`.

**Root Cause - Missing Sponsor Tracking:**

When a candidate self-registers through `AnnounceElection`, the function locks a 100,000 ELF deposit from `Context.Sender` but critically fails to record the sponsor in `State.CandidateSponsorMap`. [1](#0-0) 

In contrast, `AnnounceElectionFor` properly records the sponsor. [2](#0-1) 

The deposit locking mechanism is identical in both cases, transferring from `Context.Sender`. [3](#0-2) 

**Sponsor Map Transfer During Pubkey Replacement:**

When `ReplaceCandidatePubkey` is called, it transfers the sponsor map entry from old to new pubkey, preserving null values. [4](#0-3) 

Since `State.CandidateSponsorMap[oldPubkey]` is null for candidates who used `AnnounceElection`, the new pubkey also gets a null sponsor value.

**Failure Point - Incorrect Refund Address:**

In `QuitElection`, the refund logic uses a fallback that derives the recipient address from the NEW pubkey parameter. [5](#0-4) 

The critical flaw is that `pubkeyBytes` (line 231) is derived from `input.Value` which represents the current (NEW) pubkey after replacement. Since `State.CandidateSponsorMap[input.Value]` is null, the fallback `Address.FromPublicKey(pubkeyBytes)` uses the NEW pubkey to determine the recipient, not the original depositor's address.

The deposit amount is defined as 100,000 ELF. [6](#0-5) 

## Impact Explanation

**Direct Financial Loss:**
- The original candidate loses their entire 100,000 ELF deposit permanently
- The funds are transferred to an address derived from the replacement pubkey, which may be:
  - Controlled by a different party (in malicious admin scenarios)
  - Completely inaccessible (if the replacement pubkey was generated for a different purpose without corresponding private key control)

**Affected Scenarios:**
1. **Legitimate Key Rotation**: Honest candidates who perform legitimate key rotation for security reasons will lose their deposit upon withdrawal
2. **Malicious Admin Attack**: An admin can deliberately replace a candidate's pubkey to one they control, then call `QuitElection` to redirect the 100,000 ELF deposit to themselves

**Severity Justification:**
This is a CRITICAL vulnerability because:
- It causes complete and permanent loss of substantial funds (100,000 ELF per candidate)
- It affects a core governance mechanism (election candidate management)
- It triggers through normal, documented operational flows (key rotation + withdrawal)
- No recovery mechanism exists once funds are sent to the wrong address
- It violates the fundamental protocol invariant that deposits should be refunded to the original payer

## Likelihood Explanation

**High Likelihood - Normal Operations Trigger the Bug:**

The vulnerability manifests through standard contract operations without requiring any special conditions:

1. Candidate calls `AnnounceElection` (common self-registration path)
2. Candidate or their admin calls `ReplaceCandidatePubkey` (documented feature for key rotation)
3. Admin calls `QuitElection` (standard withdrawal mechanism)

**No Complex Preconditions:**
- No timing requirements or race conditions
- No special state manipulation needed
- No coordination with external contracts
- Pubkey replacement is a documented and intentionally supported feature for operational key management

**Attack Vectors:**
- **Accidental Loss**: Even with honest participants, legitimate key rotation followed by election withdrawal results in fund loss
- **Malicious Admin**: An admin (intentionally granted by candidate) can exploit this to steal the deposit by replacing the pubkey to one they control

**Current Test Coverage Gap:**

Existing tests verify that `QuitElection` works after `ReplaceCandidatePubkey`, but do not verify WHERE the deposit is sent. [7](#0-6) 

## Recommendation

**Fix 1: Record sponsor in `AnnounceElection`**

Add the following line after line 108 in `AnnounceElection` method:
```csharp
State.CandidateSponsorMap[pubkey] = Context.Sender;
```

**Fix 2: Use original pubkey for refund address derivation**

In `QuitElection`, modify the refund logic to use the initial pubkey instead of the current pubkey:
```csharp
var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
var initialPubkeyBytes = ByteArrayHelper.HexStringToByteArray(initialPubkey);
To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(initialPubkeyBytes)
```

**Fix 3: Add validation**

Add a check in `QuitElection` to ensure sponsor is recorded:
```csharp
Assert(State.CandidateSponsorMap[input.Value] != null, "Sponsor not recorded for candidate");
```

## Proof of Concept

```csharp
[Fact]
public async Task Test_DepositLoss_AfterPubkeyReplacement()
{
    // Setup: Candidate self-registers
    var originalKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    var originalAddress = Address.FromPublicKey(originalKeyPair.PublicKey);
    
    // Record initial balance of original depositor
    var initialBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = originalAddress,
        Symbol = "ELF"
    })).Balance;
    
    // Announce election (deposit 100,000 ELF)
    await AnnounceElectionAsync(originalKeyPair, candidateAdminAddress);
    
    // Verify deposit was locked
    var balanceAfterAnnounce = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = originalAddress,
        Symbol = "ELF"
    })).Balance;
    balanceAfterAnnounce.ShouldBe(initialBalance - 100_000_00000000);
    
    // Replace pubkey
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var newAddress = Address.FromPublicKey(newKeyPair.PublicKey);
    var candidateAdminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = originalKeyPair.PublicKey.ToHex(),
        NewPubkey = newKeyPair.PublicKey.ToHex()
    });
    
    // Quit election
    await candidateAdminStub.QuitElection.SendAsync(new StringValue
    {
        Value = newKeyPair.PublicKey.ToHex()
    });
    
    // Check balances: Original depositor should get refund but doesn't
    var finalBalanceOriginal = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = originalAddress,
        Symbol = "ELF"
    })).Balance;
    
    var finalBalanceNew = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = newAddress,
        Symbol = "ELF"
    })).Balance;
    
    // VULNERABILITY: Original depositor doesn't get refund
    finalBalanceOriginal.ShouldBe(balanceAfterAnnounce); // Still missing 100,000 ELF
    
    // Refund went to new address instead
    finalBalanceNew.ShouldBe(100_000_00000000); // New address received the deposit
}
```

**Notes:**

This vulnerability demonstrates a critical flaw in the deposit refund mechanism where the absence of sponsor tracking in the self-registration path (`AnnounceElection`) combined with the fallback logic in `QuitElection` causes deposits to be misdirected after pubkey replacement. The issue is exacerbated by the fact that pubkey replacement is a legitimate operational feature, meaning this bug will affect honest users performing routine security operations.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L231-249)
```csharp
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L79-85)
```csharp
            await candidateAdminStub.QuitElection.SendAsync(new StringValue
            {
                Value = newKeyPair.PublicKey.ToHex()
            });
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldNotContain(ByteString.CopyFrom(newKeyPair.PublicKey));
        }
```
