# Audit Report

## Title
Unvalidated Secret Sharing Reveals Allow Consensus State Corruption and Mining Order Manipulation

## Summary
The AEDPoS consensus contract accepts revealed InValues from block producers without cryptographic verification, allowing malicious miners to inject arbitrary `PreviousInValue` data for miners who missed their time slots. This corrupts consensus state, manipulates mining order calculations, and pollutes randomness generation.

## Finding Description

The vulnerability exists in two parallel code paths that process revealed InValues without cryptographic verification:

**Vulnerable Path 1 - UpdateLatestSecretPieces():**

The function accepts revealed InValues from trigger information and sets them directly into the round state without any cryptographic validation. [1](#0-0) 

The only check performed is whether the target miner's `PreviousInValue` field is empty or null—no verification that the revealed value is cryptographically correct using Shamir's Secret Sharing reconstruction.

**Vulnerable Path 2 - PerformSecretSharing():**

During UpdateValue transaction processing, this function directly persists the `MinersPreviousInValues` dictionary to chain state without validation. [2](#0-1) 

These values originated from the corrupted round state created by UpdateLatestSecretPieces, and are extracted via: [3](#0-2) 

**Validation Gap:**

The UpdateValueValidationProvider only validates the sender's own PreviousInValue, not the revealed values for other miners. [4](#0-3) 

The validation explicitly checks `validationContext.SenderPubkey` and ignores the `MinersPreviousInValues` dictionary entirely.

**Legitimate Path Comparison:**

The correct implementation exists in `RevealSharedInValues()`, which performs Shamir's Secret Sharing reconstruction using `SecretSharingHelper.DecodeSecret()`. [5](#0-4) 

However, this function is only called during NextRound behavior, not during UpdateValue processing: [6](#0-5) 

**Attack Flow:**

1. Attacker modifies their node's off-chain `SecretSharingService` to return arbitrary fake values in the `_revealedInValues` dictionary [7](#0-6) 

2. These fake values flow into `AElfConsensusTriggerInformation.RevealedInValues` via the trigger information provider [8](#0-7) 

3. When attacker produces a block, `UpdateLatestSecretPieces()` sets fake PreviousInValue for victim without validation

4. Transaction validation passes because it only checks attacker's own PreviousInValue

5. Fake values persist to state and propagate through subsequent rounds

6. During NextRound transition, `SupplyCurrentRoundInformation()` retrieves the fake PreviousInValue and uses it to calculate victim's signature [9](#0-8) 

7. The fake signature determines victim's mining order via modulo operation [10](#0-9) 

## Impact Explanation

**Consensus Integrity Violation:** The attack directly corrupts on-chain consensus state by setting incorrect `PreviousInValue`, `InValue`, and `Signature` fields for victim miners. The consensus invariant that each miner's signature must derive from their genuine InValue is violated.

**Mining Order Manipulation:** The corrupted signature directly determines the victim's `SupposedOrderOfNextRound` through the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. An attacker can systematically target specific miners to alter when they can produce blocks, potentially gaining unfair advantages or causing victims to miss their slots.

**Randomness Corruption:** Miner signatures contribute to consensus randomness through XOR aggregation: [11](#0-10) 

Injecting fake signatures pollutes this randomness source, enabling potential manipulation of round-based randomness used throughout the consensus system.

**State Persistence:** Once a fake `PreviousInValue` is set, the victim cannot correct it until they successfully produce a block with their real value. The fake data propagates through subsequent rounds via `SupplyCurrentRoundInformation()`, which uses the corrupted value to generate incorrect derived fields.

## Likelihood Explanation

**Attacker Profile:** Any authorized miner in the consensus pool can execute this attack by modifying their local node software to return fake values in `GetRevealedInValues()`.

**Attack Complexity:** Low. The attacker only needs to modify their off-chain `SecretSharingService` implementation to return arbitrary values in the `_revealedInValues` dictionary. No cryptographic operations, complex timing, or multi-party coordination is required.

**Preconditions:**
1. Attacker is an active miner in the current round
2. Target victim miner misses their time slot (hasn't produced `OutValue` yet in current round)
3. Attacker produces a block before victim in the same round

**Detection Difficulty:** High. No on-chain validation flags fake revealed values, corrupted state appears as legitimate consensus data, and victims only discover issues when attempting to mine.

**Economic Feasibility:** The attack cost is minimal—only the gas cost of producing a normal block. Potential gains include unfair mining advantages, ability to manipulate specific miners' schedules, and disruption of consensus randomness.

**Operational Constraints:** None. The attack can be executed repeatedly in every round where conditions are met. Since missed time slots occur regularly in distributed networks (network latency, node failures, maintenance), attack opportunities are frequent.

## Recommendation

Implement cryptographic validation of revealed InValues in `UpdateLatestSecretPieces()` using the same Shamir's Secret Sharing reconstruction logic from `RevealSharedInValues()`:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) ||
        (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue != Hash.Empty &&
         updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue != null))
        continue;
        
    var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
    
    // Verify sufficient decrypted pieces exist
    if (targetMiner.DecryptedPieces.Count < minersCount)
        continue;
        
    // Reconstruct and verify the revealed value using Shamir's Secret Sharing
    var orders = targetMiner.DecryptedPieces.Select((t, i) =>
        updatedRound.RealTimeMinersInformation.Values
            .First(m => m.Pubkey == targetMiner.DecryptedPieces.Keys.ToList()[i]).Order)
        .ToList();
    
    var sharedParts = targetMiner.DecryptedPieces.Values.ToList()
        .Select(s => s.ToByteArray()).ToList();
    
    var reconstructedValue = HashHelper.ComputeFrom(
        SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
    
    // Only accept if revealed value matches reconstructed value
    if (reconstructedValue == revealedInValue.Value)
        updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
}
```

Similarly, add validation in `PerformSecretSharing()` to verify `MinersPreviousInValues` entries against available decrypted pieces before persisting to state.

## Proof of Concept

A proof of concept would require:
1. Running an AElf consensus node with miner privileges
2. Modifying `SecretSharingService.RevealPreviousInValues()` to return fake hash values for a target miner
3. Producing a block during a round where the target miner has missed their slot
4. Observing the fake `PreviousInValue` persisted on-chain
5. Verifying the corrupted signature affects subsequent round order calculations

The vulnerability is confirmed through code analysis showing the absence of cryptographic validation in the two vulnerable paths, contrasted with the correct implementation in `RevealSharedInValues()` that is not used during UpdateValue processing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-184)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        var revealedInValues = new Dictionary<string, Hash>();

        foreach (var pair in round.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == selfPubkey) continue;

            var pubkey = pair.Key;
            var minerInRound = pair.Value;

            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
        }

        _revealedInValues[secretSharingInformation.CurrentRoundId] = revealedInValues;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
