# Audit Report

## Title
Missing Round Expiration Validation Allows Stale Rounds to be Accepted

## Summary
The `TimeSlotValidationProvider` fails to validate round expiration when `ProvidedRound.RoundId` matches `BaseRound.RoundId`. The validation only checks historical mining time consistency without comparing against current blockchain time, allowing miners to produce blocks for rounds that have exceeded their designated time windows.

## Finding Description

The AEDPoS consensus validation contains a critical gap in time-based validation logic:

**Missing CurrentBlockTime in Validation Context:** When `ValidateBeforeExecution()` constructs the `ConsensusValidationContext`, it does NOT include `Context.CurrentBlockTime` [1](#0-0) , and the context structure itself lacks this field entirely [2](#0-1) .

**Incomplete Time Slot Validation:** When the provided round's `RoundId` equals the base round's `RoundId`, `TimeSlotValidationProvider.ValidateHeaderInformation()` enters the else branch and calls `CheckMinerTimeSlot()` [3](#0-2) .

The `CheckMinerTimeSlot()` method only validates internal consistency by checking if `latestActualMiningTime < endOfExpectedTimeSlot`. Critically, if a miner hasn't mined yet (`latestActualMiningTime == null`), it returns true without any time-based validation against current blockchain time [4](#0-3) .

**Proper Method Exists But Unused:** The `Round.IsTimeSlotPassed()` method correctly implements time slot expiration checking by comparing `expectedMiningTime + miningInterval` against `currentBlockTime` [5](#0-4) . This method is properly used in consensus command generation where `Context.CurrentBlockTime` is available [6](#0-5)  and [7](#0-6) , but NOT in validation logic.

**No Additional Guards:** The `PreCheck()` method in processing only validates miner list membership, providing no time-based protection [8](#0-7) .

**Exploit Scenario:**
1. Round N is active with `State.CurrentRoundNumber = N`
2. Network disruption prevents miners from producing blocks or triggering NextRound
3. Current blockchain time progresses far beyond the round's designated period
4. A miner produces a block with `RoundId = N` and timestamp set to current time
5. Validation sees `ProvidedRound.RoundId == BaseRound.RoundId`, enters else branch
6. `CheckMinerTimeSlot()` returns true (miner hasn't mined yet, `latestActualMiningTime == null`)
7. Block accepted despite round being logically expired in wall-clock time

## Impact Explanation

**Severity: HIGH** - This breaks the fundamental consensus invariant that rounds must transition within their designated time periods.

The vulnerability compromises consensus integrity by:
- **Enabling stale round acceptance:** Miners can produce blocks for rounds that have expired in wall-clock time as long as `State.CurrentRoundNumber` hasn't been updated
- **Creating consensus confusion:** Nodes with different timing perceptions may disagree on valid blocks
- **Violating time-based scheduling:** AEDPoS fundamentally depends on time-slot-based round transitions
- **Potential double mining:** If some nodes accept stale rounds while others don't, it creates opportunities for conflicting chain states

While this doesn't directly cause fund loss, consensus integrity violations are critical security failures that can cascade into broader protocol failures including chain halts, fork risks, and undermining the liveness guarantees of the consensus mechanism.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Capabilities:** Any valid miner in the current round - no special privileges required beyond normal mining rights.

**Attack Complexity: LOW**
- Can occur naturally during network disruptions when no miner successfully triggers NextRound
- Requires only patience and timing - no complex transaction sequences
- No economic stake at risk for the attacker
- Simple to execute: wait for network disruption, then produce a block

**Feasibility Conditions:** All conditions are realistic and can occur during normal network operation:
- Network partition or coordination failures naturally prevent block production
- Time progresses via wall clocks while `State.CurrentRoundNumber` remains unchanged
- Any miner from the round can later produce a block that passes validation

**Detection Difficulty:** The validation passes legitimately from the contract's perspective since the missing check IS the vulnerability itself, making detection without external monitoring extremely difficult.

## Recommendation

**Fix: Include CurrentBlockTime in validation context and enforce round expiration checks.**

1. Add `CurrentBlockTime` field to `ConsensusValidationContext`:
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }
    public Timestamp CurrentBlockTime { get; set; }  // ADD THIS
    // ... existing fields
}
```

2. Populate `CurrentBlockTime` in `ValidateBeforeExecution()`:
```csharp
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,
    CurrentTermNumber = State.CurrentTermNumber.Value,
    CurrentRoundNumber = State.CurrentRoundNumber.Value,
    CurrentBlockTime = Context.CurrentBlockTime,  // ADD THIS
    // ... existing fields
};
```

3. Use `Round.IsTimeSlotPassed()` in `CheckMinerTimeSlot()`:
```csharp
private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
{
    if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
    
    // Use the proper expiration check
    if (validationContext.BaseRound.IsTimeSlotPassed(
        validationContext.SenderPubkey, 
        validationContext.CurrentBlockTime))
    {
        return false; // Time slot has expired
    }
    
    // Existing internal consistency checks...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task StaleRound_CanBeAccepted_WithoutTimeValidation()
{
    // Setup: Initialize chain with Round 1
    await InitializeConsensusAsync();
    var currentRound = await GetCurrentRoundAsync();
    var miner = currentRound.RealTimeMinersInformation.Keys.First();
    
    // Simulate network disruption - no blocks produced
    // Time advances significantly (simulate 1 hour passing)
    var staleTimestamp = currentRound.GetExpectedMiningTime(miner)
        .AddMilliseconds(currentRound.GetMiningInterval() * 100); // Far beyond round window
    
    // Miner produces block with same RoundId but stale timestamp
    var consensusInfo = new AElfConsensusHeaderInformation
    {
        Round = currentRound,
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        SenderPubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(miner))
    };
    
    // Set block time to stale time
    BlockTimeProvider.SetBlockTime(staleTimestamp);
    
    // Validation should fail but currently passes
    var validationResult = await ConsensusStub.ValidateConsensusBeforeExecution.CallAsync(
        new BytesValue { Value = consensusInfo.ToByteString() });
    
    // VULNERABILITY: This passes validation when it should fail
    validationResult.Success.ShouldBeTrue(); // This demonstrates the bug
    
    // Expected: validation should reject stale round
    // Actual: validation accepts it due to missing CurrentBlockTime check
}
```

## Notes

This vulnerability specifically affects the validation path when `ProvidedRound.RoundId == BaseRound.RoundId` (same round continuation). The fix requires minimal changes to the validation context structure and consistent use of the existing `IsTimeSlotPassed()` method that already implements correct time-based validation logic used in command generation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-31)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L26-36)
```csharp
        protected ConsensusBehaviourProviderBase(Round currentRound, string pubkey, int maximumBlocksCount,
            Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;

            _pubkey = pubkey;
            _maximumBlocksCount = maximumBlocksCount;
            _currentBlockTime = currentBlockTime;

            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
            _minerInRound = CurrentRound.RealTimeMinersInformation[_pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L34-53)
```csharp
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
