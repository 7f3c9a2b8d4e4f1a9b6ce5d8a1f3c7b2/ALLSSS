# Audit Report

## Title
Incomplete Conflict Resolution in Miner Order Assignment Leads to Duplicate Orders and Non-Deterministic Consensus

## Summary
The `ApplyNormalConsensusData()` function contains an off-by-one error in its conflict resolution loop that fails to check position `minersCount` when resolving order conflicts. When a collision occurs at this maximum position and all other positions (1 through `minersCount-1`) are occupied, two miners end up with identical `FinalOrderOfNextRound` values, violating the fundamental consensus invariant requiring unique timeslots per miner.

## Finding Description

The vulnerability exists in the conflict resolution loop of `ApplyNormalConsensusData()`. [1](#0-0) 

When a miner produces a block, their signature determines `supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1`, producing values in range [1, minersCount]. [2](#0-1) 

**The Critical Gap:**

When `supposedOrderOfNextRound = N` (where N = minersCount), the conflict resolution loop iterates from `N+1` to `2N-1`. For each iteration where `i > minersCount`, it calculates `maybeNewOrder = i % minersCount`:
- i=N+1: maybeNewOrder = 1
- i=N+2: maybeNewOrder = 2
- ...
- i=2N-1: maybeNewOrder = N-1

**Position N itself is never checked**, creating a blind spot. If positions 1 through N-1 are all occupied and a conflict exists at position N, the loop completes without reassigning the conflicted miner, leaving both miners with `FinalOrderOfNextRound = N`.

**Why Protections Fail:**

The `NextRoundMiningOrderValidationProvider` uses `Distinct()` on miner objects rather than on `FinalOrderOfNextRound` values. [3](#0-2)  Two different miners with the same order value are counted as two distinct objects, so duplicate orders pass validation.

The `TuneOrderInformation` mechanism only includes miners where `FinalOrderOfNextRound != SupposedOrderOfNextRound`. [4](#0-3)  When both conflicted miners have matching supposed and final orders, neither appears in tuning data.

When duplicates persist, `GenerateNextRoundInformation()` assigns both miners identical `Order` and `ExpectedMiningTime` values for the next round. [5](#0-4) 

## Impact Explanation

This breaks the fundamental consensus invariant that each miner must have a unique, deterministic production timeslot:

1. **Non-Deterministic Block Production**: Two miners attempt block production at the same timeslot, creating a race condition where network propagation determines acceptance rather than consensus rules.

2. **Unfair Penalties**: One miner may be incorrectly marked as missing their slot despite legitimate production attempts, affecting reputation scores and reward distribution.

3. **Chain Ambiguity**: Different network nodes may accept different blocks from competing miners at the same timeslot, risking temporary forks requiring reconciliation.

4. **Consensus Degradation**: The duplicate order persists into the next round's scheduling, continuing the non-deterministic behavior until corrected.

This is **HIGH severity** because it directly violates AEDPoS consensus integrity guarantees.

## Likelihood Explanation

This vulnerability occurs during normal consensus operations without requiring any malicious actor:

1. **Natural Hash Collisions**: Miner signatures produce pseudo-random order assignments. With 21 miners, collisions at specific positions are statistically inevitable over extended operation.

2. **High Occupancy Trigger**: As rounds progress and miners produce blocks, positions fill up. When N-1 positions are occupied and a collision occurs at position N, the bug triggers.

3. **No Privileges Required**: Happens during standard block production via `UpdateValue` consensus behavior. [6](#0-5) 

4. **Silent Failure**: No assertion or validation error prevents duplicate persistence. [7](#0-6) 

Likelihood increases with longer chain operation, higher miner participation rates, and edge-position collisions (position N has zero fallback options).

## Recommendation

Fix the off-by-one error by ensuring the conflict resolution loop checks all valid positions including `minersCount`:

```csharp
for (var i = supposedOrderOfNextRound + 1; i <= minersCount + (minersCount - 1); i++)
{
    var maybeNewOrder = i > minersCount ? i % minersCount : i;
    if (maybeNewOrder == 0) maybeNewOrder = minersCount; // Handle wrap to position N
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
        break;
    }
}
```

Additionally, add validation to ensure `FinalOrderOfNextRound` values are unique across all miners, not just checking for distinct miner objects.

## Proof of Concept

```csharp
[Fact]
public void DuplicateOrderBug_WhenPositionNConflictWithFullOccupancy()
{
    const int minersCount = 21;
    var round = new Round();
    
    // Fill positions 1-20
    for (int i = 1; i <= 20; i++)
    {
        var miner = $"miner{i}";
        round.RealTimeMinersInformation[miner] = new MinerInRound
        {
            Pubkey = miner,
            FinalOrderOfNextRound = i,
            SupposedOrderOfNextRound = i
        };
    }
    
    // Miner21 already has position 21
    round.RealTimeMinersInformation["miner21"] = new MinerInRound
    {
        Pubkey = "miner21",
        FinalOrderOfNextRound = 21,
        SupposedOrderOfNextRound = 21
    };
    
    // Miner22 calculates order 21 (collision)
    var signature = HashHelper.ComputeFrom("test");
    var sigNum = signature.ToInt64();
    var calculatedOrder = (int)(Math.Abs(sigNum % minersCount) + 1);
    
    // Force collision at position 21
    signature = HashHelper.ComputeFrom(20L);
    
    round.RealTimeMinersInformation["miner22"] = new MinerInRound { Pubkey = "miner22" };
    round.ApplyNormalConsensusData("miner22", Hash.Empty, Hash.Empty, signature);
    
    // Both miner21 and miner22 now have FinalOrderOfNextRound = 21
    Assert.Equal(21, round.RealTimeMinersInformation["miner21"].FinalOrderOfNextRound);
    Assert.Equal(21, round.RealTimeMinersInformation["miner22"].FinalOrderOfNextRound);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```
