# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Allows Arbitrary Public Key Hijacking

## Summary
The `AnnounceElectionFor` function in the Election contract lacks authorization checks, enabling any caller to register arbitrary public keys as election candidates and assign themselves as admin. This breaks the fundamental authorization invariant that only public key owners should control their candidate registrations, allowing attackers to permanently hijack candidate administration rights.

## Finding Description

The `AnnounceElectionFor` function accepts an arbitrary `pubkey` string and `admin` address without verifying that the caller has ownership or permission to announce election for that public key. [1](#0-0) 

The function directly assigns the provided `admin` parameter (defaulting to `Context.Sender` when null) as the candidate admin without any cryptographic proof of public key ownership. [2](#0-1) 

The internal `AnnounceElection(byte[] pubkeyBytes)` validation method only checks eligibility conditions (not an initial miner, not already announced, not banned) but never validates caller authorization to announce for the provided public key. [3](#0-2) 

**Contrast with Secure Implementation:**

The alternative `AnnounceElection(Address input)` method implements proper authorization by using `Context.RecoverPublicKey()` to cryptographically verify that the transaction signer owns the private key corresponding to the announced public key. [4](#0-3) 

This signature-based ownership verification pattern is completely absent from `AnnounceElectionFor`, creating a critical authorization bypass.

**Attack Execution:**

An attacker calls `AnnounceElectionFor` with:
- `Pubkey`: Any target public key hex string (e.g., a well-known public key they don't own)
- `Admin`: Attacker's address

The attacker becomes the admin controlling all administrative operations for that candidate, while the legitimate public key owner is permanently locked out.

## Impact Explanation

**1. Unauthorized Administrative Control**

The admin role assigned in `State.CandidateAdmins[pubkey]` controls critical candidate operations:

- **Quit Election**: Only the admin can quit election for a candidate. [5](#0-4) 

- **Replace Public Key**: Only the admin can replace a candidate's public key. [6](#0-5) 

- **Set Profit Receivers**: The Treasury contract verifies that only the candidate's admin can configure profit receivers. [7](#0-6) 

**2. Permanent Registration DoS**

Once a public key is announced, the validation prevents re-announcement while `IsCurrentCandidate` is true. [8](#0-7) 

The legitimate owner cannot register their own public key because the check fails. Even after the attacker quits (setting `IsCurrentCandidate = false`), they can immediately re-announce before the legitimate owner, enabling persistent griefing.

**3. Election System Manipulation**

Attackers controlling hijacked candidates can:
- Strategically quit elections to manipulate miner selection during term changes
- Cause voters to lock tokens for candidates under attacker control
- Manipulate data center ranking by controlling candidate participation timing

**Severity Assessment:** CRITICAL - This vulnerability breaks the fundamental security invariant that only public key owners should control their candidate registrations, enabling unauthorized takeover of election candidates and manipulation of the consensus mechanism.

## Likelihood Explanation

**Attacker Requirements:**
- 100,000 ELF for the candidate deposit lock [9](#0-8) 
- Ability to call a public contract method
- Knowledge of target public key hex strings

**Attack Complexity:** TRIVIAL
- Single transaction with two parameters
- No timing requirements, race conditions, or complex setup
- Direct method invocation on a public contract function

**Economic Cost:** MINIMAL

The attacker locks 100,000 ELF but receives full refund when quitting. The sponsor (attacker) is stored in `CandidateSponsorMap` [10](#0-9)  and receives the refund when the admin quits. [11](#0-10) 

Net cost: Only transaction fees.

**Detection Difficulty:** HIGH

Hijacked registrations appear legitimate on-chain. Without off-chain verification, users cannot distinguish malicious hijackings from legitimate registrations.

**Probability Assessment:** HIGH - The vulnerability is easily discoverable in contract code, trivially exploitable with standard contract calls, and economically rational for attackers seeking to manipulate elections or grief legitimate candidates.

## Recommendation

Add authorization verification to `AnnounceElectionFor` to ensure only the public key owner (or authorized delegate) can announce election. The most secure approach is to require cryptographic proof:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
    
    // CRITICAL FIX: Verify the caller owns the private key
    var recoveredPublicKey = Context.RecoverPublicKey();
    Assert(recoveredPublicKey.ToHex() == input.Pubkey, 
        "Only the public key owner can announce election for this key.");
    
    // Rest of the implementation...
}
```

Alternatively, if sponsored announcements are required by design, implement an explicit authorization mechanism (e.g., signatures from the public key owner authorizing the sponsor).

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Unauthorized_Admin_Takeover_Test()
{
    // Attacker and victim keypairs
    var attackerKeyPair = ValidationDataCenterKeyPairs.Last();
    var victimKeyPair = ValidationDataCenterKeyPairs.First();
    
    // Attacker announces election for victim's public key with attacker as admin
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimKeyPair.PublicKey.ToHex(),
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey)
    });
    
    // Verify attacker is now the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Verify victim cannot announce their own candidacy
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.AnnounceElection.SendWithExceptionAsync(
        Address.FromPublicKey(victimKeyPair.PublicKey));
    result.TransactionResult.Error.ShouldContain("already announced election");
    
    // Verify attacker controls quit operation
    var quitResult = await attackerStub.QuitElection.SendAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    quitResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This test demonstrates that an attacker can successfully hijack admin control over a victim's public key, preventing the legitimate owner from ever registering their candidacy.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```
