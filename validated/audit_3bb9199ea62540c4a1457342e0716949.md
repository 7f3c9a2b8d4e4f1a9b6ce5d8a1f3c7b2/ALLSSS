# Audit Report

## Title
Dictionary Access Vulnerability in Consensus Block Production Causes Chain Halt via Miner Pubkey Replacement Race Condition

## Summary
The AEDPoS consensus contract contains unprotected dictionary accesses to `RealTimeMinersInformation` during block production. When a candidate admin replaces an active miner's pubkey via `ReplaceCandidatePubkey`, the consensus contract removes the old pubkey from the current round information, causing a `KeyNotFoundException` when the miner attempts to produce their next block.

## Finding Description

The vulnerability stems from unprotected dictionary accesses in multiple block production code paths that fail to verify key existence before accessing `RealTimeMinersInformation`.

**Primary vulnerable location:** The `GetConsensusExtraDataToPublishOutValue` method directly accesses the dictionary without defensive checks: [1](#0-0) 

These lines access `currentRound.RealTimeMinersInformation[pubkey]` three times without verifying the key exists. The only validation at line 18 checks for empty pubkey, not missing keys.

**Attack mechanism:** The Election Contract's `ReplaceCandidatePubkey` method allows candidate admins to replace miner pubkeys: [2](#0-1) 

This triggers `RecordCandidateReplacement` in the consensus contract: [3](#0-2) 

Line 142 removes the old pubkey from `RealTimeMinersInformation`, making it unavailable for subsequent accesses.

**Additional vulnerable locations:**

`GetConsensusExtraDataForTinyBlock`: [4](#0-3) 

`GetUpdateValueRound`: [5](#0-4) 

`GetTinyBlockRound`: [6](#0-5) 

**Evidence of inconsistency:** The `NextRound` behavior HAS proper defensive checks: [7](#0-6) 

The `NextTerm` behavior also includes defensive validation: [8](#0-7) 

This inconsistency proves the missing checks in UpdateValue and TinyBlock paths are unintentional oversights.

**Race condition window:** Block production involves two phases:

1. `GetConsensusCommand` validates the miner is in the current round: [9](#0-8) 

2. Later, `GetConsensusExtraData` is called: [10](#0-9) 

Between these calls, a `ReplaceCandidatePubkey` transaction can execute in another miner's block, removing the target pubkey. When the affected miner calls `GetConsensusExtraData`, the unprotected dictionary access causes a crash.

The `IsInMinerList` check only validates at command time: [11](#0-10) 

**Attacker privilege:** Candidate admins are set during election announcement and are not part of the core trusted set: [12](#0-11) 

## Impact Explanation

**Consensus Disruption:** When a miner's block production crashes with `KeyNotFoundException`, that time slot is permanently lost. The miner cannot produce their scheduled block, breaking the expected block production cadence and violating the consensus invariant of miner schedule integrity.

**Chain Halt Risk:** In networks with few active miners or during consensus transitions, losing even one miner's block production capability could stall the chain. If multiple candidate admins coordinate replacements, they could systematically prevent multiple miners from producing blocks, effectively halting consensus until manual intervention.

**Affected Parties:**
- All blockchain users experience transaction confirmation delays
- Miners lose their block rewards for missed slots  
- DApps depending on predictable block times experience failures
- Network availability is compromised

**Severity:** This enables operational DoS of the consensus mechanism. The ability to prevent block production on-demand directly threatens chain availability, justifying HIGH severity (approaching CRITICAL in low-miner scenarios).

## Likelihood Explanation

**Attacker Capabilities:** The attacker must control a candidate admin role. While this is a privileged position, candidate admins are NOT part of the core trusted set. They are set when candidates announce election and can be any address.

**Attack Complexity:** The attack is straightforward:
1. Monitor when target miner receives their mining command (observable from consensus state)
2. Submit `ReplaceCandidatePubkey` transaction timed to execute before the miner produces their block
3. The miner's node crashes when attempting to access the removed pubkey

**Feasibility Conditions:**
- No rate limiting on `ReplaceCandidatePubkey` calls
- Transaction can be included in any block before the target miner's time slot
- Multiple candidate admins could coordinate to affect multiple miners simultaneously  
- The race window is predictable from public consensus information

**Probability Assessment:** MEDIUM-HIGH. Candidate admins have legitimate access to this functionality, and the timing window is predictable from public consensus information. A determined attacker with admin access can reliably trigger this vulnerability.

## Recommendation

Add defensive `ContainsKey` checks before all dictionary accesses to `RealTimeMinersInformation` in block production paths:

```csharp
// In GetConsensusExtraDataToPublishOutValue
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    return new AElfConsensusHeaderInformation(); // or handle appropriately

// In GetUpdateValueRound
if (!RealTimeMinersInformation.ContainsKey(pubkey))
    return new Round(); // or throw appropriate error

// In GetTinyBlockRound  
if (!RealTimeMinersInformation.ContainsKey(pubkey))
    return new Round(); // or throw appropriate error
```

Additionally, consider adding a delay or cooldown period before pubkey replacements take effect in the current round, allowing miners to complete their scheduled blocks.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a miner with candidate admin
2. Have the miner call `GetConsensusCommand` successfully
3. Execute `ReplaceCandidatePubkey` to remove the miner's old pubkey
4. Call `GetConsensusExtraData` with the old pubkey
5. Observe `KeyNotFoundException` preventing block production

The core vulnerability is the unprotected dictionary access combined with the ability to remove active miners' pubkeys mid-round.

## Notes

This vulnerability exists due to an inconsistency in defensive programming patterns across the codebase. While `NextRound` and `NextTerm` behaviors include proper `ContainsKey` checks, the `UpdateValue` and `TinyBlock` behaviors lack these protections. The race condition window, though potentially narrow, is exploitable because `ReplaceCandidatePubkey` immediately modifies the current round state, and candidate admins are not restricted from performing replacements on active miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L158-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L211-212)
```csharp
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L13-13)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L60-60)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L103-103)
```csharp
        State.CandidateAdmins[pubkey] = input;
```
