# Audit Report

## Title
Insufficient Validation in SetMinerIncreaseInterval Allows Negative Values Leading to Complete Consensus Halt

## Summary
The `SetMinerIncreaseInterval()` function lacks lower bound validation, allowing governance to set negative values for `MinerIncreaseInterval`. This causes `GetAutoIncreasedMinersCount()` to return a large negative miner count, which propagates through the consensus system. The negative count causes LINQ's `.Take()` operation in the Election contract to return an empty miner list, resulting in a consensus round with zero miners and permanent blockchain halt.

## Finding Description

**Root Cause - Missing Validation:**

The `SetMinerIncreaseInterval()` function only validates that the new value does not exceed the current value, but fails to enforce a positive lower bound. [1](#0-0) 

This allows values like -1 to pass validation since `-1 <= 31536000` (default value) evaluates to true, as confirmed by the test suite which only validates rejection of values greater than current. [2](#0-1) 

**Negative Value Calculation:**

When `GetAutoIncreasedMinersCount()` executes with a negative `MinerIncreaseInterval`, it performs integer division with a negative divisor: [3](#0-2) 

With `SupposedMinersCount = 17` [4](#0-3)  and `MinerIncreaseInterval = -1`, after 100,000 seconds of blockchain age, this calculates: `17 + (100000 / -1) * 2 = 17 - 200000 = -199,983`.

**Propagation to Election Contract:**

The negative miner count is calculated by `GetMinersCount(Round)` using the same vulnerable logic: [5](#0-4) 

This negative value is sent to the Election contract via `UpdateMinersCount` during term transitions: [6](#0-5) 

The Election contract stores this value without validation: [7](#0-6) 

**Critical LINQ Behavior Exploitation:**

When `GetVictories()` attempts to select miners, it uses the stored negative count with LINQ's `.Take()` method: [8](#0-7) 

C# LINQ's `.Take(n)` with negative `n` returns an empty sequence per .NET specification, producing a `MinerList` with zero miners.

**Consensus Termination:**

The empty miner list is used to generate the next consensus round: [9](#0-8) 

The round generation logic iterates over the sorted miners: [10](#0-9) 

With `sortedMiners.Count = 0`, the for loop never executes, creating a `Round` object with no miners in `RealTimeMinersInformation`. Since no miners exist, no blocks can be produced, causing permanent consensus halt.

## Impact Explanation

**Complete Network Failure:**
The vulnerability causes total blockchain shutdown. With zero miners in the consensus round, block production permanently halts. All network participants (validators, users, dApps) are immediately affected.

**Unrecoverable State:**
Even governance cannot fix this through normal channels since executing governance proposals requires consensus. The system enters a deadlock requiring emergency node-level intervention or chain restart.

**Network-Wide Denial of Service:**
All blockchain operations cease: token transfers, smart contract executions, cross-chain messages, and governance actions become impossible. The impact is immediate at the next term transition (typically hours after the malicious parameter is set).

This represents a complete violation of the consensus protocol's fundamental invariant that the miner set must always contain at least one active miner.

## Likelihood Explanation

**Privilege Requirements:**
The attack requires control of the `MaximumMinersCountController` authority (default: Parliament's default organization). [11](#0-10) 

**Direct Invariant Break:**
This is a directly reachable invariant break - a single authorized call to `SetMinerIncreaseInterval(-1)` deterministically breaks the fundamental invariant that miner count must be positive. The validation gap represents mis-scoped privileges: Parliament should configure valid parameters, not break consensus.

**Execution Simplicity:**
Once authorization is obtained, exploitation is trivial: a single function call with no complex transaction sequencing. The negative value persists in state and triggers failure at the next term transition.

## Recommendation

Add lower bound validation in `SetMinerIncreaseInterval()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Additionally, add validation in the Election contract's `UpdateMinersCount()`:

```csharp
public override Empty UpdateMinersCount(UpdateMinersCountInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only consensus contract can update miners count.");
    Assert(input.MinersCount > 0, "Miners count must be positive.");
    State.MinersCount.Value = input.MinersCount;
    SyncSubsidyInfoAfterReduceMiner();
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_NegativeValue_CausesConsensusHalt()
{
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    // Get current positive interval
    var currentInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    currentInterval.Value.ShouldBeGreaterThan(0);
    
    var defaultOrganizationAddress = await ParliamentStubs.First()
        .GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Parliament sets negative interval - this should fail but doesn't due to missing validation
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = -1 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });
    
    // Verify negative value was stored
    var newInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    newInterval.Value.ShouldBe(-1);
    
    // Get current miners count - should become negative
    var minersCount = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    minersCount.Value.ShouldBeLessThan(0); // Negative miner count!
    
    // On next term transition, GetVictories returns empty list, causing consensus halt
    var victories = await ElectionStub.GetVictories.CallAsync(new Empty());
    victories.Value.Count.ShouldBe(0); // Empty miner list - consensus will halt!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L121-132)
```csharp
        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-82)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-38)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```
