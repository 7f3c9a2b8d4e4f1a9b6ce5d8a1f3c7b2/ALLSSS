# Audit Report

## Title
Virtual Balance Mismatch Causes Denial of Service in TokenConverter Sell Operations

## Summary
The TokenConverter contract uses a 10 million token virtual balance for deposit connectors in Bancor pricing calculations, but this virtual balance does not represent actual tokens held by the contract. When deposit balances are low, the Bancor formula calculates payouts exceeding actual holdings, causing `Sell` transactions to fail with SafeMath underflow exceptions, preventing legitimate users from selling resource tokens.

## Finding Description
The vulnerability stems from a mismatch between the balance used for pricing calculations and the balance used for state updates in the `Sell` method.

The `NativeTokenToResourceBalance` constant is set to 10 million tokens [1](#0-0) , which is assigned as the `VirtualBalance` for native token deposit connectors during initialization [2](#0-1) .

The `GetSelfBalance` method combines this virtual balance with the actual deposit balance when calculating pricing [3](#0-2) . This inflated balance is used by the Bancor formula [4](#0-3)  to calculate `amountToReceive`.

However, the actual state update attempts to subtract `amountToReceive` from the real `DepositBalance` [5](#0-4) . When `amountToReceive` exceeds the actual `DepositBalance`, the `SafeMath.Sub` operation throws an overflow exception [6](#0-5) , causing the transaction to revert.

The Bancor formula for equal weights simplifies to: `return = toBalance * paidAmount / (fromBalance + paidAmount)` [7](#0-6) , where `toBalance` includes the 10M virtual balance, leading to calculated returns that exceed actual available deposits.

Connectors can be initialized with zero deposit balance [8](#0-7)  when all resource tokens are already held by the contract, making this scenario immediately reachable.

## Impact Explanation
**Denial of Service - Medium Severity**

Users are unable to sell resource tokens when deposit balances are insufficient relative to the 10M virtual balance. The transaction reverts cleanly without fund loss, but creates significant operational disruption:

- Legitimate sell operations fail unexpectedly despite pricing calculations indicating they should succeed
- Resource tokens become effectively frozen until sufficient deposits accumulate through Buy operations
- Impact multiplies across multiple resource token pairs (READ, WRITE, STORAGE, TRAFFIC, etc.), each with its own 10M virtual balance
- More severe during early system stages or after periods of heavy withdrawals

The issue affects system availability rather than fund security. No tokens are lost or stolen—transactions simply revert. This justifies Medium severity: significant operational impact without direct fund loss.

## Likelihood Explanation
**High Likelihood**

The vulnerability is highly likely to manifest in realistic scenarios:

The `Sell` method is publicly accessible [9](#0-8)  requiring no special privileges—any user holding resource tokens can call it.

Feasible preconditions exist naturally:
- System initialization can set deposit balance to zero when all resource tokens are in the contract
- Early adoption phase where limited Buy operations have occurred (deposit balance << 10M virtual)
- Multiple resource connectors fragment available deposits across 8+ different pairs

The mathematical condition for failure is straightforward: when `(virtualBalance + depositBalance) * sellAmount / (resourceBalance + sellAmount) > depositBalance`, which occurs frequently when `depositBalance << virtualBalance` (10M).

No attack is required—this is a natural system state during normal operation. Users have legitimate economic incentives to sell resource tokens but are blocked by insufficient deposit backing.

## Recommendation
Add a pre-check before the Bancor calculation to ensure sufficient actual balance:

```csharp
public override Empty Sell(SellInput input)
{
    var fromConnector = State.Connectors[input.Symbol];
    Assert(fromConnector != null, "[Sell]Can't find from connector.");
    Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[Sell]Can't find to connector.");
    
    var amountToReceive = BancorHelper.GetReturnFromPaid(
        GetSelfBalance(fromConnector), GetWeight(fromConnector),
        GetSelfBalance(toConnector), GetWeight(toConnector),
        input.Amount
    );

    var fee = Convert.ToInt64(amountToReceive * GetFeeRate());
    if (Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) 
        fee = 0;

    var amountToReceiveLessFee = amountToReceive.Sub(fee);
    
    // Add check for sufficient actual deposit balance
    var actualDepositBalance = State.DepositBalance[toConnector.Symbol];
    Assert(amountToReceive <= actualDepositBalance, 
        "Insufficient deposit balance to fulfill sell order.");
    
    Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

    // ... rest of method
}
```

Alternatively, consider using only actual balance (not virtual balance) for the deposit connector side in Bancor calculations, or implement a gradual virtual balance reduction mechanism as deposits accumulate.

## Proof of Concept

```csharp
[Fact]
public async Task Sell_Fails_When_Virtual_Balance_Exceeds_Actual_Deposit()
{
    // Setup: Initialize connector with low deposit balance
    await InitializeTokenConverterContract();
    
    // Enable connector with minimal deposit (simulating early system state)
    var enableInput = new ToBeConnectedTokenInfo
    {
        TokenSymbol = WriteSymbol,
        AmountToTokenConvert = 500_000_000_00000000 // All resource tokens in contract
    };
    await DefaultStub.EnableConnector.SendAsync(enableInput);
    
    // Verify low deposit balance vs 10M virtual balance
    var depositBalance = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = WriteSymbol });
    // depositBalance.Value should be 0 or very low
    
    // User performs a large sell that triggers the issue
    var sellAmount = 5_000_000_00000000; // 5M tokens
    var sellInput = new SellInput
    {
        Symbol = WriteSymbol,
        Amount = sellAmount
    };
    
    // This should fail with SafeMath underflow when trying to subtract 
    // calculated payout from insufficient DepositBalance
    var result = await DefaultStub.Sell.SendWithExceptionAsync(sellInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("overflow"); // SafeMath underflow exception
}
```

**Notes:**
- The vulnerability is confirmed through code analysis showing virtual balance inflation in pricing without corresponding actual token backing
- The 10M virtual balance constant is hardcoded and used across all deposit connectors
- Fee handling confirms that fees are donated/burned, not retained in the converter contract
- SafeMath checked arithmetic ensures transaction reverts cleanly without fund loss
- The issue manifests naturally during early system stages without requiring malicious actors

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L246-246)
```csharp
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-161)
```csharp
    public override Empty Sell(SellInput input)
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L387-387)
```csharp
        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-49)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);
```
