# Audit Report

## Title
Missing Temporal Validation Allows Premature Term Transitions

## Summary
The AEDPoS consensus contract fails to validate temporal conditions when processing `NextTerm` behavior, allowing malicious miners to trigger term transitions prematurely. While honest miners check `NeedToChangeTerm()` before proposing term changes, the validation logic only performs structural checks, enabling bypass of time-based term transition requirements.

## Finding Description

The vulnerability exists in a critical asymmetry between honest consensus behavior generation and validation logic.

**Honest Path:**
When honest miners determine whether to change terms, `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` explicitly checks the temporal condition: [1](#0-0) 

This invokes `CurrentRound.NeedToChangeTerm()` which verifies that at least 2/3 of miners have timestamps indicating the term period has elapsed: [2](#0-1) 

The temporal check uses `IsTimeToChangeTerm()` to verify the elapsed time matches the term period: [3](#0-2) 

**Validation Path (The Vulnerability):**
When a block with `NextTerm` behavior is validated, only `RoundTerminateValidationProvider` is invoked: [4](#0-3) 

However, `ValidationForNextTerm` performs only structural validation: [5](#0-4) 

**The Critical Gap:** This validation checks round number increment, term number increment, and null InValues, but does NOT invoke `NeedToChangeTerm()` to verify the temporal condition.

**Attack Execution:**
1. A malicious miner queries `GetVictories()` (a public view method) to obtain next term's elected miners
2. Generates valid next term round data using deterministic logic in `GenerateFirstRoundOfNewTerm()`: [6](#0-5) 

3. Produces a block with `Behaviour = NextTerm` during their time slot
4. Validation passes because only structural checks exist
5. `ProcessNextTerm` executes, triggering premature state transitions

## Impact Explanation

When `ProcessNextTerm` executes prematurely, it triggers critical operations designed only for term completion: [7](#0-6) 

**Concrete Harms:**

1. **Treasury Fund Release (HIGH):** Line 205-208 releases treasury funds for a term that hasn't completed, causing fund misallocation and breaking treasury period accounting.

2. **Election Snapshot Timing (HIGH):** Line 213-218 takes election snapshots at incorrect times. These snapshots determine voting rewards and future miner selection - premature snapshots corrupt governance integrity and reward calculations.

3. **Miner Statistics Reset (MEDIUM):** Lines 179-183 prematurely reset `MissedTimeSlots` and `ProducedBlocks` counters, corrupting performance tracking and allowing malicious miners to escape penalties.

4. **Miner List Disruption (HIGH):** Lines 188-190 update to newly elected miners before the term completes, disrupting the consensus schedule and potentially excluding miners from their rightful time slots.

5. **Mining Reward Miscalculation (MEDIUM):** Line 203 donates mining rewards based on incomplete term data, leading to incorrect reward distribution.

**Severity: HIGH** - Breaks fundamental consensus timing, causes premature fund releases, and corrupts governance/election data integrity.

## Likelihood Explanation

**Attacker Requirements:**
- Must be in current miner list (enforced by `MiningPermissionValidationProvider`): [8](#0-7) 

**Attack Complexity: LOW**
- Query public `GetVictories()` to obtain election results
- Generate next term round using deterministic, publicly available logic
- Set `Behaviour = NextTerm` when producing a block during time slot
- No cryptographic challenges or complex state manipulation required

**Feasibility: HIGH**
- Any malicious miner can execute
- No special permissions beyond being a current miner
- No economic cost beyond normal block production
- All required information is publicly queryable

**Probability: MEDIUM-HIGH** - Requires miner position, but attack is trivial once in position, requires no special resources, and validation gap makes it directly exploitable.

## Recommendation

Add temporal validation to `RoundTerminateValidationProvider.ValidationForNextTerm()`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Is next term number correct?
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD: Verify temporal condition for term change
    var blockchainStartTimestamp = State.BlockchainStartTimestamp.Value;
    var periodSeconds = State.MiningInterval.Value; // Get from state
    if (!validationContext.BaseRound.NeedToChangeTerm(blockchainStartTimestamp, 
        validationContext.BaseRound.TermNumber, periodSeconds))
        return new ValidationResult { Message = "Term change temporal condition not met." };

    return new ValidationResult { Success = true };
}
```

This ensures validation enforces the same temporal requirements that honest miners check before proposing term changes.

## Proof of Concept

```csharp
[Fact]
public async Task PrematureTermTransition_BypassesTemporalValidation()
{
    // Setup: Initialize consensus with normal term period
    InitializeContracts();
    var maliciousMiner = BootMinerKeyPair;
    
    // Get current round info - term period NOT elapsed
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var currentTerm = currentRound.TermNumber;
    
    // Verify NeedToChangeTerm returns false (not time yet)
    var needsChange = currentRound.NeedToChangeTerm(
        BlockchainStartTimestamp, 
        currentTerm, 
        AEDPoSContractTestConstants.PeriodSeconds);
    needsChange.ShouldBeFalse(); // Time hasn't elapsed
    
    // Malicious miner generates premature NextTerm
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    var maliciousMinerStub = GetAEDPoSContractStub(maliciousMiner);
    
    var nextTermRound = new MinerList { Pubkeys = { victories.Value } }
        .GenerateFirstRoundOfNewTerm(
            AEDPoSContractTestConstants.MiningInterval,
            Context.CurrentBlockTime,
            currentRound);
    
    var nextTermInput = new NextTermInput();
    nextTermInput.RoundNumber = nextTermRound.RoundNumber;
    nextTermInput.TermNumber = nextTermRound.TermNumber;
    nextTermInput.RealTimeMinersInformation.Add(nextTermRound.RealTimeMinersInformation);
    nextTermInput.RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(maliciousMiner));
    
    // Execute premature term transition - should fail but succeeds
    var result = await maliciousMinerStub.NextTerm.SendAsync(nextTermInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify premature state changes occurred
    var newRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.TermNumber.ShouldBe(currentTerm + 1); // Term changed prematurely!
    
    // Verify treasury was released prematurely
    // Verify election snapshot taken at wrong time
    // Verify miner statistics reset prematurely
}
```

## Notes

This vulnerability demonstrates a critical validation gap where the consensus contract's validation logic fails to enforce the same temporal constraints that guide honest behavior. The attack requires only miner status and exploits the deterministic nature of next-term round generation. The impacts span treasury management, election integrity, and consensus timing - all core protocol invariants.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-45)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
