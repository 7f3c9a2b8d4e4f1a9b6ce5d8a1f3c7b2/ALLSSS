# Audit Report

## Title
Cross-Chain NFT Type Synchronization DOS - Custom NFT Types Cause CrossChainCreate Failure

## Summary
Custom NFT types added via `AddNFTType` on one chain are not automatically synchronized to destination chains, causing `CrossChainCreate` to fail with an assertion error when attempting to create NFT protocols that use custom types. This creates a systematic DOS condition requiring manual parliament intervention on every destination chain.

## Finding Description

The NFT contract stores NFT type mappings (2-character short name to full name) in per-chain `MappedState` variables. [1](#0-0) 

When parliament adds a custom NFT type via `AddNFTType`, it only updates the state mappings on the current chain. [2](#0-1) 

The `CrossChainCreate` method is used to create NFT protocols on destination chains after token info has been synchronized. It calls `InitialNFTTypeNameMap()` which only initializes 10 hardcoded predefined types. [3](#0-2) 

The critical vulnerability occurs when `CrossChainCreate` extracts the 2-character NFT type short name from the symbol and attempts to look it up in the destination chain's `State.NFTTypeFullNameMap`. If a custom type doesn't exist on the destination chain, the transaction fails with an assertion error. [4](#0-3) 

**Root Cause:** The NFT type IS stored in the token's `ExternalInfo` under the key `NftTypeMetadataKey` during protocol creation [5](#0-4)  and this `ExternalInfo` IS synchronized cross-chain via `CrossChainCreateToken`. However, `CrossChainCreate` does NOT read the NFT type from the synchronized `ExternalInfo`. Instead, it unnecessarily derives it by looking up the short name in per-chain state that was never synchronized.

**Execution Path:**
1. MainChain: Parliament calls `AddNFTType` with custom type "GG" â†’ "Gaming"
2. MainChain: User creates NFT protocol with Gaming type, receives symbol "GG123456789"
3. Cross-chain: MultiToken's `CrossChainCreateToken` syncs token info to SideChain (including `ExternalInfo` with NFT type)
4. SideChain: User calls `CrossChainCreate("GG123456789")`
5. SideChain: `InitialNFTTypeNameMap()` only initializes default types (no "GG" mapping)
6. SideChain: Lookup of "GG" in `State.NFTTypeFullNameMap` returns null
7. Transaction reverts: "Full name of GG not found. Use AddNFTType to add this new pair."

## Impact Explanation

This vulnerability creates a **systematic operational DOS** with HIGH severity:

1. **Protocol Availability Impact:** Legitimate NFT protocols using custom types cannot function cross-chain, completely blocking users from accessing their protocols on destination chains until governance intervention.

2. **Governance Coordination Burden:** For each custom NFT type, parliament must create and approve proposals on EVERY destination chain. This creates significant coordination overhead, delays, and operational complexity.

3. **Permanent DOS Risk:** If destination chain governance is inactive, slow to respond, or uncooperative, NFT protocols remain permanently unavailable, locking users out of cross-chain functionality.

4. **User Experience Degradation:** Users receive cryptic error messages during legitimate operations without understanding a governance action is required.

The severity is HIGH because:
- It affects core cross-chain NFT functionality
- It requires multi-chain governance coordination to resolve  
- It impacts all custom NFT types systematically
- The only resolution is manual governance action on each chain

## Likelihood Explanation

The likelihood is **HIGH** because:

**No Attacker Required:** This is a design flaw manifesting during normal protocol operations. Any legitimate use of the custom NFT type feature triggers the issue.

**Minimal Complexity:**
- Parliament adds a custom NFT type on mainchain (expected legitimate governance operation)
- Protocol creator uses the custom type (the explicit purpose of `AddNFTType`)
- Cross-chain sync is attempted (standard protocol operation)

**Feasibility Conditions Met:**
- Custom NFT types are an explicit system feature with dedicated `AddNFTType` function
- Cross-chain protocol creation is a core use case
- No automatic synchronization mechanism exists

**Immediate Detection:** The issue manifests immediately when `CrossChainCreate` is called with a custom type, making this highly likely to occur once custom types are used in production.

## Recommendation

Read the NFT type directly from the synchronized token ExternalInfo instead of deriving it from per-chain state mappings.

**Fixed code for CrossChainCreate (lines 87-94):**
```csharp
var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
// FIX: Read NFT type directly from ExternalInfo instead of deriving from mappings
var nftTypeFullName = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];
if (string.IsNullOrEmpty(nftTypeFullName))
    throw new AssertionException($"NFT type not found in token external info for {input.Symbol}.");
```

This eliminates the dependency on per-chain `State.NFTTypeFullNameMap` and uses the NFT type that was already synchronized in the token's `ExternalInfo`.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_CustomNFTType_ShouldFail_DOS()
{
    // Setup: MainChain adds custom NFT type and creates protocol
    var mainChainNftContract = GetMainChainNFTContract();
    var parliamentAddress = await GetParliamentDefaultAddress();
    
    // Step 1: MainChain parliament adds custom type "GG" -> "Gaming"
    await mainChainNftContract.AddNFTType.SendAsync(new AddNFTTypeInput
    {
        ShortName = "GG",
        FullName = "Gaming"
    }, parliamentAddress);
    
    // Step 2: MainChain user creates NFT protocol with Gaming type
    var createResult = await mainChainNftContract.Create.SendAsync(new CreateInput
    {
        NftType = "Gaming",
        ProtocolName = "Test Gaming NFT",
        TotalSupply = 10000,
        BaseUri = "https://test.com/",
        IsBurnable = true,
        IssueChainId = MainChainId
    });
    var symbol = createResult.Output.Value; // e.g., "GG123456789"
    
    // Step 3: CrossChainCreateToken syncs token to SideChain
    await SyncTokenInfoToSideChain(symbol);
    
    // Step 4: SideChain - Attempt CrossChainCreate (should fail with DOS)
    var sideChainNftContract = GetSideChainNFTContract();
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await sideChainNftContract.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    
    // Verify DOS condition: "Full name of GG not found. Use AddNFTType to add this new pair."
    Assert.Contains("Full name of GG not found", exception.Message);
    Assert.Contains("Use AddNFTType to add this new pair", exception.Message);
    
    // Verify protocol was NOT created on SideChain
    var protocolInfo = await sideChainNftContract.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    Assert.Null(protocolInfo.Symbol);
}
```

**Notes:**
- The vulnerability is confirmed by code analysis showing `CrossChainCreate` unnecessarily derives the NFT type from per-chain mappings instead of reading it from the already-synchronized `ExternalInfo`
- This is a design flaw, not an implementation bug - the data is available but not used correctly
- The fix is straightforward: read `tokenInfo.ExternalInfo.Value[NftTypeMetadataKey]` instead of looking up `State.NFTTypeFullNameMap`

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-36)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-196)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```
