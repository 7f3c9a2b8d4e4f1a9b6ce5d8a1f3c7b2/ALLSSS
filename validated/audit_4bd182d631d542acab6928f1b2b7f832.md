# Audit Report

## Title
Dictionary Key Mismatch in RecoverFromUpdateValue Causes Consensus Validation DoS During Miner Replacement

## Summary
The `RecoverFromUpdateValue` method in the consensus contract contains a critical dictionary access bug that causes `KeyNotFoundException` during miner replacement scenarios. The method iterates over all miners in a provided round and directly accesses the current round's `RealTimeMinersInformation` dictionary without checking if keys exist, leading to consensus validation failures when blocks contain miners that have been replaced.

## Finding Description

The vulnerability exists in the `RecoverFromUpdateValue` method which is responsible for restoring full round state from simplified consensus data during block validation. [1](#0-0) 

**Root Cause:** While the function checks if the sender's pubkey exists in both rounds [2](#0-1) , it then iterates over ALL miners in the provided round and directly accesses `RealTimeMinersInformation[information.Key]` without verifying each key exists. This violates C# dictionary safety principles and throws `KeyNotFoundException` when a key from the provided round doesn't exist in the current round.

**Why This Occurs:** During miner replacement via `RecordCandidateReplacement`, the current round's miner list is modified by removing the old pubkey and adding a new one. [3](#0-2) 

When a block produced before the replacement (containing the old miner list) is validated after the replacement, the provided round contains miners not present in the current round, triggering the exception.

**Validation Call Paths:**

*Before-execution validation:* [4](#0-3) 

*After-execution validation:* [5](#0-4) 

**Unreachable Protection:** The system has miner replacement validation logic designed to handle this scenario [6](#0-5) , but it's unreachable because the exception is thrown at line 91 before this validation can execute.

**Pattern Inconsistency:** The codebase consistently uses `ContainsKey` checks before accessing `RealTimeMinersInformation` throughout, such as in: [7](#0-6)  and [8](#0-7) 

The missing check in `RecoverFromUpdateValue` breaks this defensive pattern.

## Impact Explanation

**High Severity DoS Impact:**
- Blocks containing consensus data from before miner replacement fail validation with unhandled exceptions rather than being properly validated or gracefully rejected
- Consensus validation becomes unreliable during miner replacement transitions as nodes with different timing see different round states
- The designed miner replacement validation mechanism (lines 103-123) that would properly handle these cases never executes
- Network disruption during normal protocol operations (miner replacement is a legitimate feature)

**Affected Operations:**
- Block validation during miner replacement events executed via [9](#0-8) 
- Consensus integrity during term transitions when miner lists change
- All nodes attempting to validate blocks during these state transitions

**Security Guarantees Broken:**
- Consensus validation should handle legitimate state transitions gracefully
- Blocks following protocol rules should be validated correctly or rejected with proper error handling
- Miner replacement should not cause validation failures via exceptions

## Likelihood Explanation

**High Likelihood - Normal Operations:**

Miner replacement is a standard protocol feature executed when candidates update their public keys via [10](#0-9) . The vulnerability triggers during legitimate operations without malicious intent.

**Triggering Scenario:**
1. At time T1, a miner (e.g., M2) produces a block with consensus data containing miner list [M1, M2, M3]
2. Miner M1's candidate admin calls `ReplaceCandidatePubkey` to replace M1 with M4
3. The consensus contract processes the replacement, updating its current round to [M4, M2, M3]
4. A validation node receives the block from T1 and validates it
5. `RecoverFromUpdateValue` is called with the block's round data containing [M1, M2, M3]
6. The sender check passes (M2 exists in both rounds)
7. The foreach loop iterates over [M1, M2, M3] from the block
8. Dictionary access for M1 fails because M1 was removed from the current round
9. `KeyNotFoundException` is thrown, validation fails

**Preconditions:** Only normal protocol operations:
- Miner replacement via the Election contract (happens periodically for key rotation)
- Block propagation timing differences between nodes (inherent in distributed systems)

**No Special Privileges Required:** This occurs during normal consensus operation, not requiring attacker control. The timing window naturally occurs in any distributed network.

## Recommendation

Add a `ContainsKey` check before accessing the dictionary in the foreach loop, consistent with the pattern used throughout the codebase:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue;
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

This allows the method to skip miners that have been replaced while still updating the information for miners that remain in the current round, enabling the designed miner replacement validation logic at lines 103-123 to execute and properly handle the scenario.

## Proof of Concept

```csharp
[Fact]
public async Task RecoverFromUpdateValue_ThrowsKeyNotFoundException_WhenMinerReplaced()
{
    // Setup: Create initial round with miners M1, M2, M3
    var currentRound = new Round
    {
        RealTimeMinersInformation =
        {
            ["M1"] = new MinerInRound { Pubkey = "M1" },
            ["M2"] = new MinerInRound { Pubkey = "M2" },
            ["M3"] = new MinerInRound { Pubkey = "M3" }
        }
    };
    
    // Create a block's round data with the same miner list
    var providedRound = new Round
    {
        RealTimeMinersInformation =
        {
            ["M1"] = new MinerInRound { 
                Pubkey = "M1",
                SupposedOrderOfNextRound = 1,
                FinalOrderOfNextRound = 1
            },
            ["M2"] = new MinerInRound { 
                Pubkey = "M2",
                SupposedOrderOfNextRound = 2,
                FinalOrderOfNextRound = 2
            },
            ["M3"] = new MinerInRound { 
                Pubkey = "M3",
                SupposedOrderOfNextRound = 3,
                FinalOrderOfNextRound = 3
            }
        }
    };
    
    // Simulate miner replacement: Remove M1, add M4
    currentRound.RealTimeMinersInformation.Remove("M1");
    currentRound.RealTimeMinersInformation["M4"] = new MinerInRound { Pubkey = "M4" };
    
    // Attempt to recover from the old round data (block produced by M2)
    // This should throw KeyNotFoundException when trying to access M1
    var exception = Assert.Throws<KeyNotFoundException>(() =>
    {
        currentRound.RecoverFromUpdateValue(providedRound, "M2");
    });
    
    Assert.NotNull(exception);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L142-143)
```csharp
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L103-123)
```csharp
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L10-10)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-40)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-256)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```
