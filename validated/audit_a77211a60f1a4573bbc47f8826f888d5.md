# Audit Report

## Title
Race Condition in Term Change Decision Allows Term Skipping Due to Stale TermNumber

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition exists between `GetConsensusCommand` and `GetConsensusExtraData` in the AEDPoS consensus system. The behavior decision to perform `NextTerm` is made using a snapshot of `CurrentRound.TermNumber`, but the actual term transition data is generated later using fresh state. When multiple miners simultaneously decide to perform term changes at a boundary, this allows the protocol to skip entire terms (e.g., Term 1 → Term 3, skipping Term 2), causing miners to lose rewards and disrupting treasury/election schedules.

## Finding Description

The vulnerability stems from a separation between consensus behavior decision and execution across two distinct method calls:

**Step 1: Behavior Decision (Stale State)**

When a miner calls `GetConsensusCommand`, the system retrieves the current round and creates a behavior provider with this snapshot: [1](#0-0) 

The behavior provider captures `CurrentRound` at instantiation time: [2](#0-1) 

For main chain consensus, the term change decision uses this captured `CurrentRound.TermNumber`: [3](#0-2) 

The decision logic checks if miners have mined in a different time period than `termNumber - 1`: [4](#0-3) 

**Step 2: Execution with Fresh State**

Later, when the miner produces the block, `GetConsensusExtraData` retrieves FRESH state: [5](#0-4) 

For `NextTerm` behavior, it calls `GenerateFirstRoundOfNextTerm` which retrieves current round AGAIN: [6](#0-5) 

The new term round is generated with `currentRound.TermNumber + 1` where `currentRound` is the freshly retrieved value: [7](#0-6) 

**Why Existing Protections Fail:**

The validation only checks that each individual term transition increments by exactly 1: [8](#0-7) 

The execution-time check also validates incremental correctness only: [9](#0-8) 

These checks pass for EACH transition individually (1→2, then 2→3) but don't prevent executing TWO term changes when only ONE is warranted.

**Exploit Scenario:**

1. At term boundary, Miner A calls `GetConsensusCommand` with state showing Term=1, decides `NextTerm`
2. Miner B calls `GetConsensusCommand` with state showing Term=1, also decides `NextTerm`
3. Miner B produces block first, calls `GetConsensusExtraData` with fresh Term=1, generates Term=2, validation passes (1+1==2)
4. Miner A produces block later, calls `GetConsensusExtraData` with fresh Term=2, generates Term=3, validation passes (2+1==3)
5. Result: Protocol skipped Term 2, which only existed for one block

## Impact Explanation

**Direct Financial Impact:**
- Miners elected for the skipped term lose 100% of their expected mining rewards for that term period (typically 7 days worth of blocks)
- The skipped term's miner list is set but never gets meaningful block production time

**Protocol Integrity Violations:**

Treasury releases occur at incorrect intervals tied to term numbers: [10](#0-9) 

Election snapshots are taken with misaligned term numbers: [11](#0-10) 

Mining rewards for the abbreviated term are calculated incorrectly: [12](#0-11) 

This violates the critical consensus invariant that each term must last its full designated period (e.g., 7 days), disrupting the entire economic and governance schedule of the blockchain.

## Likelihood Explanation

**Feasibility: HIGH** - This occurs naturally without any attacker:

1. **No Special Capabilities Required**: Honest miners following normal protocol trigger this
2. **Realistic Preconditions**: 
   - Multiple active miners (typical: 20-100)
   - Term boundary reached (every ~7 days)
   - Natural network latency causes timing variance
3. **Vulnerability Window**: Time between `GetConsensusCommand` call (decision) and `GetConsensusExtraData` call (execution), typically seconds to minutes while waiting for scheduled mining time
4. **Frequency**: Can occur at every term boundary when miners check consensus commands around the same time

The race condition is inherent to the distributed nature of the consensus system where multiple miners independently query and act on state that can change between their decision and execution phases.

## Recommendation

**Solution: Re-validate term change conditions during execution**

Modify `GetConsensusExtraData` to re-check if `NextTerm` is still appropriate given the current state:

```csharp
case AElfConsensusBehaviour.NextTerm:
    // Re-validate that term change is still needed with CURRENT state
    if (!IsMainChain || !currentRound.NeedToChangeTerm(
        GetBlockchainStartTimestamp(), 
        currentRound.TermNumber, 
        State.PeriodSeconds.Value))
    {
        // Term change no longer needed, switch to NextRound instead
        information = GetConsensusExtraDataForNextRound(currentRound, pubkey, triggerInformation);
        information.Behaviour = AElfConsensusBehaviour.NextRound;
    }
    else
    {
        information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
    }
    break;
```

This ensures the behavior decision is validated against current state at execution time, preventing term skipping when another miner's term change has already occurred.

## Proof of Concept

The vulnerability can be demonstrated by simulating the following scenario:

```csharp
// Scenario: Two miners at term boundary
// Initial state: Term 1, Round 100, time = 604800 seconds (term boundary)

// Miner A queries consensus command
var minerA_command = consensusContract.GetConsensusCommand(minerA_pubkey);
// Decision made with Term=1 snapshot: behavior = NextTerm

// Miner B queries consensus command 
var minerB_command = consensusContract.GetConsensusCommand(minerB_pubkey);
// Decision made with Term=1 snapshot: behavior = NextTerm

// Miner B produces block first
var minerB_extraData = consensusContract.GetConsensusExtraData(
    new AElfConsensusTriggerInformation { 
        Pubkey = minerB_pubkey, 
        Behaviour = NextTerm 
    });
// Uses fresh Term=1 state, generates Term=2
// State now: Term=2

// Miner A produces block later (still has stale NextTerm decision)
var minerA_extraData = consensusContract.GetConsensusExtraData(
    new AElfConsensusTriggerInformation { 
        Pubkey = minerA_pubkey, 
        Behaviour = NextTerm 
    });
// Uses fresh Term=2 state, generates Term=3
// State now: Term=3

// Result: Term 2 was skipped (lasted only one block)
// Validation passed both times: 1+1==2 ✓, 2+1==3 ✓
```

The core issue is that the `Behaviour` field in `triggerInformation` is determined at command query time but executed much later with different state, creating a TOCTOU race condition that standard incremental validations cannot prevent.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-53)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L26-37)
```csharp
        protected ConsensusBehaviourProviderBase(Round currentRound, string pubkey, int maximumBlocksCount,
            Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;

            _pubkey = pubkey;
            _maximumBlocksCount = maximumBlocksCount;
            _currentBlockTime = currentBlockTime;

            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
            _minerInRound = CurrentRound.RealTimeMinersInformation[_pubkey];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-47)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-256)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```
