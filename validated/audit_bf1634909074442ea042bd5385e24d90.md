# Audit Report

## Title
Beneficiaries with EndPeriod=long.MaxValue Cannot Be Removed from Schemes with CanRemoveBeneficiaryDirectly=false

## Summary
When a profit scheme has `CanRemoveBeneficiaryDirectly = false` (the default setting) and a beneficiary is added with `EndPeriod = long.MaxValue` (automatically set when EndPeriod is not specified), the scheme manager cannot effectively remove the beneficiary using `RemoveBeneficiary` without providing the `profitDetailId`. The removal silently succeeds without error while the beneficiary continues claiming profits indefinitely, causing permanent share dilution and unauthorized fund drainage from the profit scheme.

## Finding Description

The vulnerability exists in the `RemoveProfitDetails` helper method's filtering logic. [1](#0-0) 

When a manager calls `RemoveBeneficiary`, it invokes `RemoveProfitDetails` to identify which profit details can be removed. [2](#0-1) 

The critical flaw exists at the filtering logic: when `CanRemoveBeneficiaryDirectly = false`, only details where `d.EndPeriod < scheme.CurrentPeriod` are eligible for removal. [3](#0-2)  Since `long.MaxValue` is always greater than or equal to `CurrentPeriod`, beneficiaries with `EndPeriod = long.MaxValue` are NEVER included in `detailsCanBeRemoved`.

The default `EndPeriod` assignment occurs in `AddBeneficiary` where unspecified EndPeriod (value 0) defaults to `long.MaxValue`. [4](#0-3) 

The default value for `CanRemoveBeneficiaryDirectly` is `false` per proto3 specification for boolean fields. [5](#0-4) 

Consequently, when the beneficiary detail is not in `detailsCanBeRemoved`, the removal loop never executes, and `removedDetails.Values.Sum()` returns 0, so nothing is subtracted from `TotalShares`. [6](#0-5) 

A workaround exists where providing a `profitDetailId` can bypass the filter. [7](#0-6)  However, this is non-obvious, undocumented, and requires knowledge of the internal profit detail ID.

The removed beneficiary can continue claiming profits because the claim logic only checks if `EndPeriod >= LastProfitPeriod`, which is always satisfied for `long.MaxValue`. [8](#0-7) 

## Impact Explanation

**Direct Fund Impact:**

1. **Unauthorized Continuous Profit Claims**: After the manager attempts to remove a beneficiary, that beneficiary can continue claiming profits indefinitely because their `ProfitDetail` remains in `ProfitDetailsMap` with `EndPeriod = long.MaxValue`.

2. **Permanent Share Dilution**: The "removed" beneficiary's shares remain in the scheme's `TotalShares`, permanently diluting the profit share of all legitimate beneficiaries. For example, if 1000 tokens are distributed and the removed beneficiary had 100 shares out of 1000 total, they continue receiving 10% of all future distributions.

3. **Manager Authorization Bypass**: The scheme manager's explicit intent to remove a beneficiary is silently ignored by the contract, violating the authorization model where only managers control beneficiary membership.

4. **Undetected Exploitation**: Since `RemoveBeneficiary` returns successfully without error, the manager has no indication that the removal failed, making this issue difficult to detect without querying contract state post-removal.

**Affected Parties**: All schemes created with `CanRemoveBeneficiaryDirectly = false` (the default) where beneficiaries are added without explicitly specifying `EndPeriod`. This includes third-party dApp profit schemes and potentially future system contract upgrades.

## Likelihood Explanation

**Reachable Entry Point**: The vulnerability requires no special privileges beyond normal manager status. The manager unknowingly enables the vulnerability through common usage patterns:
1. Creating a scheme without setting `CanRemoveBeneficiaryDirectly = true`
2. Adding beneficiaries without specifying `EndPeriod`

**Feasible Preconditions**: 
- Default scheme configuration (`CanRemoveBeneficiaryDirectly = false`)
- Common beneficiary addition pattern where EndPeriod is not specified

**Execution Practicality**: 
1. Manager creates scheme with default settings
2. Manager adds beneficiary without EndPeriod (defaults to long.MaxValue)
3. Manager later calls RemoveBeneficiary (without profitDetailId)
4. Removal silently succeeds, beneficiary continues claiming profits

**Detection Constraints**: The vulnerability is silent - `RemoveBeneficiary` succeeds without error, making it undetectable without querying `ProfitDetailsMap` and `TotalShares` post-removal.

**Current System Status**: The Treasury contract creates schemes including the Welfare scheme with `CanRemoveBeneficiaryDirectly = false`. [9](#0-8)  However, the Election contract mitigates this by always specifying explicit EndPeriod values via `GetEndPeriod(lockSeconds)`. [10](#0-9)  This protection is not enforced by the Profit contract itself, leaving third-party dApps vulnerable.

**Probability**: MEDIUM-HIGH for third-party schemes and future system contracts that don't explicitly set `CanRemoveBeneficiaryDirectly = true` or always specify EndPeriod values.

## Recommendation

Implement one of the following fixes in the `RemoveBeneficiary` method:

**Option 1: Fail with clear error message**
```csharp
var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);
if (removedDetails.Values.Sum() == 0 && profitDetails != null && profitDetails.Details.Any())
{
    throw new AssertionException("Cannot remove beneficiary with EndPeriod >= CurrentPeriod. Either set CanRemoveBeneficiaryDirectly=true or provide profitDetailId.");
}
```

**Option 2: Require profitDetailId for non-cancellable schemes**
```csharp
if (!scheme.CanRemoveBeneficiaryDirectly && input.ProfitDetailId == null)
{
    throw new AssertionException("ProfitDetailId is required when CanRemoveBeneficiaryDirectly is false.");
}
```

**Option 3: Force EndPeriod to CurrentPeriod-1 for all details**
Update `RemoveProfitDetails` to always shorten EndPeriod to `scheme.CurrentPeriod.Sub(1)` for beneficiaries being removed, regardless of the filtering logic.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_RemoveBeneficiary_LongMaxValue_Fails()
{
    const int shares = 100;
    var creator = Creators[0];
    var beneficiary = Normal[0];
    var receiverAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);

    // Create scheme with default CanRemoveBeneficiaryDirectly = false
    var schemeId = await CreateSchemeAsync();

    // Add beneficiary without specifying EndPeriod (defaults to long.MaxValue)
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = receiverAddress, Shares = shares },
        SchemeId = schemeId
        // EndPeriod NOT specified - defaults to long.MaxValue
    });

    // Verify TotalShares is 100
    var schemeBefore = await creator.GetScheme.CallAsync(schemeId);
    schemeBefore.TotalShares.ShouldBe(shares);

    // Manager attempts to remove beneficiary
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        Beneficiary = receiverAddress,
        SchemeId = schemeId
        // No ProfitDetailId provided
    });

    // VULNERABILITY: TotalShares should be 0 but remains 100
    var schemeAfter = await creator.GetScheme.CallAsync(schemeId);
    schemeAfter.TotalShares.ShouldBe(shares); // Still 100, not 0!

    // VULNERABILITY: Beneficiary details still exist
    var profitDetails = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = receiverAddress
    });
    profitDetails.Details.Count.ShouldBe(1); // Should be 0, but is 1!
    profitDetails.Details[0].EndPeriod.ShouldBe(long.MaxValue);
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L161-163)
```csharp
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L308-386)
```csharp
    private RemovedDetails RemoveProfitDetails(Scheme scheme, Address beneficiary, Hash profitDetailId = null)
    {
        var removedDetails = new RemovedDetails();

        var profitDetails = State.ProfitDetailsMap[scheme.SchemeId][beneficiary];
        if (profitDetails == null)
        {
            return removedDetails;
        }
        
        // remove all removalbe profitDetails.
        // If a scheme can be cancelled, get all available profitDetail.
        // else, get those available and out of date ones.
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        //id == null
        if (scheme.CanRemoveBeneficiaryDirectly && profitDetailId != null)
        {
            detailsCanBeRemoved = detailsCanBeRemoved.All(d => d.Id != profitDetailId)
                ? detailsCanBeRemoved.Where(d => d.Id == null).ToList()
                : detailsCanBeRemoved.Where(d => d.Id == profitDetailId).ToList();
        }

        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }

        if (detailsCanBeRemoved.Any())
        {
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }

                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
            }

            Context.LogDebug(() => $"ProfitDetails after removing expired details: {profitDetails}");
        }

        var weightCanBeRemoved = profitDetails.Details
            .Where(d => d.EndPeriod == scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        foreach (var profitDetail in weightCanBeRemoved)
        {
            profitDetail.IsWeightRemoved = true;
        }

        var weights = weightCanBeRemoved.Sum(d => d.Shares);
        removedDetails.Add(0, weights);


        // Clear old profit details.
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }

        return removedDetails;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-767)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** protobuf/profit_contract.proto (L129-131)
```text
    // Whether you can directly remove the beneficiary.
    bool can_remove_beneficiary_directly = 5;
    // Use to generate scheme id.
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-68)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```
