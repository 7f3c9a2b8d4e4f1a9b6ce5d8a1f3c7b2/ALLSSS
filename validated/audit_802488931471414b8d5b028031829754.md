# Audit Report

## Title
Missing Validation of Critical Consensus Fields Allows Miners to Corrupt Round State and Manipulate Mining Order

## Summary
The AEDPoS consensus contract fails to validate critical fields in `UpdateValueInput` that control next-round mining orders and secret sharing. The `UpdateValueValidationProvider` only validates the sender's own cryptographic values (OutValue, Signature, PreviousInValue), while `ProcessUpdateValue` directly applies unvalidated fields affecting ALL miners to the round state. This allows any malicious miner to manipulate the mining schedule, exclude honest miners, and corrupt the secret sharing mechanism.

## Finding Description

The validation flow for `UpdateValue` consensus behavior has a critical gap between what is validated and what is applied to state.

**Insufficient Validation**: The `UpdateValueValidationProvider` only validates that the sender's `OutValue` and `Signature` are non-empty [1](#0-0)  and that the sender's `PreviousInValue` correctly hashes to their previous `OutValue` [2](#0-1) .

**Unvalidated Critical Fields**: The `UpdateValueInput` message contains additional fields that control consensus state for ALL miners, including `supposed_order_of_next_round`, `tune_order_information` (a map setting other miners' orders), and `miners_previous_in_values` (a map setting other miners' secret sharing values) [3](#0-2) .

**Unvalidated Application to State**: During execution, `ProcessUpdateValue` directly applies these unvalidated fields:

1. **SupposedOrderOfNextRound** is directly assigned without validation [4](#0-3) , even though it should be calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1` [5](#0-4) .

2. **TuneOrderInformation** allows setting `FinalOrderOfNextRound` for OTHER miners without validation [6](#0-5) .

3. **MinersPreviousInValues** allows setting `PreviousInValue` for OTHER miners without validation [7](#0-6) .

**Critical Impact on Mining Schedule**: The `FinalOrderOfNextRound` values determine the mining order in the next round, where miners are sorted by this field to assign time slots [8](#0-7) .

**Miner Exclusion Vulnerability**: The `GetMinedMiners()` method identifies miners who successfully mined by filtering for `SupposedOrderOfNextRound != 0` [9](#0-8) . By providing manipulated round data that sets other miners' `SupposedOrderOfNextRound` to 0, an attacker can exclude honest miners from reward distribution and consensus participation.

**Validation Flow Weakness**: Before validation, `RecoverFromUpdateValue` updates ALL miners' `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` from the provided round data without any checks [10](#0-9) , which is then used as the base for validation [11](#0-10) .

**Attack Vector**: The `UpdateValue` method is a public entry point [12](#0-11)  called during normal block production, with only basic permission checks requiring the sender to be in the miner list [13](#0-12) . A malicious miner controlling their block can construct consensus extra data with manipulated values that pass validation but corrupt the consensus state.

## Impact Explanation

This vulnerability has **HIGH** severity impact on consensus integrity:

1. **Mining Schedule Manipulation**: A malicious miner can arbitrarily control the mining order for the next round by providing manipulated `TuneOrderInformation`, violating the deterministic VRF-based schedule. This allows the attacker to decide which miners produce blocks at which times.

2. **Honest Miner Exclusion**: By setting other miners' `SupposedOrderOfNextRound` to 0, the attacker can exclude honest miners from `GetMinedMiners()`, affecting reward distribution recorded in the miner list [14](#0-13)  and potentially LIB calculation.

3. **Secret Sharing Corruption**: By providing malicious `MinersPreviousInValues`, the attacker can corrupt the secret sharing mechanism used for random number generation, potentially allowing them to predict or influence random values used in consensus.

4. **Consensus Disruption**: These manipulations can cause improper time slot assignments, reward miscalculations, and allow a single malicious miner to gain disproportionate control over block production scheduling.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

1. **Easily Reachable**: The attack occurs during normal block production when it's the malicious miner's turn to produce a block.

2. **Minimal Prerequisites**: The attacker only needs to be an elected miner in the miner list, achievable through the normal election process.

3. **Simple Exploitation**: The attacker generates proper consensus data, modifies the Round object to include malicious values for other miners, and includes it in their block header. The validation only checks their own cryptographic values (OutValue, Signature, PreviousInValue) and not the values affecting other miners.

4. **No Detection**: The validation flow does not check `SupposedOrderOfNextRound` correctness, `TuneOrderInformation` legitimacy, or `MinersPreviousInValues` validity, so malicious values are accepted and persisted to state.

5. **Immediate Effect**: Once a malicious block is accepted, the corrupted state becomes canonical and affects all subsequent consensus operations.

## Recommendation

Add comprehensive validation in `UpdateValueValidationProvider.ValidateHeaderInformation()`:

1. **Validate SupposedOrderOfNextRound**: Verify that `minerInRound.SupposedOrderOfNextRound == GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1` for the sender.

2. **Validate TuneOrderInformation**: For each entry in `TuneOrderInformation`, verify that:
   - The original `SupposedOrderOfNextRound` of the tuned miner conflicts with another miner's value
   - The new `FinalOrderOfNextRound` is the next available order that doesn't conflict
   - Only legitimate conflict resolution is performed

3. **Validate MinersPreviousInValues**: Verify that values in `MinersPreviousInValues` come from legitimate secret sharing by checking decrypted pieces and encrypted pieces consistency.

4. **Add order uniqueness check**: For `UpdateValue` behavior, add validation similar to `NextRoundMiningOrderValidationProvider` but correctly check uniqueness of `FinalOrderOfNextRound` integer values, not object references.

## Proof of Concept

A malicious miner during their time slot can:
1. Call the consensus contract to generate proper consensus data
2. Modify the `Round` object before including it in the block to set arbitrary `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` for other miners
3. Include this modified consensus data in their block header
4. The validation passes because it only checks the miner's own `OutValue`, `Signature`, and `PreviousInValue`
5. `ProcessUpdateValue` persists the corrupted values to state, affecting mining order, reward distribution, and secret sharing

The attack is feasible because miners control the blocks they produce and can modify consensus extra data before block submission, while validation fails to verify the critical fields that affect other miners' consensus participation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-231)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
