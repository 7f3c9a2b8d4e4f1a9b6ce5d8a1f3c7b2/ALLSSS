# Audit Report

## Title
VoteId Collision Leading to Permanent Token Lock and Vote Record Corruption

## Summary
The VoteContract generates VoteId without including the VotingItemId, using only the transaction origin, contract address, and the voting item's VotesAmount counter. When multiple votes on different voting items with identical VotesAmount values occur within the same transaction, they produce the same VoteId, causing the second vote to overwrite the first vote's record while tokens accumulate in the same virtual address. This results in permanent token lock for the overwritten vote amount and corrupted voting state.

## Finding Description

The vulnerability exists in the VoteId generation mechanism within the `AssertValidVoteInput` method. The VoteId is computed using `Context.GenerateId`, which concatenates the OriginTransactionId, contract address, and the VotesAmount counter: [1](#0-0) 

The underlying `GenerateId` implementation confirms this concatenation: [2](#0-1) 

**Critical Flaw**: The VoteId does NOT include the VotingItemId. Each voting item maintains its own independent VotesAmount counter, retrieved via a hash that includes the VotingItemId: [3](#0-2) 

When two different voting items have the same VotesAmount value and both votes occur in the same transaction (sharing the same OriginTransactionId), they generate identical VoteIds.

**Why Protections Fail:**

1. **No Collision Detection**: The Vote method directly overwrites VotingRecords without checking for existing entries: [4](#0-3) 

   Unlike the Election contract which has explicit collision protection: [5](#0-4) 

2. **Lock Accumulation**: The token contract's Lock mechanism computes a virtual address deterministically from the sender, user address, and LockId: [6](#0-5) 

   When the same LockId (VoteId) is used twice, tokens accumulate in the same virtual address without error.

3. **Shared OriginTransactionId**: All inline calls within a transaction share the same OriginTransactionId, enabling the collision.

**Execution Path:**

1. Attacker deploys a contract that calls `VoteContract.Vote.Send()` twice within the same method
2. First vote on Item A (VotesAmount = X) generates VoteId = Hash(TxId + Contract + X), locks 100 tokens
3. Second vote on Item B (VotesAmount = X) generates identical VoteId, locks 200 tokens to same virtual address
4. Second vote overwrites `State.VotingRecords[VoteId]`, only Item B record survives
5. Virtual address contains 300 tokens total, but only 200 tokens can be unlocked based on surviving record
6. 100 tokens remain permanently locked

## Impact Explanation

**Direct Fund Loss:**
Tokens from the overwritten vote become permanently locked in the virtual address. The surviving VotingRecord only tracks the second vote's amount: [7](#0-6) 

The Unlock method can only withdraw the amount specified in the surviving VotingRecord: [8](#0-7) 

**Example Scenario:**
- Vote 1: 100 tokens on Item A (VotesAmount = 0) → VoteId = Hash(Tx + Contract + 0)
- Vote 2: 200 tokens on Item B (VotesAmount = 0) → VoteId = Hash(Tx + Contract + 0)
- Virtual address receives 300 tokens total
- Only VotingRecord for Item B (200 tokens) exists
- Withdrawal unlocks 200 tokens
- **100 tokens permanently locked**

**Vote Record Corruption:**
The first vote's record is completely lost, causing incorrect vote tallies for Item A. The VotedItemsMap is updated for both items: [9](#0-8) 

But only one VotingRecord exists, creating state inconsistency.

**Severity: HIGH** - Direct financial loss with permanent token lock, no recovery mechanism, and corruption of core voting functionality.

## Likelihood Explanation

**Attacker Capabilities:**
- Standard user permissions (no privileged access required)
- Ability to deploy a contract with multiple Vote calls
- Ability to identify voting items with matching VotesAmount

**Attack Complexity: LOW**

1. Identify two voting items with `IsLockToken = true` that have identical VotesAmount values (newly registered items start with VotesAmount = 0): [10](#0-9) 
2. Deploy a contract that makes two `VoteContract.Vote.Send()` calls in sequence
3. Execute transaction - collision occurs automatically

**Feasibility Conditions:**
- **Common scenario**: Newly registered voting items all start with VotesAmount = 0
- **Inline transactions supported**: AElf's SendInline allows multiple Vote calls in one transaction
- **No restrictions**: Any user can vote on multiple items

**Probability: MEDIUM-HIGH** - Preconditions are easily achievable, attack is technically straightforward, and can occur accidentally with legitimate multi-voting contracts.

## Recommendation

Add collision detection in the `Vote` method before storing the VotingRecord:

```csharp
// In Vote method, before line 117
var existingRecord = State.VotingRecords[input.VoteId];
Assert(existingRecord == null || existingRecord.VotingItemId == input.VotingItemId, 
    "Vote ID collision detected.");

State.VotingRecords[input.VoteId] = votingRecord;
```

Alternatively, include the VotingItemId in the VoteId generation to ensure uniqueness:

```csharp
// In AssertValidVoteInput method, replace line 397
input.VoteId = Context.GenerateId(Context.Self, 
    ByteArrayHelper.ConcatArrays(
        votingItem.VotingItemId.Value.ToArray(),
        votingResult.VotesAmount.ToBytes(false)
    ));
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteIdCollision_ShouldCausePermanentTokenLock()
{
    // Setup: Register two voting items
    var item1Id = await RegisterVotingItem("ITEM1");
    var item2Id = await RegisterVotingItem("ITEM2");
    
    // Both items start with VotesAmount = 0
    var voter = Accounts[1];
    var initialBalance = await GetBalance(voter);
    
    // Deploy malicious contract that votes twice in same transaction
    var voteAmount1 = 100_00000000;
    var voteAmount2 = 200_00000000;
    
    // Execute double vote in single transaction
    await ExecuteDoubleVote(voter, item1Id, voteAmount1, item2Id, voteAmount2);
    
    // Verify collision occurred
    var voteId = await GetGeneratedVoteId(); // Both votes generated same ID
    var votingRecord = await GetVotingRecord(voteId);
    
    // Only second vote record exists
    votingRecord.VotingItemId.ShouldBe(item2Id);
    votingRecord.Amount.ShouldBe(voteAmount2);
    
    // Verify tokens locked in virtual address
    var virtualAddress = await GetVirtualLockAddress(voter, voteId);
    var lockedBalance = await GetBalance(virtualAddress);
    lockedBalance.ShouldBe(voteAmount1 + voteAmount2); // 300 tokens
    
    // Attempt withdrawal
    await WithdrawVote(voter, voteId);
    
    // Only second vote amount unlocked
    var finalBalance = await GetBalance(voter);
    var expectedBalance = initialBalance - voteAmount1; // First vote tokens lost
    finalBalance.ShouldBe(expectedBalance);
    
    // Verify permanent lock
    var remainingLocked = await GetBalance(virtualAddress);
    remainingLocked.ShouldBe(voteAmount1); // 100 tokens permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L57-63)
```csharp
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L193-231)
```csharp
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L392-393)
```csharp
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-146)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L433-433)
```csharp
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```
