# Audit Report

## Title
Accounting Error in Recharge Function Allows Insufficient Balance to Mark Side Chain as Active

## Summary
The `Recharge()` function contains a double-counting error in its balance validation logic that allows side chains with indexing fee debt to be marked as Active with insufficient balance. This violates the critical invariant that Active side chains must have at least `IndexingPrice` tokens to pay for indexing operations.

## Finding Description

The vulnerability exists in the balance validation check within the `Recharge()` function. [1](#0-0) 

**Execution Flow:**

1. User calls `Recharge()` with `input.Amount` tokens
2. Tokens are transferred from user to the side chain's virtual address via `TransferFrom` [2](#0-1) 
3. If the side chain is in `IndexingFeeDebt` status, arrears are paid to proposers from the virtual address [3](#0-2) 
4. After arrears payment, `GetSideChainIndexingFeeDeposit()` retrieves the current virtual address balance [4](#0-3) 
5. The buggy assertion checks: `input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice` [5](#0-4) 

**The Critical Error:**

The `GetSideChainIndexingFeeDeposit()` function queries the token balance of the virtual address, which already includes the recharged amount minus paid arrears. [6](#0-5) 

Therefore:
- `originBalance` = `initial_balance + input.Amount - arrearsAmount`
- The assertion becomes: `input.Amount + (initial_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice`
- Simplifying: `2 * input.Amount + initial_balance >= 2 * arrearsAmount + IndexingPrice`

This double-counts `input.Amount`, making the check too lenient.

**Concrete Example:**
- Given: `initial_balance = 0`, `arrearsAmount = 100`, `IndexingPrice = 10`
- Correct requirement: recharge with 110 tokens
- Buggy check allows: recharging with only 105 tokens
- Result: side chain marked Active with balance of 5 (insufficient for the required 10)

**Why This Breaks Protocol:**

When the next indexing occurs, the `IndexSideChainBlockData` function attempts to deduct `IndexingPrice` from the balance. [7](#0-6) 

With only 5 tokens available (but needing 10), the `lockedToken` becomes negative [8](#0-7) , triggering the side chain to revert to `IndexingFeeDebt` status and accumulating new arrears. The proposer receives no payment.

## Impact Explanation

**Direct Protocol Impact:**
- **Invariant Violation**: The critical invariant that Active side chains must have `balance >= IndexingPrice` is broken
- **Reward Misdirection**: Proposers who index blocks for "Active" chains won't receive payment and accumulate arrears instead [9](#0-8) 
- **Status Unreliability**: Side chain operators are misled about their chain's true operational status [10](#0-9) 

**Quantified Damage:**
The underfunding gap ranges from ~4.5% to 25% depending on the ratio of arrears to indexing price. Using the example:
- Required: 110 tokens (100 arrears + 10 minimum balance)
- Actual: 105 tokens allowed by bug
- Shortfall: 5 tokens (4.5% underfunding)

This creates "zombie" Active chains that immediately revert to debt status upon the next indexing attempt, harming both operators and proposers.

## Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point**: `Recharge()` is a public method callable by any user [11](#0-10) 

2. **Common Preconditions**: 
   - Side chains naturally enter `IndexingFeeDebt` status during normal operations when their balance depletes [12](#0-11) 
   - Users routinely hold tokens and set allowances for the CrossChain contract

3. **Simple Execution**: Requires only a single transaction with a calculated amount - no complex sequences or race conditions

4. **Economic Incentive**: Users can save 5-25% of required recharge costs, representing significant value for large arrears

5. **Low Detection**: The transaction succeeds without reverting, and the error only manifests on the next indexing attempt, making it difficult to detect immediately

## Recommendation

The assertion should check the balance BEFORE the recharge transfer, or adjust the formula to avoid double-counting. The correct check should be:

```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

Alternatively, query the balance before the `TransferFrom` call and use that in the assertion:

```csharp
var balanceBeforeRecharge = GetSideChainIndexingFeeDeposit(chainId);
TransferFrom(new TransferFromInput { ... });
// ... pay arrears ...
Assert(input.Amount + balanceBeforeRecharge >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

## Proof of Concept

```csharp
[Fact]
public async Task Recharge_DoubleCounting_Vulnerability()
{
    // Setup: Create side chain with indexingPrice = 10, lockedToken = 2
    var indexingPrice = 10;
    var lockedToken = 2;
    var sideChainId = await InitAndCreateSideChainAsync(10, 123, lockedToken, indexingPrice, AnotherKeyPair);
    
    // Index 12 blocks (needs 120 tokens, only have 2) -> creates 110 arrears
    var blockDataList = new List<SideChainBlockData>();
    for (int i = 1; i <= 12; i++)
    {
        blockDataList.Add(CreateSideChainBlockData(HashHelper.ComputeFrom($"hash{i}"), i, sideChainId, HashHelper.ComputeFrom("merkle")));
    }
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { blockDataList } }, new[] { sideChainId });
    
    // Verify in debt with 110 arrears
    var status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.IndexingFeeDebt);
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(110);
    
    // Exploit: Recharge with 105 (should need 110 + 10 = 120, but bug allows 105)
    await ApproveBalanceAsync(105, AnotherKeyPair);
    var crossChainStub = GetCrossChainContractStub(AnotherKeyPair);
    await crossChainStub.Recharge.SendAsync(new RechargeInput { ChainId = sideChainId, Amount = 105 });
    
    // Side chain is now Active but with only 5 tokens (needs 10)
    status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.Active);
    var balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(5); // Insufficient! Should have 10
    
    // Next indexing fails - immediate revert to debt
    var nextBlock = CreateSideChainBlockData(HashHelper.ComputeFrom("hash13"), 13, sideChainId, HashHelper.ComputeFrom("merkle"));
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { nextBlock } }, new[] { sideChainId });
    status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.IndexingFeeDebt); // Reverted to debt!
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L816-892)
```csharp
    private List<SideChainBlockData> IndexSideChainBlockData(IList<SideChainBlockData> sideChainBlockDataList,
        Address proposer, int chainId)
    {
        var indexedSideChainBlockData = new List<SideChainBlockData>();

        {
            var formattedProposerAddress = proposer.ToByteString().ToBase64();
            long indexingFeeAmount = 0;

            var sideChainInfo = State.SideChainInfo[chainId];
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            long arrearsAmount = 0;
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);

            foreach (var sideChainBlockData in sideChainBlockDataList)
            {
                var target = currentSideChainHeight != 0
                    ? currentSideChainHeight + 1
                    : AElfConstants.GenesisBlockHeight;
                var sideChainHeight = sideChainBlockData.Height;
                if (target != sideChainHeight)
                    break;

                // indexing fee
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }

            State.SideChainInfo[chainId] = sideChainInfo;
            State.CurrentSideChainHeight[chainId] = currentSideChainHeight;
            
            Context.Fire(new SideChainIndexed
            {
                ChainId = chainId,
                IndexedHeight = currentSideChainHeight
            });
        }

        if (indexedSideChainBlockData.Count > 0)
            Context.LogDebug(() =>
                $"Last indexed height {indexedSideChainBlockData.Last().Height} for side chain {chainId}");

        return indexedSideChainBlockData;
```
