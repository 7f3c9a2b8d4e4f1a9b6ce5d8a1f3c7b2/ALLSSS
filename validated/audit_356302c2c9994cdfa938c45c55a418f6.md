# Audit Report

## Title
Consensus Halt Attack via Empty Miner List in NextRound Validation

## Summary
The `ValidationForNextRound()` method in `RoundTerminateValidationProvider` fails to validate that the next round must contain miners. When `RealTimeMinersInformation` is empty, the validation incorrectly succeeds, allowing a malicious miner to transition the blockchain to a round with zero miners, permanently halting consensus.

## Finding Description

The vulnerability exists in the round termination validation logic where the validation only checks that InValues should be null for a fresh round. [1](#0-0) 

When `RealTimeMinersInformation` is an empty collection, the `Any(m => m.InValue != null)` expression returns false (standard C# behavior for empty collections), causing the validation to incorrectly return success.

The validation flow processes NextRound behavior through multiple validators. [2](#0-1) 

Other validators fail to prevent empty miner lists:

- **MiningPermissionValidationProvider** only checks if the sender is in the current (BaseRound) miner list, not the proposed next round: [3](#0-2) 

- **NextRoundMiningOrderValidationProvider** compares counts that are both zero when the list is empty (0 == 0 passes validation): [4](#0-3) 

Once validated, the empty round is stored via `AddRoundInformation` and becomes the new current round: [5](#0-4) 

The storage implementation directly writes the round to state without additional validation: [6](#0-5) 

## Impact Explanation

**Complete Consensus Halt**: After the empty round is stored, all miners are permanently locked out. When any miner attempts to get a consensus command through the ACS4 interface, the check fails: [7](#0-6) 

The `IsInMinerList()` implementation checks if a pubkey exists in `RealTimeMinersInformation.Keys`: [8](#0-7) 

With an empty `RealTimeMinersInformation` dictionary, this check always returns false for ALL miners, causing `GetConsensusCommand` to return `InvalidConsensusCommand`.

Additionally, the `PreCheck()` mechanism in consensus processing also validates miner membership: [9](#0-8) 

**Consequences:**
- No miner can produce blocks (consensus command always invalid)
- No transactions can be processed
- Blockchain operations halt completely
- Recovery requires hard fork or chain restart
- All pending transactions are stuck
- Economic activity ceases entirely

**Severity**: CRITICAL - This violates the fundamental consensus invariant that valid rounds must contain miners, breaking the blockchain's availability guarantee.

## Likelihood Explanation

**Attacker Capabilities**: Any current miner who becomes the extra block producer or is within their time slot can execute this attack. The attacker only needs to craft a `NextRoundInput` with empty `RealTimeMinersInformation` and call the public `NextRound` method: [10](#0-9) 

The `ToRound()` method directly copies the miner information without validation: [11](#0-10) 

**Attack Complexity**: LOW
- Attacker simply crafts a NextRound transaction with empty `RealTimeMinersInformation`
- No complex cryptographic manipulation required
- Single transaction execution

**Preconditions**: 
- Attacker must be a legitimate miner in the current round (feasible for insider threat or compromised miner)
- Attacker must have the opportunity to produce a NextRound block (happens naturally during round transitions)

**Economic Cost**: Minimal - The attacker only needs to be an existing miner with no additional cost beyond transaction fees.

**Detection**: The attack would be detected immediately upon execution (consensus halt), but by then it's too late - the damage is done and requires hard fork to recover.

**Probability**: MEDIUM-HIGH - Malicious miners periodically get opportunities to produce NextRound blocks during normal consensus operations.

## Recommendation

Add explicit validation to ensure the next round contains miners. In `RoundTerminateValidationProvider.ValidationForNextRound()`, add a check before the InValue validation:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // NEW: Validate that next round contains miners
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Next round must contain at least one miner." };
    
    // Validate InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test that shows an empty miner list passing validation and being stored:

```csharp
[Fact]
public async Task EmptyMinerList_PassesValidation_CausesConsensusHalt()
{
    // Arrange: Get current miner and round
    var currentMiner = SampleAccount.Accounts.First().KeyPair;
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Act: Create NextRoundInput with EMPTY miner list
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = { }, // EMPTY!
        TermNumber = currentRound.TermNumber,
        BlockchainAge = currentRound.BlockchainAge + 1000,
        RandomNumber = HashHelper.ComputeFrom("random").ToByteString()
    };
    
    // Execute NextRound with empty miner list
    var result = await AEDPoSContractStub.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Succeeds!
    
    // Assert: Consensus is now halted - no miner can get valid command
    var newRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Count.ShouldBe(0); // Empty!
    
    // All miners now get InvalidConsensusCommand
    var command = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        ByteStringHelper.FromHexString(currentMiner.PublicKey.ToHex()).ToBytesValue());
    command.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L105-105)
```csharp
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
