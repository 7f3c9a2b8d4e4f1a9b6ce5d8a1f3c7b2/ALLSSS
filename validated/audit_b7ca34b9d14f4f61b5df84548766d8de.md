# Audit Report

## Title
Missing Miner List Validation in NextRound Enables Consensus DoS via Bloated RealTimeMinersInformation Dictionary

## Summary
The AEDPoS consensus contract fails to validate that the miner list in submitted `NextRound` inputs matches the current round's miner list. A malicious miner can inject a bloated `Round` object with an inflated `RealTimeMinersInformation` dictionary, causing excessive computational overhead in subsequent consensus operations and leading to denial of service.

## Finding Description

The vulnerability stems from insufficient validation when processing `NextRound` transactions. The contract stores the submitted `Round` object without verifying that the miner keys in `RealTimeMinersInformation` match the current round's legitimate miner list.

**Missing Validation:**

The `RoundTerminateValidationProvider` only validates round number increments and that InValues are null: [1](#0-0) 

The `NextRoundMiningOrderValidationProvider` only validates internal consistency of the provided round, not comparison with the current round's miner list: [2](#0-1) 

The validation service for NextRound behavior only adds these two validators without any miner list composition check: [3](#0-2) 

**Exploitation Path:**

1. A malicious miner (who must be in the current legitimate miner list) submits a `NextRound` transaction with a crafted `Round` object containing hundreds or thousands of fake entries in `RealTimeMinersInformation` (21 legitimate miners + 979 fake miners = 1000 total).

2. The `NextRound` public method processes the input: [4](#0-3) 

3. The malicious round passes validation because the sender is in the current round's miner list and the round's internal structure is consistent. The `ProcessNextRound` method converts the input to a Round object and stores it directly: [5](#0-4) 

4. The bloated round is stored via `AddRoundInformation` without any miner list validation: [6](#0-5) 

5. When subsequent rounds are generated, `GenerateNextRoundInformation` derives from the bloated round, propagating all fake miners to the next round: [7](#0-6) 

6. Two rounds after injection, when producing a NextRound block, `RevealSharedInValues` iterates over the bloated `previousRound.RealTimeMinersInformation` with OrderBy, causing excessive computational overhead: [8](#0-7) 

The iteration with `OrderBy` at line 25 has O(m log m) complexity where m is the bloated dictionary size. Even though miners without sufficient encrypted/decrypted pieces are skipped (lines 35-36), the sorting overhead still occurs.

## Impact Explanation

**Consensus Denial of Service:**
- Miners attempting to produce NextRound blocks experience excessive gas consumption in `RevealSharedInValues` due to the O(n log n) sorting complexity over a bloated miner list
- The bloated miner list persists across all subsequent rounds within the term via the propagation mechanism in `GenerateNextRoundInformation`, causing sustained disruption
- Consensus progression becomes extremely expensive or impossible until NextTerm is called, which could be days or weeks away

**Protocol Disruption:**
- All network participants are affected as consensus round transitions degrade
- The attack violates the critical consensus invariant that the miner list should remain constant within a term (except for legitimate replacements)
- Block production may fail or become prohibitively expensive

**Severity Justification:**
While transaction size limits (5MB) constrain the magnitude, even moderate inflation (100-1000 fake miners vs. typical 17-21 legitimate miners) causes significant performance degradation. The complete absence of miner list validation represents a fundamental consensus integrity failure.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner with block production rights, achievable through the normal election process by obtaining sufficient votes
- Can craft arbitrary `NextRoundInput` messages with bloated `RealTimeMinersInformation` dictionaries

**Attack Complexity:**
- Low: Simply create a `Round` object with the 21 legitimate miners (with proper FinalOrderOfNextRound > 0) plus 979 fake miners (with FinalOrderOfNextRound = 0)
- The fake miner entries need minimal data to pass existing internal consistency validations
- No special privileges beyond normal miner status are required

**Feasibility:**
- Transaction size limits (5MB) provide bounded constraints but don't prevent the attack
- Each MinerInRound entry is relatively small (100-200 bytes), allowing 1000+ fake entries within limits
- No detection mechanism exists to identify malicious round data before it's stored
- The attack is reproducible and straightforward to execute once miner status is obtained

## Recommendation

Add a new validation provider that verifies the miner list composition in NextRound inputs matches the current round's miner list:

```csharp
public class MinerListCompositionValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        
        if (extraData.Behaviour != AElfConsensusBehaviour.NextRound)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        var baseRoundMinerKeys = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var providedRoundMinerKeys = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        if (baseRoundMinerKeys.Count != providedRoundMinerKeys.Count || 
            !baseRoundMinerKeys.SequenceEqual(providedRoundMinerKeys))
        {
            validationResult.Message = "Provided round miner list does not match current round miner list.";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this provider to the validation chain in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new MinerListCompositionValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithBloatedMinerList_ShouldCauseDoS()
{
    // Setup: Initialize consensus with 5 legitimate miners
    var initialMiners = GenerateMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Attacker (first miner) crafts a bloated NextRound input
    var legitimateMiners = GetCurrentRoundInformation().RealTimeMinersInformation;
    var bloatedRound = CreateBloatedRound(
        legitimateMiners: legitimateMiners,
        fakeMinersCount: 1000  // Add 1000 fake miners
    );
    
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = { bloatedRound.RealTimeMinersInformation },
        // ... other required fields
    };
    
    // Attack: Submit bloated NextRound (should be rejected but isn't)
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Round was stored with bloated miner list
    var storedRound = await GetRoundInformation(2);
    storedRound.RealTimeMinersInformation.Count.ShouldBe(1005); // 5 + 1000
    
    // Impact: Subsequent rounds propagate the bloat
    await ProduceNormalBlocks(5); // Progress through round 2
    var nextRound = await GenerateNextRound(); // Generate round 3
    nextRound.RealTimeMinersInformation.Count.ShouldBe(1005); // Bloat propagated
    
    // DoS: Excessive computation in RevealSharedInValues
    var startTime = DateTime.Now;
    await ProduceNextRoundBlock(); // From round 3 to 4
    var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
    
    // Verify DoS: Operation takes significantly longer with bloated list
    elapsed.ShouldBeGreaterThan(5000); // > 5 seconds for 1000 miners vs < 100ms normally
}
```

**Notes:**
- The vulnerability exists because no validator compares the provided round's miner keys against the current round's miner keys
- The attacker must be an elected miner, but election is achievable through normal voting mechanisms
- The 5MB transaction size limit allows for significant bloating (1000+ fake miners)
- The DoS persists for the entire term duration as the bloated list propagates through `GenerateNextRoundInformation`
- The O(n log n) sorting complexity in `RevealSharedInValues` causes measurable performance degradation that worsens with larger bloat

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```
