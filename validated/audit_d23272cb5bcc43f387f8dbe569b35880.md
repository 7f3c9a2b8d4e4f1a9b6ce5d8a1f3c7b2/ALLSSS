# Audit Report

## Title
Deterministic Infinite Loop in Symbol Number Generation Causes DoS of NFT Protocol Creation

## Summary
The `GenerateSymbolNumber()` function contains a critical infinite loop vulnerability where the collision-checking loop attempts to regenerate a random number using an unchanging hash value. Since `Context.ConvertHashToInt64` is deterministic, any collision with an existing protocol number results in an infinite loop that consumes all transaction gas and permanently blocks that specific NFT protocol creation attempt.

## Finding Description

The NFT contract uses `IsCreatedMap` to track which symbol numbers have been assigned to NFT protocols. [1](#0-0) 

The vulnerability exists in the `GenerateSymbolNumber()` helper function. The root cause is that `randomHash` is computed once before the collision-checking do-while loop and is never updated within the loop. [2](#0-1) 

The `Context.ConvertHashToInt64` method is deterministic - it uses modulo arithmetic to convert a hash to a number within a specified range. Given the same hash input and range parameters, it always returns the same output. [3](#0-2) 

When a collision occurs (the generated number already exists in `IsCreatedMap`), the while condition evaluates to true, but since `randomHash` never changes, the same number is produced on every iteration, creating an infinite loop. The deterministic nature of the hash conversion function guarantees that given identical inputs (same hash, same range), the output will always be identical.

The `GenerateSymbolNumber()` function is called during NFT protocol creation via the public `Create` method. [4](#0-3) [5](#0-4) 

## Impact Explanation

**Severity: HIGH - Denial of Service of Core Protocol Functionality**

The `Create` function is publicly callable by any user on the aelf mainchain to establish new NFT protocols. [6](#0-5) 

As NFT protocols accumulate, collision probability increases according to the birthday paradox. When a collision occurs:

1. The transaction enters an infinite loop
2. All available gas is consumed
3. The transaction fails without creating the protocol
4. The same transaction parameters will deterministically fail again

**Who is affected:** All users attempting to create NFT protocols once collision probability becomes significant. The functionality becomes increasingly unreliable and eventually unusable.

**No recovery mechanism exists:** Because the hash generation uses deterministic inputs (sender address and block-derived random bytes), retrying with the same sender at a different block height might succeed, but there's no guarantee, and users have no control over avoiding collisions.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH (increases with protocol adoption)**

**Attacker Capabilities:** No special privileges required - any user can call the public `Create()` method.

**Attack Complexity:** No intentional attack needed. This is a natural occurrence as protocol usage grows:
1. Sufficient protocols exist to create meaningful collision probability
2. Any user attempts to create a new protocol
3. The random number generation produces a collision
4. Infinite loop triggers automatically

**Feasibility:** The collision becomes increasingly likely as more protocols are created, following birthday paradox statistics.

**Detection:** Transaction timeout or gas exhaustion will occur, making the issue immediately visible to affected users.

**Probability:** The bug is deterministic - once a collision occurs with a specific hash, that transaction configuration will always fail. The overall likelihood depends on adoption levels but becomes inevitable as the protocol set grows.

## Recommendation

Update the `GenerateSymbolNumber()` method to regenerate the random hash on each collision attempt. The fixed code should update the randomness source within the loop:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    var nonce = 0;
    do
    {
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        
        // Add nonce to ensure different hash on each iteration
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(nonce));
        
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        nonce++;
        
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

Alternatively, implement a maximum retry limit and throw an explicit error if exceeded, preventing gas exhaustion while alerting users to retry.

## Proof of Concept

```csharp
[Fact]
public async Task InfiniteLoopOnCollisionTest()
{
    // Setup: Create an NFT protocol to populate IsCreatedMap
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = 1_00000000_00000000,
        To = DefaultAddress
    });

    // This test demonstrates the vulnerability conceptually
    // In a real scenario, after sufficient protocols are created (~30,000+),
    // natural collisions will occur due to birthday paradox
    // When a collision happens, the transaction will:
    // 1. Enter the do-while loop in GenerateSymbolNumber
    // 2. Generate the same randomNumber repeatedly (deterministic)
    // 3. Never exit the loop (State.IsCreatedMap[randomNumber] always true)
    // 4. Consume all gas and fail
    
    // To actually trigger this in a test environment would require:
    // - Mocking Context.ConvertHashToInt64 to return a pre-existing number
    // - Or creating thousands of protocols until natural collision occurs
    // Both approaches are impractical for unit testing but the logic flaw is evident
    
    // The vulnerability exists at:
    // contract/AElf.Contracts.NFT/NFTContract_Helpers.cs lines 79-82
    // where randomHash is never updated inside the collision-checking loop
}
```

**Notes**

The vulnerability is confirmed by code inspection:
- The `randomHash` variable is computed once outside the loop and never modified inside
- `Context.ConvertHashToInt64` is a pure function (deterministic conversion)
- The collision check uses a do-while loop with no hash regeneration mechanism
- No maximum iteration limit or timeout exists

This creates a guaranteed infinite loop scenario when collisions occur, which becomes statistically inevitable as the number of created NFT protocols grows.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L10-10)
```csharp
    public MappedState<long, bool> IsCreatedMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-82)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```
