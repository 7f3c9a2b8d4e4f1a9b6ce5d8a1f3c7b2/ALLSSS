# Audit Report

## Title
Non-Member Proposers Can Create Unreleased Proposals, Causing Governance Release Deadlock

## Summary
The Association contract fails to validate that proposers must be organization members during organization creation. This allows non-member proposers to create proposals that members can approve but cannot release, causing permanent governance deadlock when the non-member proposer is unavailable or uncooperative.

## Finding Description

The vulnerability exists in the organization validation logic, which fails to enforce a critical governance invariant: proposers must be organization members.

**Validation Gap**: The `Validate` method checks that both `ProposerWhiteList` and `OrganizationMemberList` are non-empty and contain no duplicates, but does NOT verify that proposer addresses must also be organization members. [1](#0-0) 

**Organization Creation**: This insufficient validation is enforced when creating organizations: [2](#0-1) 

**Proposal Creation**: When creating proposals, the contract only verifies the sender is in the `ProposerWhiteList`, not that they are a member: [3](#0-2) 

**Voting Mechanism**: Members can vote on any proposal by verifying membership, regardless of who created it: [4](#0-3) [5](#0-4) 

**Release Restriction**: The critical flaw is in the `Release` function, which enforces that ONLY the original proposer can release a proposal: [6](#0-5) 

**No Recovery Mechanism**: There is no alternative method to execute proposals. The `ClearProposal` method only removes expired proposals without executing them: [7](#0-6) 

**Attack Path:**
1. Organization is created with `ProposerWhiteList = {NonMemberX}` and `OrganizationMemberList = {MemberA, MemberB, MemberC}`
2. NonMemberX creates a critical governance proposal
3. Members vote and approve the proposal, meeting the release threshold
4. NonMemberX becomes unavailable or refuses to call `Release()`
5. The approved proposal can never be executed

## Impact Explanation

**HIGH Severity - Governance DoS:**
- Critical approved governance actions cannot be executed if the non-member proposer is unavailable
- Members lose effective control over their organization despite having voting power
- Can permanently block critical operations like threshold changes, member management, or fund transfers
- Time-sensitive proposals may expire before resolution
- Malicious proposers can hold organizations hostage for extortion

This breaks the fundamental governance invariant that organizations should be able to execute their approved proposals. All system contract implementations (TokenContract, CrossChainContract) implicitly assume proposers are members by setting both lists identically, but the validation doesn't enforce this assumption. [8](#0-7) [9](#0-8) 

## Likelihood Explanation

**HIGH Likelihood:**
- The `CreateOrganization` method is publicly accessible
- The validation explicitly allows non-member proposers
- Can occur through accidental misconfiguration or intentional malicious setup
- No special privileges required beyond being included in the proposer whitelist
- Zero-cost to exploit once the vulnerable configuration exists
- Economically rational for extortion scenarios

## Recommendation

Add validation to ensure all proposers are also organization members:

```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    
    // NEW: Validate all proposers are members
    if (organization.ProposerWhiteList.Proposers.Any(proposer => 
        !organization.OrganizationMemberList.Contains(proposer)))
        return false;
    
    if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
        return false;
    
    // ... rest of validation
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NonMemberProposer_CannotRelease_CausesDeadlock()
{
    // Create organization with non-member proposer
    var nonMemberProposer = Accounts[10].Address;
    var members = new[] { Reviewer1, Reviewer2, Reviewer3 };
    
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members } },
            ProposerWhiteList = new ProposerWhiteList { Proposers = { nonMemberProposer } },
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 2,
                MinimalVoteThreshold = 2,
                MaximalRejectionThreshold = 0,
                MaximalAbstentionThreshold = 0
            }
        });
    
    // Non-member creates proposal
    var proposerStub = GetAssociationContractTester(Accounts[10].KeyPair);
    var proposalId = await proposerStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        Params = new TransferInput { To = Reviewer1, Amount = 100, Symbol = "ELF" }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    });
    
    // Members approve the proposal
    var reviewer1Stub = GetAssociationContractTester(Reviewer1KeyPair);
    var reviewer2Stub = GetAssociationContractTester(Reviewer2KeyPair);
    await reviewer1Stub.Approve.SendAsync(proposalId.Output);
    await reviewer2Stub.Approve.SendAsync(proposalId.Output);
    
    // Proposal is approved but members cannot release it
    var releaseResult = await reviewer1Stub.Release.SendWithExceptionAsync(proposalId.Output);
    releaseResult.TransactionResult.Error.ShouldContain("No permission");
    
    // Governance deadlock: approved proposal cannot be executed by members
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L626-648)
```csharp
    private CreateOrganizationInput GenerateOrganizationInputForIndexingFeePrice(
        IList<Address> organizationMembers)
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposerWhiteList = new ProposerWhiteList
            {
                Proposers = { organizationMembers }
            },
            OrganizationMemberList = new OrganizationMemberList
            {
                OrganizationMembers = { organizationMembers }
            },
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = organizationMembers.ToList().Count,
                MinimalVoteThreshold = organizationMembers.ToList().Count,
                MaximalRejectionThreshold = 0,
                MaximalAbstentionThreshold = 0
            }
        };
        return createOrganizationInput;
    }
```
