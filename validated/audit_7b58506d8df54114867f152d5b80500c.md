# Audit Report

## Title
Unverified Secret Sharing Data Allows Malicious Miners to Poison Consensus Random Number Generation

## Summary
The AEDPoS consensus contract's `PerformSecretSharing` function accepts decrypted secret pieces and revealed InValues from miners without cryptographic verification. A malicious miner can submit arbitrary values for other miners' decrypted pieces and PreviousInValues, corrupting the consensus random number generation chain and breaking Shamir Secret Sharing security guarantees.

## Finding Description

The vulnerability exists in the secret sharing mechanism where miners submit `UpdateValueInput` containing `decrypted_pieces` and `miners_previous_in_values` maps for OTHER miners. The on-chain contract blindly trusts this data without verification. [1](#0-0) 

**Attack Flow:**

1. **Malicious Input**: Attacker (active miner) calls `UpdateValue` with crafted data containing arbitrary values in `decrypted_pieces` (map of victim miner pubkey → fake decrypted bytes) and `miners_previous_in_values` (map of victim miner pubkey → fake InValue hash).

2. **Unvalidated Processing**: `ProcessUpdateValue` calls `PerformSecretSharing` when secret sharing is enabled. [2](#0-1) 

3. **Direct State Pollution**: `PerformSecretSharing` directly adds attacker's fake decrypted pieces to OTHER miners' records without any validation: [3](#0-2) 

For each entry in `input.DecryptedPieces`, the code adds the attacker's claimed "decryption" to the victim miner's `DecryptedPieces` collection. Similarly, `input.MinersPreviousInValues` directly overwrites other miners' `PreviousInValue` fields.

4. **Corrupted Secret Reconstruction**: Later, `RevealSharedInValues` uses these poisoned pieces to reconstruct secrets via Shamir Secret Sharing: [4](#0-3) 

The reconstruction uses ALL decrypted pieces (including poisoned ones) to decode the secret, producing corrupted InValues.

**Why Validation Fails:**

The `UpdateValueValidationProvider` only validates the submitter's OWN `PreviousInValue` by verifying hash consistency: [5](#0-4) 

There is **NO validation** that:
- Decrypted pieces were correctly decrypted from encrypted pieces
- `miners_previous_in_values` are legitimate revealed secrets  
- Any cryptographic proof of correct decryption exists

**Off-Chain vs On-Chain Security Gap:**

The off-chain `SecretSharingService` properly performs cryptographic encryption/decryption: [6](#0-5) 

However, the on-chain contract has no mechanism to verify that submitted data matches these cryptographically computed values.

## Impact Explanation

**High Severity** - This breaks critical consensus security guarantees:

1. **Consensus Random Number Chain Corruption**: While VRF verification validates each block's random number contribution, the underlying InValue chain feeding future rounds can be poisoned. The protocol relies on InValues for random number generation, and corrupted InValues propagate through subsequent rounds.

2. **Shamir Secret Sharing Protocol Failure**: The security model assumes at least 2/3 of shares are honest. However, a single malicious miner can inject fake decrypted pieces into ALL N-1 other miners' records in one transaction, completely bypassing the threshold security. When reconstruction occurs, it uses these poisoned pieces, producing wrong InValues.

3. **Signature Chain Integrity**: Consensus signatures are calculated based on `PreviousInValue`. Poisoned values affect signature calculations in subsequent rounds, cascading through the consensus mechanism.

4. **Network-Wide Single-Point-of-Failure**: One malicious miner can poison data for ALL other miners simultaneously through the `decrypted_pieces` map, requiring no collusion and affecting the entire validator set.

## Likelihood Explanation

**High Likelihood** - The attack is trivially executable:

1. **Low Attacker Requirements**: Only requires being an active miner in the consensus validator set, which is the standard threat model for Byzantine fault tolerance testing.

2. **Simple Execution**: Attacker modifies two map fields (`decrypted_pieces` and `miners_previous_in_values`) in `UpdateValueInput` to arbitrary values. No cryptographic breaking, key compromise, or complex exploitation needed.

3. **Guaranteed Success**: Zero on-chain validation of the poisoned data ensures 100% success rate.

4. **Realistic Preconditions**: Only requires secret sharing to be enabled: [2](#0-1) 

5. **Hard to Detect**: No validation failures, assertions, or events occur. Detection requires independent off-chain verification comparing all submitted decrypted pieces against encrypted pieces using cryptographic decryption.

## Recommendation

Implement cryptographic verification of decrypted pieces on-chain. Options include:

1. **Zero-Knowledge Proofs**: Require miners to submit ZK proofs that decrypted pieces were correctly derived from encrypted pieces using proper decryption.

2. **On-Chain Decryption Verification**: If feasible within gas constraints, verify that `CryptoHelper.DecryptMessage(senderPubkey, receiverPrivateKey, encryptedPiece) == decryptedPiece` using signature-based proof techniques.

3. **Hash Chain Commitments**: Require miners to commit to decrypted pieces via hash before revealing, then verify consistency with encrypted pieces through cryptographic challenge-response.

4. **Restrict Decrypted Piece Submission**: Only allow miners to submit their OWN decrypted pieces (pieces they decrypted for themselves), not pieces claiming to represent OTHER miners' decryptions. Modify `PerformSecretSharing` to reject entries where `decryptedPreviousInValue.Key != publicKey`.

Recommended immediate fix:
```csharp
// In PerformSecretSharing, replace the blind trust with validation
foreach (var decryptedPreviousInValue in input.DecryptedPieces)
{
    // Only allow miners to submit pieces they decrypted FOR THEMSELVES
    // i.e., the attacker's decryption of victim's encrypted piece sent to attacker
    if (decryptedPreviousInValue.Key != publicKey) 
    {
        // Reject: miner cannot submit decryptions for OTHER miners
        continue; // or Assert(false, "Invalid decrypted piece submission");
    }
    
    round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
        .Add(publicKey, decryptedPreviousInValue.Value);
}
```

Similarly, prevent miners from setting OTHER miners' `PreviousInValue` directly.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Set up a multi-miner consensus scenario (e.g., 5 miners)
2. Have Miner A (attacker) submit `UpdateValueInput` with:
   - `DecryptedPieces["MinerB"] = fake_bytes`
   - `DecryptedPieces["MinerC"] = fake_bytes`
   - `MinersPreviousInValues["MinerB"] = fake_hash`
3. Verify that `round.RealTimeMinersInformation["MinerB"].DecryptedPieces["MinerA"]` now contains the fake bytes
4. Verify that `round.RealTimeMinersInformation["MinerB"].PreviousInValue` is set to the fake hash
5. Call `RevealSharedInValues` and observe it uses the poisoned pieces in Shamir reconstruction
6. Demonstrate the reconstructed InValue is incorrect compared to the legitimate value

Based on the existing test structure in: [7](#0-6) 

A similar test could be written that injects fake data during the `UpdateValue` call and verifies state corruption occurs without any validation failures.

## Notes

This vulnerability is particularly severe because:
- It bypasses the cryptographic security of the Shamir Secret Sharing protocol at the application layer
- The VRF verification in `ProcessConsensusInformation` only validates the random number proof, not the secret sharing data
- No Byzantine fault tolerance threshold protection exists since one miner can poison all others
- The attack surface exists in production consensus code, not test/mock files

### Citations

**File:** protobuf/aedpos_contract.proto (L209-216)
```text
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-53)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L127-138)
```csharp
            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
        }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/InValueRecoveryTest.cs (L20-62)
```csharp
    [Fact]
    public void OffChain_DecryptMessage_Test()
    {
        var message = HashHelper.ComputeFrom("message").ToByteArray();
        var secrets =
            SecretSharingHelper.EncodeSecret(message, MinimumCount,
                EconomicContractsTestConstants.InitialCoreDataCenterCount);
        var encryptedValues = new Dictionary<string, byte[]>();
        var decryptedValues = new Dictionary<string, byte[]>();
        var ownerKeyPair = InitialCoreDataCenterKeyPairs[0];
        var othersKeyPairs = InitialCoreDataCenterKeyPairs.Skip(1).ToList();
        var decryptResult = new byte[0];

        var initial = 0;
        foreach (var keyPair in othersKeyPairs)
        {
            var encryptedMessage = CryptoHelper.EncryptMessage(ownerKeyPair.PrivateKey, keyPair.PublicKey,
                secrets[initial++]);
            encryptedValues.Add(keyPair.PublicKey.ToHex(), encryptedMessage);
        }

        // Check encrypted values.
        encryptedValues.Count.ShouldBe(EconomicContractsTestConstants.InitialCoreDataCenterCount - 1);

        // Others try to recover.
        foreach (var keyPair in othersKeyPairs)
        {
            var cipherMessage = encryptedValues[keyPair.PublicKey.ToHex()];
            var decryptMessage =
                CryptoHelper.DecryptMessage(ownerKeyPair.PublicKey, keyPair.PrivateKey, cipherMessage);
            decryptedValues.Add(keyPair.PublicKey.ToHex(), decryptMessage);

            if (decryptedValues.Count >= MinimumCount)
            {
                decryptResult = SecretSharingHelper.DecodeSecret(
                    decryptedValues.Values.ToList(),
                    Enumerable.Range(1, MinimumCount).ToList(), MinimumCount);
                break;
            }
        }

        decryptResult.ShouldBe(message);
    }
```
