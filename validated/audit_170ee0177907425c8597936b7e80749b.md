# Audit Report

## Title
FixProfitDetail Allows Retroactive Profit Claims Through Unconstrained StartPeriod Modification

## Summary
The `FixProfitDetail` method in the Profit contract permits scheme managers to arbitrarily modify a beneficiary's `StartPeriod` to any historical value without validation. This enables beneficiaries to retroactively claim profits from periods before they were added to the scheme, violating the fundamental profit distribution invariant and diluting legitimate beneficiaries' shares.

## Finding Description

The vulnerability exists in the `FixProfitDetail` method which performs only authorization checks but lacks validation on the `StartPeriod` value being set. [1](#0-0) 

When a beneficiary is legitimately added via `AddBeneficiary`, their `StartPeriod` is correctly initialized to ensure they only receive profits from when they joined onwards: [2](#0-1) 

However, `FixProfitDetail` allows the manager to replace this value with any period through a simple conditional assignment, with no validation that the new `StartPeriod` is greater than or equal to the original, greater than or equal to the current period, or within valid scheme distribution periods. [3](#0-2) 

When `ClaimProfits` is called for the first time (when `LastProfitPeriod == 0`), it initializes `LastProfitPeriod` to the manipulated `StartPeriod`: [4](#0-3) 

The `ProfitAllPeriods` method then iterates from this manipulated starting period, calculating and transferring tokens from historical period virtual addresses: [5](#0-4) 

**Evidence of Design Intent:**

The only production usage in the Election contract never modifies `StartPeriod` - it explicitly sets the input value to 0 to preserve the original, with a comment confirming this intent: [6](#0-5) 

The comment states "The endPeriod is updated and startPeriod is 0, others stay still", indicating the design intent is to preserve the original `StartPeriod`.

## Impact Explanation

**Direct Fund Theft**: A scheme manager can:
1. Add a beneficiary at period N with legitimate `StartPeriod = N`
2. Before the beneficiary claims, call `FixProfitDetail` to set `StartPeriod = 1`
3. The beneficiary claims and receives profits from periods 1 through N-1

**Share Dilution**: When a beneficiary claims retroactive profits using shares that didn't exist in those historical periods, the profit calculation uses their current shares divided by the `TotalShares` from those earlier periods. This directly withdraws tokens from the period virtual addresses, reducing what remains available for legitimate beneficiaries who were actually present during those periods.

**Governance Bypass**: For DAO-controlled schemes (Treasury, Election welfare schemes managed by Parliament), the manager can unilaterally redistribute historical profits without governance approval, bypassing intended control mechanisms.

**Value at Risk**: All historical accumulated profits in any scheme are vulnerable. For major schemes like Treasury citizen welfare distributions, this represents significant token amounts accumulated over many periods.

## Likelihood Explanation

**Attack Complexity**: Extremely simple - requires only a single `FixProfitDetail` transaction with a modified `StartPeriod` parameter.

**Attacker Capabilities**: Requires scheme manager access. The critical issue is that even legitimate managers have MORE power than the design intends:
- For DAO-managed schemes, this bypasses governance controls (manager acts unilaterally when governance approval should be required)
- For any scheme, this violates the expected invariant that beneficiaries only receive profits from their participation period onwards
- Compromised manager keys enable direct exploitation

**Feasibility Conditions**: 
- Scheme must have distributed profits in historical periods (common for active schemes)
- Beneficiary must not have claimed yet (typical for newly added beneficiaries)
- Manager retains access
- No additional preconditions required

**Detection Difficulty**: The `StartPeriod` modification is a permanent state change. After claiming, profits are transferred and cannot be recovered. On-chain events show the claim but may not clearly reveal the period manipulation.

## Recommendation

Add validation in the `FixProfitDetail` method to ensure `StartPeriod` cannot be decreased:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    // ... existing authorization checks ...
    
    var newDetail = fixingDetail.Clone();
    
    // Validate StartPeriod if being modified
    if (input.StartPeriod != 0)
    {
        Assert(input.StartPeriod >= fixingDetail.StartPeriod, 
            "Cannot decrease StartPeriod to claim historical profits.");
    }
    
    newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
    newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
    
    // ... rest of method ...
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task FixProfitDetail_RetroactiveClaim_ShouldFail()
{
    // Setup: Create scheme and distribute profits in period 1
    var schemeId = await CreateScheme();
    await DistributeProfitsForPeriod(schemeId, period: 1, amount: 1000);
    
    // Add beneficiary in period 2 (should only get profits from period 2 onwards)
    await AdvanceToPeriod(2);
    await AddBeneficiary(schemeId, beneficiary: userAddress, shares: 500);
    
    // Attack: Manager manipulates StartPeriod to period 1
    await FixProfitDetail(schemeId, beneficiary: userAddress, startPeriod: 1);
    
    // Exploit: Beneficiary claims and receives profits from period 1
    await ClaimProfits(schemeId, beneficiary: userAddress);
    
    // Verify: Beneficiary received historical profits they shouldn't have
    var balance = await GetTokenBalance(userAddress);
    Assert.True(balance > 0, "Beneficiary illegitimately claimed profits from period 1");
}
```

## Notes

This is a broken access control vulnerability where scheme managers have excessive privileges beyond the design intent. The vulnerability is particularly severe for DAO-managed schemes where the manager role should be constrained by governance processes. The Election contract's explicit preservation of `StartPeriod` values demonstrates the intended behavior that `FixProfitDetail` violates.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L777-784)
```csharp
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-895)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L143-154)
```csharp
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```
