# Audit Report

## Title
Side Chain Miner Count Limit Bypass via Cross-Chain Synchronization

## Summary
Side chains can operate with more miners than the governance-configured `MaximumMinersCount` limit because the cross-chain synchronization path accepts and persists an unlimited miner list from the main chain without validation. This breaks the consensus security model where miner count affects decentralization, block intervals, and reward distribution.

## Finding Description

The AEDPoS consensus contract on side chains fails to enforce the `MaximumMinersCount` limit when receiving miner lists from the main chain via cross-chain synchronization. The vulnerability exists across multiple unchecked code paths:

**Root Cause 1: Unvalidated Cross-Chain Update**

The `UpdateInformationFromCrossChain` method extracts all miners from the main chain's consensus information and stores them without checking against the side chain's configured limit. [1](#0-0) 

**Root Cause 2: Unchecked NextTermInput Creation**

The `Create()` method copies all entries from `round.RealTimeMinersInformation` without validation against the maximum miners count. [2](#0-1) 

**Root Cause 3: Side Chain Fallback Path**

Side chains return false from `TryToGetVictories` because they don't use election victories, causing the fallback to use the unvalidated current round's miner list. [3](#0-2) 

The fallback path that uses the unvalidated miner list: [4](#0-3) 

**Root Cause 4: Unvalidated Term Processing**

`ProcessNextTerm` creates a `MinerList` from ALL keys in `nextRound.RealTimeMinersInformation` and stores it without checking the count limit. [5](#0-4) 

**Root Cause 5: Insufficient Validation**

The `ValidationForNextTerm` method only validates term and round number increments but does NOT check if the miner count exceeds `MaximumMinersCount`. [6](#0-5) 

**Critical Finding: MaximumMinersCount Only Used for Reporting**

The `GetMinersCount` method enforces `MaximumMinersCount` via `Math.Min`, but this is ONLY used to report to the Election contract via `UpdateMinersCountToElectionContract`, not to limit actual consensus participation. [7](#0-6) [8](#0-7) 

**Block Production Uses Unvalidated List**

The mining permission validation only checks if a sender exists in `RealTimeMinersInformation.Keys`, meaning ALL miners in the round (regardless of count) can produce blocks. [9](#0-8) 

**Side Chain Round Generation Path**

When the main chain miner list changes, side chains generate a new round using ALL synchronized miners without validation. [10](#0-9) 

The miner list generation iterates through ALL pubkeys without checking the maximum count. [11](#0-10) 

## Impact Explanation

**Consensus Integrity Violation:**

Side chains can operate with arbitrarily many block producers, violating the governance-approved `MaximumMinersCount` safety parameter. If the main chain has 25 miners and the side chain's limit is 17, all 25 miners will participate in consensus on the side chain, breaking the intended security model.

**Concrete Harms:**

1. **Security Degradation:** More miners than intended changes the security assumptions around block finality, fork resolution, and Byzantine fault tolerance thresholds. The consensus algorithm's security properties are designed based on a specific miner count.

2. **Economic Inconsistency:** The Election contract receives a capped miner count via `UpdateMinersCountToElectionContract`, but the actual consensus round operates with more miners. This creates accounting mismatches in reward calculations and distribution logic.

3. **Governance Bypass:** The `MaximumMinersCount` parameter set by Parliament via `SetMaximumMinersCount` becomes unenforceable on side chains, rendering governance decisions ineffective. This undermines the entire governance model for consensus parameters.

**Affected Parties:**
- Side chain validators expecting security guarantees from the configured miner limit
- Side chain governance expecting their `MaximumMinersCount` setting to be enforced
- Economic contracts receiving inconsistent miner count information

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is not an attack but a design flaw that triggers automatically during normal cross-chain synchronization:

1. **Reachable Entry Point:** `UpdateInformationFromCrossChain` is called by the CrossChain contract during routine cross-chain indexing as part of the ACS11 consensus synchronization standard. [12](#0-11) 

2. **Realistic Preconditions:**
   - Side chain exists with `MaximumMinersCount` configured (standard setup)
   - Main chain has more miners than side chain's limit (common as main chains typically have more miners for higher security)
   - Cross-chain indexing is active (required for normal side chain operation)

3. **Automatic Trigger:** No attacker action needed - happens during normal cross-chain synchronization whenever the main chain's miner count exceeds the side chain's configured limit.

4. **Reproducible:** This is deterministic behavior, not a race condition or timing issue. Every cross-chain consensus sync will persist the full main chain miner list.

## Recommendation

Add validation in multiple layers to enforce the `MaximumMinersCount` limit:

1. **In `UpdateInformationFromCrossChain`**: Validate the incoming miner list size before storing:
   ```csharp
   var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
   Assert(minersKeys.Count <= State.MaximumMinersCount.Value, 
          "Main chain miner count exceeds side chain's maximum limit");
   ```

2. **In `ProcessNextTerm`**: Validate the miner list size before creating the term:
   ```csharp
   var miners = new MinerList();
   miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
   Assert(miners.Pubkeys.Count <= State.MaximumMinersCount.Value,
          "Miner count exceeds maximum limit");
   ```

3. **In `ValidationForNextTerm`**: Add miner count validation:
   ```csharp
   if (extraData.Round.RealTimeMinersInformation.Count > State.MaximumMinersCount.Value)
       return new ValidationResult { Message = "Miner count exceeds maximum limit." };
   ```

4. **Alternative Design**: Instead of asserting, truncate the miner list to the maximum count, selecting miners based on a deterministic algorithm (e.g., first N miners by sorted public key).

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Deploy a main chain with 25 miners participating in consensus
2. Deploy a side chain with `MaximumMinersCount` set to 17
3. Enable cross-chain indexing between main chain and side chain
4. Observe that after `UpdateInformationFromCrossChain` is called, the side chain's `State.MainChainCurrentMinerList.Value` contains all 25 miner public keys
5. When the next term begins on the side chain, all 25 miners participate in consensus, not just 17
6. Verify that `GetMinersCount` returns 17 (capped value), but `GetCurrentMinerList` returns 25 miners
7. Confirm that all 25 miners can successfully produce blocks by checking mining permission validation

This demonstrates that the governance-configured limit is bypassed during normal operations, with no special attacker actions required.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-38)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L234-242)
```csharp
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```
