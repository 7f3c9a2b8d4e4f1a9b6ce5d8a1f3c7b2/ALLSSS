# Audit Report

## Title
Creator Impersonation Vulnerability in NFT Protocol Creation

## Summary
The NFT contract's `Create()` function accepts an arbitrary address in the `input.Creator` field without verifying that the transaction sender owns or controls that address. This allows any attacker to create NFT protocols falsely attributed to victim addresses, causing reputation damage, unwanted administrative responsibilities, and potential legal liability.

## Finding Description
The vulnerability exists in the NFT protocol creation flow where the creator address is accepted without authorization verification. [1](#0-0) 

The assigned creator address is then used as the token issuer in the underlying MultiToken contract: [2](#0-1) 

The MultiToken contract's `RegisterTokenInfo` method only validates that the issuer is not null, providing no ownership verification: [3](#0-2) 

Critically, the creator is automatically added to the minter list: [4](#0-3) 

Furthermore, only the designated creator can manage the minter list through `AddMinters`: [5](#0-4) 

And `RemoveMinters`: [6](#0-5) 

The `Create` function is publicly accessible with only a chain ID restriction: [7](#0-6) 

The NFT contract is whitelisted in the MultiToken contract's create whitelist (as confirmed in test infrastructure), bypassing seed NFT requirements: [8](#0-7) 

**Attack Flow:**
1. Attacker calls `NFTContract.Create()` with `input.Creator = victimAddress`
2. NFT contract forwards to `TokenContract.Create()` with `Issuer = victimAddress`
3. MultiToken accepts because NFT contract is whitelisted and issuer is non-null
4. Token created with victim as issuer, victim added to minter list
5. Only victim can now manage the minter list, despite never authorizing the protocol creation

## Impact Explanation
**Reputation Damage**: Attackers can create unlimited NFT protocols falsely attributed to any address. Prominent community members, organizations, or competitors can be made to appear as creators of protocols they never authorized.

**Unwanted Administrative Burden**: Victims become the sole managers of the minter list for protocols they didn't create. If they want to remove themselves as minters or delegate control, they must spend gas and time managing these unwanted protocols.

**Legal and Compliance Risk**: If an attacker creates NFT protocols containing illegal content (copyright violations, offensive material, scams) with a victim's address as creator, the victim bears reputational and potentially legal consequences from association.

**Protocol Integrity**: The blockchain becomes polluted with fake protocol creations that cannot be easily distinguished from legitimate ones, degrading trust in the entire NFT ecosystem.

## Likelihood Explanation
**Attack Complexity**: Trivial - requires only a single transaction calling `Create()` with a spoofed `Creator` field.

**Attacker Prerequisites**: None - any user with the ability to submit transactions to the mainchain can execute this attack. No special permissions, governance approvals, or economic barriers exist.

**Preconditions**: The function only checks that the transaction is on the AELF mainchain. No allowlist, reputation system, or economic stake requirement protects against abuse.

**Economic Cost**: Minimal - only standard transaction gas fees.

**Detection Difficulty**: Victims cannot proactively detect these attacks without monitoring all `NFTProtocolCreated` events on the chain and filtering for their address, which is impractical for most users.

## Recommendation
Add authorization verification to ensure the transaction sender controls the creator address:

```csharp
public override StringValue Create(CreateInput input)
{
    Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
        "NFT Protocol can only be created at aelf mainchain.");
    
    // FIX: Require sender to be the creator
    var creator = input.Creator ?? Context.Sender;
    Assert(creator == Context.Sender, 
        "Creator address must match transaction sender.");
    
    // ... rest of the function
}
```

Alternatively, remove the `Creator` field from `CreateInput` and always use `Context.Sender`:

```csharp
var creator = Context.Sender; // Always use actual caller
```

## Proof of Concept
The following test demonstrates the vulnerability by creating an NFT protocol with an arbitrary creator address:

```csharp
[Fact]
public async Task CreatorImpersonation_Attack()
{
    // Attacker creates NFT protocol attributed to victim (DefaultAddress)
    // but calls from a different address (MinterAddress)
    var attackResult = await MinterNFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://malicious/",
        Creator = DefaultAddress, // Victim address
        IsBurnable = true,
        NftType = NFTType.Any.ToString(),
        ProtocolName = "FAKE",
        TotalSupply = 1000000
    });
    
    var symbol = attackResult.Output.Value;
    
    // Verify: Protocol shows DefaultAddress as creator
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = symbol });
    protocolInfo.Creator.ShouldBe(DefaultAddress); // Victim falsely attributed
    
    // Verify: Victim is in minter list but didn't authorize this
    var minterList = await NFTContractStub.GetMinterList.CallAsync(
        new StringValue { Value = symbol });
    minterList.Value.ShouldContain(DefaultAddress);
    
    // Verify: Only victim can manage minters (attacker locked out)
    var addMinterFailed = await MinterNFTContractStub.AddMinters.SendWithExceptionAsync(
        new AddMintersInput
        {
            Symbol = symbol,
            MinterList = new MinterList { Value = { MinterAddress } }
        });
    addMinterFailed.TransactionResult.Error.ShouldContain("No permission");
}
```

## Notes
This vulnerability represents a fundamental authorization flaw where the contract accepts user-provided addresses for privileged roles without verification. The NFT contract's whitelisting in the MultiToken contract (necessary for its legitimate operation) inadvertently enables this attack by bypassing the seed NFT requirement that would normally require proof of authorization. The issue requires immediate remediation to prevent reputation attacks and protocol spam on the AElf mainchain NFT ecosystem.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-18)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-352)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L259-265)
```csharp
    private bool IsAddressInCreateWhiteList(Address address)
    {
        return address == Context.GetZeroSmartContractAddress() ||
               address == GetDefaultParliamentController().OwnerAddress ||
               address == Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName) ||
               address == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);
    }
```
