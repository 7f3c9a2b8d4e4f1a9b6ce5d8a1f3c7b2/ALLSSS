# Audit Report

## Title
Inconsistent Vote Counting After Member Replacement Allows Governance Threshold Bypass

## Summary
The Association contract's `ChangeMember()` function fails to invalidate votes from removed members on active proposals. Due to inconsistent vote counting logic in threshold verification, removed members' votes still count toward `MinimalVoteThreshold` while being excluded from approval/rejection/abstention counts, enabling proposals to pass with fewer current members participating than governance rules require.

## Finding Description

The vulnerability stems from the interaction between member replacement and vote threshold validation in the Association contract.

When `ChangeMember()` is called, it removes the old member from the organization's member list and adds the new member, but does NOT clear any votes the old member cast on active proposals. [1](#0-0) 

The vote lists (`approvals`, `rejections`, `abstentions`) in `ProposalInfo` are defined as repeated address fields that persist independently of the organization member list. [2](#0-1) 

During proposal release verification via `IsReleaseThresholdReached()`, the system employs inconsistent counting logic:

**For approval threshold checking (FILTERED by current membership):**
The approval count uses `.Count(organization.OrganizationMemberList.Contains)` which filters out votes from removed members. [3](#0-2) 

**For rejection threshold checking (FILTERED by current membership):**
The rejection count also uses `.Count(organization.OrganizationMemberList.Contains)`. [4](#0-3) 

**For abstention threshold checking (FILTERED by current membership):**
The abstention count also uses `.Count(organization.OrganizationMemberList.Contains)`. [5](#0-4) 

**For total vote threshold checking (UNFILTERED - THE VULNERABILITY):**
The total vote count concatenates all vote lists and counts without membership filtering, meaning removed members' votes still count toward `MinimalVoteThreshold`. [6](#0-5) 

This inconsistency violates the governance invariant that requires a minimum number of **current** organization members to participate in voting before a proposal can be released. The threshold structure defines `minimal_vote_threshold` as the minimum total votes needed. [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

This vulnerability directly undermines the Association governance mechanism by allowing proposals to pass without the required level of current member participation.

**Concrete Attack Scenario:**
1. Organization configured with `MinimalVoteThreshold = 7` and `MinimalApprovalThreshold = 5`
2. A proposal is created requiring both thresholds to be met
3. 5 current members approve the proposal
4. 2 members vote (abstain or reject - doesn't matter which)
5. Those 2 members are replaced via `ChangeMember()` proposals
6. The proposal now passes because:
   - `approvalCount` = 5 (only current members) ≥ 5 ✓
   - `totalVoteCount` = 7 (includes removed members) ≥ 7 ✓
   - Only 5 current members participated, violating the 7-member participation requirement

**Who is affected:**
- All Association-based governance organizations
- Particularly critical for organizations with member rotation policies
- High-value organizations controlling funds, configuration, or system parameters

**Potential consequences:**
- Unauthorized proposal releases with insufficient current member oversight
- Governance threshold requirements effectively lowered below configured values
- Malicious coalitions can strategically replace members to manipulate vote counts
- Legitimate member rotation inadvertently enables premature proposal releases

## Likelihood Explanation

**Likelihood: HIGH**

**Required Capabilities:**
`ChangeMember()` requires `Context.Sender` to be the organization address itself, meaning it can only be executed via a governance proposal. [8](#0-7) 

**Attack Path:**
1. Coalition controls enough votes to pass `ChangeMember()` proposals
2. Target proposal is created and members vote on it
3. Coalition passes `ChangeMember()` proposals to replace members who already voted
4. Target proposal now meets thresholds with fewer current members

**Feasibility Factors:**
- **Intentional Exploit**: A malicious coalition with majority control can deliberately orchestrate member replacement to manipulate vote counts
- **Unintentional Trigger**: Routine member rotation during active proposals naturally triggers this vulnerability without malicious intent
- **Detection Difficulty**: The inconsistency is not visible in events or easily queryable state
- **No Special Privileges**: Only requires normal governance participation rights
- **Low Cost**: Only transaction fees for governance proposals

**Realistic Scenarios:**
- Organizations with scheduled member rotations (term limits, role changes)
- Emergency member replacements due to compromised keys
- Natural member turnover in DAOs
- Strategic manipulation by majority coalitions

## Recommendation

The `CheckEnoughVoteAndApprovals` method should filter the total vote count by current membership, consistent with how approval/rejection/abstention counts are filtered:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership
    var totalCurrentMemberVotes = proposal.Abstentions
        .Concat(proposal.Approvals)
        .Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalCurrentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures only votes from current members count toward the minimum vote threshold.

## Proof of Concept

```csharp
[Fact]
public async Task ChangeMember_Allows_Governance_Threshold_Bypass()
{
    // Setup: Create organization with 7 members
    // MinimalVoteThreshold = 7 (all must participate)
    // MinimalApprovalThreshold = 5 (5 must approve)
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, 
                         Accounts[4].Address, Accounts[5].Address, 
                         Accounts[6].Address, Accounts[7].Address };
    
    var createOrgInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { members }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5,
            MinimalVoteThreshold = 7,
            MaximalAbstentionThreshold = 2,
            MaximalRejectionThreshold = 2
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }
        }
    };
    
    var orgResult = await AssociationContractStub.CreateOrganization.SendAsync(createOrgInput);
    var orgAddress = orgResult.Output;
    
    // Create target proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, orgAddress);
    
    // 5 members approve
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Reviewer3KeyPair, proposalId);
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[5].KeyPair).Approve.SendAsync(proposalId);
    
    // 2 members abstain (to reach MinimalVoteThreshold = 7)
    await GetAssociationContractTester(Accounts[6].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[7].KeyPair).Abstain.SendAsync(proposalId);
    
    // Verify proposal cannot be released yet (correctly - only 7 votes but need all 7 current members)
    var proposalBefore = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalBefore.ToBeReleased.ShouldBeFalse(); // Would be true with 7 votes if all were current members
    
    // Create and execute ChangeMember proposals to replace the 2 abstaining members
    var changeMember1Input = new ChangeMemberInput 
    { 
        OldMember = Accounts[6].Address, 
        NewMember = Accounts[8].Address 
    };
    var changeMember1Proposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, changeMember1Input, nameof(AssociationContractStub.ChangeMember), orgAddress);
    
    // Pass ChangeMember proposal with required votes
    await ApproveAsync(Reviewer1KeyPair, changeMember1Proposal);
    await ApproveAsync(Reviewer2KeyPair, changeMember1Proposal);
    await ApproveAsync(Reviewer3KeyPair, changeMember1Proposal);
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(changeMember1Proposal);
    await GetAssociationContractTester(Accounts[5].KeyPair).Approve.SendAsync(changeMember1Proposal);
    
    await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(changeMember1Proposal);
    
    var changeMember2Input = new ChangeMemberInput 
    { 
        OldMember = Accounts[7].Address, 
        NewMember = Accounts[9].Address 
    };
    var changeMember2Proposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, changeMember2Input, nameof(AssociationContractStub.ChangeMember), orgAddress);
    
    await ApproveAsync(Reviewer1KeyPair, changeMember2Proposal);
    await ApproveAsync(Reviewer2KeyPair, changeMember2Proposal);
    await ApproveAsync(Reviewer3KeyPair, changeMember2Proposal);
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(changeMember2Proposal);
    await GetAssociationContractTester(Accounts[5].KeyPair).Approve.SendAsync(changeMember2Proposal);
    
    await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(changeMember2Proposal);
    
    // VULNERABILITY: Original proposal can now be released
    // Even though only 5 CURRENT members participated (not 7)
    var proposalAfter = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalAfter.ToBeReleased.ShouldBeTrue(); // BUG: Should be false!
    
    // Proposal can be released with insufficient current member participation
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // BUG: Should fail!
}
```

## Notes

The root cause is in the `CheckEnoughVoteAndApprovals` method which counts total votes without filtering by current membership, while all other vote counts (approvals, rejections, abstentions) are properly filtered. This creates a window where removed members' votes artificially inflate the participation count, allowing proposals to pass governance thresholds with fewer current members than required.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L248-263)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** protobuf/acs3.proto (L128-137)
```text
message ProposalReleaseThreshold {
    // The value for the minimum approval threshold.
    int64 minimal_approval_threshold = 1;
    // The value for the maximal rejection threshold.
    int64 maximal_rejection_threshold = 2;
    // The value for the maximal abstention threshold.
    int64 maximal_abstention_threshold = 3;
    // The value for the minimal vote threshold.
    int64 minimal_vote_threshold = 4;
}
```
