# Audit Report

## Title
Miner List Manipulation via Unvalidated NextRound Input Allows Unauthorized Consensus Participation

## Summary
The AEDPoS consensus contract fails to validate that the miner list in a proposed `NextRound` matches the current round's authorized miners. A malicious miner can submit a `NextRoundInput` with additional unauthorized miner entries, which gets stored in state without validation. These unauthorized miners can then obtain valid consensus commands and participate in block production, fundamentally compromising consensus integrity.

## Finding Description

The vulnerability exists in the consensus round transition flow where the contract fails to enforce that only authorized miners from the current round can participate in the next round.

**Root Cause: Missing Miner List Validation**

When a miner calls `NextRound`, the `PreCheck()` method only validates that the transaction sender is in the current or previous round's miner list, but does NOT validate the miner list in the proposed next round. [1](#0-0) 

The `ProcessNextRound` method converts the input to a Round object and stores it directly without comparing the miner list against the current round. [2](#0-1) 

The `ToRound()` method simply copies `RealTimeMinersInformation` from the input without any validation. [3](#0-2) 

**Validation Gaps**

The validation providers for `NextRound` behavior check round numbers and mining order counts, but NOT the actual miner list membership:

- `NextRoundMiningOrderValidationProvider` only validates that count of miners with `FinalOrderOfNextRound > 0` equals count with `OutValue != null`, checking internal consistency but not comparing against the base round's miner list. [4](#0-3) 

- `RoundTerminateValidationProvider` only checks round number increment and InValue nullness. [5](#0-4) 

- `MiningPermissionValidationProvider` checks if the sender is in the base round (current round), not whether the proposed next round's miner list is valid. [6](#0-5) 

**Exploitation Path**

Once the manipulated round is stored in state, unauthorized miners can call `GetConsensusCommand`, which retrieves the round from state and validates miners using `IsInMinerList`. [7](#0-6) 

The `IsInMinerList` method simply checks if the pubkey exists in `RealTimeMinersInformation.Keys`, which will return true for the unauthorized miners that were injected. [8](#0-7) 

**Why Expected Protections Fail**

While the contract correctly generates next rounds using `GenerateNextRoundInformation`, which preserves the miner list from the current round, there is no validation that enforces the submitted `NextRoundInput` actually matches this expected miner list. [9](#0-8) 

The post-execution validation in `ValidateConsensusAfterExecution` compares the header round against the current round AFTER execution. For NextRound, the current round after execution is the newly stored next round, so it compares the manipulated round against itself, allowing the attack to succeed. [10](#0-9) 

## Impact Explanation

**Critical Consensus Integrity Compromise:**

This vulnerability directly violates the fundamental security property of the consensus mechanism: only authorized miners elected through the proper governance process should be able to produce blocks. The impact includes:

1. **Byzantine Fault Tolerance Violation**: Attackers can inject controlled nodes beyond the authorized miner set. If they add enough unauthorized miners to exceed 1/3 of total miners, they can prevent finality or cause chain reorganizations.

2. **Block Production by Unauthorized Entities**: Unauthorized miners receive valid consensus commands and can produce blocks that pass validation on all nodes (since the manipulated state is propagated across the network).

3. **Last Irreversible Block (LIB) Manipulation**: Unauthorized miners can influence LIB calculations, potentially enabling double-spend attacks.

4. **Complete Election System Bypass**: The vulnerability allows complete bypass of the election/authorization system, undermining the entire governance and security model.

**Affected Parties:**
- All nodes in the blockchain network (both main chain and side chains)
- Token holders whose assets depend on consensus integrity
- DApps relying on transaction finality guarantees

## Likelihood Explanation

**High Likelihood:**

The attack is highly likely because:

1. **Low Attacker Requirements**: The attacker only needs to be a currently authorized miner, which is a legitimate role in the system.

2. **Simple Execution**: 
   - Wait for designated time slot as extra block producer (happens periodically in round-robin fashion)
   - Generate valid `NextRoundInput` using existing methods
   - Modify `RealTimeMinersInformation` dictionary to add unauthorized entries
   - Submit via `NextRound` transaction

3. **No Economic Barriers**: Beyond normal transaction fees, there is no special economic cost.

4. **Persistent Effect**: Once the manipulated round is stored in contract state, the attack persists for the entire round duration.

5. **No Detection Mechanism**: The consensus contract itself allows the unauthorized miners, and the validation logic doesn't catch this manipulation.

## Recommendation

Add explicit miner list validation in `ProcessNextRound` to ensure the proposed next round's miner list exactly matches the current round's authorized miners (unless it's a term change where miner list changes are expected and validated via the Election contract).

**Recommended Fix:**

In `ProcessNextRound`, before storing the next round, add validation:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // NEW: Validate miner list membership unless miner list just changed
    if (!nextRound.IsMinerListJustChanged)
    {
        var currentMiners = currentRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var nextMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        Assert(currentMiners.Count == nextMiners.Count && 
               currentMiners.SequenceEqual(nextMiners),
               "Next round miner list must match current round.");
    }
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of the method
}
```

Alternatively, add a dedicated validation provider that performs this check during `ValidateBeforeExecution`.

## Proof of Concept

The vulnerability can be demonstrated with a test that:
1. Initializes a consensus round with legitimate miners
2. Has a legitimate miner submit a `NextRound` transaction with additional unauthorized miner entries in `RealTimeMinersInformation`
3. Verifies the manipulated round is stored in state
4. Shows that the unauthorized miner can call `GetConsensusCommand` and receive valid consensus commands
5. Demonstrates that blocks produced by the unauthorized miner pass validation

The core issue is in `ProcessNextRound` method which calls `AddRoundInformation(nextRound)` without validating that the keys of `nextRound.RealTimeMinersInformation` match those of `currentRound.RealTimeMinersInformation`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-27)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```
