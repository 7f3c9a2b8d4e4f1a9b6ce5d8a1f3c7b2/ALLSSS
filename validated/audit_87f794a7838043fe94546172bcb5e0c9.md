# Audit Report

## Title
NFT Collection Impersonation via Front-Running CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function in the MultiToken contract fails to validate that existing NFT collection properties match those from the source chain during cross-chain synchronization. An attacker can front-run legitimate collection synchronization by creating a fake collection with the same symbol on the main chain, causing cross-chain NFT items to reference the attacker's malicious collection and granting them unauthorized control over collection-owner-gated operations.

## Finding Description

The vulnerability exists in the `CrossChainCreateToken` method's handling of NFT collections during cross-chain token creation. When an NFT collection is synchronized from a side chain to the main chain, the function calls `AssertNftCollectionExist` to verify the collection exists, but critically **discards the returned collection information** without comparing it against the properties being synchronized from the source chain. [1](#0-0) 

The function then constructs a new `TokenInfo` object using properties from the cross-chain input (lines 492-503), but if a collection with that symbol already exists on the destination chain, it only updates alias information and returns without validation or overwriting. [2](#0-1) 

This differs fundamentally from local NFT creation, where `CreateNFTInfo` properly validates that the NFT's properties match the collection's properties, including IssueChainId validation and Owner validation. [3](#0-2) 

On the main chain (where `State.SideChainCreator.Value == null`), anyone possessing a valid seed NFT can create NFT collections locally, enabling the attack vector. [4](#0-3) 

**Attack Flow:**
1. Legitimate user creates NFT collection "COLLECTION-0" on side chain with Owner=Alice, IssueChainId=SideChainId
2. Attacker monitors cross-chain synchronization attempts
3. Attacker front-runs by creating "COLLECTION-0" on main chain with Owner=Attacker, IssueChainId=MainChainId (using a seed NFT costing 100 ELF)
4. When the legitimate `CrossChainCreateToken` executes, it sees the collection already exists at line 506 and only updates alias information (lines 522-531), without validating that the existing collection's Owner, Issuer, or IssueChainId match those from the source chain
5. Later, NFT items "COLLECTION-1", "COLLECTION-2" are synchronized with their correct properties from the side chain
6. These items reference the collection symbol "COLLECTION-0" through naming convention
7. Operations like `SetSymbolAlias` check the collection owner/issuer for permissions, but now reference the attacker's fake collection

The `SetSymbolAlias` method demonstrates the permission bypass by checking permissions against the collection's Owner/Issuer: [5](#0-4) 

This check validates against the attacker's fake collection rather than the legitimate collection from the source chain, because NFT items are related to collections through symbol naming patterns rather than explicit references. The `GetNftCollectionSymbol` extracts the collection symbol from an item symbol (e.g., "ABC-1" â†’ "ABC-0"), and permissions are checked against whichever "ABC-0" TokenInfo exists on-chain. [6](#0-5) 

## Impact Explanation

This vulnerability has **Medium** severity with the following impacts:

1. **Unauthorized Permission Control**: The attacker gains control over collection-owner-gated operations (specifically `SetSymbolAlias`) for NFT items they do not legitimately own. This allows them to set aliases for NFTs belonging to other users.

2. **Loss of Legitimate Control**: The actual NFT collection owner from the source chain loses the ability to perform collection-owner-restricted operations on their own NFTs on the destination chain.

3. **Cross-Chain Integrity Violation**: NFT items synchronized from the side chain reference a collection with fundamentally different properties (different Owner, Issuer, and IssueChainId), breaking the security invariant that NFT items must belong to collections from the same issuance context.

4. **Persistent State Corruption**: Once the fake collection is created, it cannot be overwritten by legitimate cross-chain synchronization. The corrupted state persists indefinitely.

While this vulnerability does not directly result in fund theft, it represents a serious breach of ownership and authorization controls in the NFT system, with potential economic significance for valuable NFT collections where alias control or other collection-owner operations have value.

## Likelihood Explanation

The likelihood of exploitation is **Medium-High** with the following factors:

**Attacker Requirements:**
- Must acquire a valid seed NFT (bounded cost of 100 ELF through normal creation mechanisms)
- Must monitor mempool or cross-chain events to detect collection synchronization attempts
- Must successfully front-run the legitimate `CrossChainCreateToken` transaction

**Feasibility:**
- The attack specifically targets synchronization FROM side chains TO main chain, as side chains prevent local collection creation through the `State.SideChainCreator.Value` check (line 54 in TokenContract_Actions.cs)
- Front-running is achievable through mempool monitoring or higher gas fees
- No automatic detection mechanism exists to alert legitimate users of the property mismatch
- The fake collection appears valid on-chain without cross-chain property comparison

**Exploitation Timing:**
- A timing window exists during any NFT collection cross-chain synchronization
- Attackers can prepare in advance once they identify valuable collections on side chains

The primary barrier is seed NFT acquisition cost (100 ELF), but this represents a one-time bounded investment that enables attacks on multiple collections.

## Recommendation

The `CrossChainCreateToken` method should be modified to validate existing collection properties against those being synchronized from the source chain. Specifically:

1. **Store and validate the returned collection info** from `AssertNftCollectionExist`:
```csharp
var existingCollectionInfo = AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
```

2. **If collection exists, validate that critical properties match**:
```csharp
if (State.TokenInfos[tokenInfo.Symbol] != null)
{
    var existingTokenInfo = State.TokenInfos[tokenInfo.Symbol];
    
    // For NFT collections, validate that existing properties match incoming properties
    if (existingCollectionInfo != null)
    {
        Assert(existingTokenInfo.Owner == tokenInfo.Owner, 
            "Collection owner mismatch during cross-chain synchronization.");
        Assert(existingTokenInfo.Issuer == tokenInfo.Issuer,
            "Collection issuer mismatch during cross-chain synchronization.");
        Assert(existingTokenInfo.IssueChainId == tokenInfo.IssueChainId,
            "Collection IssueChainId mismatch during cross-chain synchronization.");
    }
    
    // Update alias information
    if (isSymbolAliasSet && validateTokenInfoExistsInput.ExternalInfo.TryGetValue(...))
    {
        // existing alias update logic
    }
}
```

3. **Alternative**: Only allow cross-chain token creation if the token doesn't already exist, forcing explicit administrative action to resolve conflicts.

## Proof of Concept

A complete test would require:

1. **Setup**: Deploy main chain and side chain test environments with cross-chain infrastructure
2. **Side chain**: Create NFT collection "TEST-0" with Owner=Alice
3. **Main chain**: Attacker acquires seed NFT and creates "TEST-0" with Owner=Attacker
4. **Main chain**: Execute legitimate CrossChainCreateToken for "TEST-0" from side chain
5. **Verify**: Check that "TEST-0" on main chain still has Owner=Attacker (not Alice)
6. **Side chain**: Create NFT item "TEST-1" with Owner=Alice
7. **Main chain**: Execute CrossChainCreateToken for "TEST-1" from side chain
8. **Main chain**: Call `SetSymbolAlias` for "TEST-1" from Attacker account - should succeed (vulnerability)
9. **Main chain**: Call `SetSymbolAlias` for "TEST-1" from Alice account - should fail (illegitimate owner rejection)

The key assertion is at step 8: the attacker can successfully call `SetSymbolAlias` for an NFT item they do not legitimately own, because the permission check references their fake collection "TEST-0" rather than Alice's legitimate collection.

---

## Notes

The vulnerability specifically affects the **main chain** receiving collections from **side chains**, because:
- Side chains block local collection creation (State.SideChainCreator.Value check prevents it)
- Main chain allows local collection creation with seed NFTs
- The attack exploits the timing window during cross-chain synchronization

The impact is currently limited to `SetSymbolAlias` as the only identified collection-owner-gated operation, but the architectural flaw could affect future operations that rely on collection ownership validation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L51-66)
```csharp
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L491-491)
```csharp
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-531)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L754-761)
```csharp
        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L17-36)
```csharp
        var nftCollectionInfo = AssertNftCollectionExist(input.Symbol);
        input.IssueChainId = input.IssueChainId == 0 ? nftCollectionInfo.IssueChainId : input.IssueChainId;
        Assert(
            input.IssueChainId == nftCollectionInfo.IssueChainId,
            "NFT issue ChainId must be collection's issue chainId");
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
        else
        {
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
        }
        
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L153-170)
```csharp
    private string GetNftCollectionSymbol(string inputSymbol, bool isAllowCollection = false)
    {
        var symbol = inputSymbol;
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        const int tokenSymbolLength = 1;
        if (words.Length == tokenSymbolLength) return null;
        Assert(words.Length == 2 && IsValidItemId(words[1]), "Invalid NFT Symbol Input");
        return symbol == $"{words[0]}-0" ? (isAllowCollection ? $"{words[0]}-0" : null) : $"{words[0]}-0";
    }

    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```
