# Audit Report

## Title
Unbounded Iteration in GetProfitsMap View Method Causes DoS via ExecutionCallThreshold Exhaustion

## Summary
The `GetProfitsMap()` view method iterates over all profit details without limit and calculates profits across potentially large period ranges. This causes method call counts to exceed the ExecutionCallThreshold (15,000), resulting in RuntimeCallThresholdExceededException that prevents users from querying their total profits. While the transaction method `ClaimProfits` has proper limits, the view methods lack equivalent protections.

## Finding Description

The vulnerability exists in the Profit contract's view method implementation. The `GetProfitsMap()` view method calls the private helper `GetAllProfitsMap()` which contains an unbounded loop that iterates over ALL `availableDetails.Count` without any upper limit. [1](#0-0) 

For each profit detail, the method invokes `ProfitAllPeriods` with a period count parameter of `profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod)`. [2](#0-1)  This period span can reach hundreds or thousands of periods if the beneficiary hasn't claimed profits for an extended time or if `EndPeriod` is set to a distant future value.

Inside `ProfitAllPeriods`, nested loops iterate over token symbols and periods, with each period iteration performing method calls such as `GetDistributedPeriodProfitsVirtualAddress()` and state accesses. [3](#0-2)  These operations accumulate toward the ExecutionCallThreshold.

The AElf runtime enforces a hard limit of 15,000 method calls per transaction execution. [4](#0-3)  When this threshold is reached, the ExecutionObserver throws a RuntimeCallThresholdExceededException. [5](#0-4) 

Crucially, view methods ARE subject to the ExecutionObserver's call threshold enforcement. An ExecutionObserver is instantiated for every method execution, including view methods. [6](#0-5)  The only difference for view methods is that state changes aren't persisted, but call counting still applies.

In contrast, the transaction method `ClaimProfits` properly limits iterations to a maximum of 10 details. [7](#0-6)  It also calculates a bounded period count per detail using `GetMaximumPeriodCountForProfitableDetail()`, which divides the maximum period count (default 100) by the number of profitable details. [8](#0-7)  This ensures that even with 10 details, each detail processes at most 10 periods, keeping total operations well below the threshold.

The constant `ProfitReceivingLimitForEachTime` is set to 10. [9](#0-8) 

## Impact Explanation

**Operational DoS - Medium Severity:**

This vulnerability causes a denial-of-service condition for profit queries, preventing users from viewing their accumulated profits through `GetProfitsMap()`, `GetProfitAmount()`, and `GetAllProfitAmount()`. All three view methods rely on the vulnerable `GetAllProfitsMap()` helper. [10](#0-9) 

**Impact Scope:**
- Users cannot query profit amounts via view methods
- Frontend integrations cannot display profit information
- Users must claim profits blindly without knowing amounts
- Significant UX degradation for long-term participants

**Critical Limitations:**
- **NO fund loss**: Profits remain fully claimable via the `ClaimProfits` transaction method which has proper iteration limits
- **NO token lockup**: All funds remain accessible through the claiming mechanism
- **State integrity maintained**: No corruption of profit accounting or distribution logic

The severity is Medium because while it creates operational disruption and poor user experience, it does not prevent core functionality (profit claiming) and causes no financial loss. Users can still claim their profits through the transaction method; they simply cannot preview the amounts first.

## Likelihood Explanation

**Medium Probability - Natural Accumulation:**

This issue can occur naturally through legitimate protocol usage without any malicious intent:

**Realistic Scenario (6-12 month timeframe):**
- Profit scheme running 500+ periods (e.g., daily periods over 16+ months)
- User accumulates 30-50 profit details through TokenHolder stake adjustments
- Scheme distributes 8-10 different token symbols
- User hasn't claimed in 50+ periods
- **Calculation**: 50 details × 10 symbols × 50 periods = 25,000 operations → exceeds 15,000 threshold

**Preconditions:**
1. Long-running profit scheme with many periods elapsed
2. Beneficiary accumulated multiple profit details (each `AddBeneficiary` call creates a new detail)
3. Beneficiary hasn't claimed recently (LastProfitPeriod significantly lags behind CurrentPeriod or EndPeriod)
4. Scheme distributes multiple token symbols

**Why Details Accumulate:**

Only the scheme manager or TokenHolder contract can add beneficiaries. [11](#0-10)  The TokenHolder contract legitimately calls `AddBeneficiary` each time users adjust their staked positions, creating new profit details. Old details are only removed if they are expired AND beyond the `ProfitReceivingDuePeriodCount` cleanup window. [12](#0-11)  Active schemes with long `EndPeriod` values (including `long.MaxValue` for perpetual schemes) retain all details.

**Complexity**: Low - occurs through normal system operations  
**Detection**: Easy - query simply fails with RuntimeCallThresholdExceededException  
**Attacker capabilities**: None required - natural occurrence through protocol usage

## Recommendation

Implement the same iteration limits in view methods as exist in the transaction method `ClaimProfits`:

1. **Limit the number of details processed**: Apply `Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count)` to cap processing at 10 details, similar to ClaimProfits.

2. **Limit period calculation per detail**: Use `GetMaximumPeriodCountForProfitableDetail(profitableDetailCount)` to calculate a bounded `maxProfitReceivingPeriodCount` and pass this to `ProfitAllPeriods` instead of the unbounded `profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod)`.

3. **Add pagination support**: Consider implementing paginated view methods that allow users to query profits in chunks (e.g., `GetProfitsMapPaginated(schemeId, beneficiary, startIndex, count)`) to handle cases with many details.

Fixed code structure in `GetAllProfitsMap`:
```csharp
var profitableDetailCount = Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);

for (var i = 0; i < profitableDetailCount; i++) // Limit to 10 details
{
    var profitDetail = availableDetails[i];
    if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
    
    // Use bounded period count instead of full range
    var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount, true, symbol);
    AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
}
```

This ensures view methods remain queryable even for long-running schemes with many accumulated details while maintaining consistency with the claiming mechanism's limitations.

## Proof of Concept

A proof of concept would require:

1. Creating a profit scheme with multiple token symbols
2. Adding a beneficiary with 50+ profit details (simulating TokenHolder stake adjustments)
3. Distributing profits over 50+ periods
4. Calling `GetProfitsMap()` to trigger the ExecutionCallThreshold exception

The test would demonstrate that:
- `ClaimProfits()` succeeds with its iteration limits
- `GetProfitsMap()` fails with RuntimeCallThresholdExceededException
- The failure occurs when: `details_count × symbols_count × periods_count × operations_per_iteration > 15,000`

This confirms the DoS condition occurs naturally through protocol usage patterns.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L62-101)
```csharp
    public override Int64Value GetProfitAmount(GetProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);

        return new Int64Value
        {
            Value = allProfitsMapResult.AllProfitsMap.TryGetValue(input.Symbol, out var value) ? value : 0
        };
    }

    public override GetAllProfitAmountOutput GetAllProfitAmount(GetAllProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);
        return new GetAllProfitAmountOutput
        {
            AllProfitAmount = allProfitsMapResult.AllProfitsMap.TryGetValue(input.Symbol, out var allProfitAmount)
                ? allProfitAmount
                : 0,
            OneTimeClaimableProfitAmount =
                allProfitsMapResult.OneTimeClaimableProfitsMap.TryGetValue(input.Symbol,
                    out var oneTimeClaimableProfitAmount)
                    ? oneTimeClaimableProfitAmount
                    : 0
        };
    }

    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary);

        return new ReceivedProfitsMap
        {
            Value = { allProfitsMapResult.AllProfitsMap }
        };
    }

    public override GetAllProfitsMapOutput GetAllProfitsMap(GetAllProfitsMapInput input)
    {
        return GetAllProfitsMap(input.SchemeId, input.Beneficiary);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-135)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L203-207)
```csharp
        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-777)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L822-833)
```csharp
    private int GetMaximumPeriodCountForProfitableDetail(int profitableDetailCount)
    {
        // Get the maximum profit receiving period count
        var maxPeriodCount = GetMaximumProfitReceivingPeriodCount();
        // Check if the maximum period count is greater than the profitable detail count
        // and if the profitable detail count is greater than 0
        return maxPeriodCount > profitableDetailCount && profitableDetailCount > 0
            // Divide the maximum period count by the profitable detail count
            ? maxPeriodCount.Div(profitableDetailCount)
            // If the conditions are not met, return 1 as the maximum period count
            : 1;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-871)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-26)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L127-146)
```csharp
        var observer =
            new ExecutionObserver(CurrentTransactionContext.ExecutionObserverThreshold.ExecutionCallThreshold,
                CurrentTransactionContext.ExecutionObserverThreshold.ExecutionBranchThreshold);

        try
        {
            if (!_callHandlers.TryGetValue(methodName, out var handler))
                throw new RuntimeException(
                    $"Failed to find handler for {methodName}. We have {_callHandlers.Count} handlers: " +
                    string.Join(", ", _callHandlers.Keys.OrderBy(k => k))
                );

            _smartContractProxy.SetExecutionObserver(observer);

            ExecuteTransaction(handler);

            if (!handler.IsView())
                CurrentTransactionContext.Trace.StateSet = GetChanges();
            else
                CurrentTransactionContext.Trace.StateSet = new TransactionExecutingStateSet();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```
