# Audit Report

## Title
Missing TermNumber Validation in NextRound Allows Consensus Time Slot Bypass

## Summary
The AEDPoS consensus contract fails to validate that the `TermNumber` field remains unchanged during `NextRound` transitions. A malicious miner can craft a `NextRoundInput` with an incorrect `TermNumber`, which gets stored in state without validation. When this manipulated round later becomes the previous round for validation, it causes `IsFirstRoundOfCurrentTerm` to incorrectly return true, bypassing all time slot checks and allowing the miner to produce blocks outside their assigned schedule.

## Finding Description

The vulnerability exists in the validation pipeline for `NextRound` consensus behavior. 

**Root Cause:**

The `ToRound()` function performs no validation and blindly copies all fields including `TermNumber`: [1](#0-0) 

The pre-execution validation for `NextRound` only checks `RoundNumber` increment and `InValue` nullity, but completely omits `TermNumber` validation: [2](#0-1) 

In contrast, `NextTerm` validation explicitly checks that `TermNumber` increments by exactly 1: [3](#0-2) 

During normal operation, `GenerateNextRoundInformation` correctly keeps `TermNumber` unchanged: [4](#0-3) 

**Execution Path:**

1. A malicious miner calls the public `NextRound` method with a crafted input: [5](#0-4) 

2. `ProcessNextRound` converts the unvalidated input and stores it: [6](#0-5) 

Note that `ProcessNextRound` only updates `RoundNumber` (line 158), NOT `TermNumber`. Compare this to `ProcessNextTerm`: [7](#0-6) 

3. The manipulated Round is stored with incorrect `TermNumber`: [8](#0-7) 

4. During subsequent block validation, the stored Round with wrong `TermNumber` becomes the `PreviousRound`: [9](#0-8) 

5. The validation context is built with the manipulated `PreviousRound` and the correct global `CurrentTermNumber`: [10](#0-9) 

6. Time slot validation checks if it's the first round of a term, which incorrectly returns true: [11](#0-10) 

When `PreviousRound.TermNumber` (manipulated value) differs from `CurrentTermNumber` (correct global state), the check at line 56 returns true, causing line 39 to bypass all time slot validation.

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant of time slot validation. The AEDPoS consensus mechanism assigns specific time windows to each miner to ensure fair, distributed block production. By bypassing time slot checks, a malicious miner can:

1. **Violate Consensus Schedule**: Produce blocks outside their assigned time slot, breaking the deterministic mining order
2. **Monopolize Block Production**: Continuously mine blocks during other miners' time slots if they can maintain the attack across rounds
3. **Gain Unfair Economic Advantage**: Collect more block rewards and transaction fees than legitimately entitled
4. **Create State Inconsistency**: Stored Round objects have incorrect TermNumbers that diverge from `State.CurrentTermNumber`, violating data integrity
5. **Reduce Decentralization**: Centralize block production power, undermining network security

The severity is Medium because while the impact on consensus integrity is severe, the attacker must already be an active miner in the current round, which limits the attack surface to elected/staked participants rather than arbitrary users.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a valid miner in the current round (verified by `PreCheck()`)
- This is realistic as miners are selected through the election/staking mechanism that any participant can join

**Attack Complexity:**
The attack is straightforward:
1. Craft a `NextRoundInput` with `RoundNumber = currentRoundNumber + 1` (valid) and `TermNumber = currentTermNumber + 1` (invalid but unchecked)
2. Populate other required fields correctly
3. Call the public `NextRound()` method
4. The invalid TermNumber passes all validations and gets stored
5. Subsequent rounds experience bypassed time slot validation

**Feasibility:**
- No special privileges beyond being an elected miner
- No economic cost beyond standard transaction fees
- Immediately exploitable once in the miner list
- Difficult to detect as the global `State.CurrentTermNumber` remains correct while individual Round objects are corrupted

**Probability:** High for any malicious miner seeking competitive advantage in block production or rewards.

## Recommendation

Add TermNumber validation to `ValidationForNextRound` to ensure it remains unchanged:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate RoundNumber increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Validate TermNumber remains unchanged (NEW CHECK)
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "TermNumber must not change during NextRound transitions." };
    
    // Validate InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

This ensures that `TermNumber` can only be incremented through the `NextTerm` flow, which has proper authorization and validation.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithManipulatedTermNumber_BypassesTimeSlotValidation()
{
    // Setup: Initialize consensus with miners and advance to round 5
    var miners = await InitializeMiningAsync();
    var firstMiner = miners[0];
    await AdvanceToRoundAsync(5); // CurrentTermNumber=1, CurrentRoundNumber=5
    
    // Attack: Malicious miner crafts NextRoundInput with wrong TermNumber
    var currentRound = await GetCurrentRoundAsync();
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = 6, // Correct increment
        TermNumber = 2,  // WRONG - should be 1, but not validated
        // ... populate other fields correctly
    };
    
    // Execute malicious NextRound - should fail validation but doesn't
    var result = await firstMiner.NextRound(maliciousNextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes!
    
    // Verify: Stored round has wrong TermNumber
    var storedRound6 = await GetRoundAsync(6);
    storedRound6.TermNumber.ShouldBe(2); // Corrupted
    var currentTermNumber = await GetCurrentTermNumberAsync();
    currentTermNumber.ShouldBe(1); // Global state still correct - inconsistency!
    
    // Advance to round 7 normally
    await NormalNextRound();
    
    // Exploit: In round 7, time slot validation is bypassed
    // because PreviousRound.TermNumber (2) != CurrentTermNumber (1)
    // Miner can now produce blocks outside their assigned time slot
    var outsideTimeSlotBlock = await firstMiner.ProduceBlockOutsideTimeSlot();
    outsideTimeSlotBlock.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); 
    // Should fail time slot validation but doesn't!
}
```

The test demonstrates that a manipulated `TermNumber` in `NextRoundInput` bypasses validation, gets stored, and causes subsequent time slot validation to be incorrectly skipped.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L21-22)
```csharp
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-58)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }

    private bool IsFirstRoundOfCurrentTerm(out long termNumber, ConsensusValidationContext validationContext)
    {
        termNumber = validationContext.CurrentTermNumber;
        return validationContext.PreviousRound.TermNumber != termNumber ||
               validationContext.CurrentRoundNumber == 1;
    }
```
