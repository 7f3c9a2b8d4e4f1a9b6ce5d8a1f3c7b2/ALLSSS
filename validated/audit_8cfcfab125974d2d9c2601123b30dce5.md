# Audit Report

## Title
Missing Miner List Validation in NextRound Transitions Allows Consensus Disruption via Inflated Miner Count

## Summary
The AEDPoS consensus contract fails to validate that the miner set in NextRound transitions matches the current round's authorized miners. This allows a malicious miner to inject fake entries into `RealTimeMinersInformation`, disrupting consensus order assignments, creating block production gaps, and potentially diluting mining rewards.

## Finding Description

The vulnerability exists in the NextRound validation logic where validators only check internal consistency of the provided round structure but never verify that the miner set is legitimate.

**Missing Validation:**

The `NextRoundMiningOrderValidationProvider` only checks that miners with `FinalOrderOfNextRound > 0` equals miners with `OutValue != null` within the provided round itself: [1](#0-0) 

For a freshly generated NextRound, all miners have `FinalOrderOfNextRound = 0` and `OutValue = null`, so this check passes as `0 == 0` regardless of how many miners are in the list.

The `RoundTerminateValidationProvider` only checks round number increment and that InValues are null: [2](#0-1) 

**Critical Gap:**

The validation context provides both `BaseRound` (trusted current state) and `ProvidedRound` (from block header): [3](#0-2) 

However, no validator compares `ProvidedRound.RealTimeMinersInformation.Keys` against `BaseRound.RealTimeMinersInformation.Keys` to ensure the miner set matches.

**Exploitation Path:**

1. Malicious miner generates legitimate next round via `GetConsensusExtraDataForNextRound`: [4](#0-3) 

2. Before including in block, attacker modifies `nextRound.RealTimeMinersInformation` to add fake `MinerInRound` entries with default values

3. Validation runs but all checks pass: [5](#0-4) 

4. Corrupted round is stored to state: [6](#0-5) 

5. Fake miners persist through subsequent rounds via `GenerateNextRoundInformation`: [7](#0-6) 

6. Fake miners receive time slot assignments: [8](#0-7) 

7. Inflated miner count corrupts consensus calculations: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Breach:** The inflated `minersCount` directly affects deterministic order assignment via `GetAbsModulus(sigNum, minersCount) + 1`, causing legitimate miners to receive incorrect order assignments.

**Operational Disruption:** Fake miners are assigned time slots but cannot produce blocks, creating persistent gaps in the block production schedule that delay network progress.

**Persistent Corruption:** The `GenerateNextRoundInformation` method propagates all miners from current round to next round. Once injected, fake miners persist through subsequent NextRound transitions until a NextTerm occurs (which rebuilds miner list from election results).

**Economic Impact:** Mining rewards calculated based on miner count would be diluted across fake entries.

## Likelihood Explanation

**Attacker Requirements:**
- Must be current miner (moderate barrier - requires election)
- Must produce NextRound transition block (periodic opportunity)
- Must modify node software (low technical complexity)

**Attack Feasibility:** Straightforward execution - simply add entries to `RealTimeMinersInformation` with default values before block inclusion. No complex state manipulation required.

**Detection Difficulty:** Corrupted state appears valid to validation logic. Fake miners manifest as missed time slots, easily mistaken for network issues.

## Recommendation

Add a miner set validation check in `NextRoundMiningOrderValidationProvider` or create a new validator that compares the provided round's miner list against the base round:

```csharp
// Verify miner set matches
var providedMiners = providedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();

if (providedMiners.Count != baseMiners.Count || 
    !providedMiners.SequenceEqual(baseMiners))
{
    validationResult.Message = "NextRound miner list does not match current round.";
    return validationResult;
}
```

This ensures only the authorized miners from the current round can be included in the next round.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test consensus environment with legitimate miners
2. Having a test miner generate legitimate NextRound data
3. Adding fake miner entries to `RealTimeMinersInformation` before validation
4. Verifying validation passes despite the injected entries
5. Confirming fake miners persist through subsequent round generations
6. Observing inflated miner count affects consensus calculations

The core issue is validated by examining the validation providers which show no comparison between `BaseRound.RealTimeMinersInformation.Keys` and `ProvidedRound.RealTimeMinersInformation.Keys`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L16-18)
```csharp
        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L118-122)
```csharp
        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.gs (L42-56)
```text

```
