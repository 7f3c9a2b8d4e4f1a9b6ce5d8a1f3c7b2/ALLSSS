# Audit Report

## Title
MissedTimeSlots Counter Reset at Term Boundaries Allows Malicious Miners to Evade Evil Node Detection

## Summary
The AEDPoS consensus contract resets the `MissedTimeSlots` counter to 0 during term transitions without performing evil miner detection, while detection only occurs during normal round transitions. This allows malicious miners to strategically miss blocks below the 4320-slot threshold and have their counters reset every 7-day term, enabling indefinite evasion of punishment.

## Finding Description

The consensus contract defines a tolerance threshold of 4320 missed time slots (representing 3 days at 1 slot per minute) for detecting evil miners. [1](#0-0) 

The detection mechanism `TryToDetectEvilMiners()` identifies miners whose `MissedTimeSlots` exceeds this threshold. [2](#0-1) 

**Critical Flaw:** Evil miner detection is ONLY performed during normal round transitions in `ProcessNextRound`. [3](#0-2) 

When detected, evil miners are marked with `IsEvilNode = true` in the Election contract, which permanently removes them from the candidate list. [4](#0-3) 

However, during term transitions in `ProcessNextTerm`, the contract counts any final missed time slots via `CountMissedTimeSlots()` [5](#0-4)  and then **unconditionally resets ALL miners' `MissedTimeSlots` and `ProducedBlocks` to 0** [6](#0-5)  without calling `TryToDetectEvilMiners()` before the reset. The statistics are sent to Election contract but this is informational only. [7](#0-6) 

The `MissedTimeSlots` counter is incremented when miners fail to produce blocks during round generation. [8](#0-7) 

**Attack Scenario:** A malicious miner can miss up to 4319 time slots during each 7-day term period (~10,080 total slots per term), avoid detection since they stay below the 4320 threshold, have their counter reset to 0 at the term boundary, and repeat this pattern indefinitely across multiple terms.

## Impact Explanation

This vulnerability has severe consensus integrity implications:

**Consensus Reliability Compromise:** With a 7-day term containing ~10,080 time slots (1 slot per minute), a miner can miss 4319 slots (~42.8% of their obligations) per term without punishment, significantly reducing network block production capacity.

**Protocol Invariant Violation:** The system's fundamental security guarantee—that miners exceeding the 4320 missed-slot threshold will be removed—is completely bypassed through this cross-term evasion mechanism. The threshold becomes meaningless when counters reset every term without detection.

**Persistent Attacker Advantage:** Malicious miners can remain in the active miner set indefinitely despite consistently poor performance, while honest miners who happen to exceed the threshold in a single term are permanently banned.

**No Economic Penalty:** The attacker maintains their miner status and potential rewards despite reduced participation, creating an unfair advantage and undermining the incentive structure designed to ensure reliable block production.

## Likelihood Explanation

**Attack Complexity:** Trivial - the attacker simply needs to control their own mining node's block production behavior.

**Preconditions:** 
- Attacker must be an elected miner (achievable through normal election process)
- No special permissions required beyond standard miner status
- Term transitions occur automatically every 7 days as configured in the system

**Execution Practicality:**
- The attack is fully deterministic and risk-free
- No coordination with other parties needed
- Term boundary reset is automatic and unavoidable
- No cross-term tracking mechanisms exist to detect the pattern

**Detection Difficulty:** The current implementation provides no way to track cumulative missed slots across term boundaries, making this attack pattern completely invisible to protocol monitoring. While the Election contract receives cumulative statistics, these are not used by the evil detection mechanism which only checks the consensus contract's per-term counter.

## Recommendation

Add evil miner detection before resetting counters in `ProcessNextTerm`:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();

    // Count missed time slot of current round.
    CountMissedTimeSlots();

    // ADD: Detect evil miners BEFORE resetting counters
    if (State.IsMainChain.Value && TryToGetCurrentRoundInformation(out var currentRound) &&
        currentRound.TryToDetectEvilMiners(out var evilMiners))
    {
        foreach (var evilMiner in evilMiners)
        {
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = evilMiner,
                IsEvilNode = true
            });
        }
    }

    Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");
    // ... rest of method
}
```

Alternatively, implement cross-term cumulative tracking in the Election contract and use those values for evil detection.

## Proof of Concept

The vulnerability can be demonstrated by simulating a miner who:
1. Misses exactly 4319 time slots during a 7-day term
2. Verifies their `MissedTimeSlots` counter shows 4319 (below threshold)
3. Waits for term transition (`ProcessNextTerm` is called)
4. Verifies their `MissedTimeSlots` counter is reset to 0
5. Confirms they remain in the active miner set and were never marked as evil
6. Repeats across multiple terms

The test would need to mock the consensus behavior to simulate missed blocks and term transitions, verifying that the counter resets without triggering evil detection despite accumulating 4319+ missed slots across multiple terms.

## Notes

The vulnerability is exacerbated by the fact that the Election contract does maintain cumulative statistics via `UpdateCandidateInformation` [9](#0-8) , but these cumulative values are never checked by the evil detection logic in `TryToDetectEvilMiners()`, which only examines the per-term counter in the consensus contract.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L168-168)
```csharp
        CountMissedTimeSlots();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-118)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-55)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```
