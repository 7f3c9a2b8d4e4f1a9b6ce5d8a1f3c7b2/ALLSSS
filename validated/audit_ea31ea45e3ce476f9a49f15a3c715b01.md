# Audit Report

## Title
Integer Overflow Denial of Service in Round Generation via Unbounded FinalOrderOfNextRound Values

## Summary
A malicious miner can halt consensus indefinitely by setting arbitrary `FinalOrderOfNextRound` values (up to `Int32.MaxValue`) through the `tune_order_information` field in `UpdateValueInput`. This causes an integer overflow during next round generation, triggering an `OverflowException` that prevents any miner from producing the NextRound block.

## Finding Description

The vulnerability exists due to missing bounds validation on `tune_order_information` values in the consensus update flow, combined with overflow-prone arithmetic in round generation.

**Root Cause 1 - Missing Input Validation:**

In `ProcessUpdateValue`, the `tune_order_information` map from user input is applied directly to set `FinalOrderOfNextRound` values without any bounds checking [1](#0-0) 

The protobuf definition allows any `int32` value in this map [2](#0-1) 

**Root Cause 2 - Overflow-Prone Arithmetic:**

During next round generation, the unchecked `FinalOrderOfNextRound` value is used in a multiplication that can overflow [3](#0-2) 

The `GetMiningInterval()` method returns an `int` (typically 4000 milliseconds for single miner, or time difference between first two miners) [4](#0-3) 

**Why SafeMath Protection Fails:**

The `Mul()` extension method uses checked arithmetic that throws `OverflowException` on overflow [5](#0-4) 

While this prevents silent overflow, the exception causes consensus disruption rather than graceful handling.

**Insufficient Validation:**

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are filled, and checks `PreviousInValue` consistency. It does NOT validate `tune_order_information` bounds [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` only checks count consistency, not value bounds [7](#0-6) 

**Attack Execution Path:**

Round generation is called during consensus extra data preparation for the next round [8](#0-7) 

The normal flow ensures `FinalOrderOfNextRound` stays within `[1, minersCount]` through the `ApplyNormalConsensusData` conflict resolution [9](#0-8) 

However, `ProcessUpdateValue` bypasses this by directly overwriting values from `tune_order_information`, allowing an attacker to set `Int32.MaxValue`.

## Impact Explanation

**Consensus Denial of Service:**

When `FinalOrderOfNextRound` is set to `Int32.MaxValue` (2,147,483,647) and `miningInterval` is 4000, the calculation `4000 * 2,147,483,647 = 8,589,934,588,000` exceeds `Int32.MaxValue` (2,147,483,647). The `OverflowException` causes the `GenerateNextRoundInformation` call to fail during `GetConsensusExtraDataForNextRound`, preventing any miner from producing the NextRound block.

**Protocol-Wide Impact:**
- Consensus completely halts - no blocks can be produced for the next round
- All miners attempting to transition to the next round will fail with the same overflow exception
- Requires manual intervention, coordinated rollback, or chain restart to recover
- Affects the entire blockchain network, not just individual miners
- All transactions pending and future transactions cannot be processed

**Severity Justification:**

This is a **High severity** vulnerability because:
1. Complete consensus halt affects all network operations with no automatic recovery
2. Attack is trivial for any current miner to execute with a single transaction
3. No special permissions beyond being in the current miner set required
4. Persistent DoS - not a temporary revert but ongoing inability to produce blocks
5. Recovery requires manual intervention and coordination among network operators

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a current miner (member of the consensus round)
- Can produce at least one block in the current round
- No additional permissions or special access required beyond miner status

**Attack Complexity:**
- **Very Low**: Single `UpdateValue` transaction with crafted `UpdateValueInput`
- Simply set `tune_order_information[<any_miner_pubkey>] = Int32.MaxValue`
- No timing requirements, race conditions, or complex setup
- Deterministic outcome - overflow will always occur on next round generation

**Feasibility Conditions:**
- Attacker is in the active miner set (realistic - multiple miners exist)
- No economic barriers - attack cost is just one block production
- Can target any miner's order value, not just their own
- Attack persists until manual intervention

**Detection Constraints:**
- Attack is visible on-chain in the `UpdateValue` transaction
- However, damage occurs when next round generation is attempted
- By the time overflow is detected, consensus is already compromised

**Probability Assessment:**
- **High Likelihood**: Any malicious or compromised miner can execute this attack
- Multiple miners means multiple potential attack vectors
- Accidental triggering is unlikely (requires intentional extreme values)
- Could be used for griefing, ransom, or competitive attack

## Recommendation

Add bounds validation for `tune_order_information` values in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // ... existing code ...
    
    // Validate tune_order_information bounds before applying
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
            $"Invalid tune order value: {tuneOrder.Value}. Must be between 1 and {minersCount}.");
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key), 
            $"Miner not found in current round: {tuneOrder.Key}");
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }
    
    // ... rest of method ...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task IntegerOverflow_ConsensusHalt_Test()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeCandidates(3);
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousMiner = InitialCoreDataCenterKeyPairs[0];
    var targetMiner = currentRound.RealTimeMinersInformation.Keys.First();
    
    // Attacker creates malicious UpdateValueInput with Int32.MaxValue in tune_order_information
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("sig"),
        RoundId = currentRound.RoundId,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = { { targetMiner, int.MaxValue } }, // Malicious value
        RandomNumber = ByteString.CopyFrom(new byte[64])
    };
    
    // Execute malicious UpdateValue
    KeyPairProvider.SetKeyPair(maliciousMiner);
    await AEDPoSContractStub.UpdateValue.SendAsync(maliciousInput);
    
    // Attempt to generate next round - this should throw OverflowException
    var nextRoundMiner = InitialCoreDataCenterKeyPairs[1];
    KeyPairProvider.SetKeyPair(nextRoundMiner);
    
    // This call will fail with OverflowException during round generation
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Behaviour = AElfConsensusBehaviour.NextRound,
                Pubkey = ByteString.CopyFrom(nextRoundMiner.PublicKey)
            }.ToBytesValue());
    });
    
    // Verify overflow exception occurred
    Assert.Contains("Overflow", exception.Message);
}
```

## Notes

This vulnerability demonstrates a critical gap in the validation of consensus parameters. The `tune_order_information` field, intended for dynamic mining order adjustments, lacks proper bounds checking. While the `ApplyNormalConsensusData` method ensures normal operations keep values within safe bounds, the direct assignment in `ProcessUpdateValue` creates a bypass that can be exploited by any current miner to halt the entire network. The fix requires adding explicit validation of all `tune_order_information` values against the valid range `[1, minersCount]` before applying them to the round state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-19)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
