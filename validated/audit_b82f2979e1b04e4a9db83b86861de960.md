# Audit Report

## Title
Double Voting Vulnerability in Delegated Voting Mode Allows Unlimited Vote Inflation

## Summary
The Vote contract's `Vote()` function lacks validation to prevent reusing the same `VoteId` in delegated voting mode (IsLockToken=false). A malicious sponsor can call `Vote()` multiple times with identical `VoteId` values, causing each call to increment the voting results while only storing the final voting record, enabling unlimited vote count inflation without any token backing.

## Finding Description

The vulnerability exists in the `Vote()` function where votes are processed and recorded. The function stores voting records by directly assigning to the state mapping without first checking if the VoteId already exists. [1](#0-0) 

After storing the voting record, `UpdateVotingResult()` is called unconditionally, which adds the vote amount to the results, increments the voters count, and increases the total votes amount - regardless of whether this VoteId was previously used. [2](#0-1) 

For delegated voting items (IsLockToken=false), the validation logic only requires that the sponsor is the caller, Voter is non-null, and VoteId is non-null - there is no uniqueness check for the VoteId. [3](#0-2) 

Since no tokens are locked when IsLockToken=false, the sponsor can repeatedly call Vote() with the same VoteId using different amounts and options, and each call will add to the voting results while overwriting the previous record. [4](#0-3) 

Critically, the VotingRecords state is a simple mapping from Hash to VotingRecord, which means assignment operations overwrite existing values. [5](#0-4) 

In contrast, the ElectionContract properly validates VoteId uniqueness by checking if the VoteId has been used before, which the VoteContract fails to implement. [6](#0-5) 

## Impact Explanation

**Critical Governance Manipulation**: A malicious sponsor can completely manipulate voting outcomes by artificially inflating vote counts for any option without possessing corresponding tokens. 

Attack scenario:
1. First call: Vote(VoteId="X", Amount=1000, Option="A", Voter=Alice) → Results["A"] = 1000
2. Second call: Vote(VoteId="X", Amount=2000, Option="B", Voter=Bob) → Results["B"] = 2000  
3. Third call: Vote(VoteId="X", Amount=3000, Option="C", Voter=Charlie) → Results["C"] = 3000
4. Result: Total votes counted = 6000, but only one record exists showing 3000 for Charlie

**Severity Justification**: 
- Any sponsor of a delegated voting item can exploit this
- Vote counts can be inflated arbitrarily without limit
- No tokens are required to back the inflated votes
- Voting results become completely unreliable
- Affects any contract using the Vote contract for delegated voting scenarios
- Breaks the fundamental security guarantee that vote counts reflect actual token backing

## Likelihood Explanation

**High Exploitability**: 
- The attack requires only that the malicious actor register a voting item with IsLockToken=false by calling the public `Register()` function
- The sponsor role is automatically assigned to the transaction sender during registration
- The sponsor has complete control over VoteId, Amount, and Voter parameters in delegated voting mode
- No special privileges or complex state manipulation required
- The exploit can be executed in straightforward sequential transactions

**Feasibility**: 
- Any account can register a voting item - it's a public function
- Delegated voting (IsLockToken=false) is a documented and intentional feature for higher-level contracts
- No economic cost since no tokens need to be locked
- The vulnerability is in the core contract logic, not an edge case

**Detection Constraints**: 
- The inflated vote counts appear legitimate in the VotingResult state
- Only forensic analysis comparing VotingRecords count versus VotingResults totals would reveal the discrepancy
- The vulnerability is inherent to the contract logic, not an implementation bug

## Recommendation

Add VoteId uniqueness validation before storing the voting record, similar to how the ElectionContract implements it. The fix should:

1. Check if the VoteId already exists in VotingRecords before allowing the vote
2. Assert that the VoteId has not been used previously
3. Ensure this check applies to both locked and delegated voting modes

Recommended fix for the `Vote()` function:

```csharp
public override Empty Vote(VoteInput input)
{
    var votingItem = AssertValidVoteInput(input);
    
    // Add uniqueness check
    Assert(State.VotingRecords[input.VoteId] == null, "Vote already exists.");
    
    // ... rest of the function logic
}
```

Alternatively, add the check in `AssertValidVoteInput()` to centralize validation logic.

## Proof of Concept

```csharp
[Fact]
public async Task DoubleVoting_VoteInflation_Vulnerability_POC()
{
    // Setup: Register a delegated voting item (IsLockToken=false)
    var votingItem = await RegisterVotingItemAsync(100, 3, false, DefaultSender, 1);
    var voteItemId = votingItem.VotingItemId;
    
    // Attack: Use the same VoteId multiple times with different amounts and options
    var attackVoteId = HashHelper.ComputeFrom("AttackVoteId");
    
    // First vote: 1000 for Option A with Voter Alice
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = voteItemId,
        VoteId = attackVoteId,
        Voter = Accounts[1].Address,
        Amount = 1000,
        Option = votingItem.Options[0]
    });
    
    // Second vote: 2000 for Option B with Voter Bob (SAME VoteId)
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = voteItemId,
        VoteId = attackVoteId,
        Voter = Accounts[2].Address,
        Amount = 2000,
        Option = votingItem.Options[1]
    });
    
    // Third vote: 3000 for Option C with Voter Charlie (SAME VoteId)
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = voteItemId,
        VoteId = attackVoteId,
        Voter = Accounts[3].Address,
        Amount = 3000,
        Option = votingItem.Options[2]
    });
    
    // Verify the vulnerability: Check voting results
    var votingResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = voteItemId,
        SnapshotNumber = 1
    });
    
    // VULNERABILITY PROOF: Total votes should be 6000 (1000+2000+3000)
    // but only one record exists
    votingResult.Results[votingItem.Options[0]].ShouldBe(1000); // Option A
    votingResult.Results[votingItem.Options[1]].ShouldBe(2000); // Option B  
    votingResult.Results[votingItem.Options[2]].ShouldBe(3000); // Option C
    votingResult.VotesAmount.ShouldBe(6000); // Total inflated!
    votingResult.VotersCount.ShouldBe(3);
    
    // But only ONE voting record exists
    var votingRecord = await VoteContractStub.GetVotingRecord.CallAsync(attackVoteId);
    votingRecord.Amount.ShouldBe(3000); // Only the last amount
    votingRecord.Voter.ShouldBe(Accounts[3].Address); // Only the last voter
    votingRecord.Option.ShouldBe(votingItem.Options[2]); // Only the last option
    
    // CRITICAL: 6000 votes counted with NO token backing!
}
```

**Notes**

This vulnerability represents a fundamental breakdown in vote integrity for delegated voting scenarios. The ElectionContract correctly implements VoteId uniqueness validation, but the general-purpose VoteContract does not, making it exploitable. The fix is straightforward: add the same uniqueness assertion that exists in ElectionContract to prevent VoteId reuse. This issue only affects delegated voting (IsLockToken=false) where the sponsor has control over VoteId assignment, but it completely undermines the trustworthiness of voting results in those scenarios.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L16-19)
```csharp
    /// <summary>
    ///     VoteId -> VotingRecord
    /// </summary>
    public MappedState<Hash, VotingRecord> VotingRecords { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```
