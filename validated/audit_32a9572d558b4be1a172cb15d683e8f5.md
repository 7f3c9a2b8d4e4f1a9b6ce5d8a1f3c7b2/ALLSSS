# Audit Report

## Title
Governance Bypass via Malicious AuthorityInfo in Connector Controller Change

## Summary
The `ChangeConnectorController` function in the TokenConverter contract fails to validate that the `ContractAddress` field in the provided `AuthorityInfo` is a legitimate governance contract (Parliament, Association, or Referendum). An attacker who successfully passes one malicious Parliament proposal can set a fake governance contract that always validates as legitimate, permanently bypassing all future governance requirements for critical connector management operations.

## Finding Description

The vulnerability exists in the authorization validation pattern used by the TokenConverter contract. The contract uses an `AuthorityInfo` structure containing two fields: `ContractAddress` (the governance contract) and `OwnerAddress` (the organization address within that contract).

**Root Cause:**

The `CheckOrganizationExist` helper method makes an unchecked cross-contract call to whatever address is provided in `authorityInfo.ContractAddress`: [1](#0-0) 

This function blindly trusts the provided `ContractAddress` without validating it's one of the three legitimate system governance contracts defined in: [2](#0-1) 

**Vulnerable Flow:**

When `ChangeConnectorController` is called, it only verifies that the organization exists in the provided contract: [3](#0-2) 

After a malicious `AuthorityInfo` is set, all subsequent authorization checks in `AssertPerformedByConnectorController` only validate that the caller's address matches `OwnerAddress`, completely ignoring whether the authorization actually came through a legitimate governance process: [4](#0-3) 

**Why Legitimate Governance Works:**

In legitimate setups, the `OwnerAddress` is a virtual organization address calculated by the governance contract: [5](#0-4) 

These virtual addresses can only be used as senders through `SendVirtualInlineBySystemContract` when a proposal is approved and released: [6](#0-5) 

**Attack Scenario:**

1. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` that always returns `true`
2. Attacker crafts a Parliament proposal to call `ChangeConnectorController` with `AuthorityInfo` containing:
   - `ContractAddress` = malicious contract address
   - `OwnerAddress` = attacker's own regular address (NOT a virtual organization address)
3. If the proposal is approved (through compromise, social engineering, or emergency), it executes
4. The malicious `AuthorityInfo` passes validation because the fake contract returns `true`
5. Now `State.ConnectorController.Value.OwnerAddress` equals the attacker's regular address
6. The attacker can directly call `UpdateConnector`, `AddPairConnector`, `SetFeeRate`, etc. without any governance approval, because `AssertPerformedByConnectorController` only checks if `Context.Sender == OwnerAddress`

## Impact Explanation

**Governance Capture:**
Once the malicious controller is set, the attacker gains permanent, unrestricted control over all connector management functions:
- `UpdateConnector` - manipulate connector weights and virtual balances affecting Bancor pricing formulas
- `AddPairConnector` - create unauthorized token trading pairs
- `SetFeeRate` - eliminate or maximize transaction fees
- `ChangeConnectorController` - prevent governance from regaining control

**Economic Damage:**
The TokenConverter manages critical DeFi infrastructure. An attacker can:
- Manipulate token prices by adjusting connector weights and virtual balances
- Drain reserves through unfavorable connector parameters
- Disrupt the entire token conversion mechanism
- Extract value through fee manipulation

**Permanence and Irreversibility:**
Since the authorization check only validates `Context.Sender == OwnerAddress` and the attacker controls a regular address (not a virtual organization address), legitimate governance cannot reclaim control even through new Parliament proposals. The attacker can continuously call `ChangeConnectorController` to block any recovery attempts.

This violates the fundamental governance invariant that critical protocol parameters must always remain under decentralized governance control.

## Likelihood Explanation

**Prerequisites:**
1. Attacker deploys a malicious contract (unrestricted action)
2. ONE Parliament proposal gets approved containing the malicious `AuthorityInfo`

**Attack Complexity:**
The malicious contract is trivial to implement - just return `true` from `ValidateOrganizationExist`. The Parliament proposal would contain the malicious parameters but might not be recognized as malicious by validators reviewing standard governance proposals.

**Escalation Nature:**
This is a **privilege escalation vulnerability**. It converts temporary governance compromise (one approved proposal) into permanent, irrecoverable control loss. A single malicious or mistaken proposal has catastrophic, irreversible consequences rather than a limited one-time impact.

**Realistic Scenarios:**
- Social engineering during emergency situations
- Validator confusion about non-standard governance contract addresses  
- Temporary key compromise
- Insider attack from someone with proposal creation rights

The critical insight is that this isn't about requiring full permanent compromise of governance - it's about escalating ANY temporary governance access into permanent bypass of all future governance requirements.

## Recommendation

Add validation in `CheckOrganizationExist` or `ChangeConnectorController` to ensure `ContractAddress` is one of the three legitimate governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

This pattern should be applied to ALL contracts using `CheckOrganizationExist` for controller changes, as the same vulnerability exists across the codebase: [7](#0-6) 

## Proof of Concept

A complete test would require:

1. Deploy a malicious governance contract:
```csharp
public class MaliciousGovernance : Container.ContainerBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true };  // Always returns true
    }
}
```

2. Create and approve a Parliament proposal calling `TokenConverter.ChangeConnectorController` with:
```csharp
new AuthorityInfo 
{
    ContractAddress = maliciousGovernanceAddress,
    OwnerAddress = attackerAddress  // Regular address, not virtual
}
```

3. After execution, attacker directly calls `TokenConverter.UpdateConnector` without any governance approval:
```csharp
// This succeeds because Context.Sender == attackerAddress == State.ConnectorController.Value.OwnerAddress
await TokenConverterStub.UpdateConnector.SendAsync(new Connector 
{
    Symbol = "TARGETTOKEN",
    Weight = "0.01",  // Manipulate pricing
    VirtualBalance = 1  // Manipulate reserves
});
```

The key test assertion is that after the malicious controller is set, the attacker can call governance-protected methods directly without going through any governance proposal mechanism, permanently bypassing all authorization checks.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L18-36)
```csharp
    public static readonly Hash ParliamentContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Parliament");

    public static readonly Hash VoteContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Vote");
    public static readonly Hash ProfitContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Profit");

    public static readonly Hash CrossChainContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.CrossChain");

    public static readonly Hash TokenConverterContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.TokenConverter");

    public static readonly Hash EconomicContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Economic");

    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L293-305)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress =
            Context.ConvertVirtualAddressToContractAddressWithContractHashName(
                CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));
        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
