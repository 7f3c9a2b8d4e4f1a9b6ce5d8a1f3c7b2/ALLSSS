# Audit Report

## Title
Empty Miner List Acceptance Causes Permanent Side Chain Consensus DoS via Division by Zero

## Summary
The `UpdateInformationFromCrossChain()` function in the AEDPoS consensus contract fails to validate that the parent chain's miner list is non-empty before storing it in state. When an empty miner list is stored, all subsequent consensus updates fail with a `DivideByZeroException` during resource token distribution, permanently breaking the side chain's ability to synchronize with the parent chain.

## Finding Description

The vulnerability exists in the cross-chain consensus update mechanism where side chains receive miner list information from their parent chain.

**Root Cause:**

The `UpdateInformationFromCrossChain` method extracts miner keys without validation [1](#0-0)  and commits them directly to state. The only validation checks are for null/empty input and round number comparison [2](#0-1) , but there is no check ensuring `RealTimeMinersInformation` contains at least one miner.

**Attack Execution:**

1. **First malicious call**: Parent chain data containing empty `RealTimeMinersInformation` is indexed. The empty miner list bypasses all validation checks and gets stored in `State.MainChainCurrentMinerList.Value`.

2. **Subsequent calls**: When the next consensus update occurs, `DistributeResourceTokensToPreviousMiners()` is invoked before the new miner list update [3](#0-2) .

3. **Division by zero**: The function retrieves the empty miner list from state [4](#0-3)  and attempts to calculate token distribution per miner [5](#0-4) .

4. **Exception thrown**: The `Div` method performs standard division [6](#0-5)  which throws `DivideByZeroException` when the miner count is zero.

5. **Permanent failure**: The guard checking `amount <= 0` comes AFTER the division [7](#0-6) , so it cannot prevent the exception. All subsequent calls to `UpdateInformationFromCrossChain` fail at the same point.

**Why Protections Fail:**

- The cross-chain contract passes consensus data without content validation [8](#0-7) 
- The `IsMainChainMinerListChanged` check returns false for empty lists [9](#0-8) , preventing usage but not storage
- Parent chain block data validation only checks structural properties (height, merkle root) [10](#0-9) , not consensus data content
- Round generation can produce empty `RealTimeMinersInformation` if given an empty miner list [11](#0-10) 

## Impact Explanation

**Critical Consensus Integrity Violation:**

- The side chain permanently loses its ability to receive miner list updates from the parent chain
- All subsequent `UpdateInformationFromCrossChain` transactions revert with an unrecoverable exception
- The consensus system becomes non-functional, requiring a hard fork or chain restart
- No automated recovery mechanism exists

**Operational Impact:**

- Complete halt of cross-chain consensus synchronization
- If the empty miner list affects round generation, no blocks can be produced
- Economic damage from extended downtime and loss of user confidence
- Manual intervention required (hard fork) with significant coordination costs
- Affects the entire side chain ecosystem, not just consensus operations

The severity is **Critical** because it causes permanent DoS of core consensus functionality with no automated recovery mechanism.

## Likelihood Explanation

**Reachable Entry Point:**

The function can be triggered through the normal cross-chain indexing flow. When miners propose and release parent chain block data containing consensus information [12](#0-11) , that data is processed and forwarded to the consensus contract.

**Attack Vectors:**

1. **Parent chain bug**: A bug in the parent chain's consensus contract generates an invalid Round with empty `RealTimeMinersInformation`
2. **Malicious parent chain**: If operating a private parent-side chain pair, the parent chain could intentionally send malicious data
3. **Edge case scenario**: During parent chain maintenance or migration, empty miner data could be inadvertently propagated

**Execution Practicality:**

- Single malicious cross-chain consensus update triggers the vulnerability
- No complex preconditions required beyond the malformed data being indexed
- Attack persists permanently after a single successful execution
- No economic cost barrier if parent chain data is compromised

The likelihood is **Medium** - while it requires malformed parent chain data (uncommon in normal operation), the impact is so severe and permanent that even a low probability event represents critical risk. From a defense-in-depth perspective, the side chain should validate all external data, including parent chain consensus information.

## Recommendation

Add validation to ensure the miner list is non-empty before storing it:

```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    Assert(
        Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
        "Only Cross Chain Contract can call this method.");

    Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

    if (input == null || input.Value.IsEmpty) return new Empty();

    var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

    if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
        return new Empty();

    // ADD THIS VALIDATION
    var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
    Assert(minersKeys.Any(), "Main chain miner list cannot be empty.");

    DistributeResourceTokensToPreviousMiners();

    State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;
    State.MainChainCurrentMinerList.Value = new MinerList
    {
        Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
    };

    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UpdateInformationFromCrossChain_EmptyMinerList_CausesDivisionByZero()
{
    // Setup: Initialize side chain with valid miner list
    SetToSideChain();
    InitialContracts();
    
    var mockedCrossChain = SampleAccount.Accounts.Last();
    var mockedCrossChainStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        mockedCrossChain.KeyPair);

    // First update: Store empty miner list
    var emptyMinerListHeader = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 2,
            RealTimeMinersInformation = { } // EMPTY
        }
    };

    await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
    {
        Value = emptyMinerListHeader.ToByteString()
    });

    // Verify empty list was stored
    var storedMinerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
    storedMinerList.Pubkeys.Count.ShouldBe(0);

    // Setup: Add some tokens to consensus contract for distribution
    await CreateAndIssueToken("READ");
    await TokenStub.Transfer.SendAsync(new TransferInput
    {
        Symbol = "READ",
        Amount = 10_00000000,
        To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
    });

    // Second update: Attempt to update with valid miner list
    var validMinerListHeader = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 3,
            RealTimeMinersInformation =
            {
                { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() }
            }
        }
    };

    // This should throw DivideByZeroException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
        {
            Value = validMinerListHeader.ToByteString()
        });
    });
    
    exception.Message.ShouldContain("DivideByZero");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L41-47)
```csharp
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L72-72)
```csharp
        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L81-81)
```csharp
            var amount = balance.Div(minerList.Count);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L83-83)
```csharp
            if (amount <= 0) continue;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L338-346)
```csharp
    private void AssertParentChainBlock(int parentChainId, long currentRecordedHeight,
        ParentChainBlockData parentChainBlockData)
    {
        Assert(parentChainId == parentChainBlockData.ChainId, "Wrong parent chain id.");
        Assert(currentRecordedHeight + 1 == parentChainBlockData.Height,
            $"Parent chain block info at height {currentRecordedHeight + 1} is needed, not {parentChainBlockData.Height}");
        Assert(parentChainBlockData.TransactionStatusMerkleTreeRoot != null,
            "Parent chain transaction status merkle tree root needed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L782-788)
```csharp
            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```
