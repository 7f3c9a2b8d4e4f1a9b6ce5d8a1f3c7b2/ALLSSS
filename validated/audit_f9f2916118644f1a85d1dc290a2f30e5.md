# Audit Report

## Title
Deterministic Hash Causes Infinite Loop DOS in NFT Protocol Creation

## Summary
The `GenerateSymbolNumber()` function in the NFT contract contains a critical infinite loop vulnerability where a random hash is generated once before a collision-avoidance loop but never regenerated within the loop. Since `Context.ConvertHashToInt64()` is deterministic, the same number is produced on every iteration, causing an infinite loop and gas exhaustion when that number already exists in `State.IsCreatedMap`.

## Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` helper function where collision avoidance is attempted through a do-while loop. [1](#0-0) 

The critical flaw occurs in the following sequence:

1. A `randomHash` is computed once outside the loop using random bytes from the consensus contract combined with the sender's address. [2](#0-1) 

2. Inside the do-while loop, this fixed `randomHash` is passed to `Context.ConvertHashToInt64()` with constant range parameters. [3](#0-2) 

3. The `ConvertHashToInt64()` method is deterministic - it uses BigInteger modulo arithmetic with no randomness or state changes. [4](#0-3) 

Given identical inputs (`randomHash`, `from`, `from.Mul(10)`), this function returns the exact same `randomNumber` value on every loop iteration. If `State.IsCreatedMap[randomNumber]` returns `true`, the while condition is satisfied and the loop continues infinitely with no mechanism to escape.

This vulnerability is triggered through the public `Create()` method which calls `GetSymbol()`, which in turn calls `GenerateSymbolNumber()`. [5](#0-4) [6](#0-5) 

The number length starts at `NumberMinLength = 9`. [7](#0-6) 

## Impact Explanation

**Severity: Critical**

**Direct Operational Impact:**
- Complete DOS of the `Create()` function for specific (sender address, block height) combinations that generate already-used numbers
- Users experience transaction failures after gas exhaustion with no clear error message indicating the root cause
- The NFT protocol creation mechanism becomes progressively unreliable as `State.IsCreatedMap` accumulates more entries

**Scope of Affected Users:**
- Any user whose deterministic hash mapping collides with an existing entry
- Since the mapping is deterministic per (sender, blockHeight) pair, certain addresses will be permanently unable to create protocols at specific block heights
- As protocol creation continues over time, the collision probability increases
- With sufficient protocol creation, some address ranges may become completely blocked from ever creating new protocols

**Protocol Integrity Impact:**
- Core functionality of the NFT contract is compromised
- User trust erodes as creation attempts mysteriously fail
- Wasted transaction fees for users encountering the infinite loop
- Potential forced migration to alternative NFT solutions

This represents a critical availability vulnerability affecting the primary purpose of the NFT contract.

## Likelihood Explanation

**Likelihood: Medium to High (increasing over time)**

**Attacker Capabilities Required:** 
None - this occurs naturally without malicious intent when legitimate users attempt to create NFT protocols.

**Attack Complexity:** 
Trivial - users simply call the public `Create()` method with valid inputs. No special setup, permissions, or manipulation required.

**Feasibility Conditions:**
- The vulnerability triggers automatically when the deterministic number generation produces a value already present in `State.IsCreatedMap`
- Initial collision probability is low with 9Ã—10^8 possible 9-digit values
- However, the hash-to-number mapping is deterministic for each (sender address, block height) combination
- As more NFT protocols are created, `State.IsCreatedMap` grows and collision probability increases
- Eventually, certain sender addresses will consistently fail at specific block heights

**Probability Assessment:**
- **Initial phase:** Low probability when few protocols exist
- **Growth phase:** Probability increases as more protocols are created
- **Saturation phase:** Certain address/block height combinations reach 100% failure rate
- **Persistence:** Once an address encounters a collision at one block height, retrying at that same height will always fail due to deterministic behavior

**Detection:** 
Transaction failures manifest as gas exhaustion without descriptive error messages, making the root cause difficult to diagnose for end users.

## Recommendation

The hash must be regenerated on each loop iteration to produce different candidate numbers. The fix should modify the loop to incorporate changing inputs:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    var attempt = 0L;
    do
    {
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(attempt));
        
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        attempt++;
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

Alternatively, use an incrementing counter or include additional entropy sources that change on each iteration.

## Proof of Concept

A proof of concept would involve:

1. Create an NFT protocol using `Create()` with a specific sender address and record the generated symbol
2. Extract the numeric portion of the symbol to identify which `randomNumber` was generated
3. Manually set `State.IsCreatedMap[randomNumber] = true` 
4. Call `Create()` again from the same sender address at a block height that produces the same `randomHash`
5. Observe that the transaction runs out of gas due to the infinite loop

The test would demonstrate that once a collision occurs, the same sender at blocks producing the same consensus random bytes cannot create new protocols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
