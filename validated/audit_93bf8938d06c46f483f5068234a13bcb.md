# Audit Report

## Title
LIB Height Validation Bypass Through Pre-Validation State Mutation

## Summary
A critical ordering flaw in the `ValidateBeforeExecution` function allows malicious miners to bypass Last Irreversible Block (LIB) height validation by modifying the trusted state before validation occurs, enabling them to submit artificially decreased `ImpliedIrreversibleBlockHeight` values that violate consensus finality guarantees.

## Finding Description

The vulnerability exists in the validation sequence within the AEDPoS consensus contract. When a miner produces an `UpdateValue` block, the validation flow executes in the following flawed order:

First, `baseRound` is fetched from state containing the trusted previous `ImpliedIrreversibleBlockHeight` value. [1](#0-0) 

For `UpdateValue` behavior, `RecoverFromUpdateValue` is called on `baseRound` BEFORE validation occurs. [2](#0-1) 

The `RecoverFromUpdateValue` method modifies `baseRound` in-place, overwriting the trusted `ImpliedIrreversibleBlockHeight` from state with the provided value. [3](#0-2) 

The `ConsensusValidationContext` is then created with the modified `baseRound`, and `ProvidedRound` returns `ExtraData.Round` (the original provided round). [4](#0-3) [5](#0-4) 

The `LibInformationValidationProvider` is added to validate LIB information for UpdateValue behavior. [6](#0-5) 

The validation check compares `baseRound.ImpliedIrreversibleBlockHeight` (now containing the provided value after mutation) against `providedRound.ImpliedIrreversibleBlockHeight` (the original provided value). Since both values are identical due to the pre-validation mutation, the check fails to detect decreases from the original trusted state value. [7](#0-6) 

The malicious decreased value is then persisted to state during processing via the `UpdateValue` method entry point. [8](#0-7) [9](#0-8) [10](#0-9) 

This decreased value directly impacts LIB calculation. The `LastIrreversibleBlockHeightCalculator` retrieves sorted implied heights from miners and calculates the confirmed LIB height using a Byzantine Fault Tolerant threshold. [11](#0-10) [12](#0-11) 

If miners can decrease their implied heights by bypassing validation, the calculated `ConfirmedIrreversibleBlockHeight` can be artificially lowered, violating the fundamental blockchain invariant that LIB must never decrease.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability breaks the core consensus finality guarantee that the Last Irreversible Block height must monotonically increase and never decrease. A malicious miner can exploit this to:

1. **Violate Finality Guarantees**: By decreasing the LIB height, blocks previously considered irreversible can become reversible again, breaking the finality promise to users and applications.

2. **Enable Double-Spending Attacks**: Transactions that users believed were finalized (beyond LIB) could potentially be reversed if the LIB is artificially decreased, allowing double-spending of tokens.

3. **Cross-Chain Bridge Exploits**: Cross-chain bridges and relayers rely on LIB verification for security. Manipulating LIB enables attacks on cross-chain asset transfers.

4. **Consensus Safety Violations**: The ability to manipulate LIB affects all network participants and undermines the consensus mechanism's safety properties.

5. **Chain Reorganization Beyond Expected Window**: Applications and services assume blocks beyond LIB cannot be reorganized. This assumption is violated when LIB can be decreased.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities**: Any active miner in the consensus set can exploit this vulnerability. Miners are not privileged trusted parties - they are network participants selected through the election mechanism.

**Attack Complexity**: LOW - The attack requires only:
- Being a valid miner in the current round (passes `MiningPermissionValidationProvider`)
- Producing a block during the assigned time slot (passes `TimeSlotValidationProvider`)
- Submitting an `UpdateValue` block with a decreased `ImpliedIrreversibleBlockHeight` value

**Preconditions**: Minimal - attacker only needs to be an active miner, achievable through the election process.

**Execution Practicality**: HIGHLY PRACTICAL - The validation bypass is deterministic and guaranteed to succeed due to the code logic flaw. No race conditions, timing windows, or uncertain behaviors are involved.

**Detection Difficulty**: MODERATE - While the decreased LIB would be recorded on-chain and visible in round state, it may not trigger immediate alarms unless monitoring systems specifically check for LIB decreases.

**Economic Rationality**: HIGH - A malicious miner gains significant capability (finality manipulation) at minimal cost (normal block production), enabling profitable exploits like double-spending.

## Recommendation

Fix the ordering by performing validation BEFORE modifying the trusted state. The solution is to validate against the original unmodified `baseRound` fetched from state:

1. Fetch `baseRound` from state
2. Create validation context with unmodified `baseRound` and provided round from `extraData`
3. Perform all validation checks (including `LibInformationValidationProvider`)
4. Only after validation passes, call `RecoverFromUpdateValue` to apply the changes
5. Use the recovered round for subsequent processing

The fix would move lines 46-50 in `AEDPoSContract_Validation.cs` to execute AFTER line 98 (after validation completes successfully).

## Proof of Concept

```csharp
// Exploit scenario demonstrating the vulnerability:
// 1. Current state has miner A with ImpliedIrreversibleBlockHeight = 1000
// 2. Attacker (miner A) creates UpdateValueInput with ImpliedIrreversibleBlockHeight = 500
// 3. Calls UpdateValue() which invokes ValidateBeforeExecution()
// 4. baseRound fetched with value 1000
// 5. RecoverFromUpdateValue() overwrites baseRound to 500 (line 19 of Round_Recover.cs)
// 6. LibInformationValidationProvider compares: 500 > 500 ? FALSE -> validation passes
// 7. Should have been: 1000 > 500 ? TRUE -> validation rejects
// 8. Malicious value 500 gets persisted to state
// 9. LIB calculation uses decreased value, potentially lowering network LIB
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-19)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-18)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
```
