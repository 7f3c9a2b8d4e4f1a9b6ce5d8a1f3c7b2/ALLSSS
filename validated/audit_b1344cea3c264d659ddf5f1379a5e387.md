# Audit Report

## Title
Incomplete Validation of MinerInRound Fields in NextRound Allows Reward Manipulation and False Evil Miner Detection

## Summary
The AEDPoS consensus contract's NextRound validation fails to verify critical miner performance metrics including `ProducedBlocks`, `MissedTimeSlots`, `Order`, and `IsExtraBlockProducer` fields. A malicious extra block producer can manipulate these unvalidated fields in the consensus header to steal mining rewards and falsely ban honest miners, causing direct economic harm.

## Finding Description

The vulnerability exists in the NextRound validation pipeline. When processing NextRound behavior, the validation only adds two specific providers that check a limited subset of fields: [1](#0-0) 

The `RoundTerminateValidationProvider` validates only round number increment and null InValues: [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` validates only the count relationship between FinalOrderOfNextRound and OutValue: [3](#0-2) 

However, the `MinerInRound` structure contains 17 fields, including critical performance metrics that are NOT validated: [4](#0-3) 

During `ProcessNextRound`, the unvalidated NextRoundInput is directly converted to Round via simple field copying: [5](#0-4) [6](#0-5) 

The manipulated data is then persisted to contract state: [7](#0-6) 

## Impact Explanation

**1. Reward Theft via ProducedBlocks Manipulation**

The Treasury contract retrieves previous term data containing stored ProducedBlocks values: [8](#0-7) [9](#0-8) 

These values directly determine reward shares in UpdateBasicMinerRewardWeights: [10](#0-9) 

The CalculateShares function penalizes miners with low production, giving zero rewards below average/2: [11](#0-10) 

An attacker can inflate their own ProducedBlocks to maximize rewards while deflating competitors' values below the threshold to eliminate their rewards entirely.

**2. False Evil Miner Detection via MissedTimeSlots Manipulation**

The consensus contract detects evil miners based on MissedTimeSlots: [12](#0-11) 

The threshold is 4,320 missed slots (3 days): [13](#0-12) 

When evil miners are detected, they are permanently banned: [14](#0-13) 

The manipulated next round becomes the current round in subsequent transitions, enabling future false detections and censorship of honest miners.

**Economic Impact**: Direct theft of mining rewards proportional to manipulation magnitude, plus censorship of honest miners through false evil node marking.

## Likelihood Explanation

**Attacker Capabilities:**
- Any miner can become extra block producer through deterministic rotation
- Extra block producer selection occurs via CalculateNextExtraBlockProducerOrder: [15](#0-14) 

**Attack Complexity: LOW**
- Modify protobuf message fields before block creation (trivial operation)
- No cryptographic binding prevents modification of unvalidated fields
- Validation gap is structural and permanent
- No off-chain monitoring mechanism exists

**Execution Practicality: HIGH**
- Attack cost: Single transaction gas fee
- Potential gain: Significant fraction of term's mining rewards
- Detection difficulty: Requires off-chain comparison of actual vs. expected values
- Economic rationality: Extremely favorable risk/reward ratio

## Recommendation

Add comprehensive validation for all security-critical MinerInRound fields in NextRound validation:

1. **Add ProducedBlocks validation**: Verify that ProducedBlocks values match the expected increment based on actual mining activity tracked in the current round state.

2. **Add MissedTimeSlots validation**: Verify that MissedTimeSlots increments match miners who failed to produce blocks in the current round.

3. **Add Order validation**: Verify that Order assignments are deterministic and match the expected mining schedule algorithm.

4. **Add IsExtraBlockProducer validation**: Verify that only the correctly calculated extra block producer has this flag set.

Create a new validation provider `NextRoundPerformanceMetricsValidationProvider` that computes expected values from current round state and compares them against provided NextRoundInput values. Add this provider to the validation pipeline for NextRound behavior.

## Proof of Concept

A proof of concept would require:
1. Deploy test consensus contract with mining setup
2. Become extra block producer through rotation
3. Generate legitimate NextRoundInput via GetConsensusExtraDataForNextRound
4. Modify ProducedBlocks field (inflate attacker's, deflate victim's)
5. Create and broadcast block with manipulated consensus data
6. Verify block passes validation
7. Verify manipulated data is stored in State.Rounds
8. Progress to term end and verify victim receives reduced/zero rewards in Treasury distribution
9. Verify attacker receives inflated rewards

The test would demonstrate that validation accepts manipulated values and Treasury distributes rewards based on the falsified ProducedBlocks data, confirming the exploit path.

## Notes

This vulnerability represents a fundamental flaw in the consensus validation architecture. The validation is **permissive** (checking only specific fields) rather than **restrictive** (computing expected values and comparing). The protobuf-based consensus data structure allows arbitrary modification of unvalidated fields by the block producer, breaking the assumption that performance metrics reflect actual mining activity. The impact is compounded by the delayed effectâ€”manipulation in round N affects rewards and evil detection in subsequent rounds, making attribution difficult.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** protobuf/aedpos_contract.proto (L266-300)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L136-139)
```csharp
        var previousTermInformation = State.AEDPoSContract.GetPreviousTermInformation.Call(new Int64Value
        {
            Value = input.PeriodNumber
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L789-821)
```csharp
        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-845)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L440-456)
```csharp
    public override Round GetPreviousTermInformation(Int64Value input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[input.Value.Add(1)].Sub(1);
        var round = State.Rounds[lastRoundNumber];
        if (round == null || round.RoundId == 0) return new Round();
        var result = new Round
        {
            TermNumber = input.Value
        };
        foreach (var minerInRound in round.RealTimeMinersInformation)
            result.RealTimeMinersInformation[minerInRound.Key] = new MinerInRound
            {
                Pubkey = minerInRound.Value.Pubkey,
                ProducedBlocks = minerInRound.Value.ProducedBlocks
            };

        return result;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
