# Audit Report

## Title
Round Number Manipulation Bypasses Continuous Block Production Limits in AEDPoS Consensus

## Summary
A malicious miner can bypass the continuous block production limit by manipulating the round number in consensus block headers. The `ContinuousBlocksValidationProvider` skips validation when `ProvidedRound.RoundNumber ≤ 2`, but for `UpdateValue` and `TinyBlock` behaviors, no validator ensures the provided round number matches the actual current round. This allows miners to exceed the 8-block limit and monopolize block production.

## Finding Description

The vulnerability stems from a missing validation in the consensus header validation pipeline. The AEDPoS consensus mechanism enforces a continuous block limit to prevent any single miner from dominating block production. [1](#0-0) 

The continuous block validation logic intentionally skips early rounds: [2](#0-1) 

However, the `ProvidedRound` comes directly from the block header's consensus extra data: [3](#0-2) 

For `UpdateValue` and `TinyBlock` behaviors (the most common block production modes), the validation pipeline does NOT include round number verification: [4](#0-3) 

Only `NextRound` and `NextTerm` behaviors include the `RoundTerminateValidationProvider` which validates round numbers: [5](#0-4) 

**Attack Execution Path:**

1. Miner produces 8+ continuous blocks, causing `LatestPubkeyToTinyBlocksCount.BlocksCount` to become negative
2. Miner generates normal consensus extra data via `GetConsensusBlockExtraData` [6](#0-5) 
3. Before block submission, miner modifies `Round.RoundNumber` field to 1 or 2
4. Block validation executes via `ValidateBeforeExecution` [7](#0-6) 
5. `ContinuousBlocksValidationProvider` sees `ProvidedRound.RoundNumber ≤ 2` and skips the check entirely
6. Other validators pass because they don't check round number matching
7. Block processing uses correct `currentRound` from state, not the manipulated header [8](#0-7) 
8. Miner repeats indefinitely to monopolize block production

The security guarantee broken is **fair block production distribution**. The continuous block limit exists to ensure no miner produces more than their allocated share: [9](#0-8) 

## Impact Explanation

**HIGH** severity due to fundamental consensus integrity violation:

- **Consensus Centralization**: A malicious miner can produce 100% of blocks instead of their fair share (approximately 1/N where N is the number of miners in the consensus set)
- **Economic Impact**: Disproportionate mining rewards - legitimate miners lose expected revenue equal to (malicious blocks × reward per block)
- **Time Slot Denial**: Other miners are prevented from producing blocks during their allocated time slots
- **Censorship Capability**: Controlling all block production enables transaction censorship
- **Network Security**: Defeats the multi-miner decentralization model that protects against single points of failure

All honest miners and network users are affected. This breaks a core invariant of the AEDPoS consensus mechanism.

## Likelihood Explanation

**HIGH** likelihood of exploitation:

**Attacker Prerequisites:**
- Must be an authorized miner in the consensus set (standard permission)
- Must run modified node software to manipulate consensus extra data
- No additional special permissions required

**Attack Complexity:**
- **Low Technical Barrier**: Simple modification of a single integer field (`RoundNumber`) in block header
- **No Timing Requirements**: Works at any time after round 2 (i.e., always after network bootstrap)
- **Deterministic**: No race conditions or probabilistic elements
- **Broad Applicability**: Works for both `UpdateValue` and `TinyBlock` behaviors which represent the majority of block production

**Detection Difficulty:**
- Block appears structurally valid to all validators
- No cryptographic signature mismatch
- Difficult to distinguish from legitimate software bugs
- Detection requires manual comparison of provided vs. actual round numbers

**Economic Incentive:**
- **High Reward**: Monopolize block production and associated rewards
- **Low Cost**: No staking penalties, no additional resource requirements
- **Rational Behavior**: Any revenue-maximizing miner has incentive to exploit

## Recommendation

Add round number validation for `UpdateValue` and `TinyBlock` behaviors by including a new validator or enhancing existing ones:

**Option 1: Add dedicated round number validator for all behaviors**
```csharp
public class RoundNumberValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // For UpdateValue and TinyBlock, provided round must match current round
        if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue ||
            validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        {
            if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
            {
                return new ValidationResult 
                { 
                    Message = $"Round number mismatch: provided {validationContext.ProvidedRound.RoundNumber}, expected {validationContext.BaseRound.RoundNumber}" 
                };
            }
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Then add this validator to the basic providers list in `ValidateBeforeExecution`:
```csharp
var validationProviders = new List<IHeaderInformationValidationProvider>
{
    new MiningPermissionValidationProvider(),
    new TimeSlotValidationProvider(),
    new ContinuousBlocksValidationProvider(),
    new RoundNumberValidationProvider() // Add this
};
```

**Option 2: Modify ContinuousBlocksValidationProvider to use BaseRound**
Change the condition to use `BaseRound.RoundNumber` instead of `ProvidedRound.RoundNumber`:
```csharp
if (validationContext.BaseRound.RoundNumber > 2 && // Use BaseRound instead of ProvidedRound
    validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

This ensures the check uses the actual current round from state, not the miner-provided value.

## Proof of Concept

```csharp
[Fact]
public async Task RoundNumberManipulation_BypassesContinuousBlockLimit()
{
    // Setup: Initialize chain with miner who has already produced MaximumTinyBlocksCount blocks
    var miner = SampleAccount.Accounts.First();
    await InitializeConsensusAsync();
    
    // Produce 8 blocks continuously to reach the limit
    for (int i = 0; i < 8; i++)
    {
        await ProduceNormalBlockAsync(miner);
    }
    
    // At this point, LatestPubkeyToTinyBlocksCount.BlocksCount should be negative
    var latestCount = await ConsensusStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    Assert.True(latestCount.BlocksCount < 0);
    
    // Attempt to produce 9th block with normal round number - should FAIL
    var normalBlock = await GenerateConsensusExtraDataAsync(miner);
    var normalValidation = await ValidateBlockAsync(normalBlock);
    Assert.False(normalValidation.Success);
    Assert.Contains("too many continuous blocks", normalValidation.Message);
    
    // Attack: Produce 9th block with manipulated round number = 1 - should SUCCEED (vulnerability)
    var manipulatedBlock = await GenerateConsensusExtraDataAsync(miner);
    manipulatedBlock.Round.RoundNumber = 1; // Manipulate round number
    var manipulatedValidation = await ValidateBlockAsync(manipulatedBlock);
    Assert.True(manipulatedValidation.Success); // Validation bypassed!
    
    // Miner can continue producing unlimited blocks
    for (int i = 0; i < 10; i++)
    {
        var attackBlock = await GenerateConsensusExtraDataAsync(miner);
        attackBlock.Round.RoundNumber = 1;
        var result = await ValidateBlockAsync(attackBlock);
        Assert.True(result.Success); // All bypass validation
    }
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-75)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L20-52)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }

        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();

        return information.ToBytesValue();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-242)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L333-365)
```csharp
    /// <summary>
    ///     To prevent one miner produced too many continuous blocks.
    /// </summary>
    /// <param name="minersCountInTheory"></param>
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
