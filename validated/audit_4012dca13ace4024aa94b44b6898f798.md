# Audit Report

## Title
Gas Griefing via Unbounded AutoDistributeThreshold Iteration in RegisterForProfits

## Summary
The `RegisterForProfits` function in the TokenHolder contract performs an unbounded loop over `AutoDistributeThreshold` entries, executing a cross-contract `GetBalance` call for each entry. A malicious scheme manager can create a scheme with hundreds of threshold entries that never meet distribution conditions, forcing users to pay excessive gas costs during registration even when no distribution occurs.

## Finding Description

The vulnerability exists in the auto-distribute threshold checking logic within the `RegisterForProfits` method. [1](#0-0) 

The critical issue occurs in the threshold checking loop where the code iterates through all entries in `scheme.AutoDistributeThreshold` without any size limit. [2](#0-1)  For each entry, it makes a cross-contract call to check the token balance. When thresholds are not met (the condition at line 191 evaluates to true), the loop continues through all remaining entries. The early exit check at line 202 only occurs AFTER the foreach loop has completed all iterations.

**Root Cause**: The `CreateScheme` function accepts `AutoDistributeThreshold` input without validating the number of entries. [3](#0-2) 

The `AutoDistributeThreshold` is defined as a map type that can contain multiple entries. [4](#0-3) 

While AElf's state size limit prevents extremely large maps [5](#0-4) , it still allows hundreds of entries since each entry only requires approximately 20-50 bytes (token symbol string + int64 threshold value). With 200 entries at ~30 bytes each, the map would only consume ~6KB, well under the 128KB limit.

**Attack Execution Flow**:
1. Malicious scheme manager calls `CreateScheme` with `AutoDistributeThreshold` containing 200+ entries, each mapping a token symbol to an intentionally high threshold value
2. Legitimate user calls `RegisterForProfits` expecting normal gas costs
3. The function enters the auto-distribute checking logic and begins iterating through all threshold entries
4. For each iteration, a cross-contract `GetBalance` call is executed
5. Since all thresholds are set artificially high, the loop continues through all entries without breaking
6. User has paid gas for 200+ cross-contract calls with no benefit

## Impact Explanation

**Operational DoS and Economic Griefing**:
- Users attempting to call `RegisterForProfits` on malicious schemes pay gas costs proportional to the number of `AutoDistributeThreshold` entries
- With 100 entries, users incur 100 cross-contract `GetBalance` calls, each consuming significant gas
- With 500+ entries, gas costs could exceed block gas limits, causing transaction failures and complete operational DoS
- Even if transactions succeed, users suffer economic damage through prohibitively expensive gas fees for what should be a simple registration operation

**Who is Affected**:
- Any user attempting to register for profits on schemes controlled by malicious managers
- Legitimate scheme managers whose users cannot afford to register due to gas constraints
- The protocol's usability and reputation suffers as users encounter unexpectedly high gas costs

**Severity Justification**: Medium - This represents a concrete operational DoS vector with quantifiable economic impact through gas griefing. The attack has high likelihood and low execution complexity, but does not result in direct fund loss or compromise protocol-level security invariants.

## Likelihood Explanation

**High Likelihood**:

**Attacker Capabilities**: Any address can create a TokenHolder scheme by calling `CreateScheme`. The scheme manager has complete control over the `AutoDistributeThreshold` map size with no validation beyond the general 128KB state size limit.

**Attack Complexity**: Trivial - The attacker simply calls `CreateScheme` with a large map containing 200+ token symbol entries mapped to high threshold values. No special conditions or timing requirements exist.

**Feasibility**: No preconditions required. The attacker only needs sufficient balance to pay for the `CreateScheme` transaction (minimal cost) with no special privileges or coordination required.

**Cost to Attacker**: Negligible - Only the gas cost of a single `CreateScheme` transaction, which is low compared to the repeated gas costs inflicted on each victim.

**Detection**: Difficult to detect before users attempt registration. The malicious scheme appears valid on-chain, and users only discover the issue when their `RegisterForProfits` transaction consumes excessive gas.

## Recommendation

Add a maximum limit validation for the `AutoDistributeThreshold` map size in the `CreateScheme` function:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation for maximum threshold entries
    const int MaxThresholdEntries = 10;
    Assert(input.AutoDistributeThreshold == null || 
           input.AutoDistributeThreshold.Count <= MaxThresholdEntries,
           $"AutoDistributeThreshold cannot contain more than {MaxThresholdEntries} entries.");
    
    // ... rest of the function
}
```

Alternatively, implement an early exit mechanism in `RegisterForProfits` to limit the number of balance checks, or cache balance checks to avoid repeated cross-contract calls.

## Proof of Concept

```csharp
[Fact]
public async Task RegisterForProfits_Gas_Griefing_Attack()
{
    // Attacker creates scheme with 200 threshold entries
    var maliciousThresholds = new Dictionary<string, long>();
    for (int i = 0; i < 200; i++)
    {
        maliciousThresholds[$"TOKEN{i}"] = 1000000000; // Impossibly high thresholds
    }
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = { maliciousThresholds }
    });
    
    // Victim attempts to register - will incur 200 GetBalance calls
    var result = await TokenHolderContractStub.RegisterForProfits.SendAsync(
        new RegisterForProfitsInput
        {
            Amount = 10,
            SchemeManager = Starter
        });
    
    // Transaction succeeds but consumed excessive gas
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    // Gas consumption would be abnormally high due to 200 cross-contract calls
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** protobuf/token_holder_contract.proto (L69-69)
```text
    map<string, int64> auto_distribute_threshold = 3;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```
