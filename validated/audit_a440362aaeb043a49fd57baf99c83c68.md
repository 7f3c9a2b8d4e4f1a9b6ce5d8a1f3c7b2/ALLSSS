# Audit Report

## Title
Treasury Accepts Unfavorable Prices Due to Missing Slippage Protection on Token Conversion

## Summary
The Treasury contract converts donated non-native tokens to native tokens without implementing slippage protection. When `ConvertToNativeToken` calls `TokenConverterContract.Sell`, it omits the `ReceiveLimit` parameter, which defaults to 0 and bypasses the price validation check. This allows the Treasury to accept arbitrarily unfavorable exchange rates, resulting in direct financial losses on every convertible token donation.

## Finding Description
The vulnerability exists in the token conversion flow when non-native tokens are donated to the Treasury. The `Donate` method determines if a donated token can be converted to the native token and triggers the conversion when appropriate. [1](#0-0) 

The `ConvertToNativeToken` private method performs the actual conversion by calling the TokenConverter's `Sell` method, but only passes the `Symbol` and `Amount` parameters, completely omitting the `ReceiveLimit` parameter. [2](#0-1) 

The `ReceiveLimit` parameter in the `SellInput` message is specifically designed to provide slippage protection. According to the protocol definition, it represents the minimum amount of base tokens that must be received, and "0 is no limit". [3](#0-2) 

In the TokenConverter's `Sell` method implementation, the price validation check uses an OR condition that bypasses validation when `ReceiveLimit` equals 0. [4](#0-3) 

Since the first condition `input.ReceiveLimit == 0` evaluates to true when no limit is set, the entire assertion passes regardless of the actual exchange rate received. This means the Treasury will accept any price the Bancor formula calculates, no matter how unfavorable.

The Bancor pricing formula is deterministic and directly depends on connector balances, making it predictable and manipulable through trades. [5](#0-4) 

## Impact Explanation
This vulnerability results in direct financial loss to the Treasury, which is a critical protocol component holding significant value for distribution to miners, voters, and other stakeholders. [6](#0-5) 

**Direct Financial Loss**: On every donation of convertible non-native tokens, the Treasury accepts whatever exchange rate exists at the moment of execution, with zero protection against:
- Deliberately manipulated prices (attacker front-runs with trades to worsen the rate)
- Normal market volatility (price moves unfavorably between donation initiation and execution)
- Large donation slippage (no minimum received amount means accepting poor rates on large conversions)

**Cumulative Impact**: Since the `Donate` method is public and can be called by anyone, this affects every single convertible token donation. The losses compound over time, directly reducing:
- Mining rewards available for distribution
- Subsidy pools for candidates
- Welfare rewards for citizens/voters
- Overall protocol economic sustainability

**Attack Scenarios**:
1. **Direct manipulation**: Attacker manipulates Bancor pool prices, then triggers donation themselves
2. **Opportunistic timing**: Attacker observes donation patterns and manipulates prices accordingly
3. **Passive losses**: Even without malicious actors, normal volatility causes Treasury to receive suboptimal rates

## Likelihood Explanation
**High Likelihood** - The vulnerability is easily exploitable because:

1. **Public Entry Point**: The `Donate` method has no access controls - anyone can trigger token donations and conversions. [7](#0-6) 

2. **Deterministic Price Calculation**: The Bancor formula is deterministic and publicly calculable. Anyone can predict the exact impact of trades on conversion rates by reading connector balances on-chain.

3. **No Price Protection**: The complete absence of slippage protection means the Treasury accepts ANY rate, making it vulnerable to both malicious price manipulation and normal market conditions.

4. **Repeatable Exploitation**: The attack can be executed on every donation transaction, making this a persistent drain on Treasury resources rather than a one-time exploit.

5. **Low Attack Barriers**: No privileged access required, anyone can trade on TokenConverter to influence prices, and simple timing or direct donation triggering enables exploitation.

## Recommendation
Add slippage protection to the `ConvertToNativeToken` method by specifying a `ReceiveLimit` parameter when calling `TokenConverterContract.Sell`. The limit should be calculated based on expected market rates with an acceptable tolerance (e.g., 1-5% slippage).

Recommended fix:
1. Query the current conversion rate before executing the sell
2. Calculate the expected native token amount based on the current rate
3. Set `ReceiveLimit` to the expected amount minus an acceptable slippage percentage
4. Pass this limit to the `Sell` call

The modified `ConvertToNativeToken` should calculate a minimum acceptable amount and pass it as `ReceiveLimit` in the `SellInput`.

## Proof of Concept
The existing tests in `test/AElf.Contracts.EconomicSystem.Tests/BVT/DonateTests.cs` demonstrate that donations of convertible tokens succeed without any price validation. [8](#0-7) 

To prove the vulnerability:
1. Setup a TokenConverter with a convertible token
2. Manipulate the Bancor pool prices by executing large trades
3. Call `Treasury.Donate` with the convertible token
4. Observe that Treasury accepts the unfavorable rate without reverting
5. Measure the difference between expected fair value and actual received amount

The vulnerability can be demonstrated by comparing the Treasury balance before and after donation under manipulated price conditions versus normal conditions, showing the financial loss incurred.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L18-39)
```csharp
/// <summary>
///     The Treasury is the largest profit scheme in AElf main chain.
///     Actually the Treasury is our Dividends Pool.
///     Income of the Treasury is mining rewards
///     (AEDPoS Contract will:
///     1. transfer ELF tokens to general ledger of Treasury every time we change term (7 days),
///     the amount of ELF should be based on blocks produced during last term. 1,000,000 * 1250000 ELF,
///     then release the Treasury;
///     2. Release Treasury)
///     3 sub profit schemes:
///     (Mining Reward for Miners) - 3
///     (Subsidy for Candidates / Backups) - 1
///     (Welfare for Electors / Voters / Citizens) - 1
///     3 sub profit schemes for Mining Rewards:
///     (Basic Rewards) - 4
///     (Welcome Rewards) - 1
///     (Flexible Rewards) - 1
///     3 incomes:
///     1. 20% total supply of elf, from consensus contract
///     2. tx fees.
///     3. resource consumption of developer's contracts.
/// </summary>
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-207)
```csharp
    public override Empty Donate(DonateInput input)
    {
        Assert(input.Amount > 0, "Invalid amount of donating. Amount needs to be greater than 0.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        var isNativeSymbol = input.Symbol == Context.Variables.NativeSymbol;
        var canExchangeWithNativeSymbol =
            isNativeSymbol ||
            State.TokenConverterContract.IsSymbolAbleToSell
                .Call(new StringValue { Value = input.Symbol }).Value;

        if (Context.Sender != Context.Self)
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = Context.Self,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = "Donate to treasury."
            });

        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L667-686)
```csharp
    private void ConvertToNativeToken(string symbol, long amount)
    {
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.TokenConverterContract.Value,
            Symbol = symbol,
            Amount = amount
        });

        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });

        Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
        {
            Symbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** protobuf/token_converter_contract.proto (L135-143)
```text
message SellInput {
    // The token symbol you want to sell.
    string symbol = 1;
    // The amount you want to sell.
    int64 amount = 2;
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
}
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-180)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/DonateTests.cs (L89-108)
```csharp
    public async Task Donate_FewOtherToken_Success_Test()
    {
        await InitialBuildConnector(EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol);
        var keyPair = CoreDataCenterKeyPairs[0];
        await TransferToken(keyPair, EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol, 100);
        var stub = GetTreasuryContractTester(keyPair);
        var donateResult = await stub.Donate.SendAsync(new DonateInput
        {
            Symbol = EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol,
            Amount = 50
        });
        donateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var userBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(keyPair.PublicKey),
            Symbol = EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol
        })).Balance;
        userBalance.ShouldBe(50);
    }
```
