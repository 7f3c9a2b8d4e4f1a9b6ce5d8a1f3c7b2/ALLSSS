# Audit Report

## Title
Proposal Hijacking via Expiration-Based Overwrite in Contract Deployment Workflow

## Summary
The Genesis contract's `RegisterContractProposingData()` function allows any user to overwrite in-progress contract deployment proposals after expiration, regardless of their current governance status. This enables attackers to hijack proposals that have already received Parliament approval, causing denial of service and permanent loss of control for legitimate proposers.

## Finding Description

The vulnerability exists in `RegisterContractProposingData()` which only validates expiration time without checking the proposal's current status: [1](#0-0) 

This function allows complete overwriting if the proposal has expired, treating all expired proposals identically regardless of whether they are fresh proposals (status=PROPOSED) or in-progress proposals awaiting code check (status=APPROVED or CODE_CHECK_PROPOSED).

The contract deployment workflow has drastically different expiration periods at different stages. Initial proposals expire after 72 hours (259,200 seconds): [2](#0-1) 

However, when a proposal is approved and transitions to the code check phase, the expiration time is updated to only 15 minutes (900 seconds): [3](#0-2) 

This update occurs in `ProposeContractCodeCheck`: [4](#0-3) 

The release methods verify that the proposer matches the caller. For approved contracts: [5](#0-4) 

And for code-checked contracts: [6](#0-5) 

After an attacker overwrites the proposal by calling `ProposeNewContract` with identical input, these checks prevent the legitimate proposer from completing their own proposal since the stored `Proposer` field now references the attacker's address.

**Attack Scenario:**
1. Alice calls `ProposeNewContract` → status=PROPOSED, proposer=Alice, expiry=72 hours
2. Governance approves → Alice calls `ReleaseApprovedContract` → status=APPROVED
3. Parliament calls `ProposeContractCodeCheck` → status=CODE_CHECK_PROPOSED, expiry=15 minutes
4. Network delays cause 15+ minutes to elapse
5. Bob calls `ProposeNewContract` with identical input → overwrites with proposer=Bob, status=PROPOSED
6. Alice attempts `ReleaseCodeCheckedContract` → fails due to proposer mismatch
7. Alice's governance work is permanently lost

The same vulnerability pattern exists in user contract proposals: [7](#0-6) 

## Impact Explanation

**Severity: Medium**

The vulnerability has significant operational impact:
- Legitimate proposers lose complete control after investing time and resources in governance approvals
- All governance progress (APPROVED → CODE_CHECK_PROPOSED) is nullified when status resets to PROPOSED
- The original proposer is permanently blocked from deployment due to proposer verification failures
- Attackers can repeatedly hijack proposals, creating indefinite denial of service
- Governance integrity is compromised as approved proposals can be nullified through timing attacks

The severity is Medium rather than High because:
- No direct fund theft or token supply manipulation occurs
- Primary impact is operational disruption rather than financial loss
- Attack requires specific timing (expiration window)
- System can recover through re-proposal, though with significant cost

## Likelihood Explanation

**Likelihood: High**

The attack is highly practical:
- **No special privileges required**: Any user can call `ProposeNewContract` or `ProposeUpdateContract`
- **Minimal attack cost**: Only transaction fees required
- **Easy execution**: Attacker monitors blockchain for expiring proposals and submits identical inputs
- **Short vulnerability window**: The 15-minute code check expiration is extremely short and easily exceeded in production environments
- **Common trigger conditions**: Network congestion, block production delays, or validator unavailability commonly cause governance processes to exceed 15 minutes

The existing test suite confirms re-proposing after expiration is intentional behavior, but only validates the case where proposals at PROPOSED status expire: [8](#0-7) 

This test does not cover the vulnerability scenario where APPROVED or CODE_CHECK_PROPOSED proposals expire and get hijacked.

## Recommendation

Add status validation to `RegisterContractProposingData()` to prevent overwriting proposals that have progressed beyond the initial PROPOSED state:

```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    
    // Only allow re-proposing if proposal doesn't exist OR 
    // (has expired AND never progressed beyond PROPOSED status)
    Assert(
        registered == null || 
        (Context.CurrentBlockTime >= registered.ExpiredTime && 
         registered.Status == ContractProposingInputStatus.Proposed), 
        "Already proposed."
    );
    
    var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
    State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
    {
        Proposer = Context.Sender,
        Status = ContractProposingInputStatus.Proposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
    };
}
```

Apply the same fix to `SendUserContractProposal()`.

## Proof of Concept

```csharp
[Fact]
public async Task ProposalHijacking_AfterCodeCheckExpiration_Test()
{
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };

    // Step 1: Alice proposes contract
    var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract), 
        contractDeploymentInput
    );
    proposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var proposalId = ProposalCreated.Parser
        .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    var proposedContractInputHash = ContractProposed.Parser
        .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
        .ProposedContractInputHash;

    // Step 2: Governance approves
    await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
    
    // Step 3: Alice releases approved contract (triggers code check with 15-min expiration)
    var releaseResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ReleaseApprovedContract),
        new ReleaseContractInput
        {
            ProposalId = proposalId,
            ProposedContractInputHash = proposedContractInputHash
        }
    );
    releaseResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var codeCheckProposalId = ProposalCreated.Parser
        .ParseFrom(releaseResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;

    // Step 4: Wait for code check expiration (15 minutes = 900 seconds)
    var currentTime = TimestampHelper.GetUtcNow();
    var expiredTime = currentTime.AddSeconds(901);
    
    // Step 5: Bob (attacker) hijacks by re-proposing same contract after expiration
    var attackerTester = Tester.CreateNewContractTester(AnotherMinerKeyPair);
    var hijackResult = await attackerTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput,
        expiredTime
    );
    
    // Attack succeeds - Bob can now overwrite Alice's proposal
    hijackResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 6: Alice tries to complete her code-checked proposal but is now blocked
    await ApproveWithMinersAsync(Tester, ParliamentAddress, codeCheckProposalId);
    
    var aliceReleaseResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ReleaseCodeCheckedContract),
        new ReleaseContractInput
        {
            ProposalId = codeCheckProposalId,
            ProposedContractInputHash = proposedContractInputHash
        }
    );
    
    // Alice is permanently blocked - proposer verification fails
    aliceReleaseResult.Status.ShouldBe(TransactionResultStatus.Failed);
    aliceReleaseResult.Error.ShouldContain("Invalid contract proposing status.");
}
```

## Notes

The vulnerability exploits the gap between intended and actual behavior. The system intends to allow re-proposing of stale proposals that never progressed, but the implementation incorrectly allows overwriting proposals at any status level after expiration. The 15-minute code check window makes this particularly exploitable in production environments where network conditions frequently cause delays.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-323)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L6-6)
```csharp
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L254-260)
```csharp
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod())
            },
            OriginProposer = proposedInfo.Proposer
        };

        proposedInfo.ExpiredTime = proposalCreationInput.ProposalInput.ExpiredTime;
        State.ContractProposingInputMap[proposedContractInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L280-283)
```csharp
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L296-299)
```csharp
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L276-314)
```csharp
    public async Task Propose_MultiTimes()
    {
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory, // test the default runner
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        var utcNow = TimestampHelper.GetUtcNow();
        // propose contract code
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow);
        proposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var proposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;
        proposalId.ShouldNotBeNull();
        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        var secondProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
        secondProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);

        var thirdProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(86399));
        thirdProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
        
        var byteResult = await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractProposalExpirationTimePeriod),
            new Empty());
        var expirationTimePeriod = Int32Value.Parser.ParseFrom(byteResult);
        
        var forthProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(expirationTimePeriod.Value));
        forthProposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```
