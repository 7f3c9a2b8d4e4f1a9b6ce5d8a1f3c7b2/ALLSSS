# Audit Report

## Title
NFT Protocol Creation Accepts Empty Address Values Leading to Permanent Protocol Bricking

## Summary
The NFT contract's `Create` method fails to validate that `input.Creator` has a non-empty `Address.Value` field, and the MultiToken contract's `RegisterTokenInfo` method only checks for null addresses without validating the `Value` field. This allows creation of NFT protocols with invalid empty-value issuer addresses, permanently bricking the protocol as no one can mint NFTs or manage the minter list.

## Finding Description

The vulnerability exists across two validation failures in the NFT creation flow:

**Insufficient Creator Validation in NFT Contract:**

The NFT `Create` method uses a null-coalescing operator that only checks if `input.Creator` is null, without validating whether the Address object has an empty `Value` field. [1](#0-0) 

When a caller passes an Address object with `Value = ByteString.Empty`, this is a non-null Address that bypasses the null check, setting `creator` to an invalid empty-value address. This invalid creator is then passed directly to the MultiToken contract as the `Issuer`. [2](#0-1) 

**Incomplete Validation in MultiToken Contract:**

The `RegisterTokenInfo` method only validates that the issuer is not null, but does not check if the `Address.Value` field is empty. [3](#0-2) 

This is inconsistent with the proper validation pattern used elsewhere in the same contract. For comparison, `ModifyTokenIssuerAndOwner` correctly validates both conditions: [4](#0-3) 

**Protocol Becomes Permanently Unusable:**

Once created with an empty-value issuer, the protocol cannot be used:

1. **Minting Fails**: The `GetMinterList` helper adds the empty-value issuer to the minter list: [5](#0-4) 

However, the minting permission check in `PerformMint` fails because `Context.Sender` (a valid address with non-empty Value) will never equal the empty-value address: [6](#0-5) 

2. **Minter Management Fails**: Both `AddMinters` and `RemoveMinters` methods require the caller to equal the protocol creator: [7](#0-6) [8](#0-7) 

This check will always fail for any real sender when the creator has an empty Value, as `Context.Sender` can never be an empty-value address.

## Impact Explanation

**Severity: High/Critical**

This vulnerability enables permanent denial-of-service attacks against NFT protocol functionality:

1. **Complete Protocol Bricking**: Any NFT protocol created with an empty-value creator becomes permanently unusable. No NFTs can ever be minted, and the minter list cannot be modified. The protocol is effectively dead on creation.

2. **Economic Damage**: 
   - Attackers can intentionally brick protocols, wasting the creation fees and seed NFTs paid by legitimate users
   - Front-running attacks are possible where attackers brick a symbol before legitimate creators can use it
   - Attackers can systematically squat on popular NFT symbol names or types

3. **No Recovery Mechanism**: The protocol creator address is immutably stored with no governance override available. The `ModifyTokenIssuerAndOwner` method cannot help because it requires `tokenInfo.Issuer == Context.Sender`, which can never be true when the issuer has an empty Value. There is no way to recover from this state.

4. **Permanent State Corruption**: The bricked protocol occupies the symbol namespace permanently, preventing legitimate use of that symbol.

## Likelihood Explanation

**Probability: High**

This vulnerability is highly exploitable:

1. **Reachable Entry Point**: The `Create` method is a public function callable by any user who can satisfy the access control requirements (seed NFT or whitelist membership).

2. **Low Attack Complexity**: Exploitation requires only constructing a `CreateInput` message with `Creator = new Address { Value = ByteString.Empty }`. This is trivial in any AElf transaction client.

3. **No Special Permissions Required**: The only access control is the standard seed NFT check or whitelist membership, which is necessary for any protocol creation. An attacker with legitimate access can exploit this.

4. **Low Attack Cost**: The cost is merely the NFT creation fee and seed NFT, making griefing attacks economically viable.

5. **Undetectable Until Too Late**: The protocol appears to be created successfully, with events fired normally. The vulnerability only manifests when users attempt to mint or manage minters, at which point the protocol is already permanently bricked.

## Recommendation

Add proper address validation in both contracts:

**In NFT Contract (`NFTContract_Create.cs`):**
```csharp
var creator = input.Creator ?? Context.Sender;
Assert(creator != null && !creator.Value.IsNullOrEmpty(), "Invalid creator address.");
```

**In MultiToken Contract (`TokenContract_Helper.cs`):**
```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
        "Invalid symbol.");
    Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
    Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
    Assert(tokenInfo.Issuer != null && !tokenInfo.Issuer.Value.IsNullOrEmpty(), "Invalid issuer address.");
    Assert(tokenInfo.Owner != null && !tokenInfo.Owner.Value.IsNullOrEmpty(), "Invalid owner address.");
    State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
    State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
}
```

This matches the validation pattern already used correctly in `ModifyTokenIssuerAndOwner`.

## Proof of Concept

```csharp
[Fact]
public async Task CreateNFTProtocol_WithEmptyValueCreator_ShouldBrickProtocol()
{
    // Arrange: Create empty-value address
    var emptyValueCreator = new Address { Value = ByteString.Empty };
    
    // Act: Create NFT protocol with empty-value creator
    var createInput = new CreateInput
    {
        NftType = "Art",
        ProtocolName = "Test Protocol",
        TotalSupply = 10000,
        Creator = emptyValueCreator, // Empty Value but not null
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF"),
        BaseUri = "ipfs://test"
    };
    
    // Protocol creation succeeds (but is bricked)
    var result = await NftContractStub.Create.SendAsync(createInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var symbol = result.Output.Value;
    
    // Verify protocol exists
    var protocolInfo = await NftContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    protocolInfo.Symbol.ShouldBe(symbol);
    protocolInfo.Creator.Value.ShouldBe(ByteString.Empty); // Creator has empty Value
    
    // Assert: Minting fails - no one can mint
    var mintInput = new MintInput
    {
        Symbol = symbol,
        Alias = "test",
        TokenId = 1,
        Metadata = new Metadata()
    };
    
    var mintResult = await NftContractStub.Mint.SendWithExceptionAsync(mintInput);
    mintResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    mintResult.TransactionResult.Error.ShouldContain("No permission to mint");
    
    // Assert: Minter management fails - no one can add minters
    var addMinterInput = new AddMintersInput
    {
        Symbol = symbol,
        MinterList = new MinterList { Value = { DefaultAddress } }
    };
    
    var addMinterResult = await NftContractStub.AddMinters.SendWithExceptionAsync(addMinterInput);
    addMinterResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    addMinterResult.TransactionResult.Error.ShouldContain("No permission");
}
```

## Notes

The vulnerability is confirmed by the inconsistency in validation patterns within the same codebase. The `ModifyTokenIssuerAndOwner` method demonstrates the correct validation approach using both `!= null` and `!.Value.IsNullOrEmpty()` checks, while `RegisterTokenInfo` only checks the former. This confirms that the developers were aware of the proper validation pattern but failed to apply it consistently across all address validation points.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L27-27)
```csharp
            Issuer = creator,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L230-230)
```csharp
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L646-647)
```csharp
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-338)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-358)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
