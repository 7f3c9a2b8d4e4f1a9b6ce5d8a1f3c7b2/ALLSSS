# Audit Report

## Title
DepositBalance Underflow Causes DoS in TokenConverter Sell Operations Due to VirtualBalance Accounting Mismatch

## Summary
The `Sell()` function calculates the amount of base token to return using a combined `VirtualBalance + DepositBalance` for Bancor pricing, but the subsequent accounting update only subtracts from `DepositBalance`. When the calculated return amount exceeds the available `DepositBalance`, the checked arithmetic in `SafeMath.Sub()` throws an `OverflowException`, causing transaction revert and denying service to legitimate sell operations.

## Finding Description

The vulnerability stems from an accounting mismatch in the TokenConverter contract's sell operation logic. The issue manifests in the following execution flow:

**Pricing Calculation Phase:**
The `Sell()` function retrieves the deposit account connector and calculates the amount to receive using the Bancor formula. [1](#0-0) 

The critical issue is in `GetSelfBalance()`, which for deposit account connectors with virtual balance enabled, returns the sum of `VirtualBalance` and the actual `DepositBalance`: [2](#0-1) 

For deposit accounts, the real balance is retrieved from `State.DepositBalance[connector.Symbol]`, and when `IsVirtualBalanceEnabled` is true, it adds the large `VirtualBalance` to this amount.

**Accounting Update Phase:**
However, when updating the state after the sell, the contract only subtracts from `DepositBalance`: [3](#0-2) 

**Checked Arithmetic Protection:**
The `SafeMath.Sub()` method uses checked arithmetic that throws `OverflowException` on underflow: [4](#0-3) 

**Root Cause Configuration:**
During economic system initialization, deposit account connectors are configured with `VirtualBalance = 10_000_000_00000000`: [5](#0-4) 

These connectors are created with virtual balance enabled: [6](#0-5) 

**Bancor Formula Behavior:**
With equal weights (0.005 for both connectors), the simplified Bancor formula becomes: [7](#0-6) 

This calculates: `amountToReceive = toConnectorBalance * paidAmount / (fromConnectorBalance + paidAmount)`

Where `toConnectorBalance = VirtualBalance + DepositBalance` (10M+ tokens), but only `DepositBalance` is actually available for subtraction.

**Attack Scenario:**
When the resource token balance in the contract is relatively low (e.g., 1,000 tokens) and a user attempts to sell a significant portion (e.g., 500 tokens), the Bancor formula calculates:
```
amountToReceive = (10_000_100_00000000) * 500_00000000 / (1000_00000000 + 500_00000000)
                ≈ 3_333_366_00000000
```

But if `DepositBalance = 100_00000000`, the operation `100_00000000.Sub(3_333_366_00000000)` triggers an underflow exception.

## Impact Explanation

**Severity: HIGH - Denial of Service**

The vulnerability breaks the core availability guarantee of the TokenConverter contract:

1. **User Fund Lockup**: Users holding resource tokens cannot convert them back to base tokens, effectively locking their funds temporarily until `DepositBalance` accumulates sufficiently through buy operations from other users.

2. **Market Inefficiency**: The Bancor automated market maker mechanism fails unpredictably based on internal accounting state (`DepositBalance`) rather than actual liquidity. Pricing indicates a valid trade, but execution fails.

3. **Protocol Availability**: Core token conversion functionality is denied even when:
   - The contract holds sufficient total base token balance
   - The Bancor pricing formula indicates valid market conditions
   - The user has sufficient resource tokens and proper approvals

4. **No Fund Loss**: Importantly, the checked arithmetic prevents silent state corruption - the transaction reverts rather than allowing negative balances or wraparound, limiting the severity to DoS rather than fund theft.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability is highly practical under realistic conditions:

**Default Configuration:**
- All deposit account connectors are initialized with `VirtualBalance = 10_000_000_00000000` by default
- This is not an edge case but the standard economic system configuration

**Triggering Conditions:**
1. **Early Lifecycle**: When `DepositBalance` is still small (e.g., < 1,000 ELF) relative to the 10M `VirtualBalance`
2. **Low Volume Pairs**: Connector pairs with low trading activity accumulate minimal `DepositBalance`
3. **Resource Token Depletion**: After users buy resource tokens, the remaining balance in the contract decreases, making the Bancor formula more sensitive

**No Privilege Requirements:**
- Any user can call `Sell()` without special permissions
- Only requires owning resource tokens and having approval set
- The vulnerability is inherent in the contract design, not dependent on attacker sophistication

**Practical Execution:**
With equal connector weights and typical values:
- If resource balance = 1,000 tokens
- User sells 500 tokens  
- Formula calculates ~3,333 ELF return
- DepositBalance only has 100 ELF → Immediate revert

**Detection:**
Transaction fails with `OverflowException`, making the issue immediately visible to users but still preventing legitimate operations.

## Recommendation

**Fix: Align accounting with pricing calculation**

The accounting update should be consistent with the balance used for pricing. Two potential solutions:

**Option 1: Track virtual balance separately in accounting**
When updating `DepositBalance`, also consider the virtual balance component:
```csharp
var totalBalance = toConnector.VirtualBalance + State.DepositBalance[toConnector.Symbol];
var remainingBalance = totalBalance.Sub(amountToReceive);

// Update only the real deposit balance
if (remainingBalance >= toConnector.VirtualBalance)
{
    State.DepositBalance[toConnector.Symbol] = remainingBalance.Sub(toConnector.VirtualBalance);
}
else
{
    Assert(false, "Insufficient deposit balance for sell operation");
}
```

**Option 2: Validate before subtraction**
Add explicit validation that the calculated amount doesn't exceed available deposit balance:
```csharp
Assert(amountToReceive <= State.DepositBalance[toConnector.Symbol], 
       "Calculated return amount exceeds available deposit balance");
       
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**Option 3: Use actual balance for pricing when insufficient**
Adjust `GetSelfBalance()` to return only actual balance when virtual balance would cause underflow:
```csharp
private long GetSelfBalance(Connector connector)
{
    long realBalance;
    if (connector.IsDepositAccount)
        realBalance = State.DepositBalance[connector.Symbol];
    else
        realBalance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput { Owner = Context.Self, Symbol = connector.Symbol }).Balance;

    // For sell operations, cap at real balance to prevent accounting underflow
    if (connector.IsVirtualBalanceEnabled && connector.IsDepositAccount)
    {
        // Add virtual balance for pricing, but ensure accounting consistency
        return connector.VirtualBalance.Add(realBalance);
    }
    
    return realBalance;
}
```

The recommended fix is **Option 1**, as it maintains the Bancor pricing mechanism while ensuring accounting consistency.

## Proof of Concept

A test demonstrating the vulnerability would follow this structure:

```csharp
[Fact]
public async Task Sell_DepositBalance_Underflow_DoS_Test()
{
    // Setup: Initialize TokenConverter with VirtualBalance = 10M
    await InitializeTokenConverterWithVirtualBalance();
    
    // Setup: Enable connector with small DepositBalance (100 ELF)
    await EnableConnectorWithSmallDeposit(depositAmount: 100_00000000);
    
    // Setup: Reduce resource token balance through previous operations
    await ReduceResourceTokenBalance(remainingBalance: 1000_00000000);
    
    // Attack: User attempts legitimate sell of 500 resource tokens
    var sellInput = new SellInput
    {
        Symbol = "WRITE",
        Amount = 500_00000000,
        ReceiveLimit = 0
    };
    
    // Expected: Transaction should succeed with valid Bancor pricing
    // Actual: Transaction reverts with OverflowException due to DepositBalance underflow
    var result = await TokenConverterStub.Sell.SendAsync(sellInput);
    
    // Verify: Transaction failed due to arithmetic overflow
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Overflow");
    
    // Impact: User cannot sell their resource tokens despite valid market conditions
    // The contract holds sufficient total base tokens but accounting mismatch causes DoS
}
```

The test would demonstrate that when `DepositBalance` is insufficient relative to the calculated `amountToReceive` (which includes `VirtualBalance` in the calculation), the sell operation fails with an overflow exception, preventing legitimate token conversions.

## Notes

This vulnerability represents a critical design flaw in the TokenConverter's balance accounting model. The use of `VirtualBalance` for bootstrapping liquidity is a valid economic design pattern, but the implementation incorrectly applies it to pricing calculations while excluding it from accounting updates. This creates a systematic DoS condition that affects all connector pairs during their early lifecycle or periods of low liquidity accumulation.

The severity is classified as HIGH because it directly impacts protocol availability and user access to their funds, though the checked arithmetic prevents fund loss or state corruption. The vulnerability is most severe during system initialization and gradually mitigates as `DepositBalance` accumulates through normal buy operations.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L166-172)
```csharp
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L240-249)
```csharp
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-49)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);
```
