# Audit Report

## Title
Referendum Organizations Can Be Permanently Bricked With Invalid Proposer Addresses

## Summary
The Referendum contract's organization validation fails to verify that addresses in the ProposerWhiteList contain valid (non-empty) ByteString values. An attacker can create organizations with whitelists containing only addresses with empty ByteString values, which pass validation but are permanently unusable since no valid proposer can create proposals and the whitelist cannot be modified without executing a proposal.

## Finding Description

The vulnerability exists in the organization validation logic during creation. When `CreateOrganization` is called, it validates the organization using the `Validate()` method [1](#0-0) , which checks whether the ProposerWhiteList is empty but never validates individual address validity [2](#0-1) .

The `Empty()` extension method only checks if the count is zero [3](#0-2) . This allows an attacker to add Address objects with `Value = ByteString.Empty` (protobuf3 default) to satisfy the non-empty requirement.

The ProposerWhiteList is defined as a repeated Address field [4](#0-3) , and Address itself is just a bytes wrapper [5](#0-4) .

When users attempt to create proposals, authorization is enforced via `AssertIsAuthorizedProposer` [6](#0-5) , which checks if the proposer exists in the whitelist using `Contains()` [7](#0-6) . This check uses protobuf equality comparison [8](#0-7) , where addresses with valid ByteString values will never equal addresses with empty ByteString values.

The recovery mechanism is blocked because `ChangeOrganizationProposerWhiteList` requires `Context.Sender` to be the organization address itself [9](#0-8) , which can only occur through virtual inline calls during proposal execution [10](#0-9) . Since no proposals can be created, the whitelist cannot be updated, permanently bricking the organization.

Notably, other contracts in the codebase implement proper address validation. The MultiToken contract validates addresses with `AssertValidInputAddress` that checks for null and empty values [11](#0-10) , but the Referendum contract lacks this validation for whitelist addresses.

## Impact Explanation

**Operational Impact - Permanent DoS:**
- Any user can create permanently unusable Referendum organizations at minimal gas cost
- Organization addresses are deterministic based on input parameters [12](#0-11) , allowing attackers to pre-occupy addresses that legitimate users intend to create
- Once created, organizations cannot be deleted or recovered (no deletion method exists in the contract)
- State bloat from accumulation of unusable organizations

**Governance Impact:**
- Complete DoS of Referendum governance functionality for affected organizations
- No admin override or recovery mechanism exists
- Violates the fundamental governance invariant that organizations with non-empty whitelists must allow authorized proposers to create proposals

The severity is **HIGH** because it enables permanent, unrecoverable DoS of critical governance infrastructure with minimal attack cost and no privileged access required.

## Likelihood Explanation

**Entry Point:** The `CreateOrganization` method is publicly accessible [13](#0-12) .

**Attack Feasibility:**
- In protobuf3 C#, creating an Address with empty ByteString is trivial: `new Address()` defaults to `Value = ByteString.Empty`
- The attacker constructs a `CreateOrganizationInput` with valid parameters except the ProposerWhiteList contains only invalid addresses
- Single transaction execution with standard gas cost
- No special permissions required

**Economic Rationality:**
- Attack cost: Only transaction gas fees (same as normal organization creation)
- Impact: Permanent bricking of organization functionality
- High impact-to-cost ratio makes this economically viable for griefing attacks

The likelihood is **HIGH** due to public accessibility, trivial execution, and minimal cost.

## Recommendation

Add address validation in the `Validate()` method to check that all addresses in the ProposerWhiteList have non-empty ByteString values. Implement validation similar to the MultiToken contract's `AssertValidInputAddress` method.

Suggested fix in `Referendum_Helper.cs`:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for each address in the whitelist
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithInvalidAddresses_ShouldBrickOrganization()
{
    // Create organization with invalid (empty) addresses in whitelist
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5000,
            MinimalVoteThreshold = 5000,
            MaximalAbstentionThreshold = 10000,
            MaximalRejectionThreshold = 10000
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { new Address() } // Empty ByteString address
        },
        TokenSymbol = "ELF"
    };
    
    // Organization creation succeeds (should fail but doesn't due to bug)
    var result = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var organizationAddress = result.Output;
    
    // Verify organization exists
    var organization = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress);
    organization.OrganizationAddress.ShouldBe(organizationAddress);
    
    // Try to create proposal with valid proposer address - should fail
    var createProposalInput = new CreateProposalInput
    {
        ToAddress = TokenContractAddress,
        Params = new CreateInput().ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = organizationAddress,
        ContractMethodName = "Create"
    };
    
    // This will fail because DefaultSender (valid address) doesn't match empty address
    var proposalResult = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
    proposalResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    proposalResult.TransactionResult.Error.ShouldContain("Unauthorized to propose");
    
    // Organization is permanently bricked - no proposals can be created
    // and whitelist cannot be changed without a proposal
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L55-55)
```csharp
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L169-171)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L207-219)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress = Context.ConvertVirtualAddressToContractAddressWithContractHashName(
            CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));

        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** protobuf/acs3.proto (L140-142)
```text
    // The address of the proposers
    repeated aelf.Address proposers = 1;
}
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```
