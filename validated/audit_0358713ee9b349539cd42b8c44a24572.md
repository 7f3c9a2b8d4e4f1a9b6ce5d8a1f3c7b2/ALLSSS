# Audit Report

## Title
Deterministic Collision Causes Infinite Loop DoS in NFT Protocol Creation Due to Broken Length Expansion Logic

## Summary
The NFT contract's symbol generation mechanism contains two critical flaws that combine to create a permanent DoS vulnerability. First, a mathematically broken length expansion check prevents the symbol number space from ever growing beyond 9 digits. Second, a deterministic collision loop causes infinite transaction hangs when duplicate numbers are generated, as the same hash is reused in collision detection without regeneration.

## Finding Description

The vulnerability manifests through two interconnected defects in the NFT contract's symbol generation:

**Component 1: Broken Length Expansion Logic**

The symbol number length is initialized to 9 digits [1](#0-0)  and attempts to expand when space is exhausted. The expansion check initializes a flag to `10^(length-1)` [2](#0-1)  and then checks if doubling this flag increases its digit count [3](#0-2) .

However, this condition can never be true. With length = 9:
- flag = 10^8 = 100,000,000
- flag × 2 = 200,000,000 (still 9 digits)
- Condition: `9 > 9` = FALSE

Mathematically, `2 × 10^(n-1)` always produces exactly n digits, never n+1, permanently capping the space at 900 million 9-digit numbers.

**Component 2: Deterministic Infinite Loop**

The `GenerateSymbolNumber()` method computes a single hash from the sender and consensus random bytes [4](#0-3)  before entering a collision-detection loop [5](#0-4) . 

Inside the do-while loop, the same unchanging hash is passed to `Context.ConvertHashToInt64()` which performs deterministic BigInteger modulo arithmetic [6](#0-5) . If a collision occurs (the number already exists in IsCreatedMap), the exact same number will be generated on every iteration, creating an infinite loop with no escape mechanism.

**Root Cause**: The code lacks mechanisms to (1) properly expand the number space beyond 9 digits, and (2) regenerate fresh randomness when collisions occur.

## Impact Explanation

This vulnerability causes **Critical-severity Denial of Service**:

**Operational Impact**: Once a collision occurs, any transaction calling the public `Create` method [7](#0-6)  will hang indefinitely in the collision loop. This completely blocks NFT protocol creation on the AELF mainchain [8](#0-7) .

**Probability Escalation**: With 900 million possible 9-digit numbers, collision probability follows the birthday paradox. After approximately 30,000-50,000 NFT protocols are created, collision probability becomes significant. The first collision triggers permanent DoS.

**No Recovery Mechanism**: The contract provides no administrative function to reset the symbol number space or clear collision states. Once triggered, the DoS is permanent unless the contract is replaced through governance.

**Ecosystem Impact**: All users attempting to create NFT protocols are affected. Since protocol creation is a foundational operation for the NFT ecosystem, this breaks core functionality.

## Likelihood Explanation

**High Likelihood** for the following reasons:

**Public Entry Point**: The vulnerability is accessible through the public `Create` method callable by any user without special privileges.

**Natural Trigger Through Normal Usage**: No attack is required. The vulnerability manifests naturally as more NFT protocols are created through legitimate operations. Each new protocol creation has a chance of hitting a collision.

**Deterministic Behavior**: The execution path is completely deterministic: User calls Create() → GetSymbol() calls GenerateSymbolNumber() [9](#0-8)  → Hash computed once, used repeatedly in loop → Collision → infinite loop with same inputs.

**Increasing Probability Over Time**: As the NFT ecosystem grows and more protocols are created, collision probability increases quadratically according to the birthday paradox formula, making the vulnerability inevitable given sufficient usage.

## Recommendation

Implement two critical fixes:

**Fix 1: Correct the length expansion logic**
Change the expansion condition to properly detect when the number space is exhausted. Instead of checking if `flag × 2` has more digits, track the actual count of created symbols and expand when approaching capacity (e.g., 90% full).

**Fix 2: Regenerate randomness on collision**
Move the hash computation inside the collision loop, generating fresh random bytes from the consensus contract on each iteration. Alternatively, increment a nonce and rehash on each collision attempt.

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    var nonce = 0;
    do
    {
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(nonce));
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        nonce++;
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

## Proof of Concept

A valid test demonstrating this vulnerability would:
1. Create approximately 30,000 NFT protocols to approach collision probability
2. Continue creating protocols until a collision occurs
3. Observe that the transaction hangs indefinitely without completing or reverting
4. Confirm that all subsequent Create() calls also hang

The test would require significant setup to reach collision probability and would demonstrate the transaction timeout/hang behavior when the deterministic collision occurs.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-77)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L96-100)
```csharp
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L103-104)
```csharp
        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```
