# Audit Report

## Title
Validation Bypass via Data Contamination Enables Last Irreversible Block (LIB) Manipulation

## Summary
The AEDPoS consensus validation logic contaminates trusted round state with untrusted block header data before performing validation checks. This causes the `LibInformationValidationProvider` to compare a value against itself, always passing validation. Malicious miners can exploit this to submit arbitrary `ImpliedIrreversibleBlockHeight` values, enabling LIB manipulation with control of ⅓+ miners.

## Finding Description

The vulnerability exists in the validation flow for `UpdateValue` consensus behavior. The contract retrieves trusted round state from storage, but then modifies this trusted data with untrusted input BEFORE running validation checks.

**Data Contamination Flow:**

The `ValidateBeforeExecution` method retrieves trusted state from storage [1](#0-0) , then immediately contaminates it by calling `RecoverFromUpdateValue` for UpdateValue behavior [2](#0-1) .

The `RecoverFromUpdateValue` method directly overwrites the trusted `ImpliedIrreversibleBlockHeight` with the untrusted value from the provided round [3](#0-2) .

After contamination, the validation context is created with the now-modified baseRound [4](#0-3) .

**Validation Bypass:**

The `LibInformationValidationProvider` attempts to validate that the implied irreversible block height hasn't regressed [5](#0-4) . However, since `baseRound` was just contaminated with the same value from `providedRound`, this check becomes `X > X`, which always evaluates to false, causing validation to always pass.

**Intended Behavior vs Exploit:**

The contract sets `ImpliedIrreversibleBlockHeight` to the current block height when generating consensus data [6](#0-5) . However, a malicious miner can modify this value in the block header before submission. The validation should reject values below the stored height, but fails due to the contamination bug.

**State Persistence:**

After bypassing validation, the malicious value is persisted to state [7](#0-6)  and the round information is updated [8](#0-7) .

**LIB Calculation:**

The persisted malicious values are used in LIB calculation [9](#0-8) . The `LastIrreversibleBlockHeightCalculator` collects sorted heights and selects the value at position `(count-1)/3` [10](#0-9) .

## Impact Explanation

**Critical Severity - Consensus Integrity Breach**

With control of ⅓+ miners (the threshold needed to influence LIB consensus), attackers can:

1. **Force LIB Regression**: Submit `ImpliedIrreversibleBlockHeight = 0` or values below current LIB. Example with 21 miners: 7 malicious miners submit height=0, 14 honest miners submit height=10000. Sorted array: [0,0,0,0,0,0,0,10000,...]. Position (21-1)/3=6 yields LIB=0, causing finality to regress.

2. **Finality DoS**: Consistently report low values to prevent LIB from advancing, blocking transaction finality indefinitely.

3. **Break Irreversibility Guarantees**: The core consensus invariant that LIB heights must be monotonically increasing is violated, undermining the fundamental security property of the blockchain.

**Affected Parties:**
- All network participants relying on block finality
- Cross-chain bridges and external systems using LIB for confirmation  
- Applications depending on irreversible transaction guarantees

## Likelihood Explanation

**High Probability**

**Attacker Capabilities:** Any authorized miner in the current round can exploit this vulnerability through normal block production flow.

**Attack Complexity:** Low - The exploit requires only:
1. Being an active miner (by design, not a privilege escalation)
2. Producing a block with `UpdateValue` behavior
3. Modifying `ImpliedIrreversibleBlockHeight` in consensus extra data before block submission
4. No complex state setup or preconditions required

**Feasibility:** The attack is deterministic and repeatable. The validation is called via the standard ACS4 interface [11](#0-10)  during block validation before execution, meaning every UpdateValue block goes through the vulnerable code path.

**Detection:** The bypassed validation means no error or event is raised, making detection difficult without external monitoring.

## Recommendation

Fix the data contamination by performing validation BEFORE modifying the trusted baseRound. The validation logic should compare the untrusted providedRound against the unmodified trusted baseRound from state:

1. Move the `RecoverFromUpdateValue` call to AFTER validation completes successfully
2. Pass both the original baseRound and providedRound separately to validation providers
3. Only apply the recovery/contamination after all validation checks pass

Corrected flow in `ValidateBeforeExecution`:
- Retrieve trusted baseRound from state
- Create validation context with UNMODIFIED baseRound
- Run all validation providers (including LibInformationValidationProvider)
- Only if validation succeeds, then call `RecoverFromUpdateValue` for processing

## Proof of Concept

The vulnerability can be demonstrated by:

1. A malicious miner producing an UpdateValue block
2. Setting `ImpliedIrreversibleBlockHeight` to an arbitrary low value (e.g., 0) in the block header consensus extra data
3. The validation will pass because baseRound is contaminated before the LibInformationValidationProvider check
4. The malicious value is persisted to state
5. With ⅓+ miners submitting similar values, the LIB calculation will yield the malicious height, causing finality regression

The proof requires integration testing with the full AElf node infrastructure to demonstrate block production and validation flow, as this is a consensus-level vulnerability that manifests during block validation before transaction execution.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-269)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```
