# Audit Report

## Title
Arithmetic Overflow in Profit Calculation Due to Unbounded Beneficiary Shares Value

## Summary
The Profit contract's `SafeCalculateProfits` method performs unchecked decimal multiplication that overflows when beneficiary shares approach `long.MaxValue` and profit amounts exceed ~8.6 billion base units. This causes `ClaimProfits` to fail with `OverflowException`, permanently locking beneficiaries' earned profits in the scheme's virtual address with no recovery mechanism.

## Finding Description

The vulnerability exists in the profit distribution calculation flow where three issues combine to create a critical failure:

**1. Missing Upper Bound Validation**

The `AssertValidInput` method only validates non-negativity of shares, with no maximum limit: [1](#0-0) 

This allows scheme managers to add beneficiaries with shares values up to `long.MaxValue` (9,223,372,036,854,775,807).

**2. Vulnerable Decimal Arithmetic**

The `SafeCalculateProfits` method performs multiplication before division without overflow protection: [2](#0-1) 

The operation `decimalTotalAmount * decimalShares` executes before dividing by `decimalTotalShares`. When the first parameter (shares) ≈ 9.2 × 10^18 and second parameter (amount) > 8.6 × 10^9, their product exceeds C# `decimal.MaxValue` (7.9 × 10^28), causing an immediate `OverflowException` since decimal arithmetic in C# has built-in overflow checking.

**3. Execution Path Through ClaimProfits**

When beneficiaries claim profits, the vulnerable calculation is invoked: [3](#0-2) 

Within `ClaimProfits`, the `ProfitAllPeriods` method is called, which at line 873 invokes `SafeCalculateProfits` with potentially overflowing values: [4](#0-3) 

**4. Additional Attack Vector via Sub-Schemes**

The vulnerability also affects profit distribution to sub-schemes: [5](#0-4) 

At line 621, when a sub-scheme is added with `SubSchemeShares = long.MaxValue`, the manager's attempt to distribute profits exceeding 8.6 billion will fail, preventing ANY profit distribution to ALL beneficiaries in the scheme.

**Authorization Context**

Only scheme managers or TokenHolder contract can add beneficiaries: [6](#0-5) 

However, profit contributions are unrestricted—anyone can contribute any amount: [7](#0-6) 

## Impact Explanation

**Direct Fund Lockup:** Beneficiaries with large share values cannot claim their legitimately earned profits. The `ClaimProfits` transaction throws `OverflowException` and reverts, leaving funds permanently locked in period-specific virtual addresses: [8](#0-7) 

**No Recovery Mechanism:** The `RemoveBeneficiary` method does not transfer unclaimed profits to beneficiaries: [9](#0-8) 

Profits remain locked in immutable virtual addresses with no administrative rescue function.

**Quantified Scenario:**
- Scheme manager adds beneficiary with `shares = long.MaxValue`
- Natural profit accumulation reaches 10 billion base units (100 ELF tokens with 8 decimals—realistic for staking rewards)
- Calculation: 9.2 × 10^18 × 10 × 10^9 = 9.2 × 10^28 > decimal.MaxValue (7.9 × 10^28)
- Result: All profits for affected periods become permanently unclaimable

**Affected Parties:**
1. **Individual Beneficiaries**: Direct financial loss, cannot access earned rewards
2. **Staking Participants**: If scheme distributes validator rewards, all stakers lose access to dividends
3. **Treasury Recipients**: DAO/protocol treasury distributions fail
4. **Cross-chain Operations**: Bridge reward schemes become inoperative

**Severity Assessment:** HIGH due to:
- Permanent, irrecoverable fund lockup
- Affects core economic incentive mechanisms (staking, treasury, dividends)
- No circuit breaker or recovery path
- Breaks fundamental protocol guarantee (claimable profits)

## Likelihood Explanation

**Attack Complexity:** Very Low
- Step 1: Manager creates scheme and adds beneficiary with large shares value (single transaction)
- Step 2: Wait for natural profit accumulation OR trigger via unrestricted `ContributeProfits`
- No sophisticated timing, oracle manipulation, or multi-block requirements needed

**Attacker Capabilities:** Minimal
- Requires only scheme manager role (obtainable by creating a scheme via `CreateScheme`, zero prerequisites)
- Anyone can contribute profits to trigger overflow condition via `ContributeProfits`
- No need for governance control, consensus participation, or special privileges

**Realistic Preconditions:**
AElf ecosystem commonly sees:
- Tokens with 8 decimals (ELF has 8 decimals)
- Staking rewards accumulating billions of base units in active validator pools
- Treasury contracts receiving transaction fees over time
- 10 billion base units = 100 ELF tokens—entirely realistic distribution amount for active schemes

**Natural Occurrence Probability:** MODERATE
- Legitimate schemes could accidentally set overly large shares values
- Active schemes naturally accumulate sufficient profit amounts
- No warning signs before overflow occurs
- View methods that calculate profits will also fail, preventing detection

**Economic Incentives:**
- Malicious manager: Zero cost to DoS competitor reward schemes
- Negligent manager: Accidental misconfiguration when attempting proportional shares logic
- Griefing: Attacker creates scheme, attracts deposits, then triggers lockup

**Detection Difficulty:** High
- No on-chain validation warns of approaching overflow threshold
- Off-chain monitoring would require complex analysis of shares × amounts across all periods
- First indication is when legitimate claim transactions start failing

## Recommendation

Add maximum bounds validation for shares values in `AssertValidInput`:

```csharp
private void AssertValidInput(AddBeneficiaryInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
    Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    
    // Add maximum validation to prevent overflow
    const long maxSafeShares = long.MaxValue / 10000; // Conservative limit
    Assert(input.BeneficiaryShare?.Shares <= maxSafeShares, 
        $"Shares value too large. Maximum allowed: {maxSafeShares}");
}
```

Additionally, refactor `SafeCalculateProfits` to perform division before multiplication or use checked arithmetic with proper error handling:

```csharp
private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
{
    if (totalShares == 0) return 0;
    
    // Perform division first to reduce overflow risk
    var baseAmount = totalAmount / totalShares;
    var remainder = totalAmount % totalShares;
    
    // Calculate proportional share with remainder handling
    var result = baseAmount * shares;
    result += (remainder * shares) / totalShares;
    
    return result;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_Overflow_With_MaxValue_Shares_Test()
{
    // Create a profit scheme
    var schemeId = await creator.CreateScheme.SendAsync(new CreateSchemeInput());
    
    // Add beneficiary with long.MaxValue shares (no validation prevents this)
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId.Output,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = receiver1, 
            Shares = long.MaxValue  // 9.2 × 10^18
        },
        EndPeriod = long.MaxValue
    });
    
    // Contribute 10 billion base units (100 ELF with 8 decimals)
    // This is realistic for staking rewards
    const long profitAmount = 10_000_000_000; // 10 billion base units
    
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Amount = profitAmount,
        Symbol = "ELF",
        Period = 0
    });
    
    // Distribute profits for period 1
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Period = 1,
        AmountsMap = { { "ELF", profitAmount } }
    });
    
    // Attempt to claim profits - THIS WILL THROW OverflowException
    // Calculation: (long.MaxValue * 10_000_000_000) exceeds decimal.MaxValue
    var claimResult = await receiver1.ClaimProfits.SendWithExceptionAsync(
        new ClaimProfitsInput
        {
            SchemeId = schemeId.Output,
            Beneficiary = receiver1
        });
    
    // Assert that overflow exception occurs
    claimResult.TransactionResult.Error.ShouldContain("OverflowException");
    
    // Verify funds are locked - balance remains in virtual address
    var virtualAddress = await creator.GetSchemeAddress.CallAsync(
        new SchemePeriod { SchemeId = schemeId.Output, Period = 1 });
    var lockedBalance = await tokenContract.GetBalance.CallAsync(
        new GetBalanceInput { Owner = virtualAddress, Symbol = "ELF" });
    
    lockedBalance.Balance.ShouldBe(profitAmount); // Funds permanently locked
}
```

**Notes:**
- The vulnerability affects both direct beneficiaries (via `ClaimProfits`) and sub-schemes (via `DistributeProfits`)
- C# decimal type has built-in overflow checking that cannot be disabled
- The threshold calculation: long.MaxValue (9.22×10^18) × 8.6×10^9 ≈ 7.93×10^28 > decimal.MaxValue (7.92×10^28)
- No recovery mechanism exists once funds are locked in period virtual addresses
- The attack requires minimal privileges and is economically viable

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-809)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }

        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```
