# Audit Report

## Title
Stale BlockHeight Bypass in SetTransactionFeeDelegations Allows Immediate Use of Updated Delegations

## Summary

The `SetTransactionFeeDelegations()` method fails to update the `BlockHeight` field when modifying existing delegation amounts. This bypasses the intended confirmation period security control that prevents same-block delegation usage, allowing delegatees to immediately use increased delegation limits without the required time delay.

## Finding Description

In AElf's fee delegation system, the `SetTransactionFeeDelegations()` method allows a delegatee to register to pay transaction fees on behalf of a delegator. The system includes a security control that requires a confirmation period before delegations can be used - this is enforced by comparing the transaction's `RefBlockNumber` against the delegation's `BlockHeight`.

The vulnerability exists in the update path of `SetTransactionFeeDelegations()`. When a NEW delegatee is added, the method correctly sets the BlockHeight: [1](#0-0) 

However, when an EXISTING delegatee updates their delegation amounts (the else branch starting at line 66), the BlockHeight field is never updated: [2](#0-1) 

The security check in `ChargeFromDelegations()` relies on this BlockHeight field to prevent same-block usage: [3](#0-2) 

This check compares the transaction's RefBlockNumber against the delegation's BlockHeight. If the BlockHeight is stale (not updated during delegation modification), the check incorrectly passes, allowing immediate delegation usage.

The newer `SetTransactionFeeDelegateInfos()` method demonstrates the correct behavior by updating BlockHeight for BOTH add and update operations: [4](#0-3) [5](#0-4) 

The protobuf documentation confirms BlockHeight should track "height when added": [6](#0-5) 

## Impact Explanation

This vulnerability bypasses a critical security control designed to prevent same-block manipulation of fee delegations. When a delegatee increases their delegation limits (e.g., from 100 ELF to 10,000 ELF), the stale BlockHeight allows them to use the increased amount immediately in the same block, without waiting for the intended confirmation period.

Example exploit scenario:
- Block 100: Delegation created with {ELF: 100}, BlockHeight = 100
- Block 500: Delegation updated to {ELF: 10,000}, BlockHeight remains 100 (bug)
- Block 500: Transaction with RefBlockNumber = 498 passes the check (498 >= 100), allowing immediate use of 10,000 ELF delegation

This enables:
1. **Atomicity exploitation**: Operations that should require multiple blocks can execute atomically
2. **Front-running scenarios**: Coordinated delegation update and usage in the same block
3. **Security inconsistency**: Different behavior between old and new delegation methods

While this doesn't directly steal funds, it undermines the time-based security control that exists to prevent manipulation and allow for monitoring/intervention between delegation setup and usage.

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily triggered through normal contract usage:

1. The method is publicly accessible as an RPC method
2. Any delegatee can call `SetTransactionFeeDelegations()` to update their existing delegation amounts
3. The updated delegation can be used immediately if the transaction's RefBlockNumber >= original BlockHeight
4. No special privileges or complex setup required

The inconsistency with `SetTransactionFeeDelegateInfos()` strongly indicates this is a bug rather than intentional design, as the newer method correctly updates BlockHeight in both add and update paths.

## Recommendation

Update the `SetTransactionFeeDelegations()` method to set `BlockHeight = Context.CurrentHeight` in the else branch when updating existing delegations, consistent with the behavior in `SetTransactionFeeDelegateInfos()`.

Add the following line after line 80 in the else branch:

```csharp
allDelegateesMap[delegateeAddress].BlockHeight = currentHeight;
```

This ensures the BlockHeight is always updated to reflect when the delegation was last modified, maintaining the intended security control.

## Proof of Concept

```csharp
[Fact]
public async Task SetTransactionFeeDelegations_StaleBlockHeight_Test()
{
    // Setup: Create initial delegation at block 100
    await Initialize();
    var initialDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 100
    };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations = { initialDelegations }
        });
    
    var firstDelegation = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput()
        {
            DelegateeAddress = DefaultAddress,
            DelegatorAddress = User1Address
        });
    var originalBlockHeight = firstDelegation.BlockHeight;
    
    // Advance blocks by mining several times
    await MineAsync(10);
    
    // Update delegation to higher amount
    var updatedDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 10000
    };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations = { updatedDelegations }
        });
    
    var updatedDelegation = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput()
        {
            DelegateeAddress = DefaultAddress,
            DelegatorAddress = User1Address
        });
    
    // BUG: BlockHeight should be updated but remains the same
    updatedDelegation.BlockHeight.ShouldBe(originalBlockHeight); // This assertion passes, proving the bug
    updatedDelegation.Delegations[NativeToken].ShouldBe(10000); // Amount is updated
    
    // The delegation can be used immediately because RefBlockNumber >= stale BlockHeight
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L54-54)
```csharp
                allDelegateesMap[delegateeAddress].BlockHeight = currentHeight;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L66-98)
```csharp
        else // This delegatee exists, so update
        {
            var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }

            // Set and Fire logEvent
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

            // If a delegatee has no delegations, remove it!
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
            Context.Fire(new TransactionFeeDelegationCancelled()
            {
                Caller = Context.Sender,
                Delegatee = Context.Sender,
                Delegator = input.DelegatorAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L253-270)
```csharp
    private DelegateTransaction AddDelegateInfo(TransactionFeeDelegations existDelegateeList, DelegateInfo delegateInfo)
    {
        if (!delegateInfo.IsUnlimitedDelegate)
        {
            foreach (var (symbol, amount) in delegateInfo.Delegations)
            {
                AssertValidToken(symbol, amount);
                existDelegateeList.Delegations[symbol] = amount;
            }
        }
        existDelegateeList.BlockHeight = Context.CurrentHeight;
        existDelegateeList.IsUnlimitedDelegate = delegateInfo.IsUnlimitedDelegate;
        return new DelegateTransaction
        {
            ContractAddress = delegateInfo.ContractAddress,
            MethodName = delegateInfo.MethodName
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L272-311)
```csharp
    private DelegateTransaction UpdateDelegateInfo(TransactionFeeDelegations existDelegateInfo, DelegateInfo delegateInfo)
    {
        var existDelegation = existDelegateInfo.Delegations;
        if (delegateInfo.IsUnlimitedDelegate)
        {
            existDelegation.Clear();
        }
        else
        {
            var delegation = delegateInfo.Delegations;
            foreach (var (symbol, amount) in delegation)
            {
                if (existDelegation.ContainsKey(symbol))
                {
                    if (amount <= 0)
                    {
                        existDelegation.Remove(symbol);
                    }
                    else
                    {
                        AssertValidToken(symbol, amount);
                        existDelegation[symbol] = amount;
                    }
                }
                else
                {
                    AssertValidToken(symbol, amount);
                    existDelegation[symbol] = amount;
                }
            }
        }

        existDelegateInfo.BlockHeight = Context.CurrentHeight;
        existDelegateInfo.IsUnlimitedDelegate = delegateInfo.IsUnlimitedDelegate;
        return new DelegateTransaction
        {
            ContractAddress = delegateInfo.ContractAddress,
            MethodName = delegateInfo.MethodName
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L186-186)
```csharp
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;
```

**File:** protobuf/token_contract.proto (L661-668)
```text
message TransactionFeeDelegations{
    // delegation, symbols and its' amount
    map<string, int64> delegations = 1;
    // height when added
    int64 block_height = 2;
    //Whether to pay transaction fee continuously
    bool isUnlimitedDelegate = 3;
}
```
