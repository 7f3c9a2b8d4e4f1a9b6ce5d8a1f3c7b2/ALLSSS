# Audit Report

## Title
Insufficient Address Validation in Governance Contracts Enables Griefing Attack via Unexecutable Proposals

## Summary
The Association, Parliament, and Referendum governance contracts fail to properly validate the `ToAddress` field of proposals. The validation only checks if the Address object reference is null, but does not verify that the internal `Value` byte array is non-empty. This allows whitelisted proposers to create proposals with empty addresses that pass all validation checks but fail during execution, causing approved proposals to become permanently stuck until expiry.

## Finding Description

The three governance contracts use an insufficient validation pattern that only checks if the Address object reference is null, without validating the internal `Value` property:

**Association Contract validation:** [1](#0-0) 

**Parliament Contract validation:** [2](#0-1) 

**Referendum Contract validation:** [3](#0-2) 

The proper validation pattern used elsewhere in the codebase checks both the object reference AND the internal Value: [4](#0-3) 

This same pattern is also used in contract deployment validation: [5](#0-4) 

The Address protobuf definition shows it contains a bytes value field that can be empty: [6](#0-5) 

When a proposal with an empty address value reaches the Release stage, the inline transaction is created: [7](#0-6) 

The `SendVirtualInlineBySystemContract` method simply adds the transaction to a list without immediate validation: [8](#0-7) 

When inline transactions are executed, any failure causes the parent transaction to fail: [9](#0-8) 

The inline transaction with an invalid address triggers a `SmartContractFindRegistrationException`: [10](#0-9) 

When the transaction fails, state changes are reverted and only pre/post traces are committed: [11](#0-10) 

This means the proposal removal never gets committed, leaving the proposal stuck in storage.

## Impact Explanation

This vulnerability creates a **governance denial-of-service** attack vector:

1. **Wasted Resources**: Organization members spend time and effort reviewing, voting on, and approving proposals that can never be executed
2. **Governance Disruption**: Critical governance decisions cannot be implemented even after proper approval
3. **Storage Waste**: Unexecutable proposals remain in storage until expiry (potentially days/weeks)
4. **Trust Erosion**: Repeated failures damage member confidence in the governance system
5. **Repeatability**: Any whitelisted proposer can create multiple such proposals

While the proposals can eventually be cleared after expiry using the `ClearProposal` method, the temporary DoS and wasted effort constitute significant operational impact on governance processes.

The severity is **Medium** because while it doesn't result in direct fund loss, it significantly disrupts critical governance operations and can be systematically exploited by malicious proposers.

## Likelihood Explanation

The attack is highly feasible:

1. **Attacker Profile**: Any whitelisted proposer can execute this attack. In multi-organization ecosystems, whitelist membership is common and realistic
2. **Technical Complexity**: Trivial - simply create a proposal with an Address object that has an empty Value property (e.g., `new Address()` or `new Address { Value = ByteString.Empty }`)
3. **Preconditions**: None beyond being a whitelisted proposer
4. **Detection**: Difficult to detect before Release execution since validation passes at both creation and release stages
5. **Cost**: Only requires transaction fees for proposal creation

The likelihood is **Medium** due to the realistic attacker profile and low execution complexity.

## Recommendation

Update the validation method in all three governance contracts to check both the Address object reference and its internal Value property:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || proposal.ToAddress.Value.IsNullOrEmpty() || 
        string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;
    
    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

This brings the validation in line with the pattern already used in BasicContractZero and TokenContract.

## Proof of Concept

```csharp
[Fact]
public async Task CreateProposal_WithEmptyAddress_ShouldFail()
{
    // Create organization with whitelisted proposer
    var organizationAddress = await CreateOrganizationAsync();
    
    // Create proposal with empty Address
    var createProposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = new Address(), // Empty Value property
        ContractMethodName = "SomeMethod",
        Params = ByteString.Empty,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    
    // This should fail but currently passes validation
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(createProposalInput);
    proposalId.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Vote and approve the proposal
    await ApproveProposalAsync(proposalId.Output);
    
    // Attempt to release - this will fail with inline transaction error
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid contract address");
    
    // Verify proposal is still in storage (not removed)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ProposalId.ShouldBe(proposalId.Output);
}
```

## Notes

This vulnerability affects all three AElf governance contract types (Association, Parliament, and Referendum) equally. The fix should be applied consistently across all three contracts to maintain uniform security standards. The validation gap exists because the contracts check only object nullability rather than the semantic validity of the Address value, which is a common pattern mistake when working with protobuf message types that have default values.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L397-399)
```csharp
        Assert(contractOperation.Deployer != null && !contractOperation.Deployer.Value.IsNullOrEmpty(),
            "Invalid input deploying address.");
        Assert(contractOperation.Salt != null && !contractOperation.Salt.Value.IsNullOrEmpty(), "Invalid input salt.");
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L110-118)
```csharp
        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L152-161)
```csharp
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L236-243)
```csharp
            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;
```
