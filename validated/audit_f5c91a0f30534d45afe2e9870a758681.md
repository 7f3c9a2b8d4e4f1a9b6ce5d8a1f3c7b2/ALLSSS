# Audit Report

## Title
Unsafe `.Single()` Call in TokenHolder RemoveBeneficiary Causing Denial of Service

## Summary
The `RemoveBeneficiary` function in TokenHolderContract unconditionally calls `.Single()` on the beneficiary's profit details list without validating the collection size. This causes transaction reversion when a beneficiary has either zero details (after claiming all expired profits) or multiple details (after partial removal operations), permanently blocking the scheme manager's ability to remove beneficiaries.

## Finding Description

The core vulnerability resides in `TokenHolderContract.RemoveBeneficiary` where it retrieves profit details and directly calls `.Single()` without validation: [1](#0-0) 

The LINQ `.Single()` method throws `InvalidOperationException` in two distinct scenarios:
1. Empty sequence: "Sequence contains no elements"
2. Multiple elements: "Sequence contains more than one element"

**Scenario 1: Empty Details After ClaimProfits**

When beneficiaries claim all available profits, `ProfitContract.ClaimProfits` identifies expired profit details (where `LastProfitPeriod > EndPeriod`) and removes them from the beneficiary's profit details: [2](#0-1) 

After all details are expired and removed, the state is updated with an empty `Details` collection. The `GetProfitDetails` view method simply returns this state: [3](#0-2) 

When `RemoveBeneficiary` subsequently retrieves these details, the returned `ProfitDetails` has an empty `Details` list, causing `.Single()` to throw an exception.

**Scenario 2: Multiple Details After Partial Removal**

The test case `RemoveBeneficiary_With_Amount_Test` explicitly demonstrates that partial beneficiary removal creates multiple profit details: [4](#0-3) 

After calling `RemoveBeneficiary` with a partial amount, the beneficiary has 2 profit details. This occurs because:

1. `ProfitContract.RemoveProfitDetails` marks the old detail as `IsWeightRemoved = true` but may not physically remove it from the list if `LastProfitPeriod < CurrentPeriod`: [5](#0-4) 

2. `TokenHolderContract.RemoveBeneficiary` then adds a new detail with reduced shares: [6](#0-5) 

The root cause is the mismatch between TokenHolder's scheme configuration and implementation assumptions. The scheme is created with `CanRemoveBeneficiaryDirectly = true`: [7](#0-6) 

However, the `RemoveBeneficiary` implementation incorrectly assumes exactly one profit detail will always exist, which normal operations violate.

## Impact Explanation

**Operational Denial of Service:**
- Scheme managers permanently lose the ability to remove beneficiaries through TokenHolder contract
- Critical administrative function for scheme lifecycle management is irreversibly blocked
- Beneficiaries remain in `ProfitDetailsMap` state indefinitely despite having zero effective shares
- Inability to clean up inactive participants leads to progressive state bloat
- Gas is wasted on repeatedly failing `RemoveBeneficiary` attempts

**Affected Parties:**
- Scheme managers requiring beneficiary removal for administrative operations
- TokenHolder profit schemes needing proper lifecycle management  
- Protocol operational efficiency and on-chain state hygiene

**Severity: Medium**

While this vulnerability does not directly compromise funds or enable theft, it permanently disables a fundamental administrative capability. The beneficiary with empty details has zero effective shares, so profit distribution calculations are unaffected. However, the complete inability to maintain clean scheme state represents a significant operational failure that impacts protocol maintainability.

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be a registered beneficiary (legitimate participant role)
- Must have expired profit details (naturally occurs in normal operation after claiming all periods)
- Only requires calling the public `ClaimProfits` function
- No special privileges, front-running, or complex setup required

**Execution Simplicity:**
- Single legitimate function call to `ClaimProfits` or partial `RemoveBeneficiary`
- Can be executed defensively without timing constraints
- `ClaimProfits` is a standard operation beneficiaries perform regularly as intended functionality
- Works through normal contract interaction without front-running or MEV

**Precondition Feasibility:**
- Expired details (`LastProfitPeriod > EndPeriod`) occur naturally when beneficiaries claim all available periods
- Common in long-running schemes where participants remain active across multiple distribution periods
- Partial removals are legitimate use cases for gradual share reduction
- These scenarios are standard operational flows, not exceptional edge cases

**Economic Rationality:**
- Cost: Only gas for one `ClaimProfits` transaction (normal operation cost)
- Benefit: Prevents removal from scheme (even with zero shares, potential future re-addition benefit)
- No economic penalty for executing legitimate `ClaimProfits`
- May be rational for beneficiaries anticipating future scheme participation

**Probability: High**

The combination of minimal execution complexity, naturally occurring preconditions through normal operations, and legitimate-looking actions makes this vulnerability highly likely to manifest in production environments, either accidentally through regular usage or deliberately by beneficiaries resistant to removal.

## Recommendation

Replace the unsafe `.Single()` call with safe collection handling that validates list size and handles both empty and multiple-element cases appropriately:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);

    var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    });
    
    // Validate that profit details exist and are non-empty
    Assert(profitDetails != null && profitDetails.Details.Any(), 
        "Beneficiary has no active profit details.");
    
    // For schemes with CanRemoveBeneficiaryDirectly, sum all shares if multiple details exist
    var lockedAmount = profitDetails.Details.Sum(d => d.Shares);
    
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    
    if (lockedAmount > input.Amount &&
        input.Amount != 0)
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = lockedAmount.Sub(input.Amount)
            }
        });

    return new Empty();
}
```

Additionally, consider similar validation in `AddBeneficiary` at line 55 which also uses `.Single()` on a potentially multi-element collection.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_DoS_After_ClaimProfits_Test()
{
    // Setup: Create scheme and add beneficiary with shares
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 10000
    });
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Shares = 100
    });
    
    // Distribute profits for one period
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = Starter,
        AmountsMap = { { "ELF", 0L } }
    });
    
    // Beneficiary claims all profits (removes expired details, leaving empty list)
    var userStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    await userStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = Starter
    });
    
    // Verify details list is now empty
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            SchemeId = schemeIds.SchemeIds[0],
            Beneficiary = UserAddresses.First()
        });
    profitDetails.Details.Count.ShouldBe(0); // Empty list
    
    // Manager attempts to remove beneficiary - should fail with InvalidOperationException
    var removeResult = await TokenHolderContractStub.RemoveBeneficiary.SendWithExceptionAsync(
        new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First()
        });
    
    // Verify DoS: transaction reverts due to .Single() on empty collection
    removeResult.TransactionResult.Error.ShouldContain("Sequence contains no elements");
}
```

## Notes

This vulnerability affects the operational integrity of TokenHolder profit schemes by blocking critical administrative functions. While it does not directly impact fund security or profit distributions (beneficiaries with empty details have zero shares), the inability to maintain clean scheme state represents a significant protocol degradation. The issue is particularly concerning because it can occur through entirely legitimate user behavior (claiming profits) without any malicious intent, making it a high-probability operational failure rather than just a theoretical attack vector.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L85-95)
```csharp
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L340-356)
```csharp
        if (detailsCanBeRemoved.Any())
        {
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-806)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L187-196)
```csharp
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
