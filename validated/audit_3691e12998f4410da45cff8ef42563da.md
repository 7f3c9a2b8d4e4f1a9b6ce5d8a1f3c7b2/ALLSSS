# Audit Report

## Title
Duplicate Mining Order Validation Bypass Allows Consensus Schedule Corruption

## Summary
The `NextRoundMiningOrderValidationProvider` validation logic incorrectly applies `.Distinct()` to miner objects instead of their `FinalOrderOfNextRound` values, allowing any consensus miner to provide next-round data where multiple miners share the same mining order. This breaks the fundamental consensus invariant of unique order assignments and causes unpredictable behavior in critical mining schedule logic.

## Finding Description

The validation provider performs a flawed uniqueness check on mining orders. [1](#0-0) 

The root cause is that `.Distinct()` operates on `MinerInRound` objects from `RealTimeMinersInformation.Values`, which is a dictionary's value collection. Since dictionary values are already distinct object instances by definition (each miner has a unique pubkey as the key), this check becomes meaningless for detecting duplicate `FinalOrderOfNextRound` integer values. Two miners with identical order values but different pubkeys are considered distinct objects, allowing the validation to pass.

**Execution Path:**

1. Any miner in the consensus set calls the public `NextRound` method [2](#0-1) 

2. The only permission check verifies the sender is in the current or previous miner list [3](#0-2) 

3. For `NextRound` behavior, the validation pipeline includes `NextRoundMiningOrderValidationProvider` [4](#0-3) 

4. Malicious `NextRoundInput` with duplicate orders passes the flawed validation

5. Invalid round data is stored directly via `AddRoundInformation(nextRound)` [5](#0-4) 

6. The provided round becomes authoritative consensus state, with the `ProvidedRound` from consensus header extra data [6](#0-5) 

**Attack Vector:**

A malicious miner crafts a `NextRoundInput` message where `RealTimeMinersInformation` contains miners with duplicate `FinalOrderOfNextRound` values. [7](#0-6) 

For example, setting both Miner A and Miner B to have `FinalOrderOfNextRound = 1` while maintaining correct total counts passes validation since the distinct count of miner objects equals the count of miners who produced blocks.

## Impact Explanation

**Critical Consensus Functions Break:**

1. **BreakContinuousMining Logic Failure:** The logic uses `.First(i => i.Order == X)` to locate specific miners by order [8](#0-7) . With duplicate orders, this returns an arbitrary miner from those sharing the order, causing incorrect miner swapping and allowing continuous mining that should be prevented.

2. **Extra Block Producer Selection:** The extra block producer is selected using `.FirstOrDefault(m => m.Order == extraBlockProducerOrder)` [9](#0-8) . With duplicates, the wrong miner may be selected as extra block producer.

3. **Mining Interval Calculation Corruption:** The interval calculation selects miners with Order 1 or Order 2 to compute time differences [10](#0-9) . If multiple miners have Order=1, the list may contain two Order=1 miners instead of one Order=1 and one Order=2, resulting in incorrect interval (potentially 0ms).

4. **Order Gap Creation:** The logic determines available orders by excluding occupied ones [11](#0-10) . Duplicate orders in `occupiedOrders` cause `ableOrders` to miss valid positions, creating sequence gaps (e.g., [1, 1, 3, 4, 5] leaves no order 2).

**Severity Assessment:**
- **High Impact:** Violates the critical "unique mining order per miner" consensus invariant
- **Network-Wide:** All nodes experience consensus disruption from corrupted schedule
- **Liveness Risk:** Can degrade or halt chain progress through unpredictable mining behavior
- **Difficult Detection:** Invalid state persists until consensus anomalies become apparent

## Likelihood Explanation

**Attacker Profile:**
Any active miner in the consensus set can execute this attack. The only requirement is being in the current or previous round's miner list, which is a normal operational requirement.

**Attack Complexity:**
Low - The attacker simply crafts a `NextRoundInput` message with duplicate `FinalOrderOfNextRound` values while maintaining:
- Correct count of miners with assigned orders
- Valid time intervals to pass other validation checks
- Proper round structure

**Execution Feasibility:**
- **Permission:** Any miner has access when it's their turn to call `NextRound`
- **Cost:** Zero additional cost beyond normal NextRound transaction gas
- **Repeatability:** Can be executed repeatedly in different rounds
- **Detection:** No immediate detection mechanism exists

**Economic Rationality:**
A malicious miner can gain strategic advantage by:
- Disrupting competitor mining schedules
- Creating time slot conflicts
- Forcing consensus anomalies that benefit their position

**Probability:** High - Simple exploit, no special privileges needed beyond being a miner, low technical barrier.

## Recommendation

Fix the validation logic to check uniqueness of the `FinalOrderOfNextRound` values themselves, not the miner objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select the order values
    .Distinct()
    .Count();
```

Additionally, consider adding explicit validation that:
1. All order values form a contiguous sequence from 1 to N (where N is the number of mining miners)
2. No gaps exist in the order sequence
3. Each order value appears exactly once

## Proof of Concept

```csharp
// Test demonstrating the validation bypass
[Fact]
public async Task DuplicateOrderValidationBypass_Test()
{
    // Setup: Create round with 3 miners
    var round = GenerateTestRound(3);
    
    // Malicious input: Set two miners to have the same FinalOrderOfNextRound
    var miners = round.RealTimeMinersInformation.Values.ToList();
    miners[0].FinalOrderOfNextRound = 1;
    miners[0].OutValue = Hash.FromString("out1");
    miners[1].FinalOrderOfNextRound = 1;  // DUPLICATE!
    miners[1].OutValue = Hash.FromString("out2");
    miners[2].FinalOrderOfNextRound = 3;  // Gap - no order 2
    miners[2].OutValue = Hash.FromString("out3");
    
    // Create validation context
    var validationContext = new ConsensusValidationContext
    {
        ProvidedRound = round,
        BaseRound = round
    };
    
    // Execute validation
    var provider = new NextRoundMiningOrderValidationProvider();
    var result = provider.ValidateHeaderInformation(validationContext);
    
    // VULNERABILITY: Validation passes despite duplicate orders
    Assert.True(result.Success);  // This should FAIL but passes
    
    // Demonstrate impact: GetMiningInterval returns incorrect value
    var interval = round.GetMiningInterval();
    // With duplicate Order=1, may select two miners with same order
    // resulting in interval of 0 instead of proper interval
}
```

## Notes

This vulnerability represents a fundamental flaw in consensus schedule integrity validation. The issue is not merely theoretical - it directly enables any consensus miner to corrupt the mining order assignment, which is a core invariant of the AEDPoS consensus mechanism. The impact cascades through multiple critical functions that assume order uniqueness, making this a high-severity consensus integrity issue.

The fix requires changing a single line in the validation logic, but the consequences of the current implementation are severe for network stability and consensus correctness.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-66)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```
