# Audit Report

## Title
Unvalidated LIB Height/Round Correspondence in NextRound and NextTerm Transitions Enables State Corruption

## Summary
The AEDPoS consensus contract only validates Last Irreversible Block (LIB) information for `UpdateValue` behavior, not for `NextRound` or `NextTerm` behaviors. A malicious miner can inject mismatched `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` pairs during round/term transitions, corrupting consensus state and triggering false Abnormal/Severe blockchain status that severely restricts block production.

## Finding Description

The vulnerability stems from inconsistent validation of LIB values across different consensus behaviors. The validation logic for consensus operations is defined in `ValidateBeforeExecution`, which applies different validation providers based on the consensus behavior type. [1](#0-0) 

For `UpdateValue` behavior, the `LibInformationValidationProvider` is explicitly added to validate that LIB values do not regress. This validator ensures that both `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` cannot decrease from their previous values. [2](#0-1) 

However, for `NextRound` and `NextTerm` behaviors, only different validators are applied: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` only checks mining order correctness: [4](#0-3) 

The `RoundTerminateValidationProvider` only validates round/term number increments and InValue nullness: [5](#0-4) 

Critically, **there is no validation that `ConfirmedIrreversibleBlockRoundNumber` corresponds to the actual round at `ConfirmedIrreversibleBlockHeight`**.

For `UpdateValue`, LIB values are recalculated using the `LastIrreversibleBlockHeightCalculator`: [6](#0-5) 

In contrast, for `NextRound`, the provided LIB values from the input are preserved through the `ToRound()` conversion: [7](#0-6) [8](#0-7) 

These values are then stored directly to state: [9](#0-8) [10](#0-9) 

The same pattern applies to `NextTerm`: [11](#0-10) [12](#0-11) [13](#0-12) 

The attack path requires the attacker to be a miner in the validator set. Since `MiningPermissionValidationProvider` only checks miner list membership, any miner can call these methods: [14](#0-13) 

Both `NextRound` and `NextTerm` are public methods: [15](#0-14) [16](#0-15) 

## Impact Explanation

**Operational DoS Impact**: The corrupted LIB round number directly affects `GetMaximumBlocksCount`, which reads `ConfirmedIrreversibleBlockRoundNumber` from the current round: [17](#0-16) 

The `BlockchainMiningStatusEvaluator` uses this value to determine blockchain status: [18](#0-17) 

By providing an artificially low round number (e.g., 1 instead of 50), the system calculates a large difference between `currentRoundNumber` and `libRoundNumber`. When this difference exceeds the severe status threshold, the blockchain enters Severe status, which limits all miners to producing only 1 block each and fires the `IrreversibleBlockHeightUnacceptable` event: [19](#0-18) 

This severely restricts blockchain throughput and can trigger emergency chain rollback procedures.

**Persistence**: The corrupted LIB values propagate to all subsequent rounds because `GenerateNextRoundInformation` copies both fields from the current round to the next round: [20](#0-19) 

The corruption persists until manually corrected through governance intervention or a properly constructed NextRound block with correct values.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be a legitimate miner in the validator set. Any miner can call `NextRound` or `NextTerm` as the validation only checks miner list membership, not specific extra block producer status.

**Attack Complexity**: Low. The attacker can obtain current round information through public view methods, manually construct a `NextRoundInput` or `NextTermInput` with modified `ConfirmedIrreversibleBlockRoundNumber` values (keeping `ConfirmedIrreversibleBlockHeight` correct), and submit it through the public entry points. The validation logic does not prevent this attack vector.

**Detection**: The attack manifests when the blockchain enters false Abnormal/Severe status, miners notice incorrect LIB values, or operations dependent on accurate LIB information (such as cross-chain indexing) begin to fail. However, by the time detection occurs, the corruption has already been stored to state and requires corrective action.

## Recommendation

Apply `LibInformationValidationProvider` to `NextRound` and `NextTerm` behaviors in addition to `UpdateValue`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

Additionally, consider implementing semantic validation that verifies `ConfirmedIrreversibleBlockRoundNumber` actually corresponds to the round number at `ConfirmedIrreversibleBlockHeight` by checking historical round information.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_InjectsInvalidLIBRoundNumber_TriggeresSevereStatus()
{
    // Setup: Initialize consensus with normal miners
    await InitializeConsensusAsync();
    
    // Advance to round 50 with correct LIB tracking
    for (int i = 2; i <= 50; i++)
    {
        await AdvanceToNextRoundAsync();
    }
    
    var currentRound = await GetCurrentRoundAsync();
    Assert.Equal(50, currentRound.RoundNumber);
    Assert.Equal(48, currentRound.ConfirmedIrreversibleBlockRoundNumber); // Normal: R-2
    
    // Attack: Malicious miner constructs NextRoundInput with corrupted LIB round number
    var maliciousNextRound = GenerateNextRoundInput(currentRound);
    maliciousNextRound.ConfirmedIrreversibleBlockRoundNumber = 1; // Artificially low
    maliciousNextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight; // Keep height correct
    
    // Execute: Malicious miner calls NextRound with corrupted values
    var result = await MaliciousMinerExecuteAsync(maliciousNextRound);
    Assert.True(result.Success); // Should pass validation but shouldn't
    
    // Verify: Corrupted LIB round number is stored
    var corruptedRound = await GetCurrentRoundAsync();
    Assert.Equal(51, corruptedRound.RoundNumber);
    Assert.Equal(1, corruptedRound.ConfirmedIrreversibleBlockRoundNumber); // Corruption persisted
    
    // Verify: GetMaximumBlocksCount triggers Severe status
    var maxBlocks = await GetMaximumBlocksCountAsync();
    Assert.Equal(1, maxBlocks); // Severe status: only 1 block allowed
    
    // Verify: IrreversibleBlockHeightUnacceptable event fired
    var events = await GetEventsAsync<IrreversibleBlockHeightUnacceptable>();
    Assert.NotEmpty(events);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-20)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L11-21)
```csharp
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-46)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L196-196)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-36)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
