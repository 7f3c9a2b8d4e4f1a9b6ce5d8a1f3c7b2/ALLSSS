# Audit Report

## Title
RemoveNFTType Breaks Cross-Chain Protocol Creation for Existing NFT Protocols

## Summary
The `RemoveNFTType()` function removes NFT type mappings without verifying whether existing protocols depend on those types. When protocols attempt cross-chain synchronization via `CrossChainCreate()`, the operation fails permanently if their type mapping has been removed, causing operational DoS of critical cross-chain NFT functionality.

## Finding Description

The vulnerability exists in the `RemoveNFTType()` function which removes NFT type mappings from state without any usage validation. [1](#0-0) 

The function only validates that the sender is the Parliament default organization, the short name length is 2 characters, and that the type exists. It then removes entries from both `NFTTypeFullNameMap` and `NFTTypeShortNameMap` without checking if any protocols currently use that type.

**Root Cause**: The contract stores protocols in a `MappedState<string, NFTProtocolInfo>` structure which does not support enumeration. [2](#0-1) 

Without the ability to iterate through all protocols, there is no mechanism to verify whether a type is actively in use before removing it. This was confirmed through codebase analysis showing that `MappedState` in AElf does not provide enumeration capabilities - entries can only be accessed by key lookup.

**Execution Path**: When `CrossChainCreate()` attempts to synchronize a protocol to a sidechain, it extracts the 2-character short name from the protocol symbol and performs a lookup in `NFTTypeFullNameMap`. [3](#0-2) 

If the type has been removed, the lookup returns `null` and throws an `AssertionException` with the message "Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.", permanently preventing the protocol from being created on any sidechain until Parliament re-adds the type mapping.

**Security Guarantee Broken**: The cross-chain protocol creation flow requires NFT type mappings to be available for all existing protocol symbols. Removing a type breaks this guarantee for all protocols using that type, violating the cross-chain operational integrity invariant.

## Impact Explanation

**Operational DoS**: All NFT protocols created on the mainchain with a removed type cannot be synchronized to sidechains. This breaks the cross-chain NFT protocol creation flow, which is a core feature of the AElf multi-chain ecosystem.

**Affected Parties**:
- Protocol creators who cannot expand their NFT collections to sidechains
- Users who cannot access NFT protocols on sidechains where they were expected
- The entire cross-chain NFT ecosystem functionality

**Severity: HIGH** - While existing protocols on already-synchronized chains continue functioning (they store their own `NftType` value locally in the protocol info), any protocol not yet created on a sidechain becomes permanently unable to synchronize until Parliament re-adds the type. This causes downtime, operational disruption, and potential confusion if different mappings are used during recovery. The impact is severe because it affects a critical cross-chain operation that users depend on for multi-chain NFT functionality.

## Likelihood Explanation

**Required Authorization**: Requires Parliament default organization authorization to call `RemoveNFTType()`. [4](#0-3) 

**Feasibility: MEDIUM** - This is not a traditional "attack" but rather a governance action with severe unintended consequences. Parliament could legitimately vote to remove a type they believe is unused (perhaps to clean up deprecated types or reorganize the type system), completely unaware that protocols on the mainchain depend on it for cross-chain synchronization. 

The lack of visibility into which types are actively used by existing protocols makes accidental removal realistic during protocol maintenance or type system reorganization. The technical complexity is LOW (single governance proposal and execution), but the scenario requires a governance mistake rather than malicious intent. Given that there are no enumeration mechanisms to verify type usage and no warnings or checks in the removal function, such a mistake is plausible during routine governance operations.

## Recommendation

Add usage validation to the `RemoveNFTType()` function. Since `MappedState` doesn't support enumeration, consider one of these approaches:

1. **Maintain a usage counter**: Track the number of protocols using each NFT type when protocols are created, and only allow removal when the counter is zero.

2. **Deprecation instead of removal**: Change `RemoveNFTType()` to mark types as deprecated rather than removing them, preventing new protocol creation with that type while maintaining cross-chain compatibility for existing protocols.

3. **Add a protocol symbol list**: Maintain a separate state structure that tracks all protocol symbols, allowing enumeration to check for type usage before removal.

Recommended implementation (Option 1):
```csharp
// In NFTContractState.cs
public MappedState<string, long> NFTTypeUsageCount { get; set; }

// In Create method, after creating protocol
State.NFTTypeUsageCount[shortName] = State.NFTTypeUsageCount[shortName].Add(1);

// In RemoveNFTType method
public override Empty RemoveNFTType(StringValue input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    Assert(input.Value.Length == 2, "Incorrect short name.");
    Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
    
    // Add this validation
    var usageCount = State.NFTTypeUsageCount[input.Value];
    Assert(usageCount == 0, $"Cannot remove NFT type {input.Value}: still used by {usageCount} protocol(s).");
    
    var fullName = State.NFTTypeFullNameMap[input.Value];
    State.NFTTypeFullNameMap.Remove(input.Value);
    State.NFTTypeShortNameMap.Remove(fullName);
    var nftTypes = State.NFTTypes.Value;
    nftTypes.Value.Remove(input.Value);
    State.NFTTypes.Value = nftTypes;
    Context.Fire(new NFTTypeRemoved
    {
        ShortName = input.Value
    });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveNFTType_Breaks_CrossChainCreate_Test()
{
    // Step 1: Create an NFT protocol on mainchain with Art type (short name "AR")
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://aelf/",
        Creator = DefaultAddress,
        IsBurnable = true,
        NftType = NFTType.Art.ToString(),
        ProtocolName = "TestArt",
        TotalSupply = 1_000_000
    });
    var symbol = createResult.Output.Value;
    
    // Verify symbol starts with "AR" (Art type short name)
    symbol.Substring(0, 2).ShouldBe("AR");
    
    // Step 2: Parliament removes the "AR" NFT type
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(NFTContractAddress,
        defaultParliament, nameof(NFTContractStub.RemoveNFTType),
        new StringValue { Value = "AR" });
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Step 3: Attempt CrossChainCreate on sidechain - should fail
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    
    // Verify the failure is due to missing NFT type mapping
    exception.Message.ShouldContain("Full name of AR not found");
    exception.Message.ShouldContain("Use AddNFTType to add this new pair");
}
```

## Notes

This vulnerability demonstrates a critical gap in the NFT contract's cross-chain synchronization mechanism. The core issue is architectural: the combination of non-enumerable protocol storage and unchecked type removal creates a scenario where governance can inadvertently break existing functionality. The vulnerability is particularly concerning because:

1. **Silent failure mode**: There's no warning during removal that protocols depend on the type
2. **Cross-chain impact**: The failure occurs during cross-chain operations, not on the chain where removal happened
3. **Recovery complexity**: Requires Parliament to recognize the issue and re-add the exact same type mapping

While Parliament is a trusted role, the design should prevent unintended operational failures. This is especially important for cross-chain operations where the consequences may not be immediately visible on the chain where the governance action occurred.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L24-24)
```csharp
    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }
```
