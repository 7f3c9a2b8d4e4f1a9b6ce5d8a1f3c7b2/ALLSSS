# Audit Report

## Title
Missing Option Length Validation in Vote Contract Registration Allows Permanent Storage Bloat

## Summary
The `Register()` function in the Vote contract does not validate the length of individual option strings when creating a voting item, while `AddOption()`, `AddOptions()`, `RemoveOption()`, and `Vote()` all enforce the 1024-character limit defined in the contract constants. This inconsistency allows attackers to register voting items with arbitrarily long option strings, causing permanent blockchain storage bloat that cannot be cleaned up.

## Finding Description

The vulnerability exists in the `Register()` function where options are directly copied from input without any length validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem()` called during registration only validates timestamps and voting item uniqueness, but does not check option lengths. [2](#0-1) 

In contrast, the `AssertOption()` validation function enforces the 1024-character limit defined in constants. [3](#0-2) [4](#0-3) 

The `AddOption()` function enforces the length limit through `AssertOption()`. [5](#0-4) 

The `RemoveOption()` function enforces the length limit **before** checking if the option exists, which creates a permanent lock situation where oversized options cannot be removed. [6](#0-5) 

The `Vote()` function validates option length through `AssertValidVoteInput()`, preventing votes on oversized options. [7](#0-6) 

This inconsistency breaks the contract's intended invariant that all options must be â‰¤ 1024 characters. Once an oversized option is registered, it creates a permanent inconsistent state because:
1. The option exists in storage
2. It cannot be voted on (Vote validates length)
3. It cannot be removed (RemoveOption validates length before checking existence)

## Impact Explanation

**Storage Bloat**: An attacker can register voting items with option strings containing millions of characters, consuming excessive blockchain storage that all nodes must maintain permanently.

**Permanent Pollution**: The oversized options become permanently stuck in the blockchain state. To remove an option, the sponsor must provide the exact string to `RemoveOption()`, but if the string exceeds 1024 characters, the transaction fails at the length validation check before even checking if the option exists. [6](#0-5) 

**Useless Voting Items**: The voting items become non-functional because users cannot vote for the oversized options, and the sponsor cannot clean up the options. The voting item persists in storage but serves no purpose.

**Cost to Network**: This is a griefing attack vector where malicious actors can bloat the blockchain state at relatively low cost (only transaction fees), affecting all node operators who must store this data permanently. The impact scales with the number of oversized options registered.

## Likelihood Explanation

**Reachable Entry Point**: The `Register()` function is a public method callable by any user. [8](#0-7) 

**Low Preconditions**: The only requirement is that the accepted currency token must be in the whitelist, which is checked during registration. [9](#0-8)  For common tokens like the native token, this requirement is trivially satisfied.

**Simple Execution**: An attacker simply needs to:
1. Prepare a `VotingRegisterInput` with valid timestamps and accepted currency
2. Include one or more option strings exceeding 1024 characters
3. Call `Register()` 
4. Pay only the standard transaction fee

**No Detection**: The `AssertValidNewVotingItem()` helper only validates voting item uniqueness and timestamps - there is no check that would prevent or detect oversized options before they are permanently stored. [2](#0-1) 

## Recommendation

Add option length validation in the `Register()` function by validating each option in the input before storing them. The fix should iterate through all options and enforce the same length constraint that exists in other functions:

```csharp
// Add validation after line 34 and before line 37:
foreach (var option in input.Options)
{
    Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
}
```

Alternatively, reuse the existing `AssertOption()` helper for consistency:

```csharp
// Add validation after line 34 and before line 37:
var tempVotingItem = new VotingItem();
foreach (var option in input.Options)
{
    AssertOption(tempVotingItem, option);
    tempVotingItem.Options.Add(option);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Register_With_Oversized_Options_Creates_Unremovable_Storage_Bloat()
{
    InitializeContracts();
    
    // Create an option exceeding the 1024 character limit
    var oversizedOption = new string('A', 2000);
    
    var input = new VotingRegisterInput
    {
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(7),
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true,
        TotalSnapshotNumber = 1,
        Options = { oversizedOption }
    };
    
    // Register succeeds without validation
    var registerResult = await VoteContractStub.Register.SendAsync(input);
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var votingItemId = Hash.Parser.ParseFrom(registerResult.TransactionResult.ReturnValue);
    
    // Verify option was stored
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(votingItemId);
    votingItem.Options.Count.ShouldBe(1);
    votingItem.Options[0].Length.ShouldBe(2000);
    
    // Attempt to vote fails due to length validation
    var voteResult = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = oversizedOption,
        Amount = 100
    });
    voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.TransactionResult.Error.ShouldContain("Invalid input");
    
    // Attempt to remove fails due to length validation before existence check
    var removeResult = await VoteContractStub.RemoveOption.SendAsync(new RemoveOptionInput
    {
        VotingItemId = votingItemId,
        Option = oversizedOption
    });
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeResult.TransactionResult.Error.ShouldContain("Invalid input");
    
    // The oversized option is now permanently stuck in storage
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L29-34)
```csharp
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L307-308)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L380-381)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```
