# Audit Report

## Title
Parliament Single Point of Failure in User Fee Governance Due to Trivial Referendum Threshold

## Summary
The referendum organization protecting UserFeeController has a critically weak configuration (1 token approval threshold) combined with parliament-exclusive proposal control, allowing miners to unilaterally modify user transaction fee coefficients without meaningful token holder consensus. This violates the intended multi-stakeholder governance model.

## Finding Description

The UserFeeController governance structure is initialized with a referendum organization that has an exploitable configuration. The referendum is created with `MinimalApprovalThreshold = 1` and `MinimalVoteThreshold = 1`, while restricting the `ProposerWhiteList` to only the parliament address. [1](#0-0) 

The UserFeeController uses an Association contract as its RootController, configured with both parliament and referendum addresses as organization members, requiring both to approve proposals (threshold = 2). [2](#0-1) 

However, this dual-approval mechanism provides no security because:

1. **Proposal Monopoly**: Only parliament can create referendum proposals due to the ProposerWhiteList restriction enforced during proposal creation. [3](#0-2) 

2. **Unrestricted Voting**: The Referendum.Approve method accepts votes from any address that has approved token allowance to the proposal's virtual address, with no whitelist or membership checks. [4](#0-3)  The method retrieves allowance via GetAllowance which only checks that allowance > 0. [5](#0-4) 

3. **Trivial Threshold**: The referendum requires only 1 token of approval to be satisfied, easily provided by any miner-controlled address. [6](#0-5) 

This contrasts sharply with Association voting, which restricts approval to organization members only. [7](#0-6) 

The protected method `UpdateCoefficientsForSender` controls critical transaction fee calculation coefficients and requires authorization from the UserFeeController's RootController. [8](#0-7) [9](#0-8) 

**Attack Execution Path:**
1. Parliament creates Association proposal to update fee coefficients
2. Parliament approves in parliament organization (2/3 miners required)
3. Parliament creates referendum sub-proposal (allowed via ProposerWhiteList)
4. Any address controlled by miners approves 1 token allowance to referendum proposal virtual address
5. Same address calls Referendum.Approve() to lock 1 token
6. Referendum threshold is reached (1 ≥ 1)
7. Parliament releases referendum proposal through another parliament proposal
8. Association sees both member approvals satisfied (parliament + referendum) and releases
9. Fee coefficients are updated

The test suite demonstrates this exact governance flow, showing that any address can participate in referendum voting after approving tokens. [10](#0-9) 

## Impact Explanation

**Governance Failure**: Parliament achieves unilateral control over user transaction fee coefficients, affecting all network participants. The intended separation between parliament (miner collective) and token holder community is eliminated, concentrating economic policy power in the hands of miners.

**Economic Manipulation**: Parliament can arbitrarily adjust fee calculation formulas to:
- Increase transaction costs network-wide without community consent
- Favor specific actors through targeted fee structures
- Extract economic rent from users without oversight

**Severity Justification**: HIGH - This breaks the fundamental governance invariant that critical economic parameters require multi-stakeholder approval. Token holders are systematically excluded from decisions directly impacting their transaction costs, while the governance structure falsely appears to have checks and balances. The referendum component provides only an illusion of token holder representation.

## Likelihood Explanation

**Attacker Profile**: Parliament (default organization of miners requiring 2/3 approval) needs only 1 token for the attack, which is trivially affordable given miners earn block rewards in the primary token.

**Execution Complexity**: LOW - The governance flow is straightforward and uses only standard proposal mechanisms. No special exploits or edge cases are required. The test suite proves this is the intended usage pattern.

**Economic Feasibility**: Attack cost = 1 locked token (fully reclaimable after proposal expiry via ReclaimVoteToken). Miners collectively control significant token amounts through block rewards.

**Detection**: On-chain activity appears as legitimate governance operations. No monitoring system would differentiate this from intended usage since all actions follow standard governance protocols.

**Preconditions**: Only requires parliament to reach 2/3 miner consensus, which is the normal threshold for parliament actions. No special circumstances needed.

## Recommendation

Increase the referendum organization's `MinimalApprovalThreshold` and `MinimalVoteThreshold` to meaningful values that require substantial token holder participation. Recommended configuration:

```csharp
ProposalReleaseThreshold = new ProposalReleaseThreshold
{
    MinimalApprovalThreshold = 1_000_000, // 1M tokens minimum
    MinimalVoteThreshold = 10_000_000,     // 10M tokens total participation
    MaximalRejectionThreshold = 3_000_000, // Allow up to 3M rejection
    MaximalAbstentionThreshold = 2_000_000 // Allow up to 2M abstention
}
```

These thresholds should be calibrated based on:
- Total token supply
- Expected token holder participation rates
- Historical voting patterns
- Economic security requirements

Alternatively, consider adding voter eligibility restrictions or time-weighted voting mechanisms to ensure genuine token holder representation beyond simple token ownership.

## Proof of Concept

The existing test `UpdateCalculateFeeAlgorithmAsync_Success_Test` in MultiTokenContractReferenceFeeTest.cs demonstrates the vulnerability. The test shows:

1. Parliament creates nested proposals through the Association and Referendum organizations
2. A test account (not a special privileged role) approves tokens and votes in the referendum
3. Only a small token amount is needed (test uses 100000 but threshold is 1)
4. Parliament controls the entire flow through nested proposals

To prove the vulnerability, observe that in the `VoteToReferendumAsync` helper method:
- Lines 945-950: Any address approves tokens to referendum proposal virtual address
- Line 951: Same address calls Referendum.Approve() with no authorization failure
- The referendum approval succeeds with any token amount ≥ 1

This demonstrates that parliament can satisfy the referendum requirement using addresses they control with minimal token amounts, bypassing meaningful token holder participation.

## Notes

This vulnerability represents a governance design flaw where the multi-layer approval structure (Parliament → Association ← Referendum) fails to provide meaningful checks and balances. The referendum component, which should represent token holder interests, is effectively controlled by parliament through:

1. Proposal creation monopoly (ProposerWhiteList)
2. Unrestricted voting with trivial thresholds (any address with 1 token)
3. Control over proposal release timing

The Association's requirement for both parliament and referendum approval appears to provide dual authorization, but the referendum approval is trivially satisfied by parliament-controlled addresses, making it a rubber stamp rather than a genuine governance check.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L133-156)
```csharp
    private CreateOrganizationBySystemContractInput GetReferendumControllerCreateInputForUserFee(
        Address parliamentAddress)
    {
        var whiteList = new List<Address> { parliamentAddress };
        var tokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        return new CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new CreateOrganizationInput
            {
                TokenSymbol = tokenSymbol,
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { whiteList }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L391-397)
```csharp
    private void AssertUserFeeController()
    {
        Assert(State.UserFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == State.UserFeeController.Value.RootController.OwnerAddress, "no permission");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L141-152)
```csharp
    private long GetAllowance(Address owner, string tokenSymbol, Hash proposalId)
    {
        RequireTokenContractStateSet();
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = owner,
            Spender = GetProposalVirtualAddress(proposalId),
            Symbol = tokenSymbol
        }).Allowance;
        Assert(allowance > 0, "Allowance not enough.");
        return allowance;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-83)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L918-962)
```csharp
    private async Task VoteToReferendumAsync(Hash input, string primaryTokenSymbol)
    {
        var organizations = await GetControllerForUserFeeAsync();

        var referendumProposal = new CreateProposalInput
        {
            ToAddress = AssociationContractAddress,
            Params = input.ToByteString(),
            OrganizationAddress = organizations.ReferendumController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Approve),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };

        var parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposal.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.CreateProposal),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        var ret = await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
        var referendumProposalId = ProposalCreated.Parser
            .ParseFrom(ret.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;
        var proposalVirtualAddress =
            await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(referendumProposalId);
        var approveResult = await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = proposalVirtualAddress,
            Symbol = primaryTokenSymbol,
            Amount = 100000
        });
        await ReferendumContractStub.Approve.SendAsync(referendumProposalId);

        parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposalId.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Release),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
    }
```
