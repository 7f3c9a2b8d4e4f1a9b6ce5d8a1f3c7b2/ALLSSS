# Audit Report

## Title
Permanent Contract Lock Due to Missing Null/Empty Address Validation in SetContractAuthor

## Summary
The `SetContractAuthor()` function in the Genesis contract lacks validation to prevent setting the contract author to null or an empty address. Once triggered, this creates a permanent denial-of-service by making the contract permanently un-upgradeable through all update mechanisms, with no recovery path available.

## Finding Description

The `SetContractAuthor()` function does not validate `input.NewAuthor` before assignment, allowing null or empty addresses to be set as the contract author. [1](#0-0) 

This violates the standard validation pattern used consistently throughout the codebase. The `SetSigner()` function correctly validates addresses before assignment: [2](#0-1) 

Once `info.Author` becomes null or empty, all contract update mechanisms become permanently blocked:

**1. ProposeUpdateContract Path Blocked:**

The `ProposeUpdateContract` method calls `AssertAuthorityByContractInfo` which checks authorization before creating any governance proposal: [3](#0-2) 

The authorization helper performs the critical check that fails when the author is null: [4](#0-3) 

When `contractInfo.Author` is null, both conditions evaluate to false (`null == Context.Self` is false, and `Context.Sender == null` is false), causing the assertion to fail with "No permission." **This occurs before any proposal is created**, preventing governance from intervening.

**2. UpdateUserSmartContract Path Blocked:**

User contract updates require the sender to match the author: [5](#0-4) 

With a null author, `Context.Sender == null` is always false, permanently blocking updates.

**3. SetContractAuthor Cannot Self-Recover:**

The function itself requires author permission to execute: [6](#0-5) 

Once the author is null, this check fails, preventing any attempt to restore a valid author.

**4. No Administrative Override Exists:**

The `UpdateSmartContract` method also enforces author checks: [7](#0-6) 

The helper method enforces the same restriction: [8](#0-7) 

**Technical Root Cause:**

In Protocol Buffers v3, the `Address` type is a message that can be null when not set. The protobuf definition for `SetContractAuthorInput` allows `new_author` to be unset: [9](#0-8) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes permanent, irreversible denial-of-service with the following impacts:

1. **Complete Loss of Contract Upgradeability**: Once triggered, the contract can never be updated againâ€”not by the original author, not by governance, not by any mechanism.

2. **Affects All Contract Types**: Both system contracts and user contracts are vulnerable to this permanent lock.

3. **No Recovery Mechanism**: Unlike most smart contract issues that can be mitigated through upgrades or governance actions, this vulnerability eliminates all possible recovery paths because the authorization check in `ProposeUpdateContract` fails before any proposal can be created.

4. **Ecosystem-Wide Risk**: Any contract where the author is accidentally set to null becomes a permanent liability, potentially trapping users with buggy or vulnerable code indefinitely.

5. **Violates Critical Invariant**: The AElf protocol's design assumes contracts can always be upgraded through proper authorization. This vulnerability permanently breaks that fundamental guarantee.

## Likelihood Explanation

**Likelihood: MEDIUM**

While this requires the contract author to call `SetContractAuthor()`, several realistic scenarios make this feasible:

1. **Application Bugs**: Contract management tools, deployment scripts, or admin interfaces that incorrectly construct the protobuf message could accidentally omit the `NewAuthor` field, resulting in a null value.

2. **Protobuf Default Behavior**: Protobuf3 messages default to null for unset message fields, making it easy to accidentally create a `SetContractAuthorInput` without properly initializing `NewAuthor`.

3. **Developer Error**: Inexperienced developers or those unfamiliar with protobuf semantics might not realize that failing to set `NewAuthor` results in null rather than an error.

4. **Catastrophic Consequences**: Even a single occurrence is devastating due to the permanent, unrecoverable nature of the issue.

5. **Evidence of Concern**: The fact that the codebase consistently validates addresses in other functions (like `SetSigner`) demonstrates that the development team is aware null addresses are a real concern, making this omission particularly notable.

## Recommendation

Add validation to prevent setting null or empty addresses as the contract author:

```csharp
public override Empty SetContractAuthor(SetContractAuthorInput input)
{
    var info = State.ContractInfos[input.ContractAddress];
    Assert(info != null, "Contract not found.");
    Assert(input.NewAuthor != null && !input.NewAuthor.Value.IsNullOrEmpty(), "Invalid new author address.");
    var oldAuthor = info.Author;
    Assert(Context.Sender == info.Author, "No permission.");
    info.Author = input.NewAuthor;
    State.ContractInfos[input.ContractAddress] = info;
    Context.Fire(new AuthorUpdated()
    {
        Address = input.ContractAddress,
        OldAuthor = oldAuthor,
        NewAuthor = input.NewAuthor
    });

    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SetContractAuthor_NullAddress_PermanentLock_Test()
{
    // Deploy a test contract with known author
    var author = DefaultSender;
    var contractAddress = await DeployTestContractAsync();
    
    // Verify author can update contract initially
    var initialAuthor = await GetContractAuthorAsync(contractAddress);
    initialAuthor.ShouldBe(author);
    
    // Set author to null by creating input without NewAuthor field
    var setAuthorInput = new SetContractAuthorInput
    {
        ContractAddress = contractAddress
        // NewAuthor intentionally not set - will be null
    };
    
    var setResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.SetContractAuthor),
        setAuthorInput);
    setResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify author is now null
    var currentAuthor = await GetContractAuthorAsync(contractAddress);
    currentAuthor.ShouldBeNull();
    
    // Attempt to propose update - should fail
    var updateInput = new ContractUpdateInput
    {
        Address = contractAddress,
        Code = ByteString.CopyFrom(UpdatedContractCode)
    };
    
    var proposeResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ProposeUpdateContract),
        updateInput);
    proposeResult.Status.ShouldBe(TransactionResultStatus.Failed);
    proposeResult.Error.ShouldContain("No permission.");
    
    // Attempt to recover by setting author again - should fail
    var recoverInput = new SetContractAuthorInput
    {
        ContractAddress = contractAddress,
        NewAuthor = author
    };
    
    var recoverResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.SetContractAuthor),
        recoverInput);
    recoverResult.Status.ShouldBe(TransactionResultStatus.Failed);
    recoverResult.Error.ShouldContain("No permission.");
    
    // Contract is now permanently locked with no recovery path
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-184)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-333)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-452)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
        Assert(info.Deployer == null || info.Deployer == Context.Sender, "No permission to update.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-545)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

        if (State.SignerMap[Context.Sender] == input) return new Empty();

        State.SignerMap[Context.Sender] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-103)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** protobuf/acs0.proto (L310-313)
```text
message SetContractAuthorInput{
    aelf.Address contract_address = 1;
    aelf.Address new_author = 2;
}
```
