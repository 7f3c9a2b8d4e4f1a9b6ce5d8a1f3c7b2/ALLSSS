# Audit Report

## Title
Precision Loss in Bancor Formula Causes Zero Token Return for Small Trades with Large Connector Balances

## Summary
The `GetReturnFromPaid` function in BancorHelper performs integer truncation that causes zero token returns when connector balances are large relative to payment amounts. Users who set `ReceiveLimit = 0` (documented as "no limit") in the `Sell()` method will lose their tokens without receiving anything in return, as the transaction succeeds despite returning zero base tokens.

## Finding Description

The vulnerability exists in the Bancor formula implementation when calculating token returns. [1](#0-0) 

When connector weights are equal, the simplified formula casts a decimal calculation directly to `long`. When `fromConnectorBalance` is much larger than `paidAmount`, the decimal result becomes less than 1.0, which truncates to 0.

**Mathematical breakdown:**
With realistic initialization values from the protocol: [2](#0-1)  and [3](#0-2) 

For a trade where:
- `fromConnectorBalance` = 100_000_00000000
- `toConnectorBalance` = 1_000_00000000  
- `paidAmount` = 50 units

The formula `(toConnectorBalance / (fromConnectorBalance + paidAmount)) * paidAmount` evaluates to approximately 0.5, which casts to 0.

**Execution path in Sell():**
The `Sell()` method calls `GetReturnFromPaid` to calculate returns: [4](#0-3) 

The protection check only validates against user-specified limits: [5](#0-4) 

Per the protocol specification, `ReceiveLimit = 0` means "no limit": [6](#0-5) 

When `amountToReceive = 0` and user sets `ReceiveLimit = 0`, the assertion `0 == 0 || 0 >= 0` passes. The transaction then: [7](#0-6) 

1. Transfers 0 base tokens to the user
2. Transfers the user's `input.Amount` to the contract

Result: User loses tokens, receives nothing.

## Impact Explanation

**Direct Fund Loss:** Users permanently lose their sold tokens while receiving zero base tokens in return. This violates the fundamental protocol invariant that valid trades should return proportional value.

**Severity:** The impact is high because:
- Funds are permanently lost with no recovery mechanism
- The transaction succeeds without error or warning
- Users following documented behavior (`ReceiveLimit = 0` for "no limit") are vulnerable

**Affected Users:**
- Anyone making trades below the truncation threshold
- The threshold worsens as connector balances grow through normal protocol operation
- Resource tokens have total supply of 500_000_000_00000000: [8](#0-7) 

As balances accumulate to significant fractions of total supply, increasingly larger trades will return zero.

## Likelihood Explanation

**High Likelihood:**
- No attacker required - this occurs naturally through normal protocol usage
- Connector balances are initialized at problematic levels from genesis: [9](#0-8) 
- Initial virtual balances create immediate vulnerability for small trades
- Users commonly set `ReceiveLimit = 0` following the documented "no limit" interpretation
- The issue compounds over time as real balances accumulate

**Triggering Conditions:**
1. Connector balances at initialization values or higher (guaranteed from genesis)
2. User makes small trade where `paidAmount < fromConnectorBalance / toConnectorBalance`
3. User sets `ReceiveLimit = 0` or any value â‰¤ actual zero return

## Recommendation

Implement minimum return validation in the Bancor formula:

```csharp
public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
{
    // ... existing validation ...
    
    long result;
    if (wf == wt)
        result = (long)(bt / (bf + a) * a);
    else
    {
        var x = bf / (bf + a);
        var y = wf / wt;
        result = (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
    
    // Enforce minimum return > 0 for non-zero payment
    if (result == 0 && paidAmount > 0)
        throw new InvalidValueException("Payment amount too small for current connector balances. Minimum trade size required.");
    
    return result;
}
```

Alternative: Change the `Sell()` method to always validate minimum return:
```csharp
Assert(amountToReceiveLessFee > 0, "Return amount must be greater than zero.");
```

## Proof of Concept

```csharp
[Fact]
public void Test_ZeroReturnVulnerability()
{
    // Setup: Initialize connector with realistic values
    var fromConnectorBalance = 100_000_00000000L; // 10^15
    var toConnectorBalance = 1_000_00000000L;     // 10^13
    var weight = 0.5m;
    var paidAmount = 50L;
    
    // Execute: Calculate return using Bancor formula
    var result = BancorHelper.GetReturnFromPaid(
        fromConnectorBalance, 
        weight,
        toConnectorBalance, 
        weight, 
        paidAmount);
    
    // Verify: Result is zero due to truncation
    Assert.Equal(0L, result);
    
    // This proves user would lose paidAmount=50 tokens
    // while receiving result=0 tokens if ReceiveLimit=0
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-49)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L5-5)
```csharp
    public const long NativeTokenConnectorInitialVirtualBalance = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L11-11)
```csharp
    public const long ResourceTokenTotalSupply = 500_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L180-180)
```csharp
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L186-203)
```csharp
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
```

**File:** protobuf/token_converter_contract.proto (L140-142)
```text
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L221-246)
```csharp
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
```
