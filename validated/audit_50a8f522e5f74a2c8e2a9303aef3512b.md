# Audit Report

## Title
Side Chain Fails to Validate Incoming Parent Chain Miner List Size Leading to DoS and Storage Exhaustion

## Summary
The `UpdateInformationFromCrossChain()` function on side chains accepts unbounded parent chain miner lists without validating against the side chain's own `MaximumMinersCount` limit. This creates a defensive validation gap that exposes side chains to DoS and consensus disruption when parent chains have excessively large miner lists due to misconfiguration or bugs.

## Finding Description

The vulnerability exists in the cross-chain consensus information update mechanism. When a side chain indexes parent chain blocks, the `UpdateInformationFromCrossChain` method extracts and unconditionally stores all miner public keys from the parent chain without any size validation against the side chain's own limits. [1](#0-0) 

The function directly assigns all miners from `consensusInformation.Round.RealTimeMinersInformation.Keys` into `State.MainChainCurrentMinerList.Value` without checking against `State.MaximumMinersCount.Value`.

This triggers two critical issues:

**1. Unbounded Token Distribution DoS:**

Before updating the miner list, the function calls `DistributeResourceTokensToPreviousMiners()` which performs O(miners × symbols) token transfer operations: [2](#0-1) 

With thousands of miners, this nested iteration could exceed block gas limits or cause transaction timeouts, blocking the consensus update mechanism.

**2. Side Chain Consensus Corruption:**

The stored `MainChainCurrentMinerList` is used to generate the side chain's own consensus rounds when the parent chain miner list changes: [3](#0-2) 

When `IsMainChainMinerListChanged` detects a change, the side chain generates a new term using the unbounded miner list. The `GenerateFirstRoundOfNewTerm` method creates a `MinerInRound` entry for every single miner without any cap: [4](#0-3) 

If the parent chain has 5,000 miners, the side chain will create a consensus round expecting all 5,000 miners to participate, rendering block production non-functional.

**Root Cause - Missing Upper Bound:**

The parent chain's `SetMaximumMinersCount` method only validates that the value is positive, allowing values up to Int32.MaxValue: [5](#0-4) 

While the parent chain manages its own limits, side chains have no defensive validation when receiving this data through cross-chain indexing.

**Cross-Chain Entry Point:**

The vulnerability is triggered through normal cross-chain indexing when parent chain blocks are indexed: [6](#0-5) 

## Impact Explanation

**Critical Consensus Disruption:**

When a side chain receives an oversized parent chain miner list (e.g., 5,000 miners), the consensus mechanism generates a round with 5,000 miner entries, each with their own time slot. The side chain's consensus becomes non-functional as it expects all 5,000 miners to participate in block production.

**Operational DoS:**
- Token distribution iterates miners × symbols times, potentially exceeding gas limits or causing timeouts
- Storage grows proportionally to miner count without bounds
- Cross-chain consensus updates become blocked
- Side chain cannot produce blocks normally
- Complete service disruption for side chain users

**Affected Parties:**
- Side chain block production halts
- All side chain users experience service outage
- Resource token distribution mechanism fails

## Likelihood Explanation

**Trigger Scenarios:**

1. **Parent Chain Misconfiguration:** Parent chain governance (Parliament) can legitimately set `MaximumMinersCount` to any positive integer value through a governance proposal. An operational error setting this to 5,000+ would immediately propagate to all side chains through normal cross-chain indexing.

2. **Parent Chain Bug:** A bug in the parent chain's consensus logic that bypasses normal validation would propagate to all side chains with no defense mechanism.

**Feasibility:**
- No cryptographic breaks required
- No consensus manipulation required
- Triggered through normal cross-chain indexing operations that happen automatically
- Side chains fully trust parent chain data without defensive validation

**Architectural Gap:**

Side chains have their own `MaximumMinersCount` state variable controlled by their governance: [7](#0-6) 

However, this limit is never enforced against incoming parent chain miner lists in `UpdateInformationFromCrossChain`, creating an inconsistency where side chains have limits but don't enforce them defensively.

**Probability Assessment:**

While parent chain operators are expected to maintain reasonable limits (typical value: ~17 miners), the lack of defensive validation means side chains cannot protect themselves from parent chain operational errors or bugs. This represents a realistic operational risk in a multi-chain architecture where trust boundaries should be validated.

## Recommendation

Add defensive validation in `UpdateInformationFromCrossChain` to check the incoming miner list size against the side chain's own `MaximumMinersCount`:

```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    Assert(
        Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
        "Only Cross Chain Contract can call this method.");

    Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

    if (input == null || input.Value.IsEmpty) return new Empty();

    var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

    if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
        return new Empty();

    var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
    
    // ADD THIS VALIDATION:
    var maxMinersCount = State.MaximumMinersCount.Value;
    Assert(minersKeys.Count <= maxMinersCount, 
        $"Parent chain miner list size ({minersKeys.Count}) exceeds side chain maximum ({maxMinersCount})");

    DistributeResourceTokensToPreviousMiners();

    State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;
    State.MainChainCurrentMinerList.Value = new MinerList
    {
        Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
    };

    return new Empty();
}
```

Additionally, consider adding an upper bound validation in `SetMaximumMinersCount` to prevent unreasonably large values:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();

    Assert(input.Value > 0, "Invalid max miners count.");
    Assert(input.Value <= 1000, "Max miners count cannot exceed 1000."); // ADD THIS

    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");

    // ... rest of method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SideChain_DoS_With_Excessive_MainChain_MinerList()
{
    // Setup: Create a side chain
    var sideChainId = await InitializeSideChainAsync();
    var sideChainConsensus = GetSideChainConsensusContract(sideChainId);
    
    // Side chain sets its own maximum to reasonable value (e.g., 100)
    await sideChainConsensus.SetMaximumMinersCount(new Int32Value { Value = 100 });
    
    // Parent chain misconfigures and sets maximum to 5000
    await MainChainConsensus.SetMaximumMinersCount(new Int32Value { Value = 5000 });
    
    // Parent chain somehow gets 5000 miners (could be bug or election issue)
    var excessiveMiners = GenerateMinerList(5000);
    
    // Create parent chain consensus information with 5000 miners
    var consensusInfo = new AElfConsensusHeaderInformation
    {
        Round = CreateRoundWithMiners(excessiveMiners)
    };
    
    // Index parent chain block on side chain - this triggers UpdateInformationFromCrossChain
    var result = await IndexParentChainBlockWithConsensusData(sideChainId, consensusInfo);
    
    // Vulnerability: Side chain accepts all 5000 miners without validation
    var sideChainMinerList = await sideChainConsensus.GetMainChainCurrentMinerList(new Empty());
    sideChainMinerList.Pubkeys.Count.ShouldBe(5000); // Side chain stored all 5000 miners
    
    // Impact 1: Token distribution will iterate 5000 × symbols times
    // This will likely timeout or exceed gas limits
    
    // Impact 2: Next consensus round generation will create 5000 miner slots
    // Side chain consensus becomes non-functional
    var nextRound = await sideChainConsensus.GetNextRoundInformation();
    nextRound.RealTimeMinersInformation.Count.ShouldBe(5000); // DoS - cannot produce blocks
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-787)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
```
