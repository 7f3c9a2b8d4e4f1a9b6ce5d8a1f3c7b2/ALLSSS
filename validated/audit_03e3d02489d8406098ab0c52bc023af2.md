# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function creates a new `DistributedProfitsInfo` object and unconditionally overwrites existing state without preserving pre-contributed profits. When users contribute tokens to future periods via `ContributeProfits` and the scheme later has zero `totalShares` at distribution time, `BurnProfits` destroys the accounting record while tokens remain locked in period-specific virtual addresses, making them permanently unclaimable.

## Finding Description

The vulnerability exists in how `BurnProfits` handles periods that already have pre-contributed profits.

When users contribute to future periods, `ContributeProfits` validates the period is valid and allows future contributions [1](#0-0) , generates a period-specific virtual address [2](#0-1) , and transfers tokens there [3](#0-2) . The contribution is recorded in `DistributedProfitsMap` [4](#0-3) .

When `DistributeProfits` is later called for that period with `totalShares <= 0`, it invokes `BurnProfits` [5](#0-4) .

The critical flaw is in `BurnProfits` implementation: it creates a brand new `DistributedProfitsInfo` object without reading any existing state [6](#0-5) . It then attempts to burn tokens from the scheme's general ledger [7](#0-6) , not from the period-specific address where pre-contributions were deposited. Finally, it unconditionally overwrites the state [8](#0-7) , destroying all records of previously contributed profits.

In contrast, the normal distribution path via `UpdateDistributedProfits` correctly reads existing state [9](#0-8)  and checks the period-specific address balance [10](#0-9) .

After `BurnProfits` sets `IsReleased=true`, future contributions to that period are blocked [11](#0-10) .

When users try to claim profits via `ClaimProfits`, the calculation depends entirely on `DistributedProfitsMap` [12](#0-11) . With the accounting destroyed, the contributed tokens become permanently unrecoverable despite remaining in the period-specific virtual address.

## Impact Explanation

**High Severity - Permanent Loss of User Funds:**

1. **Complete Fund Loss:** Tokens contributed to future periods become permanently locked in period-specific virtual addresses with no recovery mechanism. The accounting in `DistributedProfitsMap` is destroyed, and `ClaimProfits` cannot retrieve these funds.

2. **Quantified Damage:** The impact scales linearly with contribution amounts. If 10,000 ELF tokens are contributed to period 5, and the scheme has zero beneficiaries when period 5 arrives, all 10,000 ELF become permanently locked.

3. **Affected Parties:**
   - Users who contribute profits to future periods expecting normal distribution
   - Scheme managers who inadvertently trigger this by removing all beneficiaries during scheme wind-down
   - The overall protocol, as tokens become permanently stuck in virtual addresses

4. **No Recovery Path:** Once `BurnProfits` executes, there is no mechanism to recover the contributed funds. The virtual address still holds the tokens, but all accounting is lost.

## Likelihood Explanation

**Medium Likelihood - Triggered Through Normal Operations:**

1. **Public Entry Point:** `ContributeProfits` is a public method callable by any user with token allowance, requiring no special privileges for the contribution step.

2. **Realistic Preconditions:**
   - Profit scheme exists and accepts contributions (common scenario)
   - User contributes to a future period (explicitly allowed by the contract)
   - By the time that period arrives, all beneficiaries have been removed via `RemoveBeneficiary`, resulting in `totalShares = 0`
   - Scheme manager calls `DistributeProfits` for the period

3. **Natural Occurrence:** This scenario occurs when:
   - A scheme is being wound down and beneficiaries are systematically removed
   - Users had previously contributed to future periods expecting normal operation
   - The timing gap between contribution and distribution allows legitimate beneficiary changes

4. **No Attack Cost:** Beyond the initial contribution (which could be small), there's no additional cost to trigger the vulnerability. The loss occurs through legitimate contract operations.

5. **Detection Difficulty:** Both `ContributeProfits` and `RemoveBeneficiary` are legitimate operations. The fund loss only becomes apparent when users attempt to claim profits, potentially much later.

## Recommendation

Modify `BurnProfits` to read existing state before creating a new object, similar to how `UpdateDistributedProfits` handles it:

```csharp
private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
    Address profitsReceivingVirtualAddress)
{
    scheme.CurrentPeriod = period.Add(1);

    // READ EXISTING STATE FIRST
    var distributedProfitsInfo = State.DistributedProfitsMap[profitsReceivingVirtualAddress] 
        ?? new DistributedProfitsInfo();
    
    distributedProfitsInfo.IsReleased = true;
    
    foreach (var profits in profitsMap)
    {
        var symbol = profits.Key;
        var amount = profits.Value;
        if (amount > 0)
        {
            var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            });
            if (balanceOfToken.Balance < amount)
                continue;
            Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                nameof(State.TokenContract.Transfer), new TransferInput
                {
                    To = Context.Self,
                    Amount = amount,
                    Symbol = symbol
                }.ToByteString());
            State.TokenContract.Burn.Send(new BurnInput
            {
                Amount = amount,
                Symbol = symbol
            });
            
            // UPDATE EXISTING AMOUNTS INSTEAD OF ADDING NEW
            if (distributedProfitsInfo.AmountsMap.ContainsKey(symbol))
            {
                distributedProfitsInfo.AmountsMap[symbol] = 
                    distributedProfitsInfo.AmountsMap[symbol].Sub(amount);
            }
            else
            {
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }
    }

    State.SchemeInfos[scheme.SchemeId] = scheme;
    State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
    return new Empty();
}
```

Additionally, check and burn tokens from the period-specific virtual address if they exist, similar to how `UpdateDistributedProfits` checks the period-specific address balance.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task BurnProfits_DestroysPre_ContributedProfits()
{
    // Setup: Create scheme and contribute to future period
    var schemeId = await CreateProfitScheme();
    var contributor = Accounts[1];
    var beneficiary = Accounts[2];
    
    // Add beneficiary initially
    await AddBeneficiary(schemeId, beneficiary, 100);
    
    // User contributes 10000 ELF to period 5 (future period)
    await ContributeProfitsAsync(schemeId, 10000, period: 5, contributor);
    
    // Verify contribution was recorded
    var periodAddress = await GetDistributedPeriodProfitsVirtualAddress(schemeId, 5);
    var balance = await GetTokenBalance(periodAddress, "ELF");
    balance.ShouldBe(10000); // Tokens in period-5 address
    
    var distributedInfo = await GetDistributedProfitsInfo(schemeId, 5);
    distributedInfo.AmountsMap["ELF"].ShouldBe(10000); // Accounting shows 10000
    
    // Manager removes all beneficiaries
    await RemoveBeneficiary(schemeId, beneficiary);
    
    // Advance to period 5 and distribute with totalShares=0
    await DistributeProfitsAsync(schemeId, period: 5);
    
    // BurnProfits was called - verify accounting destroyed
    distributedInfo = await GetDistributedProfitsInfo(schemeId, 5);
    distributedInfo.AmountsMap.ContainsKey("ELF").ShouldBeFalse(); // Accounting DESTROYED
    distributedInfo.IsReleased.ShouldBeTrue(); // Marked as released
    
    // But tokens still in virtual address!
    balance = await GetTokenBalance(periodAddress, "ELF");
    balance.ShouldBe(10000); // Tokens STILL THERE
    
    // Contributor cannot claim
    var claimable = await GetProfitAmount(schemeId, contributor, "ELF");
    claimable.ShouldBe(0); // Gets NOTHING despite 10000 ELF locked
    
    // Cannot contribute again - period is released
    await Assert.ThrowsAsync<AssertionException>(() => 
        ContributeProfitsAsync(schemeId, 1000, period: 5, contributor));
    
    // RESULT: 10000 ELF permanently locked in period-5 address
}
```

## Notes

The vulnerability is triggered when a scheme with pre-contributed future period profits has all its beneficiaries removed before distribution, causing `totalShares` to become 0. The architectural flaw in `BurnProfits` - creating a new object instead of reading existing state - results in permanent fund loss with no recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L522-525)
```csharp
        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L532-536)
```csharp
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L556-556)
```csharp
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L563-565)
```csharp
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L574-578)
```csharp
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L685-686)
```csharp
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L698-699)
```csharp
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L704-710)
```csharp
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L712-712)
```csharp
            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L866-874)
```csharp
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```
