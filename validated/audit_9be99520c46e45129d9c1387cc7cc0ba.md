# Audit Report

## Title
Unvalidated ActualMiningTime in TinyBlockInput Enables Term Change Manipulation and Consensus Corruption

## Summary
The AEDPoS consensus contract fails to validate that miner-provided `ActualMiningTime` timestamps in `TinyBlockInput` transactions match the actual block production time (`Context.CurrentBlockTime`). Since `ActualMiningTimes` is excluded from round hash verification and directly affects critical consensus decisions like term changes, malicious miners can provide arbitrary timestamps within their time slots to manipulate consensus timing and corrupt the blockchain's temporal integrity.

## Finding Description

The vulnerability exists across multiple validation layers that fail to verify timestamp authenticity:

**Root Cause #1 - No Validation in ProcessTinyBlock:**
The `ProcessTinyBlock` method directly adds the miner-provided `ActualMiningTime` to blockchain state without any comparison against `Context.CurrentBlockTime` (the actual block time). [1](#0-0) 

**Root Cause #2 - RecoverFromTinyBlock Blindly Merges:**
During validation, the `RecoverFromTinyBlock` method adds provided timestamps without validation against actual block time. [2](#0-1) 

**Root Cause #3 - Hash Verification Excludes ActualMiningTimes:**
The `GetCheckableRound` method explicitly clears `ActualMiningTimes` before computing hashes, meaning manipulated timestamps bypass integrity verification. [3](#0-2) 

**Root Cause #4 - Validation Uses Corrupted Data:**
The validation flow calls `RecoverFromTinyBlock` BEFORE validation providers run, so validators check against already-corrupted data from the miner's input. [4](#0-3) 

**Root Cause #5 - TimeSlotValidationProvider Checks Manipulated Timestamps:**
The time slot validator checks if the miner respects their time slot using the already-recovered (potentially fake) timestamps from `baseRound`. [5](#0-4) 

**Attack Execution Path:**
1. Authorized miner constructs a `TinyBlockInput` with `ActualMiningTime` set to a fake timestamp within their time slot
2. Miner calls `UpdateTinyBlockInformation` which only verifies they are in the miner list via `PreCheck` [6](#0-5) 
3. During validation, `RecoverFromTinyBlock` merges the fake timestamp into `baseRound`
4. `TimeSlotValidationProvider` validates using the fake timestamp (passes if within time slot)
5. Hash verification doesn't catch it (`ActualMiningTimes` excluded from hash)
6. `ProcessTinyBlock` persists fake timestamp to permanent state
7. Future consensus decisions use corrupted timestamp data

## Impact Explanation

**Critical Consensus Corruption:**

**1. Term Change Manipulation:**
The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` to determine when to trigger term changes. [7](#0-6) 

Miners can:
- **Delay term changes** by providing timestamps earlier in their slot, keeping themselves in power longer and postponing election updates and treasury releases
- **Advance term changes** by providing timestamps at the end of their slot, triggering premature elections

**2. Governance Disruption:**
Term changes trigger election snapshots and treasury releases. The `ProcessNextTerm` method shows that term transitions invoke `TakeSnapshot` and `Release` on Treasury. [8](#0-7)  Manipulated timing affects governance voting periods and financial distributions.

**3. Consensus Behavior Corruption:**
The `MainChainConsensusBehaviourProvider` uses `NeedToChangeTerm` to decide between `NextRound` and `NextTerm` behaviors. [9](#0-8)  Corrupted timestamps affect this critical decision.

**Affected Parties:** All blockchain participants suffer from consensus instability, miners gain unfair advantages, governance processes are disrupted, and treasury releases are mistimed.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the current miner list (verified by `PreCheck`)
- Must have normal block production capabilities
- Can construct arbitrary transaction parameters (standard capability)

**Attack Complexity: LOW**
1. The `UpdateTinyBlockInformation` entry point is publicly accessible to authorized miners [10](#0-9) 
2. Miner manually constructs `TinyBlockInput` with fake `ActualMiningTime` (within their time slot to pass validation)
3. Transaction executes successfully, persisting fake timestamp
4. No cryptographic signature on timestamps themselves
5. No comparison with `Context.CurrentBlockTime` anywhere in the validation or execution path

**Feasibility: HIGH**
- No cryptographic barriers
- No timestamp verification logic exists
- Manipulation limited only by time slot duration (4-8 seconds), sufficient for meaningful impact
- Single miner can corrupt their own timestamps; coordinated miners can amplify effects

**Detection: DIFFICULT**
- Observers only see final persisted timestamps
- Cannot distinguish legitimate variations from malicious manipulation without off-chain block time comparison
- No events or logs expose the discrepancy between provided and actual timestamps

## Recommendation

Add validation in `ProcessTinyBlock` to ensure the provided `ActualMiningTime` matches `Context.CurrentBlockTime`:

```csharp
private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // ADDED: Validate ActualMiningTime matches actual block time
    var timeDifference = Math.Abs((tinyBlockInput.ActualMiningTime - Context.CurrentBlockTime).Seconds);
    Assert(timeDifference <= 1, "ActualMiningTime does not match block production time.");

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
    minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
    minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

    Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
}
```

Alternatively, use `Context.CurrentBlockTime` directly instead of trusting the miner-provided timestamp:

```csharp
private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // CHANGED: Use Context.CurrentBlockTime instead of input
    minerInRound.ActualMiningTimes.Add(Context.CurrentBlockTime);
    minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
    minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

    Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test environment with multiple miners
2. Having a miner construct a `TinyBlockInput` with `ActualMiningTime` set to the start of their time slot (e.g., `ExpectedMiningTime` instead of actual current time)
3. Calling `UpdateTinyBlockInformation` with this manipulated input
4. Observing that the fake timestamp is accepted and persisted to state
5. Verifying that `NeedToChangeTerm` calculations use the manipulated timestamp
6. Demonstrating that term changes can be delayed or advanced by manipulating timestamps across multiple miners

The test would show that a miner producing a block at time `T+5` seconds (where T is their expected mining time) can provide `ActualMiningTime = T+1` seconds, and the system accepts this without validation, causing the term change calculation to use incorrect timing data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-218)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L49-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
