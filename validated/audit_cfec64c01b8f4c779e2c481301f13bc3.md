# Audit Report

## Title
Association Contract Threshold Validation Allows Governance Deadlock

## Summary
The `Validate(Organization)` function in the Association contract contains insufficient threshold validation that allows creation of organizations where proposals can enter permanent deadlock states. The validation checks two separate sum constraints but fails to verify that `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold` does not exceed the organization member count plus one, enabling proposals that can neither be approved, rejected, nor abstained even after all members vote.

## Finding Description

The root cause lies in the threshold validation logic which performs two independent checks without ensuring the combined constraint is satisfied: [1](#0-0) 

These constraints check:
1. `MaximalAbstentionThreshold + MinimalApprovalThreshold <= organizationMemberCount`
2. `MaximalRejectionThreshold + MinimalApprovalThreshold <= organizationMemberCount`

However, the proposal release logic uses asymmetric inequality operators that create a deadlock vulnerability: [2](#0-1) 

The release determination uses:
- **Rejected** if rejections > MaximalRejectionThreshold (strict inequality at line 38)
- **Abstained** if abstentions > MaximalAbstentionThreshold (strict inequality at line 44)  
- **Approved** if approvals >= MinimalApprovalThreshold (non-strict inequality at line 51)

Due to the strict inequalities for rejection/abstention versus non-strict for approval, a deadlock occurs when all N members vote with the distribution:
- Approvals = MinimalApprovalThreshold - 1
- Rejections = MaximalRejectionThreshold
- Abstentions = MaximalAbstentionThreshold
- Sum = N (all members voted)

This satisfies the current validation when `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = N + 1`.

**Concrete Example:**
- N = 10 members
- MinimalApprovalThreshold = 6
- MaximalRejectionThreshold = 2  
- MaximalAbstentionThreshold = 3

Validation passes (3+6=9≤10, 2+6=8≤10), but sum is 11 = N+1.

When all 10 members vote (5 approvals, 2 rejections, 3 abstentions):
- Not rejected: 2 > 2? NO
- Not abstained: 3 > 3? NO
- Not approved: 5 >= 6? NO
- **Result: DEADLOCK**

## Impact Explanation

**HIGH Severity - Governance DoS**

Organizations with deadlock-prone threshold configurations experience critical governance failure:

1. **Governance Paralysis**: Proposals requiring urgent action cannot be executed or rejected, leaving the organization unable to respond to time-sensitive situations.

2. **Resource Lock**: Proposals remain permanently stuck as the `Release` method will fail the threshold check: [3](#0-2) 

3. **No Recovery Path**: The `ChangeOrganizationThreshold` method requires execution through a proposal: [4](#0-3) 
   
If a threshold-change proposal deadlocks, the organization cannot fix its own broken configuration (Context.Sender must be the organization address at line 205, meaning it must execute via proposal).

4. **Limited Mitigation**: Only recovery is waiting for proposal expiration via `ClearProposal`: [5](#0-4) 

This violates the governance invariant that organization thresholds must ensure deterministic proposal outcomes when members vote.

## Likelihood Explanation

**HIGH Likelihood - Easily Exploitable**

The vulnerability has high exploitability:

1. **Public Entry Point**: Any user can create an Association organization through the unrestricted `CreateOrganization` method: [6](#0-5) 

2. **No Economic Barrier**: Organization creation requires no staking, approval, or special privileges.

3. **Simple Attack Vector**: Calculate threshold values satisfying `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = organizationMemberCount + 1` that pass the current validation.

4. **Accidental Creation**: Legitimate organizations attempting balanced thresholds (e.g., 60% approval requirement, 20% rejection tolerance, 30% abstention tolerance) can inadvertently create deadlock configurations.

5. **Delayed Detection**: Validation passes during creation; deadlock only manifests during voting, making it difficult to detect beforehand.

## Recommendation

Add an additional validation constraint to ensure the three thresholds cannot create a deadlock scenario. The fix should verify that it's mathematically possible for a proposal to reach one of the three terminal states:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    // Existing checks
    var basicChecksPass = 
        proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
        proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
        proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
        proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
        proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
        proposalReleaseThreshold.MaximalAbstentionThreshold +
        proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
        proposalReleaseThreshold.MaximalRejectionThreshold +
        proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    
    if (!basicChecksPass)
        return false;
    
    // NEW: Prevent deadlock by ensuring the sum doesn't exceed memberCount + 1
    // This accounts for the asymmetric inequality operators (>, >, >=)
    var thresholdSum = proposalReleaseThreshold.MaximalRejectionThreshold +
                      proposalReleaseThreshold.MaximalAbstentionThreshold +
                      proposalReleaseThreshold.MinimalApprovalThreshold;
    
    return thresholdSum <= organizationMemberCount;
}
```

This ensures that when all members vote, at least one of the three terminal states (approved, rejected, or abstained) must be reachable.

## Proof of Concept

```csharp
[Fact]
public void Test_Deadlock_Configuration()
{
    // Create organization with deadlock-prone thresholds
    var memberList = new OrganizationMemberList();
    for (int i = 0; i < 10; i++)
    {
        memberList.OrganizationMembers.Add(Address.FromPublicKey(Crypto.GenerateKeyPair().PublicKey));
    }
    
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = memberList,
        ProposerWhiteList = new ProposerWhiteList { Proposers = { memberList.OrganizationMembers[0] } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 6,
            MaximalRejectionThreshold = 2,
            MaximalAbstentionThreshold = 3,
            MinimalVoteThreshold = 10
        },
        CreationToken = HashHelper.ComputeFrom("test")
    };
    
    // This should pass validation (current bug)
    var orgAddress = AssociationContractStub.CreateOrganization.SendAsync(createInput).Result.Output;
    
    // Create a proposal
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = orgAddress,
        ToAddress = TokenContractAddress,
        ContractMethodName = "Transfer",
        Params = new Empty().ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    var proposalId = AssociationContractStub.CreateProposal.SendAsync(proposalInput).Result.Output;
    
    // Vote: 5 approvals, 2 rejections, 3 abstentions
    for (int i = 0; i < 5; i++)
        AssociationContractStub.Approve.SendAsync(proposalId).Result;
    for (int i = 5; i < 7; i++)
        AssociationContractStub.Reject.SendAsync(proposalId).Result;
    for (int i = 7; i < 10; i++)
        AssociationContractStub.Abstain.SendAsync(proposalId).Result;
    
    // Attempt to release - should fail with "Not approved" (DEADLOCK)
    var releaseResult = AssociationContractStub.Release.SendAsync(proposalId).Result;
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
}
```

## Notes

This vulnerability affects the fundamental governance mechanism of Association organizations. The asymmetric use of strict inequalities (>) for rejection/abstention checks versus non-strict inequality (>=) for approval creates an edge case where mathematical properties of the thresholds can result in proposals that cannot reach any terminal state. The fix requires adding a validation constraint that ensures the sum of the three thresholds does not exceed the member count, accounting for the inequality asymmetry.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-59)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }

    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```
