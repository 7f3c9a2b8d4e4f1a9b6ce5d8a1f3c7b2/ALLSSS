# Audit Report

## Title
Unbounded ReceivedTokenSymbols Growth Enables State Bloat and Iteration DoS on Profit Schemes

## Summary
The `ReceivedTokenSymbols` list in profit schemes lacks a size limit and can be populated by any user through unrestricted token contributions. When this list grows large (1000+ symbols), critical operations that iterate over all symbols—such as `DistributeProfits()`, `ClaimProfits()`, and `GetUndistributedDividends()`—will make excessive external contract calls that can exceed gas limits, causing operational denial-of-service for scheme managers and beneficiaries, particularly affecting critical infrastructure like the consensus dividend pool.

## Finding Description

**Root Cause - Unbounded List Definition:**

The `ReceivedTokenSymbols` field is defined as an unbounded repeated string field in the Scheme message structure without any maximum size constraint. [1](#0-0) 

**Population Without Access Control:**

The `ContributeProfits()` method allows any user to contribute tokens to any profit scheme with only minimal validation. [2](#0-1)  The only validation performed is `AssertTokenExists()` to verify the token exists. [3](#0-2)  When a new token symbol is contributed, it's automatically added to `ReceivedTokenSymbols` without any bound check. [4](#0-3) 

The list is also populated during sub-scheme distribution without bound checks. [5](#0-4) 

**Incorrect Assumption About TokenAmountLimit:**

The `TokenAmountLimit` constant exists in the codebase [6](#0-5)  but it only applies to method fee configuration, not to `ReceivedTokenSymbols`. [7](#0-6) 

**DoS Attack Vectors:**

1. **DistributeProfits() Iteration:** When `IsReleaseAllBalanceEveryTimeByDefault` is true and no specific amounts are provided, the function iterates over ALL symbols in `ReceivedTokenSymbols` and makes external `GetBalance` calls for each. [8](#0-7)  With 1000+ symbols, this creates 1000+ external contract calls that can exceed block gas limits.

2. **ProfitAllPeriods() Nested Loops:** This internal function iterates over symbols (or all symbols if no target specified) [9](#0-8)  and then iterates over periods for each symbol. [10](#0-9)  This creates nested loops with external calls that become prohibitively expensive.

3. **GetUndistributedDividends() in AEDPoS:** The consensus dividend pool's view method iterates all `ReceivedTokenSymbols` and makes external `GetBalance` calls for each. [11](#0-10)  This can timeout or fail with large symbol lists.

**Attack Execution Path:**

1. Attacker identifies target profit scheme (schemeId)
2. For each unique token symbol available on chain:
   - Call `ContributeProfits(schemeId, amount: 1, period: 0, symbol)`
   - Pay transaction fee (~1 ELF default) + minimal token amount
3. `ReceivedTokenSymbols` grows without limit
4. Legitimate scheme operations fail due to gas exhaustion

**Critical Systems Affected:**

TokenHolder contract creates schemes with `IsReleaseAllBalanceEveryTimeByDefault = true`, [12](#0-11)  making them vulnerable to this attack. Treasury contract also creates multiple schemes with this flag enabled. [13](#0-12) 

## Impact Explanation

**Operational Denial-of-Service:**
- Scheme managers cannot successfully call `DistributeProfits()` when schemes have `IsReleaseAllBalanceEveryTimeByDefault = true`, as the transaction will exceed gas limits
- Beneficiaries cannot claim their profits through `ClaimProfits()` when the calculation functions consume excessive gas
- Critical infrastructure like the consensus dividend pool becomes non-operational, potentially halting reward distributions
- View methods like `GetUndistributedDividends()` timeout, preventing monitoring and accounting

**Permanent State Bloat:**
- Each added symbol permanently increases the Scheme object's storage size
- No removal mechanism exists to clean up the symbol list
- Storage costs compound over time as more symbols are added

**Affected Systems:**
- Any profit scheme, but especially critical for:
  - Consensus dividend pools (disrupts validator rewards)
  - Treasury profit schemes (disrupts protocol revenue distribution)
  - TokenHolder schemes (disrupts staking rewards)

The severity is assessed as **Medium** due to the economic cost barrier (attacker must pay transaction fees), but the impact on critical consensus infrastructure justifies this severity level.

## Likelihood Explanation

**Attack Feasibility:**
- **Technical Complexity:** Very low - simply call `ContributeProfits()` repeatedly with different symbols
- **Permissions Required:** None - method is public and unrestricted
- **Economic Cost:** For 1000 symbols at ~1 ELF per transaction = ~1000 ELF total cost
- **Detection:** Attack is visible on-chain but difficult to prevent without protocol changes

**Attack Conditions:**
- More feasible on chains with many existing tokens
- More impactful when targeting schemes with `IsReleaseAllBalanceEveryTimeByDefault = true`
- Can be executed gradually over time to avoid detection
- Most dangerous when targeting critical protocol infrastructure

**Probability Assessment:**
**Medium-Low** likelihood overall. While technically simple and economically feasible for motivated attackers targeting high-value schemes (consensus pools worth disrupting), the upfront cost and sustained effort required reduce the probability for general profit schemes.

## Recommendation

Implement a maximum size limit for `ReceivedTokenSymbols`:

1. Add a constant in `ProfitContractConstants.cs`:
```csharp
public const int MaxReceivedTokenSymbols = 50;
```

2. Add validation in `ContributeProfits()` before adding new symbols:
```csharp
if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol))
{
    Assert(scheme.ReceivedTokenSymbols.Count < ProfitContractConstants.MaxReceivedTokenSymbols,
        "Scheme has reached maximum token symbol limit.");
    scheme.ReceivedTokenSymbols.Add(input.Symbol);
}
```

3. Apply the same check in `DistributeProfitsForSubSchemes()`.

Alternatively, consider restricting `ContributeProfits()` to require scheme manager authorization, or implement pagination for operations that iterate over all symbols.

## Proof of Concept

```csharp
[Fact]
public async Task ReceivedTokenSymbols_Unbounded_DoS_Attack()
{
    // Create a scheme with IsReleaseAllBalanceEveryTimeByDefault = true
    var createResult = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true
    });
    var schemeId = createResult.Output;
    
    // Attacker contributes many different token symbols
    // In production, this would be 1000+ symbols causing DoS
    for (int i = 0; i < 100; i++)
    {
        var tokenSymbol = $"TOKEN{i}";
        // Create token (assume tokens exist on chain)
        await TokenContractStub.Create.SendAsync(new CreateInput
        {
            Symbol = tokenSymbol,
            TokenName = $"Token {i}",
            TotalSupply = 1000000,
            Issuer = DefaultAddress
        });
        
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = tokenSymbol,
            Amount = 100,
            To = AttackerAddress
        });
        
        // Attacker contributes minimal amount
        await TokenContractStubAttacker.Approve.SendAsync(new ApproveInput
        {
            Spender = ProfitContractAddress,
            Symbol = tokenSymbol,
            Amount = 1
        });
        
        await ProfitContractStubAttacker.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Symbol = tokenSymbol,
            Amount = 1,
            Period = 0
        });
    }
    
    // Verify ReceivedTokenSymbols has grown
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    scheme.ReceivedTokenSymbols.Count.ShouldBe(100);
    
    // Now DistributeProfits will iterate 100+ symbols with external calls
    // With 1000+ symbols, this would exceed gas limits and cause DoS
    var distributeTx = await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    // In production with 1000+ symbols, this transaction would fail due to gas exhaustion
}
```

## Notes

The vulnerability is exacerbated by the fact that critical protocol infrastructure (TokenHolder, Treasury, Consensus dividend pools) all use `IsReleaseAllBalanceEveryTimeByDefault = true`, making them prime targets. The economic cost of ~1000 ELF is non-trivial but feasible for motivated attackers seeking to disrupt validator rewards or treasury operations. The lack of any removal mechanism means the attack has permanent effects on scheme usability.

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L447-460)
```csharp
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L501-508)
```csharp
    private void AssertTokenExists(string symbol)
    {
        if (string.IsNullOrEmpty(State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput { Symbol = symbol })
                .TokenName))
        {
            throw new AssertionException($"Token {symbol} not exists.");
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-666)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-851)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L853-915)
```csharp
        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L14-14)
```csharp
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L147-161)
```csharp
    public override Dividends GetUndistributedDividends(Empty input)
    {
        var scheme = GetSideChainDividendPoolScheme();
        return new Dividends
        {
            Value =
            {
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
            }
        };
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```
