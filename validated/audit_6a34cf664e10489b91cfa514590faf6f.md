# Audit Report

## Title
Organization Member List Manipulation Allows Governance Bypass Through Post-Creation Vote Manipulation

## Summary
The Association contract lacks a member list snapshot mechanism at proposal creation time. Instead, it dynamically validates voting authorization and counts votes against the current organization member list. This allows organizations to manipulate governance outcomes by retroactively invalidating votes through member list modifications after voting has occurred.

## Finding Description

The vulnerability stems from the Association contract's use of the current organization member list for both vote authorization and vote counting, rather than maintaining a snapshot from proposal creation time.

**Flaw 1: Dynamic Member Authorization During Voting**

When members attempt to vote, the contract validates authorization against the current member list. The voting functions (`Approve`, `Reject`, `Abstain`) all invoke `AssertIsAuthorizedOrganizationMember` which checks if the voter exists in the current `organization.OrganizationMemberList`. [1](#0-0) [2](#0-1) 

**Flaw 2: Vote Counting Uses Current Member List**

When determining if a proposal meets release thresholds, the contract filters votes by checking if voters exist in the current member list using `.Count(organization.OrganizationMemberList.Contains)`:

- Rejection counting: [3](#0-2) 
- Abstention counting: [4](#0-3)   
- Approval counting: [5](#0-4) 

**Root Cause: No Member List Snapshot**

The `ProposalInfo` structure only stores the organization address reference, not a member list snapshot. [6](#0-5) 

**Exploitation Path: Member List Modification**

Organizations can modify their member lists through three functions callable by the organization itself (via proposal execution):

- `AddMember`: [7](#0-6) 
- `RemoveMember`: [8](#0-7) 
- `ChangeMember`: [9](#0-8) 

These functions require `Context.Sender` to be the organization address, which occurs when proposals are executed via the `Release` function using `SendVirtualInlineBySystemContract`. [10](#0-9) 

## Impact Explanation

This vulnerability has **CRITICAL** impact on governance integrity:

1. **Vote Invalidation Attack**: Organizations can execute a proposal to remove members who voted against a controversial proposal. When the original proposal's release threshold is checked, those removed members' votes are filtered out because the vote counting logic checks if voters exist in the current member list. This can flip a failing proposal into passing.

2. **Vote Dilution Attack**: Organizations can execute a proposal to add new members favorable to a pending proposal. These new members can then vote on the existing proposal, even though they weren't members when the proposal was created.

3. **Threshold Manipulation**: By strategically modifying membership, attackers can manipulate effective voting thresholds. For example:
   - Initial state: 5 members, MinimalApproval=2, MaximalRejection=1
   - Proposal P1: 2 approvals, 2 rejections (fails due to exceeding MaximalRejection)
   - Execute proposal to remove both rejecting members  
   - P1 now counts: 2 approvals, 0 rejections (passes)

**Comparison with Parliament Contract**: The Parliament contract also uses dynamic member lists but queries current miners from the consensus contract, which cannot be arbitrarily manipulated by governance proposals. [11](#0-10)  Association's design creates a circular dependency where proposals can modify the list that validates proposals.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

**Attack Complexity: LOW**
- Only requires creating and executing standard proposals using designed contract features
- No need for special privileges beyond normal organization operation

**Attacker Requirements:**
- Ability to pass at least one proposal to modify membership (standard capability)
- Common in organizations with multiple factions or contested governance

**Realistic Scenario:**
1. Organization has 5 members: A, B, C, D, E with MinimalApproval=2, MaximalRejection=1
2. Controversial Proposal P1 created (e.g., treasury allocation)
3. Votes cast: A, B approve; C, D reject; E abstains
4. Proposal P1 fails (2 rejections exceeds MaximalRejection=1)
5. Faction controlling A, B, E creates Proposal P2: "Remove members C and D"
6. Proposal P2 passes (3 votes meet threshold)
7. P2 executes via Release, removing C and D from member list
8. Now when checking P1 release threshold: rejection count = 0 (C and D not in current list)
9. P1 may now pass

## Recommendation

Implement a member list snapshot mechanism at proposal creation time. Store the member list in `ProposalInfo` instead of just the organization address:

1. **Modify ProposalInfo structure** to include member list snapshot
2. **Update vote counting logic** to filter votes against the snapshotted member list, not the current organization member list
3. **Update vote authorization** to check against the proposal's member snapshot

Alternative: Implement proposal locking that prevents member list modifications while any proposal is pending.

## Proof of Concept

```csharp
// Test demonstrating vote invalidation through member removal
[Fact]
public async Task VoteInvalidationAttack_RemovingMembersInvalidatesTheirVotes()
{
    // Setup: Create organization with 5 members
    var members = new[] { MemberA, MemberB, MemberC, MemberD, MemberE };
    var organizationAddress = await CreateOrganization(
        members,
        minimalApproval: 2,
        maximalRejection: 1);
    
    // Step 1: Create controversial proposal P1
    var proposalP1 = await CreateProposal(organizationAddress, "TransferFunds", params);
    
    // Step 2: Cast votes - 2 approvals, 2 rejections (fails due to MaximalRejection)
    await ApproveProposal(proposalP1, MemberA);
    await ApproveProposal(proposalP1, MemberB);
    await RejectProposal(proposalP1, MemberC);
    await RejectProposal(proposalP1, MemberD);
    
    // Verify P1 cannot be released (too many rejections)
    var canReleaseP1Before = await CanRelease(proposalP1);
    Assert.False(canReleaseP1Before);
    
    // Step 3: Create and pass proposal P2 to remove rejecting members
    var proposalP2 = await CreateProposal(organizationAddress, "RemoveMember", MemberC);
    await ApproveProposal(proposalP2, MemberA);
    await ApproveProposal(proposalP2, MemberB);
    await ApproveProposal(proposalP2, MemberE);
    await ReleaseProposal(proposalP2);
    
    var proposalP3 = await CreateProposal(organizationAddress, "RemoveMember", MemberD);
    await ApproveProposal(proposalP3, MemberA);
    await ApproveProposal(proposalP3, MemberB);
    await ApproveProposal(proposalP3, MemberE);
    await ReleaseProposal(proposalP3);
    
    // Step 4: Check if P1 can now be released (votes from removed members don't count)
    var canReleaseP1After = await CanRelease(proposalP1);
    
    // VULNERABILITY: P1 can now pass because rejection votes are invalidated
    Assert.True(canReleaseP1After); // This should be False but is True due to vulnerability
}
```

---

**Notes:**
This is a fundamental design flaw in the Association contract's governance model. The dynamic member list evaluation creates a time-of-check-time-of-use (TOCTOU) vulnerability where the membership used for voting authorization differs from the membership used for vote counting. This breaks the governance invariant that votes cast by authorized members should remain valid regardless of subsequent membership changes.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```
