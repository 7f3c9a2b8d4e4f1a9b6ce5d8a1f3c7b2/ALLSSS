# Audit Report

## Title
Missing LIB Height Validation in NextTerm Allows Malicious Miner to Corrupt Blockchain Finality

## Summary
The `NextTerm` consensus operation does not validate the `ConfirmedIrreversibleBlockHeight` (LIB) field in its input, allowing a malicious miner to provide arbitrary LIB values when transitioning to a new term. This corrupted LIB height is then persisted to state and propagates to future rounds, enabling manipulation of blockchain finality guarantees.

## Finding Description

The vulnerability exists in the asymmetric validation between `NextTerm` and `UpdateValue` consensus operations in the AEDPoS consensus mechanism.

**Missing Validation in NextTerm**: When the `NextTerm` method is called, it delegates to `ProcessConsensusInformation` which only performs permission checks via `PreCheck()` to verify the sender is a miner. [1](#0-0)  The validation providers registered for `NextTerm` behavior include only `RoundTerminateValidationProvider`, which validates round and term numbers but NOT LIB fields. [2](#0-1) 

**RoundTerminateValidationProvider Limitations**: This validator only checks that the term number increments by 1 and delegates to round number validation, without any checks on `ConfirmedIrreversibleBlockHeight` or `ConfirmedIrreversibleBlockRoundNumber`. [3](#0-2) 

**Comparison - UpdateValue Has Protection**: In contrast, `UpdateValue` operations register `LibInformationValidationProvider` which explicitly checks that LIB values do not decrease. [4](#0-3)  The `LibInformationValidationProvider` validates that both `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` never go backwards. [5](#0-4) 

**Unvalidated Input Propagation**: The `NextTermInput.ToRound()` method directly copies the attacker-controlled `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values from the input to the Round object without any validation. [6](#0-5) 

**Direct Persistence**: The `ProcessNextTerm` function takes the round from `input.ToRound()` and persists it to state via `AddRoundInformation`. [7](#0-6)  The `AddRoundInformation` method directly writes the Round object to state without performing any field validation. [8](#0-7) 

**Attack Execution**: A malicious miner can call the view method `GetConsensusExtraDataForNextTerm` to obtain a legitimate `NextTermInput` where the LIB is correctly copied from the current round. [9](#0-8)  The attacker then modifies the `ConfirmedIrreversibleBlockHeight` field to any arbitrary value (higher or lower than legitimate) before submitting the `NextTerm` transaction, bypassing all validation and persisting the corrupted value to blockchain state.

## Impact Explanation

The Last Irreversible Block (LIB) height is a critical consensus invariant that determines blockchain finality. The ability to arbitrarily manipulate this value has severe consequences:

**Premature Finality (LIB set too high)**: If a malicious miner sets the LIB height higher than the legitimate value, blocks that have not achieved sufficient miner consensus (2/3+) would be incorrectly marked as final. This violates Byzantine fault tolerance guarantees and could enable acceptance of fraudulent cross-chain transfers, invalid state finalization, and potential chain splits if different nodes have divergent finality views.

**Finality Reversion (LIB set too low)**: Setting the LIB lower than the legitimate value makes blocks that should be irreversible subject to reorganization, enabling double-spend attacks on transactions that appeared finalized and reversion of cross-chain message commitments, breaking the "once confirmed, always confirmed" guarantee.

**Propagation Effect**: The corrupted LIB value persists in blockchain state and is inherited by subsequent rounds and terms via the off-chain generation process, causing long-term corruption of the finality mechanism until manually detected and corrected.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be a legitimate miner in the current or previous round to pass the `PreCheck()` permission validation. [10](#0-9) 

**Attack Complexity**: The attack is straightforward with LOW complexity:
1. Call the view method to obtain legitimate `NextTermInput` data
2. Modify the `ConfirmedIrreversibleBlockHeight` field to desired malicious value
3. Submit the `NextTerm` transaction during term transition
4. Transaction validation passes (only round/term numbers checked)
5. Corrupted LIB is persisted to state

**Feasibility**: HIGH - The attack requires only parameter manipulation at transaction submission time with no complex timing requirements, race conditions, or reliance on external state. Any miner can execute this unilaterally without collusion.

**Detection Difficulty**: Real-time detection is difficult as the malicious transaction appears structurally valid and will be accepted by all nodes. The corruption would only be noticed when analyzing LIB progression patterns or when finality-dependent operations (like cross-chain transfers) behave unexpectedly.

## Recommendation

Add `LibInformationValidationProvider` to the validation provider list for `NextTerm` behavior, making it consistent with `UpdateValue` validation. In `AEDPoSContract_Validation.cs`, modify the switch case for `NextTerm` to include the LIB validator:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider());  // Add this line
    break;
```

This ensures that any attempt to provide LIB values that go backwards will be rejected during the validation phase, preventing corruption of the finality mechanism.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up an AEDPoS contract with multiple miners in a running term
2. Have a miner obtain legitimate `NextTermInput` via the view method
3. Modify the `ConfirmedIrreversibleBlockHeight` to an arbitrary value (e.g., current LIB - 100 or current LIB + 1000)
4. Submit the `NextTerm` transaction with modified input
5. Verify the transaction succeeds and the corrupted LIB value is persisted in the new round
6. Confirm subsequent rounds inherit the corrupted LIB value

This demonstrates that LIB validation is missing for `NextTerm` operations while being present for `UpdateValue` operations, creating an exploitable validation gap that corrupts blockchain finality guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-43)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L163-196)
```csharp
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-20)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```
