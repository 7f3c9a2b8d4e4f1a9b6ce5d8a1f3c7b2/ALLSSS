# Audit Report

## Title
Proposer Whitelist Bypass - Removed Proposers Can Execute Approved Proposals

## Summary
The `Release` method in Association, Parliament, and Referendum governance contracts fails to re-validate whether the caller remains in the organization's proposer whitelist. This allows proposers who have been removed from the whitelist via `ChangeOrganizationProposerWhiteList` to retain execution authority for previously approved proposals, creating a critical authorization bypass.

## Finding Description

The vulnerability exists across all three governance contracts due to insufficient authorization validation in the `Release` method.

**Proposal Creation - Whitelist Validated:**
When a proposal is created, the system validates the proposer's whitelist membership. [1](#0-0) 

This validation strictly checks the proposer against the current whitelist: [2](#0-1) 

The same pattern exists in Parliament [3](#0-2)  and Referendum [4](#0-3) 

**Whitelist Updates Allowed:**
Organizations can update their proposer whitelist at any time through governance: [5](#0-4) 

**Proposal Release - No Whitelist Re-Check:**
When releasing an approved proposal, only the original proposer identity is verified: [6](#0-5) 

The critical flaw is that the check `Context.Sender == proposalInfo.Proposer` verifies the caller is the original proposer, but never re-validates whether this proposer is still in the current whitelist stored in `organization.ProposerWhiteList`. Once a proposer creates a proposal and gets it approved, they retain release authority indefinitely (until expiration), even after being explicitly removed from the whitelist.

The whitelist check using the `Contains` extension method is never re-evaluated at release time: [7](#0-6) 

The identical pattern exists in Parliament [8](#0-7)  and Referendum [9](#0-8) 

## Impact Explanation

**HIGH Severity** - This vulnerability represents a fundamental authorization bypass with severe consequences:

1. **Authorization Invariant Violation:** The proposer whitelist is a core security control mechanism. When organizations remove a proposer from the whitelist (due to compromise, discovered malicious intent, or changed trust model), they reasonably expect this revokes all governance authority. However, removed proposers retain full execution rights for any approved proposals.

2. **Arbitrary Contract Execution:** The `Release` method executes arbitrary contract calls on behalf of the organization's virtual address, which can invoke any contract method including token transfers from organization treasury, contract upgrades and deployments, permission and configuration changes, and cross-chain operations.

3. **Real Attack Scenarios:**
   - **Compromised Account:** Organization detects proposer account compromise and removes them from whitelist, but attacker can still execute approved proposals
   - **Malicious Proposer Discovery:** Proposer's malicious intent discovered after approval (through parameter obfuscation), but whitelist removal doesn't prevent execution
   - **Changed Trust Model:** Organization needs to reduce proposer set for security, but cannot revoke release rights for existing approved proposals

4. **No Effective Mitigation:** The only defense is waiting for proposal expiration and using `ClearProposal` [10](#0-9)  requiring organizations to wait the entire proposal lifetime (typically days) while the removed proposer can execute at will.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is highly feasible to exploit:

1. **Low Attacker Capabilities:** Attacker must only initially be in proposer whitelist (normal operational state) and create a proposal that gets approved (standard governance flow). No special technical exploits, economic resources, or timing attacks required.

2. **Low Attack Complexity:** The exploit is straightforward: (1) Create proposal while whitelisted, (2) Wait for organization member approval, (3) After being removed from whitelist via `ChangeOrganizationProposerWhiteList`, call `Release`, (4) Release succeeds because it only checks `Context.Sender == proposalInfo.Proposer`.

3. **Realistic Triggering Conditions:** Account compromise is a realistic operational risk requiring immediate whitelist removal. Discovering proposer malicious intent post-approval is common in governance. Organizations regularly need to update their trust model and proposer set. Extended attack window exists from approval to expiration (typically days).

## Recommendation

Add proposer whitelist re-validation in the `Release` method before executing the proposal. The fix should call `AssertIsAuthorizedProposer` or manually check `organization.ProposerWhiteList.Contains(proposalInfo.Proposer)` to ensure the proposer is still authorized at release time.

For Association contract, modify the `Release` method:

```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // ADD THIS LINE: Re-validate proposer is still in whitelist
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, proposalInfo.Proposer);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposalInfo.ToAddress,
        proposalInfo.ContractMethodName, proposalInfo.Params);
    // ... rest of method
}
```

Apply the same fix to Parliament and Referendum contracts.

## Proof of Concept

The existing test suite demonstrates the expected behavior that whitelist removal should prevent proposal operations: [11](#0-10) 

This test shows that after `ChangeOrganizationProposerWhiteList` executes, the removed proposer cannot create NEW proposals (line 827-829 expects "Unauthorized to propose" error). However, there is no corresponding test validating that removed proposers also cannot RELEASE existing approved proposals, revealing the gap in authorization enforcement.

A proof-of-concept test would:
1. Create organization with proposer P in whitelist
2. P creates proposal and gets it approved
3. Execute ChangeOrganizationProposerWhiteList to remove P
4. P calls Release - currently SUCCEEDS (vulnerability)
5. Expected behavior: Release should FAIL with "Unauthorized to propose"

## Notes

This vulnerability represents a critical inconsistency in the authorization model where whitelist enforcement is applied at proposal creation but not at proposal release. The existence of `ChangeOrganizationProposerWhiteList` and test expectations confirm that whitelist changes are intended to immediately affect proposer privileges. The security invariant "only current whitelist members can interact with governance proposals" is violated specifically for the Release operation, allowing removed proposers to retain execution authority indefinitely until proposal expiration.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L29-32)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L827-829)
```csharp
        var result = await associationContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
```
