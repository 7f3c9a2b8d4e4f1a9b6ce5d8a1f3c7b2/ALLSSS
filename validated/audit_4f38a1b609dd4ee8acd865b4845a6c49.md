# Audit Report

## Title
Missing Miners Count Validation in NextTerm Allows Bypass of Maximum Miner Restrictions

## Summary
The `ProcessNextTerm` method accepts a `NextTermInput` parameter and sets the miner list directly from the input without validating that the number of miners respects the governance-controlled `MaximumMinersCount`. A malicious miner can exploit this by calling the public `NextTerm` method with a crafted input containing an excessive number of miners, bypassing the restriction enforced by `SetMaximumMinersCount`.

## Finding Description

The vulnerability exists in the consensus contract's term transition logic. When `NextTerm` is called, it processes the input through `ProcessConsensusInformation`, which performs a permission check via `PreCheck()`. However, this check only validates that the **caller** is in the current or previous miner list, not the **content** of the provided input. [1](#0-0) 

The `ProcessNextTerm` method then converts the input to a Round object and directly uses all keys from `nextRound.RealTimeMinersInformation` to create the new miner list: [2](#0-1) 

Critically, there is **no validation** that `nextRound.RealTimeMinersInformation.Count` is within the allowed maximum set by `State.MaximumMinersCount.Value`.

While `UpdateMinersCountToElectionContract` is called at line 176, this method only **reports** the calculated count to the Election Contract but does not **enforce** it: [3](#0-2) 

The `GetMinersCount` helper method calculates what the count **should be** based on blockchain age and the maximum constraint, but this is only used for reporting purposes: [4](#0-3) 

The validation framework for `NextTerm` behavior only checks round and term number correctness, not the miner count: [5](#0-4) [6](#0-5) 

The `NextTerm` RPC method is publicly accessible to any caller: [7](#0-6) 

A malicious miner can construct a `NextTermInput` with arbitrary miner entries since the factory method performs no validation: [8](#0-7) 

This bypasses the governance control mechanism where `SetMaximumMinersCount` requires Parliament authorization: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Impact:**
This vulnerability allows an attacker to bypass the governance-controlled maximum miners count, which is a critical consensus parameter. The attacker can inflate the miner set to an arbitrary size (e.g., 1000 miners instead of the intended 17), breaking the fundamental invariant that the miner schedule must respect governance decisions.

**Operational Impact:**
- **Performance Degradation**: An excessive number of miners would significantly degrade consensus performance and block production efficiency
- **DoS Conditions**: The computational overhead of managing hundreds or thousands of validators could cause denial-of-service conditions
- **Reward Distribution Impact**: Mining reward calculations and distributions would be spread across an inflated miner set, affecting the economics of the system
- **Snapshot Processing**: Election snapshot operations and treasury releases would process excessive miner data

**Governance Impact:**
This directly undermines the governance control mechanism. The Parliament organization sets `MaximumMinersCount` through a formal proposal and approval process to maintain optimal consensus performance. This vulnerability allows a single malicious miner to unilaterally override that governance decision.

## Likelihood Explanation

**Attacker Capabilities:**
The attacker must be a current or previous round miner to pass the `PreCheck` validation. This is a realistic precondition since:
- Any miner in the active set can execute this attack
- The threat model considers insider attacks from miners within the normal threat boundary
- Being in the previous round's miner list still grants access

**Attack Complexity:**
The attack is straightforward to execute:
1. Attacker constructs a `NextTermInput` with excessive `RealTimeMinersInformation` entries
2. Attacker calls the public `NextTerm` RPC method with this crafted input
3. The transaction passes all current validations and updates the miner list

**Execution Practicality:**
- Direct RPC call to a public method
- No complex state manipulation required
- Single transaction execution
- No race conditions or timing dependencies

**Detection:**
The attack would be immediately visible on-chain as the miner list suddenly expands beyond the configured maximum. However, prevention is difficult since the transaction passes all existing validations. Recovery requires another term transition with the correct miner count.

## Recommendation

Add explicit validation in the `ProcessNextTerm` method to ensure the miner count does not exceed the governance-controlled maximum:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // Validate miner count against maximum
    Assert(nextRound.RealTimeMinersInformation.Count <= State.MaximumMinersCount.Value,
        $"Miner count {nextRound.RealTimeMinersInformation.Count} exceeds maximum allowed {State.MaximumMinersCount.Value}");
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of the method
}
```

Alternatively, add validation to ensure the provided miner list matches the expected election results by cross-checking with `State.ElectionContract.GetVictories` on the main chain.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_ExcessiveMinersCount_ShouldFail()
{
    // Setup: Initialize consensus with a maximum miner count of 5
    await InitializeConsensusContract();
    await SetMaximumMinersCountViaGovernance(5);
    
    // Attacker is a current miner
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var attackerStub = GetAEDPoSContractStub(attackerKeyPair);
    
    // Get current round information
    var currentRound = await attackerStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Craft malicious NextTermInput with 10 miners (exceeds maximum of 5)
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        RealTimeMinersInformation = { CreateExcessiveMinerList(10) } // 10 > 5
    };
    
    // Generate valid random number for the input
    var randomNumber = await GenerateRandomProofAsync(attackerKeyPair);
    maliciousNextTermInput.RandomNumber = ByteString.CopyFrom(randomNumber);
    
    // Execute attack: Call NextTerm with excessive miners
    var result = await attackerStub.NextTerm.SendAsync(maliciousNextTermInput);
    
    // VULNERABILITY: Transaction succeeds when it should fail
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify the miner list was set with 10 miners, bypassing the maximum of 5
    var newMinerList = await attackerStub.GetCurrentMinerList.CallAsync(new Empty());
    newMinerList.Pubkeys.Count.ShouldBe(10); // Exceeds governance maximum!
    
    var maxMinersCount = await attackerStub.GetMaximumMinersCount.CallAsync(new Empty());
    maxMinersCount.Value.ShouldBe(5); // Maximum is still 5
    
    // Assert: Miner count exceeds maximum, proving the vulnerability
    Assert.True(newMinerList.Pubkeys.Count > maxMinersCount.Value);
}
```

## Notes

This vulnerability represents a critical consensus integrity issue. The normal flow expects miners to obtain term transition data through `GetConsensusExtraData`, which calls `GenerateFirstRoundOfNextTerm` to fetch legitimate election winners from the Election Contract. However, since `ProcessNextTerm` accepts arbitrary input without validation, a malicious miner can bypass this legitimate flow and inject a crafted miner list. The fix should either validate the count or cross-reference the Election Contract's results during term transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```
