# Audit Report

## Title
NFT Token Hash Collision via Insecure String Concatenation Key Generation

## Summary
The NFT contract generates token hashes by directly concatenating symbol strings with tokenId before hashing, enabling collision attacks where different (symbol, tokenId) pairs produce identical state keys. An attacker who creates NFT protocols with strategically chosen short symbols can collide with existing NFTs, causing balance confusion, metadata corruption, and state integrity violations.

## Finding Description

The root cause lies in the `CalculateTokenHash` method which performs undelimited string concatenation before hashing: [1](#0-0) 

This design creates deterministic collision opportunities. For example:
- Protocol A: symbol="AR1", tokenId=23 → hash("AR123")  
- Protocol B: symbol="AR12", tokenId=3 → hash("AR123")
- Protocol C: symbol="AR", tokenId=123 → hash("AR123")

All three produce identical tokenHash values despite representing distinct NFTs from different protocols.

The vulnerability is exploitable because while the `Create` method auto-generates symbols with minimum 11 characters (2-char NFT type prefix + 9-digit random number): [2](#0-1) [3](#0-2) 

The `CrossChainCreate` method accepts arbitrary symbols from the Token contract without length validation: [4](#0-3) 

An attacker can create tokens with short symbols in the MultiToken contract (requiring seed NFT or whitelist access), then register them as NFT protocols via `CrossChainCreate`. The Token contract's symbol validation only checks maximum length, not minimum: [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

The collision affects all state mappings using tokenHash as the key: [9](#0-8) 

When minting occurs, the colliding tokenHash causes state corruption: [10](#0-9) 

## Impact Explanation

**HIGH Severity** - Direct state corruption enabling NFT asset manipulation:

1. **Balance Confusion**: `BalanceMap[tokenHash][address]` becomes shared between colliding NFTs. When Protocol B mints a colliding token, it adds to the same balance entry as Protocol A's NFT, causing incorrect ownership tracking.

2. **Metadata Overwrite**: `NftInfoMap[tokenHash]` can only store one NFTInfo structure. Later mints overwrite earlier NFT metadata (URI, alias, quantity) at line 439, destroying the victim's NFT data.

3. **Allowance Ambiguity**: `AllowanceMap[tokenHash][owner][spender]` approvals become indistinguishable between colliding NFTs, enabling unauthorized transfers.

4. **Protocol Integrity Violation**: The fundamental guarantee that each (symbol, tokenId) pair uniquely identifies an NFT is broken, violating the NFT uniqueness invariant.

**Concrete Attack Scenario:**
- Victim's NFT: symbol="AR100000000" (auto-generated), tokenId=1 → Hash("AR1000000001")
- Attacker creates token "AR10000000" via seed NFT, registers as NFT protocol
- Attacker mints tokenId=01 → Hash("AR1000000001") - **COLLISION**
- If `IsTokenIdReuse=true`: Attacker's mint adds to victim's quantity and overwrites metadata
- If `IsTokenIdReuse=false`: Victim's NFT becomes unmintable by attacker (DoS), but existing state is still corrupted

## Likelihood Explanation

**MEDIUM Likelihood** - Feasible attack path with economic but not cryptographic barriers:

**Attack Prerequisites:**
1. Create short-symbol token in MultiToken contract - Requires:
   - Seed NFT ownership (economic cost, publicly acquirable), OR
   - Whitelist membership (genesis/parliament/economic/crosschain contracts) [11](#0-10) [12](#0-11) 

2. Register as NFT protocol via `CrossChainCreate` - No authorization required (public method)

3. Calculate collision - Deterministic mathematical computation

**Feasibility Analysis:**
- Seed NFT barrier is economic, not technical - attackers can purchase
- Whitelist includes legitimate system contracts that could create short symbols accidentally
- Cross-chain scenarios may enable symbol creation on side chains with different policies
- Collision math is deterministic and easily calculable
- No runtime detection or prevention of collisions

## Recommendation

Implement delimiter-based or length-normalized hash key generation:

**Option 1: Add Fixed Delimiter**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}#{tokenId}");
}
```

**Option 2: Use Structured Hash Input**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    var input = new TokenHashInput 
    { 
        Symbol = symbol, 
        TokenId = tokenId 
    };
    return HashHelper.ComputeFrom(input.ToByteString());
}
```

**Additional Hardening:**
1. Enforce minimum symbol length in `CrossChainCreate`:
```csharp
Assert(input.Symbol.Length >= 11, "NFT symbol too short - collision risk");
```

2. Add collision detection in minting:
```csharp
var existingInfo = State.NftInfoMap[tokenHash];
if (existingInfo != null && existingInfo.Symbol != input.Symbol)
{
    throw new AssertionException("Token hash collision detected");
}
```

## Proof of Concept

The following test demonstrates the collision vulnerability:

```csharp
// Test: NFT_TokenHash_Collision_Attack
// 1. Create two tokens with symbols "AR1" and "AR12" 
//    (requires seed NFT or whitelist)
// 2. Register both as NFT protocols via CrossChainCreate
// 3. Mint NFT from Protocol A: symbol="AR1", tokenId=23
// 4. Mint NFT from Protocol B: symbol="AR12", tokenId=3
// 5. Verify both produce Hash("AR123")
// 6. Observe balance/metadata corruption in shared state
```

**Test Steps:**
1. Setup: Create seed NFTs for "AR1" and "AR12" tokens
2. Call `Token.Create` for both symbols with NFT external info
3. Call `NFT.CrossChainCreate` for both symbols
4. Mint "AR1" tokenId=23 to Address A
5. Mint "AR12" tokenId=3 to Address B  
6. Verify `CalculateTokenHash("AR1", 23) == CalculateTokenHash("AR12", 3)`
7. Observe shared `BalanceMap` entry and metadata overwrite

## Notes

This vulnerability affects the core NFT identification mechanism. The lack of proper delimiter or length normalization in `CalculateTokenHash` violates the assumption that different (symbol, tokenId) pairs produce unique hashes. While the `Create` method generates collision-resistant symbols, the `CrossChainCreate` bypass combined with Token contract's permissive symbol validation enables the attack. The economic barrier (seed NFT) provides some protection but does not eliminate the fundamental design flaw, especially in cross-chain or governance scenarios where privileged actors might legitimately create short symbols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-441)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-36)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-93)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L305-311)
```csharp
    private void CheckSymbolLength(string symbol, SymbolType symbolType)
    {
        if (symbolType == SymbolType.Token)
            Assert(symbol.Length <= TokenContractConstants.SymbolMaxLength, "Invalid token symbol length");
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
            Assert(symbol.Length <= TokenContractConstants.NFTSymbolMaxLength, "Invalid NFT symbol length");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L20-20)
```csharp
    public const int NFTSymbolMaxLength = 30;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-33)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-66)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L259-265)
```csharp
    private bool IsAddressInCreateWhiteList(Address address)
    {
        return address == Context.GetZeroSmartContractAddress() ||
               address == GetDefaultParliamentController().OwnerAddress ||
               address == Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName) ||
               address == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);
    }
```
