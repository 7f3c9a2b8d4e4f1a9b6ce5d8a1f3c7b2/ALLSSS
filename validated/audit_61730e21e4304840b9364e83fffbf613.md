# Audit Report

## Title
ArrangeAbnormalMiningTime Allows Single Miner to Claim Multiple Saving Time Slots and Inflate ProducedBlocks Counter

## Summary
The `ArrangeAbnormalMiningTime` function calculates saving time slots using a stateless time-based formula without verifying whether a miner has already produced blocks in the current round. This allows a malicious miner to exploit multiple non-overlapping saving slots during stalled rounds, repeatedly calling `UpdateValue` to inflate their `ProducedBlocks` counter, which directly impacts mining reward distribution and consensus reputation.

## Finding Description

The vulnerability exists in the saving slot validation logic within the `IsCurrentMiner` method. The saving slot check calculates a time window based on elapsed time but fails to verify whether the miner has already participated in the current round. [1](#0-0) 

The `ArrangeAbnormalMiningTime` function uses a stateless time-based calculation where `missedRoundsCount` is computed as `(currentTime - roundStartTime) / totalRoundTime`. As time advances without `NextRound` being called, `missedRoundsCount` increases, creating new saving slots at regular intervals. [2](#0-1) 

**Why existing protections fail:**

1. **No state verification in saving slot logic**: The saving slot check does not examine `ActualMiningTimes` or `OutValue` to determine if the miner has already produced blocks. The validation only checks if the current time falls within the calculated saving slot window.

2. **TimeSlotValidationProvider only validates normal slots**: The time slot validator checks against `ExpectedMiningTime` (normal mining slots), not the dynamically calculated saving slots. [3](#0-2) 

3. **EnsureTransactionOnlyExecutedOnceInOneBlock permits cross-block exploitation**: This protection only prevents multiple consensus transactions within a single block height, not across multiple blocks. [4](#0-3) 

4. **ProcessUpdateValue unconditionally increments ProducedBlocks**: Each `UpdateValue` call increments the counter without checking whether the miner has already contributed to the round. [5](#0-4) 

5. **UpdateValueValidationProvider does not check base round state**: The validator only verifies that OutValue and Signature are filled in the provided round data, not whether OutValue is already set in the base round state. [6](#0-5) 

## Impact Explanation

**Direct Impact on Reward Distribution:**

Mining rewards are calculated based on `ProducedBlocks` counters. The `GetMinedBlocks` method sums all miners' `ProducedBlocks` to determine total mining rewards. [7](#0-6) 

These rewards are then donated to the Treasury contract for distribution. [8](#0-7) 

The Treasury contract calculates individual miner shares using their `ProducedBlocks` counts, where higher counts yield proportionally larger rewards through the `CalculateShares` function. [9](#0-8) 

**Consensus Reputation Impact:**

The `ProducedBlocks` counter is propagated to the Election contract via `UpdateCandidateInformation`, directly affecting candidate statistics and indirectly influencing miner rankings. [10](#0-9) 

**Quantified Damage:**
- With 17 miners and 4000ms intervals: `totalRoundTime = 72000ms`
- In a 10-minute stalled round: attacker gets approximately 8 saving slots
- Result: 8x inflated `ProducedBlocks` = 8x mining rewards
- If base reward is 100 ELF per block, attacker steals 700 ELF from honest miners

**Affected Parties:**
- Honest miners receive diluted rewards
- Token holders face disproportionate emissions to malicious actors
- Election integrity is compromised by inflated reputation metrics

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be an active miner in the current round (feasible for any current consensus participant)
- Round must remain un-terminated (no `NextRound` call) for extended periods
- Attacker must produce blocks at multiple saving slot intervals

**Feasibility:**
The saving slot mechanism is explicitly designed to handle stalled rounds where miners miss their normal time slots. Such scenarios naturally occur during network coordination failures, consensus delays, or temporary miner unavailability.

The behavior determination logic shows that once a miner has produced blocks (`OutValue != null`), they should proceed to round termination rather than additional mining. However, the saving slot check in `IsCurrentMiner` bypasses this intended logic. [11](#0-10) 

**Attack Complexity:**
Low - the attacker simply waits for saving slot windows to open and calls `UpdateValue` at each interval. No cryptographic attacks or complex exploit chains are required.

**Detection:**
While multiple `ActualMiningTimes` entries for a single miner in one round are visible on-chain, the protocol currently treats this as valid behavior with no automated detection or penalty mechanisms.

## Recommendation

Add state verification to the saving slot check in `IsCurrentMiner` to ensure miners cannot exploit multiple saving slots after already producing blocks in the current round:

```csharp
// Check saving extra block time slot.
var nextArrangeMiningTime = currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());

// NEW: Verify miner hasn't already produced blocks in this round
if (minerInRound.OutValue != null)
{
    Context.LogDebug(() => "[CURRENT MINER]ALREADY MINED");
    return false;
}

if (actualArrangedMiningTime <= Context.CurrentBlockTime && 
    Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
{
    Context.LogDebug(() => "[CURRENT MINER]SAVING");
    return true;
}
```

Additionally, consider adding validation in `TimeSlotValidationProvider` to explicitly check saving slot constraints, or modify `UpdateValueValidationProvider` to verify that the miner's `OutValue` is not already set in the base round state.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setup: Create a consensus round with multiple miners
2. Step 1: Miner produces a block in their normal time slot → `OutValue` is set, `ProducedBlocks = 1`
3. Step 2: Simulate time passing without `NextRound` being called (stalled round)
4. Step 3: Wait for first saving slot window to open (after `totalRoundTime` milliseconds)
5. Step 4: Call `IsCurrentMiner` → returns `true` (only checks time window)
6. Step 5: Call `UpdateValue` → validation passes, `ProducedBlocks = 2`
7. Step 6: Repeat for additional saving slots
8. Result: Single miner has `ProducedBlocks = N` where `N > 1` for a single round

This can be verified by checking the miner's `ActualMiningTimes` list (will contain multiple entries) and `ProducedBlocks` counter (will be inflated) in the round state after exploitation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L181-189)
```csharp
        var nextArrangeMiningTime =
            currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
        var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
        if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
            Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]SAVING");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L250-252)
```csharp
        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-129)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```
