# Audit Report

## Title
Decimal Overflow in Bancor Price Calculation Causes Permanent DoS When Extreme Connector Weight Ratios Are Used

## Summary
The TokenConverter contract's Bancor pricing implementation lacks validation on the ratio between connector weights. When weights have extreme ratios (e.g., 0.9999:0.0001), moderate-sized trades trigger decimal overflow in the exponential power calculation, causing permanent denial-of-service since activated connectors cannot be reconfigured.

## Finding Description

The vulnerability exists in the interaction between Bancor formula calculation and the binary exponentiation helper function.

The `Exp` function computes exponential power series up to y^20, calling `Pow(y, iteration)` for each term. [1](#0-0) 

The `Pow` function uses left-to-right binary exponentiation with repeated squaring operations (`A *= A`). [2](#0-1) 

**Root Cause:** The argument `y` passed to `Exp` is computed as `(weight_ratio) * Ln(balance_ratio)` in the Bancor formula. [3](#0-2) 

Individual connector weights are validated to be strictly between 0 and 1. [4](#0-3) 

However, **there is no constraint on the ratio between two connector weights**. If weights are 0.9999 and 0.0001, the ratio is 9,999. When combined with a moderate trade (e.g., 30-40% of connector balance), this produces `y` values of 3,000-4,000.

**Overflow Mechanism:** For y ≈ 3,500, computing y^20 via binary exponentiation causes intermediate values to exceed `decimal.MaxValue` (≈7.9×10^28). AElf contracts enforce checked arithmetic that throws `OverflowException`. [5](#0-4) 

**Permanence:** Once connectors are activated, the `UpdateConnector` method explicitly prevents weight modifications. [6](#0-5) 

Both `Buy` and `Sell` operations directly call the vulnerable Bancor calculations without exception handling. [7](#0-6) [8](#0-7) 

## Impact Explanation

**HIGH Severity** - This vulnerability causes complete and permanent denial-of-service of token conversion functionality:

1. **Operational DoS**: All `Buy` and `Sell` transactions revert with `OverflowException` when extreme weight ratios exist, making token conversion impossible
2. **Liquidity Lock**: Tokens deposited in affected connectors cannot be converted back, effectively locking user funds
3. **Irrecoverable**: The restriction on updating activated connectors means the DoS is permanent without contract migration
4. **Economic Damage**: Loss of core protocol functionality disrupts the entire token economy

While funds are not directly stolen, the complete loss of conversion capability and permanently locked liquidity constitutes severe protocol failure.

## Likelihood Explanation

**MEDIUM-HIGH Probability**

**Preconditions:**
1. Connector controller (typically Parliament governance) sets weights with extreme ratio (>1000:1)
2. Connectors are activated (`IsPurchaseEnabled = true`)  
3. User submits trade with moderate amount (>30% of connector balance)

**Feasibility Factors:**
- **Configuration Errors**: Extreme ratios like 0.9999:0.0001 are technically valid. These could occur through typos in governance proposals (e.g., "0.0001" instead of "0.001"), poor understanding of ratio implications, or inadequate pre-deployment testing
- **No Validation**: The controller authorization checks in `UpdateConnector` and `AddPairConnector` verify only permissions, not ratio safety [9](#0-8) [10](#0-9) 
- **Easy Trigger**: Once misconfigured, any user performing normal trades triggers the DoS without specialized knowledge
- **No Warning System**: No pre-deployment simulation or ratio bounds checking exists

The combination of plausible configuration errors and easy triggering makes this a realistic threat.

## Recommendation

Implement ratio validation in connector configuration:

1. **Add ratio bounds checking** in `AssertValidConnectorWeight`:
   - Define maximum acceptable weight ratio (e.g., 100:1)
   - Validate ratio between paired connectors during `AddPairConnector` and `UpdateConnector`
   
2. **Add input bounds to `Exp` function**:
   - Validate that the input `y` to `Exp` is within safe bounds (e.g., |y| < 50)
   - Throw `InvalidValueException` for unsafe inputs before overflow occurs

3. **Add emergency recovery mechanism**:
   - Allow controller to disable problematic connectors even after activation
   - Provide emergency withdrawal function for locked liquidity

4. **Pre-deployment validation**:
   - Add simulation checks during connector activation to verify no overflow with realistic trade sizes

## Proof of Concept

The following demonstrates the overflow scenario:

```csharp
// Test: TokenConverter_Overflow_Extreme_Weight_Ratio
public void Extreme_Weight_Ratio_Causes_Overflow()
{
    // Setup: Create connector pair with extreme ratio
    var resourceWeight = "0.9999"; // 99.99%
    var nativeWeight = "0.0001";   // 0.01% -> Ratio: 9999:1
    
    AddPairConnectorWithWeights(resourceWeight, nativeWeight);
    EnableConnector();
    
    // User attempts moderate trade (35% of balance)
    var tradeAmount = GetConnectorBalance() * 35 / 100;
    
    // This will throw OverflowException in Pow calculation
    var exception = Assert.Throws<OverflowException>(() => 
    {
        Sell(new SellInput { Symbol = ResourceToken, Amount = tradeAmount });
    });
    
    // Verify: Transaction reverted due to overflow
    Assert.NotNull(exception);
    
    // Verify: Connector cannot be fixed (permanent DoS)
    Assert.Throws<AssertionException>(() =>
    {
        UpdateConnector(new Connector { Symbol = ResourceToken, Weight = "0.5" });
    }, "connector can not be updated because it has been activated");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L51-53)
```csharp
        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L60-60)
```csharp
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L81-81)
```csharp
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/project.md (L20-30)
```markdown
- It is required to enable `CheckForOverflowUnderflow` for both Release and Debug mode so that your contract will use arithmetic operators that will throw `OverflowException` if there is any overflow. This is to ensure that execution will not continue in case of an overflow in your contract and result with unpredictable output.

```xml
<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>
```
```
