# Audit Report

## Title
Referendum Contract Allows Setting Unbounded MinimalVoteThreshold Leading to Permanent Governance Lockout

## Summary
The Referendum contract's `ChangeOrganizationThreshold` function lacks upper bound validation for `MinimalVoteThreshold`, allowing an organization to set this value to unreachably high numbers (e.g., `Int64.MaxValue`). This permanently disables the organization's governance functionality with no recovery mechanism, as threshold changes require proposal execution, which becomes impossible when thresholds are unreachable. [1](#0-0) 

## Finding Description

The vulnerability exists in the threshold validation logic of the Referendum contract. When `ChangeOrganizationThreshold` is called, it validates the new threshold using the `Validate` method, which only checks relative relationships between threshold values but imposes **no upper bound** on `MinimalVoteThreshold`: [2](#0-1) 

The validation only requires:
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- `MaximalAbstentionThreshold >= 0`
- `MaximalRejectionThreshold >= 0`

When proposals attempt to release, the `IsReleaseThresholdReached` method checks if total votes meet the threshold. If `MinimalVoteThreshold` is set to an unreachable value like `Int64.MaxValue`, this check can never be satisfied: [3](#0-2) 

**Critical Comparison with Other Governance Contracts:**

Parliament enforces an upper bound on `MinimalVoteThreshold`: [4](#0-3) 

With `AbstractVoteTotal = 10000`: [5](#0-4) 

Association enforces that `MinimalVoteThreshold` cannot exceed organization member count: [6](#0-5) 

**Referendum is the only governance contract missing this critical protection.**

## Impact Explanation

**Severity: HIGH - Permanent Governance DoS**

Once an organization's `MinimalVoteThreshold` is set to an unreachable value, the organization's governance becomes **permanently non-functional**:

1. **Complete Governance Lockout**: All proposals can never be released because the vote threshold check in `IsReleaseThresholdReached` can never be satisfied when the threshold exceeds realistic token voting amounts.

2. **No Recovery Mechanism**: The `ChangeOrganizationThreshold` method requires `Context.Sender` to be the organization address itself, which can ONLY be achieved through proposal execution. Since proposals cannot be released with an unreachable threshold, the organization cannot fix its own configuration. This creates an unbreakable deadlock.

3. **Affected Parties**: All members of the affected Referendum organization lose their governance rights permanently. Any critical operations requiring governance approval (contract upgrades, parameter changes, fund releases) become impossible.

4. **Protocol Impact**: If critical protocol operations are controlled by Referendum organizations, this could impact the entire protocol's ability to adapt, upgrade, or respond to emergencies.

The attack is **irreversible** and causes **total loss of governance functionality** for the affected organization.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH - Single Malicious Proposal Attack**

**Attacker Capabilities Required:**
- Must be in the organization's proposer whitelist (standard requirement for creating proposals)
- Must successfully pass one malicious proposal through the organization's current approval process

**Attack Complexity: LOW**
1. Attacker creates a proposal calling `ChangeOrganizationThreshold` with `MinimalVoteThreshold = Int64.MaxValue` 
2. The proposal needs to pass current voting thresholds (one-time requirement)
3. Once released, the organization is permanently locked

**Feasibility Conditions:**
- **Social Engineering**: The attack could be disguised as a "security improvement" to increase voting requirements
- **Compromised Proposer**: A single compromised or malicious whitelisted proposer can initiate this attack
- **Majority Collusion**: If enough organization members collude, they can deliberately lock the organization

**Economic Cost: MINIMAL**
- Only requires gas fees to create and release one proposal
- No financial stake or capital requirements beyond normal proposal creation

**Detection Difficulty:**
- The malicious threshold change may not be immediately obvious if presented as "strengthening governance"
- Organizations may not realize they're locked until attempting to release the next proposal
- No automatic alerts or warnings exist for extreme threshold values

## Recommendation

Add upper bound validation to the Referendum contract's `Validate` method, similar to Parliament and Association contracts. The fix should ensure `MinimalVoteThreshold` cannot exceed a reasonable maximum based on the token's total supply or a predefined constant.

**Recommended Fix:**

Modify the `Validate` method in `Referendum_Helper.cs` to include an upper bound check. Consider either:

**Option 1**: Use a constant maximum (similar to Parliament's AbstractVoteTotal approach)
```csharp
private const long MaximumVoteThreshold = 1_000_000_000_00000000; // Reasonable maximum

private bool Validate(Organization organization)
{
    // ... existing checks ...
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalVoteThreshold <= MaximumVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           // ... rest of existing checks ...
}
```

**Option 2**: Check against token total supply
```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.TotalSupply &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           // ... rest of existing checks ...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ChangeOrganizationThreshold_UnboundedValue_PermanentLockout_Test()
{
    // Create organization with reasonable thresholds
    var organizationAddress = await CreateOrganizationAsync(5000, 5000, 10000, 10000, 
        new[] { DefaultSender });
    
    // Create and approve a proposal to set unreachable threshold
    var maliciousThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = long.MaxValue,
        MinimalApprovalThreshold = 5000,
        MaximalAbstentionThreshold = 10000,
        MaximalRejectionThreshold = 10000
    };
    
    var changeThresholdProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        maliciousThreshold,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress);
    
    // Approve and release the malicious proposal
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, changeThresholdProposalId);
    await ApproveAsync(Accounts[3].KeyPair, changeThresholdProposalId);
    await ReferendumContractStub.Release.SendAsync(changeThresholdProposalId);
    
    // Verify organization is now locked - create a new proposal
    var newProposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Even with maximum possible votes, proposal cannot be released
    await ApproveAllowanceAsync(Accounts[3].KeyPair, long.MaxValue / 2, newProposalId);
    await ApproveAsync(Accounts[3].KeyPair, newProposalId);
    
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(newProposalId);
    
    // Proposal can never reach threshold - organization is permanently locked
    proposal.ToBeReleased.ShouldBeFalse();
    
    // Verify release attempt fails
    var result = await ReferendumContractStub.Release.SendWithExceptionAsync(newProposalId);
    result.TransactionResult.Error.ShouldContain("Not approved");
    
    // No recovery possible - cannot change threshold back
}
```

## Notes

This vulnerability represents a critical design flaw where Referendum contract diverges from the defensive validation patterns used in Parliament and Association contracts. The missing upper bound check creates an unrecoverable governance deadlock scenario. Organizations using Referendum governance should be aware of this risk and carefully review all threshold change proposals.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
