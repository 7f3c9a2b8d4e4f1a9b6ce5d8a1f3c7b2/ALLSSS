# Audit Report

## Title
Permanent Authority Lockout via MethodFeeController Change to Inaccessible Organization

## Summary
The `ChangeMethodFeeController()` function allows changing the method fee controller to a Parliament organization with impossible-to-achieve voting thresholds (e.g., 100% approval required). Once changed, the system becomes permanently locked from any future fee updates or controller changes, as there is no recovery mechanism and the only way to modify the controller requires executing a proposal through the now-inaccessible organization.

## Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` implementation which validates only that the sender is the current controller and that the new organization exists, but does **not** validate whether the new organization has achievable voting thresholds. [1](#0-0) 

The Parliament contract's validation logic explicitly permits creating organizations with extreme thresholds. The `Validate` method allows `MinimalApprovalThreshold` up to and including 10000 (representing 100%). [2](#0-1) 

Test cases confirm that organizations with `MinimalApprovalThreshold = 10000` are explicitly permitted and successfully created: [3](#0-2) 

When a proposal is released, it executes with the organization's virtual address as the sender via `SendVirtualInlineBySystemContract`: [4](#0-3) [5](#0-4) 

The critical issue is that with a 100% approval threshold, the approval check becomes mathematically impossible if any single miner is unavailable: [6](#0-5) 

The formula `approvedMemberCount * 10000 >= 10000 * parliamentMembers.Count` requires ALL miners to approve when threshold is 10000. If any single miner is offline, compromised, or refuses to vote, the proposal can never reach the release threshold.

The default initialization only sets the controller if it's null, providing no recovery path: [7](#0-6) 

Once the `MethodFeeController` is set to an inaccessible organization, it cannot be reset to default, and there is no emergency override mechanism.

## Impact Explanation

**Critical Governance Failure with System-Wide Effect:**

1. **Permanent Loss of Fee Governance**: Once locked, the protocol permanently loses the ability to adjust method fees. This affects ALL system contracts implementing ACS1, including Token, Treasury, Consensus, Election, Parliament, Profit, CrossChain, Economic, Configuration, Referendum, TokenConverter, TokenHolder, and Vote contracts.

2. **Economic Rigidity**: The blockchain cannot adapt transaction fees to changing network conditions, token valuations, or spam attacks. Fees remain frozen at potentially inappropriate levels indefinitely.

3. **No Recovery Mechanism**: There is no bypass, emergency override, or reset function. The Emergency Response Organization has no special authority over MethodFeeController. The `RequiredMethodFeeControllerSet` function only initializes if the value is null, so once set to an inaccessible organization, it cannot be reset.

4. **Critical Invariant Violation**: Violates the fundamental governance invariant that "method-fee provider authority must remain accessible for system adaptation." This breaks the protocol's ability to evolve and respond to network conditions.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Capabilities Required:**
- Must be able to create Parliament organizations (requires being a miner or whitelisted proposer)
- Must be able to propose to the default Parliament organization (same requirement)
- Must obtain 2/3 approval from miners to pass the governance proposal [8](#0-7) 

**Attack Complexity: Low**
1. Create organization with MinimalApprovalThreshold=10000 (single transaction)
2. Create proposal to change MethodFeeController to this organization (single transaction)
3. Obtain governance approval through normal voting (may appear as legitimate governance change)
4. Release approved proposal (single transaction)

**High Feasibility:**
- The attack could be executed **accidentally** by well-intentioned governance participants who don't understand the irreversibility
- Could be executed maliciously by a compromised miner
- No technical barriers prevent execution once governance approval is obtained
- The dangerous threshold configuration (100% approval) might not be obvious to voters reviewing the proposal

**Economic Rationality:**
- Attack cost is minimal (only transaction fees)
- Could be motivated by griefing, ransom demands, or competitive sabotage
- Accidental execution through governance error is realistic given complexity of threshold implications

## Recommendation

Implement validation in `ChangeMethodFeeController` to ensure the new organization has achievable thresholds:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate organization has achievable thresholds
    var organization = GetOrganization(input.OwnerAddress);
    Assert(organization.ProposalReleaseThreshold.MinimalApprovalThreshold < AbstractVoteTotal,
        "Organization requires 100% approval which is unachievable.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

Additional recommendations:
1. Add maximum threshold limit (e.g., 9000/10000 = 90%) for organizations that control critical system functions
2. Implement an emergency recovery mechanism that allows the Genesis contract or a special emergency organization to reset inaccessible controllers
3. Add pre-proposal validation that warns about dangerous threshold configurations
4. Document the irreversibility of MethodFeeController changes in governance UI/documentation

## Proof of Concept

```csharp
[Fact]
public async Task MethodFeeController_PermanentLockout_Test()
{
    // Step 1: Create organization with 100% approval threshold (impossible to achieve)
    var impossibleOrg = await ParliamentContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 10000, // 100% - requires ALL miners
                MinimalVoteThreshold = 10000,
                MaximalAbstentionThreshold = 0,
                MaximalRejectionThreshold = 0
            }
        });
    var impossibleOrgAddress = Address.Parser.ParseFrom(impossibleOrg.TransactionResult.ReturnValue);
    
    // Step 2: Get current controller (default Parliament org)
    var currentController = await ParliamentContractStub.GetMethodFeeController.CallAsync(new Empty());
    
    // Step 3: Create proposal to change controller to impossible org
    var proposalId = await CreateFeeProposalAsync(
        ParliamentContractAddress,
        currentController.OwnerAddress,
        nameof(ParliamentContractStub.ChangeMethodFeeController),
        new AuthorityInfo
        {
            OwnerAddress = impossibleOrgAddress,
            ContractAddress = ParliamentContractAddress
        });
    
    // Step 4: Get 2/3 approval and release
    await ApproveAsync(InitialMinersKeyPairs[0], proposalId);
    await ApproveAsync(InitialMinersKeyPairs[1], proposalId);
    await ApproveAsync(InitialMinersKeyPairs[2], proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Step 5: Verify controller changed to impossible org
    var newController = await ParliamentContractStub.GetMethodFeeController.CallAsync(new Empty());
    newController.OwnerAddress.ShouldBe(impossibleOrgAddress);
    
    // Step 6: Attempt to change controller back - create proposal to impossible org
    var recoveryProposalId = await CreateProposalAsync(
        impossibleOrgAddress,
        nameof(ParliamentContractStub.ChangeMethodFeeController),
        new AuthorityInfo
        {
            OwnerAddress = currentController.OwnerAddress, // try to change back
            ContractAddress = ParliamentContractAddress
        });
    
    // Step 7: Even with all miners approving, if one is missing/offline, cannot release
    // Simulate one miner being unavailable by only getting n-1 approvals
    await ApproveAsync(InitialMinersKeyPairs[0], recoveryProposalId);
    await ApproveAsync(InitialMinersKeyPairs[1], recoveryProposalId);
    // Missing one approval from InitialMinersKeyPairs[2]
    
    // Step 8: Verify release fails - threshold not reached
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(recoveryProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Result: MethodFeeController is permanently locked to impossible organization
    // No recovery mechanism exists
}
```

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L189-195)
```csharp
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L50-59)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        Assert(
            ValidateAddressInWhiteList(Context.Sender) || ValidateParliamentMemberAuthority(Context.Sender) ||
            State.DefaultOrganizationAddress.Value == Context.Sender,
            "Unauthorized to create organization.");
        var organizationAddress = CreateNewOrganization(input);

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L49-63)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```
