# Audit Report

## Title
Missing Miner Order Validation in NextTerm Allows Mining Schedule Manipulation

## Summary
The AEDPoS consensus system fails to validate miner Order values during NextTerm transitions. A malicious miner producing the NextTerm block can arbitrarily modify Order assignments, bypassing the protocol's deterministic ordering mechanism and manipulating the mining schedule for an entire term (typically 7 days).

## Finding Description

The AEDPoS protocol expects miner Order values to be deterministically assigned by sorting miners by their public key's first byte in descending order. [1](#0-0) 

However, the NextTerm validation flow contains a critical gap. The `NextTermInput.Create()` method simply copies the `RealTimeMinersInformation` dictionary from the provided Round object without any validation. [2](#0-1) 

During block validation via `ValidateBeforeExecution`, the NextTerm behavior only adds `RoundTerminateValidationProvider` beyond basic providers (MiningPermissionValidationProvider, TimeSlotValidationProvider, ContinuousBlocksValidationProvider). Critically, `NextRoundMiningOrderValidationProvider` is NOT added for NextTerm. [3](#0-2) 

The `RoundTerminateValidationProvider` only validates round/term number increments and null InValues - it does NOT validate Order values. [4](#0-3) 

The `TimeSlotValidationProvider` calls `CheckRoundTimeSlots()`, which orders miners by the PROVIDED Order values to check time spacing, but never verifies the Orders themselves match the expected deterministic assignment. [5](#0-4) 

Finally, `ProcessNextTerm` directly stores the provided Round via `AddRoundInformation(nextRound)` without any Order validation. [6](#0-5) 

**Attack Scenario:**
1. Malicious miner produces NextTerm block
2. Calls `GetConsensusExtraDataForNextTerm` which generates Round with correct Orders [7](#0-6) 
3. Before broadcasting, modifies Order values (assigns themselves Order 1)
4. Ensures ExpectedMiningTimes remain evenly spaced
5. Validation passes because no validator checks Order correctness
6. ProcessNextTerm executes, storing corrupted Orders for entire term

## Impact Explanation

**HIGH severity** - Direct consensus integrity violation:

**Consensus Mechanism Compromise**: The fundamental guarantee of deterministic, fair miner ordering is bypassed. The protocol assumes Orders follow deterministic assignment based on public key sorting, and all mining schedule logic depends on this invariant being maintained.

**Mining Schedule Manipulation**: An attacker can assign themselves favorable Order positions (Order 1, 2) to mine first blocks, swap Orders with colluding miners, manipulate extra block producer selection, and cause timing conflicts where honest miners miss slots due to incorrect Order expectations.

**Protocol-Wide Impact**: Once corrupted Orders are stored in state, they affect all round progression for the entire term (7 days), time slot calculations for every miner, extra block producer selection, and mining reward distribution.

**No Self-Correction**: The corrupted Orders persist for the full term. There is no automatic recovery mechanism - the protocol uses manipulated values until the next term transition, which could be exploited again.

## Likelihood Explanation

**MODERATE-HIGH likelihood**:

**Low Attacker Barrier**: The attacker must be an authorized miner eligible to produce the NextTerm block. Term transitions occur regularly (every 7 days), and any miner in rotation can trigger them when conditions are met.

**Low Technical Complexity**: Exploitation only requires parsing and modifying a protobuf Round object and ensuring ExpectedMiningTimes maintain valid spacing - no cryptographic bypasses or complex state manipulation needed.

**No Detection**: The malicious Orders pass all validation checks because no validator compares Orders against expected deterministic assignment, no validator recalculates expected Orders from the miner list, and TimeSlotValidationProvider only verifies time spacing is valid. [8](#0-7) 

Post-execution validation also fails to detect this because it compares the header Round with the already-updated state Round rather than independently recalculating expected Orders. [9](#0-8) 

**Economic Incentive**: Attackers gain earlier mining positions leading to more blocks and higher rewards, MEV extraction opportunities, increased influence over block production, and ability to disadvantage competing miners.

## Recommendation

Add Order validation to the NextTerm flow:

1. **Create NextTermOrderValidationProvider**: Implement a new validation provider that:
   - Queries the Election contract to get the actual new miner list
   - Sorts miners deterministically by public key first byte descending
   - Calculates expected Order values (1, 2, 3, ...)
   - Compares provided Order values against expected values

2. **Add to validation chain**: In `ValidateBeforeExecution`, add the new provider for NextTerm behavior:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new NextTermOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

3. **Alternative approach**: In `ProcessNextTerm`, independently recalculate the Round with correct Orders from the Election contract miner list and compare with the provided Round, rejecting if Orders don't match.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system requiring multi-node setup, election contract state, and block production infrastructure, a complete PoC would require extensive test framework modifications. However, the vulnerability can be verified by:

1. Observing that `ValidateBeforeExecution` for NextTerm does not include any Order validation provider
2. Confirming `CheckRoundTimeSlots()` only validates time spacing using provided Orders
3. Verifying `ProcessNextTerm` stores the Round directly without Order validation
4. Testing that a modified NextTermInput with arbitrary Order values passes validation as long as time spacing is maintained

The code flow analysis conclusively demonstrates the validation gap exists in production code.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-31)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
