# Audit Report

## Title
Insufficient Alternative Selection Allows Banned Miners to Remain Active in Consensus

## Summary
The Election contract's `GetMinerReplacementInformation()` can return fewer alternative candidates than the number of banned miners requiring replacement. The consensus contract only processes replacements up to the count of alternatives provided, allowing unreplaced banned miners to remain in the active validator set and continue producing blocks without detection.

## Finding Description

**Root Cause - Alternative Selection Mismatch:**

In the Election contract's `GetMinerReplacementInformation()`, alternatives are selected with `Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count)` [1](#0-0) , limiting alternatives to available candidates. When insufficient, the function supplements with initial miners using `Math.Min(diff, State.InitialMiners.Value.Value.Count)` [2](#0-1) , but after filtering for banned and current miners, the final count can be less than evil miner count [3](#0-2) .

**Incomplete Replacement in Consensus:**

The consensus contract's `GenerateNextRoundInformation` loops only `AlternativeCandidatePubkeys.Count` times [4](#0-3) , processing paired evil miners and alternatives. For each iteration, it calls `UpdateCandidateInformation` with `IsEvilNode=true` [5](#0-4) , removes the evil miner from `RealTimeMinersInformation` [6](#0-5) , and adds the alternative. Evil miners at indices beyond `AlternativeCandidatePubkeys.Count` are never processed and remain in the active miner set.

**Validation Bypass:**

When banned miners attempt block production, `PreCheck()` only verifies miner list membership via `IsInMinerList()` [7](#0-6) . The `MiningPermissionValidationProvider` similarly checks only `RealTimeMinersInformation.Keys.Contains()` [8](#0-7) . Neither validation checks the Election contract's `BannedPubkeyMap` state where banned status is recorded [9](#0-8) .

**Execution Flow:**

1. Multiple miners marked as banned via `UpdateCandidateInformation(IsEvilNode=true)` [10](#0-9) 
2. During round generation, `GetEvilMinersPubkeys()` identifies all banned miners from current list [11](#0-10) 
3. Insufficient alternatives returned by `GetMinerReplacementInformation()` [12](#0-11) 
4. Consensus replaces only available alternatives, leaving remaining evil miners in `RealTimeMinersInformation` [13](#0-12) 
5. Unreplaced banned miners pass all validations and continue mining

## Impact Explanation

**Consensus Security Breach:**

This vulnerability breaks the fundamental invariant that banned miners must be immediately excluded from consensus. Miners banned for malicious behavior (protocol violations, double-signing, coordinated attacks) continue producing blocks and earning rewards.

**Quantified Impact:**
- **Byzantine Tolerance Violation**: Multiple coordinating attackers remaining active after detection may compromise BFT safety thresholds
- **Reward Misallocation**: Banned miners inappropriately earn block production rewards meant for legitimate validators
- **Extended Attack Window**: Malicious miners continue their attacks even after detection and attempted removal

**Affected Parties:**
- Entire network suffers degraded consensus security
- Legitimate miners lose potential rewards and block production opportunities  
- Token holders bear increased risk of consensus compromise

## Likelihood Explanation

**Triggering Conditions:**

This protocol-level flaw occurs automatically when:
1. Multiple miners banned simultaneously (e.g., 5+ miners in a 17-validator set)
2. Limited candidate pool (fewer than 10 qualified alternatives)
3. Initial miners depleted (already active or themselves banned)

**Realistic Scenario:**
- Network detects coordinated attack and bans 5 miners
- Only 3 alternative candidates exist after filtering
- 2 initial miners available, but 1 is already an active miner and 1 is banned
- Result: Only 3 evil miners replaced, 2 remain active in consensus

**Execution Practicality:**
- No attacker action required - occurs through normal protocol operations
- No special privileges needed
- No transaction manipulation necessary
- Deterministic outcome based on state conditions

The probability is **Medium-to-High** in realistic network conditions, particularly during mass detection of coordinated attacks, early chain stages with limited candidates, or low election participation periods.

## Recommendation

**Solution 1: Enforce Complete Replacement**

In `GenerateNextRoundInformation`, verify replacement completeness and revert if insufficient alternatives:

```csharp
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count < 
    minerReplacementInformation.EvilMinerPubkeys.Count)
{
    Assert(false, "Insufficient alternatives to replace all evil miners");
}
```

**Solution 2: Add Ban Validation**

In `PreCheck()`, cross-check ban status with Election contract:

```csharp
if (State.IsMainChain.Value && State.ElectionContract.Value != null)
{
    var isBanned = State.ElectionContract.IsPubkeyBanned.Call(
        new StringValue { Value = _processingBlockMinerPubkey });
    if (isBanned.Value) return false;
}
```

**Solution 3: Fallback Replacement Strategy**

Modify `GetMinerReplacementInformation` to guarantee equal counts by using additional fallback sources or recycling vetted alternatives when primary sources exhausted.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

**Setup:**
1. Deploy contracts with 17 initial miners
2. Ban 5 miners via `UpdateCandidateInformation(IsEvilNode=true)`
3. Ensure candidate pool has only 2 qualified alternatives
4. Ensure 1 initial miner available (others active or banned)

**Execution:**
1. Trigger round generation via `ProcessNextRound`
2. `GetMinerReplacementInformation` returns 5 evil miners but only 3 alternatives (2 from candidates + 1 from initial miners)
3. Consensus processes loop 3 times, replacing only first 3 evil miners
4. Remaining 2 evil miners stay in `RealTimeMinersInformation`
5. Banned miners successfully call `UpdateValue` and produce blocks
6. `PreCheck()` passes validation as they exist in miner list
7. `MiningPermissionValidationProvider` passes as they exist in `RealTimeMinersInformation.Keys`

**Verification:**
- Query `GetCurrentMinerList` - shows 2 banned miners still present
- Banned miners continue earning block rewards
- No consensus failure occurs despite ban status

This demonstrates the complete exploit path where banned miners remain active due to insufficient alternative selection and missing ban validation in consensus checks.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```
