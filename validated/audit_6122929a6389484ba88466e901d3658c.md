# Audit Report

## Title
Unvalidated MinerIncreaseInterval Initialization Enables Unrecoverable Division by Zero DoS in Consensus Operations

## Summary
The AEDPoS consensus contract's `InitialAElfConsensusContract` method lacks validation to prevent `MinerIncreaseInterval` from being initialized to zero. This causes immediate consensus failure during the first round transition when `GetMinersCount()` performs division by zero, halting the mainchain without possibility of recovery through governance mechanisms.

## Finding Description

The vulnerability exists across multiple layers of the consensus initialization and operation flow:

**Missing Input Validation:**
The initialization method directly assigns the input value without validation: [1](#0-0) 

**Division by Zero in Critical Path:**
During the first round to second round transition on mainchain, the consensus contract calls `GetMinersCount()` which performs unchecked division: [2](#0-1) 

The `GetMinersCount()` internal method performs the vulnerable division after `BlockchainStartTimestamp` is set: [3](#0-2) 

Similarly, the public view method `GetMaximumMinersCount()` calls `GetAutoIncreasedMinersCount()` which also divides by `MinerIncreaseInterval`: [4](#0-3) 

**SafeMath Does Not Prevent Division by Zero:**
The `.Div()` extension method performs standard division without zero checking: [5](#0-4) 

**Broken Recovery Mechanism:**
The governance method to update `MinerIncreaseInterval` only allows decreasing the value, preventing recovery from zero: [6](#0-5) 

If the current value is 0, the assertion `input.Value <= 0` prevents setting any positive value.

## Impact Explanation

**Critical Consensus Failure:**

The impact is more severe than typical DoS scenarios because it affects the core consensus round transition mechanism:

1. **Immediate Chain Halt**: During the transition from round 1 to round 2, the `ProcessNextRound` method calls `GetMinersCount()` which throws `DivideByZeroException`, causing the transaction to fail and preventing further rounds from being created.

2. **Mainchain-Specific**: The vulnerability only affects mainnets due to the conditional check at the failure point.

3. **Multiple Failure Points**: Beyond the automatic consensus failure, any call to `GetMaximumMinersCount()` (public view method) or `SetMaximumMinersCount()` (governance method) will also fail, preventing manual intervention.

4. **Permanent Damage**: The recovery method's flawed assertion logic makes it impossible to fix via governance. A hard fork or complete chain restart would be required.

5. **Election Contract Integration Broken**: The failure prevents updating the Election Contract with miner count information, breaking the coordination between consensus and election subsystems.

## Likelihood Explanation

**Likelihood: LOW but POSSIBLE**

While unlikely in practice, this vulnerability represents a critical configuration error with no safety net:

**Mitigating Factors:**
- Default configuration value is 31536000 (one year): [7](#0-6) 
- Genesis initialization is typically carefully reviewed
- No evidence in codebase of zero values being used in tests

**Risk Factors:**
- **No Validation**: Zero technical barrier prevents the misconfiguration
- **One-Time Operation**: Genesis initialization happens once, potentially without comprehensive testing of edge cases
- **Catastrophic Consequence**: If it occurs, recovery requires chain restart
- **Silent Acceptance**: The contract accepts zero without warning or error

The combination of no validation with catastrophic unrecoverable impact makes this a valid security concern despite low likelihood.

## Recommendation

Add validation in the `InitialAElfConsensusContract` method:

```csharp
public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
{
    Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
    State.Initialized.Value = true;

    State.PeriodSeconds.Value = input.IsTermStayOne
        ? int.MaxValue
        : input.PeriodSeconds;

    // Add validation to prevent zero or negative values
    Assert(input.MinerIncreaseInterval > 0, "MinerIncreaseInterval must be positive.");
    State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
    
    // ... rest of method
}
```

Additionally, fix the recovery mechanism in `SetMinerIncreaseInterval` to allow increasing the value when current value is problematic:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "MinerIncreaseInterval must be positive.");
    // Allow increasing from zero or small values, but generally only allow decreasing
    Assert(input.Value <= State.MinerIncreaseInterval.Value || State.MinerIncreaseInterval.Value == 0, 
        "Can only decrease interval, unless recovering from invalid state");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task DivisionByZero_When_MinerIncreaseInterval_IsZero()
{
    // Initialize consensus contract with MinerIncreaseInterval = 0
    await ConsensusStub.InitialAElfConsensusContract.SendAsync(
        new InitialAElfConsensusContractInput
        {
            PeriodSeconds = 604800,
            MinerIncreaseInterval = 0, // Invalid value - no validation prevents this
            IsSideChain = false,
            IsTermStayOne = false
        });

    // Initialize first round
    var firstRound = GenerateFirstRound(5);
    await ConsensusStub.FirstRound.SendAsync(firstRound);

    // Mine through round 1
    await BlockMiningService.MineBlockAsync();

    // Attempt to transition to round 2 - this will throw DivideByZeroException
    // because GetMinersCount divides by MinerIncreaseInterval which is 0
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await BlockMiningService.MineBlockToNextRoundAsync();
    });
    
    exception.Message.ShouldContain("DivideByZeroException");
    
    // Verify GetMaximumMinersCount also fails
    var viewException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    });
    viewException.Message.ShouldContain("DivideByZeroException");
}
```

## Notes

This vulnerability demonstrates the critical importance of input validation during genesis initialization. While the default configuration prevents this issue, the lack of validation creates a footgun that could cause irreversible chain failure. The combination of (1) no validation, (2) catastrophic impact, and (3) impossible recovery makes this a valid security concern that should be addressed regardless of likelihood.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L31-31)
```csharp
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L126-134)
```csharp
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```
