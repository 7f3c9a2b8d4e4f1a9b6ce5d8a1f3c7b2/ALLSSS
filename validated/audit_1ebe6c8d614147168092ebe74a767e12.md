# Audit Report

## Title
Election Contract Miners Count Desynchronization After MinerIncreaseInterval Change

## Summary
When `SetMinerIncreaseInterval()` modifies the miner increase interval, it fails to notify the Election contract of the resulting change in effective miners count. This causes the Election contract to use stale miners count data during the next term transition, resulting in an incorrect number of block producers being elected for that term.

## Finding Description

The AEDPoS consensus contract maintains a `MinerIncreaseInterval` parameter that controls how the maximum number of miners automatically increases based on blockchain age. The `SetMinerIncreaseInterval()` function updates this value but fails to synchronize it with the Election contract. [1](#0-0) 

The `GetMinersCount()` function calculates the effective miners count using the formula: `SupposedMinersCount + ((BlockchainAge / MinerIncreaseInterval) * 2)`, capped by `MaximumMinersCount`. This means when `MinerIncreaseInterval` decreases, the effective miners count increases proportionally. [2](#0-1) 

In contrast, `SetMaximumMinersCount()` correctly notifies the Election contract immediately via `UpdateMinersCount.Send()`: [3](#0-2) 

During term transitions, the Election contract's `GetVictories()` function uses its stored `State.MinersCount.Value` to determine how many candidates to select as block producers: [4](#0-3) 

The critical timing issue occurs during term transitions. When a new term begins, `GetConsensusExtraDataForNextTerm()` is called during block generation (before execution) to prepare the consensus header: [5](#0-4) 

This calls `GenerateFirstRoundOfNextTerm()`, which retrieves candidates from the Election contract: [6](#0-5) 

The `TryToGetVictories()` method calls the Election contract's `GetVictories()`, which uses the stale `MinersCount` value: [7](#0-6) 

Only after the block is executed does `ProcessNextTerm()` update the Election contract's miners count: [8](#0-7) 

However, by this point the round has already been generated with the wrong number of miners based on the stale Election contract data.

The Election contract's `UpdateMinersCount()` method updates the stored value, but this happens too late in the process: [9](#0-8) 

## Impact Explanation

**Concrete Harm to Protocol Integrity:**

When `MinerIncreaseInterval` is decreased (to accelerate miner growth), the auto-calculated count increases, but the Election contract still uses the old lower count. This causes fewer candidates to be elected as block producers than the system intends.

**Example Scenario:**
- Blockchain age: 2 years (63,072,000 seconds)
- Initial `MinerIncreaseInterval`: 31,536,000 (1 year)
- Auto-increased count: 17 + (63,072,000 / 31,536,000) * 2 = 21
- Election contract `MinersCount`: 21
- After governance reduces interval to 15,768,000 (6 months)
- New auto-increased count: 17 + (63,072,000 / 15,768,000) * 2 = 25
- Election contract still has `MinersCount`: 21
- At next term: `GetVictories()` returns only 21 candidates instead of 25

**Affected Parties:**
- Candidates ranked 22-25 who should be elected but are excluded from block production
- Voters who voted for these candidates expecting staking returns and rewards
- Network decentralization objectives are compromised with fewer active validators than intended

**Duration:** The desynchronization persists from the `SetMinerIncreaseInterval()` call until the next term transition (typically 1 day in AElf), though the incorrect miner count affects the entire subsequent term.

## Likelihood Explanation

This is not a traditional attack but an operational vulnerability triggered by legitimate governance actions. The Parliament organization (requiring 2/3 miner consensus) can call `SetMinerIncreaseInterval()`.

**Feasibility Factors:**
- `SetMinerIncreaseInterval()` is a legitimate administrative function for network policy adjustments
- No malicious intent required - the desynchronization is an unintentional side effect of normal operations
- The validation constraint only prevents increasing the interval, not decreasing it
- Term transitions happen regularly (daily on mainnet)

**Execution Practicality:** The vulnerability manifests automatically during normal protocol operation whenever `MinerIncreaseInterval` is changed between term transitions.

**Probability Assessment:** Medium - While `MinerIncreaseInterval` changes are infrequent governance decisions, they are legitimate protocol adjustments that could occur during network growth phases or when governance decides to modify validator expansion policy.

## Recommendation

Modify `SetMinerIncreaseInterval()` to immediately notify the Election contract of the miners count change, following the same pattern as `SetMaximumMinersCount()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    
    // Add this synchronization step:
    TryToGetCurrentRoundInformation(out var round);
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });
    
    return new Empty();
}
```

This ensures the Election contract is immediately synchronized with the new effective miners count calculation whenever the interval changes.

## Proof of Concept

```csharp
[Fact]
public async Task MinerIncreaseInterval_Change_Causes_Election_Desync()
{
    // Setup: Initialize with MinerIncreaseInterval = 31536000 (1 year)
    await InitializeContracts();
    
    // Advance blockchain age to 2 years (63072000 seconds)
    await AdvanceBlockchainAge(63072000);
    
    // Verify current miners count: 17 + (63072000 / 31536000) * 2 = 21
    var currentMinersCount = await ConsensusContract.GetMinersCount.CallAsync(currentRound);
    Assert.Equal(21, currentMinersCount);
    
    // Verify Election contract has MinersCount = 21
    var electionMinersCount = await ElectionContract.GetMinersCount.CallAsync(new Empty());
    Assert.Equal(21, electionMinersCount.Value);
    
    // Parliament governance changes MinerIncreaseInterval to 15768000 (6 months)
    await ParliamentContract.SetMinerIncreaseInterval(new Int64Value { Value = 15768000 });
    
    // Consensus contract now calculates: 17 + (63072000 / 15768000) * 2 = 25
    currentMinersCount = await ConsensusContract.GetMinersCount.CallAsync(currentRound);
    Assert.Equal(25, currentMinersCount);
    
    // BUG: Election contract still has stale MinersCount = 21
    electionMinersCount = await ElectionContract.GetMinersCount.CallAsync(new Empty());
    Assert.Equal(21, electionMinersCount.Value); // Should be 25, but is still 21
    
    // Trigger term transition
    await TriggerNextTerm();
    
    // VULNERABILITY: Only 21 candidates elected instead of 25
    var victories = await ElectionContract.GetVictories.CallAsync(new Empty());
    Assert.Equal(21, victories.Value.Count); // Wrong! Should be 25
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-176)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
