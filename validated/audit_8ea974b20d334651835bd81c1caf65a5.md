# Audit Report

## Title
State Inconsistency Between Consensus and Election Contracts Causes Incorrect Miner Selection During Term Transitions

## Summary
A state synchronization bug in the AEDPoS consensus contract causes the Election contract to select the wrong number of miners during term transitions. When `SetMinerIncreaseInterval()` is called to decrease the miner increase interval, it updates the consensus contract's calculation parameters but fails to synchronize this change with the Election contract's stored `MinersCount` value, resulting in an incorrect miner set that persists for the entire term duration.

## Finding Description

The vulnerability stems from inconsistent state synchronization between the Consensus and Election contracts during miner count parameter updates.

**Root Cause - Missing Synchronization:**

The `SetMinerIncreaseInterval()` method updates `State.MinerIncreaseInterval.Value` without calling `UpdateMinersCount()` on the Election contract. [1](#0-0) 

This contrasts with `SetMaximumMinersCount()`, which properly synchronizes by calling `State.ElectionContract.UpdateMinersCount.Send()`. [2](#0-1) 

The consensus contract's `GetMinersCount()` and `GetAutoIncreasedMinersCount()` calculate the effective miner count using a formula that incorporates `MinerIncreaseInterval`. When the interval is decreased, this calculation immediately returns a higher miner count, but the Election contract remains unaware of this change. [3](#0-2) 

**Exploitation Path:**

During term transitions, the consensus contract generates the first round of the new term by calling `GenerateFirstRoundOfNextTerm()`, which invokes `TryToGetVictories()` to retrieve the elected miners from the Election contract. [4](#0-3) 

The `TryToGetVictories()` method calls the Election contract's `GetVictories()`. [5](#0-4) 

The Election contract's `GetVictories()` method relies on its stored `State.MinersCount.Value` to determine how many candidates to select. Since `SetMinerIncreaseInterval()` did not update this value, `GetVictories()` selects miners based on the outdated count. [6](#0-5) 

**Critical Timing Issue:**

The miner list is determined during block production when generating consensus extra data (BEFORE the `NextTerm` transaction executes). [7](#0-6) 

Only after the term has started with the incorrect miner set does `ProcessNextTerm()` call `UpdateMinersCountToElectionContract()`, which synchronizes the Election contract's `MinersCount`. By this point, the term is already running with the wrong miners. [8](#0-7) [9](#0-8) 

The Election contract's `UpdateMinersCount()` can only be called by the Consensus contract, confirming this is the proper synchronization channel that `SetMinerIncreaseInterval()` fails to use. [10](#0-9) 

## Impact Explanation

**Consensus Integrity Violation:**
- The term begins with an incorrect number of miners (e.g., if the interval is halved, the calculation might return 11 miners but GetVictories selects only 7)
- Top-voted candidates who should be mining are completely excluded from the term
- These excluded candidates lose all mining opportunities and block rewards for the entire term duration
- Voters who staked tokens for excluded candidates receive no mining reward distributions

**Network Security Impact:**
- Reduced miner diversity weakens consensus security
- Fewer active miners increase centralization risk
- The decentralization guarantee of the AEDPoS consensus mechanism is compromised

**Duration and Persistence:**
- The issue persists for the full term duration (potentially multiple days to weeks)
- Cannot self-correct until the next term transition occurs
- Each subsequent term transition after the initial `SetMinerIncreaseInterval()` call will correctly synchronize, but the damage from the first transition is permanent for that term

**Severity Justification (Medium):**
This violates critical consensus invariants requiring miner schedule integrity and causes invalid state in the election system. While it requires governance action (not an arbitrary attacker), the unintended consequences affect protocol correctness and economic fairness.

## Likelihood Explanation

**Trigger Mechanism:**
- Requires governance authority via the `MaximumMinersCountController` (typically Parliament)
- NOT a malicious attack - occurs through legitimate governance operations
- The governance change itself (decreasing `MinerIncreaseInterval` to allow faster miner growth) is a realistic protocol evolution action

**Feasibility:**
- Low complexity: Single governance proposal execution followed by natural term transition
- No special timing manipulation needed - the vulnerability triggers automatically at the next term boundary
- The validation in `SetMinerIncreaseInterval()` only allows decreasing the interval, making the scenario realistic

**Probability Assessment (Medium):**
While miner parameter changes are infrequent, they are realistic for protocol maturation. Governance might legitimately want to accelerate miner growth to increase decentralization, and this change would naturally be implemented via `SetMinerIncreaseInterval()`. The vulnerability automatically triggers at the next term transition without any further action required.

## Recommendation

The `SetMinerIncreaseInterval()` method should immediately synchronize the updated miner count with the Election contract, following the same pattern as `SetMaximumMinersCount()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    
    TryToGetCurrentRoundInformation(out var round);
    
    State.MinerIncreaseInterval.Value = input.Value;
    
    // Add synchronization call
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });
    
    return new Empty();
}
```

This ensures the Election contract's `MinersCount` is immediately updated to reflect the new calculated value based on the decreased interval, preventing stale data from being used during the next term transition.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Initialize the consensus and election contracts with initial miners
2. Call `SetMinerIncreaseInterval()` with a decreased interval value via governance
3. Advance time and trigger a term transition
4. Verify that `GetVictories()` returns fewer miners than `GetMinersCount()` calculates
5. Confirm the term starts with the incorrect (smaller) miner set
6. Verify that after `ProcessNextTerm()` completes, the Election contract's `MinersCount` is updated, but the active miners remain incorrect for that term

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-84)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-176)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
