# Audit Report

## Title
Incomplete WritePaths Declaration Enables Race Conditions in Token Transfer Callbacks

## Summary
The `GetResourceInfo` method for `Transfer` and `TransferFrom` operations in the MultiToken contract fails to account for cross-contract callbacks configured via token ExternalInfo. When tokens have transfer callbacks enabled, multiple transfer transactions can execute in parallel and trigger concurrent callback invocations that modify shared state without proper isolation, violating parallel execution correctness guarantees.

## Finding Description

The MultiToken contract implements a callback mechanism where tokens can specify external contracts to be invoked during transfers. The `Transfer` method executes balance modifications and then calls `DealWithExternalInfoDuringTransfer`, which checks if the token has a callback configured under the `TransferCallbackExternalInfoKey` and invokes it via `Context.SendInline`. [1](#0-0) 

The callback invocation logic reads the token's ExternalInfo and executes the specified contract method: [2](#0-1) 

The callback key is defined as a constant: [3](#0-2) 

However, the `GetResourceInfo` implementation for `Transfer` only declares WritePaths for token balances, transaction fees, delegatees, and free allowances. It does NOT check whether the token has a callback configured, nor does it mark the transaction as non-parallelizable: [4](#0-3) 

The same issue exists for `TransferFrom`: [5](#0-4) [6](#0-5) 

Importantly, `GetResourceInfo` CAN access contract state during resource extraction, as evidenced by its calls to state-reading methods: [7](#0-6) 

The parallel execution system's `TransactionGrouper` relies on complete WritePaths declarations to group non-conflicting transactions. Transactions with incomplete resource declarations will be incorrectly grouped for parallel execution: [8](#0-7) 

When multiple transfers of a callback-enabled token execute in parallel, both transactions declare identical WritePaths (only for balances and fees), get grouped together, execute simultaneously, and invoke their callbacks concurrently. If the callbacks modify shared state in the callback contract, this creates race conditions leading to state corruption.

## Impact Explanation

**HIGH Severity** - This vulnerability violates the fundamental correctness guarantee of the parallel execution system. When multiple transfers with callbacks execute in parallel:

1. Race conditions occur in callback contract state
2. Non-deterministic execution outcomes arise (same transactions may produce different results depending on execution order)
3. State corruption in callback contracts can occur
4. Callback contract invariants may be broken

The impact extends beyond the MultiToken contract itself to any contract that implements transfer callbacks, making it a systemic issue that undermines the reliability of the parallel execution framework. This cannot be detected or prevented by callback contract developers.

## Likelihood Explanation

**MEDIUM Likelihood** - The vulnerability can be triggered by:

1. Creating a token with `TransferCallbackExternalInfoKey` configured in ExternalInfo during token creation (this is an intentional feature)
2. Submitting multiple Transfer/TransferFrom transactions for that token in the same block
3. The parallel grouper automatically groups them together since their declared WritePaths don't conflict

Entry points are public methods (`Transfer` and `TransferFrom`) callable by anyone. The callback feature is intentionally designed and available for use. The only barrier to exploitation is whether tokens with callbacks are actually deployed in production, which depends on adoption of this feature.

## Recommendation

Modify `GetResourceInfo` to check if the token has a transfer callback configured and mark such transactions as non-parallelizable:

```csharp
case nameof(Transfer):
{
    var args = TransferInput.Parser.ParseFrom(txn.Params);
    
    // Check if token has transfer callback configured
    var tokenInfo = State.TokenInfos[args.Symbol];
    if (tokenInfo?.ExternalInfo?.Value?.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey) == true)
    {
        return new ResourceInfo { NonParallelizable = true };
    }
    
    var resourceInfo = new ResourceInfo
    {
        WritePaths = { /* existing paths */ }
    };
    // ... rest of existing logic
}
```

Apply the same check to `TransferFrom` and other methods that invoke `DealWithExternalInfoDuringTransfer`, `DealWithExternalInfoDuringLocking`, or `DealWithExternalInfoDuringUnlock`.

## Proof of Concept

A proof of concept would require:

1. Creating a test token with ExternalInfo containing a transfer callback configuration
2. Implementing a callback contract with state that tracks invocation count
3. Submitting multiple Transfer transactions in parallel
4. Demonstrating that the callback contract's state becomes corrupted due to concurrent invocations

The vulnerability cannot be demonstrated with a simple single-function test because it requires:
- The parallel execution infrastructure to group transactions
- Multiple transactions executing concurrently
- A callback contract with race-condition-susceptible state

However, the code analysis definitively shows that `GetResourceInfo` does not account for callbacks, which is sufficient to validate the vulnerability exists in the design.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-38)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L84-96)
```csharp
    private void AddPathForTransactionFee(ResourceInfo resourceInfo, string from, string methodName)
    {
        var symbols = GetTransactionFeeSymbols(methodName);
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        if (_primaryTokenSymbol != string.Empty && !symbols.Contains(primaryTokenSymbol))
            symbols.Add(primaryTokenSymbol);
        var paths = symbols.Select(symbol => GetPath(nameof(TokenContractState.Balances), from, symbol));
        foreach (var path in paths)
        {
            if (resourceInfo.WritePaths.Contains(path)) continue;
            resourceInfo.WritePaths.Add(path);
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/TransactionGrouper.cs (L115-174)
```csharp
    private List<List<Transaction>> GroupParallelizables(List<TransactionWithResourceInfo> txsWithResources)
    {
        var resourceUnionSet = new Dictionary<int, UnionFindNode>();
        var transactionResourceHandle = new Dictionary<Transaction, int>();
        var groups = new List<List<Transaction>>();
        var readOnlyPaths = txsWithResources.GetReadOnlyPaths();
        foreach (var txWithResource in txsWithResources)
        {
            UnionFindNode first = null;
            var transaction = txWithResource.Transaction;
            var transactionResourceInfo = txWithResource.TransactionResourceInfo;

            // Add resources to disjoint-set, later each resource will be connected to a node id, which will be our group id
            foreach (var resource in transactionResourceInfo.WritePaths.Concat(transactionResourceInfo.ReadPaths)
                         .Where(p => !readOnlyPaths.Contains(p))
                         .Select(p => p.GetHashCode()))
            {
                if (!resourceUnionSet.TryGetValue(resource, out var node))
                {
                    node = new UnionFindNode();
                    resourceUnionSet.Add(resource, node);
                }

                if (first == null)
                {
                    first = node;
                    transactionResourceHandle.Add(transaction, resource);
                }
                else
                {
                    node.Union(first);
                }
            }
        }

        var grouped = new Dictionary<int, List<Transaction>>();

        foreach (var txWithResource in txsWithResources)
        {
            var transaction = txWithResource.Transaction;
            if (!transactionResourceHandle.TryGetValue(transaction, out var firstResource))
                continue;

            // Node Id will be our group id
            var gId = resourceUnionSet[firstResource].Find().NodeId;

            if (!grouped.TryGetValue(gId, out var gTransactions))
            {
                gTransactions = new List<Transaction>();
                grouped.Add(gId, gTransactions);
            }

            // Add transaction to its group
            gTransactions.Add(transaction);
        }

        groups.AddRange(grouped.Values);

        return groups;
    }
```
