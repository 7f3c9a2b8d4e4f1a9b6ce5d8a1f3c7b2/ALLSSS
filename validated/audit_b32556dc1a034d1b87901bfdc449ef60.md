# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass via RecoverFromUpdateValue Timing Issue

## Summary
The `LibInformationValidationProvider` validation is completely bypassed for `ImpliedIrreversibleBlockHeight` during UpdateValue consensus behavior. The root cause is that `RecoverFromUpdateValue` modifies the `BaseRound` object before validation occurs, causing the validator to compare the malicious value against itself. This allows any miner to inject fraudulently low implied LIB heights into consensus state, compromising blockchain finality guarantees.

## Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior due to incorrect execution ordering.

When validating UpdateValue behavior, the system first retrieves the current round information from state into `baseRound`. [1](#0-0) 

Before any validation occurs, if the behavior is UpdateValue, `RecoverFromUpdateValue` is called on the `baseRound` object, modifying it in-memory. [2](#0-1) 

The recovery implementation copies `ImpliedIrreversibleBlockHeight` from the provided round (attacker's input) into the baseRound object. [3](#0-2) 

The validation context is then created using the now-modified baseRound, and the `LibInformationValidationProvider` is added to the validation chain for UpdateValue behavior. [4](#0-3) [5](#0-4) 

The validator's context uses `BaseRound` (the modified state round) and `ProvidedRound` (which returns the attacker's input from ExtraData). [6](#0-5) 

The validator attempts to check if the baseRound's ImpliedIrreversibleBlockHeight is greater than the providedRound's value to detect regression. [7](#0-6) 

However, since `RecoverFromUpdateValue` already copied the value from `providedRound[pubkey].ImpliedIrreversibleBlockHeight` into `baseRound[pubkey].ImpliedIrreversibleBlockHeight`, both values are now identical. The validation check becomes: `maliciousValue > maliciousValue`, which always evaluates to false, allowing the malicious value to pass validation.

After validation passes, the malicious `ImpliedIrreversibleBlockHeight` is persisted to state during consensus processing. [8](#0-7) 

**Root Cause**: The design flaw is that state recovery happens before validation, corrupting the reference point (baseRound) that validators rely on to detect malicious decreases. The validation becomes a tautology.

## Impact Explanation

The `ImpliedIrreversibleBlockHeight` is a critical component of the Last Irreversible Block (LIB) calculation. The LIB calculation collects implied irreversible heights from miners in the previous round, sorts them, and takes the value at position `(count-1)/3` to ensure 2/3+1 Byzantine fault tolerance. [9](#0-8) [10](#0-9) 

A malicious miner can:

1. **Inject Fraudulent Low Values**: Submit an arbitrarily low `ImpliedIrreversibleBlockHeight` (e.g., 100 when the current height is 1000) during their UpdateValue call
2. **Manipulate LIB Calculation**: In subsequent rounds, this fraudulent value enters the sorted list used for LIB calculation [11](#0-10) 
3. **Compromise Finality**: While the 2/3+1 threshold limits single-miner impact, repeated attacks or collusion among multiple miners can significantly lower the calculated LIB and prevent proper finality advancement

**Severity**: HIGH - This bypasses a critical consensus validation mechanism designed to prevent regression of finality markers, directly impacting blockchain security guarantees and affecting all network participants relying on LIB for transaction finality confirmation.

## Likelihood Explanation

**Attacker Capabilities**: Any elected miner in the current round can execute this attack with no special privileges beyond normal mining rights.

**Attack Complexity**: LOW - The attack simply requires providing a lower-than-legitimate `ImpliedIrreversibleBlockHeight` value when producing a block during UpdateValue behavior. The validation bypass is automatic due to the code execution order.

**Feasibility**: The attack is executable during normal block production (UpdateValue occurs every block), requires no additional preconditions, and has no detection mechanism in the current validation logic.

**Probability**: HIGH - Any miner can execute this attack at any time during their block production slot without detection by the current validation system.

## Recommendation

The fix is to preserve the original baseRound value before recovery for use in validation. Modify `ValidateBeforeExecution` to clone the baseRound before calling `RecoverFromUpdateValue`:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // Preserve original baseRound for validation
    var originalBaseRound = baseRound.Clone(); // Add Clone method to Round class
    
    // Skip initial miner check...
    
    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

    if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

    var validationContext = new ConsensusValidationContext
    {
        BaseRound = originalBaseRound, // Use original for validation
        // ... rest of initialization
    };
    // ... rest of validation
}
```

Alternatively, move the recovery logic to occur AFTER validation completes successfully.

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Advances through the first round with normal UpdateValue operations
2. Has a miner submit an UpdateValue with ImpliedIrreversibleBlockHeight significantly lower than their previous value
3. Verifies that ValidateConsensusBeforeExecution returns Success=true despite the regression
4. Confirms the malicious low value is persisted to state

The test would show that the validation intended to catch decreasing ImpliedIrreversibleBlockHeight values fails due to the timing issue where RecoverFromUpdateValue modifies the reference point before the comparison occurs.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L80-82)
```csharp
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-27)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L25-32)
```csharp
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
