# Audit Report

## Title
Incomplete Token Distribution Due to Outdated SymbolList in TakeSnapshot Causing Permanent Reward Loss

## Summary
The Election contract's `TakeSnapshot()` method retrieves Treasury's `SymbolList` and passes it as `AmountsMap` to `DistributeProfits()` for reward distribution to SubsidyHash and WelfareHash schemes. A critical design flaw in `DistributeProfits()` causes it to process ONLY symbols in `AmountsMap` when non-empty, completely bypassing the `IsReleaseAllBalanceEveryTimeByDefault` flag and ignoring all other tokens tracked in `ReceivedTokenSymbols`. This results in permanent loss of non-native token rewards when Treasury's `SymbolList` is not updated to include all tokens in the ecosystem.

## Finding Description

The vulnerability stems from a three-component interaction that violates the invariant that all contributed tokens should be distributed to beneficiaries:

**Component 1 - Entry Point:**
The Election contract's `TakeSnapshot()` method, called automatically by the consensus contract at each term end, retrieves the symbol list from Treasury and passes it to distribution: [1](#0-0) [2](#0-1) 

The symbol list is obtained from Treasury's `GetSymbolList()`, which returns a manually configured list: [3](#0-2) 

**Component 2 - Root Cause:**
The `DistributeProfits()` method contains the critical flaw. When `AmountsMap` has ANY entries, it processes ONLY those symbols: [4](#0-3) 

The else block (lines 447-460) that would distribute all tokens using `ReceivedTokenSymbols` NEVER executes when `AmountsMap.Any()` is true. This means the `IsReleaseAllBalanceEveryTimeByDefault` flag is completely bypassed.

Schemes are initialized with this flag set to true: [5](#0-4) 

**Component 3 - Irreversible Period Increment:**
After distribution completes, the period always increments: [6](#0-5) 

**Component 4 - Prevention of Retry:**
Period validation prevents redistributing a past period: [7](#0-6) 

**Why Protections Fail:**

Treasury's `SymbolList` is initialized with only the native token: [8](#0-7) 

When tokens are contributed to schemes, they are tracked in `ReceivedTokenSymbols`: [9](#0-8) 

When Treasury distributes to sub-schemes (SubsidyHash, WelfareHash), tokens are transferred and tracked in sub-scheme's `ReceivedTokenSymbols`: [10](#0-9) 

However, there is no validation that Treasury's `SymbolList` includes all these tokens.

## Impact Explanation

**Direct Financial Harm:**
When Treasury supports multiple tokens (e.g., ELF, USDT) that have been donated and distributed to SubsidyHash and WelfareHash schemes, but Treasury's `SymbolList` only contains `["ELF"]`:

1. Only ELF rewards are distributed to backup candidates and voters
2. USDT and other tokens remain permanently locked in the schemes' virtual addresses for that period
3. These tokens cannot be distributed for that specific period due to period validation
4. The distribution period advances, making the loss permanent for that term
5. Beneficiaries lose their entitled share of rewards

**Affected Parties:**
- Backup node operators expecting subsidy rewards from SubsidyHash
- Token holders/voters expecting welfare dividends from WelfareHash
- All beneficiaries of profit schemes using this distribution mechanism

**Severity Justification:**
- **High Impact**: Permanent loss of rewards for an entire period; funds effectively locked
- **No Recovery Mechanism**: The period-based model with strict validation prevents retroactive fixes
- **Cumulative Effect**: Each term with incomplete symbol list causes additional compounding loss
- **Trust Damage**: Users lose confidence when entitled rewards are not received

## Likelihood Explanation

**Realistic Scenario:**
1. Treasury initialized with `SymbolList = ["ELF"]`
2. Governance adds new tokens to ecosystem (e.g., USDT as method fee token)
3. Tokens flow through Treasury `Donate()` to SubsidyHash/WelfareHash schemes
4. Governance fails to update Treasury's `SymbolList` (operational oversight)
5. `TakeSnapshot()` automatically called by consensus contract at term end (~weekly)
6. Incomplete distribution occurs, locking non-ELF tokens for that period

**Feasibility:**
- **No Attacker Required**: Operational failure triggered by normal operations
- **Automatic Trigger**: `TakeSnapshot()` called automatically by consensus
- **No Safeguards**: No validation that `SymbolList` includes all `ReceivedTokenSymbols`
- **Governance Dependency**: Requires perfect coordination between token additions and `SymbolList` updates

**Probability:**
Medium-High - As the ecosystem grows and new tokens integrate, coordination overhead increases significantly. A single oversight in the multi-step process (add token → enable for fees → update SymbolList) causes immediate, permanent loss for that term.

## Recommendation

**Fix 1 - Modify Distribution Logic (Recommended):**
Change `DistributeProfits()` to respect `IsReleaseAllBalanceEveryTimeByDefault` even when `AmountsMap` is provided. When this flag is true, merge `AmountsMap` symbols with `ReceivedTokenSymbols` to ensure all tokens are distributed.

**Fix 2 - Add Validation:**
In `TakeSnapshot()` or `DistributeProfits()`, add validation that compares `SymbolList` against scheme's `ReceivedTokenSymbols` and revert if tokens are missing, forcing governance to update the list before distribution can proceed.

**Fix 3 - Automatic Symbol Discovery:**
Modify `TakeSnapshot()` to query the scheme's `ReceivedTokenSymbols` directly instead of relying on Treasury's manually configured `SymbolList`.

## Proof of Concept

```csharp
// Test demonstrating incomplete distribution when SymbolList is outdated
[Fact]
public async Task Test_IncompleteDistribution_OutdatedSymbolList()
{
    // Setup: Initialize Treasury with only ELF in SymbolList
    await TreasuryContractStub.InitialTreasuryContract.SendAsync(new Empty());
    await TreasuryContractStub.InitialMiningRewardProfitItem.SendAsync(new Empty());
    
    // Donate USDT to Treasury (gets added to ReceivedTokenSymbols)
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TreasuryContractAddress,
        Symbol = "USDT",
        Amount = 1000_00000000
    });
    await TreasuryContractStub.Donate.SendAsync(new DonateInput
    {
        Symbol = "USDT",
        Amount = 1000_00000000
    });
    
    // Release Treasury - distributes to SubsidyHash/WelfareHash
    await TreasuryContractStub.Release.SendAsync(new ReleaseInput
    {
        PeriodNumber = 1
    });
    
    // Get SubsidyHash scheme info - verify USDT is in ReceivedTokenSymbols
    var subsidyScheme = await ProfitContractStub.GetScheme.CallAsync(subsidyHash);
    Assert.Contains("USDT", subsidyScheme.ReceivedTokenSymbols);
    
    // Get USDT balance in SubsidyHash virtual address before distribution
    var balanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = subsidyScheme.VirtualAddress,
        Symbol = "USDT"
    });
    Assert.True(balanceBefore.Balance > 0);
    
    // TakeSnapshot is called (SymbolList still only has ELF, not USDT)
    await ElectionContractStub.TakeSnapshot.SendAsync(new TakeElectionSnapshotInput
    {
        TermNumber = 1,
        MinedBlocks = 100,
        RoundNumber = 1
    });
    
    // Verify USDT was NOT distributed - balance unchanged
    var balanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = subsidyScheme.VirtualAddress,
        Symbol = "USDT"
    });
    Assert.Equal(balanceBefore.Balance, balanceAfter.Balance); // USDT locked!
    
    // Verify CurrentPeriod incremented - cannot retry distribution
    var schemeAfter = await ProfitContractStub.GetScheme.CallAsync(subsidyHash);
    Assert.Equal(2, schemeAfter.CurrentPeriod); // Period advanced
    
    // Attempting to distribute period 1 again fails
    var result = await ProfitContractStub.DistributeProfits.SendWithExceptionAsync(
        new DistributeProfitsInput
        {
            SchemeId = subsidyHash,
            Period = 1,
            AmountsMap = { { "USDT", 0 } }
        });
    Assert.Contains("Invalid period", result.TransactionResult.Error);
    
    // USDT permanently locked for period 1
}
```

**Notes:**
- This vulnerability requires the Treasury contract's `SymbolList` to be incomplete relative to tokens actually present in the system
- The automatic weekly execution via consensus contract makes this a recurring risk
- The period-based distribution model prevents any retroactive correction
- Beneficiaries permanently lose their share of non-native token rewards for affected periods

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L440-447)
```csharp
        var symbolList = State.DividendPoolContract.GetSymbolList.Call(new Empty());
        var amountsMap = symbolList.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L449-454)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L72-75)
```csharp
        State.SymbolList.Value = new SymbolList
        {
            Value = { Context.Variables.NativeSymbol }
        };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L394-397)
```csharp
    public override SymbolList GetSymbolList(Empty input)
    {
        return State.SymbolList.Value;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-460)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```
