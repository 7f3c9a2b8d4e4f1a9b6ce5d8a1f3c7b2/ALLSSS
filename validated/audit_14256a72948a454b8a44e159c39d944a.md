# Audit Report

## Title
Missing Validation for Negative Resource Amounts Enables Resource Rental Reversal Attack

## Summary
The `InitializeFromParentChain` method in the MultiToken contract lacks validation for negative `ResourceAmount` values. Non-exclusive side chains bypass CrossChain contract validation, allowing negative resource amounts to be set during initialization. This causes rental payment calculations to reverse - side chain creators receive tokens instead of paying fees, draining the consensus contract.

## Finding Description

The vulnerability arises from inconsistent validation across different initialization paths in the resource rental system.

**Root Cause - Missing Validation:**

The `InitializeFromParentChain` method directly sets resource amounts WITHOUT validating non-negativity. [1](#0-0) 

In contrast, `UpdateRentedResources` properly validates amounts as non-negative. [2](#0-1) 

**Protection Bypass - Validation Gap:**

The CrossChain contract's `AssertValidSideChainCreationRequest` returns early for non-exclusive side chains, bypassing resource amount validation. [3](#0-2) 

The `AssertValidResourceTokenAmount` validation requires positive values but is only called for exclusive chains. [4](#0-3) 

However, `InitialResourceAmount` is passed to side chains for ALL types in the chain initialization data. [5](#0-4) 

The protobuf definition uses `int32`, which permits negative values. [6](#0-5) 

**Exploitation Mechanism:**

When `PayRental` executes, it calculates rental using the potentially negative `ResourceAmount`. The calculation `rental = duration * ResourceAmount * Rental` produces a negative value when ResourceAmount is negative. [7](#0-6) 

With negative rental, the balance check `availableBalance >= rental` always passes, and `ModifyBalance(creator, -donates)` with negative donates adds tokens to the creator's balance, while `ModifyBalance(consensusContractAddress, donates)` with negative donates subtracts tokens from the consensus contract. [8](#0-7) 

The `DonateResourceToken` method is automatically generated as a system transaction during block production, triggering `PayRental` on side chains. [9](#0-8) 

## Impact Explanation

**Severity: HIGH**

This vulnerability enables direct token theft from the consensus contract with the following impacts:

1. **Fund Loss:** The consensus contract loses tokens proportional to `duration × |ResourceAmount| × Rental` every rental period
2. **Unauthorized Token Generation:** Side chain creators receive free tokens instead of paying rental fees  
3. **Economic Invariant Violation:** Breaks the fundamental design where resource rental must flow FROM creator TO consensus
4. **Cumulative Damage:** The theft repeats automatically every rental period for the lifetime of the side chain

The consensus contract accumulates rental payments from legitimate side chains [10](#0-9)  which can then be drained by an attacker's malicious side chain with negative resource amounts.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is feasible with the following considerations:

**Reachable Entry Point:**
- `RequestSideChainCreation` is a public method callable by any address [11](#0-10) 
- Automatic execution via system transaction generation [12](#0-11) 

**Preconditions:**
1. Attacker must create a non-exclusive side chain (permitted operation)
2. Must provide locked token amount and indexing fee allowance (economic barrier exists)
3. Requires governance approval through SideChainLifetimeController [13](#0-12) 
4. No special permissions or compromised keys required

**Execution Practicality:**
- Attack executes automatically after initialization
- No complex transaction crafting needed
- Works within normal AElf runtime semantics
- Accumulates unbounded gains over time

The governance approval requirement adds friction but may not prevent the attack since non-exclusive chains receive less scrutiny and validation focuses on economic parameters rather than technical resource amounts.

## Recommendation

Add non-negativity validation to `InitializeFromParentChain` method:

```csharp
public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
{
    Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
    State.InitializedFromParentChain.Value = true;
    Assert(input.Creator != null, "creator should not be null");
    
    // Add validation for non-negative resource amounts
    foreach (var pair in input.ResourceAmount)
    {
        Assert(pair.Value >= 0, "Invalid resource amount: must be non-negative.");
        State.ResourceAmount[pair.Key] = pair.Value;
    }

    foreach (var pair in input.RegisteredOtherTokenContractAddresses)
        State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

    SetSideChainCreator(input.Creator);
    return new Empty();
}
```

Additionally, consider enforcing validation for ALL side chain types in `AssertValidSideChainCreationRequest`, not just exclusive chains.

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Creates a non-exclusive side chain with negative `InitialResourceAmount` (e.g., CPU: -100)
2. Waits for governance approval
3. Observes that after side chain creation and initialization, `PayRental` executes automatically
4. Verifies that the side chain creator's balance increases while the consensus contract's balance decreases

The core exploitation logic relies on the rental calculation producing a negative value when `ResourceAmount` is negative, which then reverses the balance modifications in the payment flow.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-953)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1097)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L100-137)
```csharp
    private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
        Address proposer)
    {
        var proposedRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(proposedRequest == null || Context.CurrentBlockTime >= proposedRequest.ExpiredTime,
            "Request side chain creation failed.");

        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = proposer,
            Spender = Context.Self,
            Symbol = Context.Variables.NativeSymbol
        }).Allowance;

        Assert(
            allowance >= sideChainCreationRequest.LockedTokenAmount,
            "Allowance not enough.");

        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");

        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);

        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // assert primary token to create
        AssertValidSideChainTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest);
        Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
               sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
            "Invalid side chain token initial issue list.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L139-145)
```csharp
    private void AssertValidResourceTokenAmount(SideChainCreationRequest sideChainCreationRequest)
    {
        var resourceTokenMap = sideChainCreationRequest.InitialResourceAmount;
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayRentalSymbolListName))
            Assert(resourceTokenMap.ContainsKey(resourceTokenSymbol) && resourceTokenMap[resourceTokenSymbol] > 0,
                "Invalid side chain resource token request.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L360-388)
```csharp
    private SideChainCreationRequestState ProposeNewSideChain(SideChainCreationRequest request, Address proposer)
    {
        var sideChainLifeTimeController = GetSideChainLifetimeController();
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput =
                new CreateProposalInput
                {
                    ContractMethodName = nameof(CreateSideChain),
                    ToAddress = Context.Self,
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(SideChainCreationProposalExpirationTimePeriod),
                    Params = new CreateSideChainInput { SideChainCreationRequest = request, Proposer = proposer }
                        .ToByteString(),
                    OrganizationAddress = sideChainLifeTimeController.OwnerAddress
                },
            OriginProposer = Context.Sender
        };
        Context.SendInline(sideChainLifeTimeController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
        var sideChainCreationRequest = new SideChainCreationRequestState
        {
            SideChainCreationRequest = request,
            ExpiredTime = proposalCreationInput.ProposalInput.ExpiredTime,
            Proposer = proposer
        };
        return sideChainCreationRequest;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L516-557)
```csharp
    private ChainInitializationData GetChainInitializationData(SideChainInfo sideChainInfo,
        SideChainCreationRequest sideChainCreationRequest)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var res = new ChainInitializationData
        {
            CreationHeightOnParentChain = sideChainInfo.CreationHeightOnParentChain,
            ChainId = sideChainInfo.SideChainId,
            Creator = sideChainInfo.Proposer,
            CreationTimestamp = sideChainInfo.CreationTimestamp,
            ChainCreatorPrivilegePreserved = sideChainInfo.IsPrivilegePreserved,
            ParentChainTokenContractAddress = State.TokenContract.Value
        };

        var initialConsensusInfo = GetInitialConsensusInformation();
        res.ChainInitializationConsensusInfo = new ChainInitializationConsensusInfo
            { InitialConsensusData = initialConsensusInfo };

        var nativeTokenInformation = GetNativeTokenInfo().ToByteString();
        res.NativeTokenInfoData = nativeTokenInformation;

        var resourceTokenInformation = GetResourceTokenInfo().ToByteString();
        res.ResourceTokenInfo = new ResourceTokenInfo
        {
            ResourceTokenListData = resourceTokenInformation,
            InitialResourceAmount = { sideChainCreationRequest.InitialResourceAmount }
        };

        if (IsPrimaryTokenNeeded(sideChainCreationRequest))
        {
            var sideChainTokenInformation =
                GetTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenSymbol)
                    .ToByteString();
            res.ChainPrimaryTokenInfo = new ChainPrimaryTokenInfo
            {
                ChainPrimaryTokenData = sideChainTokenInformation,
                SideChainTokenInitialIssueList = { sideChainCreationRequest.SideChainTokenInitialIssueList }
            };
        }

        return res;
    }
```

**File:** protobuf/acs7.proto (L183-188)
```text
message ResourceTokenInfo{
    // The resource token information.
    bytes resource_token_list_data = 1;
    // The initial resource token amount.
    map<string, int32> initial_resource_amount = 2;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L28-75)
```csharp
    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();

        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        };

        var tokenContractAddress =
            await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
                TokenSmartContractAddressNameProvider.StringName);

        if (tokenContractAddress == null) return generatedTransactions;

        var totalResourceTokensMaps = await _totalResourceTokensMapsProvider.GetTotalResourceTokensMapsAsync(
            chainContext);

        ByteString input;
        if (totalResourceTokensMaps != null && totalResourceTokensMaps.BlockHeight == preBlockHeight &&
            totalResourceTokensMaps.BlockHash == preBlockHash)
            // If totalResourceTokensMaps match current block.
            input = totalResourceTokensMaps.ToByteString();
        else
            input = new TotalResourceTokensMaps
            {
                BlockHash = preBlockHash,
                BlockHeight = preBlockHeight
            }.ToByteString();

        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });

        Logger.LogTrace("Tx DonateResourceToken generated.");
        return generatedTransactions;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-94)
```csharp
    public override Empty Donate(DonateInput input)
    {
        EnsureTokenContractAddressSet();

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });

        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;

        Context.LogDebug(() => $"Contributed {input.Amount} {input.Symbol}s to side chain dividends pool.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L90-96)
```csharp
    public override Empty RequestSideChainCreation(SideChainCreationRequest input)
    {
        AssertValidSideChainCreationRequest(input, Context.Sender);
        var sideChainCreationRequestState = ProposeNewSideChain(input, Context.Sender);
        State.ProposedSideChainCreationRequestState[Context.Sender] = sideChainCreationRequestState;
        return new Empty();
    }
```
