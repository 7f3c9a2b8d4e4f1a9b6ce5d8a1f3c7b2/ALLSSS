# Audit Report

## Title
Consensus DoS via Missing Extra Block Producer Validation in Round Transition

## Summary
A malicious authorized miner can craft a `NextRoundInput` without designating any miner as the extra block producer, bypass validation, and store this malformed round in state. When any miner subsequently attempts to generate consensus commands for round termination, the system invokes `GetExtraBlockProducerInformation()` which uses `First()` on an empty sequence, throwing an `InvalidOperationException` and halting all consensus operations indefinitely.

## Finding Description

The AEDPoS consensus contract contains a critical validation gap that allows malicious round data to be persisted to state, breaking the fundamental invariant that every round must have exactly one extra block producer.

**Root Cause:**

The `GetExtraBlockProducerInformation()` method unconditionally uses `First()` with a predicate to retrieve the extra block producer. [1](#0-0)  If no miner has `IsExtraBlockProducer = true`, this will throw an `InvalidOperationException`.

This method is invoked during abnormal mining time arrangement, which is used when miners need to handle round termination. [2](#0-1) 

The consensus command generation flow calls this method when handling NextRound or NextTerm behaviors through the `TerminateRoundCommandStrategy`, which arranges extra block mining time. [3](#0-2) 

The mining time arranging service delegates to the round's abnormal mining time method. [4](#0-3) 

**Validation Gap:**

The `NextRound` method is publicly callable and only verifies the caller is an authorized miner through `PreCheck()`. [5](#0-4) 

The permission check only validates miner list membership, not the validity of the round data being submitted. [6](#0-5) 

The input is converted to a `Round` object through simple field copying without any validation of the extra block producer. [7](#0-6) 

The `RoundTerminateValidationProvider` only validates round number increment and that InValues are null, but **does not** check for extra block producer existence. [8](#0-7) 

The malicious round is then stored directly to state through `AddRoundInformation()`. [9](#0-8) 

**Exploit Sequence:**

1. Malicious authorized miner constructs a `NextRoundInput` where all miners have `IsExtraBlockProducer = false`
2. Submits transaction calling `NextRound()` - passes `PreCheck()` as authorized miner
3. Validation passes (no check for extra block producer)
4. Malformed round stored to `State.Rounds[roundNumber]`
5. When any miner calls `GetConsensusCommand()` for NextRound/NextTerm behavior, the command strategy invokes abnormal mining time arrangement
6. `GetExtraBlockProducerInformation()` executes `First()` on an empty sequence
7. `InvalidOperationException` thrown, consensus command generation fails
8. All miners affected - blockchain halts

The public `GetConsensusCommand()` method is called by miners during normal operation to obtain their next consensus instruction. [10](#0-9) 

When miners need to terminate a round, the system uses the terminate round command strategy. [11](#0-10) 

## Impact Explanation

**Severity: Critical**

This vulnerability enables complete denial of service of the consensus mechanism with catastrophic consequences:

- **Consensus Failure**: No miner can generate valid consensus commands once the malformed round is stored
- **Blockchain Halt**: Block production stops indefinitely as all command generation attempts throw exceptions
- **Transaction Processing**: All pending and new transactions cannot be processed
- **Cross-Chain Operations**: Side chains depending on this chain cannot proceed with cross-chain indexing
- **Economic Impact**: Staking rewards freeze, token operations halt, all DApp functionality stops
- **Recovery Difficulty**: The chain cannot recover through normal consensus flow - requires manual intervention and potentially hard fork

**Affected Parties:**
- All network validators and miners
- All users with pending transactions
- DApp operators and users
- Dependent side chains
- Token holders and stakers

The impact is maximal because once exploited, the entire blockchain becomes non-functional and cannot self-recover through the normal consensus protocol.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Must be an authorized miner in the current or previous miner list
- While this requires insider access or miner compromise, it represents a realistic threat in Byzantine fault tolerance scenarios

**Attack Complexity: Low**
- No complex timing requirements
- No race conditions to exploit
- Single transaction exploit
- Malicious input is trivial to construct (set all `IsExtraBlockProducer` flags to false)

**Feasibility: High**
- The validation gap is structural, not dependent on specific state conditions
- Exploitable immediately once miner access is obtained
- No additional privileges beyond miner status needed
- The vulnerability is deterministic and reproducible

**Detection: Post-Exploitation Only**
- The malicious round is stored before any failure occurs
- Consensus failure becomes apparent only when miners attempt command generation
- By that point, the damage is irreversible through normal consensus

Given that blockchain consensus systems must be resilient against Byzantine actors (malicious miners), and the attack requires only miner-level access with trivial execution complexity, this represents a significant practical threat.

## Recommendation

Add validation to ensure every round has exactly one extra block producer before storing it to state. This validation should be added in two places:

1. **In `RoundTerminateValidationProvider.ValidationForNextRound()`**: Add a check that verifies exactly one miner has `IsExtraBlockProducer = true`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate extra block producer exists
    var extraBlockProducerCount = extraData.Round.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    if (extraBlockProducerCount != 1)
        return new ValidationResult { Message = "Round must have exactly one extra block producer." };

    return new ValidationResult { Success = true };
}
```

2. **In `NextRoundInput.ToRound()` or during `ProcessNextRound()`**: Add defensive validation before persisting the round to state.

Additionally, consider making `GetExtraBlockProducerInformation()` more defensive by using `FirstOrDefault()` and handling the null case gracefully, though the primary fix should be preventing invalid rounds from being stored.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Deploy the AEDPoS consensus contract in test mode
2. Initialize with valid miners
3. As an authorized miner, craft a `NextRoundInput` where no miner has `IsExtraBlockProducer = true`
4. Call `NextRound()` with this malformed input
5. Verify the transaction succeeds (validation passes)
6. Call `GetConsensusCommand()` as any miner with NextRound behavior
7. Observe `InvalidOperationException` being thrown from `GetExtraBlockProducerInformation()`
8. Verify that consensus is now halted and no further blocks can be produced

The test would confirm that malformed round data bypasses validation and causes consensus failure when command generation is attempted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-26)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```
