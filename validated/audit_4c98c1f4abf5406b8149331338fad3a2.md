# Audit Report

## Title
Miners Can Manipulate Mining Order by Providing Arbitrary SupposedOrderOfNextRound Values

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` values from miners without validating they match the signature-based calculation, allowing miners to arbitrarily choose their mining position in subsequent rounds and breaking consensus fairness guarantees.

## Finding Description

The AEDPoS consensus mechanism is designed to calculate each miner's position in the next round based on their cryptographic signature using the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1` to ensure unpredictability and fairness. [1](#0-0) 

This calculation occurs when `GetConsensusExtraDataToPublishOutValue` calls `ApplyNormalConsensusData`: [2](#0-1) 

However, the critical vulnerability exists in `ProcessUpdateValue`, which directly assigns the `SupposedOrderOfNextRound` value from the transaction input without any recalculation or validation: [3](#0-2) 

The validation phase only checks that `OutValue` and `Signature` are non-null and validates the `PreviousInValue` hash relationship, but completely omits validation of the `SupposedOrderOfNextRound`: [4](#0-3) [5](#0-4) 

Furthermore, the `NextRoundMiningOrderValidationProvider` is only applied for `NextRound` behavior, not for `UpdateValue`: [6](#0-5) 

This validator only checks that the count of miners with valid orders matches the count who mined, but does not verify individual `SupposedOrderOfNextRound` correctness: [7](#0-6) 

The manipulated `SupposedOrderOfNextRound` becomes the `FinalOrderOfNextRound` and is directly used by `GenerateNextRoundInformation` to determine mining positions in the next round: [8](#0-7) 

## Impact Explanation

This vulnerability fundamentally breaks the fairness and unpredictability guarantees of the AEDPoS consensus mechanism:

1. **Consensus Manipulation**: A malicious miner can consistently position themselves first in mining order, giving them priority access to block production and extra block rewards.

2. **Economic Advantage**: The first miner produces extra blocks if subsequent miners are offline or late, earning disproportionate rewards. They also have priority in transaction inclusion and MEV extraction opportunities.

3. **Random Number Influence**: Mining order affects the sequence of random number generation in the consensus mechanism, potentially enabling manipulation of consensus randomness used by other protocol operations.

4. **Systemic Risk**: If multiple colluding miners exploit this, they could coordinate their positions to dominate consensus, destabilize round transitions, or create predictable mining patterns that undermine the security model.

The impact is **CRITICAL** because it breaks a core invariant: that mining order must be cryptographically unpredictable and derived from signatures, not arbitrarily chosen by miners.

## Likelihood Explanation

The attack is **HIGHLY LIKELY** with minimal complexity:

**Attacker Capabilities**: Any active miner in the consensus set can execute this attack. No special privileges required beyond normal miner participation.

**Attack Steps**:
1. Miner calls `GetConsensusExtraData` (a view function) to obtain valid `OutValue` and `Signature` values for their legitimate mining operation
2. Miner constructs a modified `UpdateValueInput` with the valid cryptographic values but replaces `SupposedOrderOfNextRound` with their desired value (e.g., 1 for first position)
3. Miner includes this modified transaction in their block during their mining turn
4. The contract accepts the arbitrary order value and uses it for next round generation

**Feasibility**: The attack requires no special conditionsâ€”just normal participation in consensus. The cost is negligible (standard transaction gas), while the benefit is continuous preferential mining positions and increased block rewards. Miners are economically incentivized to exploit this vulnerability.

## Recommendation

Add validation in `ProcessUpdateValue` to recalculate and verify the `SupposedOrderOfNextRound` value matches the cryptographic calculation:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // Recalculate the supposed order from signature
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    var sigNum = updateValueInput.Signature.ToInt64();
    var calculatedSupposedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    
    // Validate the provided value matches the calculation
    Assert(updateValueInput.SupposedOrderOfNextRound == calculatedSupposedOrder, 
        "Invalid SupposedOrderOfNextRound: does not match signature-based calculation.");
    
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    minerInRound.Signature = updateValueInput.Signature;
    minerInRound.OutValue = updateValueInput.OutValue;
    minerInRound.SupposedOrderOfNextRound = calculatedSupposedOrder;
    minerInRound.FinalOrderOfNextRound = calculatedSupposedOrder;
    // ... rest of the method
}
```

Additionally, add the helper method to the contract: [9](#0-8) 

## Proof of Concept

A malicious miner can execute this attack during their mining turn by:

1. Calling `GetConsensusExtraData` to obtain their legitimate `OutValue` and `Signature`
2. Creating an `UpdateValueInput` with:
   - The valid `OutValue` and `Signature` from step 1
   - A manipulated `SupposedOrderOfNextRound` = 1 (to be first next round)
   - Other required fields (PreviousInValue, ActualMiningTime, etc.)
3. Including this transaction in their block
4. The validation passes because only `OutValue`, `Signature`, and `PreviousInValue` are checked
5. The manipulated order value is saved to state
6. In the next round, the miner mines first due to their manipulated `FinalOrderOfNextRound`

This can be repeated indefinitely, allowing the attacker to consistently maintain first position across rounds.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```
