# Audit Report

## Title
MissedTimeSlots Counter Reset at Term Transitions Allows Indefinite Miner Retention Despite Poor Performance

## Summary
The AEDPoS consensus contract unconditionally resets the `MissedTimeSlots` counter to zero at every term transition, preventing the evil miner detection mechanism from functioning when term durations are shorter than the time required to accumulate the 4,320 missed slot threshold. This allows underperforming miners to remain in the consensus set indefinitely based solely on voting power, undermining network integrity.

## Finding Description

The consensus contract implements an evil miner detection system that tracks missed time slots and removes miners who exceed a threshold. However, a critical design flaw allows this protection to be bypassed in deployments with short term durations.

**Vulnerability Flow:**

1. During normal round transitions, miners who fail to produce blocks have their `MissedTimeSlots` counter incremented by 1. [1](#0-0) 

2. The system defines a detection threshold of 4,320 missed time slots (representing 3 days at 1 slot per minute). [2](#0-1) 

3. The `TryToDetectEvilMiners()` method checks if any miner has exceeded this threshold. [3](#0-2) 

4. Evil miner detection occurs during `ProcessNextRound()`, where detected miners are marked for removal via the Election contract. [4](#0-3) 

**Root Cause:**

At every term transition, the `ProcessNextTerm()` function unconditionally resets all miners' `MissedTimeSlots` and `ProducedBlocks` counters to zero for the next term. [5](#0-4) 

This reset occurs BEFORE the counter can reach 4,320 if the term duration is shorter than the accumulation time. With 17 miners and 4-second intervals, accumulating 4,320 missed slots requires approximately 293,760 seconds (â‰ˆ3.4 days), but configurations exist with `PeriodSeconds` set to 120 seconds (2 minutes). [6](#0-5) [7](#0-6) 

**Why Protections Fail:**

1. Evil miner detection only checks the Round-level `MissedTimeSlots` counter which resets at term boundaries
2. Miner selection for new terms is based purely on voting power (`ObtainedActiveVotedVotesAmount`), with no consideration of performance metrics. [8](#0-7) 
3. Although missed slot statistics are sent to the Election contract and accumulated, [9](#0-8) [10](#0-9)  this cumulative data is never used to prevent miner re-selection
4. No validation exists to ensure `PeriodSeconds` is configured long enough for the detection mechanism to function. [11](#0-10) 

## Impact Explanation

**Consensus Integrity Degradation**: Miners who consistently fail to produce blocks can occupy consensus slots indefinitely, reducing the network's effective block production rate. With a typical set of 17 miners, even 2-3 inactive miners represent 12-18% capacity loss.

**Network Liveness Risk**: If multiple miners exploit this mechanism simultaneously, the effective number of active block producers decreases, potentially impacting the network's ability to achieve two-thirds consensus for critical operations and increasing block time variance.

**Opportunity Cost**: Active, high-performing candidates are denied miner positions while underperforming miners retain their slots based solely on voting power, misaligning the consensus set with actual network contribution.

**Severity Justification**: Medium - While miners do lose block production rewards for non-production, [12](#0-11)  they can maintain consensus participation rights and governance influence indefinitely, affecting protocol security and fairness.

## Likelihood Explanation

**Preconditions**: This vulnerability manifests when the term duration (`PeriodSeconds`) is configured shorter than approximately 3.4 days. Test environments and potentially sidechains use 120-second terms, making this highly exploitable in those contexts.

**Execution Simplicity**: A miner simply stops producing blocks during their assigned time slots. This requires no special transactions, exploits, or technical sophistication - passive non-participation is sufficient.

**Economic Rationale**: Despite losing block production rewards, a miner may rationally choose to:
- Maintain consensus voting rights for governance decisions
- Reduce infrastructure costs while preserving their position
- Wait for more favorable economic conditions to resume active mining

**Detection Difficulty**: Missed blocks appear identical to legitimate network issues, making intentional non-production difficult to distinguish from technical problems.

**Mainnet vs. Other Networks**: The mainnet configuration uses 7-day terms (604800 seconds), [13](#0-12)  which is longer than the 3.4-day threshold, so the mechanism works correctly there. However, this represents a configuration vulnerability for sidechains, testnets, and future deployments.

## Recommendation

Implement one or more of the following mitigations:

1. **Validate Minimum Term Duration**: Add validation in `InitialAElfConsensusContract()` to ensure `PeriodSeconds` is at least 4 days (345,600 seconds) to allow evil miner detection to function:
   ```csharp
   Assert(input.PeriodSeconds >= 345600 || input.IsTermStayOne, 
          "PeriodSeconds must be at least 4 days for evil miner detection");
   ```

2. **Implement Cross-Term Accumulation**: Maintain a separate cumulative `TotalMissedTimeSlots` counter that persists across term transitions, checked independently during term changes.

3. **Use Election Contract Data**: Modify `GetVictories()` to filter candidates based on their cumulative `MissedTimeSlots` stored in the Election contract, preventing re-selection of consistently underperforming miners.

4. **Proportional Threshold**: Scale the detection threshold based on term duration: `min(4320, PeriodSeconds / 60 * 0.75)` to ensure detection is possible within each term.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MinerCanAvoidEvilDetectionWithShortTerms()
{
    // Setup: Initialize consensus with 120-second terms (2 minutes)
    await InitializeConsensusWithShortTerm(periodSeconds: 120);
    
    // Scenario: Miner stops producing blocks entirely
    var maliciousMiner = InitialMiners[0];
    
    // Simulate multiple term transitions over 1 hour
    for (int term = 1; term <= 30; term++) // 30 terms * 2 minutes = 60 minutes
    {
        // Miner misses all slots in this term (never produces)
        await SkipMinerBlockProductionForEntireTerm(maliciousMiner);
        
        // Trigger term transition
        await TransitionToNextTerm();
        
        // Verify: MissedTimeSlots was reset to 0
        var roundInfo = await GetCurrentRoundInformation();
        var minerInfo = roundInfo.RealTimeMinersInformation[maliciousMiner];
        
        // Counter is reset, so it never accumulates to 4320
        Assert.True(minerInfo.MissedTimeSlots < 4320);
        
        // Verify: Miner is NOT banned and remains in the miner list
        Assert.False(await IsMinerBanned(maliciousMiner));
        Assert.Contains(maliciousMiner, await GetCurrentMinerList());
    }
    
    // Result: After 1 hour of complete non-participation across 30 terms,
    // the miner is still in the consensus set and has never been detected as evil
    Assert.Contains(maliciousMiner, await GetCurrentMinerList());
}
```

The test demonstrates that with 120-second terms, a miner can avoid detection indefinitely because `MissedTimeSlots` resets every 2 minutes, preventing accumulation to the 4,320 threshold that would require ~3.4 days of continuous non-production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L54-54)
```csharp
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/AEDPoSContractTestConstants.cs (L20-20)
```csharp
    internal const long PeriodSeconds = 120; // 7 * 60 * 60 * 24
```

**File:** src/AElf.ContractTestKit.AEDPoSExtension/AEDPoSExtensionConstants.cs (L13-13)
```csharp
    public const int PeriodSeconds = 120;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-118)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-29)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;
```

**File:** src/AElf.Launcher/appsettings.json (L30-30)
```json
    "PeriodSeconds": 604800,
```
