# Audit Report

## Title
Secret Sharing Validation Bypass Allows Mining Order Manipulation in AEDPoS Consensus

## Summary
The AEDPoS consensus contract fails to validate that reconstructed InValues from secret sharing match previously published OutValues. A malicious miner can publish `OutValue = Hash(InValue_A)` while providing encrypted pieces of `InValue_B`, where `InValue_B ≠ InValue_A`. This allows manipulation of signature calculations used for mining order determination, undermining the consensus protocol's randomness guarantees.

## Finding Description

The vulnerability exists in the secret sharing revelation mechanism where InValues are reconstructed from encrypted/decrypted pieces without cryptographic validation against the originally committed OutValues.

**Root Cause - Missing Validation in Secret Sharing Reconstruction:**

When off-chain services reconstruct InValues through secret sharing, they compute the revealed value but never validate it matches the miner's published OutValue. [1](#0-0) 

This reconstructed value is then included in `RevealedInValues` and propagated to the on-chain contract via `MinersPreviousInValues`: [2](#0-1) [3](#0-2) 

**Critical Validation Gap:**

When `ProcessUpdateValue` processes these values, it directly sets PreviousInValue for other miners without any validation: [4](#0-3) 

The existing `UpdateValueValidationProvider` only validates the PreviousInValue of the transaction sender, NOT the values being set for other miners in `MinersPreviousInValues`: [5](#0-4) 

**Attack Execution Path:**

1. **Malicious UpdateValue Submission:** In round N, attacker submits `UpdateValue` with:
   - `OutValue = Hash(InValue_A)` (legitimate-looking commitment)
   - `EncryptedPieces(InValue_B)` where `InValue_B ≠ InValue_A` (fraudulent shares)

   The encrypted pieces are stored without validation: [6](#0-5) 

2. **Secret Reconstruction:** In round N+1, honest miners' off-chain service reconstructs `Hash(InValue_B)` from the attacker's encrypted pieces and includes it in their `UpdateValue` transaction's `MinersPreviousInValues`.

3. **State Corruption:** The contract sets `attacker's PreviousInValue = Hash(InValue_B)` without verifying `Hash(InValue_B) == Hash(InValue_A)`.

4. **Signature Manipulation:** This fraudulent PreviousInValue is used in signature calculations: [7](#0-6) 

   The signature is computed using XOR operations: [8](#0-7) 

5. **Mining Order Impact:** The manipulated signature determines the miner's position: [9](#0-8) 

## Impact Explanation

**Severity: HIGH - Consensus Integrity Violation**

This vulnerability directly compromises the consensus protocol's core security guarantees:

1. **Mining Order Manipulation:** Attackers can influence their `SupposedOrderOfNextRound` by controlling the InValue used in signature calculations, potentially securing favorable mining positions.

2. **Randomness Degradation:** AEDPoS relies on XOR-combined signatures for randomness generation. By injecting arbitrary InValues through fraudulent secret sharing, attackers can bias the consensus randomness, which is critical for fair extra block producer selection and other protocol operations.

3. **Protocol Trust Breakdown:** The fundamental assumption that InValues are cryptographically bound to their OutValues through hash commitments is violated, degrading the security model that ensures miners cannot manipulate their revealed values retroactively.

4. **Collusion Amplification:** Multiple colluding malicious miners can compound this attack to achieve greater control over mining schedules and randomness outcomes.

While this doesn't immediately enable fund theft, it violates critical consensus invariants that ensure fair block production and network security, meeting the threshold for HIGH impact on protocol integrity.

## Likelihood Explanation

**Probability: HIGH**

**Attacker Prerequisites:**
- Must be an active consensus miner (normal operational requirement)
- Ability to call `UpdateValue` (standard miner capability)
- No special permissions or administrative access required

**Attack Complexity: LOW**
1. Generate legitimate `InValue_A` and compute `OutValue = Hash(InValue_A)`
2. Create different `InValue_B`
3. Use Shamir's Secret Sharing to generate encrypted pieces of `InValue_B`
4. Submit `UpdateValue` with `OutValue` from step 1 but encrypted pieces from step 3
5. Wait for honest miners to reconstruct and propagate the fraudulent value

**Feasibility Conditions:**
- Works whenever secret sharing is enabled in the configuration
- No additional preconditions or complex state setup required

**Detection Difficulty: HARD**
The encrypted pieces are cryptographically valid and properly formatted. Only the semantic relationship between the revealed InValue and the published OutValue is incorrect, requiring off-chain monitoring of both committed and revealed values to detect.

## Recommendation

Add validation in `ProcessUpdateValue` to verify that any PreviousInValue being set for a miner matches their previously published OutValue:

```csharp
foreach (var previousInValue in input.MinersPreviousInValues)
{
    // Validate that the revealed InValue matches the miner's OutValue from previous round
    if (previousRound != null && 
        previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
    {
        var expectedOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
        var actualHash = HashHelper.ComputeFrom(previousInValue.Value);
        
        Assert(actualHash == expectedOutValue, 
            $"Revealed InValue does not match OutValue for miner {previousInValue.Key}");
    }
    
    round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

This ensures the cryptographic binding between OutValue commitments and revealed InValues is enforced, preventing miners from submitting fraudulent secret shares.

## Proof of Concept

A proof of concept would require:

1. Setting up a local AEDPoS test network with multiple miner nodes
2. Implementing a malicious miner that:
   - Generates `InValue_A` and publishes `OutValue = Hash(InValue_A)`
   - Creates secret shares of a different `InValue_B`
   - Submits these mismatched values in an `UpdateValue` transaction
3. Observing that the revealed `PreviousInValue = Hash(InValue_B)` is accepted and persisted
4. Verifying the manipulated signature affects the miner's `SupposedOrderOfNextRound`

The test would demonstrate that no validation prevents this mismatch, confirming the vulnerability.

---

**Notes:**

The vulnerability is subtle because it exploits a gap between:
- Individual miner validation (which checks their own PreviousInValue)
- Collective revelation validation (which should check revealed values for all miners)

The protocol correctly validates that a miner's self-provided PreviousInValue matches their OutValue, but fails to validate when other miners reveal values on their behalf through secret sharing. This asymmetry creates the exploitable validation bypass.

### Citations

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L175-180)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L47-47)
```csharp
            MinersPreviousInValues = { minersPreviousInValues },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L290-290)
```csharp
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-48)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L199-199)
```csharp
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
