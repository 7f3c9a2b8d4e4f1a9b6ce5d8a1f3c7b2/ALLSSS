# Audit Report

## Title
Mid-Voting Member Addition Enables Retroactive Vote Manipulation

## Summary
The Association contract allows organizations to add new members during active proposal voting periods. These newly added members can immediately vote on pre-existing proposals, and their votes are counted using the current organization member list rather than a membership snapshot taken at proposal creation time. This design flaw enables retroactive manipulation of vote outcomes, violating the fundamental governance principle that vote outcomes should be determined by the electorate as it existed when voting began.

## Finding Description

The vulnerability stems from the interaction between member management and vote counting mechanisms in the Association governance contract.

**No Membership Snapshot Protection**: The `AddMember()` function adds members to the organization without creating historical snapshots or checking for active proposals. [1](#0-0) 

**Vote Authorization Against Current Membership**: When members attempt to vote, the authorization check verifies their presence in the CURRENT organization member list via `AssertIsAuthorizedOrganizationMember()`. [2](#0-1) [3](#0-2) [4](#0-3) 

The authorization function checks current membership only: [5](#0-4) 

**Vote Counting Filters By Current Membership**: When determining if a proposal can be released, the system counts votes by filtering them against the CURRENT organization member list:
- Rejections: [6](#0-5) 
- Abstentions: [7](#0-6) 
- Approvals: [8](#0-7) 

**Missing Snapshot in ProposalInfo**: The `ProposalInfo` structure stores voter address lists but does not capture a snapshot of the organization's member list at proposal creation time. [9](#0-8) 

**Attack Execution Path**:
1. Organization has 5 members {A,B,C,D,E} with MinimalApprovalThreshold=3, MaximalRejectionThreshold=2
2. Proposal P1 is created and receives 3 approvals from A, B, C (meets approval threshold)
3. Attacker controls sufficient members to pass proposals adding new members F, G, H
4. New members F, G, H are added via successful AddMember proposals
5. F, G, H immediately vote to reject P1 (authorization succeeds as they're in current member list)
6. When Release(P1) is attempted, `IsProposalRejected()` counts 3 rejections from F, G, H
7. Since 3 > MaximalRejectionThreshold (2), `IsReleaseThresholdReached()` returns false
8. P1 cannot be released despite having achieved the approval threshold before the membership change

This breaks the governance invariant that proposal outcomes should be determined by the electorate at the time of proposal creation.

## Impact Explanation

**HIGH Severity** - This vulnerability enables critical governance attacks:

**Proposal Blocking**: Legitimate proposals that have achieved the required approval threshold can be retroactively blocked by adding new attacker-controlled members who vote to reject them, pushing rejection counts above `MaximalRejectionThreshold`.

**Malicious Proposal Approval**: Failing malicious proposals can be rescued by adding new attacker-controlled members who vote to approve them, pushing approval counts above `MinimalApprovalThreshold`.

**Governance Integrity Violation**: The fundamental principle of democratic governance is that vote outcomes should reflect the will of the electorate as it existed when voting began. This vulnerability allows the electorate itself to be manipulated mid-vote to alter outcomes, fundamentally undermining trust in the governance system.

**Systemic Risk**: This affects all Association organizations across the AElf ecosystem, making it a protocol-wide governance vulnerability rather than an isolated contract issue.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** - The attack is practical and straightforward to execute:

**Attacker Prerequisites**: 
- Requires control of sufficient organization members to pass `AddMember` proposals
- This is the same threshold needed for normal governance operations

**Attack Complexity**: LOW
- No sophisticated technical knowledge required
- Simple transaction sequence: create AddMember proposal → get it approved → new members vote
- No strict timing constraints beyond standard proposal expiration windows

**Detection Challenges**: 
- Member additions emit `MemberAdded` events but appear as legitimate governance actions
- By the time additions are detected, new members can already influence active proposals
- No built-in protection mechanisms exist in the contract

**Economic Feasibility**: If an attacker already has temporary governance control, the cost is minimal (only transaction fees), while the potential benefit from manipulating high-value proposals could be substantial.

## Recommendation

Implement membership snapshot protection by capturing and storing the organization's member list at proposal creation time:

1. **Add Snapshot Field to ProposalInfo**: Extend the `ProposalInfo` structure to include `repeated aelf.Address eligible_voters` field that captures the organization member list at proposal creation time.

2. **Snapshot During Proposal Creation**: In the `CreateNewProposal()` function, copy the current organization member list into the proposal's eligible_voters field.

3. **Use Snapshot for Authorization**: Modify `AssertIsAuthorizedOrganizationMember()` to check against the proposal's eligible_voters snapshot rather than the current organization member list when validating votes.

4. **Use Snapshot for Vote Counting**: Update `IsProposalRejected()`, `IsProposalAbstained()`, and `CheckEnoughVoteAndApprovals()` to filter votes against the proposal's eligible_voters snapshot instead of the current organization member list.

This ensures that proposal outcomes are determined by the electorate as it existed when the proposal was created, preventing retroactive manipulation through membership changes.

## Proof of Concept

```csharp
[Fact]
public async Task MidVoting_MemberAddition_Enables_Retroactive_VoteManipulation_Test()
{
    // Setup: Create organization with 5 members and specific thresholds
    var minimalApprovalThreshold = 3;
    var maximalRejectionThreshold = 2;
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 5, 0, maximalRejectionThreshold, 
        Reviewer1);
    
    // Step 1: Create proposal P1
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    await TransferToOrganizationAddressAsync(organizationAddress);
    
    // Step 2: P1 receives 3 approvals (meets threshold)
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Reviewer3KeyPair, proposalId);
    
    // Verify P1 can be released at this point
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue();
    
    // Step 3: Add new members F, G, H via governance proposals
    var newMember1 = Accounts[4].Address;
    var newMember2 = Accounts[5].Address;
    var newMember3 = Accounts[6].Address;
    
    var addMemberProposal1 = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, newMember1, nameof(AssociationContractStub.AddMember), 
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, addMemberProposal1);
    await ApproveAsync(Reviewer2KeyPair, addMemberProposal1);
    await ApproveAsync(Reviewer3KeyPair, addMemberProposal1);
    await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(addMemberProposal1);
    
    // Repeat for members 2 and 3
    var addMemberProposal2 = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, newMember2, nameof(AssociationContractStub.AddMember), 
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, addMemberProposal2);
    await ApproveAsync(Reviewer2KeyPair, addMemberProposal2);
    await ApproveAsync(Reviewer3KeyPair, addMemberProposal2);
    await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(addMemberProposal2);
    
    var addMemberProposal3 = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, newMember3, nameof(AssociationContractStub.AddMember), 
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, addMemberProposal3);
    await ApproveAsync(Reviewer2KeyPair, addMemberProposal3);
    await ApproveAsync(Reviewer3KeyPair, addMemberProposal3);
    await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(addMemberProposal3);
    
    // Step 4: New members vote to reject P1
    await RejectAsync(Accounts[4].KeyPair, proposalId);
    await RejectAsync(Accounts[5].KeyPair, proposalId);
    await RejectAsync(Accounts[6].KeyPair, proposalId);
    
    // Step 5: Verify P1 can no longer be released
    proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeFalse(); // Vulnerability: P1 is now blocked
    
    // Attempt to release should fail
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved.");
}
```

## Notes

This vulnerability represents a fundamental design flaw in how the Association contract handles the temporal relationship between membership and voting rights. The attack is particularly insidious because:

1. **Legitimate-Looking Operations**: All actions (AddMember proposals and subsequent votes) appear as normal governance activities, making detection difficult.

2. **Threshold Immutability**: While member counts change, the threshold values (`MaximalRejectionThreshold`, `MinimalApprovalThreshold`) remain fixed, creating a mismatch that attackers can exploit.

3. **Bidirectional Exploitation**: The vulnerability works both ways - attackers can block legitimate proposals OR force through malicious ones by manipulating membership.

4. **No Built-in Protections**: The contract lacks any temporal guards, snapshot mechanisms, or checks to prevent this class of attack.

The recommended fix requires both storage changes (adding snapshot fields) and logic changes (using snapshots for authorization and counting), but is essential to maintain governance integrity.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L148-148)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L168-168)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** protobuf/association_contract.proto (L77-103)
```text
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```
