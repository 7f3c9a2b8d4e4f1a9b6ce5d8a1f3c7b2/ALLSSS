# Audit Report

## Title
Consensus Signature Manipulation Allows Mining Order Control

## Summary
The AEDPoS consensus contract lacks validation to verify that the signature field in UpdateValue transactions matches its expected calculated value. A malicious miner can submit arbitrary signature values that directly determine their mining order in the next round, breaking consensus fairness and enabling strategic position manipulation.

## Finding Description

The AEDPoS consensus mechanism relies on unpredictable signature values to fairly determine mining order in subsequent rounds. However, the contract never validates that provided signatures match their expected calculation from previous round state.

**Expected Behavior:**
During normal block production, the signature is calculated deterministically using [1](#0-0) , which XORs the previousInValue with all signatures from the previous round via [2](#0-1) .

**Vulnerable Code Path:**

1. When a block is validated, the signature from consensus extra data is blindly copied without verification in [3](#0-2) 

2. The validation provider only checks that the signature is non-null and non-empty, not correctness: [4](#0-3) 

3. During execution, the unvalidated signature is stored directly: [5](#0-4) 

4. This signature directly determines the miner's order in the next round through modulo operation: [6](#0-5) 

5. The calculated order is used to set actual mining positions in the next round: [7](#0-6) 

**Attack Scenario:**
A malicious miner modifies their node to:
1. Calculate their desired mining position for the next round
2. Work backwards to determine which signature value will produce that position via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. Include this manipulated signature in their block's consensus extra data
4. All validations pass since no check verifies `providedSignature == previousRound.CalculateSignature(previousInValue)`

## Impact Explanation

**Consensus Integrity Violation:**
The mining order is designed to be unpredictable, derived from cryptographic operations on secret values. By controlling their signature value, an attacker gains direct control over their mining position, fundamentally breaking the fairness guarantee.

**Concrete Harms:**
- **Strategic Mining Advantage**: Attackers position themselves optimally (e.g., first in round for transaction ordering influence, or after specific miners for MEV extraction)
- **Coordinated Attacks**: Multiple colluding miners coordinate signature values to control the entire mining sequence
- **Randomness Compromise**: Protocol security assumptions based on unpredictable mining order are violated
- **LIB Manipulation**: Strategic positions influence Last Irreversible Block calculations, affecting finality

**Affected Parties:**
- Honest miners lose fair mining opportunities
- Users face reduced security from compromised consensus randomness  
- DApps relying on consensus fairness for timing-sensitive operations are at risk

## Likelihood Explanation

**Attack Prerequisites:**
- Must be an elected miner (validated by existing permission checks)
- Must produce blocks during assigned time slots (validated by time slot checks)
- Requires only normal mining node operation with minor code modifications

**Attack Complexity: LOW**
1. Calculate correct OutValue and PreviousInValue (both validated by existing checks)
2. Choose arbitrary signature value targeting desired mining order
3. Include in block consensus extra data
4. All validations pass - no signature correctness check exists

**Feasibility: HIGH**
- No cryptographic keys need compromise
- Standard miner privileges sufficient (obtainable through election)
- No cryptographic primitives need breaking - this is a validation gap
- Executable every round without detection
- Manipulated signatures appear identical to valid ones (properly formatted Hash values)

**Economic Rationality: HIGH**
- Cost: Standard transaction fees only
- Benefit: Strategic mining position provides MEV, optimal rewards, consensus influence
- Risk: Undetectable as no validation checks signature correctness

## Recommendation

Add signature correctness validation in `UpdateValueValidationProvider.ValidateHeaderInformation()`:

```csharp
private bool ValidateSignatureCorrectness(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var previousInValue = minerInRound.PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // Skip validation for first round or missing previous in value
        
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return minerInRound.Signature == expectedSignature;
}
```

Then call this method in the main validation logic before returning success.

## Proof of Concept

A malicious miner can exploit this by:

1. Obtaining miner status through standard election
2. Modifying their node's `GetConsensusExtraDataToPublishOutValue` method to calculate a favorable signature:
   - Instead of `signature = previousRound.CalculateSignature(previousInValue)` at line 92
   - Calculate desired order: `desiredOrder` (e.g., 1 for first position)
   - Work backwards: `manipulatedSignature = CalculateSignatureForDesiredOrder(desiredOrder, minersCount)`
3. Produce block with this manipulated signature in consensus extra data
4. Block passes all validations since none verify signature correctness
5. In next round, attacker mines at their chosen position via the modulo calculation

The vulnerability can be demonstrated by creating a test that:
- Sets up a round with multiple miners
- Creates an UpdateValue with an arbitrary signature (not calculated via CalculateSignature)
- Verifies the block passes validation
- Confirms the miner's next round order is determined by the arbitrary signature value

**Notes**

The vulnerability exists because the signature field, while cryptographically calculated in honest implementations, is never validated against its expected value during block validation. The only checks are for non-null/non-empty values and proper PreviousInValue hashing, creating a critical gap that allows direct mining order manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
