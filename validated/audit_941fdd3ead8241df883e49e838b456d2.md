# Audit Report

## Title
Hash Collision in NFT Token Identification Causes Cross-Protocol Balance and State Corruption

## Summary
The `CalculateTokenHash` function concatenates NFT symbol and tokenId without a delimiter, creating hash collisions when protocol symbol lengths transition from N to N+1 digits. This allows different NFTs from different protocols to share the same tokenHash, corrupting balances, metadata, allowances, and assembly data across protocols.

## Finding Description

The core vulnerability exists in the `CalculateTokenHash` function which computes NFT identifiers through direct string concatenation without any delimiter. [1](#0-0) 

NFT protocol symbols follow the format `{2-letter-code}{N-digit-number}`, where 2-letter codes are defined in the type mapping (AR, MU, VW, etc.). [2](#0-1) 

The random number portion starts at 9 digits and grows dynamically. [3](#0-2) 

The number length increases when protocol count exceeds capacity. [4](#0-3) 

**Collision Scenario:**
- Early protocol: "AR123456789" (2 letters + 9 digits)
- Later protocol: "AR1234567891" (2 letters + 10 digits)
- Concatenation "AR123456789" + "123" = "AR123456789123"
- Concatenation "AR1234567891" + "23" = "AR123456789123"
- **Both produce identical strings before hashing → same tokenHash**

This colliding tokenHash corrupts all state mappings that use it as a key. [5](#0-4) 

Critical operations use this flawed hash calculation including Transfer, TransferFrom, Burn, and Approve. [6](#0-5) [7](#0-6) 

The `PerformMint` function only validates tokenId uniqueness within a protocol, not tokenHash uniqueness across protocols. When `IsTokenIdReuse` is true and `isTokenIdMustBeUnique` is false, the validation is bypassed, allowing the collision. Even when validation runs, it provides misleading error messages and can modify existing NFT data from different protocols. [8](#0-7) 

Minters can specify arbitrary tokenIds when minting, enabling precise collision targeting. [9](#0-8) 

## Impact Explanation

**Critical State Corruption:**

1. **Balance Mixing**: `BalanceMap[tokenHash][owner]` combines balances from NFTs of different protocols. Users querying balance of ("AR123456789", 123) receive an incorrect total including balance from ("AR1234567891", 23).

2. **NFT Metadata Overwrite**: When the second colliding NFT is minted and validation is bypassed, it modifies the first NFT's metadata in `NftInfoMap[tokenHash]`, corrupting protocol name, creator, base URI, and custom metadata.

3. **Allowance Confusion**: `AllowanceMap[tokenHash][owner][spender]` shares approval state between different NFTs, allowing unintended transfers of NFTs from different protocols.

4. **Assembly Data Corruption**: `AssembledNftsMap` and `AssembledFtsMap` store incorrect component data, breaking disassembly operations and potentially locking funds permanently.

**Fund Impact**: Users lose access to NFTs or receive incorrect balances. Transfers and burns may affect wrong NFTs. Protocol supply counters become inaccurate. Assembled NFTs cannot be properly disassembled, locking constituent assets.

**Affected Parties**: All users holding NFTs from protocols created after symbol length transitions occur. Multi-protocol NFT applications relying on accurate balance queries and transfers.

## Likelihood Explanation

**Attacker Capabilities:**
- Protocol creation is open to any user on mainchain (no authorization restrictions)
- Minters can specify custom tokenIds when minting NFTs
- No special permissions or governance approval required beyond being designated as a minter

**Attack Complexity**: Low
1. Monitor or wait for protocol count to reach transition threshold (9→10 digits)
2. Identify an existing protocol with N-digit number (e.g., "AR123456789")
3. Create protocols until obtaining N+1-digit number that overlaps (e.g., "AR1234567891")
4. Calculate the required tokenId to create collision using simple string arithmetic
5. Mint NFT with the calculated tokenId (e.g., tokenId 23 to collide with tokenId 123)

**Feasibility**: HIGH
- Occurs naturally as ecosystem scales and protocol count grows
- Initial protocols use 9-digit numbers (100,000,000 - 999,999,999)
- Transition to 10-digit numbers happens after sufficient protocol creation
- Collision opportunities exist at every length transition boundary (9→10, 10→11, etc.)
- Attack requires only being a minter, which protocol creators can freely grant

**Detection**: Difficult - Appears as legitimate protocol creation and NFT minting. Balance queries return values without error, but the values are incorrect, making the issue hard to detect until users notice discrepancies through manual verification.

## Recommendation

Add a delimiter between symbol and tokenId in the hash calculation to prevent collisions:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");
}
```

Alternatively, use structured hashing instead of string concatenation:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, add global tokenHash uniqueness validation in `PerformMint` to prevent any cross-protocol collisions:

```csharp
var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
var nftInfo = State.NftInfoMap[tokenHash];
if (nftInfo != null && nftInfo.Symbol != input.Symbol)
{
    throw new AssertionException($"Token hash collision detected with protocol {nftInfo.Symbol}");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task HashCollision_CrossProtocol_CorruptsState()
{
    // Setup: Create first protocol with 9-digit number
    var protocol1Symbol = "AR123456789"; // Simulated 9-digit protocol
    
    // Setup: Create second protocol with 10-digit number overlapping first
    var protocol2Symbol = "AR1234567891"; // 10-digit starting with protocol1
    
    // Mint NFT from protocol1 with tokenId 123
    var tokenId1 = 123;
    var hash1 = CalculateTokenHash(protocol1Symbol, tokenId1);
    // Concatenation: "AR123456789" + "123" = "AR123456789123"
    
    // Mint NFT from protocol2 with tokenId 23
    var tokenId2 = 23;
    var hash2 = CalculateTokenHash(protocol2Symbol, tokenId2);
    // Concatenation: "AR1234567891" + "23" = "AR123456789123"
    
    // Verify collision
    Assert.Equal(hash1, hash2);
    
    // This proves both NFTs map to same tokenHash, causing:
    // - Shared balance in BalanceMap[hash1]
    // - Metadata overwrite in NftInfoMap[hash1]
    // - Shared allowances in AllowanceMap[hash1]
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-463)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);

        var nftMinted = new NFTMinted
        {
            Symbol = input.Symbol,
            ProtocolName = protocolInfo.ProtocolName,
            TokenId = tokenId,
            Metadata = nftMetadata,
            Owner = owner,
            Minter = Context.Sender,
            Quantity = quantity,
            Alias = input.Alias,
            BaseUri = protocolInfo.BaseUri,
            Uri = input.Uri ?? string.Empty,
            Creator = protocolInfo.Creator,
            NftType = protocolInfo.NftType,
            TotalQuantity = nftInfo.Quantity,
            TokenHash = tokenHash
        };
        Context.Fire(nftMinted);

        return nftMinted;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-33)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```
