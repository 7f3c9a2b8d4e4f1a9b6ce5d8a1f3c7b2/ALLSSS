# Audit Report

## Title
Auto-Distribution Break Statement Prevents Multiple Token Threshold Checks in TokenHolder Contract

## Summary
The `RegisterForProfits` function contains a break statement that exits the threshold checking loop after processing only the first qualifying token, preventing subsequent tokens from being evaluated and distributed even when they simultaneously meet their configured thresholds. This breaks the multi-token auto-distribution functionality.

## Finding Description

The `RegisterForProfits` function implements auto-distribution logic to automatically trigger profit distribution when token balances exceed configured thresholds. The function iterates through all thresholds defined in `scheme.AutoDistributeThreshold` to check which tokens qualify for distribution. [1](#0-0) 

The critical flaw is the unconditional break statement at line 199. When the first token meets its threshold, the token symbol is added to `distributedInput.AmountsMap` with value 0, then the break immediately exits the foreach loop. All remaining thresholds are never evaluated, and subsequent qualifying tokens are excluded from the distribution.

The `AutoDistributeThreshold` field is explicitly designed as `map<string, int64>` to support multiple token symbols with different threshold values: [2](#0-1) [3](#0-2) 

The downstream `DistributeProfits` function in the Profit contract only processes tokens explicitly listed in the `AmountsMap` parameter. When a token symbol maps to value 0, the contract fetches and distributes the full balance of that token: [4](#0-3) 

Therefore, tokens not added to `AmountsMap` due to the premature loop exit will not be distributed, regardless of whether their balances exceed their configured thresholds.

## Impact Explanation

**Direct Impact**: When multiple token types accumulate in a profit scheme's virtual address and simultaneously meet their thresholds, only the first token encountered in the dictionary iteration will be auto-distributed. Other qualifying tokens remain locked in the virtual address.

**Affected Scenarios**:
- Multi-token profit schemes with configurations like `{"ELF": 1000, "USDT": 500, "BTC": 0.1}`
- When all three tokens exceed their thresholds simultaneously, only one gets distributed
- The remaining tokens' profits are trapped until the scheme manager manually calls `DistributeProfits` or another `RegisterForProfits` triggers when only those tokens qualify

**Severity Justification - Medium**:
1. Funds are not permanently lost but become temporarily inaccessible through auto-distribution
2. Manual intervention by the scheme manager can distribute the trapped profits
3. The issue affects core functionality of multi-token profit schemes
4. User experience is degraded as expected distributions don't occur

## Likelihood Explanation

**Reachable Entry Point**: `RegisterForProfits` is a public RPC method callable by any user: [5](#0-4) 

**Feasible Preconditions**:
1. A profit scheme created with multiple tokens in `AutoDistributeThreshold`
2. Multiple token types contributed to the scheme over time
3. Multiple tokens simultaneously exceed their configured thresholds
4. Any user calls `RegisterForProfits` to lock tokens and register

These conditions are realistic in production environments where schemes accept diverse payment tokens. The test suite demonstrates this intended functionality: [6](#0-5) 

**Execution Practicality**: The bug triggers automatically during normal operation. No attacker manipulation is required - the break statement executes whenever the first qualifying token is found.

**Probability**: High for multi-token schemes. As profit schemes accumulate various token types, it's expected that multiple thresholds would be reached simultaneously, especially after periods where no distribution occurs.

## Recommendation

Remove the `break` statement at line 199 to allow the loop to continue checking all tokens in `AutoDistributeThreshold`. This ensures that all qualifying tokens are added to `AmountsMap` and subsequently distributed.

**Fixed code (line 184-200)**:
```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Remove the break statement here
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MultiToken_AutoDistribution_Bug_Test()
{
    var amount = 1000L;
    var tokenELF = "ELF";
    var tokenJUN = "JUN";
    
    // Create token JUN and approve
    await StarterCreateIssueAndApproveTokenAsync(tokenJUN, 1000000L, 100000L);
    
    // Create scheme with two tokens in AutoDistributeThreshold
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = tokenELF,
        AutoDistributeThreshold =
        {
            { tokenELF, amount },
            { tokenJUN, amount }
        }
    });
    
    // Contribute both tokens to the scheme (both exceed threshold)
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = tokenELF
    });
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = tokenJUN
    });
    
    // Register for profits - this should auto-distribute BOTH tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = amount,
        SchemeManager = Starter
    });
    
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds.First();
    
    // Check distributed period 1 to verify both tokens were distributed
    var distributedInfo = await ProfitContractStub.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    // BUG: Only one token is distributed due to break statement
    // Expected: distributedInfo.AmountsMap.Count == 2
    // Actual: distributedInfo.AmountsMap.Count == 1
    distributedInfo.AmountsMap.Count.ShouldBe(1); // Demonstrates the bug
    distributedInfo.AmountsMap.ContainsKey(tokenJUN).ShouldBeFalse(); // JUN not distributed
}
```

## Notes

This vulnerability has been validated through comprehensive code analysis. The break statement at line 199 definitively prevents the loop from processing subsequent tokens after the first qualifying token is found. While the system is designed to support multi-token auto-distribution (as evidenced by the `map<string, int64>` type definition and test suite setup), the implementation fails to fulfill this design intent. The funds remain accessible through manual intervention, justifying the Medium severity classification rather than High.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** protobuf/token_holder_contract.proto (L40-42)
```text
    // The user registers a bonus project.
    rpc RegisterForProfits (RegisterForProfitsInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** protobuf/token_holder_contract.proto (L116-127)
```text
message TokenHolderProfitScheme {
    // The token symbol.
    string symbol = 1;
    // The scheme id.
    aelf.Hash scheme_id = 2;
    // The current dividend period.
    int64 period = 3;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 4;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 5;
}
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-445)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L365-373)
```csharp
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol,
            AutoDistributeThreshold =
            {
                { nativeTokenSymbol, amount },
                { tokenA, amount }
            }
        });
```
