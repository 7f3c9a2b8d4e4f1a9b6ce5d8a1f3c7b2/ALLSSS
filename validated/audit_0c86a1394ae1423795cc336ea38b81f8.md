# Audit Report

## Title
Time-of-Check-Time-of-Use (TOCTOU) Race Condition in Contract Address Reservation Allows Conflicting Proposals

## Summary
The `ProposeNewContract` function in the Genesis contract validates contract address availability at proposal creation time but does not reserve the address until deployment execution occurs after multi-stage governance approval. This TOCTOU gap allows multiple proposals with identical deployer/salt combinations (but different code) to pass validation, resulting in governance resource waste when only the first deployed contract succeeds while subsequent approved proposals fail.

## Finding Description

The vulnerability exists in the contract deployment proposal workflow within the BasicContractZero (Genesis) contract.

**Check Phase (Proposal Creation):**

When a new contract proposal is submitted via `ProposeNewContract`, the function validates that the deterministic contract address is available. [1](#0-0) 

This check calls `AssertContractAddressAvailable` which computes the contract address from the deployer and salt, then verifies it's not already occupied: [2](#0-1) 

However, this validation does NOT reserve the address. The proposal is merely registered in state by its input hash: [3](#0-2) 

The `RegisterContractProposingData` method stores proposals by `proposedContractInputHash`, which is computed from the entire input including the code. [4](#0-3) 

This means proposals with the same deployer/salt but different code will have different input hashes and are treated as separate, independent proposals that do not conflict with each other.

**Use Phase (Actual Deployment):**

After governance approval, the actual deployment occurs via `DeploySmartContract`, which calls the private helper method. The address is only reserved when `State.ContractInfos[contractAddress]` is set: [5](#0-4) 

Before this reservation, the deployment code checks if the address is already occupied: [6](#0-5) 

**Root Cause:**

The time gap between the availability check (proposal creation) and address reservation (deployment) can span days or weeks given the multi-stage governance process. During this window, multiple valid proposals with conflicting deployer/salt combinations can be created and approved, but only one can successfully deploy.

**Attack Constraint:**

The attacker must provide a valid signature for the `ContractOperation`. The signature validation requires the recovered address to match either the deployer itself or an authorized signer: [7](#0-6) 

## Impact Explanation

**Governance Resource Waste:**
When multiple proposals with conflicting deployer/salt pairs proceed through the governance pipeline (ContractDeploymentController approval → ProposeContractCodeCheck → CodeCheckController approval), all but one will fail at deployment despite full approval. This wastes:
- Validator voting resources and transaction fees for approving doomed proposals
- Block producer time for code checking contracts that will never deploy
- User gas fees for executing release transactions that will revert

**Deployment Failures:**
Legitimate users who successfully navigate the entire governance approval process will experience unexpected deployment failures with "Contract address exists" error, despite their proposal passing all validation checks and receiving governance approval. This creates unpredictable outcomes and poor user experience.

**Griefing Vector:**
An attacker with signing authority (either the deployer's private key or registered as a signer via `SetSigner`) can intentionally create conflicting proposals to block legitimate deployments or force races between competing proposals. [8](#0-7) 

In scenarios involving multisig deployers or delegated deployment rights, malicious parties with partial signing authority can exploit this vulnerability.

**Severity Assessment:**
Medium severity due to operational disruption of governance processes and potential for griefing attacks, though partially mitigated by the signature requirement.

## Likelihood Explanation

**Required Capabilities:**
- Access to the deployer address's private key OR registration as an authorized signer
- Ability to construct valid `ContractOperation` with proper signature  
- Knowledge of pending proposals (publicly observable on-chain)

**Realistic Attack Scenarios:**

1. **Malicious Signer Grief:** A party granted signer rights submits conflicting proposals to disrupt the original deployer's deployment plans
2. **Multisig Conflicts:** Multiple teams sharing the same multisig deployer accidentally or intentionally create overlapping proposals
3. **Accidental Collisions:** A single user testing different code versions accidentally submits proposals with identical deployer/salt pairs
4. **Front-running:** An attacker monitors pending proposals and submits a competing transaction with the same deterministic address parameters

**Feasibility:**
- Entry point `ProposeNewContract` is publicly accessible [9](#0-8) 
- The commented-out authorization check at line 124 provides no additional protection
- Signature validation is the sole barrier, which is realistic in delegated deployment scenarios

**Probability:**
Low-to-Medium likelihood. While the signature requirement prevents arbitrary attackers, legitimate scenarios exist where multiple parties possess signing authority (multisig wallets, delegated rights, contract factories). The extended time window (typically days/weeks as defined by the default 72-hour proposal expiration period) between proposal and deployment increases collision probability. [10](#0-9) 

## Recommendation

Reserve the contract address at proposal creation time rather than at deployment time. Modify the `ProposeNewContract` function to store a mapping from deterministic addresses to proposal hashes:

```csharp
// Add to state
public MappedState<Address, Hash> ReservedAddresses { get; set; }

// In ProposeNewContract after line 139:
if (input.ContractOperation != null)
{
    ValidateContractOperation(input.ContractOperation, 0, codeHash);
    RemoveOneTimeSigner(input.ContractOperation.Deployer);
    
    var contractAddress = AddressHelper.ComputeContractAddress(
        input.ContractOperation.Deployer, input.ContractOperation.Salt);
    
    // Check availability
    Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
    
    // Reserve the address
    Assert(State.ReservedAddresses[contractAddress] == null || 
           Context.CurrentBlockTime >= GetReservationExpiry(State.ReservedAddresses[contractAddress]),
           "Address already reserved by another pending proposal.");
    State.ReservedAddresses[contractAddress] = proposedContractInputHash;
}

// In DeploySmartContract, clear the reservation after successful deployment:
if (input.ContractOperation?.Salt != null)
{
    var contractAddress = AddressHelper.ComputeContractAddress(
        input.ContractOperation.Deployer, input.ContractOperation.Salt);
    State.ReservedAddresses.Remove(contractAddress);
}

// Add cleanup for expired proposals in TryClearContractProposingData
```

Additionally, implement expiration-based cleanup for stale reservations when proposals expire or are rejected.

## Proof of Concept

The following test demonstrates the vulnerability by creating two proposals with the same deployer/salt but different code. Both pass validation, but only the first to deploy succeeds:

```csharp
[Fact]
public async Task TOCTOU_MultipleProposalsWithSameDeployerSalt_AllPassValidation()
{
    // Setup: Create deployer keypair and register signer
    var deployerKeyPair = SampleECKeyPairs.KeyPairs[0];
    var deployer = Address.FromPublicKey(deployerKeyPair.PublicKey);
    
    // Create two different contract codes
    byte[] code1 = GenerateContractCode("ContractA");
    byte[] code2 = GenerateContractCode("ContractB"); // Different code
    var salt = HashHelper.ComputeFrom("shared-salt");
    
    // Both proposals use same deployer and salt
    var input1 = CreateDeploymentInput(code1, deployer, salt, deployerKeyPair);
    var input2 = CreateDeploymentInput(code2, deployer, salt, deployerKeyPair);
    
    // Proposal 1: Should succeed
    var hash1 = await GenesisContractStub.ProposeNewContract.SendAsync(input1);
    hash1.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Proposal 2: Should ALSO succeed (this is the bug)
    var hash2 = await GenesisContractStub.ProposeNewContract.SendAsync(input2);
    hash2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Both proposals accepted!
    
    // Approve both proposals through governance...
    await ApproveProposal(hash1.Output);
    await ApproveProposal(hash2.Output);
    
    // Deploy first proposal - succeeds
    var deploy1 = await GenesisContractStub.DeploySmartContract.SendAsync(input1);
    deploy1.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Deploy second proposal - FAILS with "Contract address exists"
    var deploy2 = await GenesisContractStub.DeploySmartContract.SendAsync(input2);
    deploy2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    deploy2.TransactionResult.Error.ShouldContain("Contract address exists");
    
    // Governance resources wasted on Proposal 2
}
```

**Notes:**
- The vulnerability is confirmed by the ability to create multiple proposals with identical deployer/salt combinations that all pass the `AssertContractAddressAvailable` check at proposal time
- The proposals are treated as distinct due to different input hashes (from different code)
- Only the deployment phase detects the conflict, after full governance approval has already been obtained
- This represents a classic TOCTOU race condition where the check (proposal) and use (deployment) are separated by a significant time gap with no reservation mechanism in between

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-122)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L128-128)
```csharp
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L139-139)
```csharp
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-545)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

        if (State.SignerMap[Context.Sender] == input) return new Empty();

        State.SignerMap[Context.Sender] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L40-40)
```csharp
        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L70-70)
```csharp
        State.ContractInfos[contractAddress] = info;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L410-412)
```csharp
        Assert(
            recoveredAddress == contractOperation.Deployer ||
            State.SignerMap[contractOperation.Deployer] == recoveredAddress, "Invalid signature.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L440-444)
```csharp
    private void AssertContractAddressAvailable(Address deployer, Hash salt)
    {
        var contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
