# Audit Report

## Title
Sponsor Can Remove Voted Options During Active Voting, Causing DOS and Vote Manipulation

## Summary
The `RemoveOption()` function allows voting sponsors to remove options at any time without validating whether voting is active or whether votes have been cast. This creates denial-of-service for new voters and enables vote manipulation through selective option removal during active voting periods.

## Finding Description

The `RemoveOption()` function only validates sponsor permission, option existence, and option length before removing an option, lacking any checks on voting status or existing votes: [1](#0-0) 

**Root Cause**: The function lacks critical checks:
1. No validation that voting period is inactive (no check against `StartTimestamp` or `EndTimestamp`)
2. No verification that the option has zero votes before removal
3. No protection against repeated add/remove operations

The `Vote()` function requires options to exist in the voting item's option list when validating input: [2](#0-1) 

When an option is removed, existing votes remain in the `VotingResult.Results[option]` mapping because `RemoveOption()` only modifies `VotingItem.Options` and never updates the voting results: [3](#0-2) 

The voting item structure stores `StartTimestamp` and `EndTimestamp` during registration: [4](#0-3) 

However, the `Vote()` validation function never checks these timestamps - it only validates snapshot numbers: [5](#0-4) 

**Execution Path**:
1. Sponsor registers voting with options A, B, C via `Register()`
2. Voting period starts (`CurrentBlockTime >= StartTimestamp`)
3. Voters cast 1000 votes for option A via `Vote()` → stored in `VotingResult.Results["A"]`
4. Sponsor calls `RemoveOption()` with option A → removed from `VotingItem.Options`
5. New voters attempting to vote for A encounter: "Option A not found" assertion failure at line 381
6. Existing 1000 votes for A remain in results but option is unavailable for new votes
7. Sponsor can re-add option A later via `AddOption()`, allowing votes to accumulate on existing total

**Real-World Usage**: The Election contract uses `RemoveOption()` when candidates quit during active elections: [6](#0-5) [7](#0-6) 

## Impact Explanation

**Direct Harm**:
- **Denial of Service**: New voters are blocked from voting on options that have existing votes, fragmenting the voting pool and preventing fair participation
- **Vote Manipulation**: Sponsor can selectively remove losing options temporarily, wait for voting patterns to change, then re-add them to influence outcomes
- **Result Inconsistency**: Voting results contain votes for options that no longer exist in the voting item, breaking result integrity and making tallying unreliable
- **Voter Confusion**: Voters see different option sets at different times, undermining trust in the governance process

**Affected Parties**:
- New voters attempting to vote on previously popular options
- Existing voters whose votes become "orphaned" when options are removed
- Election contract users relying on Vote contract for candidate selection
- Any governance processes dependent on voting results

**Severity Justification**: Medium-High
- Breaks voting integrity invariant (governance impact)
- Enables sponsor to manipulate outcomes through timing-based option management
- Creates operational DOS for legitimate voters during active voting periods
- While no funds are directly stolen, governance decisions can be manipulated, potentially affecting fund allocations and protocol parameters

## Likelihood Explanation

**Attacker Capabilities**:
- Attacker must be the sponsor of the voting item (legitimate role - anyone can create a voting item)
- Single transaction execution via public `RemoveOption()` method
- No special permissions beyond sponsor role required

**Attack Complexity**: Low
- Direct function call with voting item ID and option name
- No complex state setup or precise timing requirements
- Can be repeated arbitrarily during voting period without rate limiting

**Feasibility Conditions**:
- Voting item must exist (trivial - sponsor creates it via `Register()`)
- Option must currently exist in list (trivial - sponsor knows current options)
- No cooldown periods or transaction limits prevent repeated calls

**Detection Constraints**:
- No events emitted when options are removed (no audit trail)
- No on-chain indication of option modifications
- Off-chain monitoring would need to continuously poll option lists to detect changes

**Probability**: High - Simple to execute with legitimate sponsor role, no technical barriers, and already occurring in Election contract usage.

## Recommendation

Add validation to `RemoveOption()` to prevent modification during active voting and when votes exist:

```csharp
public override Empty RemoveOption(RemoveOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // NEW: Prevent removal during active voting period
    Assert(Context.CurrentBlockTime < votingItem.StartTimestamp || 
           Context.CurrentBlockTime > votingItem.EndTimestamp,
           "Cannot modify options during active voting period.");
    
    // NEW: Check if option has existing votes
    var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
    var votingResult = State.VotingResults[votingResultHash];
    if (votingResult.Results.ContainsKey(input.Option))
    {
        Assert(votingResult.Results[input.Option] == 0, 
               "Cannot remove option with existing votes.");
    }
    
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
    votingItem.Options.Remove(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    
    // NEW: Emit event for transparency
    Context.Fire(new OptionRemoved
    {
        VotingItemId = votingItem.VotingItemId,
        Option = input.Option
    });
    
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveOption_During_Active_Voting_Causes_DOS()
{
    // Register voting item with 3 options, 100 day duration
    var votingItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
    var voter1 = Accounts[2].KeyPair;
    
    // Voter1 casts 1000 votes for option A (first option)
    await Vote(voter1, votingItem.VotingItemId, votingItem.Options[0], 1000L);
    
    // Verify the vote was recorded
    var votingResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    votingResult.Results[votingItem.Options[0]].ShouldBe(1000L);
    
    // Sponsor removes option A during active voting (no validation prevents this)
    var removeResult = await VoteContractStub.RemoveOption.SendAsync(new RemoveOptionInput
    {
        VotingItemId = votingItem.VotingItemId,
        Option = votingItem.Options[0]
    });
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify option was removed from voting item
    var updatedVotingItem = await GetVoteItem(votingItem.VotingItemId);
    updatedVotingItem.Options.Contains(votingItem.Options[0]).ShouldBeFalse();
    
    // BUT: Existing votes remain in the results (orphaned votes)
    var resultAfterRemoval = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    resultAfterRemoval.Results[votingItem.Options[0]].ShouldBe(1000L);
    
    // NEW VOTER DENIAL OF SERVICE: Voter2 tries to vote for option A but fails
    var voter2 = Accounts[3].KeyPair;
    var dosResult = await VoteWithException(voter2, votingItem.VotingItemId, votingItem.Options[0], 500L);
    dosResult.Status.ShouldBe(TransactionResultStatus.Failed);
    dosResult.Error.ShouldContain("Option"); // "Option not found" assertion
    
    // This demonstrates:
    // 1. Sponsor can remove options during active voting (no timestamp check)
    // 2. Options with existing votes can be removed (no vote count check)
    // 3. New voters are DOS'd from voting on removed options
    // 4. Existing votes become orphaned (remain in results for removed options)
}
```

## Notes

This vulnerability demonstrates a fundamental flaw in the Vote contract's governance model where sponsors have unconstrained control over voting options during active periods. The Election contract's use of `RemoveOption()` for candidate withdrawals shows this is an active attack vector in production. The lack of any events or audit trail makes detection extremely difficult, allowing sponsors to silently manipulate voting outcomes by strategically timing option removals.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L45-47)
```csharp
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L257-261)
```csharp
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L308-312)
```csharp
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
```
