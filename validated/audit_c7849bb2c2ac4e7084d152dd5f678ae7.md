# Audit Report

## Title
Last Irreversible Block (LIB) Height Stuck at Zero During Round 2 Due to Missing ImpliedIrreversibleBlockHeight Updates in Non-UpdateValue Behaviors

## Summary
The AEDPoS consensus mechanism fails to update the `ImpliedIrreversibleBlockHeight` field during TinyBlock, NextRound, and NextTerm behaviors. When Round 1 completes without any UpdateValue blocks (possible if the first miner is offline and other miners trigger NextRound), all miners enter Round 2 with `ImpliedIrreversibleBlockHeight = 0`. This causes the LIB calculation to fail and keeps LIB stuck at 0 throughout Round 2, blocking cross-chain operations and finality-dependent services.

## Finding Description

The vulnerability stems from incomplete handling of the `ImpliedIrreversibleBlockHeight` field across different consensus behaviors.

**Root Cause Analysis:**

Only the UpdateValue behavior sets `ImpliedIrreversibleBlockHeight` to the current block height: [1](#0-0) 

The other three consensus behaviors do NOT update this field:
- **TinyBlock**: [2](#0-1) 
- **NextRound**: [3](#0-2) 
- **NextTerm**: [4](#0-3) 

**Vulnerable Execution Path:**

1. During Round 1, all miners initialize with `ImpliedIrreversibleBlockHeight = 0` (protobuf int64 default): [5](#0-4) 

2. The consensus behavior logic explicitly allows non-first miners to trigger NextRound if the first miner hasn't produced blocks: [6](#0-5) 

3. When NextRound is triggered, new MinerInRound objects are created copying only `ProducedBlocks` and `MissedTimeSlots` - NOT `ImpliedIrreversibleBlockHeight`: [7](#0-6) 

4. In Round 2, when miners produce UpdateValue blocks, the LIB calculator filters Round 1 miners by `ImpliedIrreversibleBlockHeight > 0`: [8](#0-7) 

5. Since all Round 1 miners have value 0, the filtered list is empty. The calculator returns `libHeight = 0`: [9](#0-8) 

6. The LIB update only proceeds if the new value is strictly greater than the current value: [10](#0-9) 

With both values at 0, the condition `0 < 0` is false, so LIB remains stuck at 0.

## Impact Explanation

**High Severity - Denial of Service on Consensus Finality:**

- **LIB Stuck at Zero**: Throughout the entire Round 2 (potentially hundreds of blocks depending on miner count and mining interval), no blocks can be confirmed as irreversible.

- **Cross-Chain Operations Blocked**: Cross-chain indexing validation requires LIB height > genesis height: [11](#0-10) 

With LIB stuck at 0, cross-chain transfers and state synchronization cannot proceed safely.

- **Finality-Dependent Applications Fail**: Any application or service waiting for transaction finality (irreversibility confirmation) will be blocked for an entire round.

- **Recovery Only in Round 3**: LIB can only recover when Round 3 begins and the calculator can reference Round 2's miners who have non-zero `ImpliedIrreversibleBlockHeight` values.

This breaks the fundamental invariant that LIB should monotonically increase as blocks are produced and reach 2/3+ consensus.

## Likelihood Explanation

**Medium to High Likelihood:**

The vulnerability triggers automatically if Round 1 completes without any UpdateValue blocks. This scenario occurs when:

1. **First Miner Failure**: The miner with Order == 1 in Round 1 fails to produce blocks (offline, network issues, delayed node start)

2. **Automatic NextRound Trigger**: The consensus mechanism explicitly designed this as a safety feature - when the first miner hasn't produced blocks, other miners must trigger NextRound to prevent fork blocks

3. **Genesis/Initialization Vulnerability Window**: This is most likely during initial chain deployment when:
   - Network connectivity may be unstable
   - Miner nodes are still synchronizing  
   - Configuration errors could delay the first miner
   - Genesis timing issues are most common

**No sophisticated attack required** - this can occur naturally due to network conditions, or be induced by a malicious first miner simply going offline during Round 1.

## Recommendation

Update the `ImpliedIrreversibleBlockHeight` field in all consensus behaviors, not just UpdateValue:

**For TinyBlock behavior** in `GetConsensusExtraDataForTinyBlock`:
```csharp
currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
    .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
    currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
    .Add(Context.CurrentBlockTime);
// ADD THIS LINE:
currentRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**For NextRound behavior** in `GetConsensusExtraDataForNextRound`:
```csharp
nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
    nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
    .Add(Context.CurrentBlockTime);
// ADD THIS LINE:
nextRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**For NextTerm behavior** in `GetConsensusExtraDataForNextTerm`:
```csharp
if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
{
    firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
    // ADD THIS LINE:
    firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
}
```

Alternatively, modify `GenerateNextRoundInformation` in `Round_Generation.cs` to preserve `ImpliedIrreversibleBlockHeight` when creating next round miners, similar to how `ProducedBlocks` and `MissedTimeSlots` are preserved.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize genesis with multiple miners
2. Have the first miner (Order = 1) go offline/not produce blocks
3. Have a second miner (Order = 2) trigger NextRound behavior during Round 1
4. Verify Round 2 begins with all Round 1 miners having `ImpliedIrreversibleBlockHeight = 0`
5. Have any miner in Round 2 produce an UpdateValue block
6. Call the LIB calculator and verify it returns 0 due to empty filtered list
7. Verify `ConfirmedIrreversibleBlockHeight` remains at 0 throughout Round 2
8. Verify cross-chain operations fail validation due to LIB at genesis height

The vulnerability is confirmed by the code analysis showing the exact execution path where `ImpliedIrreversibleBlockHeight` is never set during NextRound behavior, combined with the LIB calculator's requirement for non-zero values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L155-171)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForTinyBlock(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = currentRound.GetTinyBlockRound(pubkey),
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** protobuf/aedpos_contract.proto (L300-300)
```text
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L94-102)
```csharp
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-29)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-272)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
```

**File:** src/AElf.CrossChain.Core/Indexing/Infrastructure/IrreversibleBlockStateProvider.cs (L30-37)
```csharp
    public async Task<bool> ValidateIrreversibleBlockExistingAsync()
    {
        if (_irreversibleBlockExists)
            return true;
        var libIdHeight = await GetLastIrreversibleBlockHashAndHeightAsync();
        var lastIrreversibleBlockHeight = libIdHeight.BlockHeight;
        _irreversibleBlockExists = lastIrreversibleBlockHeight > AElfConstants.GenesisBlockHeight;
        return _irreversibleBlockExists;
```
