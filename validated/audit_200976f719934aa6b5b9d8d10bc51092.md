# Audit Report

## Title
TokenHolder Scheme Configuration Overwrite Allows Violation of Lock Agreements

## Summary
The `CreateScheme` function in TokenHolderContract lacks protection against being called multiple times by the same scheme manager. This allows a malicious scheme manager to arbitrarily change the `Symbol` or `MinimumLockMinutes` parameters after users have already locked their tokens, breaking the lock agreement and causing permanent fund loss or enabling unintended early withdrawals.

## Finding Description

The TokenHolderContract's `CreateScheme` function contains no validation to prevent a scheme manager from calling it multiple times. [1](#0-0) 

Each invocation unconditionally overwrites the `State.TokenHolderProfitSchemes[Context.Sender]` mapping with new values for `Symbol`, `MinimumLockMinutes`, and `AutoDistributeThreshold`. [2](#0-1) 

While each call to `CreateScheme` creates a new profit scheme in the underlying Profit contract [3](#0-2) , the Profit contract allows the same manager to create multiple schemes by appending each new scheme ID to a list. [4](#0-3) 

The `GetValidScheme` function retrieves the scheme ID via `FirstOrDefault()` [5](#0-4) , which always returns the first scheme created, but uses the **overwritten** `Symbol` and `MinimumLockMinutes` values from TokenHolder's state that were set by subsequent `CreateScheme` calls.

When users register for profits, they lock tokens using the current `scheme.Symbol` value [6](#0-5) , and the lock timestamp is recorded. [7](#0-6) 

However, when users attempt to withdraw, the `Withdraw` function queries locked amounts using the **current** `scheme.Symbol` from the overwritten state [8](#0-7) , and checks the time lock using the **current** `scheme.MinimumLockMinutes`. [9](#0-8) 

The `GetLockedAmount` implementation queries the balance of the virtual address for the specified symbol. [10](#0-9)  If tokens were locked as "ELF" but the query uses "USDT", it returns 0 because the virtual address contains ELF tokens, not USDT.

The test suite demonstrates protection against repeated `RegisterForProfits` calls [11](#0-10) , but no equivalent test exists for repeated `CreateScheme` calls, confirming the missing protection.

## Impact Explanation

**Attack Scenario 1 - Symbol Change (Permanent Fund Loss):**
1. Users lock ELF tokens under a scheme with `Symbol="ELF"`
2. Scheme manager calls `CreateScheme` again with `Symbol="USDT"`, overwriting the state
3. When users attempt withdrawal, `GetLockedAmount` queries for USDT locks instead of ELF
4. The query returns 0 (tokens were locked as ELF, not USDT)
5. Users cannot unlock their ELF tokens - **permanent fund loss**

**Attack Scenario 2 - MinimumLockMinutes Reduction (Early Withdrawal):**
1. Scheme manager creates scheme with `MinimumLockMinutes=10000` (≈7 days)
2. Users lock tokens expecting a 10000-minute minimum lock period
3. Scheme manager calls `CreateScheme` with `MinimumLockMinutes=1`
4. Users (or the scheme manager as a beneficiary) can withdraw after 1 minute instead of 10000 minutes
5. Violates profit distribution timeframe expectations

**Attack Scenario 3 - MinimumLockMinutes Increase (Extended Lock):**
1. Users lock tokens with `MinimumLockMinutes=100`
2. Scheme manager calls `CreateScheme` with `MinimumLockMinutes=1000000`
3. Users cannot withdraw for 1000000 minutes (≈694 days) instead of expected 100 minutes
4. Funds locked far beyond user consent

**Severity Justification: HIGH**
- Direct fund impact: Complete loss of access to locked funds or unintended early access
- Breaks critical invariant: lock/unlock correctness
- Violates user expectations and lock agreements
- No recovery mechanism exists for affected users

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be the scheme manager (original creator of the scheme)
- No additional authorization or governance approval required
- Can be executed by any address that previously called `CreateScheme`

**Attack Complexity:**
- Extremely simple: Single transaction calling `CreateScheme` with modified parameters
- No complex state manipulation required
- No timing constraints or dependencies

**Feasibility Conditions:**
- Scheme manager role is not a privileged trusted role - any address can create schemes
- Economic cost is minimal (just transaction fees)

**Economic Rationality:**
- Malicious scheme manager could benefit by reducing `MinimumLockMinutes` to withdraw their own profits early
- Could change `Symbol` to DoS competitors' locked funds
- Could create griefing attacks at minimal cost

**Probability Assessment: HIGH**
- Public function with no access controls beyond being the original creator
- Simple to execute, whether maliciously or accidentally
- No disincentive mechanism to prevent this behavior

## Recommendation

Add a validation check in the `CreateScheme` function to prevent scheme managers from calling it multiple times:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check to prevent overwriting existing schemes
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if updating scheme parameters should be allowed, implement a separate `UpdateScheme` function with proper validation to ensure existing locked tokens are handled correctly.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_Twice_Causes_Withdrawal_Failure()
{
    // Step 1: Manager creates initial scheme with ELF symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Step 2: User locks ELF tokens
    var lockAmount = 1000L;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });
    
    // Verify tokens are locked
    var balanceAfterLock = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = Starter
    })).Balance;
    
    // Step 3: Manager calls CreateScheme again with USDT symbol (ATTACK)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",  // Different symbol!
        MinimumLockMinutes = 100
    });
    
    // Step 4: User attempts to withdraw - this will fail
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    
    // Verify withdrawal failed or returned 0 amount
    // The GetLockedAmount will query for "USDT" but tokens were locked as "ELF"
    // This returns 0, causing the withdrawal to fail or unlock 0 tokens
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    
    // User's ELF tokens remain locked permanently
    var balanceAfterWithdraw = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = Starter
    })).Balance;
    
    balanceAfterWithdraw.ShouldBe(balanceAfterLock); // Balance unchanged - funds stuck!
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L167-167)
```csharp
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L306-325)
```csharp
    public async Task RegisterForProfits_Repeatedly_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            AutoDistributeThreshold = { { "ELF", 1000 } }
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = 10,
            SchemeManager = Starter
        });
        var repeatRegisterRet = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
            new RegisterForProfitsInput
            {
                Amount = 10,
                SchemeManager = Starter
            });
        repeatRegisterRet.TransactionResult.Error.ShouldContain("Already registered.");
    }
```
