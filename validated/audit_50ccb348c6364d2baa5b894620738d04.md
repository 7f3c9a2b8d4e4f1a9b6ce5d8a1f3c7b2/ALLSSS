# Audit Report

## Title
Missing Signature Validation Allows Consensus Schedule Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miner-provided signatures are correctly calculated, allowing malicious miners to manipulate their mining order in the next round and control extra block producer selection. This completely undermines the consensus protocol's randomness guarantees.

## Finding Description

The vulnerability exists in how the `UpdateValue` transaction processes miner signatures. The signature field is designed to provide cryptographic randomness for determining the next round's mining schedule by XORing the miner's previous in-value with all signatures from the previous round. [1](#0-0) 

During legitimate block production, the signature is correctly calculated using `previousRound.CalculateSignature(previousInValue)`. [2](#0-1) 

However, the validation provider only checks that the signature field is non-null and non-empty, without verifying correctness. [3](#0-2) 

When processing the `UpdateValue` transaction, the signature from user input is directly assigned to the round state without any cryptographic validation. [4](#0-3) 

This signature directly determines the miner's position in the next round through the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [5](#0-4) 

Additionally, if the attacker is the first miner in the current round, their signature determines which miner becomes the extra block producer in the next round. [6](#0-5) 

## Impact Explanation

**HIGH SEVERITY** - This vulnerability directly compromises the core consensus mechanism:

1. **Consensus Schedule Manipulation**: Miners can choose any mining order (1 to N) in the next round by selecting signature values that produce their desired modulus result. This allows strategic positioning for maximum profit or to coordinate attacks.

2. **Extra Block Producer Control**: The first miner in each round can deterministically select who becomes the extra block producer in the next round, enabling reward manipulation and potential collusion schemes.

3. **Randomness Violation**: The signature mechanism is the primary source of randomness for fair mining schedule distribution. Allowing arbitrary signatures completely eliminates this randomness, making the consensus protocol predictable and manipulable.

4. **Collusion Potential**: Multiple malicious miners can coordinate their signature values to dominate consecutive rounds, concentrating rewards and potentially enabling other attacks like censorship or double-spending attempts.

## Likelihood Explanation

**CERTAIN** - This vulnerability is trivially exploitable:

- **Entry Point**: The `UpdateValue` method is the standard transaction every miner sends during normal block production, making it constantly accessible.

- **Preconditions**: The attacker only needs to be a valid miner in the current validator set, which is the normal operational state for any miner.

- **Execution**: The exploit requires no special timing, state manipulation, or complex transactions. The attacker simply provides an arbitrary Hash value instead of calling `CalculateSignature()` when constructing their `UpdateValueInput`.

- **Cost**: Zero - changing a hash value in the transaction input costs nothing beyond normal transaction fees.

- **Detection**: Impossible - there is no validation logic that compares the provided signature against the expected value, so the attack is indistinguishable from legitimate behavior.

- **Success Rate**: 100% - every malicious signature is accepted and stored.

## Recommendation

Add cryptographic validation of the signature field in `UpdateValueValidationProvider`:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Existing checks
    if (minerInRound.OutValue == null || minerInRound.Signature == null ||
        !minerInRound.OutValue.Value.Any() || !minerInRound.Signature.Value.Any())
        return false;
    
    // NEW: Validate signature calculation
    if (validationContext.PreviousRound != null && 
        !validationContext.PreviousRound.IsEmpty &&
        minerInRound.PreviousInValue != null && 
        minerInRound.PreviousInValue != Hash.Empty)
    {
        var expectedSignature = validationContext.PreviousRound.CalculateSignature(minerInRound.PreviousInValue);
        if (minerInRound.Signature != expectedSignature)
            return false;
    }
    
    return true;
}
```

This validation ensures that the signature matches the deterministic calculation based on the previous round's data, preventing miners from providing arbitrary values.

## Proof of Concept

A proof of concept would involve:

1. Setting up a test miner in the AEDPoS consensus test environment
2. Calling `UpdateValue` with a crafted signature value (e.g., Hash.Empty or any arbitrary value)
3. Observing that the transaction is accepted
4. Verifying that the `SupposedOrderOfNextRound` is calculated based on the arbitrary signature
5. Demonstrating that different signature values produce different mining orders

The test would confirm that no validation prevents arbitrary signature values from being stored and used for next round order calculation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L88-92)
```csharp
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
