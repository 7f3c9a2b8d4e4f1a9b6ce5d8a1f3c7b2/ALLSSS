# Audit Report

## Title
Missing Validation of TuneOrderInformation Allows Miners to Corrupt Next Round Mining Schedule

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract directly applies `TuneOrderInformation` values from miner-submitted `UpdateValueInput` to `FinalOrderOfNextRound` without validating that order values are within the valid range [1, minersCount] or checking for duplicates. This allows a malicious miner to inject arbitrary order values that corrupt the mining schedule, causing non-deterministic round generation across nodes and consensus failure.

## Finding Description

The vulnerability exists in the consensus update flow where mining order information for the next round is processed without validation.

When a miner produces a block, they submit an `UpdateValue` transaction containing an `UpdateValueInput` message. This message includes a `tune_order_information` map that allows setting order values for multiple miners. [1](#0-0) 

In `ProcessUpdateValue`, these values are directly applied to the current round state without any validation: [2](#0-1) 

The validation system for `UpdateValue` behavior only checks cryptographic values (OutValue, Signature, PreviousInValue), not the order information. [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` is only applied to `NextRound` behavior, not to `UpdateValue`. [4](#0-3) 

Furthermore, `NextRoundMiningOrderValidationProvider` has a critical bug - it calls `.Distinct()` on `MinerInRound` objects instead of on the order values themselves, so it cannot detect duplicate order values even when it does run. [5](#0-4) 

When generating the next round, the corrupted `FinalOrderOfNextRound` values are used directly to determine mining order and timing. [6](#0-5) 

The `OrderBy` operation becomes non-deterministic when duplicate order values exist, because the source sequence (dictionary values) has non-deterministic iteration order across different nodes, and `OrderBy` preserves the relative order of equal elements from the source.

## Impact Explanation

This vulnerability breaks consensus integrity with severe network-wide consequences:

**1. Non-Deterministic Round Generation**: When a malicious miner sets duplicate order values (e.g., two miners with `FinalOrderOfNextRound` = 3), different nodes will generate different `nextRound` objects because `OrderBy` preserves the relative order from the source dictionary, which has non-deterministic iteration order. This causes block hash mismatches and consensus failure.

**2. Mining Schedule Corruption**: Out-of-range order values (e.g., Order=999 when there are 7 miners) push affected miners' `ExpectedMiningTime` far into the future, effectively excluding them from consensus and disrupting the intended round-robin mining schedule.

**3. Protocol-Level DoS**: Once the round state is corrupted, all nodes fail to reach consensus on the next round, halting block production. The attack affects the entire network, not just individual participants.

**4. No Recovery Mechanism**: There is no validation or recovery mechanism to detect and correct corrupted order values once they enter the round state.

The attack breaks the fundamental consensus guarantee that all honest nodes agree on the mining schedule and block production order.

## Likelihood Explanation

The vulnerability is highly exploitable:

**Attacker Requirements**: The attacker must be an elected miner in the current miner list, which is verified by `PreCheck()`. [7](#0-6) 

**Attack Complexity**: Low. The attacker only needs to:
1. Modify their consensus client to craft a custom `UpdateValueInput` with malicious `TuneOrderInformation` values
2. Submit the transaction during their legitimate mining time slot

**Method Accessibility**: The `UpdateValue` method is publicly accessible. [8](#0-7) 

**No Prevention**: The validation providers check miner permissions, time slots, and continuous block limits, but none validate the order values. [9](#0-8) 

**Probability**: High. Any malicious miner can execute this attack during their time slot in every round they participate in, with only transaction fee costs.

## Recommendation

Add validation for `TuneOrderInformation` in `ProcessUpdateValue`:

```csharp
// After line 258, before applying TuneOrderInformation:
var minersCount = currentRound.RealTimeMinersInformation.Count;
var usedOrders = new HashSet<int>();

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate range
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
        $"Invalid order value {tuneOrder.Value}. Must be in range [1, {minersCount}]");
    
    // Validate no duplicates
    Assert(usedOrders.Add(tuneOrder.Value), 
        $"Duplicate order value {tuneOrder.Value} detected");
    
    // Validate miner exists
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        $"Miner {tuneOrder.Key} not found in current round");
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

Additionally, fix the `NextRoundMiningOrderValidationProvider` bug by selecting the order values before calling `Distinct()`:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct()
    .Count();
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CorruptsRoundWithDuplicateOrders_CausesConsensusFailure()
{
    // Setup: Initialize consensus with 3 miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(miners);
    
    // Malicious miner1 submits UpdateValue with duplicate order values
    var maliciousInput = new UpdateValueInput
    {
        OutValue = Hash.FromString("out"),
        Signature = Hash.FromString("sig"),
        PreviousInValue = Hash.Empty,
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            { "miner2", 3 },  // Duplicate order 3
            { "miner3", 3 }   // Duplicate order 3 - SHOULD BE REJECTED
        },
        RandomNumber = ByteString.CopyFromUtf8("random")
    };
    
    // Act: Miner1 calls UpdateValue - this should fail but doesn't
    await consensusStub.UpdateValue(maliciousInput);
    
    // Assert: Verify round state is corrupted with duplicate orders
    var currentRound = await consensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var miner2Order = currentRound.RealTimeMinersInformation["miner2"].FinalOrderOfNextRound;
    var miner3Order = currentRound.RealTimeMinersInformation["miner3"].FinalOrderOfNextRound;
    
    // Both have order 3 - consensus will fail when generating next round
    Assert.Equal(3, miner2Order);
    Assert.Equal(3, miner3Order);
    
    // When nodes try to generate next round, OrderBy produces non-deterministic results
    // Different nodes will order miner2 and miner3 differently, causing consensus failure
}
```

## Notes

The vulnerability is confirmed through complete code path validation. The attack is executable by any elected miner with low complexity. The impact is critical as it breaks the fundamental consensus mechanism, causing network-wide denial of service with no recovery path. The fix requires adding proper validation of `TuneOrderInformation` values before applying them to round state.

### Citations

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-82)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
