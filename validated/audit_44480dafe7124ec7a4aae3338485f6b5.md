# Audit Report

## Title
Decimal Overflow in Bancor Exponential Calculation Causes DoS of Token Conversion Operations

## Summary
The `Exp()` function in `BancorHelper.cs` computes exponentials using Taylor series expansion up to the 20th power without validating the magnitude of input arguments. When connector weights have extreme ratios (>40), the exponential calculation overflows `decimal.MaxValue`, throwing `OverflowException` that reverts all Buy and Sell transactions for the affected token pair, causing complete denial of service.

## Finding Description

The vulnerability exists in the Bancor pricing formula's exponential calculation. The `Exp()` function uses a Taylor series that computes powers up to `y^20`: [1](#0-0) 

At each iteration, it calls `Pow(y, (uint)iteration)` without bounds checking on the input magnitude `y`.

**Root Cause - Unbounded Weight Ratios:**

In `GetAmountToPayFromReturn()` (Buy operation), the exponential argument is `y * Ln(x)` where `y = toConnectorWeight / fromConnectorWeight`: [2](#0-1) 

In `GetReturnFromPaid()` (Sell operation), the argument is `y * Ln(x)` where `y = fromConnectorWeight / toConnectorWeight`: [3](#0-2) 

**Insufficient Validation:**

Connector weights are only validated individually to be between 0 and 1: [4](#0-3) [5](#0-4) 

However, the **ratio** of two valid weights is unbounded. Examples:
- Weights 0.976 and 0.024 → ratio 40.67
- Weights 0.99 and 0.01 → ratio 99.0

The `Ln()` function accepts values where `0 < a < 2`: [6](#0-5) 

Maximum `Ln(x)` approaches 0.693 when x approaches 2. With a weight ratio of 99, the exponential argument becomes 99 × 0.693 ≈ 68.6. Computing `Pow(68.6, 20)` yields approximately 10^36, far exceeding `decimal.MaxValue` (≈ 7.9 × 10^28).

**No Exception Handling:**

The contract has `CheckForOverflowUnderflow` enabled: [7](#0-6) 

This causes arithmetic overflow to throw `System.OverflowException`, as confirmed by security tests: [8](#0-7) 

The `Buy()` and `Sell()` methods have no try-catch blocks around Bancor calculations: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Severity: HIGH**

**Concrete Harm:**
1. **Complete DoS**: All Buy and Sell operations fail with `OverflowException` for any token pair with weight ratio >40
2. **Fund Lockup**: Users holding the affected token cannot trade out of their positions, effectively locking funds
3. **Protocol Revenue Loss**: No trading fees can be collected; treasury receives no donations from the affected pair
4. **Systemic Impact**: TokenConverter becomes non-functional for the entire trading pair

**Affected Parties:**
- All users holding or attempting to trade the affected token pair
- Protocol treasury and fee recipients who lose expected revenue
- Overall protocol utility and reputation

The vulnerability violates the core security guarantee that users can always trade tokens through the TokenConverter. Once triggered, there is no user-level recovery mechanism—only governance intervention to modify connector weights can restore functionality.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Preconditions:**
- A token pair must be configured with extreme weight ratio (>40)
- Current validation explicitly allows any weight between 0 and 1, making ratios >40 achievable
- Weights are set through governance-controlled methods requiring Parliament approval

**Trigger Scenarios:**
1. **Accidental Misconfiguration**: Governance accidentally sets extreme weights due to typo (e.g., 0.98 instead of 0.098) or misunderstanding of the economic implications
2. **Intentional Design Choice**: Protocol designers choose extreme weights for specific economic properties without realizing the computational overflow risk
3. **Malicious Proposal**: Attacker with governance influence proposes extreme weight ratios

**Attack Complexity: LOW**
- Once extreme weights are configured, ANY user calling `Buy()` or `Sell()` triggers the DoS
- No special privileges required beyond normal user access to public methods
- Transaction parameters are straightforward (symbol, amount)

**Probability:** HIGH if extreme weight ratios are ever configured. The validation logic places no restrictions on weight ratios, only on individual weights, making such configurations technically valid but operationally catastrophic.

## Recommendation

Add validation to restrict the maximum weight ratio during connector configuration:

```csharp
private void AssertValidConnectorWeight(Connector connector)
{
    var weight = AssertedDecimal(connector.Weight);
    Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
    connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
}

// Add new method to validate weight ratios when configuring pairs
private void AssertValidWeightRatio(decimal weight1, decimal weight2)
{
    var ratio = Math.Max(weight1 / weight2, weight2 / weight1);
    Assert(ratio <= 10m, "Weight ratio cannot exceed 10 to prevent overflow in Bancor calculations.");
}
```

Apply this validation in `Initialize()`, `UpdateConnector()`, and `AddPairConnector()` methods when setting up connector pairs. Alternatively, add bounds checking in the `Exp()` function itself to gracefully handle or reject large arguments before overflow occurs.

## Proof of Concept

```csharp
[Fact]
public async Task ExtremeWeightRatio_Causes_Overflow_DoS()
{
    // Configure token pair with extreme weight ratio
    var extremeWeightConnector = new Connector
    {
        Symbol = "EXTREME",
        VirtualBalance = 100_0000,
        Weight = "0.99", // High weight
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "NTEXTREME"
    };
    
    var extremeNtConnector = new Connector
    {
        Symbol = "NTEXTREME",
        VirtualBalance = 100_0000,
        Weight = "0.01", // Low weight - ratio is 99
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "EXTREME",
        IsDepositAccount = true
    };
    
    // Initialize with extreme ratio connectors
    await InitializeWithConnectors(extremeWeightConnector, extremeNtConnector);
    
    // Attempt Buy operation - should fail with OverflowException
    var buyResult = await TokenConverterStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = "EXTREME",
        Amount = 1000,
        PayLimit = 100_0000
    });
    
    // Verify transaction failed due to overflow
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    buyResult.TransactionResult.Error.ShouldContain("System.OverflowException");
    
    // Verify state unchanged - DoS confirmed
    var connector = await TokenConverterStub.GetConnector.CallAsync(new TokenSymbol { Symbol = "EXTREME" });
    connector.ShouldNotBeNull();
}
```

## Notes

This vulnerability demonstrates a critical gap between input validation and computational safety. While the governance is trusted, the validation logic should prevent configurations that break system invariants even if accidentally approved. The overflow occurs due to the mathematical properties of the Bancor formula combined with C#'s checked arithmetic, creating a DoS vector that affects protocol availability rather than funds directly—but the impact on users who cannot exit positions is equally severe.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L51-53)
```csharp
        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** test/AElf.Contracts.TestContract.Tests/ContractSecurityTests.cs (L30-36)
```csharp
        var transactionResult = (await TestBasicSecurityContractStub.TestInt32State.SendWithExceptionAsync(
            new Int32Input
            {
                Int32Value = 100
            })).TransactionResult;
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        transactionResult.Error.Contains("System.OverflowException").ShouldBeTrue();
```
