# Audit Report

## Title
Unbounded Proposal Expiration Time Enables Permanent Storage Lock in Governance Contracts

## Summary
The Association, Parliament, and Referendum contracts accept user-provided `ExpiredTime` values without enforcing maximum bounds, allowing whitelisted proposers to create proposals with expiration dates up to year 9999. Since the `ClearProposal` cleanup mechanism requires the current time to exceed the expiration time, these proposals cannot be removed from storage for thousands of years, enabling permanent storage bloat attacks.

## Finding Description

The vulnerability exists in the proposal validation logic across all three governance contracts. When a proposal is created, the `ExpiredTime` field is validated only to ensure it's non-null and in the future, with no upper bound check.

In the Association contract, the validation only checks that `Context.CurrentBlockTime < proposal.ExpiredTime`, allowing any future timestamp [1](#0-0) . The `ExpiredTime` is taken directly from user input without sanitization [2](#0-1) .

The maximum valid Timestamp value in the AElf system is 253402300799 seconds (corresponding to December 31, 9999) [3](#0-2) .

The cleanup mechanism in the Association contract explicitly requires the proposal to be expired before removal [4](#0-3) . This enforcement prevents cleanup of proposals with far-future expiration times. Proposals are stored in the `State.Proposals` mapping [5](#0-4) .

The same vulnerability pattern exists in Parliament and Referendum contracts with identical validation logic [6](#0-5) [7](#0-6) . Both contracts have the same cleanup requirement [8](#0-7) [9](#0-8) .

## Impact Explanation

An attacker with ProposerWhiteList membership can create proposals with `ExpiredTime` set to year 9999 (timestamp 253402300799), causing:

1. **Permanent Storage Consumption**: Each `ProposalInfo` object occupies storage containing addresses, parameters, title, description, and vote tracking lists. These proposals cannot be cleaned up until year 9999 (approximately 8,000 years from now).

2. **Unbounded Storage Growth**: There are no limits on the number of proposals a whitelisted proposer can create. By repeatedly calling `CreateProposal` with maximum expiration times, an attacker can continuously inflate storage.

3. **Organization-Specific Impact**: The attack affects the targeted organization's proposal storage in the `State.Proposals` mapping. While other organizations remain unaffected, the victim organization experiences degraded performance and increased operational costs.

4. **Economic Griefing**: The attack cost is limited to transaction fees, making it economically feasible as a griefing vector against specific governance organizations.

The severity is **Medium** because while the impact is real and permanent, it:
- Does not enable fund theft or unauthorized execution
- Requires ProposerWhiteList membership (partial trust assumption)
- Affects specific organizations rather than the entire protocol
- Does not compromise consensus or cross-chain integrity

## Likelihood Explanation

**Attacker Capabilities Required:**
- Membership in an organization's ProposerWhiteList
- This is a partially trusted role but can be compromised through account hacking or malicious insiders

**Attack Complexity:**
- Low - simply call `CreateProposal` with `ExpiredTime.Seconds = 253402300799L`
- No complex transaction sequences or timing requirements needed
- Can be repeated arbitrarily to create multiple locked proposals

**Feasibility Conditions:**
- The `CreateProposal` function is publicly accessible with only whitelist authorization [10](#0-9) 
- Transaction fees provide minimal economic deterrent
- ProposerWhiteList members may have legitimate reasons to be in the list but could act maliciously or be compromised

**Detection Constraints:**
- Proposals with far-future expiration times are valid according to current contract logic
- No monitoring or alerting mechanisms exist for abnormal expiration time values
- The attack would only become apparent when storage costs become burdensome

The likelihood is **Realistic** because ProposerWhiteList compromise scenarios (stolen keys, malicious insiders, or social engineering) are practical threat vectors in decentralized governance systems.

## Recommendation

Add an upper bound validation on the `ExpiredTime` field in the proposal validation logic for all three governance contracts. The fix should enforce a reasonable maximum proposal lifetime (e.g., 1 year or 365 days):

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    // Add maximum expiration time check
    var maxExpirationTime = Context.CurrentBlockTime.AddDays(365); // 1 year maximum
    
    return proposal.ExpiredTime != null && 
           Context.CurrentBlockTime < proposal.ExpiredTime &&
           proposal.ExpiredTime <= maxExpirationTime;
}
```

This change should be applied to:
- `Association_Helper.cs` (line 83-90)
- `Parliament_Helper.cs` (line 177-180)
- `Referendum_Helper.cs` (line 104-113)

## Proof of Concept

```csharp
[Fact]
public async Task CreateProposal_WithFarFutureExpiration_CannotBeCleared()
{
    // Setup: Create an organization and add proposer to whitelist
    var organizationAddress = await CreateOrganizationAsync();
    var proposer = DefaultSender;
    
    // Create proposal with year 9999 expiration
    var farFutureTime = new Timestamp { Seconds = 253402300799L }; // Year 9999
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractStub.Transfer),
            ExpiredTime = farFutureTime,
            Params = new TransferInput { To = User1Address, Amount = 100, Symbol = "ELF" }.ToByteString()
        });
    
    // Verify proposal was created successfully
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ExpiredTime.Seconds.ShouldBe(253402300799L);
    
    // Attempt to clear the proposal - should fail because it's not expired
    var clearResult = await AssociationContractStub.ClearProposal.SendWithExceptionAsync(proposalId.Output);
    clearResult.TransactionResult.Error.ShouldContain("Proposal clear failed");
    
    // Verify proposal still exists in storage
    var stillExists = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    stillExists.ProposalId.ShouldBe(proposalId.Output);
}
```

## Notes

This vulnerability represents a design flaw in input validation rather than a critical security breach. While ProposerWhiteList members are semi-trusted, the system should enforce reasonable bounds on all user inputs, including proposal expiration times. The issue is classified as Medium severity because it enables permanent storage bloat attacks at minimal cost, but does not compromise funds, authorization, or consensus mechanisms. Organizations can mitigate this by carefully vetting ProposerWhiteList members, but a protocol-level fix is recommended to enforce maximum proposal lifetimes.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L89-89)
```csharp
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L152-152)
```csharp
            ExpiredTime = input.ExpiredTime,
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L164-164)
```csharp
        State.Proposals[proposalId] = proposal;
```

**File:** contract/AElf.Contracts.Election/TimestampHelper.cs (L15-15)
```csharp
    public static Timestamp MaxValue => new() { Nanos = 999999999, Seconds = 253402300799L };
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L286-286)
```csharp
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L179-179)
```csharp
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L108-108)
```csharp
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L183-183)
```csharp
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L158-158)
```csharp
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
```
