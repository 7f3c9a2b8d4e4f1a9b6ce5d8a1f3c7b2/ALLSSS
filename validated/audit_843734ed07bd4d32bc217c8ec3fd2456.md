# Audit Report

## Title
Vote ID Reuse in Delegated Voting Enables Historical Record Manipulation and Audit Trail Corruption

## Summary
The Vote contract's `Vote()` function unconditionally overwrites `VotingRecord` state without validating vote ID uniqueness in delegated voting scenarios. When a Sponsor reuses a previously withdrawn vote ID for a different voter, the original voting record is permanently destroyed, corrupting the historical audit trail relied upon by governance view methods.

## Finding Description

The vulnerability exists in the `Vote()` function which stores voting records by directly overwriting state without checking if a vote ID already exists: [1](#0-0) 

For delegated voting (IsLockToken = false), the Sponsor provides the vote ID in the input parameter and has full control over its value. The validation function `AssertValidVoteInput()` checks voting item existence, options, and snapshot numbers, but critically does NOT validate vote ID uniqueness: [2](#0-1) 

When `UpdateVotedItems()` is called during voting, it only removes the vote ID from the **current voter's** `WithdrawnVotes` list, not from any previous voter who may have used that ID: [3](#0-2) 

**Attack Flow:**
1. Sponsor creates vote for Voter A with `voteId = X`, Option = Candidate A
2. Sponsor withdraws vote X (sets `IsWithdrawn = true`, adds X to Voter A's `WithdrawnVotingRecordIds`)
3. Sponsor creates NEW vote for Voter B with SAME `voteId = X`, Option = Candidate B
4. `State.VotingRecords[X]` is overwritten with Voter B's data (Voter: B, Option: Candidate B)
5. Voter A's `WithdrawnVotingRecordIds` still contains X, but `GetVotingRecords(X)` now returns Voter B's record
6. Original historical record showing Voter A voted for Candidate A is permanently lost

The Election contract's `GetElectorVoteWithAllRecords()` method relies on these records for displaying complete voting history: [4](#0-3) 

This method fetches withdrawn records using the vote IDs from `WithdrawnVotingRecordIds`, but receives corrupted data when IDs are reused.

Critically, the Election contract's own `ChangeVotingOption` feature intentionally exploits this design by reusing vote IDs: [5](#0-4) 

This proves the vulnerability is not theoretical—it's actively used in production and causes audit trail corruption even for legitimate use cases.

## Impact Explanation

**Critical Governance Impact:**
- **Permanent Data Loss:** Original `VotingRecord` data is irrecoverably destroyed when overwritten
- **Audit Trail Corruption:** View methods like `GetElectorVoteWithAllRecords()` and `GetCandidateVoteWithAllRecords()` return incorrect historical data showing votes that belonged to other voters
- **Transparency Violation:** Governance systems require immutable historical records for accountability and compliance
- **Evidence Destruction:** Previous voting decisions can be erased, hiding evidence of governance actions

**Why MEDIUM Severity:**
- Vote tallies remain mathematically correct due to proper addition/subtraction in `UpdateVotingResult()` and withdrawal logic
- No direct financial loss to users or protocol
- Requires Sponsor role, which is typically a trusted governance contract
- However, governance integrity and transparency are fundamental protocol invariants that must be preserved regardless of trust assumptions

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities:**
- Must be the Sponsor of a delegated voting item (IsLockToken = false)
- Can provide arbitrary vote IDs when calling `Vote()`
- Single transaction is sufficient to exploit

**Why This is Realistic:**
1. **Already Happening in Production:** The Election contract's `ChangeVotingOption` feature intentionally reuses vote IDs, demonstrating this issue exists in live code and affects real users

2. **Documented Feature:** Delegated voting is a standard feature where the Election contract acts as Sponsor: [6](#0-5) 

3. **Generic Library Contract:** The Vote contract is designed to be used by multiple contracts, not just Election. Other Sponsors might lack additional protections

4. **No Detection Mechanism:** The `Voted` event is emitted normally, and observers cannot detect that a previous record was overwritten

**Feasibility:** LOW complexity—single transaction with controlled input, no timing requirements, easily reproducible.

## Recommendation

Add vote ID uniqueness validation in `AssertValidVoteInput()` for delegated voting:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    if (!votingItem.IsLockToken)
    {
        Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
        Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
        Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        // ADD THIS CHECK:
        Assert(State.VotingRecords[input.VoteId] == null, "Vote ID already exists. Cannot reuse vote IDs.");
    }
    else
    {
        // ... existing code
    }
    return votingItem;
}
```

Alternatively, if vote ID reuse is intentional for `ChangeVotingOption`, implement a proper "update" mechanism that preserves historical records by:
1. Creating a new vote ID for the changed vote
2. Keeping the original withdrawn record intact
3. Or maintaining a separate audit log that tracks all vote state transitions

## Proof of Concept

```csharp
[Fact]
public async Task VoteIdReuse_CorruptsAuditTrail_Test()
{
    // Register a delegated voting item (IsLockToken = false)
    var votingItem = await RegisterVotingItemAsync(100, 3, false, DefaultSender, 1);
    
    // Scenario: Sponsor creates vote for VoterA
    var voterA = Accounts[1].Address;
    var voterB = Accounts[2].Address;
    var sharedVoteId = HashHelper.ComputeFrom("shared_vote_id");
    var optionA = votingItem.Options[0];
    var optionB = votingItem.Options[1];
    
    // Step 1: Sponsor votes for VoterA with voteId X
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Voter = voterA,
        VoteId = sharedVoteId,
        Option = optionA,
        Amount = 100
    });
    
    // Verify VoterA's record
    var voterARecord1 = await VoteContractStub.GetVotingRecord.CallAsync(sharedVoteId);
    voterARecord1.Voter.ShouldBe(voterA);
    voterARecord1.Option.ShouldBe(optionA);
    
    // Step 2: Sponsor withdraws VoterA's vote
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput { VoteId = sharedVoteId });
    
    // Verify vote is in VoterA's withdrawn list
    var voterAItems = await VoteContractStub.GetVotedItems.CallAsync(voterA);
    voterAItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.ShouldContain(sharedVoteId);
    
    // Step 3: Sponsor reuses SAME voteId X for VoterB with different option
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Voter = voterB,
        VoteId = sharedVoteId, // REUSING THE SAME ID!
        Option = optionB,
        Amount = 200
    });
    
    // VULNERABILITY: Original record is overwritten
    var corruptedRecord = await VoteContractStub.GetVotingRecord.CallAsync(sharedVoteId);
    corruptedRecord.Voter.ShouldBe(voterB); // Now shows VoterB instead of VoterA
    corruptedRecord.Option.ShouldBe(optionB); // Now shows OptionB instead of OptionA
    
    // AUDIT TRAIL CORRUPTION: VoterA's withdrawn votes list still contains sharedVoteId,
    // but retrieving it returns VoterB's data
    voterAItems = await VoteContractStub.GetVotedItems.CallAsync(voterA);
    voterAItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.ShouldContain(sharedVoteId);
    
    // When GetVotingRecords is called with VoterA's withdrawn IDs, it returns VoterB's data!
    var withdrawnRecords = await VoteContractStub.GetVotingRecords.CallAsync(new GetVotingRecordsInput
    {
        Ids = { voterAItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes }
    });
    
    // PROOF OF CORRUPTION: VoterA's historical record shows VoterB's vote!
    withdrawnRecords.Records[0].Voter.ShouldBe(voterB); // WRONG! Should be voterA
    withdrawnRecords.Records[0].Option.ShouldBe(optionB); // WRONG! Should be optionA
    
    // Original historical record of VoterA voting for optionA is permanently lost
}
```

## Notes

This vulnerability represents a fundamental design flaw where historical immutability is not enforced in the Vote contract. While the Election contract's `ChangeVotingOption` is the most visible manifestation, any Sponsor of delegated voting items could exploit this to corrupt audit trails. The MEDIUM severity reflects that while there's no fund loss, governance transparency and accountability are critical invariants that must be maintained in any blockchain governance system.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L204-222)
```csharp
    public override ElectorVote GetElectorVoteWithAllRecords(StringValue input)
    {
        var votes = GetElectorVoteWithRecords(input);

        if (!votes.WithdrawnVotingRecordIds.Any()) return votes;

        var votedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.WithdrawnVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in votedWithdrawnRecords)
        {
            var voteId = votes.WithdrawnVotingRecordIds[index++];
            votes.WithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L45-60)
```csharp
        // Withdraw old votes
        State.VoteContract.Withdraw.Send(new WithdrawInput
        {
            VoteId = input.VoteId
        });

        // Create new votes
        State.VoteContract.Vote.Send(new VoteInput
        {
            VoteId = input.VoteId,
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Amount = votingRecord.Amount,
            Voter = votingRecord.Voter,
            Option = input.CandidatePubkey,
            IsChangeTarget = true
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L62-62)
```csharp
            IsLockToken = false,
```
