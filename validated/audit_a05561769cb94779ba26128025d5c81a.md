# Audit Report

## Title
Secret Sharing Information Permanently Stored On-Chain Enabling Retrospective InValue Recovery

## Summary
The AEDPoS consensus contract stores encrypted and decrypted secret sharing pieces in persistent blockchain storage (`State.Rounds`) but only removes them from block headers. Anyone can query historical round information via the public `GetRoundInformation` view method and recover miners' secret InValues using the stored decrypted pieces, completely undermining the secret sharing security mechanism.

## Finding Description

The vulnerability exists due to a critical disconnect between what data is stored persistently versus what data is cleaned up.

**Storage Path:** When miners produce blocks, `ProcessUpdateValue` processes consensus updates. [1](#0-0)  When secret sharing is enabled, it calls `PerformSecretSharing` which adds `encrypted_pieces` and `decrypted_pieces` to the Round object's miner information. [2](#0-1) 

This Round object (containing all secret pieces) is then persisted to blockchain state via `TryToUpdateRoundInformation`. [3](#0-2) [4](#0-3) 

**Deletion Path:** The `DeleteSecretSharingInformation()` method clears encrypted and decrypted pieces from Round objects. [5](#0-4) 

However, this method is ONLY called when generating consensus block extra data for headers, and it operates on a copy of the Round object being returned (`information.Round`) - not the already-persisted state in `State.Rounds`. [6](#0-5) 

**Exposure Path:** The public view method `GetRoundInformation` directly returns Round objects from `State.Rounds[roundNumber]` without any filtering of secret sharing information. [7](#0-6) [8](#0-7)  It is defined as a view method with no access control. [9](#0-8) 

**Recovery Mechanism:** The contract itself demonstrates how to recover InValues from decrypted pieces using `SecretSharingHelper.DecodeSecret`, requiring only 2/3 threshold of miners' decrypted pieces. [10](#0-9) 

The protobuf definition confirms that `encrypted_pieces` and `decrypted_pieces` are stored as part of `MinerInRound` within the Round structure. [11](#0-10) 

## Impact Explanation

This vulnerability has **HIGH severity** impact on consensus integrity:

1. **Secret Sharing Security Broken**: The entire purpose of the secret sharing mechanism is defeated. InValues are meant to remain secret until explicitly revealed by the protocol, but all decrypted pieces (which can reconstruct the InValue) are permanently stored on-chain in accessible storage.

2. **Retrospective Analysis**: Any party can reconstruct past InValues by querying historical rounds and using the publicly available recovery algorithm with the stored decrypted pieces. This enables analysis of all consensus randomness since deployment.

3. **Consensus Predictability**: InValues are used for random number generation in consensus through VRF mechanisms. Recovering past InValues could enable analysis of consensus behavior patterns and potentially predict future randomness if there are implementation weaknesses in InValue generation.

4. **Protocol-Wide Exposure**: This affects all consensus rounds where secret sharing is enabled. Historical round data persists for multiple rounds (40,960 rounds as controlled by `AEDPoSContractConstants.KeepRounds`). [12](#0-11) [13](#0-12) 

## Likelihood Explanation

The likelihood of exploitation is **VERY HIGH**:

1. **Zero Barrier Entry**: `GetRoundInformation` is a public view method with no authentication or permission checks. Any user can call it.

2. **Trivial Execution**: Exploitation requires only three simple steps:
   - Query `GetRoundInformation(roundNumber)` for any past round
   - Extract `DecryptedPieces` from the returned Round object's miner information
   - Apply the publicly available `SecretSharingHelper.DecodeSecret` algorithm with 2/3 threshold

3. **No Detection**: Querying view methods is a read-only operation that leaves no transaction trace on the blockchain, making exploitation completely undetectable.

4. **Zero Cost**: View methods are free to call and require no transaction fees.

5. **Always Available**: The data persists in `State.Rounds` for 40,960 rounds before cleanup, providing a wide window of exposure.

## Recommendation

Apply `DeleteSecretSharingInformation()` to the Round object before persisting it to `State.Rounds`, not just when generating block headers. Modify `TryToUpdateRoundInformation` to clean secret sharing data:

```csharp
private bool TryToUpdateRoundInformation(Round round)
{
    var ri = State.Rounds[round.RoundNumber];
    if (ri == null) return false;
    
    // Clean secret sharing information before persisting
    round.DeleteSecretSharingInformation();
    
    State.Rounds[round.RoundNumber] = round;
    return true;
}
```

Alternatively, filter the output of `GetRoundInformation` to exclude secret sharing data before returning it to callers.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
public async Task SecretSharingDataExposedViaGetRoundInformation()
{
    // Setup: Mine some blocks with secret sharing enabled
    await InitializeConsensusContract();
    await MineSeveralBlocksWithSecretSharing();
    
    // Attack: Query historical round information
    var roundNumber = await ConsensusStub.GetCurrentRoundNumber.CallAsync(new Empty());
    var roundInfo = await ConsensusStub.GetRoundInformation.CallAsync(roundNumber);
    
    // Verify: Secret sharing data is exposed
    var minerInfo = roundInfo.RealTimeMinersInformation.First().Value;
    
    // Assert that encrypted and decrypted pieces are present in persistent storage
    Assert.True(minerInfo.EncryptedPieces.Count > 0);
    Assert.True(minerInfo.DecryptedPieces.Count > 0);
    
    // Demonstrate InValue recovery is possible
    var decryptedPieces = roundInfo.RealTimeMinersInformation.Values
        .SelectMany(m => m.DecryptedPieces.Values)
        .ToList();
    
    // With 2/3 threshold, InValue can be recovered using SecretSharingHelper.DecodeSecret
    Assert.True(decryptedPieces.Count >= roundInfo.RealTimeMinersInformation.Count * 2 / 3);
}
```

## Notes

The vulnerability stems from an architectural design flaw where the cleanup mechanism (`DeleteSecretSharingInformation`) was only applied to the block header data path, not the persistent storage path. The secret sharing mechanism's security model assumes that decrypted pieces remain ephemeral and are never accessible together, but storing them all in queryable persistent state violates this assumption completely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-258)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L66-70)
```csharp
    private bool TryToGetRoundInformation(long roundNumber, out Round round)
    {
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L118-123)
```csharp
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L26-29)
```csharp
    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** protobuf/aedpos_contract.proto (L78-80)
```text
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/aedpos_contract.proto (L294-296)
```text
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
