# Audit Report

## Title
Unvalidated Miner Order Assignment Enables Consensus DoS via Duplicate and Invalid Orders

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract accepts user-provided order values without validation, allowing malicious miners to assign invalid orders (outside the range [1, minersCount]) to themselves or other miners via `TuneOrderInformation`. This causes the `BreakContinuousMining()` function to throw an `InvalidOperationException` during next round generation, permanently halting consensus progression.

## Finding Description

The vulnerability exists in the order assignment flow where user-controlled order values are directly assigned without bounds checking, breaking the consensus invariant that all miners must have unique orders within the valid range [1, minersCount].

**Entry Point - Public Method:**
The `UpdateValue` method is publicly accessible to any miner in the current miner list. [1](#0-0) 

**Authorization Check - Insufficient:**
The only authorization check is `PreCheck()` which verifies the caller is in the current or previous miner list, but does NOT validate order values. [2](#0-1) 

**Missing Validation - Direct Assignment:**
In `ProcessUpdateValue`, user-provided order values are directly assigned to `FinalOrderOfNextRound` without any bounds checking to ensure they are within [1, minersCount]. [3](#0-2) 

Additionally, the `TuneOrderInformation` map allows a miner to set ANY other miner's order to ANY value without validation. [4](#0-3) 

**Input Definition - No Constraints:**
The proto definition shows these are user-controlled int32 fields with no constraints. [5](#0-4) 

**Validation Provider - Insufficient:**
The `UpdateValueValidationProvider` only validates OutValue, Signature, and PreviousInValue - it does NOT validate order values at all. [6](#0-5) 

**Propagation to Next Round:**
When generating the next round, miners who successfully mined use their `FinalOrderOfNextRound` values (which may be invalid). [7](#0-6) 

The `occupiedOrders` list contains these potentially invalid orders, and `ableOrders` is calculated as the complement. [8](#0-7) 

**Critical Failure Point:**
The `BreakContinuousMining()` function is called during next round generation. [9](#0-8) 

This function uses `First()` to find miners with specific orders. If a miner with Order == 1 doesn't exist (because an invalid order was assigned), this throws `InvalidOperationException`. [10](#0-9) 

Similarly for Order == 2: [11](#0-10) 

The `GetMiningInterval()` function also expects exactly two miners with Order == 1 and Order == 2, accessing `firstTwoMiners[1]`. [12](#0-11) 

**Attack Scenario:**
1. Assume 5 miners (A, B, C, D, E) all successfully mine in current round
2. Malicious Miner B calls `UpdateValue` with `TuneOrderInformation = { "A": 10 }`
3. This sets Miner A's `FinalOrderOfNextRound = 10` (invalid, outside [1, 5])
4. After processing: A(10), B(2), C(3), D(4), E(5)
5. Next round generation uses these orders
6. When `BreakContinuousMining()` executes line 79, it searches for `Order == 1`
7. No miner has Order == 1, so `First()` throws `InvalidOperationException`
8. Next round generation fails, consensus halts permanently

## Impact Explanation

**Consensus Halt (Critical):**
When a malicious miner assigns invalid orders via `TuneOrderInformation`, the next round cannot be generated because `BreakContinuousMining()` throws an exception. This is called during the NextRound consensus behavior. [13](#0-12) 

**Protocol-Wide Impact:**
- All nodes cannot progress past the corrupted round
- Mining rewards are not distributed
- Cross-chain operations that depend on round progression are blocked  
- The entire chain becomes unresponsive until governance intervention (requiring emergency contract upgrade or manual state repair)

**Severity Justification:**
This is a critical availability vulnerability. Unlike temporary DoS that can recover, this creates a permanent consensus halt requiring extraordinary governance intervention. The entire blockchain infrastructure becomes non-functional.

## Likelihood Explanation

**Attacker Capabilities:**
Any miner in the current miner list can exploit this vulnerability. Being a miner only requires winning the normal election process through staking, which is the intended design of the system.

**Attack Complexity:**
The attack is trivial to execute:
- Call the public `UpdateValue` method with crafted `TuneOrderInformation`
- No race conditions or timing requirements
- Single transaction with immediate effect
- No economic cost beyond normal transaction fees

**Feasibility:**
The attack has no barriers beyond becoming a miner through normal election:
- No special privileges required
- No need to compromise other miners
- Attack succeeds deterministically
- Cannot be prevented by other miners or validators

**Detection/Prevention:**
Currently there is no validation that prevents this attack. By the time the invalid orders are observable on-chain, the next round generation has already failed and consensus is halted.

**Likelihood Assessment:** 
HIGH - Any miner can execute this attack at any time with a single transaction. The attack is practical, requires minimal effort, and immediately achieves complete consensus DoS.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all order values are within the valid range [1, minersCount]:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound
    Assert(updateValueInput.SupposedOrderOfNextRound >= 1 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           $"Invalid order: must be between 1 and {minersCount}");
    
    // Validate TuneOrderInformation values
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
               $"Invalid tune order for {tuneOrder.Key}: must be between 1 and {minersCount}");
    }
    
    // Rest of existing logic...
}
```

Additionally, add a defensive check in `BreakContinuousMining()` to gracefully handle missing orders rather than throwing exceptions, though the primary fix should be input validation.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanHaltConsensus_ViaInvalidOrderAssignment()
{
    // Setup: 5 miners in current round, all successfully mine
    var minerKeys = Enumerable.Range(0, 5).Select(_ => SampleECKeyPairs.KeyPairs[_]).ToList();
    var currentRound = GenerateRoundWithMiners(minerKeys, allMined: true);
    
    // Malicious Miner B (index 1) crafts UpdateValueInput
    var maliciousInput = new UpdateValueInput
    {
        SupposedOrderOfNextRound = 2, // Valid for self
        TuneOrderInformation = 
        {
            { minerKeys[0].PublicKey.ToHex(), 10 } // Invalid! Sets Miner A to order 10 (out of range)
        },
        // ... other required fields ...
    };
    
    // Miner B calls UpdateValue
    var result = await MinerBStub.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // When next round generation is triggered by extra block producer
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(async () =>
    {
        await ExtraBlockProducerStub.NextRound.SendAsync(new NextRoundInput { /* ... */ });
    });
    
    // Verify: Consensus halted due to missing Order == 1
    exception.Message.ShouldContain("Sequence contains no matching element");
    
    // Chain is now permanently halted - no further blocks can be produced
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation for the AEDPoS consensus mechanism. The `TuneOrderInformation` feature is designed to allow miners to coordinate order adjustments for efficiency, but without validation it becomes a consensus-breaking attack vector.

The root cause is the trust placed in miners to provide valid order values, combined with the use of `First()` instead of `FirstOrDefault()` in critical consensus logic. Both issues must be addressed: input validation to prevent invalid states, and defensive programming to handle unexpected states gracefully.

Recovery from this attack would require either:
1. Emergency contract upgrade via governance (if governance can still function)
2. Manual state repair by chain operators
3. Chain restart from a checkpoint before the corrupted round

All of these recovery options have severe operational and security implications.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L206-208)
```text
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L67-67)
```csharp
        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L83-84)
```csharp
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
