# Audit Report

## Title
Unbounded MaximumMinersCount Enables Computational DoS via DecodeSecret Complexity

## Summary
The `SetMaximumMinersCount` function lacks upper bound validation, allowing Parliament to set arbitrarily large miner counts that cause excessive computational overhead during NextRound block production. The `RevealSharedInValues` method calls `SecretSharingHelper.DecodeSecret` with O(minimumCount²) complexity for each miner, and since system contracts bypass execution observer tracking, this can exceed the 300ms block mining timeout and halt consensus.

## Finding Description

**Vulnerable Function**: The `SetMaximumMinersCount` method only validates that the input is greater than zero, with no upper bound check. [1](#0-0) 

**Attack Vector**: During NextRound block production, `GetConsensusExtraDataForNextRound` invokes `RevealSharedInValues` to reconstruct missing in-values from the previous round using Shamir's Secret Sharing. [2](#0-1) 

The method iterates through all miners in the previous round and calculates `minimumCount = minersCount × 2 / 3` for secret reconstruction threshold. [3](#0-2) 

For each qualifying miner, it calls `SecretSharingHelper.DecodeSecret` with this threshold to perform Lagrange polynomial interpolation. [4](#0-3) 

**Computational Complexity**: The `DecodeSecret` method performs nested iterations over the threshold value, resulting in O(threshold²) BigInteger operations over a finite field. With minersCount=300, minimumCount=200, each call performs approximately 40,000 BigInteger multiplications, modular arithmetic, and inverse calculations. [5](#0-4) 

**Execution Observer Bypass**: The execution observer patcher explicitly ignores system contracts, meaning the AEDPoS consensus contract's methods are not instrumented for branch/call count tracking. [6](#0-5) [7](#0-6) 

Additionally, `SecretSharingHelper` is in the external `AElf.Cryptography` assembly, which is never patched regardless - only methods within the contract module being compiled receive execution tracking injections. [8](#0-7) 

The default execution branch threshold is 15,000, but this limit does not apply to the DecodeSecret operations. [9](#0-8) 

**Mining Timeout Limits**: NextRound blocks use `DefaultBlockMiningLimit` which is calculated as `TinyBlockSlotInterval × 3/5`. With the default 4000ms mining interval and 8 tiny blocks per slot, this yields 300ms per block. [10](#0-9) [11](#0-10) 

When the computational cost of `RevealSharedInValues` exceeds this 300ms limit, block production fails and the round cannot advance.

## Impact Explanation

**Severity: HIGH** - Consensus Denial of Service leading to chain halt.

When Parliament sets `MaximumMinersCount` to a large value (e.g., 300-1000) and the actual miner count approaches this limit, the computational cost of processing secret shares for each miner becomes prohibitive:

- With 300 miners and threshold=200: Each miner's DecodeSecret performs ~40,000 operations
- Iterating through all 300 miners: Up to 12,000,000 BigInteger operations in a single block
- This easily exceeds the 300ms NextRound block timeout

Consequences:
1. NextRound block production times out and fails
2. Producing miners miss their time slots
3. Round transitions cannot complete
4. Chain consensus halts, preventing all block production and transaction processing

**Affected Parties**: All network participants - miners cannot produce blocks, users cannot submit transactions, and the entire chain becomes unavailable until Parliament can reduce the miner count (which itself requires block production to execute).

## Likelihood Explanation

**Probability: MEDIUM-LOW** - Requires Parliament governance approval but lacks technical safeguards.

**Prerequisites**:
1. Parliament must approve a `SetMaximumMinersCount` proposal with a dangerously high value (>200)
2. Actual miner count must grow toward this maximum through the auto-increment mechanism or election dynamics
3. NextRound block production must trigger `RevealSharedInValues` with a large miner set

**Feasibility**: While Parliament governance provides a social barrier against malicious actions, there is **no technical validation** preventing well-intentioned misconfiguration. Parliament members may set values like 500 or 1000 without understanding the O(n²) computational implications for secret sharing. The natural miner growth rate is slow (starting at 17 miners + 2/year), but Parliament can override this at any time. [12](#0-11) 

**Detection**: The issue becomes apparent when blocks begin timing out, allowing reactive mitigation. However, during the window of elevated miner counts, consensus availability is severely compromised.

## Recommendation

Add an upper bound validation to `SetMaximumMinersCount` that considers the computational constraints of secret sharing during block production. A safe maximum should account for the O(n²) complexity of DecodeSecret and the 300ms block timeout.

**Recommended fix**:
```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    Assert(input.Value <= AEDPoSContractConstants.MaximumMinersCountUpperBound, 
        "Max miners count exceeds safe computational limit.");
    
    // ... rest of method
}
```

Define `MaximumMinersCountUpperBound` based on empirical testing of DecodeSecret performance to ensure NextRound blocks complete within the 300ms timeout. A conservative value would be in the range of 50-100 miners.

Additionally, consider optimizing or caching secret sharing computations, or increasing the NextRound block timeout specifically to accommodate the additional computational overhead.

## Proof of Concept

```csharp
[Fact]
public async Task SetMaximumMinersCount_ExcessiveValue_CausesBlockTimeout()
{
    // Setup: Initialize consensus with Parliament control
    await InitializeContracts();
    
    // Parliament proposes and approves setting MaximumMinersCount to 300
    var proposal = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        ToAddress = ConsensusContractAddress,
        ContractMethodName = nameof(AEDPoSContract.SetMaximumMinersCount),
        Params = new Int32Value { Value = 300 }.ToByteString(),
        OrganizationAddress = parliamentOrganization
    });
    
    await ApproveAndReleaseProposal(proposal.Output);
    
    // Verify no upper bound check prevented this
    var maxMiners = await ConsensusContractStub.GetMaximumMinersCount.CallAsync(new Empty());
    maxMiners.Value.ShouldBe(300);
    
    // Simulate miner count growing to 300 through election
    await GrowMinerCountTo(300);
    
    // Attempt NextRound block production
    var startTime = DateTime.Now;
    var blockTimeout = false;
    
    try
    {
        // This will call GetConsensusExtraDataForNextRound -> RevealSharedInValues
        // which performs 300 × DecodeSecret(threshold=200) operations
        await ProduceNextRoundBlock();
    }
    catch (TimeoutException)
    {
        blockTimeout = true;
    }
    
    var duration = (DateTime.Now - startTime).TotalMilliseconds;
    
    // Assert: Block production exceeded 300ms timeout due to computational overhead
    blockTimeout.ShouldBeTrue();
    duration.ShouldBeGreaterThan(300);
}
```

## Notes

This vulnerability demonstrates a mis-scoped privilege where Parliament's authority to configure consensus parameters lacks technical safeguards against computationally infeasible values. While Parliament is trusted to act honestly, the absence of upper bound validation allows inadvertent chain DoS through legitimate governance processes. The issue is particularly subtle because the impact scales quadratically with miner count, making it non-obvious until the chain reaches critical size.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L48-62)
```csharp
            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/CallAndBranchCounts/Patcher.cs (L11-11)
```csharp
    public bool SystemContactIgnored => true;
```

**File:** src/AElf.CSharp.CodeOps/CSharpContractPatcher.cs (L32-32)
```csharp
        var patchers = _policy.GetPatchers<T>().Where(p => !p.SystemContactIgnored || !isSystemContract).ToList();
```

**File:** src/AElf.CSharp.CodeOps/Validators/Whitelist/IWhitelistProvider.cs (L226-228)
```csharp
            .Namespace("AElf.Cryptography.SecretSharing", Permission.Denied, type => type
                .Type(typeof(SecretSharingHelper), Permission.Denied, member => member
                    .Member(nameof(SecretSharingHelper.DecodeSecret), Permission.Allowed)));
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L36-37)
```csharp
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
```
