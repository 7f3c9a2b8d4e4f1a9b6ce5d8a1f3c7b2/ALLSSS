# Audit Report

## Title
Memory Exhaustion DoS via Unbounded RealTimeMinersInformation Dictionary in Consensus Validation

## Summary
The AEDPoS consensus validation process does not validate the size of the `ProvidedRound.RealTimeMinersInformation` dictionary before performing memory-intensive materialization operations. An elected miner can craft a block with consensus extra data containing an excessively large Round object, causing memory exhaustion on all validating nodes and resulting in network-wide denial of service.

## Finding Description

When a block is validated, the `ValidateConsensusBeforeExecution` method parses the consensus header information without any size constraints on the Round object's miner dictionary [1](#0-0) . The parsed `extraData.Round` becomes the `ProvidedRound` in the validation context [2](#0-1) .

During validation of new rounds, `TimeSlotValidationProvider` unconditionally calls `CheckRoundTimeSlots()` for rounds with different RoundIds [3](#0-2) . The critical vulnerability occurs in `CheckRoundTimeSlots()`, which materializes ALL values from the `RealTimeMinersInformation` dictionary into memory and sorts them [4](#0-3) .

Additional materialization occurs in `NextRoundMiningOrderValidationProvider` for NextRound behavior [5](#0-4)  and in `RoundTerminateValidationProvider` [6](#0-5) .

**Root Cause:** There is no validation comparing `ProvidedRound.RealTimeMinersInformation.Count` against `BaseRound.RealTimeMinersInformation.Count` or reasonable bounds. The only check is that the sender exists in the BaseRound [7](#0-6) . 

Each `MinerInRound` is a complex protobuf structure with multiple fields including maps and repeated timestamps [8](#0-7) . The network message size limit is 100MB [9](#0-8) , which allows for tens of thousands of miner entries.

## Impact Explanation

**Concrete Harm:**
- **Memory Exhaustion**: Materializing hundreds of thousands of `MinerInRound` objects causes OutOfMemoryException or severe memory pressure
- **Network-Wide DoS**: All nodes validating the malicious block experience simultaneous memory exhaustion
- **Consensus Disruption**: Nodes cannot process blocks, halting chain progression
- **Resource Starvation**: Even without OutOfMemoryException, excessive allocation and sorting operations degrade all node performance

**Affected Parties:**
- All full nodes performing block validation
- Block producers attempting to continue consensus
- Overall network availability and liveness

This represents a high-impact consensus availability attack that can be executed with a single malicious block from any elected miner.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an elected miner (one of ~17-21 initially)
- Can sign blocks and include arbitrary consensus extra data
- Needs to craft only one malicious block to trigger DoS

**Attack Complexity:**
- Low - simply populate the `RealTimeMinersInformation` protobuf map with excessive entries (e.g., 100,000+)
- No complex state manipulation required
- No precise timing requirements
- The malicious block propagates normally through the network

**Feasibility:**
- Attacker must be elected as a miner (requires community support/stake)
- Once elected, execution is straightforward
- No network-level protections prevent oversized Round objects in block headers
- The 5MB transaction limit does not apply to block header extra data

**Detection Difficulty:**
- The attack appears as a valid block until validation begins
- Memory exhaustion occurs during validation processing
- Limited forensic traces beyond the oversized consensus data

Given these factors, the likelihood is **Medium-High** for a malicious elected miner, as execution is trivial once miner status is obtained.

## Recommendation

Add validation to check the size of `ProvidedRound.RealTimeMinersInformation` before materialization:

1. In `ValidateBeforeExecution`, add a check comparing `extraData.Round.RealTimeMinersInformation.Count` against `baseRound.RealTimeMinersInformation.Count` with a reasonable tolerance (e.g., allow only the same count or minor variations for miner replacement scenarios).

2. Add an absolute upper bound check against the configured `MaximumMinersCount` value.

3. Consider adding early-exit checks in validation providers that materialize the dictionary to reject rounds with excessive miner counts before allocation.

Example fix location: Add validation after line 60 in `AEDPoSContract_Validation.cs`:
```csharp
// Validate miner count before expensive operations
if (extraData.Round.RealTimeMinersInformation.Count > baseRound.RealTimeMinersInformation.Count * 2 ||
    extraData.Round.RealTimeMinersInformation.Count > State.MaximumMinersCount.Value * 2)
{
    return new ValidationResult { 
        Success = false, 
        Message = "Provided round contains excessive miner entries." 
    };
}
```

## Proof of Concept

A proof of concept would involve:

1. Set up a test environment with an elected miner
2. Create a Round object with 100,000+ fake miner entries in `RealTimeMinersInformation`
3. Package this into a NextRound block's consensus extra data
4. Observe memory exhaustion during validation when `CheckRoundTimeSlots()` is called
5. Verify that all validating nodes experience the DoS condition

The test would demonstrate that the validation logic unconditionally materializes all dictionary values without checking the count first, leading to predictable memory exhaustion on all nodes.

## Notes

The vulnerability exists because the validation framework was designed to validate the correctness of consensus data from legitimate miners, but lacks defenses against deliberately oversized data structures. While the network message size limit (100MB) provides some constraint, it still allows for tens of thousands of complex `MinerInRound` objects that, when materialized and sorted, can exhaust node memory or cause severe performance degradation sufficient to halt consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L35-35)
```csharp
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-32)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** src/AElf.OS.Network.Grpc/GrpcConstants.cs (L28-29)
```csharp
    public const int DefaultMaxReceiveMessageLength = 100 * 1024 * 1024;
    public const int DefaultMaxSendMessageLength = 100 * 1024 * 1024;
```
