# Audit Report

## Title 
Symbol Number Collision Causes Guaranteed Transaction Failure with Maximum Fee Consumption in NFT Creation

## Summary
The `GenerateSymbolNumber()` function contains a critical flaw where the random hash is computed once before the collision-handling loop but never updated within it. When a collision occurs, the deterministic hash conversion returns the same number on every iteration, causing the loop to run until AElf's 15,000 branch threshold is exceeded, resulting in transaction failure with maximum fee consumption.

## Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` method where `randomHash` is calculated once before the do-while loop and remains static throughout all iterations. [1](#0-0) 

Inside the do-while loop, `Context.ConvertHashToInt64(randomHash, from, from.Mul(10))` is called with the same unchanging hash value on every iteration. [2](#0-1) 

The `ConvertHashToInt64` implementation uses deterministic modulo arithmetic, guaranteeing identical outputs for identical inputs. [3](#0-2) 

When a collision occurs (the generated number exists in `State.IsCreatedMap`), the while condition remains true indefinitely since the static hash produces the same number on every iteration, and the collision check continues to fail.

AElf's execution observer limits branch execution to 15,000 iterations. [4](#0-3) 

This protection causes the transaction to fail with `RuntimeBranchThresholdExceededException` after consuming maximum computational resources. [5](#0-4) 

The execution path is: User calls `Create(CreateInput)` [6](#0-5)  → `GetSymbol()` invokes `GenerateSymbolNumber()` [7](#0-6)  → Collision triggers infinite loop until branch threshold → Transaction fails with maximum fees consumed.

## Impact Explanation

**Direct Financial Loss:** Users lose transaction fees equivalent to 15,000 loop iterations when encountering a symbol collision, representing substantial resource consumption without successful NFT protocol creation.

**Denial of Service:** Legitimate users cannot create NFT protocols when collisions occur. As `State.IsCreatedMap` grows with more NFT creations, collision probability increases, progressively degrading system reliability. [8](#0-7) 

**Affected Users:** Any user calling the `Create()` method can be affected. The initial number space is constrained by `GetCurrentNumberLength()`, but collisions become inevitable as adoption grows. [9](#0-8) 

**Severity:** HIGH - This combines guaranteed financial loss (wasted transaction fees), denial of critical functionality (NFT protocol creation), and exploitability by malicious actors who can predict the deterministic random number generation.

## Likelihood Explanation

**Attacker Capabilities:** An attacker can predict the symbol number by observing publicly available block height and target user addresses (from pending transactions), given the deterministic nature of random number generation based on these inputs.

**Attack Complexity:** LOW to MEDIUM
1. Monitor pending `Create()` transactions or identify target user
2. Calculate the symbol number that will be generated for that user at the next block (using same block randomness and sender address)
3. Front-run by creating an NFT with that exact symbol number
4. Victim's transaction executes, hits collision, and fails after 15,000 iterations

**Accidental Triggering:** Even without malicious intent, natural collisions will occur as more NFTs are created. With deterministic random generation based on limited entropy sources (block height and sender address), the birthday paradox makes collisions statistically likely over time.

**Economic Rationality:** Attacker cost is minimal (one NFT creation fee), while the victim suffers maximum transaction fee loss. The attack is economically profitable if the attacker benefits from denying the victim's NFT creation (e.g., competitive NFT launch scenarios).

## Recommendation

Update the `GenerateSymbolNumber()` method to regenerate the random hash inside the loop when a collision is detected:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    do
    {
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

Alternatively, add a counter or nonce to the hash computation inside the loop to ensure different values on each iteration.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create an NFT protocol to occupy a specific symbol number
2. Mock the random number generation to produce the same number
3. Attempt to create another NFT protocol
4. Observe the transaction failing after 15,000 iterations with `RuntimeBranchThresholdExceededException`
5. Verify maximum fees were consumed

The vulnerability is evident from code inspection: the static hash in the loop guarantees the same number is generated on every iteration, making collision resolution impossible.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-26)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L67-69)
```csharp
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L75-77)
```csharp
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/Exceptions.cs (L77-86)
```csharp
public class RuntimeBranchThresholdExceededException : BaseAElfException
{
    public RuntimeBranchThresholdExceededException()
    {
    }

    public RuntimeBranchThresholdExceededException(string message) : base(message)
    {
    }
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L10-10)
```csharp
    public MappedState<long, bool> IsCreatedMap { get; set; }
```
