# Audit Report

## Title
EnableConnector DepositBalance Overwrite Vulnerability Leading to Fund Lock and Sell DoS

## Summary
The `EnableConnector` function in the TokenConverter contract directly overwrites `State.DepositBalance` with a newly calculated value, completely ignoring any existing balance accumulated from previous buy transactions. This publicly callable function lacks authorization checks and duplicate call prevention, allowing any attacker to repeatedly reset the deposit balance, causing permanent fund lock and complete denial of service for sell operations.

## Finding Description

The vulnerability exists in the `EnableConnector` function where deposit balance accounting is fundamentally broken through direct state assignment.

**Root Cause - Direct Assignment Instead of Increment:**

The critical flaw occurs where `EnableConnector` performs a direct assignment that completely overwrites any existing deposit balance [1](#0-0) . In contrast, the `Buy` function correctly increments the balance [2](#0-1) .

When users purchase tokens through `Buy`, the deposit balance correctly accumulates base tokens. However, calling `EnableConnector` on an already-enabled connector resets this accumulated value to whatever `GetNeededDeposit` calculates, without considering the current balance.

**Missing Protection #1 - No Duplicate Call Prevention:**

The `EnableConnector` function has no check to prevent re-enabling already active connectors [3](#0-2) . Compare this to `UpdateConnector` which explicitly guards against updating after activation [4](#0-3) . This explicit guard prevents updating after activation, but `EnableConnector` lacks any similar protection.

**Missing Protection #2 - No Authorization Requirement:**

The entire `EnableConnector` function is publicly callable with no authorization check [5](#0-4) . In contrast, critical management functions like `UpdateConnector`, `AddPairConnector`, and `SetFeeRate` all require controller authority via `AssertPerformedByConnectorController()` [6](#0-5) .

**Manipulable Calculation:**

The `GetNeededDeposit` calculation depends on user-controlled `AmountToTokenConvert` parameter [7](#0-6) . An attacker can manipulate this parameter such that `amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert` becomes zero or negative, resulting in `needDeposit = 0`, allowing them to overwrite large accumulated balances with zero or minimal values.

**Attack Execution Path:**

1. Connector pair exists with `IsPurchaseEnabled = true` and accumulated `DepositBalance = 5000` from user trading
2. Attacker crafts `ToBeConnectedTokenInfo` with `AmountToTokenConvert` set to minimize deposit calculation (e.g., setting it equal to or greater than `tokenInfo.TotalSupply - balance`)
3. Attacker calls public `EnableConnector` function (no authorization check stops this)
4. Function calculates `needDeposit.NeedAmount = 0` based on manipulated input
5. Line 297 overwrites: `State.DepositBalance[(NT)RESOURCE] = 0` (was 5000)
6. **5000 base tokens become permanently unaccounted for**

## Impact Explanation

**Permanent Fund Lock:**

The difference between the actual accumulated balance and the overwritten value becomes permanently locked in the contract with no state variable tracking it. The `DepositBalance` state variable [8](#0-7)  is the sole accounting mechanism for deposit tracking. Once overwritten, these funds cannot be recovered through normal contract operations since all balance accounting references the incorrect, artificially reduced value.

**Complete Sell Denial of Service:**

The `Sell` function relies on accurate `DepositBalance` for price calculation via `GetSelfBalance` [9](#0-8) . When the deposit connector's balance is retrieved, it returns the corrupted `State.DepositBalance` value [10](#0-9) .

The Bancor formula immediately rejects zero or negative balance as invalid [11](#0-10) . Any user attempting to sell tokens will trigger an `InvalidValueException` with message "Connector balance needs to be a positive number" before the transaction can even reach the balance subtraction logic [12](#0-11) .

This creates complete DoS of sell functionality for the affected connector pair, trapping all token holders.

**Affected Parties:**
- All existing token holders who purchased through `Buy` and wish to exit positions
- The protocol's market integrity and liquidity mechanisms  
- Future users unable to interact with the compromised connector pair

This breaks the fundamental security guarantee that user deposits are accurately tracked and redeemable.

## Likelihood Explanation

**High Likelihood due to:**

1. **No Privileges Required:** Any user can call `EnableConnector` - it's a public function with zero authorization checks
2. **Low Attack Complexity:** Single function call with easily calculable parameters
3. **Common Precondition:** Active connector pairs with trading volume exist in normal operation
4. **Minimal Attack Cost:** Attacker may need to transfer some resource tokens, but these tokens remain in the contract (not consumed), making the attack cost minimal or even reversible
5. **High Economic Incentive:** 
   - Attack cost is minimal (temporary token transfer)
   - Impact is severe (lock large sums + market DoS)
   - Profit opportunities via shorting affected tokens or manipulating prices by removing sell liquidity
6. **Difficult Detection:** Attack appears as legitimate `EnableConnector` call in logs without obvious malicious indicators

The combination of public access, no duplicate call prevention, and direct balance overwrite makes this vulnerability easily exploitable in production environments.

## Recommendation

Implement the following protections:

1. **Add Authorization Check:** Require connector controller authority at the start of `EnableConnector`:
   ```csharp
   public override Empty EnableConnector(ToBeConnectedTokenInfo input)
   {
       AssertPerformedByConnectorController();
       // ... rest of function
   }
   ```

2. **Add Duplicate Call Prevention:** Check if connector is already enabled:
   ```csharp
   var fromConnector = State.Connectors[input.TokenSymbol];
   Assert(fromConnector != null && !fromConnector.IsDepositAccount, 
       "[EnableConnector]Can't find from connector.");
   Assert(!fromConnector.IsPurchaseEnabled, 
       "Connector is already enabled");
   var toConnector = State.Connectors[fromConnector.RelatedSymbol];
   Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
   Assert(!toConnector.IsPurchaseEnabled, 
       "Connector is already enabled");
   ```

3. **Use Increment Instead of Assignment:** Change line 297 to add to existing balance:
   ```csharp
   State.DepositBalance[toConnector.Symbol] = 
       State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
   ```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_DepositBalance_Overwrite_Vulnerability_Test()
{
    // Setup: Initialize converter with connector pair
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "CPU";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue tokens and enable connector initially
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 1_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 1_000_000
    });
    
    // Simulate user trading - Buy operation accumulates deposit balance
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 10_000,
        PayLimit = 10_000
    });
    
    // Get deposit balance after buy - should have accumulated base tokens
    var ntSymbol = $"(NT){tokenSymbol}";
    var balanceAfterBuy = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    balanceAfterBuy.Value.ShouldBeGreaterThan(0); // Balance accumulated from trading
    
    // ATTACK: Call EnableConnector again with manipulated AmountToTokenConvert
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = tokenSymbol });
    var balance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = TokenConverterContractAddress, Symbol = tokenSymbol });
    
    // Set AmountToTokenConvert to make needDeposit = 0
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = tokenInfo.TotalSupply - balance.Balance
    });
    
    // VERIFY VULNERABILITY: Deposit balance has been overwritten to 0
    var balanceAfterAttack = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    balanceAfterAttack.Value.ShouldBe(0); // Balance was overwritten!
    
    // VERIFY IMPACT: Sell operation now fails with DoS
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = tokenSymbol,
        Amount = 1_000,
        ReceiveLimit = 0
    });
    sellResult.TransactionResult.Error.ShouldContain("Connector balance needs to be a positive number");
}
```

**Notes:**

The vulnerability is confirmed through code analysis showing three critical flaws that combine to create the exploit:

1. **Direct Assignment at Line 297**: Uses `=` operator instead of `.Add()` for balance updates, destroying accumulated state
2. **No Authorization**: Unlike other management functions (`UpdateConnector`, `AddPairConnector`, `SetFeeRate`), `EnableConnector` lacks `AssertPerformedByConnectorController()` check
3. **No Duplicate Protection**: Unlike `UpdateConnector` which asserts `!IsPurchaseEnabled`, `EnableConnector` allows re-activation

The attack is executable by any user with minimal cost, and results in permanent fund lock plus complete sell DoS due to Bancor formula rejecting zero balance. This breaks the core invariant that deposits must be accurately tracked for redemption.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L60-60)
```csharp
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L19-19)
```csharp
    public MappedState<string, long> DepositBalance { get; set; }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```
