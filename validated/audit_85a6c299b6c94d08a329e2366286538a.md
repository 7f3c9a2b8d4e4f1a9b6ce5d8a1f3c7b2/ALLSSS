# Audit Report

## Title
Unbounded Scheme Creation Leading to State Bloat and DoS in TokenHolder Contract

## Summary
The `CreateScheme` function in TokenHolderContract allows any caller to repeatedly create unlimited profit schemes without validation. Each invocation creates a new `Scheme` object in ProfitContract with permanent storage, causing unbounded state growth and enabling state bloat attacks that degrade node performance.

## Finding Description

The `CreateScheme` method in TokenHolderContract lacks validation to prevent duplicate scheme creation. [1](#0-0) 

Each invocation unconditionally calls `State.ProfitContract.CreateScheme.Send()`, which creates a new scheme in the underlying ProfitContract. The ProfitContract generates unique scheme IDs using a count-based mechanism [2](#0-1)  where the ID generation uses the existing scheme count to ensure uniqueness. [3](#0-2) 

When `Token` is null (as provided by TokenHolderContract), the scheme ID is generated as `Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false))` where `createdSchemeCount` equals the current count of schemes for that manager. This ensures each invocation creates a distinct scheme rather than updating an existing one.

Each created scheme is permanently stored in state. [4](#0-3)  The scheme is stored in `State.SchemeInfos[schemeId]` [5](#0-4)  and the scheme ID is appended to the `ManagingSchemeIds` array. [6](#0-5) [7](#0-6) 

Test evidence confirms this pattern is executable - a single manager can create multiple schemes successfully. [8](#0-7) 

## Impact Explanation

**State Database Bloat**: Each scheme creates a `Scheme` object containing virtual address, manager, scheme ID, current period, total shares, and other fields that is permanently stored. [9](#0-8) 

Additionally, each scheme ID is permanently appended to the `ManagingSchemeIds` array, causing linear growth with no upper bound or cleanup mechanism.

**DoS of Query Operations**: The `GetManagingSchemeIds` view method returns the complete array of scheme IDs for a manager. [10](#0-9) 

As schemes accumulate, this query returns increasingly large arrays, degrading node performance and potentially causing timeouts or memory issues. No constants limit the scheme count. [11](#0-10) 

**Severity**: Medium - While transaction fees provide economic barriers, the lack of any hard limit or duplicate check allows determined attackers to cause significant operational degradation through sustained state bloat attacks.

## Likelihood Explanation

**No Authorization Required**: The `CreateScheme` method is publicly accessible with no authorization checks in the TokenHolderContract implementation.

Any address can invoke this method repeatedly, limited only by transaction fees and block gas constraints. The attack can be executed across multiple blocks to bypass per-block limits.

**Economic Feasibility**: Transaction fees (if configured via ACS1) [12](#0-11)  provide the primary cost barrier. However, if fees are set low or an attacker has sufficient funds, they can create hundreds or thousands of schemes. The test suite demonstrates creating multiple schemes (5 in the test case) is a supported and executable pattern.

**Probability**: Medium - Simple to execute but requires sustained transaction fee expenditure proportional to the number of schemes created.

## Recommendation

Implement one or more of the following mitigations:

1. **Add duplicate check**: Before creating a new scheme in TokenHolderContract, check if `State.TokenHolderProfitSchemes[Context.Sender]` already contains a valid scheme. Prevent creation if one exists.

2. **Implement maximum scheme limit**: Add a constant in ProfitContractConstants limiting the maximum number of schemes per manager (e.g., `MaxSchemesPerManager = 10`). Enforce this limit in `ProfitContract.CreateScheme`.

3. **Require scheme removal before recreation**: Add a `RemoveScheme` method that properly cleans up state, and require users to call it before creating a new scheme.

4. **Add governance-controlled scheme creation**: Make scheme creation require approval from a governance organization for non-system contracts.

Example fix for TokenHolderContract:
```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add duplicate check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null || 
           State.TokenHolderProfitSchemes[Context.Sender].SchemeId == null,
           "Scheme already exists for this address.");
    
    // ... rest of implementation
}
```

## Proof of Concept

The following test demonstrates the vulnerability by creating multiple schemes for the same manager:

```csharp
[Fact]
public async Task TokenHolder_UnboundedSchemeCreation_StateBloa_Test()
{
    // Demonstrate that a single address can create multiple schemes
    const int schemeCreationCount = 10;
    
    for (var i = 0; i < schemeCreationCount; i++)
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(
            new CreateTokenHolderProfitSchemeInput
            {
                Symbol = "ELF",
                MinimumLockMinutes = 100
            });
    }
    
    // Verify multiple schemes were created in ProfitContract
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    
    // This demonstrates unbounded growth - count increases with each call
    schemeIds.SchemeIds.Count.ShouldBeGreaterThanOrEqualTo(schemeCreationCount);
    
    // Each scheme consumes permanent storage
    foreach (var schemeId in schemeIds.SchemeIds)
    {
        var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        scheme.ShouldNotBeNull();
        scheme.Manager.ShouldBe(Starter);
    }
}
```

This test proves that:
1. Multiple CreateScheme calls succeed without error
2. Each call creates a new scheme in ProfitContract storage
3. The ManagingSchemeIds array grows unboundedly
4. All schemes persist permanently in state

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-56)
```csharp
        var schemeId = GenerateSchemeId(input);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L59-60)
```csharp
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L938-954)
```csharp
    private Scheme GetNewScheme(CreateSchemeInput input, Hash schemeId, Address manager)
    {
        var scheme = new Scheme
        {
            SchemeId = schemeId,
            // The address of general ledger for current profit scheme.
            VirtualAddress = Context.ConvertVirtualAddressToContractAddress(schemeId),
            Manager = manager,
            ProfitReceivingDuePeriodCount = input.ProfitReceivingDuePeriodCount,
            CurrentPeriod = 1,
            IsReleaseAllBalanceEveryTimeByDefault = input.IsReleaseAllBalanceEveryTimeByDefault,
            DelayDistributePeriodCount = input.DelayDistributePeriodCount,
            CanRemoveBeneficiaryDirectly = input.CanRemoveBeneficiaryDirectly
        };

        return scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L9-9)
```csharp
    public MappedState<Hash, Scheme> SchemeInfos { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L15-15)
```csharp
    public MappedState<Address, CreatedSchemeIds> ManagingSchemeIds { get; set; }
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L19-40)
```csharp
    public async Task ProfitContract_CreateManyProfitItems_Test()
    {
        const int createTimes = 5;

        var creator = Creators[0];
        var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

        for (var i = 0; i < createTimes; i++)
        {
            var executionResult = await creator.CreateScheme.SendAsync(new CreateSchemeInput
            {
            });
            executionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }

        var createdSchemeIds = await creator.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = creatorAddress
        });

        createdSchemeIds.SchemeIds.Count.ShouldBe(createTimes);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L1-10)
```csharp
namespace AElf.Contracts.Profit;

public class ProfitContractConstants
{
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
}
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```
