# Audit Report

## Title
Missing Cryptographic Validation in Secret Sharing Revelation Allows Consensus Manipulation and Denial of Service

## Summary
The AEDPoS consensus contract accepts revealed InValues from miners via secret sharing without validating that they hash to previously committed OutValues. This breaks the VRF commit-reveal scheme's fundamental cryptographic guarantee, allowing any miner to inject arbitrary values as another miner's PreviousInValue, enabling targeted denial-of-service attacks that prevent specific miners from producing valid blocks.

## Finding Description

### Vulnerability Location

The vulnerability exists in three distinct code paths where revealed InValues are set without cryptographic validation:

**Path 1: UpdateLatestSecretPieces** - Accepts unvalidated revealed InValues from trigger information and directly sets them as other miners' PreviousInValue: [1](#0-0) 

**Path 2: PerformSecretSharing** - Accepts unvalidated InValues from transaction input and directly sets them as other miners' PreviousInValue: [2](#0-1) 

**Path 3: RevealSharedInValues** - Reconstructs InValues via secret sharing and sets them as PreviousInValue without validation: [3](#0-2) 

### Root Cause Analysis

The existing validation only checks the block producer's own PreviousInValue, not revealed InValues for other miners. The validation explicitly retrieves only the sender's public key: [4](#0-3) 

### Attack Mechanism

**Step 1**: During validation, `RecoverFromUpdateValue` unconditionally copies PreviousInValues from block header to validation context for ALL miners: [5](#0-4) 

**Step 2**: When the victim miner produces a block, `ApplyNormalConsensusData` checks if PreviousInValue is already set before updating it. If an attacker already set a fake PreviousInValue, this condition prevents the real value from being set: [6](#0-5) 

**Step 3**: The fake PreviousInValue gets persisted to state when PerformSecretSharing processes the UpdateValueInput: [7](#0-6) 

**Step 4**: The UpdateValue entry point directly calls ProcessConsensusInformation without validating the MinersPreviousInValues field: [8](#0-7) 

### Complete Attack Flow

1. **Round N**: Victim miner A mines successfully, committing OutValue_A = Hash(InValue_A)
2. **Round N+1, Time Slot 1**: Malicious miner B produces a block and includes `fake_InValue` for A in the `miners_previous_in_values` field of UpdateValueInput
3. `PerformSecretSharing` sets `round.RealTimeMinersInformation[A].PreviousInValue = fake_InValue` without validation
4. Round state is persisted with fake PreviousInValue for miner A
5. **Round N+1, Time Slot 2**: When miner A tries to produce a block:
   - Current round is loaded from state (contains fake PreviousInValue for A)
   - `ApplyNormalConsensusData` sees PreviousInValue is not empty, doesn't overwrite it
   - Block header contains fake PreviousInValue
   - Validation extracts A's PreviousInValue from block header (fake value)
   - Validation calculates Hash(fake_InValue) and compares to OutValue_A from Round N
   - Validation fails: Hash(fake_InValue) ≠ OutValue_A
   - **Miner A's block is rejected**

The UpdateValueInput structure defines the miners_previous_in_values field with no enforcement of cryptographic validation: [9](#0-8) 

## Impact Explanation

This vulnerability breaks a fundamental cryptographic invariant of the AEDPoS consensus mechanism:

### Consensus Integrity Compromise
The commit-reveal VRF scheme requires that revealed InValues hash to previously committed OutValues. By accepting unvalidated revealed InValues, the security model collapses. The signature calculation uses PreviousInValue to determine mining order for the next round: [10](#0-9) 

### Targeted Denial of Service
Any miner can prevent any other specific miner from producing valid blocks within the same round. The victim's blocks will be rejected by validation, causing:
- **Mining reward loss**: Victim cannot earn block rewards for that time slot
- **Network disruption**: Reduced block production capacity
- **Reputation damage**: Victim appears to have validation failures

### Mining Order Manipulation
Attackers can strategically block specific miners to influence mining order and timing, enabling MEV extraction opportunities and coordination with colluding miners.

**Severity: CRITICAL** - This is directly exploitable and breaks core consensus security guarantees.

## Likelihood Explanation

### Attacker Requirements
- Must be a valid miner in the current round (normal consensus participant)
- Ability to produce blocks in assigned time slot (standard miner capability)
- Ability to modify UpdateValueInput transaction parameters

### Attack Complexity: LOW
The attack requires minimal sophistication:
1. When producing a block, modify the `miners_previous_in_values` field in UpdateValueInput
2. Include arbitrary hash values for target miners
3. Produce block normally during assigned time slot
4. Fake values pass through without validation

### Preconditions
- Secret sharing must be enabled (standard operational configuration)
- Target miner must produce a block later in the same round
- These are normal operational conditions

### Detection Difficulty: HIGH
- Malicious revealed InValues are indistinguishable from legitimate ones on-chain
- No validation errors occur during the attacker's block acceptance
- Only when the victim attempts to mine does validation fail
- No audit trail links the failure to the attacker's previous block

**Likelihood: HIGH** - Immediately exploitable by any miner with standard capabilities.

## Recommendation

Add cryptographic validation for all revealed InValues, not just the block producer's own value. Specifically:

1. In `PerformSecretSharing`, validate each entry in `MinersPreviousInValues`:
```csharp
foreach (var previousInValue in input.MinersPreviousInValues)
{
    // Validate against previous round's OutValue
    if (previousRound != null && 
        previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
    {
        var expectedOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
        if (expectedOutValue != null && 
            HashHelper.ComputeFrom(previousInValue.Value) != expectedOutValue)
        {
            continue; // Skip invalid revealed InValues
        }
    }
    round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

2. Apply similar validation in `UpdateLatestSecretPieces` for `RevealedInValues`

3. In `RevealSharedInValues`, validate reconstructed InValues against committed OutValues before setting them

## Proof of Concept

The vulnerability can be demonstrated by creating a test where:
1. Miner A produces a block in time slot 1 with OutValue_A
2. Miner B produces a block in time slot 2 with fake PreviousInValue for A in UpdateValueInput.miners_previous_in_values
3. Miner A attempts to produce in time slot 3 and validation fails

The test would verify that Miner A's block is rejected due to Hash(fake_InValue) ≠ OutValue_A, despite A providing the correct InValue in their trigger information.

## Notes

This vulnerability affects the core consensus mechanism and can be exploited within a single round. The attack persists only within the same round since new rounds regenerate MinerInRound objects without copying PreviousInValue fields, as shown in: [11](#0-10) 

However, the attacker can repeat the attack in subsequent rounds to continuously block target miners. The validation framework correctly identifies this as a CRITICAL consensus integrity issue that breaks the fundamental commit-reveal cryptographic guarantee.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** protobuf/aedpos_contract.proto (L215-216)
```text
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
