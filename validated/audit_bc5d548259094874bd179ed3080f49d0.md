# Audit Report

## Title
TokenHolder Scheme Symbol Overwrite Causes Permanent Fund Lock

## Summary
The `CreateScheme` method in TokenHolderContract allows a scheme manager to overwrite an existing scheme without validation, enabling symbol changes that permanently lock user funds. When the scheme symbol is changed after users lock tokens, the `Withdraw` function queries locked balances using the new symbol instead of the original, returning zero and leaving tokens permanently inaccessible.

## Finding Description

The vulnerability exists because `CreateScheme` directly overwrites the stored scheme without checking if one already exists. [1](#0-0) 

When users lock tokens via `RegisterForProfits`, the tokens are locked using the current scheme's symbol: [2](#0-1) 

The critical issue is that the MultiToken contract computes the virtual address for locking WITHOUT including the symbol in the hash: [3](#0-2) 

During withdrawal, `GetLockedAmount` queries the balance at the virtual address for the CURRENT scheme symbol: [4](#0-3) [5](#0-4) 

**Attack Sequence:**
1. Manager creates scheme with Symbol = "ELF"
2. Users lock 1,000 ELF tokens via `RegisterForProfits`
3. Manager calls `CreateScheme` again with Symbol = "USDT" (overwrites scheme)
4. User calls `Withdraw`:
   - Retrieves scheme with Symbol = "USDT"
   - Queries locked amount for "USDT" at virtual address
   - Returns 0 (virtual address only contains "ELF" tokens)
   - Unlocks 0 tokens
5. Original 1,000 ELF tokens remain permanently locked

The scheme symbol must remain constant throughout the scheme's lifetime, but no validation enforces this invariant.

## Impact Explanation

This vulnerability results in **permanent, irreversible fund loss** for all users who registered before the scheme overwrite:

- **Direct Loss**: All locked tokens become permanently inaccessible
- **Scale**: Affects every beneficiary who called `RegisterForProfits` under the original scheme
- **Irreversibility**: The virtual address holding original tokens cannot be accessed because queries use the wrong symbol
- **Broken Invariant**: Violates the fundamental lock/unlock correctness guarantee - users cannot withdraw what they locked

**Severity: CRITICAL** - Results in permanent fund loss with no recovery mechanism.

## Likelihood Explanation

**Trigger Conditions:**
- Single call to `CreateScheme` by the scheme manager with a different symbol
- No special permissions required beyond being the scheme manager (any address can create schemes for itself)
- Low complexity - no multi-step attack or timing requirements

**Realistic Scenarios:**
1. **Operational Error**: Manager accidentally calls `CreateScheme` twice during initial setup, using different token symbols
2. **Contract Upgrade**: Management transition or scheme reinitialization attempts lead to unintended overwrite
3. **Malicious Manager**: Compromised or rogue manager intentionally locks user funds

**Detection Difficulty:**
- No events emitted on scheme overwrite
- Silent failure mode - withdrawals succeed but unlock zero tokens
- Users discover the issue only when attempting withdrawal

**Probability: MEDIUM-HIGH** - While scheme managers are typically project owners, the lack of validation creates substantial operational risk through human error, even without malicious intent.

## Recommendation

Add validation to prevent scheme overwrites in `CreateScheme`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Prevent overwriting existing schemes
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, add a separate `UpdateScheme` method that validates symbol immutability if scheme updates are required.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeSymbolOverwrite_CausesPermanentFundLock()
{
    // Setup: Manager creates scheme with ELF symbol
    var manager = Accounts[0].Address;
    var user = Accounts[1].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // User locks 1000 ELF tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 1000
    });
    
    // Verify tokens are locked
    var lockedAmount1 = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = ComputeLockId(manager, user)
    });
    lockedAmount1.Amount.ShouldBe(1000);
    
    // ATTACK: Manager overwrites scheme with USDT symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 100
    });
    
    // Fast forward past minimum lock time
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(101));
    
    // User attempts withdrawal - queries wrong symbol
    await TokenHolderContractStub.Withdraw.SendAsync(manager);
    
    // VULNERABILITY: Original ELF tokens remain locked
    var lockedAmountAfterWithdraw = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",  // Original symbol
        LockId = ComputeLockId(manager, user)
    });
    
    // Tokens are still locked - permanent loss!
    lockedAmountAfterWithdraw.Amount.ShouldBe(1000); 
    
    // User's balance did not increase
    var userBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user,
        Symbol = "ELF"
    });
    userBalance.Balance.ShouldBe(0); // Expected 1000, got 0
}

private Hash ComputeLockId(Address schemeManager, Address user)
{
    return HashHelper.ComputeFrom(
        TokenHolderContractAddress.Value
        .Concat(schemeManager.Value)
        .Concat(user.Value)
        .ToArray());
}
```

## Notes

This vulnerability demonstrates a critical design flaw where state mutation lacks validation against existing data. The immutability of the scheme symbol is an implicit invariant required for lock/unlock correctness, but this invariant is not enforced in code. The virtual address computation being symbol-agnostic creates a hidden coupling that breaks when the scheme symbol changes.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-165)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-225)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L109-115)
```csharp
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
