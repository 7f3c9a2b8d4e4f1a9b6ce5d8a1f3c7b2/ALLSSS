# Audit Report

## Title
Unbounded ProfitDetails Growth Causes Denial of Service in Profit Claiming

## Summary
The Profit contract allows unlimited `ProfitDetail` entries to accumulate per beneficiary without enforcing any size limits. When beneficiaries attempt to claim profits, the contract must iterate through all accumulated details using LINQ filtering, leading to gas exhaustion and permanent denial of service once the list grows to thousands of entries. This vulnerability affects both malicious scheme manager attacks and natural Election contract voting scenarios.

## Finding Description

The root cause lies in the `AddBeneficiary` method which unconditionally appends new `ProfitDetail` entries to a beneficiary's list without any size limit validation or deduplication: [1](#0-0) 

The `ProfitDetailsMap` state stores a repeated list structure per beneficiary: [2](#0-1) 

**Why Existing Protections Fail:**

1. **Insufficient Cleanup Logic**: The cleanup mechanism only removes details that meet extremely strict conditions - they must be fully claimed AND expired AND beyond the receiving period: [3](#0-2) 

2. **Processing Limit Doesn't Prevent Iteration**: The `ProfitReceivingLimitForEachTime` constant limits processing to 10 details per claim, but this occurs AFTER the expensive LINQ filtering operation: [4](#0-3) 

3. **Full List Iteration Required**: The `ClaimProfits` method must iterate through ALL accumulated details to filter available ones: [5](#0-4) 

**Attack Vector 1 - Malicious Scheme Manager:**

Any user can create their own profit scheme and become its manager. The manager can then repeatedly call `AddBeneficiary` with the same beneficiary but different `ProfitDetailId` values, as authorization only checks manager status: [6](#0-5) 

**Attack Vector 2 - Election Contract Natural Accumulation:**

The Election contract creates a new profit detail for each vote with a unique `voteId` as the `ProfitDetailId`: [7](#0-6) 

When votes are withdrawn, the removal does NOT specify a `ProfitDetailId`, causing only expired details to be removed: [8](#0-7) 

This is because the WelfareHash scheme (used for Election voters) has `CanRemoveBeneficiaryDirectly` set to false, meaning only expired details are removed during withdrawal: [9](#0-8) [10](#0-9) 

The `RemoveProfitDetails` method confirms this conditional cleanup behavior: [11](#0-10) 

## Impact Explanation

**Operational DoS Impact:**

When a beneficiary with thousands of accumulated `ProfitDetail` entries attempts to claim profits, the LINQ `Where` clause on line 765 of `ClaimProfits` must iterate through the entire list to filter available details. With 10,000 entries, this gas-intensive operation will exceed block gas limits, causing the transaction to fail and making profit claims permanently impossible.

**Who is Affected:**
- Election contract users who vote frequently (100+ times) will naturally accumulate hundreds of profit details and eventually face claim DoS
- Any beneficiary targeted by a malicious scheme manager will be unable to claim profits from that scheme  
- System-wide welfare distribution can be disrupted, affecting the core reward mechanism

**Severity Assessment: HIGH**
- **Permanent Denial of Service**: Once gas limits are exceeded, there is no recovery mechanism
- **Funds Locked**: Profits remain permanently unclaimed in the contract with no alternative withdrawal path
- **Protocol Core Functionality**: Affects the fundamental reward distribution system across Election, TokenHolder, and Treasury contracts

## Likelihood Explanation

**Likelihood Assessment: HIGH**

**Attacker Capabilities:**
- Any user can create their own profit scheme via the public `CreateScheme` method and become its manager
- Scheme managers have full authority to call `AddBeneficiary` repeatedly with different `ProfitDetailId` values
- No economic barrier exists beyond standard transaction fees

**Attack Complexity: LOW**
- Single transaction batch calling `AddBeneficiary` 10,000 times with incrementing `ProfitDetailId` values
- No special permissions required beyond creating a scheme (available to all users)
- Can target any address preemptively before they attempt to claim

**Natural Occurrence: HIGH**  
- The Election contract naturally creates this scenario through normal user voting behavior
- Users who vote 100+ times over several months will accumulate 100+ permanent profit details
- Details persist indefinitely until `EndPeriod + ProfitReceivingDuePeriodCount` is reached AND they have been fully claimed (10+ periods beyond expiration)

**Detection Constraints:**
- Attack is undetectable until the victim attempts to claim profits
- No monitoring mechanisms exist to alert users of growing detail lists
- Gas costs for attackers are minimal compared to the permanent impact on victims

## Recommendation

Implement multiple protective measures:

1. **Enforce Maximum Details Per Beneficiary**: Add a constant limit (e.g., 100) and reject `AddBeneficiary` calls that would exceed this threshold

2. **Aggregate Details by Period**: Instead of creating separate details for each vote/addition, aggregate shares within the same period range to reduce list growth

3. **Paginated Claiming**: Implement a cursor-based pagination system for `ClaimProfits` that processes a fixed subset of details per transaction, allowing users to claim across multiple transactions

4. **Automatic Cleanup Enhancement**: Relax cleanup conditions to remove claimed details immediately rather than waiting for expiration + receiving period

5. **Emergency Recovery Method**: Add a privileged method allowing Parliament to force-clear details for affected beneficiaries while preserving their claimable amounts

Example fix for maximum limit enforcement:

```csharp
public override Empty AddBeneficiary(AddBeneficiaryInput input)
{
    AssertValidInput(input);
    // ... existing code ...
    
    var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
    if (currentProfitDetails != null)
    {
        Assert(currentProfitDetails.Details.Count < ProfitContractConstants.MaxProfitDetailsPerBeneficiary,
            "Maximum profit details limit reached for beneficiary.");
    }
    
    // ... continue with existing logic ...
}
```

## Proof of Concept

```csharp
// Test demonstrating DoS via unbounded ProfitDetail accumulation
[Fact]
public async Task Test_ProfitDetails_DoS_Attack()
{
    // Setup: Create a profit scheme
    var schemeId = await CreateTestScheme();
    var victimAddress = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey);
    
    // Attack: Add 1000 profit details with different IDs for the same beneficiary
    for (int i = 0; i < 1000; i++)
    {
        await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
        {
            SchemeId = schemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = victimAddress,
                Shares = 100
            },
            EndPeriod = long.MaxValue,
            ProfitDetailId = HashHelper.ComputeFrom(i) // Unique ID for each
        });
    }
    
    // Distribute some profits
    await DistributeProfitsToScheme(schemeId, 100000);
    
    // Victim attempts to claim - this should fail or consume excessive gas
    var claimResult = await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = victimAddress
    });
    
    // Assertion: Transaction should fail due to gas exhaustion with large detail count
    // In production, 10,000+ details would cause permanent DoS
    Assert.True(claimResult.TransactionResult.Status == TransactionResultStatus.Failed 
        || claimResult.TransactionResult.TransactionFee > ExpectedNormalTransactionFee * 100);
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-201)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-767)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L13-13)
```csharp
    public MappedState<Hash, Address, ProfitDetails> ProfitDetailsMap { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L304-310)
```csharp
    private void RemoveBeneficiaryOfVoter(Address voterAddress = null)
    {
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            Beneficiary = voterAddress ?? Context.Sender
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L92-93)
```csharp
        State.SubsidyHash.Value = managingSchemeIds[2];
        State.WelfareHash.Value = managingSchemeIds[3];
```
