# Audit Report

## Title
Missing Cryptographic Verification of DecryptedPieces in Secret Sharing Mechanism

## Summary
The AEDPoS consensus contract's secret sharing mechanism accepts DecryptedPieces from miners without cryptographic verification, allowing a single malicious miner to permanently corrupt InValues stored on-chain. The reconstructed InValues are used in consensus signature calculations without validating that `Hash(revealedInValue) == previousOutValue`, compromising consensus integrity and violating Byzantine fault tolerance guarantees.

## Finding Description

The vulnerability exists in the secret sharing mechanism that recovers miners' InValues when they fail to self-report. The protocol flow involves two critical unprotected stages:

**Stage 1: Accepting Unverified DecryptedPieces**

When miners submit UpdateValueInput, the `PerformSecretSharing` function stores DecryptedPieces directly into other miners' records without any cryptographic verification. [1](#0-0) 

A malicious miner can submit arbitrary bytes as `DecryptedPieces[VictimPubkey]`, and these corrupt bytes are stored without validation that they are legitimate decryptions of the victim's EncryptedPieces.

**Stage 2: Reconstructing Without Validation**

During NextRound transitions, `RevealSharedInValues` is called to reconstruct InValues. [2](#0-1) 

The function reads DecryptedPieces, passes them to `SecretSharingHelper.DecodeSecret()`, and stores the reconstructed InValue directly as PreviousInValue. [3](#0-2) 

Critically, there is **no validation** that `Hash(revealedInValue) == previousOutValue`.

**Why Existing Protections Fail**

The contract does validate self-reported PreviousInValue values through `UpdateValueValidationProvider`. [4](#0-3) 

However, this validation only applies when miners directly report their InValue in UpdateValueInput. For InValues revealed through secret sharing reconstruction, no such validation exists.

**Attack Execution Path:**

1. Round N: Honest Miner A produces block, publishes `OutValue_A = Hash(InValue_A)` and `EncryptedPieces`
2. Round N+1: Malicious Miner B submits `UpdateValueInput` with `DecryptedPieces[A] = arbitrary_garbage` via the public `UpdateValue` method [5](#0-4) 
3. `PerformSecretSharing` stores the garbage bytes without verification [6](#0-5) 
4. NextRound transition occurs
5. Shamir's Secret Sharing reconstruction produces corrupted InValue from garbage bytes
6. Corrupted InValue stored as Miner A's PreviousInValue
7. `SupplyCurrentRoundInformation` retrieves the corrupted PreviousInValue [7](#0-6) 
8. Corrupted signature calculated using the corrupted value [8](#0-7) 
9. Corrupted InValue and signature permanently stored for subsequent rounds

## Impact Explanation

**Consensus State Corruption:**
The corrupted InValues become permanent on-chain state. When miners who didn't produce blocks need their InValue filled, `SupplyCurrentRoundInformation` uses the corrupted PreviousInValue, perpetuating the corruption indefinitely.

**Signature Chain Corruption:**
Consensus signatures are calculated by XORing InValues with accumulated signatures. [9](#0-8) 

Corrupted InValues produce incorrect signatures, breaking the cryptographic chain that ensures consensus integrity and randomness quality.

**Byzantine Fault Tolerance Breach:**
The secret sharing mechanism is designed to provide 2/3 Byzantine fault tolerance. [10](#0-9) 

However, this vulnerability allows a **single malicious miner** to corrupt InValue revelation without meeting the Byzantine threshold. The minimum count requirement provides no protection since the malicious DecryptedPiece is counted as valid input to the reconstruction algorithm. [11](#0-10) 

This represents a critical severity issue as it undermines the fundamental security guarantees of the consensus mechanism, affecting all network participants and the integrity of the blockchain's consensus layer.

## Likelihood Explanation

**Attacker Capabilities:**
Any miner in the active consensus pool can execute this attack. The authorization check only verifies the caller is in the current or previous round's miner list. [12](#0-11) 

**Attack Complexity: LOW**
The attack requires no sophisticated techniques:
1. Call the public `UpdateValue` method with manipulated DecryptedPieces
2. No timing constraints, race conditions, or multi-step setup required
3. Attack succeeds deterministically

**Feasibility: HIGH**  
The entry point `UpdateValue` processes the `UpdateValueInput` through standard consensus flow. No special permissions beyond standard miner authorization are required. Shamir's Secret Sharing reconstruction always produces output even from invalid inputsâ€”it has no internal validation mechanism to detect corrupt pieces.

**Detection: IMPOSSIBLE**
The contract has no validation to detect corrupt DecryptedPieces. All nodes process the corrupted data identically through deterministic state transitions, making the attack undetectable at the protocol level.

**Economic Rationality:**
- Attack cost: Transaction fee only (negligible)
- Impact: High (consensus integrity compromise)  
- Risk of detection: Zero (no validation mechanism exists)
- Potential benefit: Disrupting consensus, manipulating randomness, targeting specific miners

## Recommendation

Add cryptographic verification in `RevealSharedInValues` to validate that the reconstructed InValue matches the previously stored OutValue:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate that Hash(revealedInValue) matches the stored OutValue
var expectedOutValue = anotherMinerInPreviousRound.OutValue;
if (expectedOutValue != null && HashHelper.ComputeFrom(revealedInValue) != expectedOutValue)
{
    Context.LogDebug(() => $"Invalid secret sharing reconstruction for {publicKeyOfAnotherMiner}");
    continue; // Skip this miner if validation fails
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures that only cryptographically valid InValue reconstructions are accepted, maintaining the same security guarantee as the self-reported path.

## Proof of Concept

Due to the complexity of setting up a full consensus environment with multiple miners, a complete executable test would require extensive infrastructure. However, the vulnerability can be demonstrated by tracing the code path:

1. A malicious miner calls `UpdateValue` with arbitrary `DecryptedPieces` data
2. The data is stored without validation in `PerformSecretSharing`
3. During `NextRound`, `RevealSharedInValues` reconstructs using the corrupt data
4. No validation occurs before storing the result as `PreviousInValue`
5. The corrupted value is used in subsequent signature calculations

The absence of validation at the reconstruction step is the root cause, allowing any miner to inject invalid data that corrupts the consensus state permanently.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L256-256)
```csharp
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-191)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L199-199)
```csharp
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
