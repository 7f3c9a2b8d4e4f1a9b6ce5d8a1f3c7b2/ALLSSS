# Audit Report

## Title
Side Chain Disposal Returns Funds to Proposer Without Paying Indexer Debt

## Summary
The `DisposeSideChain()` method fails to settle outstanding indexing fee arrears before returning deposited tokens to the side chain proposer. When a side chain is disposed while having debt recorded in `ArrearsInfo`, indexers who provided services lose their earned fees while the proposer improperly recovers funds that should have been used to pay creditors.

## Finding Description

The vulnerability exists in the side chain disposal flow where debt settlement is completely bypassed.

**Primary Vulnerability - Missing Debt Settlement:**

When `DisposeSideChain()` is called, it performs authority validation and status checks, then immediately calls `UnlockTokenAndResource()` without any debt verification. [1](#0-0) 

The `UnlockTokenAndResource()` function retrieves the full deposit balance and transfers it entirely to the proposer, with zero checks for the `ArrearsInfo` field that tracks debt owed to indexers. [2](#0-1) 

**Debt Accumulation Mechanism:**

During indexing operations, when the deposit balance becomes insufficient to pay indexing fees, the contract continues to allow indexing but records unpaid amounts in `ArrearsInfo` (a map of creditor addresses to owed amounts) and changes the chain status to `IndexingFeeDebt`. [3](#0-2) 

The `ArrearsInfo` field is defined in the `SideChainInfo` protobuf message as a map tracking creditors and their owed amounts. [4](#0-3) 

**Correct Pattern Exists in Recharge():**

The `Recharge()` method demonstrates the correct approach: it explicitly checks for `IndexingFeeDebt` status, iterates through `ArrearsInfo` to pay all creditors first, clears the debt map, and only then resumes normal operations. [5](#0-4) 

This proves the development team was aware of the debt mechanism but failed to apply the same settlement logic to the disposal flow.

**Misleading Balance Information:**

The `GetSideChainBalance()` view function returns only the gross deposit amount without subtracting debt. [6](#0-5) 

While `GetSideChainIndexingFeeDebt()` separately returns the total arrears, governance making disposal decisions may not realize they need to check both functions to understand the true financial position. [7](#0-6) 

## Impact Explanation

**Direct Financial Loss:**
- Indexers who performed cross-chain block indexing services during periods of insufficient deposit receive no payment for their work
- This represents direct theft of earned fees from legitimate service providers
- The proposer recovers deposited funds that should have been allocated to pay outstanding debt

**Economic Impact Magnitude:**
- Amount at risk: minimum of (remaining deposit balance, total arrears owed)
- In scenarios where partial recharge occurred but disposal happens before full settlement, indexers lose the entire arrears amount
- Creates perverse incentive where proposers can accumulate debt and dispose chains to recover deposits

**Protocol Integrity:**
- Violates the fundamental economic guarantee that indexing services will be compensated
- Undermines trust in the cross-chain indexing incentive mechanism
- Severity: **HIGH** - Direct misallocation of funds from creditors to debtor

## Likelihood Explanation

**Trigger Mechanism:**
`DisposeSideChain()` is publicly accessible via governance (SideChainLifetimeController, typically Parliament organization), making it a routine operational function.

**Preconditions (All Realistic):**
1. Side chain accumulates indexing fee debt through normal operation (indexing beyond available deposit)
2. Chain retains some balance (from partial recharge, initial deposit remainder, or direct transfers)
3. Governance approves disposal proposal (standard chain lifecycle management)

**Exploitation Scenarios:**

*Accidental (Most Likely):* During routine chain lifecycle management, governance may approve disposal of inactive or problematic side chains without realizing unpaid debt exists. Since `GetSideChainBalance()` shows gross balance and debt checking requires a separate query, the issue may go unnoticed.

*Intentional:* A malicious proposer could create a side chain with minimal deposit, allow indexing to accumulate substantial debt, partially recharge to maintain some balance, then lobby for disposal to recover funds while leaving indexers unpaid.

**Attack Complexity:**
- Low - The vulnerability triggers automatically in the disposal logic
- Requires only standard governance approval, no sophisticated techniques
- No need to bypass security controls, as the controls are simply absent

**Detection Difficulty:**
- High - `ArrearsInfo` data exists in contract state but is not validated during disposal
- Governance would need to manually query `GetSideChainIndexingFeeDebt()` before each disposal decision
- No on-chain warnings or validation alerts governance to the debt situation

**Likelihood Assessment:** MEDIUM-HIGH - While requiring governance approval (reducing purely malicious likelihood), the lack of on-chain validation and the misleading nature of the balance view function make accidental occurrences highly probable during routine operations.

## Recommendation

Implement debt settlement in the disposal flow, mirroring the logic already present in `Recharge()`:

```csharp
private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
{
    var chainId = sideChainInfo.SideChainId;
    var balance = GetSideChainIndexingFeeDeposit(chainId);
    if (balance <= 0)
        return;
    
    // Pay arrears first if any exist
    long paidArrears = 0;
    foreach (var arrears in sideChainInfo.ArrearsInfo)
    {
        paidArrears += arrears.Value;
        TransferDepositToken(new TransferInput
        {
            To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = arrears.Value,
            Memo = "Indexing fee arrears payment on disposal."
        }, chainId);
    }
    
    // Transfer remaining balance (if any) to proposer
    var remainingBalance = balance - paidArrears;
    if (remainingBalance > 0)
    {
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = remainingBalance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
}
```

Additionally, consider modifying `GetSideChainBalance()` to return net balance (deposit minus debt) or add a dedicated `GetSideChainNetBalance()` view function to help governance make informed disposal decisions.

## Proof of Concept

```csharp
[Fact]
public async Task DisposeSideChain_WithArrears_ShouldPayIndexersFirst()
{
    // Setup: Create side chain with initial deposit
    var parentChainId = 123;
    long initialDeposit = 10;
    long indexingPrice = 3;
    var sideChainId = await InitAndCreateSideChainAsync(10, parentChainId, initialDeposit, indexingPrice);
    
    // Step 1: Index blocks until balance is exhausted and debt accumulates
    var blockData1 = CreateSideChainBlockData(HashHelper.ComputeFrom("hash1"), 1, sideChainId, HashHelper.ComputeFrom("root1"));
    var blockData2 = CreateSideChainBlockData(HashHelper.ComputeFrom("hash2"), 2, sideChainId, HashHelper.ComputeFrom("root2"));
    var blockData3 = CreateSideChainBlockData(HashHelper.ComputeFrom("hash3"), 3, sideChainId, HashHelper.ComputeFrom("root3"));
    var blockData4 = CreateSideChainBlockData(HashHelper.ComputeFrom("hash4"), 4, sideChainId, HashHelper.ComputeFrom("root4"));
    
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { blockData1, blockData2, blockData3, blockData4 } }, new[] { sideChainId });
    
    // Verify chain is in debt: 4 blocks * 3 fee = 12 cost, but only 10 deposited
    var status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(2); // 12 - 10 = 2 in arrears
    
    // Step 2: Partial recharge to add some balance back
    await ApproveBalanceAsync(5);
    await CrossChainContractStub.Recharge.SendAsync(new RechargeInput { ChainId = sideChainId, Amount = 5 });
    
    // After recharge: 5 added, 2 paid to indexers as arrears, 3 remains, status back to Active
    var balanceAfterRecharge = await GetSideChainBalanceAsync(sideChainId);
    balanceAfterRecharge.ShouldBe(3);
    
    var statusAfterRecharge = await GetSideChainStatusAsync(sideChainId);
    statusAfterRecharge.ShouldBe(SideChainStatus.Active);
    
    // Step 3: Create more debt
    var blockData5 = CreateSideChainBlockData(HashHelper.ComputeFrom("hash5"), 5, sideChainId, HashHelper.ComputeFrom("root5"));
    var blockData6 = CreateSideChainBlockData(HashHelper.ComputeFrom("hash6"), 6, sideChainId, HashHelper.ComputeFrom("root6"));
    
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { blockData5, blockData6 } }, new[] { sideChainId });
    
    // Now: 3 - 6 = -3, so 3 in new arrears
    var statusWithDebt = await GetSideChainStatusAsync(sideChainId);
    statusWithDebt.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var currentDebt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(new Int32Value { Value = sideChainId });
    currentDebt.Value.ShouldBe(3);
    
    var currentBalance = await GetSideChainBalanceAsync(sideChainId);
    currentBalance.ShouldBe(0);
    
    // Step 4: Add balance WITHOUT going through Recharge (e.g., direct transfer to virtual address)
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(sideChainId)),
        Amount = 5,
        Symbol = "ELF"
    });
    
    var balanceBeforeDisposal = await GetSideChainBalanceAsync(sideChainId);
    balanceBeforeDisposal.ShouldBe(5);
    
    var debtBeforeDisposal = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(new Int32Value { Value = sideChainId });
    debtBeforeDisposal.Value.ShouldBe(3); // Still owed to indexers
    
    // Record indexer balance before disposal
    var indexerBalanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput { Owner = DefaultSender, Symbol = "ELF" });
    
    // Record proposer balance before disposal
    var proposerBalanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput { Owner = AnotherSender, Symbol = "ELF" });
    
    // Step 5: Dispose the side chain through governance
    var disposalProposalId = await DisposeSideChainProposalAsync(new Int32Value { Value = sideChainId });
    await ApproveWithMinersAsync(disposalProposalId);
    await ReleaseProposalAsync(disposalProposalId);
    
    // Step 6: VULNERABILITY VERIFICATION
    // Expected: Indexers should receive 3 tokens (the debt), proposer should receive 2 tokens (5 - 3)
    // Actual: Proposer receives all 5 tokens, indexers receive nothing
    
    var indexerBalanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput { Owner = DefaultSender, Symbol = "ELF" });
    var proposerBalanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput { Owner = AnotherSender, Symbol = "ELF" });
    
    var indexerGain = indexerBalanceAfter.Balance - indexerBalanceBefore.Balance;
    var proposerGain = proposerBalanceAfter.Balance - proposerBalanceBefore.Balance;
    
    // VULNERABILITY PROOF: Indexer gains nothing despite being owed 3 tokens
    indexerGain.ShouldBe(0); // Should be 3, but is 0 due to bug
    
    // VULNERABILITY PROOF: Proposer gains entire balance including debt-encumbered funds
    proposerGain.ShouldBe(5); // Should be 2, but is 5 due to bug
    
    // The 3 tokens owed to indexers are lost - this is direct fund theft from service providers
}
```

## Notes

This vulnerability represents a fundamental breach of economic integrity in the cross-chain indexing system. The existence of correct debt settlement logic in `Recharge()` proves the development team understood the debt mechanism, making this omission in the disposal flow particularly concerning. The issue is exacerbated by the misleading nature of `GetSideChainBalance()` which returns gross rather than net balance, potentially causing governance to unknowingly approve disposals that harm indexers.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L191-214)
```csharp
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L222-242)
```csharp
    public override Int32Value DisposeSideChain(Int32Value input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var chainId = input.Value;
        var info = State.SideChainInfo[chainId];
        Assert(info != null, "Side chain not found.");
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");

        if (TryGetIndexingProposal(chainId, out _))
            ResetChainIndexingProposal(chainId);

        UnlockTokenAndResource(info);
        info.SideChainStatus = SideChainStatus.Terminated;
        State.SideChainInfo[chainId] = info;
        Context.Fire(new Disposed
        {
            ChainId = chainId
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L73-86)
```csharp
    private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
    {
        // unlock token
        var chainId = sideChainInfo.SideChainId;
        var balance = GetSideChainIndexingFeeDeposit(chainId);
        if (balance <= 0)
            return;
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = balance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L846-876)
```csharp
                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }
```

**File:** protobuf/cross_chain_contract.proto (L216-217)
```text
    // creditor and amounts for the chain indexing fee debt 
    map<string, int64> arrears_info = 8;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L81-87)
```csharp
    public override Int64Value GetSideChainBalance(Int32Value input)
    {
        var chainId = input.Value;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null, "Side chain not found.");
        return new Int64Value { Value = GetSideChainIndexingFeeDeposit(chainId) };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L89-99)
```csharp
    public override Int64Value GetSideChainIndexingFeeDebt(Int32Value input)
    {
        var chainId = input.Value;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null, "Side chain not found.");

        return new Int64Value
        {
            Value = sideChainInfo.ArrearsInfo.Values.Sum()
        };
    }
```
