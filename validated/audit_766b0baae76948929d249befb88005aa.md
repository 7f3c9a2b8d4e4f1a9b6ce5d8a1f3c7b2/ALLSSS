# Audit Report

## Title
Fee-Free CrossChainReceiveToken Enables Computational DoS via Unbounded Merkle Proof Verification

## Summary
The `CrossChainReceiveToken` method is configured as completely fee-free and performs expensive merkle path verification with no depth limits. An attacker can submit transactions containing massive merkle paths (up to ~130,000-155,000 nodes within the 5MB transaction limit) that force all validators to perform extensive SHA256 hash computations without paying any fees, enabling asymmetric computational resource exhaustion attacks.

## Finding Description

The vulnerability exists in the interaction between the fee-free configuration and the unbounded merkle path verification in the cross-chain token receiving mechanism.

**Fee-Free Configuration:** The `CrossChainReceiveToken` method is explicitly marked as fee-free, with `IsSizeFeeFree = true` and no base fees configured, meaning the size fee charging logic is completely bypassed. [1](#0-0) 

**No Authorization Checks:** This public method can be called by any address without authorization restrictions. [2](#0-1) 

**Execution Flow with Expensive Verification:** The method performs preliminary checks (transaction parsing, double-claim check, token validation, registered contract check) before invoking `CrossChainVerify` at line 617, which triggers the expensive merkle proof computation. [2](#0-1) 

**Cross-Chain Verification Call:** The helper method constructs verification input and calls the CrossChain contract's `VerifyTransaction` method. [3](#0-2) 

**Merkle Root Computation:** The verification retrieves the stored merkle tree root and computes the root from the provided merkle path. [4](#0-3) 

**Expensive Hash Operations:** The computation concatenates transaction ID with status bytes, then uses the merkle path extension to compute the root. [5](#0-4) 

**Per-Node Hash Computation:** The extension method performs one SHA256 hash operation per merkle path node using `Aggregate`, with each iteration calling `HashHelper.ConcatAndCompute`. [6](#0-5) 

**Unbounded Merkle Path:** The `MerklePath` protobuf definition uses a `repeated` field with no explicit depth or size limit. [7](#0-6) 

**Transaction Size Limit:** The transaction pool enforces a 5MB transaction size limit, which allows for approximately 130,000-155,000 merkle path nodes. [8](#0-7) 

**Size Fee Bypass:** When `IsSizeFeeFree` is true, the size fee charging logic is completely skipped, allowing large transactions without any size-based fees. [9](#0-8) 

**Attack Vector:** An attacker crafts a `CrossChainReceiveTokenInput` containing a fake but structurally valid transaction, a registered token contract address, a valid indexed parent chain height (obtainable from public view methods), and a massive merkle path. The transaction passes preliminary checks but fails at merkle verificationâ€”however, all validators have already performed the expensive hash computations for the entire merkle path before the verification failure.

**Why Protections Fail:**
- The double-claim check only prevents reusing the same transaction ID, not fabricated IDs
- The registered contract check is satisfied for any chain with cross-chain operations
- Execution observers track contract-level calls/branches, but the merkle path iteration happens within library code (LINQ `Aggregate`) and doesn't increment these counters
- Resource fees are charged post-execution, after the expensive computation has already occurred

## Impact Explanation

**Computational Resource Exhaustion:** Each malicious transaction forces all network validators to perform ~130,000-155,000 SHA256 hash operations on concatenated 64-byte inputs, consuming significant CPU resources.

**Asymmetric Attack Economics:** The attacker pays zero transaction fees (method is completely fee-free), while all validators must perform expensive computations. This creates an extremely asymmetric cost structure favoring the attacker.

**Network Performance Degradation:** Validators processing these transactions experience increased block processing time, degraded performance for legitimate transactions, and potential delays in block production if execution time limits are approached.

**Sustained Attack Capability:** The attack can be repeated indefinitely with different fake transaction IDs, creating continuous resource exhaustion.

**Protocol Invariant Violation:** This breaks the fundamental blockchain economic security principle that computational cost must be reflected in transaction fees, undermining the fee mechanism's purpose.

**Severity Assessment:** HIGH - The vulnerability enables asymmetric resource exhaustion with zero cost to attackers, requires no special permissions, violates core fee mechanism invariants, and can impact the operational capacity of all network validators simultaneously.

## Likelihood Explanation

**Entry Point Accessibility:** The method is public with no authorization checks, callable by any address on the network.

**Trivial Prerequisites:** All attack prerequisites are easily satisfied:
- Valid indexed heights are obtainable through public view methods (`GetParentChainHeight`, `GetSideChainHeight`)
- Chain IDs with registered token contracts exist for any chain performing cross-chain operations
- Unique fake transaction IDs are trivially generated
- Large merkle path construction is straightforward array creation

**Execution Simplicity:** The attack is deterministic and fully automatable with no timing dependencies, race conditions, or competitive processes. Transactions are accepted by the transaction pool and included in blocks. The attack succeeds at forcing computation even when transactions ultimately fail validation.

**Economic Rationality:** From the attacker's perspective, the attack is economically rational: zero cost per transaction, forces expensive validator computation, and can be repeated without limits.

**Detection Difficulty:** Malicious transactions appear legitimate until merkle verification fails, making them difficult to filter proactively without performing the expensive verification itself.

**Likelihood Assessment:** HIGH - The attack is highly practical, easily executable, economically advantageous for attackers, and difficult to prevent without protocol changes.

## Recommendation

Implement multiple defensive layers:

1. **Add Merkle Path Depth Limit:** Enforce a maximum depth limit on `MerklePath` in the verification logic (e.g., maximum 20-30 nodes, which is sufficient for legitimate use cases).

2. **Charge Proportional Fees:** Remove the `IsSizeFeeFree` exemption for `CrossChainReceiveToken` or implement a fee structure that charges proportionally to merkle path size/complexity.

3. **Early Validation:** Move cheap validation checks (like merkle path size limits) before expensive cryptographic operations.

4. **Rate Limiting:** Implement per-address rate limiting for cross-chain receive operations to prevent sustained attacks from single sources.

Example fix for depth limit in verification:
```csharp
// In CrossChainVerify or VerifyTransaction
const int MaxMerklePathDepth = 30;
Assert(input.Path.MerklePathNodes.Count <= MaxMerklePathDepth, 
    $"Merkle path depth {input.Path.MerklePathNodes.Count} exceeds maximum {MaxMerklePathDepth}");
```

## Proof of Concept

A proof of concept would demonstrate creating a transaction with a massive merkle path and showing that all validators must process it despite paying no fees. The test would:

1. Create a `CrossChainReceiveTokenInput` with a valid-looking but fake transaction
2. Populate the merkle path with 100,000+ nodes
3. Call `CrossChainReceiveToken` and verify the transaction is processed
4. Measure the computational cost (time/CPU) required
5. Confirm zero fees were charged
6. Show the transaction ultimately fails verification but only after computation

Due to the complexity of setting up a full test environment with cross-chain infrastructure, the validation relies on code analysis confirming the execution path leads to unbounded merkle path processing with no fee charging mechanism.

---

## Notes

This vulnerability is valid because it demonstrates a clear protocol-level security issue where:
- Computational resources can be exhausted asymmetrically (zero attacker cost, high validator cost)
- The fee mechanism fails to protect against this specific attack vector
- The attack is practical, executable, and repeatable
- No existing protections prevent the exploitation

The core issue is the combination of fee-free configuration with unbounded merkle path processing, creating an exploitable asymmetry in the economic security model.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L34-40)
```csharp
    private Hash ComputeRootWithTransactionStatusMerklePath(Hash txId, MerklePath path)
    {
        var txResultStatusRawBytes =
            EncodingHelper.EncodeUtf8(TransactionResultStatus.Mined.ToString());
        var hash = HashHelper.ComputeFrom(ByteArrayHelper.ConcatArrays(txId.ToByteArray(), txResultStatusRawBytes));
        return path.ComputeRootWithLeafNode(hash);
    }
```

**File:** src/AElf.Types/Extensions/MerklePathExtensions.cs (L9-14)
```csharp
        public static Hash ComputeRootWithLeafNode(this MerklePath path, Hash leaf)
        {
            return path.MerklePathNodes.Aggregate(leaf, (current, node) => node.IsLeftChildNode
                ? HashHelper.ConcatAndCompute(node.Hash, current)
                : HashHelper.ConcatAndCompute(current, node.Hash));
        }
```

**File:** protobuf/aelf/core.proto (L155-165)
```text
message MerklePath {
    // The merkle path nodes.
    repeated MerklePathNode merkle_path_nodes = 1;
}

message MerklePathNode{
    // The node hash.
    Hash hash = 1;
    // Whether it is a left child node.
    bool is_left_child_node = 2;
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L1-6)
```csharp
namespace AElf.Kernel.TransactionPool;

public class TransactionPoolConsts
{
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L285-300)
```csharp
        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
    }
```
