# Audit Report

## Title
Coordinated LIB Denial-of-Service via Zero ImpliedIrreversibleBlockHeight Bypass

## Summary
The `LibInformationValidationProvider` contains a validation bypass that allows miners to submit zero `ImpliedIrreversibleBlockHeight` values, circumventing regression checks. When more than one-third of miners exploit this flaw, the Last Irreversible Block (LIB) calculation permanently fails, halting consensus finality and blocking all cross-chain operations.

## Finding Description

The vulnerability exists in the validation logic that checks whether a miner's reported irreversible block height has regressed. [1](#0-0) 

The conditional check was designed to allow new miners (who legitimately have zero initial values) to pass validation without regression checks. However, this creates an exploitable bypass: existing miners can intentionally submit zero values to avoid validation entirely.

During normal block production, the system sets a miner's `ImpliedIrreversibleBlockHeight` to the current block height, which should never be zero after genesis: [2](#0-1) 

When a miner submits an `UpdateValue` transaction, the provided `ImpliedIrreversibleBlockHeight` is stored directly in the round state: [3](#0-2) 

The attack propagates through the LIB calculation. When computing the LIB, the system explicitly filters out zero values: [4](#0-3) 

The LIB calculation requires a minimum threshold defined as `MinersCountOfConsent` (two-thirds plus one): [5](#0-4) 

If insufficient valid heights remain after filtering zeros, the calculation returns zero, indicating LIB progression has failed: [6](#0-5) 

The `UpdateValue` method is publicly accessible with miner permission checks: [7](#0-6) 

Pre-execution validation applies `LibInformationValidationProvider` for `UpdateValue` behavior: [8](#0-7) 

## Impact Explanation

**Consensus Finality Breakdown:**
The LIB mechanism is fundamental to AElf's consensus safety. When LIB stops advancing (returns zero), no blocks become irreversible, eliminating finality guarantees. This breaks the core invariant that LIB should monotonically increase or remain constant, never regressing to zero after having advanced.

**Cross-Chain Operations Blocked:**
Cross-chain indexing critically depends on irreversible block heights. The `IrreversibleBlockStateProvider` validates LIB existence before allowing cross-chain operations: [9](#0-8) 

When LIB fails to advance beyond genesis height, cross-chain data retrieval is blocked: [10](#0-9) 

**Quantified Attack Threshold:**
For a network with 21 miners:
- `MinersCountOfConsent = 21 ร 2 รท 3 + 1 = 15`
- Attack requires 8 colluding miners (>1/3 Byzantine threshold)
- This leaves 13 valid heights, below the required 15
- LIB calculation returns 0, permanently halting finality

**Severity:** Critical - violates fundamental consensus safety properties with protocol-wide operational impact.

## Likelihood Explanation

**Attacker Capabilities:**
The attack requires coordination among slightly more than one-third of active miners (8 out of 21). While this exceeds the Byzantine fault tolerance threshold, the validation bypass makes execution trivial - miners simply submit zero values instead of maintaining non-decreasing heights.

**Attack Complexity:**
Execution is trivial. A malicious miner constructs an `UpdateValueInput` with `ImpliedIrreversibleBlockHeight = 0` and submits it during their assigned time slot. Without the bypass, even Byzantine miners would be constrained to maintain non-decreasing values. The bypass eliminates this protection, making the attack significantly easier.

**Feasibility Conditions:**
While the standard Byzantine adversary model assumes up to one-third of participants may act maliciously, BFT systems are designed to maintain liveness with <1/3 Byzantine actors. The vulnerability allows miners at exactly the Byzantine threshold (1/3) to trivially halt LIB progression by exploiting the validation bypass, when proper validation would constrain their behavior.

**Detection and Attribution:**
The effect (LIB not advancing) is immediately observable, but attributing responsibility to specific miners is difficult. The protocol lacks mechanisms to penalize or automatically exclude miners engaging in this behavior.

## Recommendation

Modify the validation logic to distinguish between truly new miners and existing miners attempting to regress their values. Track whether a miner has previously reported a non-zero `ImpliedIrreversibleBlockHeight` and reject zero values from established miners:

```csharp
// In LibInformationValidationProvider.cs
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var baseHeight = baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    
    // Only allow zero for truly new miners (both values are zero)
    if (baseHeight > 0 && providedHeight == 0)
    {
        validationResult.Message = "Cannot regress ImpliedIrreversibleBlockHeight to zero.";
        return validationResult;
    }
    
    // Existing regression check
    if (providedHeight != 0 && baseHeight > providedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
}
```

This ensures the bypass only applies to genuinely new miners while preventing established miners from resetting their values to zero.

## Proof of Concept

The vulnerability can be demonstrated by simulating a scenario where miners submit `UpdateValueInput` messages with `ImpliedIrreversibleBlockHeight = 0`. The test would show that:
1. The validation passes despite the zero value (bypass)
2. After sufficient miners submit zeros, `GetSortedImpliedIrreversibleBlockHeights` returns fewer than `MinersCountOfConsent` valid heights
3. `LastIrreversibleBlockHeightCalculator` returns 0, indicating LIB calculation failure
4. `ValidateIrreversibleBlockExistingAsync` returns false, blocking cross-chain operations

The core issue is verified through the code analysis showing the `!= 0` check in the validation logic creates an exploitable bypass that should not exist for established miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-26)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** src/AElf.CrossChain.Core/Indexing/Infrastructure/IrreversibleBlockStateProvider.cs (L30-38)
```csharp
    public async Task<bool> ValidateIrreversibleBlockExistingAsync()
    {
        if (_irreversibleBlockExists)
            return true;
        var libIdHeight = await GetLastIrreversibleBlockHashAndHeightAsync();
        var lastIrreversibleBlockHeight = libIdHeight.BlockHeight;
        _irreversibleBlockExists = lastIrreversibleBlockHeight > AElfConstants.GenesisBlockHeight;
        return _irreversibleBlockExists;
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L271-277)
```csharp
    private async Task<List<ParentChainBlockData>> GetNonIndexedParentChainBlockDataAsync(Hash blockHash,
        long blockHeight, HashSet<int> excludeChainIdList)
    {
        var parentChainBlockDataList = new List<ParentChainBlockData>();
        var libExists = await _irreversibleBlockStateProvider.ValidateIrreversibleBlockExistingAsync();
        if (!libExists)
            return parentChainBlockDataList;
```
