# Audit Report

## Title
Missing Validation of Extra Block Producer in Round Structure Enables Consensus DoS

## Summary
The AEDPoS consensus contract fails to validate Round structure integrity when miners submit `NextRound` or `NextTerm` transactions. A malicious miner can submit a Round with no extra block producer, causing subsequent round generation attempts to throw an `InvalidOperationException`, permanently halting consensus.

## Finding Description

The vulnerability exists in the Round structure validation during consensus round transitions. The core issue is that `GetExtraBlockProducerInformation()` uses LINQ's `First()` operator without verifying an extra block producer exists [1](#0-0) .

This method is called during critical consensus operations when generating the next round [2](#0-1) , specifically at lines 80 and 97 during `BreakContinuousMining()`.

**The Attack Path:**

1. A malicious miner with valid mining privileges generates legitimate Round data through normal consensus flow [3](#0-2) 

2. Before submission, the attacker modifies the Round structure to remove `IsExtraBlockProducer = true` from all miners or sets the extra block producer's `Order` to 0

3. The attacker submits this via `NextRound()` transaction [4](#0-3) 

4. The transaction passes `PreCheck()` which only validates the sender is in the miner list [5](#0-4) 

5. The consensus validation providers fail to detect the malicious structure [6](#0-5) . They only validate round number increments and that InValues are null, but NOT extra block producer existence

6. The corrupt Round is directly stored without structural validation [7](#0-6) 

7. When the next miner attempts to generate the subsequent round, the contract calls `GenerateNextRoundInformation()` with the corrupt Round as the current round [8](#0-7) 

8. This triggers `GetExtraBlockProducerInformation()` which throws `InvalidOperationException` when `First()` finds no element matching the predicate, permanently breaking consensus

## Impact Explanation

**Critical Consensus DoS:**
When `GetExtraBlockProducerInformation()` is called on a Round with no extra block producer, the LINQ `First()` operator throws an `InvalidOperationException`. This occurs during the next miner's attempt to generate their round-terminating block, causing the transaction to fail and preventing any further block production.

The impact is catastrophic because:
- **Permanent halt**: Once the corrupt Round is stored, no miner can successfully generate the next round
- **Network-wide**: All miners are affected, not just the attacker
- **No automatic recovery**: The system cannot self-correct without manual intervention or a chain fork
- **Economic disruption**: Mining rewards cease, transaction processing stops, and network services become unavailable

The direct storage of Round data without structural validation [9](#0-8)  means there are no safeguards to prevent this attack once the malicious transaction is accepted.

## Likelihood Explanation

**Medium-High Likelihood:**

**Attacker Requirements:**
- Must be an active miner in the current round (achievable through normal election/rotation mechanisms)
- Must produce the NextRound/NextTerm block (happens regularly during normal consensus operation)

**Attack Complexity: Low**
The attack requires only modifying transaction input data before submission. No sophisticated cryptographic attacks or timing exploits are needed. The attacker simply:
1. Calls the view method to generate valid Round data
2. Modifies the `IsExtraBlockProducer` flags in memory
3. Submits the modified data via `NextRound` transaction

**Feasibility Factors:**
- No cryptographic signature verification on Round structure contents
- No structural integrity validation in consensus providers
- Direct storage without defensive checks
- The random number is verified via VRF [10](#0-9) , but this doesn't protect the Round structure itself

**Detection Constraints:**
The attack succeeds silently. The corrupt Round is stored and appears valid until the next miner attempts to terminate that round, at which point consensus is already broken.

While requiring miner privileges raises the bar slightly, miner rotation and the potential for compromised/malicious validators make this a realistic threat. The lack of validation makes exploitation straightforward for any miner.

## Recommendation

**Add structural validation to consensus validation providers:**

1. Create a new `RoundStructureValidationProvider` that validates:
   - Exactly one miner has `IsExtraBlockProducer = true`
   - All miners have `Order > 0` and `Order <= miner_count`
   - No duplicate Order values
   - Extra block producer has valid `ExpectedMiningTime`

2. Add this validator to `ValidateBeforeExecution()` for NextRound and NextTerm behaviors

3. Add a defensive check in `GetExtraBlockProducerInformation()`:
```csharp
private MinerInRound GetExtraBlockProducerInformation()
{
    var extraBlockProducer = RealTimeMinersInformation.FirstOrDefault(bp => bp.Value.IsExtraBlockProducer).Value;
    Assert(extraBlockProducer != null, "No extra block producer found in round.");
    return extraBlockProducer;
}
```

4. Validate Order values when storing Round data in `AddRoundInformation()` or as part of structural validation

## Proof of Concept

```csharp
// POC demonstrating the vulnerability
public async Task TestConsensusDoS()
{
    // Setup: Deploy consensus contract and initialize first round with valid miners
    var miners = await InitializeConsensusWithMiners(3);
    
    // Attacker is miner[0], scheduled to produce NextRound block
    var attacker = miners[0];
    
    // Step 1: Get valid round data for next round
    var validNextRound = await GetConsensusBlockExtraDataAsync(attacker);
    var nextRoundInput = NextRoundInput.Create(validNextRound.Round, validNextRound.RandomNumber);
    
    // Step 2: Malicious modification - remove IsExtraBlockProducer from all miners
    foreach (var miner in nextRoundInput.RealTimeMinersInformation.Values)
    {
        miner.IsExtraBlockProducer = false;
    }
    
    // Step 3: Submit corrupt Round - this should succeed
    var result = await attacker.SendTransactionAsync(ConsensusContract, "NextRound", nextRoundInput);
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Step 4: Next miner attempts to generate their NextRound block
    var nextMiner = miners[1];
    
    // This will throw InvalidOperationException and fail
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await nextMiner.GenerateNextRoundAsync();
    });
    
    // Verify consensus is broken
    Assert.Contains("InvalidOperationException", exception.Message);
    Assert.Contains("First", exception.Message);
    
    // No miner can produce blocks anymore - consensus permanently halted
}
```

---

**Notes:**
- This vulnerability affects the core consensus mechanism and has network-wide impact
- The lack of structural validation on Round data is a critical oversight in the consensus validation framework
- The fix requires adding comprehensive Round structure validation before accepting NextRound/NextTerm transactions
- Similar validation should be considered for other consensus data structures to prevent analogous attacks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L76-81)
```csharp
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```
