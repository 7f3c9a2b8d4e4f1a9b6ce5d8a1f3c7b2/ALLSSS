# Audit Report

## Title
Large ByteString DoS via Unconstrained OutValue and Signature Fields in Consensus Validation

## Summary
The `NewConsensusInformationFilled` validation method in the AEDPoS consensus contract only verifies that `OutValue` and `Signature` ByteStrings are non-empty using `.Any()`, without enforcing the expected 32-byte hash size. A malicious elected miner can produce blocks with arbitrarily large ByteStrings (up to the 100MB network limit) that pass validation but cause resource exhaustion during protobuf deserialization across all validating nodes.

## Finding Description

The vulnerability exists in the consensus validation pipeline where `OutValue` and `Signature` fields are validated without proper size constraints.

The `NewConsensusInformationFilled` method performs only a minimal existence check instead of validating the expected hash size: [1](#0-0) 

This validation only checks if the ByteStrings contain at least one byte via `.Any()`, not that they are exactly 32 bytes as required for SHA256 hashes.

The `Hash` protobuf type itself has no size constraint in its definition: [2](#0-1) 

While `Hash.LoadFromByteArray()` enforces 32-byte validation, this method is never called during the validation flow: [3](#0-2) 

Legitimate `OutValue` and `Signature` values are always 32-byte hashes generated via `HashHelper.ComputeFrom`: [4](#0-3) 

**Attack Execution Path:**

1. **Entry point**: `ValidateConsensusBeforeExecution` parses consensus data via protobuf deserialization where resource allocation occurs: [5](#0-4) 

2. Additional parsing also happens in the extractor before contract validation: [6](#0-5) 

3. The validation pipeline invokes `UpdateValueValidationProvider` for `UpdateValue` behavior: [7](#0-6) 

4. `RecoverFromUpdateValue` directly assigns oversized values without size validation: [8](#0-7) 

5. If block execution proceeds, `ProcessUpdateValue` persists oversized values to state: [9](#0-8) 

The network layer permits messages up to 100MB, providing no protection against this attack vector.

## Impact Explanation

**Medium Severity - Consensus Resource Exhaustion DoS**

This vulnerability enables a resource consumption denial-of-service attack against the consensus layer:

1. **Memory Exhaustion**: Protobuf parsing allocates memory proportional to ByteString size. A malicious miner could embed 10-20MB in each field within the 100MB gRPC limit, causing significant memory consumption.

2. **CPU Waste**: Expensive deserialization operations occur during `Parser.ParseFrom()` and subsequent operations when processing the oversized data. These operations scale with data size.

3. **Network Amplification**: The malicious block propagates to all validators via P2P gossip. Each validator independently parses and processes the same oversized data, multiplying resource consumption across the entire network.

4. **Potential State Bloat**: If validation passes and the block executes, oversized values are permanently stored in `State.Rounds`, causing long-term state storage bloat.

The severity is Medium rather than High because:
- The attack requires a compromised elected miner (not an arbitrary attacker)
- Impact is limited to resource consumption, not fund theft or state corruption
- Rate-limited by the malicious miner's block production schedule
- Eventually detectable through validation failures or monitoring

However, this represents a genuine DoS vector that violates the principle that validation should be cheap and fail fast on invalid input.

## Likelihood Explanation

**Medium Likelihood**

**Attacker Capabilities Required:**
- Must be an elected block producer through the AElf election mechanism

Miners are elected participants, not trusted system roles. They could become malicious through:
- Key compromise
- Malicious intent after legitimate election
- Coordination among multiple elected miners

**Attack Complexity:**
Once miner access is achieved, execution is straightforward:
1. Generate valid consensus trigger information
2. Modify `OutValue.Value` and `Signature.Value` ByteStrings to oversized values (e.g., 10MB each)
3. Produce and propagate the block

The `.Any()` check passes for any non-empty ByteString regardless of size, providing no protection against this attack.

**Detection:**
The block may eventually fail post-execution validation due to state inconsistencies, but resource consumption occurs before rejection across all validating nodes.

**Probability Assessment:** Medium - Requires elected miner compromise but attack execution is trivial once access is obtained.

## Recommendation

Add explicit size validation for `OutValue` and `Signature` fields in the `NewConsensusInformationFilled` method:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound =
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Validate OutValue and Signature are not null and exactly 32 bytes (SHA256 hash size)
    return minerInRound.OutValue != null && 
           minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Length == AElfConstants.HashByteArrayLength &&
           minerInRound.Signature.Value.Length == AElfConstants.HashByteArrayLength;
}
```

This ensures that:
1. Both fields exist (not null)
2. Both fields contain exactly 32 bytes (proper hash size)
3. Oversized ByteStrings are rejected early, before expensive processing
4. Validation fails fast on invalid input

Additionally, consider adding size validation in `RecoverFromUpdateValue` as a defense-in-depth measure to prevent oversized values from being assigned to the round information even if validation is bypassed.

## Proof of Concept

A malicious miner would create a block with the following modified consensus extra data structure:

```csharp
// Normal: 32-byte hash
var normalOutValue = HashHelper.ComputeFrom(inValue); // 32 bytes

// Malicious: 10MB ByteString
var maliciousOutValue = new Hash 
{ 
    Value = ByteString.CopyFrom(new byte[10 * 1024 * 1024]) // 10MB
};
var maliciousSignature = new Hash 
{ 
    Value = ByteString.CopyFrom(new byte[10 * 1024 * 1024]) // 10MB
};

// Embed in UpdateValueInput
var updateValueInput = new UpdateValueInput
{
    OutValue = maliciousOutValue,
    Signature = maliciousSignature,
    // ... other valid fields
};
```

When this block reaches validators:
1. `AElfConsensusHeaderInformation.Parser.ParseFrom()` allocates ~20MB per validator
2. `.Any()` check passes (ByteStrings are non-empty)
3. All validators waste resources processing oversized data
4. Block may eventually fail later validation, but damage is done

The attack is repeatable for every block the malicious miner produces, causing sustained resource exhaustion across the validator network.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** protobuf/aelf/core.proto (L140-143)
```text
message Hash
{
    bytes value = 1;
}
```

**File:** src/AElf.Types/Types/Hash.cs (L49-58)
```csharp
        public static Hash LoadFromByteArray(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.HashByteArrayLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Hash
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-82)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```
