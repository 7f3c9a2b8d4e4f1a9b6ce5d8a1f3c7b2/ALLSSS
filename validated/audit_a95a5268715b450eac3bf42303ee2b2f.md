# Audit Report

## Title
Case-Sensitive Ban Bypass in ReplaceCandidatePubkey Allows Banned Miners to Evade Restrictions

## Summary
The `BannedPubkeyMap` state mapping uses case-sensitive string comparison while consensus-originated bans are stored in lowercase hex format. The `ReplaceCandidatePubkey` method accepts user-provided pubkey strings without case normalization, allowing a banned miner's admin to bypass the ban check by providing the banned pubkey in uppercase or mixed case, enabling evasion of permanent consensus exclusion.

## Finding Description

**Root Cause: Case-Sensitive String Key Mismatch**

The `BannedPubkeyMap` is defined as `MappedState<string, bool>` [1](#0-0) , which uses case-sensitive string keys for dictionary lookups in C#.

The `ToHex()` extension method uses the formula `b + 0x37 + 0x20` which always produces lowercase hex characters ('a'-'f') [2](#0-1) .

When the consensus contract creates miner information, pubkeys are converted using `miner.ToHex()` to populate `RealTimeMinersInformation` dictionary keys, ensuring lowercase storage [3](#0-2) .

When evil miners are detected, their pubkeys from `RealTimeMinersInformation` (lowercase) are passed directly to `UpdateCandidateInformation` with `IsEvilNode = true` [4](#0-3) , storing the ban with a lowercase key [5](#0-4) .

**Vulnerable Code Path:**

The `ReplaceCandidatePubkey` method performs its ban check using the user-provided input directly without normalization [6](#0-5) . The `IsPubkeyBanned` helper performs a case-sensitive dictionary lookup [7](#0-6) .

The `IsCurrentCandidateOrInitialMiner` validation uses `HexStringToByteArray`, which is case-insensitive because it uses `Convert.ToByte(hex.Substring(i, 2), 16)` [8](#0-7) . This allows uppercase pubkeys to pass validation [9](#0-8) .

The admin lookup uses `State.InitialPubkeyMap[input.Value] ?? input.Value`, which will return the user-provided uppercase string if no exact-case match exists [10](#0-9) .

**Attack Scenario:**
1. Initial miner with lowercase pubkey "abc123..." exists in consensus
2. Admin sets admin using uppercase: `SetCandidateAdmin(Pubkey: "ABC123...", Admin: adminAddress)` - passes due to case-insensitive byte validation
3. Consensus marks miner as evil, storing ban as `BannedPubkeyMap["abc123..."] = true`
4. Admin calls `ReplaceCandidatePubkey(OldPubkey: "ABC123...", NewPubkey: "newkey")`
5. Ban check `IsPubkeyBanned("ABC123...")` performs case-sensitive lookup on `BannedPubkeyMap["ABC123..."]`, returns false (ban was stored with lowercase key)
6. Admin check passes (stored with uppercase key), initial miner check passes (case-insensitive bytes)
7. Replacement succeeds, banned miner effectively unbanned with new pubkey

## Impact Explanation

This vulnerability critically undermines consensus security by allowing banned malicious miners to rejoin consensus operations. A banned miner can:

1. **Resume Block Production**: The new pubkey can participate in consensus rounds and produce blocks
2. **Continue Malicious Activity**: The same actor banned for evil behavior can continue operating under a new identity
3. **Subvert Governance Enforcement**: Emergency response organization's ban decisions become ineffective
4. **Extract Mining Rewards**: Continue receiving block rewards and subsidies despite permanent ban
5. **Compromise Network Integrity**: Persistently malicious actors cannot be removed, degrading consensus security guarantees

This affects all network participants relying on the consensus mechanism's integrity and the ban system as a critical security enforcement tool.

## Likelihood Explanation

**High Likelihood:**

**Prerequisites:**
- Banned miner previously set candidate admin (standard practice)
- Admin retains control of signing key
- No elevated privileges required

**Attack Complexity: Low**
- Single transaction with case-manipulated pubkey string
- Simple string transformation (lowercase â†’ uppercase)
- No timing dependencies or complex state setup
- Publicly accessible method

**Economic Incentive: Strong**
- Banned miners forfeit all mining rewards and influence
- Strong financial motivation to circumvent permanent exclusion
- Enables continued participation in lucrative block production

**Detection Difficulty:**
- Appears as legitimate pubkey replacement
- Case variation may not trigger monitoring alerts
- String comparison tools would miss the discrepancy

## Recommendation

Normalize all pubkey strings to lowercase before any state lookup or storage operation. Add the following helper method:

```csharp
private string NormalizePubkey(string pubkey)
{
    return pubkey?.ToLower();
}
```

Update all pubkey-related state operations to use normalized keys:

In `IsPubkeyBanned`:
```csharp
private bool IsPubkeyBanned(string pubkey)
{
    return State.BannedPubkeyMap[NormalizePubkey(pubkey)];
}
```

In `SetCandidateAdmin` and `GetCandidateAdmin`, normalize before state access:
```csharp
var normalizedPubkey = NormalizePubkey(input.Pubkey);
var pubkey = State.InitialPubkeyMap[normalizedPubkey] ?? normalizedPubkey;
```

Apply normalization consistently across `ReplaceCandidatePubkey`, `UpdateCandidateInformation`, and all other pubkey state mappings.

## Proof of Concept

```csharp
[Fact]
public async Task CaseSensitiveBanBypass_Test()
{
    // Setup: Create initial miner with lowercase pubkey
    var initialMinerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var lowercasePubkey = initialMinerKeyPair.PublicKey.ToHex(); // lowercase from ToHex()
    var uppercasePubkey = lowercasePubkey.ToUpper();
    var adminKeyPair = ValidationDataCenterKeyPairs.First();
    var adminAddress = Address.FromPublicKey(adminKeyPair.PublicKey);
    
    // Step 1: Admin sets admin using uppercase pubkey (passes due to case-insensitive bytes)
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, initialMinerKeyPair);
    await adminStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = uppercasePubkey,
        Admin = adminAddress
    });
    
    // Step 2: Consensus marks miner as evil (stores ban with lowercase key)
    var consensusStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, BootMinerKeyPair);
    await consensusStub.UpdateCandidateInformation.SendAsync(new UpdateCandidateInformationInput
    {
        Pubkey = lowercasePubkey,
        IsEvilNode = true
    });
    
    // Verify ban stored with lowercase key
    var isBannedLower = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = lowercasePubkey });
    isBannedLower.Value.ShouldBeTrue();
    
    // Step 3: Admin replaces using uppercase pubkey (bypasses ban check!)
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var replacementStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, adminKeyPair);
    var result = await replacementStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = uppercasePubkey, // Case mismatch bypasses ban
        NewPubkey = newKeyPair.PublicKey.ToHex()
    });
    
    // VULNERABILITY: Replacement succeeds despite ban
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Banned miner now has new unbanned pubkey
    var newCandidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = newKeyPair.PublicKey.ToHex() });
    newCandidateInfo.IsCurrentCandidate.ShouldBeTrue(); // Miner rejoined!
}
```

## Notes

This vulnerability exploits the case sensitivity mismatch between:
- Consensus contract's lowercase pubkey storage (from `ToHex()`)
- Election contract's case-sensitive state mapping lookups
- Case-insensitive byte comparison validation

The issue is exacerbated by allowing users to provide pubkey strings in any case without normalization, creating multiple valid representations of the same cryptographic identity with different ban statuses.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L33-33)
```csharp
    public MappedState<string, bool> BannedPubkeyMap { get; set; }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L17-17)
```csharp
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L143-153)
```csharp
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L96-96)
```csharp
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L177-178)
```csharp
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L16-16)
```csharp
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```
