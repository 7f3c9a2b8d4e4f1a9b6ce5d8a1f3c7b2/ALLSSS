# Audit Report

## Title
Vote Target Change Denial of Service for Legacy Votes After Weight Settings Update

## Summary
Legacy votes created before the ProfitDetailId feature cannot change targets with extended profit periods (`IsResetVotingTime=true`) after governance updates vote weight calculation settings. The weight recalculation mechanism uses current settings instead of original settings, causing a shares mismatch that results in an `AssertionException` and transaction failure.

## Finding Description

The vulnerability manifests when users with legacy votes attempt to change vote targets with profit period extension after governance modifies weight calculation parameters.

**Root Cause - Weight Recalculation Mismatch:**

When a vote is originally created, profit details are stored with shares calculated using the weight settings active at creation time. [1](#0-0) 

The weight calculation uses `VoteWeightInterestList` and `VoteWeightProportion` settings. [2](#0-1) 

When changing vote targets with `IsResetVotingTime=true`, the `ExtendVoterWelfareProfits` function is invoked. [3](#0-2) 

This function retrieves the election voting record, which recalculates the weight using CURRENT settings, not the original settings from vote creation time. [4](#0-3) 

**Lookup Failure for Legacy Votes:**

The `GetProfitDetailByElectionVotingRecord` function attempts to find the matching profit detail using two strategies. First, it tries matching by profit detail ID. For legacy votes created before the ProfitDetailId feature, this ID is null (as indicated by the code comment "in the old world, profitDetail.Id is null"). When the ID match fails, it falls back to matching by shares. [5](#0-4) 

The shares matching compares the stored shares (calculated with OLD weight settings) against the recalculated weight (using NEW settings). If governance has changed the weight settings, these values will not match, causing the function to return null.

**Transaction Failure:**

When the profit detail cannot be found, the `ExtendVoterWelfareProfits` function throws an AssertionException. [6](#0-5) 

This causes the entire `ChangeVotingOption` transaction to fail.

**Governance Can Legitimately Change Settings:**

The Parliament governance can update vote weight settings via `SetVoteWeightInterest` and `SetVoteWeightProportion` methods. [7](#0-6) 

These methods are controlled by Parliament authority. [8](#0-7) 

## Impact Explanation

**Affected Users:** All holders of legacy votes (created before ProfitDetailId feature implementation) who attempt to change vote targets after ANY governance update to weight calculation settings.

**Concrete Harm:**
1. **Denial of Service**: The legitimate `ChangeVotingOption` feature with `IsResetVotingTime=true` becomes completely unusable for legacy votes
2. **Economic Loss**: Users are forced to either:
   - Maintain their current vote target (losing voting flexibility)
   - Use `IsResetVotingTime=false`, which proportionally reduces their remaining profit earning period, resulting in direct economic loss of expected rewards

**Severity Justification:** Medium severity because:
- It's a protocol-level DoS affecting a core governance feature
- Causes quantifiable economic loss through reduced profit periods
- Affects all legacy votes system-wide after a single governance action
- No direct fund theft, but legitimate users suffer economic harm
- Workaround exists but comes with economic penalties

## Likelihood Explanation

**Preconditions:**
1. Legacy votes exist in the system (explicitly acknowledged by code comments and fallback logic)
2. Governance updates weight settings through legitimate governance actions

**Feasibility:** HIGH
- Weight setting changes are legitimate governance operations for adjusting economic incentives
- No attacker capabilities required - triggered by honest governance actions
- Test suite confirms governance can modify these settings successfully

**Probability:** MEDIUM-HIGH
- Governance weight adjustments are economically rational during protocol evolution
- Settings may need updates to fix calculation issues or adjust incentive structures
- Once settings change, ALL legacy votes are immediately affected

## Recommendation

Implement a migration mechanism or store the original weight calculation parameters with each profit detail to ensure consistent matching regardless of subsequent governance changes. Options include:

1. **Store Original Weight with Profit Detail**: When creating legacy profit details, store the actual calculated weight alongside the shares to enable correct matching even after settings changes.

2. **Migration Function**: Provide a governance-controlled migration function that updates legacy profit detail IDs to match their corresponding vote IDs, eliminating the need for shares-based matching.

3. **Recalculation Cache**: Cache the original weight calculation parameters (VoteWeightInterestList, VoteWeightProportion) with each vote record, and use these cached parameters when recalculating weights for legacy votes.

4. **Fallback Fix**: Modify `GetProfitDetailByElectionVotingRecord` to try multiple weight calculation strategies when the shares match fails, using historical weight settings if available.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task LegacyVote_ChangeTarget_AfterWeightSettingsUpdate_Fails()
{
    // Setup: Create a vote with initial weight settings
    var voter = VoterKeyPairs.First();
    var oldCandidate = ValidationDataCenterKeyPairs.First();
    var newCandidate = ValidationDataCenterKeyPairs.Skip(1).First();
    
    await AnnounceElectionAsync(oldCandidate);
    await AnnounceElectionAsync(newCandidate);
    
    // Vote with original weight settings
    var voteResult = await VoteToCandidateAsync(voter, oldCandidate.PublicKey.ToHex(), 
        lockTime: 365 * 24 * 60 * 60, amount: 1000);
    var voteId = Hash.Parser.ParseFrom(voteResult.ReturnValue);
    
    // Simulate legacy vote by removing ProfitDetailId (or assume it's a pre-existing legacy vote)
    // In reality, legacy votes already exist on-chain without IDs
    
    // Governance updates weight settings (legitimate action)
    var newWeightSettings = new VoteWeightInterestList
    {
        VoteWeightInterestInfos = {
            new VoteWeightInterest { Day = 365, Interest = 2, Capital = 1000 }, // Changed from Interest=1
            new VoteWeightInterest { Day = 730, Interest = 20, Capital = 10000 }, // Changed from Interest=15
            new VoteWeightInterest { Day = 1095, Interest = 3, Capital = 1000 } // Changed from Interest=2
        }
    };
    await ExecuteProposalForParliamentTransaction(ElectionContractAddress,
        nameof(ElectionContractStub.SetVoteWeightInterest), newWeightSettings);
    
    // Advance time
    BlockTimeProvider.SetBlockTime(StartTimestamp.AddDays(30));
    
    // Attempt to change vote target with IsResetVotingTime=true
    var electionStub = GetElectionContractTester(voter);
    var changeResult = await electionStub.ChangeVotingOption.SendAsync(
        new ChangeVotingOptionInput
        {
            VoteId = voteId,
            CandidatePubkey = newCandidate.PublicKey.ToHex(),
            IsResetVotingTime = true // This should extend profit period
        });
    
    // EXPECTED: Transaction fails with "Cannot find profit detail of given vote id"
    changeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    changeResult.TransactionResult.Error.ShouldContain("Cannot find profit detail");
}
```

**Notes:**
- The vulnerability affects the existing legacy vote population that was created before the ProfitDetailId feature was implemented
- The code explicitly handles legacy votes through fallback matching by shares, confirming their existence
- Once governance updates weight settings, the recalculated weight will differ from stored shares, breaking the matching logic
- Users lose the ability to extend their profit earning periods when changing vote targets, resulting in economic loss

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-37)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L156-159)
```csharp
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-216)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }

    public override Empty SetVoteWeightProportion(VoteWeightProportion input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.TimeProportion > 0 && input.AmountProportion > 0, "invalid input");
        State.VoteWeightProportion.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L385-400)
```csharp
    private void AssertPerformedByVoteWeightInterestController()
    {
        if (State.VoteWeightInterestController.Value == null)
            State.VoteWeightInterestController.Value = GetDefaultVoteWeightInterestController();

        Assert(Context.Sender == State.VoteWeightInterestController.Value.OwnerAddress, "No permission.");
    }

    private AuthorityInfo GetDefaultVoteWeightInterestController()
    {
        return new AuthorityInfo
        {
            ContractAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
            OwnerAddress = GetParliamentDefaultAddress()
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```
