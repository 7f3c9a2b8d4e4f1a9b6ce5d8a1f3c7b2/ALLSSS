# Audit Report

## Title
Permanent Contract Lock Due to Missing Null/Empty Address Validation in SetContractAuthor

## Summary
The `SetContractAuthor()` function in the Genesis contract lacks validation to prevent setting the contract author to null or an empty address. Once triggered, this creates a permanent denial-of-service by making the contract permanently un-upgradeable through all update mechanisms, with no recovery path available.

## Finding Description

The `SetContractAuthor()` function does not validate `input.NewAuthor` before assignment, allowing null or empty addresses to be set as the contract author. [1](#0-0) 

This violates the standard validation pattern used consistently throughout the codebase. Compare with `SetSigner()` which correctly validates addresses: [2](#0-1) 

Once `info.Author` becomes null or empty, all contract update mechanisms become permanently blocked:

**1. ProposeUpdateContract Path Blocked:**
The `ProposeUpdateContract` method calls `AssertAuthorityByContractInfo` which checks if the author matches the sender or if the contract is self-updating. [3](#0-2) 

The authorization helper performs the critical check: [4](#0-3) 

When `contractInfo.Author` is null, both conditions evaluate to false (`null == Context.Self` is false, and `Context.Sender == null` is false), causing the assertion to fail with "No permission."

**2. UpdateUserSmartContract Path Blocked:**
User contract updates require the sender to match the author: [5](#0-4) 

With a null author, `Context.Sender == null` is always false, permanently blocking updates.

**3. SetContractAuthor Cannot Self-Recover:**
The function itself requires author permission to execute: [6](#0-5) 

Once the author is null, this check fails, preventing any attempt to restore a valid author.

**4. No Administrative Override Exists:**
The `UpdateSmartContract` method also enforces author checks when no proposal data exists: [7](#0-6) 

While governance proposals could theoretically bypass some checks, they cannot be created in the first place because `ProposeUpdateContract` fails at the authorization check before the proposal is even submitted.

**Technical Root Cause:**
In Protocol Buffers v3, the `Address` type is a message that can be null when not set: [8](#0-7) 

The protobuf definition for `SetContractAuthorInput` allows `new_author` to be unset: [9](#0-8) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes permanent, irreversible denial-of-service with the following impacts:

1. **Complete Loss of Contract Upgradeability**: Once triggered, the contract can never be updated againâ€”not by the original author, not by governance, not by any mechanism.

2. **Affects All Contract Types**: Both system contracts and user contracts are vulnerable to this permanent lock.

3. **No Recovery Mechanism**: Unlike most smart contract issues that can be mitigated through upgrades or governance actions, this vulnerability eliminates all possible recovery paths.

4. **Ecosystem-Wide Risk**: Any contract where the author is accidentally set to null becomes a permanent liability, potentially trapping users with buggy or vulnerable code indefinitely.

5. **Violates Critical Invariant**: The AElf protocol's design assumes contracts can always be upgraded through proper authorization. This vulnerability permanently breaks that fundamental guarantee.

## Likelihood Explanation

**Likelihood: MEDIUM**

While this requires the contract author to call `SetContractAuthor()`, several realistic scenarios make this feasible:

1. **Application Bugs**: Contract management tools, deployment scripts, or admin interfaces that incorrectly construct the protobuf message could accidentally omit the `NewAuthor` field, resulting in a null value.

2. **Protobuf Default Behavior**: Protobuf3 messages default to null for unset message fields, making it easy to accidentally create a `SetContractAuthorInput` without properly initializing `NewAuthor`.

3. **Developer Error**: Inexperienced developers or those unfamiliar with protobuf semantics might not realize that failing to set `NewAuthor` results in null rather than an error.

4. **Catastrophic Consequences**: Even a single occurrence is devastating due to the permanent, unrecoverable nature of the issue.

5. **Evidence of Concern**: The fact that the codebase consistently validates addresses in other functions (like `SetSigner`) demonstrates that the development team is aware null addresses are a real concern, making this omission particularly notable.

## Recommendation

Add validation to `SetContractAuthor()` to match the pattern used in `SetSigner()` and throughout the codebase:

```csharp
public override Empty SetContractAuthor(SetContractAuthorInput input)
{
    var info = State.ContractInfos[input.ContractAddress];
    Assert(info != null, "Contract not found.");
    Assert(input.NewAuthor != null && !input.NewAuthor.Value.IsNullOrEmpty(), "Invalid new author address.");
    var oldAuthor = info.Author;
    Assert(Context.Sender == info.Author, "No permission.");
    info.Author = input.NewAuthor;
    State.ContractInfos[input.ContractAddress] = info;
    Context.Fire(new AuthorUpdated()
    {
        Address = input.ContractAddress,
        OldAuthor = oldAuthor,
        NewAuthor = input.NewAuthor
    });

    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SetContractAuthor_NullAddress_PermanentlyLocksContract_Test()
{
    // Deploy a test contract
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };
    
    var contractAddress = await DeployAsync(Tester, ParliamentAddress, BasicContractZeroAddress, contractDeploymentInput);
    
    // Verify contract was deployed with valid author
    var authorBefore = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.GetContractAuthor), 
        contractAddress));
    authorBefore.ShouldNotBeNull();
    
    // Set author to null - THIS SHOULD FAIL BUT DOESN'T
    var setResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.SetContractAuthor), 
        new SetContractAuthorInput
        {
            ContractAddress = contractAddress,
            NewAuthor = null  // Setting to null
        });
    setResult.Status.ShouldBe(TransactionResultStatus.Mined);  // Currently succeeds
    
    // Verify author is now null
    var authorAfter = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.GetContractAuthor), 
        contractAddress));
    authorAfter.ShouldBeNull();  // Author is now null
    
    // Attempt to propose an update - PERMANENTLY FAILS
    var updateInput = new ContractUpdateInput
    {
        Address = contractAddress,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicFunction")).Value)
    };
    
    var proposalResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeUpdateContract), 
        updateInput);
    proposalResult.Status.ShouldBe(TransactionResultStatus.Failed);
    proposalResult.Error.ShouldContain("No permission.");
    
    // Contract is now PERMANENTLY locked - cannot be updated by anyone ever again
}
```

**Notes:**

This vulnerability represents a critical flaw in the contract authorization system. The missing validation creates a permanent state from which there is no recovery, violating the fundamental principle that contracts should always be maintainable through proper authorization channels. The consistency of address validation throughout the rest of the codebase makes this omission particularly striking and suggests it was an oversight rather than an intentional design decision.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-183)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-452)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
        Assert(info.Deployer == null || info.Deployer == Context.Sender, "No permission to update.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-545)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

        if (State.SignerMap[Context.Sender] == input) return new Empty();

        State.SignerMap[Context.Sender] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** protobuf/acs0.proto (L310-313)
```text
message SetContractAuthorInput{
    aelf.Address contract_address = 1;
    aelf.Address new_author = 2;
}
```
