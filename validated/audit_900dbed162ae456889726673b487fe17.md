# Audit Report

## Title
Continuous Block Limit Bypass via Candidate Public Key Replacement

## Summary
A miner can bypass the continuous blocks production limit by exploiting the candidate public key replacement mechanism. When a miner replaces their public key, the consensus contract updates round information but fails to update the `LatestPubkeyToTinyBlocksCount` state variable, creating a pubkey mismatch that causes all enforcement checks to fail and the counter to reset, enabling unlimited continuous block production.

## Finding Description

The AEDPoS consensus system enforces a continuous blocks limit to prevent network forks and ensure decentralization. This limit is tracked via the `LatestPubkeyToTinyBlocksCount` state variable [1](#0-0)  and enforced through three critical checkpoints that all compare the stored pubkey against the current miner's pubkey.

**Validation Checkpoint:** During block validation, the system checks if a miner has exceeded their continuous block limit by comparing the stored pubkey with the sender's pubkey. If they match and the counter is negative, validation fails. [2](#0-1) 

**Command Generation Checkpoint:** When generating consensus commands, the system forces a round transition if the stored pubkey matches the current miner's pubkey and the counter is negative. [3](#0-2) 

**Counter Reset Logic:** After processing each block, the system either decrements the counter (if pubkeys match) or resets it to maximum (if pubkeys differ). [4](#0-3) 

**Root Cause:** When a miner calls `ReplaceCandidatePubkey` through the Election contract [5](#0-4) , it triggers `RecordCandidateReplacement` in the consensus contract via line 298-302. This method updates the round information to replace the old pubkey with the new one [6](#0-5) , but critically **never updates** `State.LatestPubkeyToTinyBlocksCount`.

This creates a permanent mismatch where:
- `LatestPubkeyToTinyBlocksCount.Pubkey` = old pubkey  
- `SenderPubkey` / `_processingBlockMinerPubkey` = new pubkey

When the miner produces their next block with the new key, all three pubkey equality checks evaluate to false (old_pubkey != new_pubkey), causing:
1. Validation to pass even if `BlocksCount < 0`
2. `GetConsensusCommand` to not force `NextRound` behavior
3. Counter to reset to maximum value instead of remaining negative

The miner can prepare multiple keypairs in advance and repeat this process. While old keys become banned after replacement [7](#0-6) , this only prevents reuse of the same key - it doesn't prevent the exploit pattern itself.

## Impact Explanation

**Consensus Integrity Violation:** The continuous blocks limit exists to prevent network instability and forks. The maximum limit is defined as 8 blocks [8](#0-7)  and is enforced through the validation and command generation mechanisms.

By bypassing this limit, a malicious miner can:
- Produce unlimited continuous blocks by repeatedly changing keys
- Defeat fork prevention mechanisms designed to maintain network stability
- Cause network synchronization issues for other nodes
- Violate protocol-level decentralization guarantees
- Undermine the blockchain health monitoring system

**Severity Assessment:** Medium - This violates a critical consensus safety mechanism, but requires modest preparation (multiple prepared keypairs) and is visible on-chain through replacement events [9](#0-8) .

## Likelihood Explanation

**Attacker Capabilities:**
- Miner must control their candidate admin account (typical scenario as miners usually manage their own accounts) [10](#0-9) 
- Miner must prepare multiple valid keypairs in advance
- Each old key becomes banned after use, requiring multiple prepared keys

**Attack Complexity:** Low - The attack only requires calling a public contract method between block productions with no complex preconditions.

**Feasibility:** High
- Entry point `ReplaceCandidatePubkey` is publicly accessible
- No rate limiting or cooldown period exists on key replacements
- Miner can generate multiple keypairs offline before the attack
- Execution timing between blocks is straightforward

**Detection:** Partial - Key replacements are visible on-chain through events, but distinguishing legitimate replacements from exploit attempts is difficult without additional context.

**Economic Rationality:** High - The cost is minimal (only transaction fees), no collateral is at risk, and the attacker gains a potential advantage in block production that could increase mining rewards.

**Overall Likelihood:** Medium - Practical for any miner to execute with modest preparation of multiple keypairs.

## Recommendation

The issue can be fixed by updating `State.LatestPubkeyToTinyBlocksCount` in the `RecordCandidateReplacement` method when a miner's pubkey is replaced. Add the following logic after updating the round information:

```csharp
// Update LatestPubkeyToTinyBlocksCount if it contains the old pubkey
if (State.LatestPubkeyToTinyBlocksCount.Value != null &&
    State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == input.OldPubkey)
{
    State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
    {
        Pubkey = input.NewPubkey,
        BlocksCount = State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount
    };
}
```

This ensures the continuous blocks tracking remains consistent with the miner's current public key, preventing the bypass.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Setup a miner with a valid candidate registration
2. Have the miner produce blocks until approaching the continuous blocks limit
3. Call `ReplaceCandidatePubkey` to change the miner's public key
4. Verify that the miner can continue producing blocks beyond the limit without the system forcing a round transition
5. Confirm that `LatestPubkeyToTinyBlocksCount` still contains the old pubkey while the miner is using the new pubkey

The test would show that after key replacement, the counter resets to maximum (7) instead of maintaining the negative value, allowing unlimited continuous block production through repeated key replacements.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L44-44)
```csharp
    public SingletonState<LatestPubkeyToTinyBlocksCount> LatestPubkeyToTinyBlocksCount { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L17-19)
```csharp
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L31-35)
```csharp
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-363)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
