# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Malicious Miner to Monopolize Block Production

## Summary
The `NextTerm` function in the AEDPoS consensus contract fails to validate that the provided miner list matches the Election Contract's `GetVictories()` result. A malicious current miner can submit a term transition containing only their own public key, bypassing election results and gaining complete control over block production for the entire term.

## Finding Description

The AEDPoS consensus system is designed such that legitimate miners for each term are determined through elections managed by the Election Contract. [1](#0-0) 

The `GenerateFirstRoundOfNextTerm` method demonstrates the intended behavior by calling `TryToGetVictories()` to retrieve elected miners from the Election Contract. [2](#0-1) 

However, when processing a `NextTerm` transaction, the validation logic contains a critical gap. The `ValidationForNextTerm` method only verifies that round and term numbers increment correctly and that InValues are null, but performs no validation of the miner list content. [3](#0-2) 

The `ProcessNextTerm` method directly extracts the miner list from the unvalidated input and stores it in state. [4](#0-3) 

The `SetMinerList` method only checks if a miner list was already set for the term but performs no content validation. [5](#0-4) 

**Attack Execution**:
1. Attacker (a current miner) crafts a `NextTermInput` with only their public key in `RealTimeMinersInformation`
2. During term transition, attacker produces a block containing this fraudulent `NextTerm` transaction
3. `PreCheck()` passes because attacker is in the current miner list [6](#0-5) 
4. Validation providers check mining permission, time slots, and round/term increments but never validate the miner list against `GetVictories()`
5. The fraudulent single-miner list is stored in state
6. Subsequent blocks bypass continuous block validation because the check is skipped when miner count equals 1 [7](#0-6) 

## Impact Explanation

This vulnerability breaks the fundamental security assumption that miners are determined through democratic elections:

**Consensus Integrity Violation**: The attacker monopolizes block production for an entire term, reducing a multi-validator Byzantine Fault Tolerant system to a single point of control.

**Transaction Censorship**: With sole mining authority, the attacker can permanently censor any transactions including governance proposals to fix the issue, election votes for the next term, or any user transactions.

**Economic Damage**: The attacker captures 100% of mining rewards while legitimately elected miners receive nothing, directly stealing value from honest validators who won through proper voting.

**Persistent Attack**: The attacker controls all future term transitions and can repeatedly submit fraudulent `NextTerm` transactions to maintain monopoly indefinitely.

## Likelihood Explanation

**Highly Feasible**: The attack only requires being one of the current miners, which is a realistic threat scenario for any compromised or malicious validator. The entry point is the public `NextTerm` method. [8](#0-7) 

**Low Complexity**: Execution requires producing a single block with modified consensus extra data during the natural term transition window. The validation logic has no defense against this attack.

**No Detection**: The validation system checks mining permissions against the current round, validates time slots, and verifies round/term number increments, but never validates the new miner list content against the Election Contract's authoritative source.

**Economic Rationality**: Attack cost is minimal (one block production during term transition), while the benefit is capturing 100% of mining rewards and complete network control.

## Recommendation

Add miner list validation to `ValidationForNextTerm` by querying the Election Contract's `GetVictories()` method and verifying that the provided miner list in `RealTimeMinersInformation` matches the elected miners:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Existing term number check
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate miner list against Election Contract
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var electedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        
        if (!providedMiners.SequenceEqual(electedMiners))
            return new ValidationResult { Message = "Miner list does not match Election Contract victories." };
    }
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanMonopolizeBlockProductionViaNextTerm()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = new[] { InitialCoreDataCenterKeyPairs[0], InitialCoreDataCenterKeyPairs[1], InitialCoreDataCenterKeyPairs[2] };
    await InitializeConsensusAsync(initialMiners);
    
    // Attacker is the first miner
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var attackerPubkey = attackerKeyPair.PublicKey.ToHex();
    
    // Mine blocks until near term transition
    await MineBlocksToNearTermEnd();
    
    // Attacker crafts fraudulent NextTermInput with only their pubkey
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var fraudulentNextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        RandomNumber = GenerateRandomProof(attackerKeyPair),
        IsMinerListJustChanged = true
    };
    
    // Add ONLY attacker's miner information
    fraudulentNextTermInput.RealTimeMinersInformation[attackerPubkey] = new MinerInRound
    {
        Pubkey = attackerPubkey,
        Order = 1,
        IsExtraBlockProducer = true,
        ExpectedMiningTime = Context.CurrentBlockTime.AddMilliseconds(4000)
    };
    
    // Execute fraudulent term transition
    var result = await GetConsensusStub(attackerKeyPair).NextTerm.SendAsync(fraudulentNextTermInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should FAIL but PASSES
    
    // Verify attacker now has monopoly
    var newMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    newMinerList.Pubkeys.Count.ShouldBe(1); // Only one miner
    newMinerList.Pubkeys[0].ToHex().ShouldBe(attackerPubkey); // It's the attacker
    
    // Verify legitimate miners were excluded despite winning elections
    var victories = await ElectionStub.GetVictories.CallAsync(new Empty());
    victories.Value.Count.ShouldBeGreaterThan(1); // Multiple miners should have won
    // But only attacker can produce blocks now - VULNERABILITY CONFIRMED
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```
