# Audit Report

## Title
Continuous Blocks Validation Bypass via Negative RoundNumber in UpdateValue/TinyBlock Behaviors

## Summary
The `ContinuousBlocksValidationProvider` can be bypassed by providing a negative `RoundNumber` in consensus extra data. The validation check `ProvidedRound.RoundNumber > 2` evaluates to false for negative values, allowing miners to produce more consecutive blocks than the configured maximum threshold of 8 blocks, violating consensus fairness guarantees.

## Finding Description
The AEDPoS consensus mechanism enforces a fairness rule preventing any single miner from producing more than 8 consecutive "tiny blocks" within their time slot. This is tracked via `LatestPubkeyToTinyBlocksCount.BlocksCount`, which decrements each time the same miner produces consecutive blocks. [1](#0-0) 

The `ContinuousBlocksValidationProvider` enforces this limit by checking if `BlocksCount < 0`, indicating excessive consecutive blocks. However, this validation only executes when `ProvidedRound.RoundNumber > 2`: [2](#0-1) 

The `RoundNumber` field is defined as `int64` in the protobuf schema, allowing negative values: [3](#0-2) 

The `ProvidedRound` is populated from block header extra data without validating that `RoundNumber` is positive: [4](#0-3) 

**Attack Scenario:**
1. Miner produces 8 consecutive blocks, causing `BlocksCount` to become negative (-1 after the 8th block)
2. The consensus command logic would normally force the miner to produce a `NextRound` block: [5](#0-4) 

3. Instead, the miner crafts a block with `UpdateValue` or `TinyBlock` behavior and sets `RoundNumber = -1` in the consensus extra data
4. During validation in `ValidateBeforeExecution`, the `RecoverFromUpdateValue` or `RecoverFromTinyBlock` methods are called, which do not validate or use the `RoundNumber` field: [6](#0-5) 

5. When `ContinuousBlocksValidationProvider` runs, the check `-1 > 2` evaluates to false, causing the entire continuous blocks validation to be skipped
6. The block passes validation despite exceeding the consecutive blocks limit

The vulnerability exists because no validation provider checks whether `ProvidedRound.RoundNumber` is positive or matches the actual current round number stored in state for `UpdateValue` and `TinyBlock` behaviors. The `RoundTerminateValidationProvider` validates `RoundNumber` for `NextRound` and `NextTerm` behaviors: [7](#0-6) 

But this provider is not added to the validation pipeline for `UpdateValue` or `TinyBlock` behaviors: [8](#0-7) 

## Impact Explanation
This vulnerability violates the consensus fairness guarantee designed to prevent block production centralization. A malicious miner can:

1. Continue producing blocks beyond the 8-block limit without triggering validation failures
2. Dominate block production and centralize consensus power  
3. Deny other miners their fair share of block production slots and associated rewards

However, the impact is LIMITED because:
- The attacker must be a validly elected miner with legitimate mining permissions
- Other critical validations remain enforced (mining permission, time slot validation)
- State integrity is maintained since actual round updates use `BaseRound` from state, not the malicious `ProvidedRound`: [9](#0-8) 

- No direct fund theft or total consensus break occurs

This is appropriately classified as **LOW severity** - it affects consensus fairness and decentralization rather than causing direct financial loss or complete consensus failure.

## Likelihood Explanation
The attack is practically exploitable with **moderate likelihood**:

**Required Capabilities:**
- Must be an authorized miner in the current miner list (validated by `MiningPermissionValidationProvider`)
- Must be within assigned time slot (validated by `TimeSlotValidationProvider`)  
- Technical capability to craft custom block headers with modified protobuf consensus extra data

**Attack Complexity:**
- Low to moderate - requires modifying the `RoundNumber` field in the `AElfConsensusHeaderInformation` protobuf message
- No cryptographic challenges or complex preconditions beyond being a valid miner
- Protobuf serialization accepts arbitrary int64 values without type-level constraints

**Economic Rationality:**
- Elected miners have economic incentive to maximize block production and associated mining rewards
- The cost is minimal (just crafting modified headers)
- The benefit is increased block production share and rewards

## Recommendation
Add validation that `ProvidedRound.RoundNumber` matches `BaseRound.RoundNumber` for `UpdateValue` and `TinyBlock` behaviors, or at minimum validate that it is positive:

```csharp
// In ContinuousBlocksValidationProvider.cs
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Validate RoundNumber is non-negative
    if (validationContext.ProvidedRound.RoundNumber < 0)
    {
        validationResult.Message = "Invalid negative round number.";
        return validationResult;
    }

    if (validationContext.ProvidedRound.RoundNumber > 2 && 
        validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
    {
        // existing validation logic
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

Alternatively, add a dedicated `RoundNumberValidationProvider` that validates `ProvidedRound.RoundNumber` matches `BaseRound.RoundNumber` for all behaviors except `NextRound` and `NextTerm`.

## Proof of Concept
The PoC would require setting up an AElf test environment with multiple miners, producing 8 consecutive blocks with one miner to drive `BlocksCount` negative, then crafting a block with `UpdateValue` behavior where the consensus extra data contains `RoundNumber = -1`. The validation would pass despite the excessive consecutive blocks, and the block would be accepted into the chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** protobuf/aedpos_contract.proto (L243-245)
```text
message Round {
    // The round number.
    int64 round_number = 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```
