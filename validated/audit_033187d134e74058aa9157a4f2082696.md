# Audit Report

## Title
Broken Post-Execution Consensus Validation Allows Round State Corruption

## Summary
The `ValidateConsensusAfterExecution` method contains a critical object aliasing bug where `RecoverFromUpdateValue` and `RecoverFromTinyBlock` return `this` after modifying the current round in-place, causing validation to compare an object with itself and rendering post-execution integrity checks completely ineffective.

## Finding Description

The vulnerability exists in the post-execution validation logic where an object reference aliasing bug defeats the entire validation mechanism. [1](#0-0) 

The root cause is that both recovery methods modify the `currentRound` object in-place and return `this`: [2](#0-1) [3](#0-2) 

After lines 89-97 execute, `headerInformation.Round` becomes a reference to the same object as `currentRound`. The subsequent hash comparison always succeeds because it compares an object with itself: [4](#0-3) 

Hash computation relies on serialized state: [5](#0-4) [6](#0-5) 

**Attack Path:**

1. Malicious miner obtains consensus data and modifies critical fields before block production
2. Transaction input contains corrupted values via `ExtractInformationToUpdateConsensus`: [7](#0-6) 

3. During execution, `ProcessUpdateValue` writes corrupted values directly to state without proper validation: [8](#0-7) 

4. Broken post-execution validation fails to detect corruption
5. Corrupted state persists and propagates to future rounds

The pre-execution validation in `ValidateBeforeExecution` also uses the same recovery methods but only checks basic constraints: [9](#0-8) 

## Impact Explanation

This breaks fundamental consensus integrity:

**1. LIB Manipulation:** `LibInformationValidationProvider` only prevents decreases, not arbitrary increases: [10](#0-9) 

Attackers can set arbitrary `ImpliedIrreversibleBlockHeight` values, manipulating finality calculations.

**2. Mining Order Manipulation:** `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` control block producer scheduling but have NO pre-execution validation: [11](#0-10) 

This enables censorship attacks and unfair mining advantages.

**3. Random Number Manipulation:** Corrupted `OutValue` and `Signature` poison random hash generation throughout consensus.

**Severity: CRITICAL** - Allows arbitrary consensus state corruption by any block producer without detection.

## Likelihood Explanation

**Attacker Requirements:**
- Active block producer (scheduled miner)
- Ability to modify node software (standard capability)
- No special privileges required

**Feasibility: HIGH**
- Single interception point in block production
- No timing dependencies
- Completely undetectable due to broken validation

**Detection: NONE** - The primary defense mechanism is completely broken. Pre-execution validation only checks basic constraints, not field correctness.

## Recommendation

Fix the object aliasing bug by creating a copy instead of modifying in-place:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Create a copy for validation instead of modifying currentRound
        var currentRoundCopy = currentRound.Clone();
        
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            currentRoundCopy.RecoverFromUpdateValue(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            currentRoundCopy.RecoverFromTinyBlock(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        // Now compare recovered copy with original header
        if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
            currentRoundCopy.GetHash(isContainPreviousInValue))
        {
            // validation logic...
        }
    }
    return new ValidationResult { Success = true };
}
```

Additionally, add pre-execution validation for `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` to verify they match expected consensus rules.

## Proof of Concept

```csharp
[Fact]
public async Task ValidateConsensusAfterExecution_ObjectAliasingBug_Test()
{
    // Setup: Produce first block normally
    await AEDPoSContract_FirstRound_BootMiner_Test();
    
    var usingKeyPair = InitialCoreDataCenterKeyPairs[1];
    KeyPairProvider.SetKeyPair(usingKeyPair);
    
    // Get legitimate consensus command
    var consensusCommand = await AEDPoSContract_GetConsensusCommand_FirstRound_SecondMiner_Test();
    var triggerForCommand = TriggerInformationProvider
        .GetTriggerInformationForBlockHeaderExtraData(consensusCommand.ToBytesValue());
    var extraDataBytes = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggerForCommand);
    var extraData = extraDataBytes.ToConsensusHeaderInformation();
    
    // Malicious modification: Set arbitrary FinalOrderOfNextRound values
    var originalOrderValue = extraData.Round.RealTimeMinersInformation[usingKeyPair.PublicKey.ToHex()].FinalOrderOfNextRound;
    extraData.Round.RealTimeMinersInformation[usingKeyPair.PublicKey.ToHex()].FinalOrderOfNextRound = 999; // Corrupted value
    
    // Validation should fail but doesn't due to object aliasing bug
    var validationResult = await AEDPoSContractStub.ValidateConsensusAfterExecution.CallAsync(extraData.ToBytesValue());
    
    // BUG: Validation succeeds even with corrupted data
    validationResult.Success.ShouldBeTrue(); // This passes when it shouldn't
    
    // Verify the bug: Both references point to same object after RecoverFromUpdateValue
    // The comparison always succeeds because it compares object with itself
}
```

## Notes

This vulnerability fundamentally breaks the consensus validation security model. The post-execution check exists specifically to detect when executed state diverges from proposed header information, but the object aliasing bug makes this check meaningless. Any active miner can exploit this to corrupt consensus state without detection, compromising blockchain integrity at the protocol level.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-97)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L60-63)
```csharp
    public Hash GetHash(bool isContainPreviousInValue = true)
    {
        return HashHelper.ComputeFrom(GetCheckableRound(isContainPreviousInValue));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```
