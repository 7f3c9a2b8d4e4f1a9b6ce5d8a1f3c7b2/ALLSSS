# Audit Report

## Title
Missing Order Value Validation in NextTerm Allows Consensus DoS via Malformed Round Data

## Summary
The AEDPoS consensus contract lacks Order value validation for NextTerm behavior, creating a validation gap that allows a malicious block producer to inject Round data with zero or invalid Order values. This causes critical consensus methods to throw exceptions, immediately halting block production chain-wide.

## Finding Description

The vulnerability arises from an asymmetry in validation logic between NextRound and NextTerm consensus behaviors.

**Root Cause - Missing Validation:**

When NextTerm behavior is validated, only `RoundTerminateValidationProvider` is added to the validation chain, which exclusively checks round number and term number increments. [1](#0-0) 

The `RoundTerminateValidationProvider` implementation confirms it only validates round and term number progression, with no Order value checks. [2](#0-1) 

In contrast, NextRound behavior includes `NextRoundMiningOrderValidationProvider` which validates that `FinalOrderOfNextRound > 0`. [3](#0-2) [4](#0-3) 

**Data Flow Without Validation:**

The `NextTermInput.Create()` method directly copies RealTimeMinersInformation without any Order value validation. [5](#0-4) 

When consensus transactions are generated, the Round data from consensus extra data is used to create NextTermInput via the Create method. [6](#0-5) 

The NextTerm processing stores this Round data directly into state without additional validation. [7](#0-6) [8](#0-7) 

**Attack Vector:**

A malicious miner can modify their node software to bypass the normal `MinerList.GenerateFirstRoundOfNewTerm` method (which correctly assigns Order = i + 1) [9](#0-8) 

and instead inject malformed consensus extra data with Order = 0 or negative values during NextTerm block production. This malformed data passes validation and gets stored in state.

**Immediate Failure Points:**

Multiple consensus-critical methods assume valid Order values and will throw exceptions:

1. **GetMiningInterval()** filters miners with `Order == 1 || Order == 2` and accesses array indices without bounds checking. With Order = 0, the filtered list is empty, causing `IndexOutOfRangeException` when accessing `firstTwoMiners[1]`. [10](#0-9) 

2. **BreakContinuousMining()** uses `.First(i => i.Order == 1)` which throws `InvalidOperationException` if no miner has Order 1. [11](#0-10) 

3. **TimeSlotValidationProvider** (used in every block validation) calls GetMiningInterval(), triggering the exception. [12](#0-11) 

4. **GenerateNextRoundInformation()** also calls GetMiningInterval() at the start of round generation. [13](#0-12) 

## Impact Explanation

**Severity: Critical - Complete Consensus Halt**

Once a malicious NextTerm block with Order = 0 is accepted:

1. The corrupted Round data is permanently stored in consensus state
2. The very next block's validation will call `TimeSlotValidationProvider.CheckMinerTimeSlot()`
3. This calls `GetMiningInterval()` on the corrupted Round
4. `GetMiningInterval()` throws `IndexOutOfRangeException`
5. Block validation fails for all subsequent blocks
6. **The entire blockchain stops producing blocks**

The impact affects all network participants immediately and requires manual intervention to recover (likely requiring a chain rollback or state migration). Normal operations including block production and validation, transaction processing, time slot calculation, miner scheduling, and round transitions all become impossible until the corrupted state is remediated.

This is a high-confidence availability attack (DoS) that breaks the fundamental consensus invariant that Order values must be sequential positive integers starting from 1.

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Must be an active miner in the current term
- Must be scheduled to produce the NextTerm transition block
- Must modify node software to inject malformed consensus data

**Feasibility:**
The attack is technically straightforward - miners control the consensus extra data generation in their node software. The validation gap is exploitable with minimal code modification. Any miner will eventually be scheduled to produce a NextTerm block due to rotation.

**Realistic Scenarios:**
- Compromised miner node (malware/hacking)
- Malicious insider miner attempting ecosystem disruption
- Buggy node software update that inadvertently generates invalid Order values
- Competitor attempting to halt chain for market advantage

**Detection:**
The attack is immediately visible post-execution as exceptions appear in block validation logs, but by then the damage is done with corrupted state already persisted.

## Recommendation

Add Order value validation to the NextTerm validation chain by including a validation provider that ensures all Order values in `RealTimeMinersInformation` are positive integers starting from 1 with no gaps.

The fix should add an Order validation provider to the NextTerm validation chain:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new OrderValueValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

Create a new `OrderValueValidationProvider` that validates:
- All miners have Order values > 0
- Order values are sequential from 1 to minerCount
- No duplicate Order values exist

## Proof of Concept

A proof of concept would require:
1. Setting up an AElf test network with multiple miners
2. Modifying one miner's node software to generate malformed NextTermInput with Order = 0
3. Waiting for that miner to be scheduled for NextTerm block production
4. Observing the consensus halt when the next block attempts validation

The test would verify that `GetMiningInterval()` throws `IndexOutOfRangeException` when called with a Round containing miners with Order = 0, demonstrating the validation gap and its impact on consensus operations.

## Notes

This vulnerability represents a critical validation gap in the consensus layer. The asymmetry between NextRound and NextTerm validation logic creates an exploitable weakness that violates fundamental consensus invariants. The fix requires adding consistent Order value validation across all consensus behaviors that modify Round state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L30-31)
```csharp
            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-21)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-90)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```
