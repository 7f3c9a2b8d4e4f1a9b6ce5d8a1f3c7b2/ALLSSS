# Audit Report

## Title
ProposerWhiteList Validation Bypass Allows Creation of Permanently Bricked Referendum Organizations

## Summary
The Referendum contract fails to validate that addresses in the ProposerWhiteList contain non-empty value fields, allowing attackers to create organizations with malformed addresses that permanently prevent proposal creation, resulting in complete denial-of-service of governance functionality.

## Finding Description

The vulnerability exists in the Referendum contract's organization validation logic. The root cause is that validation only performs a count-based check on the ProposerWhiteList without verifying that individual Address objects contain valid data. [1](#0-0) 

The validation checks if the ProposerWhiteList is non-empty using the `Empty()` extension method: [2](#0-1) 

This count-based approach only verifies that Address objects exist in the list, but does not validate that their `Value` fields (ByteString) are non-empty. In protobuf3, the Address message allows empty bytes values: [3](#0-2) 

While C# Address constructors enforce 32-byte length requirements, protobuf deserialization bypasses these constructors: [4](#0-3) 

The correct validation pattern exists in TokenContract: [5](#0-4) 

This proper validation uses the `IsNullOrEmpty()` extension method: [6](#0-5) 

**Attack Execution:**

1. Attacker crafts CreateOrganizationInput with ProposerWhiteList containing Address objects with empty value fields
2. Organization is created via the public CreateOrganization() method: [7](#0-6) 

3. When legitimate users attempt to create proposals, AssertIsAuthorizedProposer() is invoked: [8](#0-7) 

4. The authorization check uses Contains() which compares Address equality: [9](#0-8) 

5. The Contains() implementation relies on protobuf's default equality comparison: [10](#0-9) 

6. Valid addresses (32 bytes) never match addresses with empty bytes, causing all proposal creations to fail with "Unauthorized to propose."

## Impact Explanation

This vulnerability enables complete permanent denial-of-service of governance functionality for affected Referendum organizations. Once an organization is created with malformed addresses in the ProposerWhiteList, no legitimate user can ever create proposals for that organization.

The governance mechanism becomes permanently non-functional because the authorization check will always fail when comparing valid addresses (32-byte ByteString) against empty-valued addresses (0-byte ByteString). While ChangeOrganizationProposerWhiteList() exists to modify the whitelist: [11](#0-10) 

This method can only be called by the organization address itself (Context.Sender must equal the organization), which requires passing a proposal firstâ€”an impossibility when no proposals can be created.

Organizations relying on Referendum-based governance for parameter updates, upgrades, or treasury management would lose this capability entirely. The impact is permanent unless the contract is upgraded.

## Likelihood Explanation

The likelihood is medium-to-high based on:

**Attacker Capabilities:** CreateOrganization() is a public method requiring no special permissions. The attacker must craft protobuf messages with Address objects containing empty value fields, achievable with standard protobuf libraries.

**Attack Complexity:** Protobuf3 allows all fields to have default values. For bytes fields, the default is empty. An attacker can craft messages where Address.Value is empty, bypassing C# constructor validations that only apply to programmatic object creation, not protobuf deserialization.

**Economic Rationality:** Attack cost is minimal (transaction gas fees only). While there's no direct economic benefit, this enables targeted griefing attacks against specific governance organizations.

**Detection:** Bricked organizations are only discovered when the first proposal creation attempt fails. No proactive detection mechanism exists to identify organizations with invalid whitelists.

## Recommendation

Add explicit validation for Address.Value in the ProposerWhiteList validation logic:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for each address in ProposerWhiteList
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Additionally, consider adding similar validation to the Association contract which exhibits the same vulnerability pattern: [12](#0-11) 

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithEmptyAddressValue_ShouldBrickProposalCreation()
{
    // Create organization with empty-valued address in ProposerWhiteList
    var emptyAddress = new Address { Value = ByteString.Empty };
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        TokenSymbol = "ELF",
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalRejectionThreshold = 0,
            MaximalAbstentionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { emptyAddress }
        }
    };
    
    // Organization creation should succeed (but shouldn't)
    var organizationAddress = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    organizationAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Now try to create a proposal with a valid proposer address
    var validProposer = DefaultSender; // or any valid address
    var createProposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ContractMethodName = "Transfer",
        ToAddress = TokenContractAddress,
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        Params = new TransferInput { To = validProposer, Amount = 100, Symbol = "ELF" }.ToByteString()
    };
    
    // Proposal creation should fail with "Unauthorized to propose."
    var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** src/AElf.Types/Types/Address.cs (L12-18)
```csharp
        private Address(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            Value = ByteString.CopyFrom(bytes);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L34-37)
```csharp
        public static bool IsNullOrEmpty(this ByteString byteString)
        {
            return byteString == null || byteString.IsEmpty;
        }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
