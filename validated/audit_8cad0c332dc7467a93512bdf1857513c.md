# Audit Report

## Title
Insufficient Address Validation in Governance Contracts Enables Griefing Attack via Unexecutable Proposals

## Summary
The Association, Parliament, and Referendum governance contracts only validate that `ToAddress` is not null, failing to check if the internal `Value` byte array is empty. This allows whitelisted proposers to create proposals with invalid addresses that pass validation during creation and release, but fail during inline transaction execution, permanently blocking proposal release until expiry.

## Finding Description

All three governance contracts implement insufficient address validation that only checks for null object references rather than validating the internal `Value` byte array content.

**Association Contract Validation:**
The `Validate(ProposalInfo proposal)` method only verifies the Address object is not null: [1](#0-0) 

**Parliament Contract Validation:**
Parliament uses the same insufficient null-only check: [2](#0-1) 

**Referendum Contract Validation:**
Referendum also only validates null references: [3](#0-2) 

**Proper Validation Pattern:**
The codebase demonstrates the correct validation in TokenContract, which checks both the object reference AND the internal `Value`: [4](#0-3) 

**Attack Flow:**

1. A whitelisted proposer creates a proposal with `new Address()` which has `Value = ByteString.Empty`

2. The Address protobuf type allows this construction as it's a valid protobuf default value: [5](#0-4) 

3. Validation passes during CreateProposal because it only checks `!= null`

4. Organization members vote and approve the proposal normally

5. When Release is called, the proposal state is removed AFTER the inline transaction: [6](#0-5) 

6. During inline transaction execution, `GetExecutiveAsync` is called with the invalid address and throws `SmartContractFindRegistrationException`: [7](#0-6) 

7. The inline trace is marked unsuccessful, causing the parent trace to fail via recursive validation: [8](#0-7) 

8. Failed traces only have pre/post plugin state changes applied, not the main transaction's state changes: [9](#0-8) 

9. The `State.Proposals.Remove(input)` at line 198 in Association.cs never persists, leaving the proposal in an approved but permanently unexecutable state until it expires

## Impact Explanation

**Governance Denial of Service**: Organizations lose the ability to execute approved proposals, disrupting critical governance operations. Members waste significant time and effort reviewing, voting on, and attempting to execute proposals that can never succeed.

**Resource Waste**: Approved proposals remain stuck in contract state consuming storage until their expiration time (potentially days or weeks later), preventing efficient governance operations.

**Repeated Griefing**: Any whitelisted proposer can create multiple such proposals simultaneously, overwhelming the organization with unexecutable proposals and forcing them to wait for each to expire naturally.

**Trust Erosion**: Repeated failures to execute approved proposals damage member confidence in the governance system, potentially causing members to disengage from governance activities.

The severity is **Medium** because while it does not directly steal funds or compromise token supplies, it significantly disrupts critical governance infrastructure that controls protocol upgrades, treasury management, and other essential operations.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be in the organization's proposer whitelist. While this is a barrier, it is realistic in multi-organization ecosystems where various parties participate in governance (DAOs, protocol partners, delegates, etc.).

**Attack Complexity**: The attack is trivial to executeâ€”simply instantiate an Address with `Value = ByteString.Empty` when creating a proposal. No complex state manipulation, precise timing, or special conditions are required.

**Detection Difficulty**: The issue is difficult to detect before Release execution because the validation consistently passes at both creation and release time. Organization members have no way to identify such proposals before voting.

**Economic Feasibility**: The attack costs only standard transaction fees, making sustained griefing campaigns economically viable.

**Reproducibility**: The attack works consistently under normal operational conditions with no special preconditions needed.

The likelihood is **Medium** due to the low technical barrier and the realistic attacker profile of a malicious whitelisted proposer.

## Recommendation

Add proper address validation in all three governance contracts' `Validate(ProposalInfo proposal)` methods to check both the null reference AND the internal `Value` using the `IsNullOrEmpty()` extension method:

**For Association Contract:**
Modify the validation to include:
```csharp
if (proposal.ToAddress == null || proposal.ToAddress.Value.IsNullOrEmpty() || 
    string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
    !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
    return false;
```

Apply the same fix to Parliament and Referendum contracts' validation methods. This ensures consistency with the proper validation pattern already used in TokenContract.

## Proof of Concept

```csharp
[Fact]
public async Task GriefingAttack_InvalidAddress_ProposalStuck()
{
    // Setup: Create organization with proposer in whitelist
    var organizationAddress = await CreateAssociationOrganization();
    var proposer = Accounts[0].Address;
    
    // Attack: Create proposal with invalid address (empty Value)
    var invalidAddress = new Address(); // Value = ByteString.Empty by default
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ToAddress = invalidAddress, // Invalid but passes validation
            ContractMethodName = "SomeMethod",
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            Params = ByteString.Empty
        });
    
    // Proposal created successfully (validation only checked != null)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ToAddress.ShouldNotBeNull(); // Passes
    
    // Members approve the proposal
    await ApproveProposal(proposalId.Output);
    
    // Attempt to release - should fail due to invalid inline transaction
    var releaseResult = await AssociationContractStub.Release.SendWithExceptionAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid contract address");
    
    // Verify proposal is STILL in state (Remove did not persist)
    var proposalAfter = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposalAfter.ProposalId.ShouldBe(proposalId.Output); // Still exists!
    proposalAfter.ToBeReleased.ShouldBeTrue(); // Still marked as releasable
    
    // Proposal is now stuck until expiry - cannot be released
    // This demonstrates the governance DoS vulnerability
}
```

## Notes

This vulnerability affects all three governance contracts identically. The root cause is the inconsistent validation pattern compared to TokenContract. The AElf protobuf Address type allows construction with empty `Value`, which is semantically invalid for contract addresses but passes the null-only validation. The transaction execution model's state cache behavior ensures that failed inline transactions prevent parent transaction state changes from persisting, creating the stuck proposal condition.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L34-37)
```csharp
        public static bool IsNullOrEmpty(this ByteString byteString)
        {
            return byteString == null || byteString.IsEmpty;
        }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L149-161)
```csharp
        IExecutive executive;
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```
