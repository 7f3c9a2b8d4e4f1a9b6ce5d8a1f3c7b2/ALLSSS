# Audit Report

## Title
Term Change Deadlock Due to Threshold Mismatch Between Total and Active Miners

## Summary
The AEDPoS consensus mechanism contains a critical logic flaw where term transitions can be indefinitely blocked when more than one-third of miners go offline. The `NeedToChangeTerm()` method compares the count of active miners against a threshold calculated from total miners, creating a mathematically unreachable condition that prevents essential state updates including miner list changes, reward distributions, and election snapshots.

## Finding Description

The vulnerability exists in the term transition decision logic within the consensus system. When determining whether to proceed to the next term, the system uses `GetConsensusBehaviourToTerminateCurrentRound()` [1](#0-0) , which calls `NeedToChangeTerm()` to evaluate if the term period has elapsed and sufficient consensus exists.

The root cause is a threshold calculation mismatch. The `MinersCountOfConsent` property calculates the required threshold as `(TotalMiners * 2 / 3) + 1` based on all miners in `RealTimeMinersInformation.Count` [2](#0-1) .

However, `NeedToChangeTerm()` only counts miners who have actually mined blocks by filtering with `.Where(m => m.ActualMiningTimes.Any())` [3](#0-2) . This creates an impossible condition: if more than 1/3 of the total miners are offline or haven't mined, the active miner count can never reach the threshold, causing `NeedToChangeTerm()` to always return false.

When this occurs, the system executes `ProcessNextRound()` instead of `ProcessNextTerm()` [4](#0-3) . This bypasses critical operations that only `ProcessNextTerm()` performs [5](#0-4) , including:

1. Term number updates [6](#0-5) 
2. Miner list updates via `SetMinerList()` [7](#0-6) 
3. Mining reward donations [8](#0-7) 
4. Treasury releases [9](#0-8) 
5. Election snapshots [10](#0-9) 

## Impact Explanation

The impact is severe and affects multiple critical blockchain operations:

**Consensus State Corruption:** The round number advances while the term number remains frozen, creating state desynchronization. New election results cannot be applied since miner list updates only occur in `ProcessNextTerm()` [11](#0-10) , leaving elected candidates unable to join the active miner set.

**Economic Impact:** Mining rewards accumulate but are never distributed to miners or the treasury through the `DonateMiningReward()` mechanism. Vote-based dividends cannot be calculated without election snapshots, harming voters and delegators.

**Duration:** This deadlock persists until offline miners are detected as evil nodes after exceeding `TolerableMissedTimeSlotsCount` (4,320 slots ≈ 3 days) [12](#0-11) , after which replacement occurs via `TryToDetectEvilMiners()` [13](#0-12)  and detection logic in `ProcessNextRound()` [14](#0-13) .

All network participants are affected: miners don't receive earned rewards, voters don't receive dividends, and elected candidates cannot become active validators despite winning elections.

## Likelihood Explanation

This vulnerability has medium-high likelihood because it requires no malicious actors—only natural network conditions. In a typical small network with 7 miners requiring 5 for consensus (2/3 + 1), if 3 miners experience simultaneous downtime during the term transition period, the deadlock triggers automatically.

The scenario is realistic given:
- Geographic distribution causing connectivity issues
- Infrastructure maintenance windows
- Hardware failures or power outages
- Network partitions

Larger networks (17+ miners) have more redundancy but remain vulnerable if more than 1/3 experience coordinated issues (e.g., cloud provider outages affecting multiple nodes).

Detection is low—operators may observe round/term number divergence but might assume the system is waiting for consensus rather than being deadlocked. The `ActualMiningTimes` tracking mechanism [15](#0-14)  only populates when miners successfully produce blocks, so offline miners will have empty `ActualMiningTimes` arrays indefinitely until they return or are marked as evil.

## Recommendation

Modify the `NeedToChangeTerm()` method to use consistent miner counting. The threshold should either:

1. **Option A (Recommended):** Use only active miners for both threshold calculation and counting:
```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var activeMiners = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .ToList();
    
    var activeMinersThreshold = activeMiners.Count.Mul(2).Div(3).Add(1);
    
    return activeMiners
        .Select(m => m.ActualMiningTimes.Last())
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds))
        >= activeMinersThreshold;
}
```

2. **Option B:** Use total miners for counting by checking expected mining time instead of actual:
```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    return RealTimeMinersInformation.Values
        .Select(m => m.ActualMiningTimes.Any() ? m.ActualMiningTimes.Last() : m.ExpectedMiningTime)
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds))
        >= MinersCountOfConsent;
}
```

Option A is safer as it ensures term changes only occur when sufficient active consensus exists, while Option B may force premature term changes based on expected rather than actual mining times.

## Proof of Concept

```csharp
// Test scenario demonstrating the deadlock
// Network: 7 miners, threshold = 5 (2/3 + 1)
// 3 miners go offline, leaving 4 active
// Term transition attempted at period boundary

var round = new Round
{
    RoundNumber = 100,
    TermNumber = 2,
    RealTimeMinersInformation = 
    {
        // 4 active miners with ActualMiningTimes
        {"miner1", new MinerInRound { Pubkey = "miner1", ActualMiningTimes = { pastTermTimestamp } }},
        {"miner2", new MinerInRound { Pubkey = "miner2", ActualMiningTimes = { pastTermTimestamp } }},
        {"miner3", new MinerInRound { Pubkey = "miner3", ActualMiningTimes = { pastTermTimestamp } }},
        {"miner4", new MinerInRound { Pubkey = "miner4", ActualMiningTimes = { pastTermTimestamp } }},
        
        // 3 offline miners with empty ActualMiningTimes
        {"miner5", new MinerInRound { Pubkey = "miner5", ActualMiningTimes = { } }},
        {"miner6", new MinerInRound { Pubkey = "miner6", ActualMiningTimes = { } }},
        {"miner7", new MinerInRound { Pubkey = "miner7", ActualMiningTimes = { } }}
    }
};

// MinersCountOfConsent = (7 * 2 / 3) + 1 = 5
var threshold = round.MinersCountOfConsent; // Returns 5

// NeedToChangeTerm only counts active miners (4)
var needsTermChange = round.NeedToChangeTerm(blockchainStart, 2, termPeriod);

// Result: false (4 < 5), term change blocked despite period elapsed
Assert.False(needsTermChange); // Deadlock occurs
```

## Notes

The vulnerability is exacerbated by the `GenerateNextRoundInformation()` method [16](#0-15) , which increments `MissedTimeSlots` for offline miners but does not populate their `ActualMiningTimes`. This means offline miners remain excluded from the term change consensus calculation until they either return online or accumulate enough missed slots to be marked as evil nodes and replaced.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```
