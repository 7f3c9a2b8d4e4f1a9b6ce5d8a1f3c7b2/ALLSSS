# Audit Report

## Title
Off-by-One Error in CheckResourceToken Blocks Solvent Contracts from Execution

## Summary
The `CheckResourceToken` method contains an off-by-one error using strict greater-than comparison (`balance > owningBalance`) instead of greater-than-or-equal (`balance >= owningBalance`). This prevents contracts with exactly sufficient balance to match their accumulated resource token debt from executing transactions, creating an operational denial-of-service condition for solvent contracts.

## Finding Description

The vulnerability exists in the `CheckResourceToken` method which executes as a pre-plugin transaction before every method call on ACS8-compliant contracts. [1](#0-0) 

The assertion uses a strict greater-than comparison that incorrectly rejects the valid break-even state where `balance == owningBalance`. A contract in this state has exactly enough balance to cover its historical maximum debt and should be considered solvent.

**Root Cause**: The `OwningResourceToken` state variable tracks cumulative resource token debt. [2](#0-1)  When contracts cannot pay resource fees during transaction execution, the deficit is recorded and accumulated in this state variable. [3](#0-2) 

**Critical Issue**: The debt counter never decreases. Analysis of all write operations to `State.OwningResourceToken` confirms it only accumulates through a single write location - there is no debt clearing logic in `PayResourceTokens`. This contrasts with the `PayRental` method which does clear `OwningRental` debt [4](#0-3)  (though `PayRental` also suffers from the same off-by-one issue on line 1051).

**Inconsistency Evidence**: The related `ChargeResourceToken` method validates current transaction resource needs using the correct `>=` comparison, demonstrating that equality should be acceptable. [5](#0-4) 

**Execution Flow**:
1. Contract accumulates resource token debt when balance is insufficient during resource payment
2. Owner tops up contract to exactly `owningBalance` amount  
3. `CheckResourceToken` pre-plugin executes automatically before next transaction [6](#0-5) 
4. Assertion `balance > owningBalance` fails (100 > 100 = false)
5. Transaction reverts with error: "Contract balance of {symbol} token is not enough. Owning {owningBalance}."
6. Contract remains blocked until receiving at least 1 additional token

## Impact Explanation

**Operational Denial-of-Service**: Contracts with `balance == owningBalance` are in a solvent break-even state - they have exactly enough balance to cover their historical maximum debt. However, the strict `>` check incorrectly treats this as insufficient, preventing all contract method execution.

**Permanent Penalty**: Since `OwningResourceToken` never decreases (only accumulates), contracts must maintain perpetual excess balance beyond their debt to remain operational. This creates an artificial economic barrier where exact debt recovery is insufficient.

**Affected Parties**:
- Any ACS8 contract that has historically accumulated resource token debt
- Contract owners attempting to restore operations by transferring exact debt amounts
- Users unable to interact with contracts stuck at break-even balance

**Severity**: Medium - causes operational denial-of-service affecting contract availability and user experience, but does not result in direct fund loss. Workaround exists (send 1 extra token), but represents flawed economic logic that contradicts the semantic meaning of "solvent."

## Likelihood Explanation

**High Likelihood**: This issue is easily triggered during normal contract operations without any special setup or attacker actions.

**Triggering Scenario**:
1. Contract operates normally until resource token balance is exhausted
2. Transaction attempts with insufficient balance accumulate debt in `OwningResourceToken`
3. Contract owner or user calculates exact debt amount and transfers it to contract
4. Next transaction attempt automatically triggers `CheckResourceToken` pre-plugin
5. Assertion fails, contract remains blocked

**No Special Permissions Required**: The `CheckResourceToken` method executes automatically as a pre-plugin transaction for all ACS8 contracts - any user attempting to call a contract method will trigger this validation.

**Natural User Behavior**: Users attempting "exact recovery" by transferring precisely the debt amount is a completely natural scenario, making this highly likely to occur in production environments.

## Recommendation

Change the comparison operator from strict greater-than (`>`) to greater-than-or-equal (`>=`) to accept the valid break-even state:

```csharp
Assert(balance >= owningBalance,
    $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
```

Additionally, consider implementing debt clearing logic similar to `PayRental` to reduce the perpetual balance requirement, or apply the same fix to `PayRental` at line 1051.

## Proof of Concept

The existing test suite demonstrates the failure condition: [7](#0-6) 

To reproduce:
1. Deploy an ACS8-compliant contract
2. Execute transactions until resource tokens are exhausted, accumulating debt
3. Transfer exact debt amount to the contract (balance == owningBalance)
4. Attempt to call any contract method
5. Observe transaction revert with "token is not enough. Owning" error
6. Transfer 1 additional token to unblock (balance > owningBalance)

## Notes

The vulnerability is confirmed by examining the complete resource token debt management system. The inconsistency between `CheckResourceToken` (using `>`) and `ChargeResourceToken` (using `>=`) demonstrates this is a logical error rather than intentional design. The fact that `OwningResourceToken` never decreases while `OwningRental` does get cleared further highlights the flawed implementation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L580-581)
```csharp
            Assert(existingBalance >= pair.Value,
                $"Insufficient resource of {pair.Key}. Need balance: {pair.Value}; Current balance: {existingBalance}.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L609-610)
```csharp
            Assert(balance > owningBalance,
                $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L970-974)
```csharp
                if (amount > existingBalance)
                {
                    var owned = amount.Sub(existingBalance);
                    var currentOwning = State.OwningResourceToken[bill.ContractAddress][symbol].Add(owned);
                    State.OwningResourceToken[bill.ContractAddress][symbol] = currentOwning;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1051-1057)
```csharp
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L29-32)
```csharp
    /// <summary>
    ///     Contract Address -> (Owning) Resource Token Symbol -> Amount.
    /// </summary>
    public MappedState<Address, string, long> OwningResourceToken { get; set; }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/ResourceConsumptionPreExecutionPlugin.cs (L62-67)
```csharp
        var checkResourceTokenTransaction = tokenStub.CheckResourceToken.GetTransaction(new Empty());

        return new List<Transaction>
        {
            checkResourceTokenTransaction
        };
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee.Tests/ExecutionPluginForResourceFeeTest.cs (L360-365)
```csharp
    public async Task CheckResourceToken_Fail_Test()
    {
        await TestContractStub.CpuConsumingMethod.SendWithExceptionAsync(new Empty());
        var checkResourceTokenRet = await TestContractStub.CpuConsumingMethod.SendWithExceptionAsync(new Empty());
        checkResourceTokenRet.TransactionResult.Error.ShouldContain("token is not enough. Owning");
    }
```
