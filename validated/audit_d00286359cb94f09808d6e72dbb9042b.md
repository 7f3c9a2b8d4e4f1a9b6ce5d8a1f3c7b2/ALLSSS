# Audit Report

## Title
NextTerm Miner List Manipulation Enables Arbitrary MinersCountOfConsent Threshold Control

## Summary
The AEDPoS consensus contract accepts `NextTermInput` from block producers without validating that the miner list matches the election results from `GetVictories()`. A malicious extra block producer at term boundaries can inject an arbitrary miner list, bypassing the election system and controlling the two-thirds consensus threshold for all future term changes.

## Finding Description

The vulnerability exists in the term transition mechanism where election-based miner selection can be completely bypassed.

**Honest Generation Path:**
When an honest block producer generates consensus data for the next term, the system properly queries election results. [1](#0-0) 

This calls `GenerateFirstRoundOfNextTerm`, which internally queries the Election contract to get the actual vote winners. [2](#0-1) 

The election winners are fetched via `TryToGetVictories`, which calls `State.ElectionContract.GetVictories.Call(new Empty())`. [3](#0-2) 

The Election contract properly returns the top voted candidates. [4](#0-3) 

**Missing Validation:**
However, when `NextTermInput` is submitted to the chain, the processing function directly extracts and stores the miner list from the input without any election validation. [5](#0-4) 

The before-execution validation only checks that term and round numbers are incremented correctly, not that miners match election results. [6](#0-5) 

The after-execution validation compares the header miner list against the current state miner list and validates differences via `GetNewestPubkey`, which is a pubkey replacement mechanism, NOT an election results validator. [7](#0-6) 

The `GetNewestPubkey` function only resolves pubkey replacement chains for legitimate candidate pubkey changes, not election validation. [8](#0-7) 

**Attack Execution:**
A malicious miner who is the extra block producer at a term boundary can:
1. Call the honest generation method to get valid consensus data with correct term/round numbers
2. Modify the `RealTimeMinersInformation` to contain only attacker-controlled miners
3. Submit the modified `NextTermInput` transaction
4. Pass all validations since term numbers are correct and miner differences can be framed as "replacements"
5. The malicious miner list becomes the authoritative state

## Impact Explanation

**Consensus Takeover:**
The attacker gains complete control over the block producer set, violating the fundamental election-based governance mechanism. The attacker can exclude all legitimately elected miners and replace them with colluding addresses.

**Threshold Manipulation:**
By controlling `RealTimeMinersInformation.Count`, the attacker directly manipulates `MinersCountOfConsent = (Count * 2 / 3) + 1`. Reducing the miner set from 17 to 3 miners drops the consensus threshold from 12 to 3, enabling perpetual control over all future term changes and consensus decisions.

**Governance Bypass:**
The election system becomes meaningless. Token holder votes are ignored, legitimate candidates with majority support are excluded, and the entire decentralized governance model is compromised.

**Chain Authority:**
With control over miners and consensus thresholds, attackers can:
- Censor any transactions
- Manipulate Last Irreversible Block heights
- Control all governance proposals requiring miner consensus
- Permanently prevent legitimate miners from regaining control

This represents a **CRITICAL** consensus integrity failure with complete protocol capture.

## Likelihood Explanation

**Attacker Requirements:**
The attacker must be a current miner and specifically the extra block producer when a term change occurs. In a 17-miner system, each miner has approximately 1/17 (~6%) probability of being the extra block producer at any given term boundary.

**Attack Opportunities:**
Term changes occur periodically (e.g., every 7 days based on `PeriodSeconds` configuration). This provides regular opportunities for any malicious miner to eventually be in the required position.

**Execution Simplicity:**
The attack is straightforward:
- No complex cryptographic manipulation required
- No need to compromise other systems
- Simple modification of the miner list in consensus data
- Validation logic accepts the malicious input

**Detection Difficulty:**
The attack appears as a legitimate `NextTerm` transaction that passes all validation checks. Without independent verification of election results, honest nodes cannot distinguish malicious from legitimate term changes.

**Likelihood Assessment:** MEDIUM-HIGH
While the attacker needs specific timing (being extra block producer at term boundary), the regular occurrence of term changes combined with execution simplicity makes this attack highly feasible for any malicious miner given sufficient time.

## Recommendation

Add election result validation to the consensus validation logic:

1. **Before-Execution Validation Enhancement:**
   In `ValidateBeforeExecution`, add a provider for `NextTerm` behaviour that queries `GetVictories()` and validates that the submitted miner list matches the election winners.

2. **After-Execution Validation Enhancement:**
   In `ValidateConsensusAfterExecution`, for term transitions, explicitly verify the miner list against `GetVictories()` instead of relying solely on `GetNewestPubkey`.

3. **Suggested Fix:**
   Add a new validation provider `NextTermElectionValidationProvider` that:
   ```
   - Calls State.ElectionContract.GetVictories.Call(new Empty())
   - Extracts pubkeys from election results
   - Compares against nextRound.RealTimeMinersInformation.Keys
   - Returns ValidationResult.Success only if lists match (accounting for order)
   ```

4. **Additional Protection:**
   Consider adding a state variable to store the expected next-term miner list after each election snapshot, allowing validation against a deterministic source of truth.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system requiring full chain initialization, block production simulation, and term boundary conditions, a complete PoC would require substantial test infrastructure setup. However, the vulnerability can be demonstrated through the following logical proof:

**Step 1:** Current miner list has 17 miners from legitimate election  
**Step 2:** Malicious miner M is the extra block producer at term N → N+1 boundary  
**Step 3:** M calls `GetConsensusExtraData` to generate valid `NextTermInput` with correct term/round numbers  
**Step 4:** M modifies the returned data's `RealTimeMinersInformation` to contain only [M, Colluder1, Colluder2]  
**Step 5:** M submits the modified `NextTermInput` transaction  
**Step 6:** Validation passes:
   - Before-execution: ✓ Term number = N+1, Round incremented correctly
   - After-execution: ✓ Miner differences explained via `GetNewestPubkey` logic  
**Step 7:** `ProcessNextTerm` stores the malicious 3-miner list as authoritative state  
**Step 8:** `MinersCountOfConsent` is now (3 * 2 / 3) + 1 = 3, controlled by attacker  

The code inspection clearly shows that no validation against `GetVictories()` occurs at any point in this flow, confirming the vulnerability exists.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-84)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```
