# Audit Report

## Title
Unbounded Nested Loop Complexity in Consensus Round Update Causes Block Production Denial of Service

## Summary
The `ApplyNormalConsensusData` function in the AEDPoS consensus contract contains nested loops with O(c×n²) computational complexity that can exceed AElf's execution branch threshold of 15,000, causing block production to fail with `RuntimeBranchThresholdExceededException`. When governance legitimately scales `MaximumMinersCount` to 100+ miners and order conflicts occur, the conflict resolution algorithm triggers excessive branch counting, halting consensus operations.

## Finding Description

The vulnerability exists in the consensus round update logic where miners calculate their next-round order assignments. The nested loop structure creates O(c×n²) complexity in the conflict resolution algorithm. [1](#0-0) 

The outer `foreach` iterates over miners with duplicate `FinalOrderOfNextRound` values (conflicts), the inner `for` loop searches up to `2×minersCount` positions, and the `All()` method checks all `minersCount` miners for each candidate position. [2](#0-1) 

This function is invoked during normal block production through the following execution path:

1. Block production calls the ACS4 standard method `GetConsensusExtraData` [3](#0-2) 

2. Which delegates to `GetConsensusBlockExtraData` that routes to `GetConsensusExtraDataToPublishOutValue` for UpdateValue behavior [4](#0-3) 

3. Which invokes the vulnerable `ApplyNormalConsensusData` function [5](#0-4) 

The critical failure point is that `SetMaximumMinersCount` has no upper bound validation beyond checking the value is positive. [6](#0-5) 

AElf enforces execution limits through branch counting at the IL level. The branch threshold is hardcoded at 15,000. [7](#0-6) 

The execution observer increments the branch counter at every backward branch instruction (loop iteration) and throws `RuntimeBranchThresholdExceededException` when the threshold is reached. [8](#0-7) 

The IL patcher automatically injects branch counting calls at loop entry points during contract compilation. [9](#0-8) 

Order assignment is hash-based, creating natural collision probability. [10](#0-9) 

With minersCount=100 and conflicts=3, the total branch count reaches approximately 60,000 (3 × 200 × 100), which is 4× over the 15,000 threshold, causing block production to fail.

## Impact Explanation

**Operational DoS of Consensus:**
- When `ApplyNormalConsensusData` exceeds the branch threshold, it throws `RuntimeBranchThresholdExceededException`, preventing the miner from generating valid consensus extra data
- The miner cannot produce a block, as the exception occurs during the critical `GetConsensusExtraData` call required for block header generation
- If multiple miners encounter this condition simultaneously, the blockchain experiences block production delays or complete halts
- Recovery requires emergency governance action to reduce `MaximumMinersCount`, which paradoxically requires functional block production to execute the governance proposal

**Quantified Threshold Breach:**
- minersCount=50, conflicts=6: ~30,000 branches (2× over threshold)
- minersCount=100, conflicts=3: ~60,000 branches (4× over threshold)
- minersCount=200, conflicts=2: ~160,000 branches (10.7× over threshold)

**Severity Justification:**
High severity because it causes operational DoS of the core consensus mechanism. While it requires governance to set enabling parameters, this is a legitimate network scaling action, not a malicious configuration. The vulnerability breaks the availability guarantee of the consensus protocol.

## Likelihood Explanation

**Preconditions:**
1. Governance sets `MaximumMinersCount` to 100+ through Parliament proposal (legitimate network scaling)
2. Order conflicts occur among miners through hash collisions on `FinalOrderOfNextRound` values

**Attack Complexity:**
- Medium-High: Does not require compromising governance or any privileged keys
- Natural network scaling toward 100+ miners is a predictable evolution for a growing blockchain
- Hash-based order assignment creates natural collision probability due to the birthday paradox
- With 100 miners, conflicts accumulate as miners produce blocks within a round
- The conflict list persists across block productions within the same round, as `FinalOrderOfNextRound` values are used when generating the next round [11](#0-10) 

**Feasibility:**
- Execution limits are enforced at runtime during block production in all contract executions
- No complexity checks or upper bounds exist on miner count
- Reachable through standard consensus flow via the public ACS4 `GetConsensusExtraData` method without special permissions
- Even consensus contract methods are subject to the branch threshold despite being fee-exempt

**Probability Reasoning:**
Medium-to-High likelihood as the chain matures. Current 17-miner configuration is safe, but scaling toward 50-100 miners creates a critical risk zone. Natural network evolution makes this increasingly probable, and conflicts are statistically inevitable with hash-based ordering at scale.

## Recommendation

Implement multiple mitigations:

1. **Add upper bound validation in `SetMaximumMinersCount`:**
```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    Assert(input.Value <= 50, "Miner count exceeds safe threshold for conflict resolution.");
    
    // ... rest of method
}
```

2. **Optimize the conflict resolution algorithm to reduce complexity:**
    - Replace the nested `All()` check with a `HashSet<int>` lookup for O(1) order checking
    - Add early termination if conflicts cannot be resolved within a reasonable iteration limit
    - Consider pre-computing available orders instead of searching linearly

3. **Alternative conflict resolution strategy:**
    - Implement a deterministic conflict resolution that doesn't require iterating through all miners
    - Use a secondary hash or round-robin assignment for conflicted miners

4. **Add monitoring and circuit breaker:**
    - Track conflict counts and miner count in consensus metrics
    - Implement warnings when approaching dangerous combinations

## Proof of Concept

A test demonstrating the vulnerability would involve:

```csharp
[Fact]
public async Task Test_ApplyNormalConsensusData_ExceedsBranchThreshold()
{
    // Setup: Create a round with 100 miners
    var minersCount = 100;
    var round = GenerateRoundWithMiners(minersCount);
    
    // Create 3 conflicts by setting duplicate FinalOrderOfNextRound
    var conflictOrder = 42;
    var conflictingMiners = round.RealTimeMinersInformation.Values.Take(3).ToList();
    foreach (var miner in conflictingMiners)
    {
        miner.FinalOrderOfNextRound = conflictOrder;
    }
    
    // Attempt to apply consensus data for a new miner
    var newMiner = "new_miner_pubkey";
    var signature = Hash.FromString("test_signature");
    
    // This should throw RuntimeBranchThresholdExceededException
    // because: 3 conflicts × 200 iterations × 100 All() checks = 60,000 branches
    Assert.Throws<RuntimeBranchThresholdExceededException>(() =>
    {
        round.ApplyNormalConsensusData(newMiner, Hash.Empty, Hash.Empty, signature);
    });
}
```

The test would fail on current code, confirming that the branch threshold is exceeded when the specified conditions are met during normal consensus operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-30)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/CallAndBranchCounts/Patcher.cs (L80-92)
```csharp
        static bool IsValidInstruction(Instruction instruction)
        {
            var targetInstruction = (Instruction) instruction.Operand;
            return targetInstruction.Offset < instruction.Offset; // What does this mean?
        }

        foreach (var instruction in AllBranchingInstructions.Where(IsValidInstruction))
        {
            var jumpingDestination = (Instruction) instruction.Operand;
            var callBranchCountMethod = processor.Create(OpCodes.Call, _proxy.BranchCountMethod);
            processor.InsertBefore(jumpingDestination, callBranchCountMethod);
            instruction.Operand = callBranchCountMethod;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-28)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
```
