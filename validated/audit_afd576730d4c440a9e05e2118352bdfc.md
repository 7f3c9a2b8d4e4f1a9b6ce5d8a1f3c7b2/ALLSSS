# Audit Report

## Title
Mining Order Collision via Unchecked TuneOrderInformation Allows Time Slot Conflicts and Consensus Disruption

## Summary
The AEDPoS consensus contract allows malicious miners to inject colliding `FinalOrderOfNextRound` values through consensus extra data without validation, causing multiple miners to be assigned identical mining time slots in subsequent rounds. This breaks the fundamental consensus invariant of unique time slot assignment per miner.

## Finding Description

The vulnerability exists in the consensus round update flow where order collision validation is completely missing for `UpdateValue` behavior.

**Root Cause:**

The `ProcessUpdateValue` method directly applies `TuneOrderInformation` from consensus extra data without validating uniqueness of `FinalOrderOfNextRound` values. [1](#0-0) 

More critically, during validation, `RecoverFromUpdateValue` is called to reconstruct the round state from the provided consensus extra data, blindly copying all `FinalOrderOfNextRound` values for all miners from the attacker-controlled Round object. [2](#0-1)  This happens at validation time before any validation providers execute. [3](#0-2) 

**Missing Validation:**

For `UpdateValue` behavior, the validation pipeline only includes `UpdateValueValidationProvider` and `LibInformationValidationProvider`. [4](#0-3) 

The `UpdateValueValidationProvider` only validates that OutValue/Signature are filled and that PreviousInValue is correct - it performs no order collision checks. [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` exists but is only used for `NextRound` behavior, not `UpdateValue`. [6](#0-5) 

**How Legitimate Collision Resolution is Bypassed:**

Normal flow uses collision resolution in `ApplyNormalConsensusData` when honest miners generate consensus extra data. [7](#0-6)  This method is called during consensus extra data generation. [8](#0-7) 

However, a malicious miner can:

1. Generate legitimate consensus extra data with collision-resolved orders
2. Modify the simplified `Round` object in consensus extra data after `GetUpdateValueRound` creates it to inject colliding `FinalOrderOfNextRound` values
3. Include this modified data in their block header

The simplified Round in consensus extra data includes `FinalOrderOfNextRound` for all miners, not just the current miner. [9](#0-8)  This simplified Round is used when `isGeneratingTransactions` is false. [10](#0-9) 

**Direct Impact on Next Round Generation:**

When the next round is generated, miners' `Order` values are directly assigned from their `FinalOrderOfNextRound`. [11](#0-10) 

Multiple miners with identical `FinalOrderOfNextRound` values will receive identical `Order` values and identical `ExpectedMiningTime` values, creating a time slot collision where multiple miners believe they should mine at exactly the same time.

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation:**

- **Broken Invariant:** The core consensus mechanism requires each miner to have a unique time slot. This vulnerability allows multiple miners to be assigned the same time slot, breaking this fundamental guarantee.

- **Consensus Disruption:** When multiple miners have identical `ExpectedMiningTime` values, both will attempt to mine at the same time, creating race conditions and potential consensus stalls.

- **No Recovery Mechanism:** Once colliding orders are written to state via `ProcessUpdateValue`, they persist until the next term transition. The network may fail to make progress during this period.

- **Blockchain Availability Impact:** Critical miners being assigned duplicate slots can prevent block production entirely if they're unable to coordinate who should actually mine.

- **Exploit Scope:** Any active miner can execute this attack, affecting all subsequent rounds until term transition.

## Likelihood Explanation

**HIGH Likelihood:**

**Attacker Requirements:**
- Must be an active miner (block producer) in the current consensus set
- Requires modified node software to craft malicious consensus extra data
- No additional governance permissions or key compromise needed

**Attack Complexity:**
- Straightforward technical execution - simply modify the `FinalOrderOfNextRound` values in the Round object after honest generation but before including in block header
- No complex cryptographic operations required
- No timing constraints or race conditions to exploit
- Single malicious block can inject colliding orders

**Feasibility:**
- Being in the active miner set is the intended precondition for participating in consensus
- Modifying consensus extra data before signing the block header is trivial with custom node software
- The malicious data passes all existing validations because `RecoverFromUpdateValue` loads it before validation providers run, and no validation provider checks for order uniqueness
- Attack persists across multiple rounds until term transition

**Detection:**
- Malicious input appears structurally valid to all existing validation providers
- Collision only becomes apparent when next round is generated
- No automated on-chain detection or rejection mechanism exists

## Recommendation

Add order collision validation for `UpdateValue` behavior:

1. **Add collision check in validation pipeline:** Include `NextRoundMiningOrderValidationProvider` for `UpdateValue` behavior, or create a dedicated order uniqueness validator.

2. **Enhance NextRoundMiningOrderValidationProvider:** The current implementation uses `.Distinct()` on `MinerInRound` objects rather than on the `FinalOrderOfNextRound` values themselves. It should validate uniqueness of the actual order values:

```csharp
var ordersWithValues = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (ordersWithValues.Count != ordersWithValues.Distinct().Count())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}
```

3. **Validate TuneOrderInformation:** Add explicit validation in `ProcessUpdateValue` to ensure no duplicate values exist in the tuning information before applying it.

4. **Add state-level validation:** Before updating round information, verify that all `FinalOrderOfNextRound` values in the round are unique.

## Proof of Concept

```csharp
[Fact]
public async Task MiningOrderCollision_Via_MaliciousUpdateValue_Test()
{
    // Initialize consensus with multiple miners
    await InitializeCandidates(5);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // First miner produces a normal block to establish round state
    var firstMiner = firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order).First();
    var firstMinerKeyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == firstMiner.Pubkey);
    KeyPairProvider.SetKeyPair(firstMinerKeyPair);
    BlockTimeProvider.SetBlockTime(firstMiner.ExpectedMiningTime);
    
    var trigger = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(firstMinerKeyPair.PublicKey),
        InValue = HashHelper.ComputeFrom("test_hash"),
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    // Get legitimate consensus extra data (with proper collision resolution)
    var headerInfo = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(trigger.ToBytesValue()))
        .ToConsensusHeaderInformation();
    
    // ATTACK: Modify the Round object to inject colliding FinalOrderOfNextRound
    var maliciousRound = headerInfo.Round;
    var allMiners = maliciousRound.RealTimeMinersInformation.Values.ToList();
    
    // Make two different miners have the same FinalOrderOfNextRound
    if (allMiners.Count >= 2)
    {
        allMiners[0].FinalOrderOfNextRound = 3;
        allMiners[1].FinalOrderOfNextRound = 3; // COLLISION!
    }
    
    // Extract update input with malicious Round
    var randomNumber = await GenerateRandomProofAsync(firstMinerKeyPair);
    var maliciousInput = maliciousRound.ExtractInformationToUpdateConsensus(
        firstMiner.Pubkey, 
        ByteString.CopyFrom(randomNumber));
    
    // This should fail but doesn't due to missing validation
    var result = await GetAEDPoSContractStub(firstMinerKeyPair).UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Malicious block accepted!
    
    // Verify collision persists in state
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minersWithOrder3 = updatedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound == 3)
        .ToList();
    
    minersWithOrder3.Count.ShouldBeGreaterThan(1); // COLLISION CONFIRMED!
    
    // When next round is generated, both miners will get same time slot
    // This breaks the consensus invariant of unique time slots per miner
}
```

## Notes

This vulnerability specifically affects the `UpdateValue` consensus behavior path. The attack leverages the fact that `RecoverFromUpdateValue` is called during validation (before validation providers run) and blindly trusts the `FinalOrderOfNextRound` values in the attacker-controlled consensus extra data. The normal collision resolution in `ApplyNormalConsensusData` is bypassed because the attacker modifies the Round object after it's been generated with proper collision resolution but before signing the block.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
