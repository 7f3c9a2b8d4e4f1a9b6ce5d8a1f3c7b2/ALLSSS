# Audit Report

## Title
Retroactive Vote Invalidation via Strategic Member Removal in Association Governance

## Summary
The Association contract's vote counting mechanism filters votes against the current organization member list, allowing votes from previously removed members to be retroactively invalidated. This enables manipulation of governance outcomes by removing members after they vote, causing their votes to no longer count toward threshold calculations.

## Finding Description

The vulnerability exists in the temporal inconsistency between vote casting and vote counting in the Association contract.

When members vote on a proposal, their addresses are stored in the proposal's vote lists. [1](#0-0) [2](#0-1) [3](#0-2)  The voting methods validate current membership when the vote is cast. [4](#0-3) [5](#0-4) [6](#0-5) 

However, when checking if a proposal can be released, the vote counting logic filters votes against the **current** organization member list rather than preserving the validity of votes cast when the voter was a member. [7](#0-6) 

Specifically, the vote counting uses `.Count(organization.OrganizationMemberList.Contains)` which only counts votes from addresses that are **currently** members:
- Rejection counting: [8](#0-7) 
- Abstention counting: [9](#0-8) 
- Approval counting: [10](#0-9) 

The `Contains()` method simply checks current membership without any historical validation. [11](#0-10) 

The `RemoveMember` method can be called through the organization's proposal mechanism. [12](#0-11)  When a proposal is released, the organization's virtual address becomes `Context.Sender`, allowing member management actions to be executed through governance. [13](#0-12) 

**Root Cause**: Vote lists store only addresses without timestamps or membership snapshots. [14](#0-13)  This allows the vote counting logic to retroactively filter out votes from members who were valid at voting time but were subsequently removed.

**Why Existing Protections Fail**: While `AssertIsAuthorizedOrganizationMember` validates membership when voting, [15](#0-14)  there is no mechanism to preserve vote validity after a member is removed. The validation at vote-counting time re-checks membership, creating the temporal vulnerability.

## Impact Explanation

**Concrete Harm**:
- **Governance Manipulation**: Attackers can block legitimate proposals by removing members who approved them, causing approval counts to fall below thresholds
- **Vote Invalidation**: Members who voted in good faith have their votes retroactively nullified without their consent
- **Proposal Blocking**: Proposals that met release thresholds can be prevented from execution by strategically removing approvers
- **Proposal Forcing**: Malicious proposals can be pushed through by removing members who rejected them

**Attack Scenario**:
1. Organization has 5 members with threshold requiring 3 approvals
2. Proposal P1 receives 3 approvals from members A, B, C (meets threshold at approval time)
3. Attacker creates Proposal P2 to call `RemoveMember` for member A
4. Proposal P2 passes with votes from B, C, and others
5. P2 executes through `Release`, removing A from the organization member list
6. When P1's release is attempted, `IsReleaseThresholdReached` recounts votes using current membership
7. Only 2 approvals count (B and C) because A is no longer in `organization.OrganizationMemberList`
8. P1 can no longer be released despite having met requirements when voted

**Who Is Affected**: All Association-based organizations using the governance mechanism, including multi-signature wallets and DAOs built on this contract.

**Severity Justification**: HIGH - This directly undermines the integrity of the governance system, allowing manipulation of proposal outcomes through retroactive vote invalidation. It violates the fundamental invariant that validly cast votes should maintain their validity unless explicitly changed through proper governance reconsideration processes.

## Likelihood Explanation

**Attacker Capabilities**: Only requires ability to create proposals and coordinate votes - standard governance participation. No special privileges beyond being an authorized proposer and having sufficient member support.

**Attack Complexity**: Medium - Requires:
1. Creating a member removal proposal concurrent with or after the target proposal
2. Coordinating sufficient votes to pass the removal proposal
3. Executing the removal before the target proposal is released

**Feasibility Conditions**:
- Multiple active proposals can exist simultaneously (proposals are identified by hash, allowing concurrent existence)
- `RemoveMember` is a standard governance action callable via proposals through the `Release` mechanism
- No time locks or delays prevent immediate removal
- Vote recounting happens on every `GetProposal` call and during `Release` execution

**Detection Constraints**: Difficult to detect as member management is a legitimate governance function. The attack leaves no obvious trace distinguishing it from normal organizational restructuring.

**Economic Rationality**: Transaction cost is comparable to any governance action (gas fees + coordination effort). The benefit is control over high-value proposals (treasury transfers, permission changes, contract upgrades, etc.).

**Probability**: HIGH - The attack vector is straightforward, requires no special setup beyond normal governance participation, and can be executed through standard contract operations.

## Recommendation

Implement vote validity preservation by capturing membership status at vote time. Two approaches:

**Option 1**: Store membership snapshot with each vote
- Modify ProposalInfo to include a mapping of voter addresses to membership proof/timestamp
- Validate votes against their historical membership status rather than current list

**Option 2**: Make votes immutable once cast
- Once a valid member votes, their vote remains valid regardless of subsequent membership changes
- Only allow vote changes through explicit revote mechanisms

**Option 3**: Add time-lock mechanism
- Prevent member removal while proposals from that member exist
- Or add delay between member removal and vote recounting

The recommended fix is Option 1, as it preserves the most accurate governance state without restricting legitimate member management operations.

## Proof of Concept

```csharp
[Fact]
public async Task RetroactiveVoteInvalidation_Attack_Test()
{
    // Setup: Create organization with 5 members, threshold = 3 approvals
    var organization = await CreateOrganizationAsync(3, 5, 0, 0, Reviewer1);
    
    // Step 1: Create proposal P1 (target proposal)
    var p1 = await CreateProposalAsync(Reviewer1KeyPair, organization);
    
    // Step 2: Members A, B, C approve P1 (meets threshold)
    await ApproveAsync(Reviewer1KeyPair, p1); // Member A
    await ApproveAsync(Reviewer2KeyPair, p1); // Member B  
    await ApproveAsync(Reviewer3KeyPair, p1); // Member C
    
    // Verify P1 can be released (has 3 approvals)
    var p1Output = await AssociationContractStub.GetProposal.CallAsync(p1);
    p1Output.ToBeReleased.ShouldBeTrue();
    p1Output.ApprovalCount.ShouldBe(3);
    
    // Step 3: Create proposal P2 to remove member A
    var removeMemberInput = Reviewer1; // Member A address
    var p2 = await CreateProposalAsync(
        Reviewer2KeyPair, 
        organization,
        nameof(AssociationContractStub.RemoveMember),
        removeMemberInput
    );
    
    // Step 4: P2 passes with votes from B, C, D
    await ApproveAsync(Reviewer2KeyPair, p2); // Member B
    await ApproveAsync(Reviewer3KeyPair, p2); // Member C
    await ApproveAsync(Reviewer4KeyPair, p2); // Member D
    
    // Step 5: Release P2 - removes member A from organization
    await ReleaseAsync(Reviewer2KeyPair, p2);
    
    // Step 6: Verify P1 can NO LONGER be released
    // Only 2 approvals count now (B and C) because A was removed
    var p1OutputAfter = await AssociationContractStub.GetProposal.CallAsync(p1);
    p1OutputAfter.ToBeReleased.ShouldBeFalse(); // âœ“ VULNERABILITY CONFIRMED
    p1OutputAfter.ApprovalCount.ShouldBe(2); // Only B and C count
    
    // P1 cannot be released despite having met requirements when voted
    var releaseResult = await ReleaseAsync(Reviewer1KeyPair, p1);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved.");
}
```

## Notes

This vulnerability demonstrates a critical flaw in the Association contract's governance mechanism where temporal consistency is not maintained between vote casting and vote counting. The issue arises from the design decision to filter votes against the current membership state rather than preserving the validity of votes based on membership status at the time they were cast. This breaks the fundamental governance invariant that valid votes should remain valid unless explicitly revoked through proper governance processes.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L148-148)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L150-150)
```csharp
        proposal.Rejections.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L168-168)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L170-170)
```csharp
        proposal.Abstentions.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L189-191)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```
