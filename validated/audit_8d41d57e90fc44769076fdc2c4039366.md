# Audit Report

## Title
Incorrect Distinct() Usage Allows Duplicate FinalOrderOfNextRound Values to Bypass Validation

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method incorrectly calls `Distinct()` on `MinerInRound` objects instead of on their `FinalOrderOfNextRound` values. This allows malicious miners to submit `NextRound` transactions with duplicate mining order assignments, causing consensus disruption through non-deterministic miner selection and mining schedule conflicts.

## Finding Description

The validation logic in `NextRoundMiningOrderValidationProvider` contains a critical flaw in how it verifies the uniqueness of mining orders for the next round. [1](#0-0) 

This code calls `Distinct()` directly on the collection of `MinerInRound` objects. Since `MinerInRound` is a protobuf-generated message [2](#0-1)  that implements value-based equality comparing all fields (pubkey, order, in_value, out_value, signature, expected_mining_time, produced_blocks, missed_time_slots, previous_in_value, supposed_order_of_next_round, final_order_of_next_round), the `Distinct()` operation compares entire objects rather than just the `FinalOrderOfNextRound` field.

**Attack Scenario Example:**
- Miner A: `FinalOrderOfNextRound = 1`, `Pubkey = "A"`, `OutValue = hash1`
- Miner B: `FinalOrderOfNextRound = 1`, `Pubkey = "B"`, `OutValue = hash2`  
- Miner C: `FinalOrderOfNextRound = 2`, `Pubkey = "C"`, `OutValue = hash3`

The flawed validation counts 3 distinct `MinerInRound` objects (because pubkeys differ), which equals the count of miners who mined (3 miners with non-null `OutValue`), so validation incorrectly passes. However, there are only 2 distinct `FinalOrderOfNextRound` values - miners A and B both claim order 1 for the next round.

The validation is invoked during `NextRound` behavior processing [3](#0-2)  as part of the consensus information update flow [4](#0-3) .

## Impact Explanation

**Consensus Disruption via Duplicate Orders:**

When `GenerateNextRoundInformation` processes the validated (but malicious) round data, it directly assigns each miner's `Order` from their `FinalOrderOfNextRound` value [5](#0-4) . Multiple miners end up with identical `Order` values in the next round, each maintaining their unique dictionary key (pubkey).

**Non-Deterministic Behavior:**

Functions that select miners by order produce unpredictable results. The extra block producer selection uses `FirstOrDefault` [6](#0-5) . When multiple miners share the same order, this returns an arbitrary miner, making the extra block producer selection non-deterministic.

Similarly, the continuous mining prevention logic uses `First()` to find miners by specific order values [7](#0-6)  and [8](#0-7) . With duplicate orders, these lookups become non-deterministic, breaking the consensus guarantees that prevent continuous mining by the same miner.

**Mining Schedule Conflicts:**

Multiple miners with the same `Order` value calculate identical expected mining times [9](#0-8) , causing simultaneous mining attempts. This violates the fundamental AEDPoS consensus property that each miner has a unique time slot within a round.

**Affected Parties:**

All network participants suffer from consensus instability. The chain may experience fork scenarios, block production conflicts, or halt entirely if multiple miners simultaneously claim the same time slot.

## Likelihood Explanation

**Reachable Entry Point:**

The `NextRound` method is a public RPC endpoint [10](#0-9)  that any current miner can invoke [11](#0-10) .

**Feasible Preconditions:**

The attacker must be a current miner, verified by the `PreCheck()` method [12](#0-11) . This is a realistic precondition since miners are legitimate network participants who may turn malicious.

**Execution Practicality:**

A malicious miner can construct a crafted `NextRoundInput` [13](#0-12)  by manually setting duplicate `FinalOrderOfNextRound` values in the `RealTimeMinersInformation` dictionary, then submitting it via a standard transaction.

**Economic Rationality:**

The attack costs only transaction fees but can cause significant network disruption, making it attractive for attackers seeking to halt the chain, manipulate mining rewards, or create market instability.

## Recommendation

Replace the flawed distinct check with one that validates the actual `FinalOrderOfNextRound` values:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select the order value first
    .Distinct()
    .Count();
```

This ensures that duplicate `FinalOrderOfNextRound` values are properly detected, regardless of differences in other fields like pubkey or OutValue.

## Proof of Concept

```csharp
[Fact]
public void NextRound_DuplicateFinalOrderOfNextRound_ShouldFailValidation()
{
    // Arrange: Get current round with 3 miners
    var currentRound = AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty()).Result;
    var minerPubkeys = currentRound.RealTimeMinersInformation.Keys.Take(3).ToList();
    
    // Create malicious NextRoundInput with duplicate FinalOrderOfNextRound values
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = 
        {
            // Miner 1 and 2 both claim order 1 for next round
            { minerPubkeys[0], new MinerInRound 
                { 
                    Pubkey = minerPubkeys[0], 
                    FinalOrderOfNextRound = 1,  // Duplicate!
                    OutValue = HashHelper.ComputeFrom("hash1")
                }
            },
            { minerPubkeys[1], new MinerInRound 
                { 
                    Pubkey = minerPubkeys[1], 
                    FinalOrderOfNextRound = 1,  // Duplicate!
                    OutValue = HashHelper.ComputeFrom("hash2")
                }
            },
            { minerPubkeys[2], new MinerInRound 
                { 
                    Pubkey = minerPubkeys[2], 
                    FinalOrderOfNextRound = 2,
                    OutValue = HashHelper.ComputeFrom("hash3")
                }
            }
        }
    };
    
    // Act: Try to submit the malicious NextRound transaction
    var validationResult = AEDPoSContractStub.ValidateConsensusBeforeExecution
        .CallAsync(maliciousInput.ToByteString()).Result;
    
    // Assert: Should fail but currently passes due to the bug
    // With the bug: distinctCount = 3 (objects differ by pubkey)
    // Expected: distinctCount should check FinalOrderOfNextRound values = 2
    // Should fail: 2 != 3 (count of miners who mined)
    Assert.False(validationResult.Success); // Currently fails - validation passes when it shouldn't
    Assert.Contains("Invalid FinalOrderOfNextRound", validationResult.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-290)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L60-61)
```csharp
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-89)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L93-107)
```csharp
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L27-28)
```csharp
        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
