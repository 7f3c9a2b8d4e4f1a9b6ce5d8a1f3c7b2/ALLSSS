# Audit Report

## Title 
Arithmetic Overflow in PayRental Calculation Causes Permanent DoS of Side Chain Resource Fee Collection

## Summary
The `PayRental()` method performs uncapped multiplication of unbounded `duration` with `ResourceAmount` and `Rental` parameters, where duration grows based on elapsed time since last payment. With moderate rental parameters, side chains experiencing extended downtime trigger checked arithmetic overflow, causing permanent DoS of the resource rental collection mechanism until governance intervention.

## Finding Description

The vulnerability exists in the rental fee calculation logic that executes automatically on every block for side chains. The `PayRental()` method calculates rental charges using the formula: [1](#0-0) 

Where `duration` is the unbounded time difference in minutes since the last payment: [2](#0-1) 

The multiplication operations use checked arithmetic that throws `OverflowException` on overflow. The `.Mul()` extension method is implemented with explicit checked blocks: [3](#0-2) 

The root cause is that governance-controlled rental parameters lack upper bound validation. The `UpdateRental` method only validates non-negativity: [4](#0-3) 

Similarly, `UpdateRentedResources` has the same insufficient validation: [5](#0-4) 

The execution path is automatic and unavoidable. `PayRental()` is called from `DonateResourceToken()` on all side chains: [6](#0-5) 

And `DonateResourceToken()` is automatically invoked by miners each block via the system transaction generator: [7](#0-6) 

When overflow occurs, the entire system transaction fails with `OverflowException`, preventing all subsequent rental collection attempts until governance reduces the parameters.

## Impact Explanation

**Severity: HIGH**

The impact is complete operational failure of a critical side chain economic mechanism. When the overflow occurs, it causes:

1. **Permanent DoS**: `DonateResourceToken()` fails on every block attempt, completely breaking the resource rental collection system
2. **Economic disruption**: Side chain creators stop paying rental fees for resources (CPU, RAM, DISK, NET), violating the economic model
3. **Consensus impact**: The consensus contract stops receiving rental payments that should fund validator rewards

Overflow timing with realistic parameter ranges (long.MaxValue = 9,223,372,036,854,775,807):
- **Moderate parameters** (ResourceAmount=1000, Rental=10 billion): Overflow after ~640 days downtime
- **High parameters** (ResourceAmount=10000, Rental=100 billion): Overflow after ~6.4 days downtime  
- **Very high parameters** (ResourceAmount=100000, Rental=1 trillion): Overflow after ~1.5 hours downtime

The only recovery path is emergency governance intervention to reduce `Rental` or `ResourceAmount` values, which requires proposal creation, approval, and execution—a multi-step, time-consuming process during which the DoS persists.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability has high likelihood because:

1. **No attacker required**: The vulnerability triggers automatically based on time passage—no malicious action needed
2. **Realistic preconditions**: Side chains can experience extended downtime due to:
   - Network partitions separating validators
   - All validators going offline simultaneously
   - Critical bugs requiring emergency fixes
   - Economic attacks causing validator departures
3. **Legitimate parameter values**: Governance may legitimately set moderate-to-high rental rates for resource pricing, unknowingly creating overflow risk
4. **Automatic trigger**: Once the threshold is reached, the next miner's automatic `DonateResourceToken()` call immediately triggers the overflow
5. **Observable in production**: The overflow manifests as clear `OverflowException` in transaction results, making it detectable but not preventable once triggered

The combination of realistic downtime scenarios, legitimate parameter choices, and automatic triggering makes this vulnerability highly likely to occur in production side chains.

## Recommendation

Add maximum bounds validation to prevent overflow-prone parameter combinations. In `UpdateRental` and `UpdateRentedResources`, validate that the product of `ResourceAmount` and `Rental` for any symbol, multiplied by a reasonable maximum downtime duration (e.g., 365 days = 525,600 minutes), does not exceed `long.MaxValue`:

```csharp
public override Empty UpdateRental(UpdateRentalInput input)
{
    AssertControllerForSideChainRental();
    foreach (var pair in input.Rental)
    {
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
            "Invalid symbol.");
        Assert(pair.Value >= 0, "Invalid amount.");
        
        // Add overflow protection
        var maxDuration = 525600L; // 365 days in minutes
        var resourceAmount = State.ResourceAmount[pair.Key];
        if (resourceAmount > 0 && pair.Value > 0)
        {
            Assert(
                maxDuration <= long.MaxValue / pair.Value / resourceAmount,
                "Rental parameters would cause overflow with extended downtime.");
        }
        
        State.Rental[pair.Key] = pair.Value;
    }
    return new Empty();
}
```

Apply similar validation to `UpdateRentedResources`. Alternatively, use unchecked arithmetic and cap the result to a maximum value, or implement overflow handling that gracefully degrades rather than throwing exceptions.

## Proof of Concept

```csharp
[Fact]
public async Task PayRental_Overflow_DoS_Test()
{
    // Initialize side chain with rental parameters
    await InitialTokenContractAsync();
    
    // Set high rental parameters via governance
    await UpdateRentalAsync(new Dictionary<string, long>
    {
        {"CPU", 100_000_000_000L},  // 100 billion per unit per minute
        {"RAM", 100_000_000_000L},
        {"DISK", 100_000_000_000L},
        {"NET", 100_000_000_000L}
    });
    
    await UpdateRentedResourcesAsync(new Dictionary<string, long>
    {
        {"CPU", 10000L},
        {"RAM", 10000L},
        {"DISK", 10000L},
        {"NET", 10000L}
    });
    
    // Simulate side chain downtime of 7 days
    await DelayMinutesAsync(7 * 24 * 60); // 10,080 minutes
    
    // Attempt to mine next block - DonateResourceToken will overflow
    var result = await TokenContractStub.DonateResourceToken.SendWithExceptionAsync(
        new TotalResourceTokensMaps 
        { 
            BlockHeight = Context.CurrentHeight,
            BlockHash = Context.PreviousBlockHash 
        });
    
    // Verify overflow exception causes DoS
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("OverflowException");
    
    // All subsequent attempts fail permanently
    for (int i = 0; i < 5; i++)
    {
        await DelayOneMinuteAsync();
        var retryResult = await TokenContractStub.DonateResourceToken.SendWithExceptionAsync(
            new TotalResourceTokensMaps 
            { 
                BlockHeight = Context.CurrentHeight,
                BlockHash = Context.PreviousBlockHash 
            });
        retryResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    }
}
```

## Notes

This vulnerability represents a critical design flaw where arithmetic overflow in time-based calculations can permanently disable a core economic mechanism. The issue is particularly severe because:

1. The overflow is deterministic and inevitable given sufficient downtime with high rental parameters
2. The automatic system transaction nature means the DoS repeats on every block
3. Recovery requires governance action, which may be difficult if the side chain is already experiencing operational issues
4. The lack of bounds checking in parameter updates allows governance to unknowingly create overflow-prone configurations

Side chains with high resource rental rates are especially vulnerable, as even brief periods of downtime (hours to days) can trigger the overflow condition.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L947-950)
```csharp
        if (!isMainChain)
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1031-1031)
```csharp
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1112)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L60-71)
```csharp
        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });
```
