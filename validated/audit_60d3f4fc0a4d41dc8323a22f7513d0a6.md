# Audit Report

## Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

## Summary
The `CrossChainCreate` method in the NFT contract creates NFT protocols on sidechains without performing cryptographic cross-chain verification. Unlike the TokenContract's `CrossChainCreateToken` which validates cross-chain state using merkle proofs, the NFT contract only checks local token state, allowing anyone to create unauthorized NFT protocols and gain minting privileges on sidechains.

## Finding Description

The vulnerability exists in the NFT contract's cross-chain synchronization mechanism. The `CrossChainCreate` method accepts only a symbol as input and creates an NFT protocol based solely on local TokenContract state, without verifying that the protocol legitimately exists on the source chain. [1](#0-0) 

The method performs minimal validation: checking if the protocol already exists locally, retrieving token information from the local TokenContract state, and validating that the NFT type is registered. Critically, it directly assigns the Creator from the token's issuer without any cross-chain proof verification. [2](#0-1) 

This contrasts sharply with TokenContract's `CrossChainCreateToken`, which implements proper cross-chain verification: [3](#0-2) 

The TokenContract validates cross-chain state by calling `CrossChainVerify` with transaction ID, parent chain height, chain ID, and merkle path to cryptographically prove the transaction occurred on the source chain: [4](#0-3) 

The input structure differences reveal the design flaw. NFT's `CrossChainCreateInput` contains only a symbol: [5](#0-4) 

While TokenContract's `CrossChainCreateTokenInput` includes comprehensive cross-chain verification data: [6](#0-5) 

**Attack Execution Path:**

1. Attacker creates a token on mainchain via TokenContract.Create with themselves as issuer, including required NFT metadata (NftBaseUriMetadataKey, NftTokenIdReuseMetadataKey) in ExternalInfo and using a symbol with a registered NFT type prefix
2. Token is legitimately synced to sidechain via CrossChainCreateToken (which properly validates cross-chain state)
3. Attacker calls NFTContract.CrossChainCreate on sidechain with the token symbol
4. NFT protocol is created on sidechain with attacker as Creator and automatically added to MinterList, granting minting privileges

The MinterList authorization is properly enforced for minting operations: [7](#0-6) 

However, the vulnerability allows unauthorized entry into this MinterList by creating fake cross-chain protocols.

## Impact Explanation

**Cross-Chain Integrity Violation:** The fundamental security guarantee of cross-chain synchronization is broken. NFT protocols on sidechains should only exist if they legitimately exist on the source chain and have been cryptographically verified. This vulnerability allows creation of protocols that exist only on sidechains, violating the cross-chain consistency model.

**Unauthorized Privilege Escalation:** Attackers gain minting rights on sidechains for NFT protocols they control, without those protocols existing on the mainchain. This represents unauthorized privilege escalation in the NFT system.

**User Deception Risk:** Sidechain users may reasonably assume that NFT protocols exist because they were legitimately synchronized from mainchain. This false assumption could lead to interactions with fake protocols, potentially resulting in economic harm if users trade NFTs they believe to be authentic cross-chain assets.

**Economic Consequences:** While there's no direct fund theft, attackers can mint NFTs that appear to be part of legitimate cross-chain protocols. If these NFTs are traded, users purchasing them may suffer financial losses.

The severity is HIGH (not Critical) because while it enables significant authorization bypass and protocol integrity violation, it doesn't directly drain funds or allow immediate token theft.

## Likelihood Explanation

**Attack Feasibility:** The attack is highly feasible with low complexity:
- Token creation on mainchain requires only a seed NFT or whitelist status (seed NFTs are obtainable through normal market operations)
- CrossChainCreate is a public method with no authorization checks
- Only two simple transaction steps are required

**Preconditions:** All preconditions are realistic and commonly met:
- At least one NFT type must be registered (standard system configuration)
- Token must be synced to sidechain first (standard cross-chain operation that anyone can trigger)
- Protocol with that symbol must not already exist (first-come-first-served)

**Detection Difficulty:** The attack is difficult to detect through automated monitoring because:
- All transactions appear legitimate on the surface
- Events are fired normally
- The token genuinely exists on both chains
- Only manual verification of mainchain state would reveal the discrepancy

**Execution Cost:** Minimal - only transaction fees on mainchain (token creation) and sidechain (CrossChainCreate call).

The likelihood is HIGH due to the combination of low attack complexity, realistic preconditions, and lack of authorization checks.

## Recommendation

Implement proper cross-chain verification in `CrossChainCreate` following the same pattern as `CrossChainCreateToken`:

1. **Modify CrossChainCreateInput** to include cross-chain verification data:
   - from_chain_id
   - parent_chain_height
   - transaction_bytes (containing the mainchain protocol creation transaction)
   - merkle_path

2. **Add cross-chain verification** in CrossChainCreate:
   - Verify the token contract address is registered for the source chain
   - Parse the original transaction to extract NFT protocol creation details
   - Call `CrossChainVerify` to validate the transaction with merkle proof
   - Only create the protocol if verification succeeds

3. **Validate protocol properties** match between source and destination chains (symbol, creator, metadata, etc.)

Example fix structure:
```
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    // Verify source chain token contract is registered
    var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
    Assert(tokenContractAddress != null, "Token contract not registered");
    
    // Parse and verify original transaction
    var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);
    AssertCrossChainTransaction(originalTransaction, tokenContractAddress, "Create");
    
    // Perform cross-chain verification with merkle proof
    CrossChainVerify(originalTransaction.GetHash(), input.ParentChainHeight, 
                     input.FromChainId, input.MerklePath);
    
    // Extract and validate protocol info from verified transaction
    // ... rest of protocol creation logic
}
```

## Proof of Concept

The POC would require a multi-chain test environment. A simplified demonstration:

```csharp
[Fact]
public async Task UnauthorizedNFTProtocolCreation_ShouldSucceed()
{
    // Step 1: Attacker creates token on mainchain with NFT metadata
    var createTokenResult = await MainChainTokenStub.Create.SendAsync(new CreateInput
    {
        Symbol = "BA12345", // Using registered "BA" (Badges) type
        TokenName = "Fake Protocol",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = AttackerAddress,
        IsBurnable = true,
        IssueChainId = MainChainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "__nft_base_uri", "https://fake.uri" },
                { "__nft_token_id_reuse", "false" }
            }
        }
    });
    
    // Step 2: Token is synced to sidechain (legitimate cross-chain operation)
    // ... cross-chain sync with proper merkle proofs ...
    
    // Step 3: Attacker calls CrossChainCreate on sidechain WITHOUT verification
    var crossChainCreateResult = await SideChainNFTStub.CrossChainCreate.SendAsync(
        new CrossChainCreateInput
        {
            Symbol = "BA12345" // Only symbol, no merkle proof!
        });
    
    // Verify: NFT protocol was created on sidechain with attacker as creator
    var protocolInfo = await SideChainNFTStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = "BA12345" });
    
    protocolInfo.Creator.ShouldBe(AttackerAddress); // Attacker is the creator
    
    // Verify: Attacker is in minter list and can mint NFTs
    var minterList = await SideChainNFTStub.GetMinterList.CallAsync(
        new StringValue { Value = "BA12345" });
    
    minterList.Value.ShouldContain(AttackerAddress);
    
    // Attacker can now mint NFTs on sidechain for a protocol that doesn't exist on mainchain
    var mintResult = await SideChainNFTStub.Mint.SendAsync(new MintInput
    {
        Symbol = "BA12345",
        Alias = "Fake NFT",
        TokenId = 1
    });
    
    mintResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This POC demonstrates that an attacker can create an NFT protocol on a sidechain without that protocol existing on the mainchain, solely by leveraging a legitimately created token. The protocol creation succeeds despite having no corresponding mainchain NFT protocol, and the attacker gains minting privileges.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** protobuf/token_contract.proto (L571-580)
```text
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-400)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");
```
