# Audit Report

## Title
Unvalidated LIB Height/Round Correspondence in NextRound and NextTerm Transitions Enables State Corruption

## Summary
The `LibInformationValidationProvider` only validates Last Irreversible Block (LIB) information for `UpdateValue` consensus behavior, but not for `NextRound` or `NextTerm` behaviors. A malicious extra block producer can inject mismatched `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` pairs during round transitions, corrupting consensus state and triggering operational disruption.

## Finding Description

The AEDPoS consensus contract implements differential validation logic across consensus behaviors. The `LibInformationValidationProvider` validates that LIB values do not regress (go backwards): [1](#0-0) 

However, this critical validator is only applied to `UpdateValue` behavior during the validation pipeline assembly: [2](#0-1) 

For `UpdateValue`, even though LIB values are validated, they are subsequently discarded and recalculated using `LastIrreversibleBlockHeightCalculator` based on miner consensus: [3](#0-2) 

In contrast, `NextRound` and `NextTerm` behaviors accept LIB values from the input and convert them directly into a Round object: [4](#0-3) 

These values are then stored directly to state without any correspondence validation: [5](#0-4) 

The validators for `NextRound` only check mining order: [6](#0-5) 

And round number increment: [7](#0-6) 

Critically, there is no validation ensuring `ConfirmedIrreversibleBlockRoundNumber` corresponds to the actual round at `ConfirmedIrreversibleBlockHeight`. An attacker can provide round number 1 when the actual round at that height was 50, and this mismatch will be accepted and stored.

## Impact Explanation

**Operational DoS Impact:** The corrupted LIB values directly affect `GetMaximumBlocksCount`, which evaluates blockchain mining status by calculating the difference between current round and LIB round: [8](#0-7) 

By providing an artificially low `ConfirmedIrreversibleBlockRoundNumber` (e.g., 1 instead of actual 50), an attacker forces a large `currentRoundNumber - libRoundNumber` difference, triggering:
- **Abnormal status**: Reduces maximum blocks per miner via a false crisis formula
- **Severe status**: Limits all miners to 1 block each and fires `IrreversibleBlockHeightUnacceptable` event

**Persistence:** The corrupted values propagate to subsequent rounds since `GenerateNextRoundInformation` copies them forward: [9](#0-8) 

The corruption persists until corrected through governance intervention or until an honest extra block producer submits a NextRound with correct values.

**State Integrity Break:** The consensus state now contains a critical inconsistency where `ConfirmedIrreversibleBlockRoundNumber` does not correspond to the actual round at `ConfirmedIrreversibleBlockHeight`, violating the fundamental invariant that these two fields must always be synchronized.

## Likelihood Explanation

**Attacker Capabilities:** The attacker must be the extra block producer for the current round. The extra block producer role rotates deterministically among miners based on signature randomness. With N miners (typically 17-21 in AElf networks), a malicious miner becomes extra block producer approximately every N rounds.

**Attack Complexity:** Low. The attack sequence:
1. Attacker waits until they are selected as extra block producer
2. Off-chain, constructs a `NextRoundInput` with all legitimate values except `ConfirmedIrreversibleBlockRoundNumber` set to an artificially low value (e.g., 1)
3. Produces a NextRound block containing a transaction with this modified input
4. Validation passes because `LibInformationValidationProvider` is not included in the validation pipeline
5. Corrupted values are stored to state via `AddRoundInformation`

**Detection:** The attack manifests when `GetMaximumBlocksCount` returns incorrect values, causing false Abnormal/Severe status. However, by this point the state corruption has occurred and requires corrective action.

**Economic Rationality:** The attack cost is minimal (one block production opportunity). Motivation could include:
- Disrupting competitor chains in multi-chain ecosystems
- Griefing attacks without direct financial benefit
- Creating operational chaos to execute secondary attacks during recovery

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` and `NextTerm` behaviors in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
```

Additionally, consider implementing explicit validation that `ConfirmedIrreversibleBlockRoundNumber` cannot be arbitrarily lower than the current round number minus a reasonable threshold (e.g., 2-3 rounds), to catch even subtle mismatches.

## Proof of Concept

A proof of concept test would:
1. Initialize a consensus system with multiple miners at round 50
2. Set legitimate LIB values (height=1000, roundNumber=48)
3. Make a miner the extra block producer
4. Craft a `NextRoundInput` with all correct values except `ConfirmedIrreversibleBlockRoundNumber=1`
5. Call `NextRound` and verify validation passes
6. Verify the corrupted values are stored in state
7. Call `GetMaximumBlocksCount` and verify it returns 1 (Severe status) instead of the expected maximum
8. Verify `IrreversibleBlockHeightUnacceptable` event is fired

The test would demonstrate that the validation gap allows state corruption with measurable operational impact on block production limits.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-91)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
