# Audit Report

## Title
Unbounded ProfitDetails Growth Causes Denial of Service in Profit Claiming

## Summary
The Profit contract allows unlimited `ProfitDetail` entries to accumulate per beneficiary without enforcing size limits. When beneficiaries attempt to claim profits, the contract must iterate through all accumulated details using LINQ filtering before the processing limit is applied, leading to gas exhaustion and permanent denial of service once the list grows to thousands of entries.

## Finding Description

The root cause lies in the `AddBeneficiary` method which unconditionally appends new `ProfitDetail` entries to a beneficiary's list without any size limit validation or deduplication. [1](#0-0) 

The beneficiary's profit details are stored as a repeated list structure with no size constraints. [2](#0-1) 

**Why Existing Protections Fail:**

1. **Insufficient Cleanup Logic**: The cleanup mechanism only removes details that meet extremely strict conditions - they must be fully claimed AND expired AND beyond the receiving period. [3](#0-2) 

2. **Processing Limit Doesn't Prevent Iteration**: The `ProfitReceivingLimitForEachTime` constant limits processing to 10 details per claim [4](#0-3) , but this limit is applied AFTER the expensive LINQ filtering operation. [5](#0-4) 

3. **Full List Iteration Required**: The `ClaimProfits` method must iterate through ALL accumulated details to filter available ones before any limit is applied. [6](#0-5) 

**Attack Vector 1 - Malicious Scheme Manager:**

Any user can create their own profit scheme via the public `CreateScheme` method and become its manager. [7](#0-6)  The manager can then repeatedly call `AddBeneficiary` with the same beneficiary but different `ProfitDetailId` values, as authorization only checks manager status. [8](#0-7) 

**Attack Vector 2 - Election Contract Natural Accumulation:**

The Election contract creates a new profit detail for each vote with a unique `voteId` as the `ProfitDetailId`. [9](#0-8) 

When votes are withdrawn, the `RemoveBeneficiaryOfVoter` method calls `RemoveBeneficiary` without specifying a `ProfitDetailId`. [10](#0-9) 

The WelfareHash scheme (used for Election voters) has `CanRemoveBeneficiaryDirectly` set to false (index 3, not in the list {2,5,6}). [11](#0-10)  The scheme index mapping shows WelfareHash is at index 3. [12](#0-11) 

The `RemoveProfitDetails` method confirms that when `CanRemoveBeneficiaryDirectly` is false, only expired details are removed (those where `EndPeriod < CurrentPeriod`). [13](#0-12) 

## Impact Explanation

**Operational DoS Impact:**

When a beneficiary with thousands of accumulated `ProfitDetail` entries attempts to claim profits, the LINQ `Where` clause must iterate through the entire list to filter available details. With 10,000 entries, this gas-intensive operation will exceed block gas limits, causing the transaction to fail and making profit claims permanently impossible.

**Who is Affected:**
- Election contract users who vote frequently (100+ times) will naturally accumulate hundreds of profit details and eventually face claim DoS
- Any beneficiary targeted by a malicious scheme manager will be unable to claim profits from that scheme
- System-wide welfare distribution can be disrupted, affecting the core reward mechanism

**Severity Assessment: HIGH**
- **Permanent Denial of Service**: Once gas limits are exceeded, there is no recovery mechanism for beneficiaries to claim accumulated profits
- **Funds Locked**: Profits remain permanently unclaimed in the contract with no alternative withdrawal path
- **Protocol Core Functionality**: Affects the fundamental reward distribution system across Election, TokenHolder, and Treasury contracts

## Likelihood Explanation

**Likelihood Assessment: HIGH**

**Attacker Capabilities:**
- Any user can create their own profit scheme via the public `CreateScheme` method and become its manager
- Scheme managers have full authority to call `AddBeneficiary` repeatedly with different `ProfitDetailId` values
- No economic barrier exists beyond standard transaction fees

**Attack Complexity: LOW**
- Single transaction batch calling `AddBeneficiary` thousands of times with incrementing `ProfitDetailId` values
- No special permissions required beyond creating a scheme (available to all users)
- Can target any address preemptively before they attempt to claim

**Natural Occurrence: HIGH**
- The Election contract naturally creates this scenario through normal user voting behavior
- Users who vote 100+ times over several months will accumulate 100+ permanent profit details
- Details persist indefinitely until `EndPeriod + ProfitReceivingDuePeriodCount` is reached AND they have been fully claimed (10+ periods beyond expiration)

**Detection Constraints:**
- Attack is undetectable until the victim attempts to claim profits
- No monitoring mechanisms exist to alert users of growing detail lists
- Gas costs for attackers are minimal compared to the permanent impact on victims

## Recommendation

Implement size limits and batch cleanup mechanisms:

1. **Add Maximum Detail Count Validation** in `AddBeneficiary`:
   - Reject new beneficiary additions when `profitDetails.Details.Count` exceeds a reasonable threshold (e.g., 100)
   - Or implement detail deduplication/consolidation logic

2. **Improve Cleanup Logic**:
   - Remove the strict condition requiring full claiming before cleanup
   - Allow periodic cleanup of expired details regardless of claim status

3. **Optimize ClaimProfits**:
   - Implement pagination or cursor-based claiming to process details in smaller batches
   - Store an index of claimable details to avoid full list iteration

4. **Add Recovery Mechanism**:
   - Provide an administrative function to reset or consolidate profit details for affected beneficiaries

## Proof of Concept

```csharp
// POC: Attacker creates scheme and DoS target beneficiary
public async Task ProfitDetails_DoS_Attack()
{
    // 1. Attacker creates their own profit scheme
    var createResult = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true
    });
    var schemeId = createResult.Output;
    
    // 2. Attacker spams AddBeneficiary with different ProfitDetailIds
    var targetBeneficiary = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey);
    for (int i = 0; i < 10000; i++)
    {
        await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
        {
            SchemeId = schemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = targetBeneficiary,
                Shares = 1
            },
            ProfitDetailId = HashHelper.ComputeFrom($"attack_{i}"),
            EndPeriod = long.MaxValue
        });
    }
    
    // 3. Victim attempts to claim profits - transaction fails due to gas exhaustion
    var claimResult = await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = targetBeneficiary
    });
    // Expected: Transaction runs out of gas during LINQ iteration
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-773)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L13-13)
```csharp
    public MappedState<Hash, Address, ProfitDetails> ProfitDetailsMap { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L304-311)
```csharp
    private void RemoveBeneficiaryOfVoter(Address voterAddress = null)
    {
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            Beneficiary = voterAddress ?? Context.Sender
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L56-67)
```csharp
        for (var i = 0; i < 7; i++)
        {
            var index = i;
            Context.LogDebug(() => profitItemNameList[index]);
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L90-96)
```csharp
        State.TreasuryHash.Value = managingSchemeIds[0];
        State.RewardHash.Value = managingSchemeIds[1];
        State.SubsidyHash.Value = managingSchemeIds[2];
        State.WelfareHash.Value = managingSchemeIds[3];
        State.BasicRewardHash.Value = managingSchemeIds[4];
        State.VotesWeightRewardHash.Value = managingSchemeIds[5];
        State.ReElectionRewardHash.Value = managingSchemeIds[6];
```
