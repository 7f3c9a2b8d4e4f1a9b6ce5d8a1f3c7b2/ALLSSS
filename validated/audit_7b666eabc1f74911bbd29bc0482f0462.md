# Audit Report

## Title
Inconsistent Miner Count Threshold Causes LIB Calculation Failure During Term Transitions

## Summary
A mathematical inconsistency in the `LastIrreversibleBlockHeightCalculator` prevents Last Irreversible Block (LIB) advancement during term transitions when new miners join. The algorithm compares a filtered count of previous round miners against a threshold calculated from all current round miners, causing legitimate LIB updates to fail when the miner list changes.

## Finding Description

The vulnerability exists in the LIB calculation algorithm implemented in the `Deconstruct()` method. [1](#0-0) 

The bug stems from an asymmetric miner counting approach:

1. **Current Round Miners**: The method retrieves miners who successfully mined in the current round using `GetMinedMiners()`, which returns miners where `SupposedOrderOfNextRound != 0`. [2](#0-1) 

2. **Previous Round Filtering**: These current round miner pubkeys are then used to filter the previous round via `GetSortedImpliedIrreversibleBlockHeights()`. [3](#0-2)  This filtering excludes any new miners who didn't exist in the previous round.

3. **Threshold Calculation**: The filtered count is compared against `MinersCountOfConsent`, which is calculated as `RealTimeMinersInformation.Count * 2/3 + 1` based on ALL current round miners. [4](#0-3) 

During term transitions, the miner list is updated via `ProcessNextTerm()`. [5](#0-4)  New miners join and are marked with `IsMinerListJustChanged = true`. [6](#0-5) 

When miners subsequently call `UpdateValue` to submit block information, the LIB calculator is invoked. [7](#0-6) 

**Critical Flaw**: New miners who mined in the current round cannot contribute to the filtered count because they don't exist in the previous round's `RealTimeMinersInformation`. However, they ARE included in the denominator when calculating `MinersCountOfConsent`. This creates an artificial deficit that fails the threshold check even when sufficient miners participated.

## Impact Explanation

**Medium Severity - Operational Disruption with Temporary Finality Delay**

When the threshold check fails, `libHeight` is set to 0, preventing LIB advancement. The `IrreversibleBlockFound` event is not fired, [8](#0-7)  which means the blockchain service's LIB update mechanism is not triggered. [9](#0-8) 

**Concrete Impact**:
- Cross-chain operations that depend on LIB are delayed, as the cross-chain module listens for `NewIrreversibleBlockFoundEvent`. [10](#0-9) 
- Finality guarantees are postponed for all new blocks during the affected rounds
- Network participants cannot rely on irreversibility confirmation during term transitions
- Side chains waiting for main chain LIB updates experience delays

**Example Scenario**:
- Previous round: 7 miners [A, B, C, D, E, F, G]
- Current round after term transition: 7 miners [D, E, F, G, H, I, J]
- 5 miners successfully mined: [D, E, G, H, I]
- Threshold: 7 Ã— 2/3 + 1 = 5 miners required
- Filtered count: Only 3 (D, E, G existed in previous round; H, I are new)
- Check fails: 3 < 5, despite 5 legitimate participants

The issue is self-resolving once new miners establish presence across multiple rounds, limiting it to Medium severity rather than High.

## Likelihood Explanation

**High Likelihood - Triggered by Normal Consensus Operations**

This vulnerability occurs during regular network operations without requiring any attacker:

1. **Trigger Frequency**: Every term transition where the miner list changes. Term transitions are part of normal AEDPoS consensus flow.

2. **Entry Point**: The public `UpdateValue` method, called by miners during standard block production workflow.

3. **Preconditions**: Only requires that new miners join during a term transition - a routine occurrence in election-based consensus.

4. **Detection**: Observable through monitoring when LIB height stops advancing for 1-2 rounds after term changes, despite normal block production continuing.

The vulnerability affects the first rounds of each new term proportionally to the number of new miners joining. With significant miner set changes (e.g., 30-50% turnover), the issue becomes highly likely to manifest.

## Recommendation

Modify the LIB calculation to use a consistent miner set for both the threshold and the filtered count. The threshold should be based on the intersection of miners who exist in both rounds, not the total current round count:

**Option 1 - Adjust Threshold**:
Calculate `MinersCountOfConsent` based on the count of miners who exist in both previous and current rounds, rather than all current miners.

**Option 2 - Fallback Logic**:
When the filtered count is below threshold due to miner list changes, use an alternative LIB calculation method, such as:
- Using only the overlapping miners' heights
- Applying a lower threshold during `IsMinerListJustChanged` rounds
- Carrying forward the previous LIB until sufficient history accumulates

**Recommended Fix**: Option 1 provides the cleanest solution. Update the comparison logic to account for miner set intersections during term transitions.

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Calculation_Fails_During_Term_Transition_With_New_Miners()
{
    // Setup: Create a scenario with 7 initial miners
    var initialMiners = new List<string> { "A", "B", "C", "D", "E", "F", "G" };
    
    // Simulate previous round with all 7 miners having mined
    var previousRound = CreateRoundWithMiners(initialMiners, roundNumber: 100);
    SetAllMinersAsHavingMined(previousRound);
    
    // Simulate term transition: 3 new miners join, replacing A, B, C
    var newMiners = new List<string> { "D", "E", "F", "G", "H", "I", "J" };
    var currentRound = CreateRoundWithMiners(newMiners, roundNumber: 101);
    currentRound.IsMinerListJustChanged = true;
    
    // 5 miners mine (D, E, G, H, I) - meeting 2/3+1 threshold
    SetMinersAsHavingMined(currentRound, new[] { "D", "E", "G", "H", "I" });
    
    // Execute LIB calculation
    var calculator = new LastIrreversibleBlockHeightCalculator(currentRound, previousRound);
    calculator.Deconstruct(out var libHeight);
    
    // Bug: libHeight should be > 0 since 5/7 miners participated
    // But it returns 0 because only 3 miners (D, E, G) exist in previous round
    libHeight.ShouldBe(0); // Demonstrates the bug
    
    // Expected: libHeight should be calculated from the 3 overlapping miners' heights
    // or the threshold should account for only 4 overlapping miners (D,E,F,G)
}
```

**Notes**

This vulnerability represents a design flaw in the Byzantine fault tolerance algorithm's handling of dynamic miner sets. The core issue is that the 2/3+1 consensus threshold assumes a static miner set, but AEDPoS allows miner list changes. The mismatch between the threshold basis (all current miners) and the data source (previous round miners) creates an edge case that disrupts finality progression during legitimate network evolution.

The impact is classified as Medium because while it affects critical infrastructure (finality and cross-chain operations), it is temporary and self-correcting as new miners participate across multiple rounds. However, in scenarios with frequent or large-scale miner turnover, the cumulative effect could significantly impact network reliability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L73-80)
```csharp
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var currentChain = await _blockchainService.GetChainAsync();
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
                }, KernelConstants.UpdateChainQueueName);
```

**File:** src/AElf.CrossChain/CrossChainModuleEventHandler.cs (L25-28)
```csharp
    public async Task HandleEventAsync(NewIrreversibleBlockFoundEvent eventData)
    {
        await _crossChainService.UpdateCrossChainDataWithLibAsync(eventData.BlockHash, eventData.BlockHeight);
    }
```
