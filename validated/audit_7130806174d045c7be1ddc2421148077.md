# Audit Report

## Title
Quadratic Voting Results Corruption Due to Inconsistent Amount Tracking

## Summary
The Vote contract contains a critical accounting mismatch in quadratic voting. During voting, it increments `Results[option]` by 1 (vote count), but during withdrawal, it decrements by the full token amount. This causes voting tallies to become negative and completely corrupts quadratic voting results.

## Finding Description

The vulnerability exists in how the Vote contract tracks quadratic voting results across two operations:

**During Voting:** When `IsQuadratic` is true, the contract calculates the token amount to lock based on the current vote count. [1](#0-0) 

This token amount is stored in the voting record. [2](#0-1) 

However, when updating voting results, the contract passes `1` (vote count) instead of `amount` (token amount) for quadratic voting. [3](#0-2) 

The `UpdateVotingResult` function then increments both `Results[option]` and `VotesAmount` by this passed value (which is `1` for quadratic voting). [4](#0-3) 

**During Withdrawal:** The withdrawal logic decrements both `Results[option]` and `VotesAmount` by `votingRecord.Amount`, which contains the full token amount, not 1. [5](#0-4) 

**The Mismatch:** For quadratic voting, `Results[option]` is incremented by 1 during voting but decremented by potentially large token amounts during withdrawal, causing the results to become negative and completely corrupted.

## Impact Explanation

This vulnerability has critical impact on voting integrity:

1. **Negative Vote Counts**: After withdrawals, `Results[option]` becomes negative (e.g., 2 - 200 = -198)
2. **Corrupted Tallies**: Vote results no longer represent actual voting outcomes
3. **Broken Governance**: Any decisions based on these vote results will use corrupted data
4. **Feature Unusable**: Quadratic voting is completely non-functional

**Concrete Example:**
- First vote: `Results["OptionA"]` increments by 1, locks 100 tokens
- Second vote: `Results["OptionA"]` increments by 1 (total: 2), locks 200 tokens
- Withdraw second vote: `Results["OptionA"]` decrements by 200 â†’ **Results = -198**

This affects all participants in quadratic voting items, voting sponsors who rely on accurate counts, and any downstream systems depending on vote results.

## Likelihood Explanation

The likelihood of this issue is **Very High**:

1. **No Special Privileges Required**: Any regular user can trigger this by participating in a quadratic voting item
2. **Trivial to Trigger**: Occurs during normal vote and withdrawal operations
3. **No Complex Setup**: Simply requires voting with `IsQuadratic = true` and later withdrawing
4. **Immediate Observable**: Bug manifests on first withdrawal, easily detectable through negative vote counts

The vulnerability is automatically triggered in any quadratic voting scenario where users exercise their legitimate right to withdraw votes.

## Recommendation

Fix the accounting mismatch by ensuring consistent tracking in both voting and withdrawal operations. For quadratic voting, either:

**Option 1 (Recommended)**: Store vote count separately from token amount
- Increment `Results[option]` by 1 during vote (representing number of votes)
- Decrement `Results[option]` by 1 during withdrawal
- Track token amounts separately in `VotesAmount`

**Option 2**: Use token amounts consistently
- Change line 119 to pass `amount` instead of `1` for quadratic voting
- This means `Results[option]` tracks token amounts for all voting types

The recommended fix for line 119 would be:
```csharp
UpdateVotingResult(votingItem, input.Option, amount);
```

This ensures both `Results[option]` and `VotesAmount` are incremented and decremented by the same `amount` value.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_Withdrawal_Causes_Negative_Results()
{
    // Register a quadratic voting item with TicketCost = 100
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { "OptionA", "OptionB" },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true,
        IsQuadratic = true,
        TicketCost = 100
    };
    
    var registerResult = await VoteContractStub.Register.SendAsync(input);
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender));
    
    var voter = Accounts[1].KeyPair;
    var voterStub = GetVoteContractTester(voter);
    
    // First vote: costs 100 tokens, Results["OptionA"] should be 1
    await voterStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0 // Amount is ignored for quadratic voting
    });
    
    var result1 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 });
    result1.Results["OptionA"].ShouldBe(1); // Correct: 1 vote
    result1.VotesAmount.ShouldBe(1); // Correct: incremented by 1
    
    // Second vote: costs 200 tokens (100 * 2), Results["OptionA"] should be 2
    await voterStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "OptionA",
        Amount = 0
    });
    
    var result2 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 });
    result2.Results["OptionA"].ShouldBe(2); // Correct: 2 votes
    result2.VotesAmount.ShouldBe(2); // Correct: incremented by 1 again
    
    // Get vote IDs for withdrawal
    var voteIds = await voterStub.GetVotingIds.CallAsync(new GetVotingIdsInput
    {
        Voter = Address.FromPublicKey(voter.PublicKey),
        VotingItemId = votingItemId
    });
    
    // Withdraw the second vote (which locked 200 tokens)
    var secondVoteId = voteIds.ActiveVotes[1];
    await voterStub.Withdraw.SendAsync(new WithdrawInput { VoteId = secondVoteId });
    
    // BUG: Results["OptionA"] is decremented by 200 (the token amount)
    // Expected: 2 - 1 = 1
    // Actual: 2 - 200 = -198
    var result3 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 });
    
    // This assertion will fail, proving the vulnerability
    result3.Results["OptionA"].ShouldBeLessThan(0); // Negative result!
    result3.VotesAmount.ShouldBeLessThan(0); // Also negative!
}
```

## Notes

This vulnerability completely breaks the quadratic voting feature in the AElf Vote contract. The accounting mismatch between increment (by 1) and decrement (by token amount) operations makes it impossible to maintain accurate vote tallies. Any production use of quadratic voting will result in corrupted data as soon as users begin withdrawing their votes.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-103)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-115)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```
