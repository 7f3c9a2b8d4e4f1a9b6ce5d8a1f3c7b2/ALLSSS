# Audit Report

## Title
Referendum Organizations Can Be Permanently Bricked With Invalid Proposer Addresses

## Summary
The Referendum contract's organization validation fails to verify that addresses in the ProposerWhiteList contain valid (non-empty) ByteString values. An attacker can create organizations with whitelists containing only addresses with empty ByteString values, which pass validation but are permanently unusable since no valid proposer can create proposals and the whitelist cannot be modified without executing a proposal.

## Finding Description

The vulnerability exists in the organization validation logic during creation. When `CreateOrganization` is called, it validates the organization using the `Validate()` method [1](#0-0) , which checks whether the ProposerWhiteList is empty but never validates individual address validity [2](#0-1) .

The `Empty()` extension method only checks if the count is zero [3](#0-2) . This allows an attacker to add Address objects with `Value = ByteString.Empty` (protobuf3 default) to satisfy the non-empty requirement.

The ProposerWhiteList is defined as a repeated Address field with no inherent validation [4](#0-3) , and Address itself is just a bytes wrapper [5](#0-4) .

When users attempt to create proposals, authorization is enforced via `AssertIsAuthorizedProposer` [6](#0-5) , which checks if the proposer exists in the whitelist using `Contains()` [7](#0-6) . This check uses protobuf equality comparison, where addresses with valid ByteString values will never equal addresses with empty ByteString values.

The recovery mechanism is blocked because `ChangeOrganizationProposerWhiteList` requires `Context.Sender` to be the organization address itself [8](#0-7) , which can only occur through virtual inline calls during proposal execution. Since no proposals can be created, the whitelist cannot be updated, permanently bricking the organization.

Notably, other contracts in the codebase implement proper address validation. The MultiToken contract validates addresses with `AssertValidInputAddress` that checks for null and empty values [9](#0-8) , but the Referendum contract lacks this validation for whitelist addresses.

## Impact Explanation

**Operational Impact - Permanent DoS:**
- Any user can create permanently unusable Referendum organizations at minimal gas cost
- Organization addresses are deterministic based on input parameters [10](#0-9) , allowing attackers to pre-occupy addresses that legitimate users intend to create
- Once created, organizations cannot be deleted or recovered (no delete method exists in the contract)
- State bloat from accumulation of unusable organizations

**Governance Impact:**
- Complete DoS of Referendum governance functionality for affected organizations
- No admin override or recovery mechanism exists
- Violates the fundamental governance invariant that organizations with non-empty whitelists must allow authorized proposers to create proposals

The severity is **HIGH** because it enables permanent, unrecoverable DoS of critical governance infrastructure with minimal attack cost and no privileged access required.

## Likelihood Explanation

**Entry Point:** The `CreateOrganization` method is publicly accessible [11](#0-10)  with no authorization checks.

**Attack Feasibility:**
- In protobuf3 C#, creating an Address with empty ByteString is trivial: `new Address()` defaults to `Value = ByteString.Empty`
- The attacker constructs a `CreateOrganizationInput` with valid parameters except the ProposerWhiteList contains only invalid addresses
- Single transaction execution with standard gas cost
- No special permissions required

**Economic Rationality:**
- Attack cost: Only transaction gas fees (same as normal organization creation)
- Impact: Permanent bricking of organization functionality
- High impact-to-cost ratio makes this economically viable for griefing attacks

The likelihood is **HIGH** due to public accessibility, trivial execution, and minimal cost.

## Recommendation

Add individual address validation in the `Validate()` method to ensure all addresses in the ProposerWhiteList have non-empty ByteString values:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for individual addresses
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Alternatively, create a dedicated validation method similar to MultiToken's `AssertValidInputAddress` and use it consistently across the contract.

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithEmptyAddresses_ShouldBrickOrganization()
{
    // Create organization with empty ByteString addresses
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5000,
            MinimalVoteThreshold = 5000,
            MaximalAbstentionThreshold = 10000,
            MaximalRejectionThreshold = 10000
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { new Address() } // Empty ByteString address
        },
        TokenSymbol = "ELF"
    };

    // Organization creation succeeds (vulnerability)
    var result = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var organizationAddress = result.Output;

    // Verify organization exists
    var organization = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress);
    organization.OrganizationAddress.ShouldBe(organizationAddress);

    // Attempt to create proposal with valid proposer - should fail
    var createProposalInput = new CreateProposalInput
    {
        ContractMethodName = "Create",
        ToAddress = TokenContractAddress,
        Params = new CreateInput().ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        OrganizationAddress = organizationAddress,
        Title = "Test",
        Description = "Test"
    };

    // This fails because valid address doesn't match empty address
    var proposalResult = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
    proposalResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    proposalResult.TransactionResult.Error.ShouldContain("Unauthorized to propose");

    // Organization is now permanently bricked - no proposals can be created
    // and whitelist cannot be modified without proposal execution
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L207-219)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress = Context.ConvertVirtualAddressToContractAddressWithContractHashName(
            CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));

        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** protobuf/acs3.proto (L139-142)
```text
message ProposerWhiteList{
    // The address of the proposers
    repeated aelf.Address proposers = 1;
}
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```
