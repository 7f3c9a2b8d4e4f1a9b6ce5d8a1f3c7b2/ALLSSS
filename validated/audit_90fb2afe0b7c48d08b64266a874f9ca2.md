# Audit Report

## Title
Cross-Chain Token Creation Bypasses TokenName Length Validation Allowing Unbounded Names

## Summary
The `CrossChainCreateToken` method fails to enforce the 80-character token name length limit that is strictly validated in the local token creation path. This validation inconsistency allows side chain operators to create tokens with arbitrarily large names and propagate them to the main chain via legitimate cross-chain mechanisms, resulting in permanent state bloat and protocol invariant violations.

## Finding Description

The vulnerability stems from a validation bypass between two token creation paths in the MultiToken contract.

**Local Token Creation Path (Protected):**
The `CreateToken` method enforces strict validation by calling `AssertValidCreateInput` [1](#0-0) , which validates that token names do not exceed the maximum allowed length [2](#0-1) . The `TokenNameLength` constant is defined as 80 characters [3](#0-2) .

**Cross-Chain Token Creation Path (Vulnerable):**
The `CrossChainCreateToken` method constructs a `TokenInfo` object directly from cross-chain input without any length validation [4](#0-3) . It then calls `RegisterTokenInfo` which only validates that the token name is not empty, but does not check the maximum length [5](#0-4) .

**Root Cause:**
The cross-chain verification process validates the merkle proof cryptographically but does not enforce semantic validity of token parameters against local chain rules. The protobuf definition for `ValidateTokenInfoExistsInput` has no length constraint on the `token_name` field [6](#0-5) , allowing unbounded strings to be transmitted.

**Attack Scenario:**
1. Attacker controls or compromises a side chain registered in `State.CrossChainTransferWhiteList`
2. On the side chain, create a token with an excessively long name (e.g., 10,000+ characters)
3. Execute `ValidateTokenInfoExists` transaction on the side chain
4. Extract merkle proof and call `CrossChainCreateToken` on the main chain with valid cryptographic proof
5. Main chain accepts the token because merkle proof is valid, despite violating the 80-character semantic constraint

## Impact Explanation

This vulnerability has **Medium severity** with the following concrete impacts:

1. **Storage Bloat**: Token names of unlimited length consume excessive contract storage permanently. Each oversized token name represents irreversible state pollution that cannot be removed once registered.

2. **Gas Inefficiency**: All operations that read or write token information (transfers, queries, approvals, balance checks) will consume significantly more gas due to larger string operations, affecting every user who interacts with the malicious token.

3. **UI/Display Issues**: Frontend applications, block explorers, and wallets may crash or malfunction when attempting to display extremely long token names, degrading user experience across the entire ecosystem.

4. **Protocol Invariant Violation**: The protocol establishes a clear 80-character limit for token names. This inconsistency creates two classes of tokens with different validation rules, breaking the uniformity of the security model and user expectations.

While this does not directly enable fund theft or supply manipulation, it represents a significant denial-of-service vector through permanent state growth and operational degradation that cannot be remediated once malicious tokens are registered.

## Likelihood Explanation

The likelihood is **Medium** based on the following analysis:

**Required Attacker Capabilities:**
- Control or compromise of a side chain registered in the cross-chain whitelist (checked at line 480-482 of TokenContract_Actions.cs)
- Ability to create tokens on that side chain
- Ability to submit valid merkle proofs to the main chain

**Feasibility Assessment:**
While controlling a side chain represents a high barrier to entry, it is realistic in AElf's multi-chain ecosystem where:
- Side chains are operated by different organizations with varying security standards
- Malicious operators could pass initial governance review during registration
- Existing side chains could be compromised through governance attacks or security breaches
- Side chains are NOT in the protocol's trusted roles list (genesis, Parliament, consensus contracts)

The `CrossChainCreateToken` method is public and callable by anyone with valid merkle proofs. Once side chain access is obtained, the attack complexity is lowâ€”no sophisticated cryptographic manipulation is required, only standard cross-chain token creation flow. The cross-chain infrastructure is operational and actively used, making this a realistic attack vector.

## Recommendation

Add explicit token name length validation in the `CrossChainCreateToken` method before calling `RegisterTokenInfo`. The fix should be applied at line 492-503 in `TokenContract_Actions.cs`:

```csharp
var validateTokenInfoExistsInput =
    ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);

// Add validation here:
Assert(validateTokenInfoExistsInput.TokenName.Length <= TokenContractConstants.TokenNameLength,
    "Token name exceeds maximum length.");

var tokenInfo = new TokenInfo
{
    Symbol = validateTokenInfoExistsInput.Symbol,
    TokenName = validateTokenInfoExistsInput.TokenName,
    // ... rest of initialization
};
```

Alternatively, modify `RegisterTokenInfo` in `TokenContract_Helper.cs` to include the length check, ensuring all registration paths are protected:

```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
        "Invalid symbol.");
    Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
    Assert(tokenInfo.TokenName.Length <= TokenContractConstants.TokenNameLength,
        "Token name exceeds maximum length."); // Add this check
    Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
    Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
    Assert(tokenInfo.Owner != null, "Invalid owner address.");
    State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
    State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
}
```

## Proof of Concept

A test case demonstrating this vulnerability would:

1. Set up a side chain and register its token contract address on the main chain
2. Create a token on the side chain with a token name exceeding 80 characters (e.g., 200 characters)
3. Execute `ValidateTokenInfoExists` on the side chain
4. Extract the merkle proof and use `CrossChainCreateToken` to propagate the token to the main chain
5. Verify that the token is successfully created on the main chain despite violating the 80-character limit
6. Confirm that the same token cannot be created directly on the main chain using `Create` method (which would fail validation)

The test would demonstrate that `CrossChainCreateToken` accepts the oversized token name while `CreateToken` correctly rejects it, proving the validation inconsistency.

---

## Notes

This vulnerability represents a semantic validation gap in the cross-chain token creation flow. The cryptographic verification (merkle proof validation) correctly ensures the token exists on the source chain, but semantic validation (parameter constraints like length limits) is not enforced. This creates an asymmetry where local and cross-chain token creation have different validation rules, violating the principle of uniform security guarantees across all token creation paths.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-50)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-277)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L5-5)
```csharp
    public const int TokenNameLength = 80;
```

**File:** protobuf/token_contract_impl.proto (L251-256)
```text
message ValidateTokenInfoExistsInput{
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
```
