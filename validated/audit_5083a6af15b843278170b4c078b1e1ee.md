## Audit Report

### Title
Continuous Block Limit Bypass via Candidate Public Key Replacement

### Summary
A miner can bypass the continuous blocks production limit by exploiting the candidate public key replacement mechanism. When a miner replaces their public key, the consensus contract updates round information but fails to update the `LatestPubkeyToTinyBlocksCount` state variable, creating a pubkey mismatch that causes all enforcement checks to fail and the counter to reset, enabling unlimited continuous block production.

### Finding Description

The AEDPoS consensus system enforces a continuous blocks limit to prevent network forks and ensure decentralization. This limit is tracked via the `LatestPubkeyToTinyBlocksCount` state variable and enforced through three critical checkpoints that all compare the stored pubkey against the current miner's pubkey.

**Validation Checkpoint:** During block validation, the system checks if a miner has exceeded their continuous block limit by comparing the stored pubkey with the sender's pubkey. If they match and the counter is negative, validation fails. [1](#0-0) 

**Command Generation Checkpoint:** When generating consensus commands, the system forces a round transition if the stored pubkey matches the current miner's pubkey and the counter is negative. [2](#0-1) 

**Counter Reset Logic:** After processing each block, the system either decrements the counter (if pubkeys match) or resets it to maximum (if pubkeys differ). [3](#0-2) 

**Root Cause:** When a miner calls `ReplaceCandidatePubkey` through the Election contract [4](#0-3) , it triggers `RecordCandidateReplacement` in the consensus contract. This method updates the round information to replace the old pubkey with the new one [5](#0-4) , but critically **never updates** `State.LatestPubkeyToTinyBlocksCount`.

This creates a permanent mismatch where:
- `LatestPubkeyToTinyBlocksCount.Pubkey` = old pubkey  
- `SenderPubkey` / `_processingBlockMinerPubkey` = new pubkey

When the miner produces their next block with the new key, all three pubkey equality checks evaluate to false (old_pubkey != new_pubkey), causing:
1. Validation to pass even if `BlocksCount < 0`
2. `GetConsensusCommand` to not force `NextRound` behavior
3. Counter to reset to maximum value instead of remaining negative

The miner can prepare multiple keypairs in advance and repeat this process. While old keys become banned after replacement [6](#0-5) , this only prevents reuse of the same key - it doesn't prevent the exploit pattern itself.

### Impact Explanation

**Consensus Integrity Violation:** The continuous blocks limit exists to prevent network instability and forks. The maximum limit is defined as 8 blocks [7](#0-6)  and is dynamically adjusted based on blockchain health to prevent fork proliferation [8](#0-7) .

By bypassing this limit, a malicious miner can:
- Produce unlimited continuous blocks by repeatedly changing keys
- Defeat fork prevention mechanisms designed to maintain network stability
- Cause network synchronization issues for other nodes
- Violate protocol-level decentralization guarantees
- Undermine the blockchain health monitoring system

**Severity Assessment:** Medium - This violates a critical consensus safety mechanism, but requires modest preparation (multiple prepared keypairs) and is visible on-chain through replacement events.

### Likelihood Explanation

**Attacker Capabilities:**
- Miner must control their candidate admin account (typical scenario as miners usually manage their own accounts) [9](#0-8) 
- Miner must prepare multiple valid keypairs in advance
- Each old key becomes banned after use, requiring multiple prepared keys

**Attack Complexity:** Low - The attack only requires calling a public contract method between block productions with no complex preconditions.

**Feasibility:** High
- Entry point `ReplaceCandidatePubkey` is publicly accessible
- No rate limiting or cooldown period exists on key replacements
- Miner can generate multiple keypairs offline before the attack
- Execution timing between blocks is straightforward

**Detection:** Partial - Key replacements are visible on-chain through events [10](#0-9) , but distinguishing legitimate replacements from exploit attempts is difficult without additional context.

**Economic Rationality:** High - The cost is minimal (only transaction fees), no collateral is at risk, and the attacker gains a potential advantage in block production that could increase mining rewards.

**Overall Likelihood:** Medium - Practical for any miner to execute with modest preparation of multiple keypairs.

### Recommendation

Update the `RecordCandidateReplacement` method to also update the `LatestPubkeyToTinyBlocksCount` state variable when a miner's pubkey is replaced. The fix should update the stored pubkey to the new value while preserving the current `BlocksCount`:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // If this candidate is current miner, need to modify current round information.
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // **FIX: Update LatestPubkeyToTinyBlocksCount if it contains the old pubkey**
    var latestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value;
    if (latestPubkeyToTinyBlocksCount != null && 
        latestPubkeyToTinyBlocksCount.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = latestPubkeyToTinyBlocksCount.BlocksCount
        };
    }

    // Notify Treasury Contract to update replacement information.
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

This ensures that when a miner's pubkey is replaced, the continuous blocks tracking state is properly updated, preventing the bypass exploit while maintaining the counter's enforcement value.

### Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimitBypass_ViaKeyReplacement()
{
    // Setup: Miner produces blocks until limit is exceeded
    var miner = InitialCoreDataCenterKeyPairs[0];
    var oldPubkey = miner.PublicKey.ToHex();
    
    // Produce 9 blocks to exceed limit (MaximumTinyBlocksCount = 8)
    for (int i = 0; i < 9; i++)
    {
        await ProduceTinyBlock(miner);
    }
    
    // Verify counter is negative
    var counterBefore = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    var latestPubkeyCount = await GetLatestPubkeyToTinyBlocksCount();
    Assert.Equal(oldPubkey, latestPubkeyCount.Pubkey);
    Assert.True(latestPubkeyCount.BlocksCount < 0);
    
    // Replace pubkey
    var newKeyPair = CryptoHelper.GenerateKeyPair();
    var newPubkey = newKeyPair.PublicKey.ToHex();
    await ElectionStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey
    });
    
    // Verify: LatestPubkeyToTinyBlocksCount still has old pubkey (vulnerability)
    var latestPubkeyCountAfter = await GetLatestPubkeyToTinyBlocksCount();
    Assert.Equal(oldPubkey, latestPubkeyCountAfter.Pubkey); // Still old pubkey!
    Assert.True(latestPubkeyCountAfter.BlocksCount < 0);
    
    // Exploit: Produce block with new key - should fail but succeeds
    await ProduceTinyBlock(newKeyPair);
    
    // Verify: Counter was reset instead of staying negative (bypass successful)
    var latestPubkeyCountFinal = await GetLatestPubkeyToTinyBlocksCount();
    Assert.Equal(newPubkey, latestPubkeyCountFinal.Pubkey); // Now new pubkey
    Assert.True(latestPubkeyCountFinal.BlocksCount >= 0); // Counter was reset!
    
    // Miner can now produce 8 more blocks, bypassing the limit
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-363)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L250-254)
```csharp
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```
