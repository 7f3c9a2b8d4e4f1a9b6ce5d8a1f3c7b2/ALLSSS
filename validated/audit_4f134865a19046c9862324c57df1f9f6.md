# Audit Report

## Title
Unvalidated Secret Sharing Reveals Allow Consensus State Corruption and Mining Order Manipulation

## Summary
The AEDPoS consensus contract accepts revealed InValues from block producers without cryptographic verification, allowing malicious miners to inject arbitrary `PreviousInValue` data for miners who missed their time slots. This corrupts consensus state, manipulates mining order calculations, and pollutes randomness generation.

## Finding Description

The vulnerability exists in two parallel code paths that process revealed InValues without cryptographic verification:

**Vulnerable Path 1 - UpdateLatestSecretPieces():**
The function accepts revealed InValues from trigger information and sets them directly into the round state without any cryptographic validation. [1](#0-0) 
The only check performed is whether the target miner's `PreviousInValue` field is currently empty or null—no verification that the revealed value is cryptographically correct.

**Vulnerable Path 2 - PerformSecretSharing():**
During UpdateValue transaction processing, this function directly persists the `MinersPreviousInValues` dictionary to chain state without validation. [2](#0-1) 
These values originated from the corrupted round state created by UpdateLatestSecretPieces.

**Validation Gap:**
The UpdateValueValidationProvider only validates the sender's own PreviousInValue, not the revealed values for other miners. [3](#0-2) 
The validation explicitly checks `validationContext.SenderPubkey` and ignores the `MinersPreviousInValues` dictionary entirely.

**Legitimate Path Comparison:**
The correct implementation exists in `RevealSharedInValues()`, which performs Shamir's Secret Sharing reconstruction using `SecretSharingHelper.DecodeSecret()`. [4](#0-3) 
However, this function is only called during NextRound behavior, not during UpdateValue processing, and requires sufficient decrypted pieces which won't exist for miners who missed their slots.

**Attack Flow:**
1. Attacker modifies their node's off-chain trigger information generation to return arbitrary fake values for target victims
2. When attacker produces a block, `UpdateLatestSecretPieces()` sets fake PreviousInValue for victim without validation
3. Transaction validation passes because `UpdateValueValidationProvider` only checks attacker's own PreviousInValue
4. Fake values persist to state via `PerformSecretSharing()`
5. During subsequent round preparation, `SupplyCurrentRoundInformation()` retrieves the fake PreviousInValue [5](#0-4) 
6. The fake PreviousInValue generates a fake signature
7. The fake signature determines victim's mining order via modulo operation [6](#0-5) 

## Impact Explanation

**Consensus Integrity Violation:** The attack directly corrupts on-chain consensus state by setting incorrect `PreviousInValue`, `InValue`, and `Signature` fields for victim miners. The consensus invariant that each miner's signature must derive from their genuine InValue is violated.

**Mining Order Manipulation:** The corrupted signature directly determines the victim's `SupposedOrderOfNextRound`. An attacker can systematically target specific miners to alter when they can produce blocks, potentially gaining unfair advantages or causing victims to miss their slots.

**Randomness Corruption:** Miner signatures contribute to consensus randomness through XOR aggregation. [7](#0-6) 
Injecting fake signatures pollutes this randomness source, enabling potential manipulation of round-based randomness used throughout the consensus system.

**State Persistence:** Once a fake `PreviousInValue` is set, the victim cannot correct it until they successfully produce a block with their real value. The fake data propagates through subsequent rounds, and the legitimate cryptographic reconstruction path (`RevealSharedInValues`) cannot recover values for miners who missed slots due to insufficient decrypted pieces.

## Likelihood Explanation

**Attacker Profile:** Any authorized miner in the consensus pool can execute this attack by modifying their local node software to provide malicious trigger information.

**Attack Complexity:** Low. The attacker only needs to modify their off-chain trigger information generation to return arbitrary values. No cryptographic operations, complex timing, or multi-party coordination is required. The on-chain contract accepts these values without validation.

**Preconditions:**
1. Attacker is an active miner in the current round
2. Target victim miner misses their time slot (hasn't produced `OutValue` yet in current round)
3. Attacker produces a block before victim in the same round

These preconditions are realistic—missed time slots occur regularly in distributed networks due to network latency, node failures, or maintenance.

**Detection Difficulty:** High. No on-chain validation flags fake revealed values, corrupted state appears as legitimate consensus data, and victims only discover issues when attempting to mine.

**Economic Feasibility:** The attack cost is minimal—only the gas cost of producing a normal block. Potential gains include unfair mining advantages, ability to manipulate specific miners' schedules, and disruption of consensus randomness.

## Recommendation

Implement cryptographic validation of revealed InValues in `UpdateLatestSecretPieces()` and `PerformSecretSharing()`:

1. Store sufficient on-chain decrypted pieces to enable cryptographic reconstruction
2. When processing `RevealedInValues`, verify each revealed value by reconstructing it from on-chain decrypted pieces using `SecretSharingHelper.DecodeSecret()`
3. Only accept revealed values that match the cryptographically reconstructed value
4. Extend `UpdateValueValidationProvider` to validate the `MinersPreviousInValues` dictionary, not just the sender's own value
5. For miners with insufficient pieces for reconstruction, use a deterministic fallback (like the existing fake InValue generation) rather than accepting unvalidated user-provided values

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a test network with multiple miners
2. Having one miner miss their time slot
3. Having an attacker miner produce a block with modified trigger information containing a fake revealed InValue for the victim
4. Observing that the fake value is persisted to state without validation
5. Verifying that the victim's calculated signature and mining order are based on the fake value rather than their genuine InValue

The core issue is visible in the code where revealed values flow through `UpdateLatestSecretPieces()` → `PerformSecretSharing()` without any cryptographic validation against on-chain decrypted pieces that could be used to verify correctness.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
