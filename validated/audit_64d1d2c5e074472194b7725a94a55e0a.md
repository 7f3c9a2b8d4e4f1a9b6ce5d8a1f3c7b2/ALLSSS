# Audit Report

## Title
Precision Loss in SafeCalculateProfits Causes Permanent Fund Lockup in Period-Specific Virtual Addresses

## Summary
The `SafeCalculateProfits` method uses truncating `(long)` cast that rounds down profit calculations, causing dust amounts to permanently accumulate in period-specific virtual addresses. Since each period generates a unique virtual address via hash functions and no recovery mechanism exists, these funds become permanently locked and unrecoverable over time.

## Finding Description

The ProfitContract contains a systematic precision loss issue that causes permanent fund lockup through two mechanisms:

**1. Truncating Arithmetic in SafeCalculateProfits:**

The method performs decimal calculations but truncates when casting to long: [1](#0-0) 

This always rounds DOWN, causing each beneficiary to receive slightly less than their exact proportional share.

**2. Two-Level Precision Loss:**

First, during sub-scheme distribution, truncated amounts are calculated and sent: [2](#0-1) 

The remainder (including first-level dust) is transferred to the period-specific virtual address: [3](#0-2) 

Second, when beneficiaries claim via `ClaimProfits`, truncation occurs again: [4](#0-3) 

**3. Permanent Lockup via Unique Virtual Addresses:**

Each period uses a unique virtual address generated by XORing the scheme ID with a hash of the period number: [5](#0-4) 

This means:
- Period 1's dust remains in virtual address Hash(schemeId XOR Hash(1))
- Period 2's dust accumulates in virtual address Hash(schemeId XOR Hash(2))
- These addresses are never reused or swept

**4. No Recovery Mechanism:**

The `BurnProfits` method only operates on the scheme's general ledger, not period-specific addresses: [6](#0-5) 

The only way funds leave period-specific addresses is through beneficiary claims, which themselves cause additional dust accumulation.

## Impact Explanation

**Direct Fund Loss:**
- Each distribution creates dust from truncation (typically < 1 token per distribution)
- Example: 99 tokens among 3 beneficiaries with shares (3333, 3333, 3334) out of 10000:
  - Beneficiary 1: `(long)(99 * 3333 / 10000)` = 32 tokens
  - Beneficiary 2: `(long)(99 * 3333 / 10000)` = 32 tokens  
  - Beneficiary 3: `(long)(99 * 3334 / 10000)` = 33 tokens
  - Total distributed: 97 tokens
  - **Permanently locked: 2 tokens**

**Systemic Impact:**
- Affects ALL profit schemes including Treasury, TokenHolder, and Election dividends
- Cumulative over time: For daily distributions over 5 years = 1,825+ locked tokens per scheme
- No recovery mechanism means funds are permanently lost
- Impacts protocol treasury and all stakeholders

## Likelihood Explanation

**Probability: CERTAIN (100%)**
- Occurs automatically on EVERY distribution where shares don't divide evenly into the amount
- No attacker action required - this is an inherent design flaw
- Guaranteed by the truncating `(long)` cast in arithmetic operations

**Reachability:**
`DistributeProfits` is publicly callable by authorized scheme managers and the TokenHolder contract: [7](#0-6) 

**Execution Complexity: TRIVIAL**
- Normal protocol operation automatically triggers the vulnerability
- No special preconditions or timing requirements
- Works under all standard AElf contract semantics

## Recommendation

Implement a dust recovery mechanism with the following approaches:

**Option 1: Admin Sweep Function**
Add a privileged function (callable by scheme manager or Parliament) to transfer remaining dust from old period addresses back to the scheme's general ledger.

**Option 2: Automatic Sweep During Distribution**
When distributing a new period, check and sweep any remaining balance from old periods (e.g., periods older than `ProfitReceivingDuePeriodCount`) back to the general ledger before new distribution.

**Option 3: Higher Precision Arithmetic**
Use higher precision throughout calculations and only truncate at the final beneficiary transfer, reducing but not eliminating dust accumulation.

**Recommended Fix (Option 2 + 1):**
```csharp
// Add to DistributeProfits before line 492
private void SweepOldPeriodDust(Hash schemeId, long currentPeriod, Scheme scheme)
{
    var oldPeriodThreshold = currentPeriod - scheme.ProfitReceivingDuePeriodCount - 1;
    if (oldPeriodThreshold > 0)
    {
        for (var period = 1; period <= oldPeriodThreshold; period++)
        {
            var oldPeriodAddress = GetDistributedPeriodProfitsVirtualAddress(schemeId, period);
            // Sweep any remaining balance back to general ledger
            foreach (var symbol in scheme.ReceivedTokenSymbols)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = oldPeriodAddress,
                    Symbol = symbol
                }).Balance;
                if (balance > 0)
                {
                    Context.SendVirtualInline(
                        GeneratePeriodVirtualAddressFromHash(schemeId, period),
                        State.TokenContract.Value,
                        nameof(State.TokenContract.Transfer),
                        new TransferInput
                        {
                            To = scheme.VirtualAddress,
                            Amount = balance,
                            Symbol = symbol
                        }.ToByteString());
                }
            }
        }
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task PrecisionLoss_CausesDustLockup_Test()
{
    // Setup: Create scheme with 3 beneficiaries
    const long shares1 = 3333;
    const long shares2 = 3333;
    const long shares3 = 3334;
    const long distributionAmount = 99;
    
    var creator = Creators[0];
    var schemeId = await CreateSchemeAsync();
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = Accounts[0].Address, Shares = shares1 }
    });
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = Accounts[1].Address, Shares = shares2 }
    });
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = Accounts[2].Address, Shares = shares3 }
    });
    
    // Contribute and distribute
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = distributionAmount,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, distributionAmount } }
    });
    
    // All beneficiaries claim
    await Normal[0].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await Normal[1].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await Normal[2].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    
    // Check period address has dust locked
    var periodAddress = await creator.GetSchemeAddress.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    var lockedBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = periodAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    // Expected: 2 tokens locked due to truncation
    // 99 - (32 + 32 + 33) = 2 tokens permanently locked
    lockedBalance.ShouldBe(2);
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-429)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");

```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L517-558)
```csharp
    private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
        Address profitsReceivingVirtualAddress)
    {
        scheme.CurrentPeriod = period.Add(1);

        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            if (amount > 0)
            {
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-60)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```
