# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass Due to Premature State Recovery

## Summary
The `LibInformationValidationProvider` validation logic in the AEDPoS consensus contract is broken because `RecoverFromUpdateValue` modifies the `baseRound` state before validation occurs. This causes the validation check to compare identical values instead of comparing StateDb values against newly provided values, allowing malicious miners to report artificially low `ImpliedIrreversibleBlockHeight` values that would otherwise be rejected. This can prevent Last Irreversible Block (LIB) advancement if 1/3+ miners collude.

## Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior. The validation sequence executes as follows:

**State Retrieval**: The validation process begins by fetching the current round from StateDb. [1](#0-0) 

**Premature Recovery**: Before validation providers are invoked, `RecoverFromUpdateValue` is called on `baseRound` for UpdateValue behavior. [2](#0-1) 

**State Corruption**: The `RecoverFromUpdateValue` method copies values from `providedRound` into `baseRound`, including the miner's `ImpliedIrreversibleBlockHeight`. [3](#0-2) 

**Validation Context Creation**: A validation context is created using the now-modified `baseRound`. [4](#0-3) 

**Broken Validation**: The `LibInformationValidationProvider` is added to validators [5](#0-4)  and attempts to validate that the miner's `ImpliedIrreversibleBlockHeight` hasn't decreased. [6](#0-5) 

**Root Cause**: Since `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was already overwritten with `providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight`, the comparison always evaluates identical values. The check can never detect a decrease because both sides of the comparison reference the same value.

The validation context uses `ProvidedRound` as a property that returns `ExtraData.Round` [7](#0-6) , which is the same round data that was used to modify `baseRound`.

## Impact Explanation

**Operational Impact - High Severity**:

**LIB Finalization Prevention**: Malicious miners can report artificially low `ImpliedIrreversibleBlockHeight` values without detection. During LIB calculation, these values are sorted and the value at position `(count-1)/3` is selected as the new LIB height. [8](#0-7)  If 1/3+ miners collude to provide artificially low values, the calculated LIB will be suppressed.

**Cross-Chain Operations Disruption**: LIB height is critical for cross-chain verification and merkle proof validation. Stalled LIB prevents parent/side-chain synchronization and cross-chain message processing.

**State Management Issues**: LIB determines which blocks can be safely pruned from the state database. Preventing LIB advancement causes unbounded state growth and eventual resource exhaustion.

**Transaction Finality Delay**: Users cannot achieve finality guarantees on their transactions when LIB is stalled, affecting economic activity and user confidence in the system.

While this is a liveness attack rather than a safety violation (LIB cannot decrease due to the check in ProcessUpdateValue [9](#0-8) ), the operational impact is severe enough to warrant HIGH severity classification.

## Likelihood Explanation

**Medium Likelihood**:

**Attacker Capabilities**: 
- Must be an elected miner in the consensus round (achievable through the election mechanism)
- Can modify consensus extra data before block production, as the `ImpliedIrreversibleBlockHeight` is set by the contract [10](#0-9)  and the miner receives this data which they can tamper with before signing and producing the block

**Attack Complexity**: 
- Low complexity for an individual miner to provide false data
- Medium complexity to coordinate 1/3+ miners for significant LIB impact
- No cryptographic protection prevents miners from modifying their own consensus extra data

**Feasibility Conditions**:
- Block validation is sequential via the ACS4 interface [11](#0-10) 
- Post-execution validation also fails to detect tampering since it uses the same recovery pattern [12](#0-11) 

**Detection/Operational Constraints**:
- Attack is detectable through explicit monitoring of individual miner `ImpliedIrreversibleBlockHeight` reports
- Miners have reputation and economic stake at risk through the election mechanism
- However, subtle variations in reported heights may go unnoticed without dedicated monitoring infrastructure

## Recommendation

The fix requires preserving the original StateDb value before calling `RecoverFromUpdateValue`. The validation should compare the **original** StateDb value against the provided value:

```csharp
// In ValidateBeforeExecution method
if (!TryToGetCurrentRoundInformation(out var baseRound))
    return new ValidationResult { Success = false, Message = "Failed to get current round information." };

// Store original value BEFORE recovery
var originalBaseRound = baseRound.Clone(); // or store specific values needed for validation

if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

// Pass BOTH original and recovered rounds to validation context
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,
    OriginalBaseRound = originalBaseRound, // Add this field
    // ... other fields
};
```

Then update `LibInformationValidationProvider` to use `OriginalBaseRound` for comparison:

```csharp
var originalBaseRound = validationContext.OriginalBaseRound;
var providedRound = validationContext.ProvidedRound;

if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
    originalBaseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
{
    validationResult.Message = "Incorrect implied lib height.";
    return validationResult;
}
```

## Proof of Concept

The vulnerability can be demonstrated by creating a test that shows the validation always passes even when providing decreasing `ImpliedIrreversibleBlockHeight` values:

```csharp
[Fact]
public async Task LibValidation_ShouldReject_DecreasingImpliedIrreversibleBlockHeight()
{
    // Setup: Miner produces first block with ImpliedIrreversibleBlockHeight = 100
    var miner = SampleAccount.Accounts[0];
    var currentHeight = 100L;
    
    // Produce first block - this sets the baseline
    var round1 = await ProduceNormalBlock(miner, currentHeight);
    Assert.Equal(100L, round1.RealTimeMinersInformation[miner.PublicKey.ToHex()].ImpliedIrreversibleBlockHeight);
    
    // Attack: Same miner tries to produce next block with LOWER ImpliedIrreversibleBlockHeight = 50
    var maliciousExtraData = CreateUpdateValueExtraData(miner, impliedIrreversibleHeight: 50L);
    
    // Validation should REJECT this, but it PASSES due to the bug
    var validationResult = await ConsensusStub.ValidateConsensusBeforeExecution.CallAsync(
        new BytesValue { Value = maliciousExtraData.ToByteString() }
    );
    
    // BUG: This assertion FAILS because validation incorrectly passes
    Assert.False(validationResult.Success, "Validation should reject decreasing ImpliedIrreversibleBlockHeight");
    Assert.Contains("Incorrect implied lib height", validationResult.Message);
}
```

**Notes**

This is a Time-of-Check-Time-of-Use (TOCTOU) vulnerability where the validation data is modified before the check occurs. The issue affects consensus finality and could be exploited by Byzantine miners to stall the Last Irreversible Block, impacting cross-chain operations, state management, and transaction finality guarantees. The vulnerability requires coordination of 1/3+ malicious miners for significant impact, placing it at MEDIUM likelihood but HIGH impact due to the operational consequences for the network.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-272)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```
