# Audit Report

## Title
3-Miner Configuration Creates Zero Fault Tolerance for Last Irreversible Block Advancement

## Summary
The AEDPoS consensus contract permits exactly 3 miners to be configured, requiring unanimous participation (3/3) for Last Irreversible Block (LIB) advancement. This provides zero fault tolerance—when any single miner experiences operational failure, LIB stops advancing indefinitely, halting transaction finality and blocking cross-chain operations.

## Finding Description

The Byzantine Fault Tolerance threshold for consensus is calculated by `MinersCountOfConsent`, which implements the formula: `count × 2 ÷ 3 + 1`. [1](#0-0) 

For exactly 3 miners, this evaluates to: `3 × 2 ÷ 3 + 1 = 2 + 1 = 3`, requiring unanimous participation from all three miners.

The `LastIrreversibleBlockHeightCalculator` determines LIB advancement by retrieving miners who participated in the current round and checking their count against `MinersCountOfConsent`. [2](#0-1)  If participating miners fall below this threshold, the calculator sets `libHeight = 0`, preventing any blocks from becoming irreversible. [3](#0-2) 

During block production, `ProcessUpdateValue` calculates the new LIB height and only advances it when the calculated height exceeds the current confirmed height. [4](#0-3)  When `libHeight = 0`, no advancement occurs.

The `SetMaximumMinersCount` method validates only that the input value is positive, with no minimum threshold enforcing fault-tolerant configurations. [5](#0-4)  Test cases explicitly validate 3-miner configurations as acceptable without warnings. [6](#0-5) 

While `SolitaryMinerDetection` prevents a single miner from continuing indefinitely when all others are offline, [7](#0-6)  it does not address the scenario where 2 out of 3 miners continue producing blocks but cannot reach the unanimous consensus threshold.

## Impact Explanation

**Operational Denial of Service on Transaction Finality:**

When LIB stops advancing, no new blocks become irreversible, leaving all transactions in an unfinalized state indefinitely. This creates operational uncertainty for users and applications requiring finality guarantees.

**Cross-Chain Operations Blocked:**

Cross-chain indexing mechanisms explicitly validate irreversible block existence before proceeding. [8](#0-7)  The system retrieves chain height pairs at the current LIB for cross-chain cache updates. [9](#0-8)  When LIB advancement halts, all cross-chain operations requiring irreversible block proofs are blocked.

**Severity Justification:**

This is a **Medium severity** availability issue. The system maintains safety (no invalid blocks accepted, no funds at risk), but loses liveness (blocks cannot achieve finality). While block production continues with 2 out of 3 miners, the inability to finalize blocks creates cascading operational impacts on dependent protocols and cross-chain infrastructure.

## Likelihood Explanation

**High Likelihood in 3-Miner Configurations:**

The configuration is explicitly permitted and tested without warnings or minimum validation requirements. Single-node failures are common operational events in distributed systems, including hardware failures, software updates, network partitions, scheduled maintenance, and resource exhaustion.

**No Attacker Required:**

This is not an attack scenario—it is a natural operational failure mode. Any system configured with exactly 3 miners will experience this issue whenever a single miner becomes unavailable, which is a realistic and expected event in any distributed system deployment. The issue manifests immediately and is observable through monitoring systems tracking `ConfirmedIrreversibleBlockHeight`.

## Recommendation

Implement minimum threshold validation in `SetMaximumMinersCount` to enforce fault-tolerant configurations:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    // Enforce minimum of 4 miners to ensure fault tolerance
    Assert(input.Value >= 4, "Minimum 4 miners required for fault tolerance.");
    
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");
    
    // ... rest of implementation
}
```

This ensures any deployment maintains at least (2f+1) = 3 miners for consensus with one additional for fault tolerance, preventing zero-tolerance configurations.

## Proof of Concept

```csharp
[Fact]
public async Task ThreeMinerConfiguration_SingleFailure_StopsLIB()
{
    // Setup: Configure exactly 3 miners
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ConsensusContractAddress,
        ContractMethodName = nameof(ConsensusStub.SetMaximumMinersCount),
        Params = new Int32Value { Value = 3 }.ToByteString(),
        OrganizationAddress = defaultOrganizationAddress
    });
    
    // Verify 3 miners are configured
    var minerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    minerList.Pubkeys.Count.ShouldBe(3);
    
    // Mine blocks with all 3 miners - LIB advances
    var libBefore = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    await MineBlocksWithAllMiners();
    var libAfter = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    libAfter.ConfirmedIrreversibleBlockHeight.ShouldBeGreaterThan(libBefore.ConfirmedIrreversibleBlockHeight);
    
    // Simulate 1 miner offline - only 2 miners produce blocks
    var libBeforeFailure = libAfter.ConfirmedIrreversibleBlockHeight;
    await MineBlocksWithTwoMinersOnly();
    
    // Verify LIB does NOT advance despite new blocks being produced
    var libAfterFailure = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    libAfterFailure.ConfirmedIrreversibleBlockHeight.ShouldBe(libBeforeFailure); // LIB stuck!
    
    // Verify cross-chain operations are blocked
    var chainHeights = await CrossChainService.GetAllChainIdHeightPairsAtLibAsync();
    // chainHeights remains at old LIB height, cannot advance
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-128)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L27-29)
```csharp
    [InlineData(7)]
    [InlineData(3)]
    public async Task SetMaximumMinersCountTest(int targetMinersCount)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-83)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L159-162)
```csharp
        var isReadyToCreateChainCache =
            await _irreversibleBlockStateProvider.ValidateIrreversibleBlockExistingAsync();
        if (!isReadyToCreateChainCache)
            return new ChainIdAndHeightDict();
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L44-45)
```csharp
        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();
```
