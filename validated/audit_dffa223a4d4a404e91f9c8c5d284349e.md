# Audit Report

## Title
Unbounded State Bloat via Unlimited Profit Scheme Creation in TokenHolderContract

## Summary
The `CreateScheme()` function in TokenHolderContract allows any user to create unlimited profit schemes without authorization or duplicate checks. Each invocation creates a new permanent scheme in ProfitContract while only the latest is tracked in TokenHolderContract, resulting in unbounded state accumulation that consumes blockchain storage indefinitely.

## Finding Description

The vulnerability exists in the interaction between TokenHolderContract and ProfitContract during scheme creation:

**Unrestricted Entry Point:**
The `CreateScheme()` function is publicly accessible with no authorization validation whatsoever. [1](#0-0) 

**Storage Overwrite in TokenHolderContract:**
Each call unconditionally overwrites the single scheme slot per address in `State.TokenHolderProfitSchemes[Context.Sender]`, with no check for existing schemes. [2](#0-1) 

The state definition confirms only one scheme reference is maintained per address. [3](#0-2) 

**Unbounded Accumulation in ProfitContract:**
Each `CreateScheme` call generates a new unique schemeId based on an incrementing counter, not the scheme content. [4](#0-3) 

The scheme is then stored permanently in state and added to the manager's unbounded scheme list. [5](#0-4) 

The duplicate check at line 59 only prevents identical schemeIds, but since each schemeId is unique (based on incrementing counter), this check never prevents multiple schemes per manager. [6](#0-5) 

**Inconsistent Scheme Access:**
When TokenHolderContract retrieves schemes, it uses `FirstOrDefault()` which only accesses the first scheme in the list, not the latest one that was stored in TokenHolderContract state. [7](#0-6) 

This creates an inconsistency where subsequent schemes become orphanedâ€”stored permanently in ProfitContract state but not the one actually used by TokenHolderContract operations.

**No Cleanup Mechanism:**
No method exists in ProfitContract to delete or remove a top-level scheme. The contract provides `RemoveSubScheme` and `ResetManager`, but neither removes the scheme from state storage. [8](#0-7) 

All schemes persist permanently in `State.SchemeInfos`. [9](#0-8) 

## Impact Explanation

This vulnerability enables unbounded state bloat with permanent blockchain-wide impact:

**Direct State Impact:**
- Each scheme consumes significant storage: SchemeId (Hash), VirtualAddress (Address), Manager (Address), period counts (int64), configuration flags (bool), ReceivedTokenSymbols (repeated string field), SubSchemes (repeated nested message), and CachedDelayTotalShares (map<int64,int64>)
- An attacker can create thousands of schemes from a single address at minimal cost (only transaction fees)
- All schemes persist permanently in distributed state storage with no removal mechanism

**Blockchain-Wide Consequences:**
- Unbounded growth of ProfitContract state database
- Increased node synchronization time as the state database expands
- Degraded query performance for scheme lookups and beneficiary operations
- All validators must store, maintain, and replicate the bloated state permanently across the network

**Economic Viability:**
The attack requires only transaction fees with no token locks, burns, stakes, or collateral. This makes it economically feasible for an attacker to inflict disproportionate permanent storage costs on the entire network. A small expenditure in transaction fees results in permanent state growth that all validators must bear forever.

## Likelihood Explanation

**Execution Complexity:** Trivial - the attacker simply calls `CreateScheme()` repeatedly with any valid input parameters. No complex transaction orchestration or timing requirements exist.

**Attacker Prerequisites:** None - the function is publicly accessible to any address. No special permissions, governance approvals, token holdings, or contract allowances are required.

**Attack Barriers:** None identified in the codebase:
- No rate limiting on scheme creation
- No duplicate prevention check in TokenHolderContract before calling ProfitContract
- No validation that a scheme already exists for the caller
- No economic penalty beyond transaction fees (no deposits, stakes, or burns)

**Detection/Mitigation:** The attack is visible on-chain through transaction logs and state growth metrics, but the damage is irreversible once schemes are created since no removal mechanism exists. Network cannot prevent the attack without protocol upgrade.

## Recommendation

Implement multiple defensive layers:

**1. Add Duplicate Prevention in TokenHolderContract:**
Before line 20 in `CreateScheme()`, add:
```csharp
Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
       "Scheme already exists for this address.");
```

**2. Add Scheme Removal Capability in ProfitContract:**
Implement a `RemoveScheme` method that allows the manager to delete a scheme when it has no active beneficiaries and zero balance, properly cleaning up:
- `State.SchemeInfos[schemeId]`
- Entry in `State.ManagingSchemeIds[manager]`
- Associated `State.ProfitDetailsMap` entries

**3. Add Economic Disincentive:**
Consider requiring a refundable deposit when creating schemes through TokenHolderContract, returned only when the scheme is properly cleaned up. This discourages spam while maintaining legitimate functionality.

**4. Add Scheme Count Limit:**
Implement a per-address maximum scheme count (e.g., 10) to prevent abuse while allowing legitimate multi-scheme use cases.

## Proof of Concept

```csharp
[Fact]
public async Task UnboundedSchemeCreation_StateBlotAttack()
{
    // Attacker creates multiple schemes with minimal cost
    const int attackIterations = 100;
    
    for (int i = 0; i < attackIterations; i++)
    {
        // Each call succeeds and creates a new permanent scheme
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = 100
        });
    }
    
    // Verify: ProfitContract has 100 schemes for this manager
    var managedSchemes = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = DefaultSender });
    
    managedSchemes.SchemeIds.Count.ShouldBe(attackIterations);
    
    // Verify: TokenHolderContract only tracks the latest one
    var trackedScheme = await TokenHolderContractStub.GetScheme.CallAsync(DefaultSender);
    trackedScheme.ShouldNotBeNull();
    
    // Verify: FirstOrDefault returns the FIRST scheme, not the latest
    var firstSchemeId = managedSchemes.SchemeIds.First();
    var firstScheme = await ProfitContractStub.GetScheme.CallAsync(firstSchemeId);
    firstScheme.SchemeId.ShouldBe(firstSchemeId);
    
    // 99 schemes are orphaned in ProfitContract state forever
    // All 100 schemes consume permanent storage across all validators
}
```

## Notes

This vulnerability represents a critical protocol-level state management flaw. The design intentionally allows ProfitContract to support multiple schemes per manager (as evidenced by the use of lists and counter-based ID generation), but TokenHolderContract's public `CreateScheme()` method exposes this capability without proper access control or duplicate prevention.

The inconsistency between TokenHolderContract tracking only one scheme via simple overwrite while ProfitContract accumulates all schemes in an unbounded list creates both the orphaning issue and the state bloat vector. The lack of any cleanup mechanism in ProfitContract makes all created schemes permanent, converting a design feature into an exploitable vulnerability when exposed through an unrestricted public interface.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L59-59)
```csharp
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L60-71)
```csharp
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L723-743)
```csharp
    public override Empty ResetManager(ResetManagerInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");

        // Transfer managing scheme id.
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;

        scheme.Manager = input.NewManager;
        State.SchemeInfos[input.SchemeId] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L9-9)
```csharp
    public MappedState<Hash, Scheme> SchemeInfos { get; set; }
```
