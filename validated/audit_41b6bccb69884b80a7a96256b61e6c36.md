# Audit Report

## Title
TokenHolder Scheme Overwrite Causes Permanent Token Lock for Registered Users

## Summary
The `CreateScheme` method in TokenHolderContract unconditionally overwrites scheme state without validation, enabling a critical vulnerability where users' locked tokens become permanently inaccessible when a manager creates a second scheme with a different symbol. The withdrawal logic attempts to unlock tokens using the new scheme's symbol with lockIds that reference tokens locked under the original scheme's symbol, resulting in complete fund loss.

## Finding Description

The vulnerability stems from three interconnected contract methods that create a state inconsistency between scheme metadata and locked token records.

**Root Cause - State Overwrite Without Validation:**

The `CreateScheme` method unconditionally overwrites the scheme state mapping without checking if a scheme already exists for the manager: [1](#0-0) 

Meanwhile, the underlying Profit contract properly supports multiple schemes per manager by appending each new scheme to a list: [2](#0-1) 

**User Registration - Token Locking:**

When users call `RegisterForProfits`, the contract generates a deterministic lockId and locks tokens using the scheme's symbol at that point in time: [3](#0-2) 

**Withdrawal Failure - Symbol Mismatch:**

The critical flaw manifests during withdrawal. The `GetValidScheme` method retrieves the overwritten scheme data, and `UpdateTokenHolderProfitScheme` fetches the first scheme ID from ProfitContract but uses the overwritten symbol from TokenHolderProfitSchemes state: [4](#0-3) 

The `Withdraw` method then queries `GetLockedAmount` with the new symbol and the old lockId. Since `GetLockedAmount` returns the balance for the specific symbol queried: [5](#0-4) 

This returns 0 because no tokens of the new symbol were ever locked under that lockId. The contract then unlocks 0 tokens and permanently removes the lockId mapping: [6](#0-5) 

The original locked tokens remain permanently inaccessible with no recovery mechanism.

## Impact Explanation

**Direct Fund Loss:** This vulnerability causes complete and permanent loss of user funds. When a manager creates a second scheme with a different token symbol:
- All users who registered under the original scheme lose access to their locked tokens
- The tokens remain locked in the MultiToken contract but become inaccessible
- The lockId deletion prevents any future recovery attempts

**Scale of Impact:** If a popular scheme has thousands of registered users with locked tokens, a single `CreateScheme` transaction by the manager renders all those tokens permanently inaccessible. For example:
- User locks 1,000 ELF tokens under Scheme A (Symbol: "ELF")
- Manager creates Scheme B with Symbol: "USDT"
- User's withdrawal attempts query for locked USDT with the ELF lockId â†’ returns 0
- User's 1,000 ELF remains permanently locked with no recovery path

**Severity Assessment:** HIGH - This breaks the fundamental security guarantee that users can withdraw their locked tokens after the lock period expires. The vulnerability causes irreversible financial loss to innocent users through either accidental misconfiguration or malicious exploitation.

## Likelihood Explanation

**Attack Surface:** `CreateScheme` is a public method - any address can call it to manage their own schemes without additional access controls beyond the manager managing their own state.

**Execution Simplicity:** The vulnerability requires only:
1. Manager creates initial scheme (legitimate operation)
2. Users register and lock tokens (legitimate operation)
3. Manager calls `CreateScheme` again with different symbol (single transaction)

**Realistic Scenarios:**
- **Accidental Trigger:** A manager attempting to "update" scheme parameters may unknowingly call `CreateScheme` again, not realizing it overwrites critical state
- **Contract Upgrade Confusion:** During protocol upgrades, managers might recreate schemes thinking it's necessary
- **Malicious Exploitation:** A malicious manager can intentionally lock all user funds as an exit scam with zero cost

**No Protective Barriers:** 
- No duplicate scheme validation exists in CreateScheme
- No warning mechanisms alert users when scheme state changes
- The `RegisterForProfits` duplicate check only prevents users from registering twice: [7](#0-6) 

This does not protect against scheme overwrites by the manager.

**Likelihood Assessment:** MEDIUM to HIGH - The vulnerability can manifest through normal operational mistakes or deliberate exploitation, with no technical barriers preventing either scenario.

## Recommendation

Add validation in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation to prevent overwriting existing schemes
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager. Cannot create duplicate scheme.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, provide an explicit `UpdateScheme` method that preserves existing user registrations and validates the update is safe.

## Proof of Concept

```csharp
[Fact]
public async Task TokenHolder_SchemeOverwrite_CausesTokenLock()
{
    // 1. Manager creates initial scheme with ELF symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // 2. User registers and locks 1000 ELF tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await UserTokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = ManagerAddress,
        Amount = 1000
    });
    
    // Verify tokens are locked
    var lockedBefore = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = UserAddress,
        Symbol = "ELF",
        LockId = GenerateLockId(ManagerAddress, UserAddress)
    });
    lockedBefore.Amount.ShouldBe(1000);
    
    // 3. Manager creates second scheme with USDT symbol - OVERWRITES STATE
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 1
    });
    
    // 4. User attempts withdrawal after lock period
    await UserTokenHolderContractStub.Withdraw.SendAsync(ManagerAddress);
    
    // 5. Verify ELF tokens remain locked but user lost access
    var lockedAfter = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = UserAddress,
        Symbol = "ELF",
        LockId = GenerateLockId(ManagerAddress, UserAddress)
    });
    
    // Tokens still locked - PERMANENT FUND LOSS
    lockedAfter.Amount.ShouldBe(1000);
    
    // LockId mapping deleted - no recovery possible
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(ManagerAddress);
    scheme.Symbol.ShouldBe("USDT"); // Overwritten to USDT
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L151-151)
```csharp
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-167)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-244)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```
