# Audit Report

## Title
Mining Order Manipulation via Unvalidated FinalOrderOfNextRound in UpdateValue Blocks

## Summary
The AEDPoS consensus validation logic fails to validate `FinalOrderOfNextRound` values in block headers for `UpdateValue` behavior. A malicious miner can manipulate these order values in their block header to control the mining sequence of the next round, bypassing the intended randomized consensus mechanism and conflict resolution logic.

## Finding Description

The vulnerability exists in the consensus header validation flow for `UpdateValue` blocks. When a miner produces an `UpdateValue` block, the block header contains a `Round` object with `FinalOrderOfNextRound` values for all miners.

**The Intended Flow:**

The honest flow calls `GetConsensusExtraDataToPublishOutValue`, which applies the proper order calculation via `ApplyNormalConsensusData`. [1](#0-0)  This function calculates `SupposedOrderOfNextRound` from the miner's signature and detects order conflicts, reassigning conflicting miners to different positions via conflict resolution logic. [2](#0-1) 

**The Attack Vector:**

Miners control their node software and can modify the `Round` object in the header to set arbitrary `FinalOrderOfNextRound` values for all miners after (or instead of) the proper calculation. The simplified header includes these values for all miners. [3](#0-2) 

**The Validation Gap:**

When the block is validated in `ValidateBeforeExecution`, the code calls `RecoverFromUpdateValue` which blindly copies `FinalOrderOfNextRound` values from the provided header for ALL miners without any validation. [4](#0-3) [5](#0-4) 

The validation for `UpdateValue` behavior only adds `UpdateValueValidationProvider` and `LibInformationValidationProvider`. [6](#0-5)  The `UpdateValueValidationProvider` only checks that `OutValue` and `Signature` are filled and validates `PreviousInValue` hash correctness - it does NOT validate order values. [7](#0-6) 

Critically, `NextRoundMiningOrderValidationProvider` (which validates `FinalOrderOfNextRound` distinctness and correctness) is only added for `NextRound` behavior, NOT for `UpdateValue`. [8](#0-7) [9](#0-8) 

**State Corruption:**

During execution, `ProcessUpdateValue` applies the manipulated `TuneOrderInformation` directly to state without validation, overwriting `FinalOrderOfNextRound` values for all affected miners. [10](#0-9) 

**Impact Propagation:**

When the next round is generated, `GenerateNextRoundInformation` orders miners by their `FinalOrderOfNextRound` values, directly using the attacker's manipulated values to determine mining order, time slots, and extra block producer selection. [11](#0-10) 

**Ineffective After-Validation:**

The `ValidateConsensusAfterExecution` performs a hash comparison, but this is ineffective because it compares the header (with manipulated FinalOrderOfNextRound) against state that was recovered using those same manipulated values via `RecoverFromUpdateValue`. [12](#0-11)  The hash includes `FinalOrderOfNextRound` as it is not cleared in the checkable round. [13](#0-12) 

## Impact Explanation

**Consensus Integrity Compromise:**
- Attackers can arbitrarily control the mining order for the next round, fundamentally breaking the signature-based randomized consensus mechanism
- Miners can guarantee themselves position 1 (first miner slot) for timing advantages and MEV extraction opportunities
- Can manipulate which miner becomes the extra block producer, affecting reward distribution
- Complete bypass of the conflict resolution logic that ensures fair randomized order assignment

**Economic Harm:**
- Priority manipulation enables potential MEV extraction by controlling mining sequence
- Can delay competing miners by pushing them to later time slots
- Affects reward distribution calculations that depend on mining order and extra block producer selection
- Miners can avoid penalty detection by manipulating their positions relative to time slot constraints

**Protocol Degradation:**
- Once one miner exploits this vulnerability, rational miners must follow to remain competitive, creating a race to the bottom
- Undermines the fairness and unpredictability of AEDPoS consensus, which is a core security property
- Long-term erosion of trust in the consensus randomness mechanism
- Violates the fundamental consensus invariant that mining order should be determined by cryptographic randomness, not miner choice

## Likelihood Explanation

**High Likelihood** - All exploitation conditions are satisfied:

**Attacker Requirements:**
- Must be an active miner in the consensus set (achievable through standard election and staking mechanisms)
- Requires modifying their node software to manipulate block header content before signing (straightforward for any miner running their own infrastructure)

**Attack Complexity:**
- **Low** - Single-step attack: modify `FinalOrderOfNextRound` values in the `Round` object before it's serialized into the block header
- No timing windows, race conditions, or multi-party coordination required
- No cryptographic barriers - the block signature only covers the block hash, not individual consensus field validity

**Feasibility:**
- Entry point is accessible during normal operation: any miner produces `UpdateValue` blocks as part of standard consensus operation
- No economic barriers beyond standard mining costs already incurred
- Repeatable on every `UpdateValue` block the attacker produces
- The attack is undetectable as manipulated headers appear structurally valid and pass all validation checks

**Detection Difficulty:**
- No on-chain evidence distinguishes malicious blocks from honest blocks
- Manipulated values blend seamlessly with legitimate conflict resolution results
- The validation comparison in `ValidateConsensusAfterExecution` provides a false sense of security but is ineffective against this attack

## Recommendation

Add `NextRoundMiningOrderValidationProvider` to the validation pipeline for `UpdateValue` behavior:

```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider()); // ADD THIS
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

Additionally, consider validating that `FinalOrderOfNextRound` values match the expected values from `ApplyNormalConsensusData` calculations, or verifying that `TuneOrderInformation` entries correspond to legitimate conflict resolutions. The validation should occur in `ValidateBeforeExecution` before the manipulated values are applied to state.

## Proof of Concept

A proof of concept would require:

1. Setting up an AElf test network with multiple miners
2. Modifying miner node software to intercept the `GetConsensusExtraDataToPublishOutValue` result
3. Manipulating the `FinalOrderOfNextRound` values in the returned `Round` object to set attacker's order to 1 and competitors to higher values
4. Creating a matching `UpdateValueInput` with corresponding `TuneOrderInformation`
5. Broadcasting the manipulated block
6. Observing that the block passes validation and the next round uses the manipulated mining order

The vulnerability is confirmed by code analysis showing the complete absence of validation for `FinalOrderOfNextRound` in `UpdateValue` blocks, combined with the direct application of unvalidated `TuneOrderInformation` to consensus state and its subsequent use in determining next round mining order.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L47-48)
```csharp
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-27)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```
