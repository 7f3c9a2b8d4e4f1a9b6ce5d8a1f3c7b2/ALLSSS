# Audit Report

## Title
Missing Validation Allows Consensus DoS via Zero FinalOrderOfNextRound Values

## Summary
The `ProcessUpdateValue` method accepts arbitrary `SupposedOrderOfNextRound` and `TuneOrderInformation` values without validation, allowing malicious miners to corrupt consensus state with zero values. While `NextRoundMiningOrderValidationProvider` detects this corruption during round transitions, by then the invalid state has been persisted, creating a denial-of-service condition that blocks all future round progressions with no built-in recovery mechanism.

## Finding Description

**Root Cause - Missing Input Validation:**

The `ProcessUpdateValue` method directly assigns user-controlled `SupposedOrderOfNextRound` values from `UpdateValueInput` to both the `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` fields without any validation that the value falls within the valid range [1, minersCount]: [1](#0-0) 

Additionally, the `TuneOrderInformation` dictionary allows any miner to set arbitrary `FinalOrderOfNextRound` values for any other miner without access control or range validation: [2](#0-1) 

**Why Existing Validation Fails:**

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are present and non-empty, and that `PreviousInValue` is correct. It does NOT check `SupposedOrderOfNextRound` or `FinalOrderOfNextRound` values: [3](#0-2) 

**Detection Occurs Too Late:**

The corruption is only detected when `NextRoundMiningOrderValidationProvider` validates the round transition. It checks that the count of miners with `FinalOrderOfNextRound > 0` equals the count of miners with non-null `OutValue`: [4](#0-3) 

However, this validation only runs during `NextRound` behavior, not during `UpdateValue`. The validation provider assignment shows that `UpdateValueValidationProvider` is used for UpdateValue behavior, while `NextRoundMiningOrderValidationProvider` is only used for NextRound behavior: [5](#0-4) 

**Expected vs Actual Behavior:**

By design, `ApplyNormalConsensusData` calculates `FinalOrderOfNextRound` as `GetAbsModulus(sigNum, minersCount) + 1`, which guarantees values in the range [1, minersCount]: [6](#0-5) [7](#0-6) 

However, since miners control their node software and the `UpdateValueInput` structure accepts these fields as standard inputs, they can submit arbitrary values that bypass this expected calculation: [8](#0-7) 

**Attack Execution Path:**

1. Malicious miner modifies their node software to bypass normal `ApplyNormalConsensusData` calculation
2. Creates `UpdateValueInput` with `SupposedOrderOfNextRound = 0` and `TuneOrderInformation = {"miner1": 0, "miner2": 0, ...}`
3. `UpdateValueValidationProvider` validates successfully (doesn't check order values)
4. `ProcessUpdateValue` executes and corrupts state by setting all miners' `FinalOrderOfNextRound = 0`
5. When any miner attempts `NextRound`, `NextRoundMiningOrderValidationProvider` validation fails because `distinctCount = 0` but some miners have `OutValue != null`
6. Consensus is permanently halted until manual intervention

## Impact Explanation

**Severity: HIGH**

This vulnerability causes a complete consensus halt with no built-in recovery mechanism:

- The blockchain cannot progress to the next round once state is corrupted with zero `FinalOrderOfNextRound` values
- No new blocks can be produced after the current round completes
- All transaction processing stops completely
- All validators, users, and DApps experience service interruption

The code provides no contract method to correct corrupted `FinalOrderOfNextRound` values once set to zero. Recovery requires manual state intervention by network operators or a hard fork, requiring significant coordination overhead.

A single malicious miner can unilaterally corrupt the entire network's consensus state via the `TuneOrderInformation` dictionary, affecting all miners simultaneously.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Feasibility:**
- The `UpdateValue` method is a public consensus method that miners call during normal block production: [9](#0-8) 

- Miners control their node software and can modify it to generate arbitrary `UpdateValueInput` structures
- No cryptographic proofs or complex exploit techniques are required
- A single malicious miner can corrupt the entire network state

**Prerequisites:**
- Attacker must be a current miner in the active miner set
- Requires ability to modify node software to bypass normal input generation
- No collusion required due to `TuneOrderInformation` allowing unilateral corruption of all miners

**Detection:**
- Attack is only detected at `NextRound` transition, after state corruption has occurred
- No real-time monitoring can prevent the malicious `UpdateValue` transaction from executing
- By the time detection occurs, recovery is already complex

## Recommendation

Add validation to `ProcessUpdateValue` to ensure order values are within valid range:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound is in valid range [1, minersCount]
    Assert(updateValueInput.SupposedOrderOfNextRound > 0 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid SupposedOrderOfNextRound value.");
    
    // Validate TuneOrderInformation values are in valid range
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
               "Invalid miner pubkey in TuneOrderInformation.");
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount,
               "Invalid FinalOrderOfNextRound value in TuneOrderInformation.");
    }
    
    // Continue with existing logic...
}
```

Additionally, consider adding the `NextRoundMiningOrderValidationProvider` to the UpdateValue validation chain to detect inconsistencies early.

## Proof of Concept

A malicious miner can create a block with the following `UpdateValueInput`:

```csharp
var maliciousInput = new UpdateValueInput
{
    OutValue = validOutValue,
    Signature = validSignature,
    PreviousInValue = validPreviousInValue,
    RoundId = currentRoundId,
    ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
    SupposedOrderOfNextRound = 0,  // Invalid zero value
    TuneOrderInformation = 
    {
        ["miner1"] = 0,  // Corrupt other miners
        ["miner2"] = 0,
        ["miner3"] = 0
    },
    ProducedBlocks = 1,
    ImpliedIrreversibleBlockHeight = currentHeight,
    RandomNumber = validRandomNumber
};
```

When this input is processed:
1. `UpdateValueValidationProvider` passes (doesn't check order values)
2. `ProcessUpdateValue` sets all `FinalOrderOfNextRound` values to 0
3. Next `NextRound` attempt fails with "Invalid FinalOrderOfNextRound" error
4. Consensus halts permanently

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** protobuf/aedpos_contract.proto (L205-208)
```text
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
