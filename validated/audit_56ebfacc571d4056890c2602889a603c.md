# Audit Report

## Title
Critical Off-By-One Error in Bancor Exponential Calculation Causes Incorrect Token Conversion Pricing

## Summary
The production `BancorHelper.cs` contains a critical off-by-one error in factorial array initialization and access. The `Fact` array stores factorials 0! through 19! but the `Exp` function accesses it as if it contains 1! through 20!, causing all exponential series terms (except the first) to use incorrect factorial denominators. This results in systematically wrong token conversion prices for all swaps where connector weights differ. [1](#0-0) 

## Finding Description

The static constructor initializes the factorial array by computing factorials from 0 to 19, where `Fact[i]` contains i!. [1](#0-0) 

The `DynFact` function correctly computes individual factorials. [2](#0-1) 

However, the `Exp` function accesses this array incorrectly. [3](#0-2)  For the exponential series exp(y) = 1 + y¹/1! + y²/2! + y³/3! + ... + y²⁰/20!, when computing the term for y^n at line 159, it uses `Fact[iteration - 1]` expecting n!, but `Fact[n-1]` actually contains (n-1)!.

This causes:
- y¹ term: uses Fact[0] = 0! = 1 instead of 1! = 1 (correct by coincidence)
- y² term: uses Fact[1] = 1! = 1 instead of 2! = 2 (wrong by factor of 2)
- y³ term: uses Fact[2] = 2! = 2 instead of 3! = 6 (wrong by factor of 3)
- y²⁰ term: uses Fact[19] = 19! instead of 20! (wrong by factor of 20)

The test version demonstrates the correct implementation by hardcoding `Fact[i] = (i+1)!` in the array initialization. [4](#0-3) 

This bug is triggered in production through the `Buy` operation [5](#0-4)  and `Sell` operation [6](#0-5)  whenever connector weights differ. The vulnerability activates when `fromConnectorWeight != toConnectorWeight`, bypassing the optimization shortcut that would avoid the exponential calculation. [7](#0-6) 

## Impact Explanation

This vulnerability breaks the core security guarantee of accurate token pricing in the Bancor-based converter. All terms in the exponential series use factorial denominators that are too small by a factor equal to their term number, causing systematic overestimation of the exponential function.

For exp(0.1), the production code produces approximately 1.1105 instead of the correct 1.10517—a 0.5% error. For larger exponent values used in conversions with significantly different weights, this error compounds dramatically.

The financial impact is severe:
- **Users consistently receive incorrect token amounts** in conversions
- Depending on trade direction, users either **overpay or are underpaid**
- **Arbitrageurs can exploit the predictable mispricing** for guaranteed profits
- **Protocol reserve balances become increasingly imbalanced** over time
- Loss of user trust and potential fund drainage from reserves

## Likelihood Explanation

**Likelihood: CERTAIN**

This bug triggers deterministically on every token conversion where `fromConnectorWeight != toConnectorWeight`. The entry points are publicly accessible methods with no permission requirements:
- Any user can call `Buy` to purchase tokens [8](#0-7) 
- Any user can call `Sell` to sell tokens [9](#0-8) 
- No special conditions, approvals, or state requirements needed
- The bug is always active since the static constructor runs at deployment

The vulnerability affects all real-world usage scenarios where token pairs have different connector weights, which is the common case for Bancor converters with asymmetric reserves.

## Recommendation

Fix the factorial array initialization to match the test version's correct implementation. Change the static constructor to initialize `Fact[i] = (i+1)!` instead of `Fact[i] = i!`:

```csharp
static BancorHelper()
{
    Fact = Array.AsReadOnly(Enumerable.Range(1, 20).Select(x => DynFact(x)).ToArray());
}
```

This changes the range from `Range(0, 20)` to `Range(1, 20)`, ensuring `Fact[0] = 1!`, `Fact[1] = 2!`, ..., `Fact[19] = 20!`, which matches what the `Exp` function expects when accessing `Fact[iteration - 1]`.

## Proof of Concept

```csharp
[Fact]
public void TestFactorialArrayOffByOne()
{
    // Production code computes: Fact[i] = i!
    // But Exp() expects: Fact[i] = (i+1)!
    
    // Test case: exp(0.1) calculation
    decimal y = 0.1m;
    
    // Production result (wrong)
    var productionResult = BancorHelper.Exp(y); // Uses wrong factorials
    
    // Expected correct result
    decimal correctResult = 1.10517m; // Mathematical exp(0.1)
    
    // The production result will be approximately 1.1105 instead of 1.10517
    // This is a 0.5% error that affects all conversions
    Assert.NotEqual(correctResult, productionResult, 4); // Will fail - proves wrong calculation
}
```

**Notes**

The vulnerability is proven by comparing the production implementation with the test version. The test file explicitly hardcodes the correct factorial values where `Fact[i] = (i+1)!`, while the production code incorrectly uses `Fact[i] = i!`. This mathematical error directly affects all token conversions with asymmetric connector weights, which is the standard configuration for Bancor-style automated market makers.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L11-14)
```csharp
    static BancorHelper()
    {
        Fact = Array.AsReadOnly(Enumerable.Range(0, 20).Select(x => DynFact(x)).ToArray());
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L16-21)
```csharp
    private static long DynFact(long number)
    {
        var fact = number == 0 ? 1 : number;
        for (var i = number - 1; i >= 1; i--) fact *= i;
        return fact;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-53)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/BancorHelper.cs (L78-102)
```csharp
    private static readonly long[] Fact =
    {
        1L,
        1L * 2,
        1L * 2 * 3,
        1L * 2 * 3 * 4,
        1L * 2 * 3 * 4 * 5,
        1L * 2 * 3 * 4 * 5 * 6,
        1L * 2 * 3 * 4 * 5 * 6 * 7,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20
        //14197454024290336768L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21,        // NOTE: Overflow during compilation
        //17196083355034583040L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21 * 22    // NOTE: Overflow during compilation
    };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```
