# Audit Report

## Title
Scheme Manager Can Manipulate Minimum Lock Period by Calling CreateScheme Multiple Times

## Summary
The `CreateScheme` method in TokenHolderContract allows a scheme manager to call it multiple times, overwriting the stored `MinimumLockMinutes` parameter. This enables the manager to manipulate withdrawal timing for users who have already locked tokens under the original lock duration, allowing either premature withdrawal or indefinite lock extension without user consent.

## Finding Description

The vulnerability exists because `CreateScheme` does not validate whether a scheme already exists for the caller before overwriting the stored scheme parameters. [1](#0-0) 

Each `CreateScheme` invocation performs two operations:
1. Creates a new Profit scheme with unique SchemeId [2](#0-1) 
2. Overwrites `State.TokenHolderProfitSchemes[Context.Sender]` with new parameters including `MinimumLockMinutes` [3](#0-2) 

When users register via `RegisterForProfits`, they lock tokens and are registered as beneficiaries in the Profit scheme, with their lock timestamp recorded. [4](#0-3) 

During withdrawal, the `Withdraw` method retrieves the scheme and validates the lock period against `MinimumLockMinutes`. [5](#0-4) 

The critical flaw occurs in `UpdateTokenHolderProfitScheme`, which correctly updates the `SchemeId` field by querying for the FIRST scheme created by that manager. [6](#0-5) [7](#0-6) 

However, `UpdateTokenHolderProfitScheme` only updates `SchemeId` and `Period` - it does NOT update `MinimumLockMinutes`. This field retains whatever value was set during the LAST `CreateScheme` call, while users are actually registered in the FIRST scheme.

The Profit contract maintains schemes in insertion order. [8](#0-7) 

**Attack Scenario:**
1. Manager calls `CreateScheme({symbol: "ELF", minimum_lock_minutes: 100000})` → Creates Scheme A
2. User calls `RegisterForProfits` → Locks tokens at timestamp T, registered to Scheme A, expecting 100000 minute lock
3. Manager calls `CreateScheme({symbol: "ELF", minimum_lock_minutes: 1})` → Creates Scheme B, overwrites TokenHolderProfitSchemes entry with MinimumLockMinutes=1
4. User calls `Withdraw` → GetValidScheme returns scheme with SchemeId=A (correct) but MinimumLockMinutes=1 (manipulated)
5. Withdrawal succeeds after only 1 minute instead of 100000 minutes

## Impact Explanation

**HIGH Severity** - This vulnerability enables direct financial manipulation:

**Breach of Lock Commitment:**
- Users lock tokens with explicit contractual expectations about withdrawal timing based on the scheme's `MinimumLockMinutes`
- The manager can unilaterally reduce the lock period, allowing users to withdraw immediately and violating the economic assumptions of profit-sharing schemes
- Alternatively, the manager can increase the lock period, trapping users beyond their originally agreed duration

**Economic Model Disruption:**
- Profit distribution schemes rely on predictable token lock durations to ensure fair allocation among long-term participants
- Premature withdrawal by some users breaks commitment periods that affect expected returns for all participants
- This undermines the fundamental trust and incentive alignment in the TokenHolder ecosystem

**User Fund Control Loss:**
- If `MinimumLockMinutes` is increased arbitrarily, users lose access to their locked funds indefinitely
- The change affects ALL existing participants simultaneously without their consent or notification
- No recovery mechanism exists once the scheme parameters are overwritten

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is trivially exploitable:

**No Access Control:**
- `CreateScheme` is publicly callable by any address without special permissions or governance requirements [9](#0-8) 
- The scheme manager can call it at any time with standard transaction execution
- No validation prevents duplicate scheme creation

**Minimal Complexity:**
- Attack requires only two simple transactions from the manager's address
- No sophisticated techniques, race conditions, or complex preconditions needed
- Could occur accidentally if a manager attempts to "update" scheme parameters

**Detection Difficulty:**
- The overwrite occurs through a normal `CreateScheme` transaction indistinguishable from initial creation
- No events indicate that existing scheme parameters have been modified
- Users only discover the manipulation when attempting withdrawal

## Recommendation

Add validation in `CreateScheme` to prevent duplicate scheme creation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check at the beginning
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    // ... rest of the existing code
}
```

Alternatively, implement a dedicated `UpdateScheme` method with proper authorization checks if parameter updates are intended functionality.

## Proof of Concept

```csharp
[Fact]
public async Task ManipulateMinimumLockPeriod_Vulnerability()
{
    // Step 1: Manager creates scheme with 100000 minute lock
    await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = 100000
        });
    
    // Step 2: User locks tokens
    var userStub = GetTokenHolderContractStub(UserAddresses[0]);
    await userStub.RegisterForProfits.SendAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = Starter,
            Amount = 1000
        });
    
    // Step 3: Manager creates second scheme with 1 minute lock (overwrites)
    await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = 1
        });
    
    // Step 4: Advance time by only 2 minutes
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(2));
    
    // Step 5: User can withdraw after 1 minute instead of 100000 minutes!
    var result = await userStub.Withdraw.SendAsync(Starter);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify tokens were unlocked (should have failed but succeeded)
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(
        new GetLockedAmountInput
        {
            Address = UserAddresses[0],
            Symbol = "ELF",
            LockId = /* lockId from RegisterForProfits */
        });
    lockedAmount.Amount.ShouldBe(0); // Tokens unlocked prematurely!
}
```

**Notes:**

This vulnerability breaks the fundamental security guarantee that locked tokens remain locked for the agreed duration. The scheme manager is a trusted role, but this level of unilateral control over existing user locks violates reasonable trust boundaries. The lack of validation in `CreateScheme` combined with the partial update logic in `UpdateTokenHolderProfitScheme` creates a dangerous state inconsistency where `MinimumLockMinutes` can diverge from the actual scheme users are registered in.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-228)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```
