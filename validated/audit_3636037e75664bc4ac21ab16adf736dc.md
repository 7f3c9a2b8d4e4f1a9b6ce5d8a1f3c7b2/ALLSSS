# Audit Report

## Title
Side Chain Miner Count Limit Bypass via Cross-Chain Synchronization

## Summary
Side chains can operate with more miners than the governance-configured `MaximumMinersCount` limit because the cross-chain synchronization path accepts and persists an unlimited miner list from the main chain without validation. This breaks the consensus security model where miner count affects decentralization, block intervals, and reward distribution.

## Finding Description

The AEDPoS consensus contract on side chains fails to enforce the `MaximumMinersCount` limit when receiving miner lists from the main chain via cross-chain synchronization. The vulnerability exists across multiple unchecked code paths:

**Root Cause 1: Unvalidated Cross-Chain Update**
The `UpdateInformationFromCrossChain` method extracts all miners from the main chain's consensus information and stores them without checking against the side chain's configured limit. [1](#0-0) 

**Root Cause 2: Unchecked NextTermInput Creation**
The `Create()` method copies all entries from `round.RealTimeMinersInformation` without validation. [2](#0-1) 

**Root Cause 3: Side Chain Fallback Path**
Side chains return false from `TryToGetVictories` (they don't use election victories), causing the fallback to use the unvalidated current round's miner list. [3](#0-2) [4](#0-3) 

**Root Cause 4: Unvalidated Term Processing**
`ProcessNextTerm` creates a `MinerList` from ALL keys in `nextRound.RealTimeMinersInformation` and stores it without checking the count limit. [5](#0-4) 

**Root Cause 5: Insufficient Validation**
The `ValidationForNextTerm` method only validates term and round number increments but does NOT check if the miner count exceeds `MaximumMinersCount`. [6](#0-5) 

**Critical Finding: MaximumMinersCount Only Used for Reporting**
The `GetMinersCount` method enforces `MaximumMinersCount` via `Math.Min`, but this is ONLY used to report to the Election contract, not to limit actual consensus participation. [7](#0-6) 

**Block Production Uses Unvalidated List**
The mining permission validation only checks if a sender exists in `RealTimeMinersInformation.Keys`, meaning ALL miners in the round (regardless of count) can produce blocks. [8](#0-7) 

## Impact Explanation

**Consensus Integrity Violation:**
Side chains can operate with arbitrarily many block producers, violating the governance-approved `MaximumMinersCount` safety parameter. If the main chain has 25 miners and the side chain's limit is 17, all 25 miners will participate in consensus on the side chain, breaking the intended security model.

**Concrete Harms:**
1. **Security Degradation:** More miners than intended changes the security assumptions around block finality, fork resolution, and Byzantine fault tolerance thresholds
2. **Economic Inconsistency:** The Election contract receives a capped miner count via `UpdateMinersCountToElectionContract`, but the actual consensus round operates with more miners, creating accounting mismatches in reward calculations
3. **Governance Bypass:** The `MaximumMinersCount` parameter set by Parliament via `SetMaximumMinersCount` becomes unenforceable on side chains, rendering governance decisions ineffective

**Affected Parties:**
- Side chain validators expecting security guarantees from the configured miner limit
- Side chain governance expecting their `MaximumMinersCount` setting to be enforced
- Economic contracts receiving inconsistent miner count information

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is not an attack but a design flaw that triggers automatically:

1. **Reachable Entry Point:** `UpdateInformationFromCrossChain` is called by the CrossChain contract during routine cross-chain indexing [9](#0-8) 

2. **Realistic Preconditions:**
   - Side chain exists with `MaximumMinersCount` configured (standard setup)
   - Main chain has more miners than side chain's limit (common as main chains typically have more miners)
   - Cross-chain indexing is active (required for normal side chain operation)

3. **Automatic Trigger:** No attacker action needed - happens during normal cross-chain synchronization whenever the main chain's miner count exceeds the side chain's configured limit

4. **Reproducible:** This is deterministic behavior, not a race condition or timing issue

## Recommendation

Add validation at multiple checkpoints to enforce `MaximumMinersCount`:

**1. Validate in UpdateInformationFromCrossChain:**
```csharp
var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
var maxMinersCount = State.MaximumMinersCount.Value;
if (minersKeys.Count > maxMinersCount)
{
    minersKeys = minersKeys.Take(maxMinersCount);
}
State.MainChainCurrentMinerList.Value = new MinerList
{
    Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
};
```

**2. Validate in ProcessNextTerm:**
```csharp
var minerKeys = nextRound.RealTimeMinersInformation.Keys;
var maxCount = State.MaximumMinersCount.Value;
Assert(minerKeys.Count <= maxCount, 
    $"Miner count {minerKeys.Count} exceeds maximum {maxCount}");
```

**3. Add validation in ValidationForNextTerm:**
```csharp
if (extraData.Round.RealTimeMinersInformation.Count > 
    validationContext.MaximumMinersCount)
{
    return new ValidationResult 
    { 
        Message = "Miner count exceeds maximum limit." 
    };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SideChain_AcceptsMoreMinersThanMaximumLimit()
{
    // Setup: Side chain with MaximumMinersCount = 5
    await AEDPoSContractStub.SetMaximumMinersCount.SendAsync(new Int32Value { Value = 5 });
    
    // Main chain has 10 miners
    var mainChainRound = GenerateRoundWith10Miners();
    var consensusInfo = new AElfConsensusHeaderInformation
    {
        Round = mainChainRound
    };
    
    // Trigger cross-chain update
    await AEDPoSContractStub.UpdateInformationFromCrossChain.SendAsync(
        new BytesValue { Value = consensusInfo.ToByteString() });
    
    // Verify: Side chain accepted all 10 miners despite limit of 5
    var currentMinerList = await AEDPoSContractStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
    
    Assert.Equal(10, currentMinerList.Pubkeys.Count); // Bug: Should be 5
    
    // All 10 miners can produce blocks
    foreach (var miner in currentMinerList.Pubkeys)
    {
        var canMine = await VerifyMinerCanProduceBlock(miner);
        Assert.True(canMine); // Bug: Miners beyond limit can still mine
    }
}
```

## Notes

This vulnerability demonstrates a critical gap between **policy declaration** (`MaximumMinersCount` configuration) and **policy enforcement** (actual consensus participation). The `MaximumMinersCount` parameter is respected for reporting purposes but completely bypassed for actual block production on side chains. This creates a false sense of security where governance believes they've configured a miner limit, but the side chain operates with an unrestricted miner set from the main chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-36)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L12-12)
```csharp
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L237-239)
```csharp
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L268-272)
```csharp
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-17)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
```
