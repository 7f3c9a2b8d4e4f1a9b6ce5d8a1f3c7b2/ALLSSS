# Audit Report

## Title
Secret Sharing Manipulation Through Selective Decrypted Piece Withholding

## Summary
The AEDPoS consensus contract contains a critical threshold mismatch in its secret sharing implementation. The `RevealSharedInValues()` function requires all miners (100%) to provide decrypted pieces before revealing InValues, despite Shamir's Secret Sharing only needing a 2/3 threshold. A malicious miner can exploit this by selectively withholding decrypted pieces to force targeted miners into using predictable fake values, thereby manipulating consensus randomness and mining order for subsequent rounds.

## Finding Description

The vulnerability exists in the secret sharing revelation logic where a threshold mismatch allows consensus manipulation.

The `RevealSharedInValues()` function enforces a 100% participation requirement before attempting InValue reconstruction. [1](#0-0) 

However, the cryptographic scheme only requires a 2/3 threshold for successful secret reconstruction. [2](#0-1)  The actual secret decoding uses this lower threshold. [3](#0-2) 

During the `UpdateValue` consensus behavior, miners provide their decrypted pieces through `UpdateValueInput`. The `PerformSecretSharing` function processes these pieces without any validation to ensure miners provide all decrypted pieces they possess. [4](#0-3)  A malicious miner can simply omit certain pubkeys from their `DecryptedPieces` map.

When InValue revelation fails due to insufficient decrypted pieces, miners without a valid `PreviousInValue` must use a deterministic fake value computed from their public key and block height. [5](#0-4) 

This fake value is then used in signature calculation, which XORs the inValue with all existing miner signatures. [6](#0-5)  The signature determines the next round's mining order through modulo arithmetic. [7](#0-6) [8](#0-7) 

## Impact Explanation

**Consensus Randomness Manipulation**: An attacker can selectively prevent specific miners' InValue revelation, forcing them to use predictable fake values instead of their actual InValues. Since the signature is computed by XORing the InValue with all previous round signatures, and mining order is calculated from this signature, the attacker can influence which miners receive favorable or unfavorable mining positions.

**Concrete Attack Scenario**:
1. Attacker decrypts all other miners' encrypted pieces off-chain (possible since pieces are public on-chain)
2. For each target miner, attacker calculates resulting mining orders under two scenarios:
   - Scenario A: Provide the decrypted piece (allowing InValue revelation)
   - Scenario B: Withhold the decrypted piece (forcing fake value usage)
3. Attacker selectively withholds pieces where scenario B produces more favorable mining order
4. This manipulation increases attacker's mining frequency, enables consecutive block production, or disadvantages competing miners

**Severity Justification**: The cryptographic protocol is designed for 2/3 Byzantine fault tolerance, but the implementation requires 100% honest participation. This allows any single malicious miner to manipulate consensus without detection or penalty. Mining order directly affects block rewards and transaction fee capture, creating economic incentives for exploitation.

## Likelihood Explanation

**Attacker Capabilities**: A single malicious miner in the active miner set can execute this attack. The attacker only needs to:
1. Run standard consensus node software
2. Selectively omit certain pubkeys from their `DecryptedPieces` map when calling `UpdateValue`

**Attack Complexity**: Trivial. The encrypted pieces are stored on-chain in the round information, allowing any miner to decrypt them. The attacker simply filters which decrypted pieces to include in their `UpdateValueInput` before submitting the transaction.

**Detection/Penalties**: None. The validation provider explicitly allows `Hash.Empty` as a valid `PreviousInValue`. [9](#0-8)  The system cannot distinguish between an honest miner who failed to decrypt due to technical issues versus a malicious miner intentionally withholding decryptions.

**Economic Rationality**: Mining order determines when miners produce blocks within a round. Earlier positions typically capture more transactions and fees. The attack cost is zero (just omitting data), while the benefit is improved mining position and increased rewards.

## Recommendation

Modify the `RevealSharedInValues()` function to use the cryptographic minimum threshold (2/3) instead of requiring 100% participation:

```csharp
// Change line 36 from:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// To:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This aligns the implementation with the cryptographic guarantees of Shamir's Secret Sharing, ensuring the protocol actually achieves its intended 2/3 Byzantine fault tolerance. Additionally, consider implementing detection mechanisms for miners who consistently fail to provide decrypted pieces, as this could indicate malicious behavior even if it doesn't directly break the reconstruction.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a round with N miners where each has provided encrypted pieces
2. Have miner A selectively omit miner B's decrypted piece from their `UpdateValueInput`
3. Call `NextRound` to trigger `RevealSharedInValues()`
4. Verify that miner B's `PreviousInValue` remains `Hash.Empty` despite sufficient pieces existing cryptographically (2/3 threshold met)
5. Show that miner B must use a fake value when producing their next block
6. Demonstrate that this fake value creates a different signature and thus different mining order compared to if the real InValue had been revealed

The core issue is that the check at line 36 of `AEDPoSContract_SecretSharing.cs` enforces `minersCount` (100%) when `minimumCount` (2/3) would be cryptographically sufficient, creating an exploitable gap between the protocol's fault tolerance design and its actual implementation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```
