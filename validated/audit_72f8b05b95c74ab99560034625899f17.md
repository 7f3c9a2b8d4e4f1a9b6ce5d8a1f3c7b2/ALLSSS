# Audit Report

## Title
Incorrect Accounting Assertion in Recharge() Causes Denial of Service for Valid Side Chain Recharges

## Summary
The `Recharge()` function contains a critical logic error in its validation assertion that incorrectly counts `input.Amount` twice when checking if sufficient funds have been provided. This causes legitimate recharge transactions to be rejected, preventing side chains in debt status from being recovered.

## Finding Description

The vulnerability is located in the `Recharge()` function. [1](#0-0) 

**Execution Flow:**

1. The function first transfers `input.Amount` from the sender to the side chain's virtual address. [2](#0-1) 

2. If the side chain is in debt status, it loops through accumulated arrears and transfers them to proposers FROM the side chain's virtual address. [3](#0-2) 

3. After arrears transfers complete, it retrieves the current balance of the side chain. [4](#0-3) 

4. It validates using: `Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice)` [5](#0-4) 

**The Logic Error:**

The `GetSideChainIndexingFeeDeposit()` function queries the token balance of the side chain's virtual address. [6](#0-5) 

At line 206, `originBalance` is retrieved AFTER the arrears have been transferred out, so it equals:
```
originBalance = old_balance + input.Amount - arrearsAmount
```

The assertion at line 207 becomes:
```
input.Amount + (old_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice
```

Simplifying:
```
2*input.Amount + old_balance >= 2*arrearsAmount + IndexingPrice
```

**Correct Logic:**

After recharge and paying arrears, the remaining balance must be at least `IndexingPrice`:
```
old_balance + input.Amount - arrearsAmount >= IndexingPrice
```

Or equivalently:
```
old_balance + input.Amount >= arrearsAmount + IndexingPrice
```

Since `originBalance` already has arrears deducted, the correct check should be:
```
originBalance >= IndexingPrice
```

The bug causes the assertion to require approximately double the necessary funds because `input.Amount` is counted twice in the validation.

## Impact Explanation

**Denial of Service - HIGH Severity:**

Legitimate users attempting to recharge side chains in debt status will be incorrectly rejected when they provide exactly the mathematically required amount. This completely blocks the recovery mechanism for debt-ridden side chains.

**Concrete Example:**
- Side chain balance: 75 tokens
- Arrears owed: 100 tokens  
- Indexing price: 50 tokens
- User provides: 75 tokens (correct amount)

**Expected:** Should succeed (75+75=150 total, minus 100 arrears = 50 remaining ≥ 50 required)

**Actual:** Transaction fails (assertion checks 75+50 ≥ 100+50 → 125 ≥ 150 ✗)

**Who is affected:**
- Side chain creators attempting to clear debt
- Side chain operators maintaining service continuity
- All users depending on debt-affected side chains

The only workaround is to overpay by approximately double, which creates significant capital inefficiency and may not be understood by users, leaving side chains permanently stuck in debt status.

## Likelihood Explanation

**HIGH Likelihood:**

The `Recharge()` function is a public entry point callable by any user without special privileges. [7](#0-6) 

**Feasible Preconditions:**
1. Side chain exists and is in `IndexingFeeDebt` status (occurs naturally during normal operations when indexing fees deplete) [8](#0-7) 
2. Arrears have accumulated in the side chain's `ArrearsInfo` [9](#0-8) 
3. User has token allowance for the recharge amount

**Execution Practicality:**

This bug triggers automatically in normal operation whenever a side chain falls into debt and someone tries to recharge with the mathematically correct amount. No attack is needed - it's a logic error affecting legitimate usage. Given the economic incentive to minimize capital lockup, users will naturally attempt to recharge with the minimum required amount, triggering this bug frequently.

## Recommendation

Change the assertion at line 207 to check only the remaining balance after arrears have been paid:

```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

Alternatively, if you want to check before transfers, move the balance check to before the arrears payment loop and use:

```csharp
Assert(input.Amount + GetSideChainIndexingFeeDeposit(chainId) >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

## Proof of Concept

The following test demonstrates the bug. When a user provides exactly the required amount (arrearsAmount + IndexingPrice - oldBalance), the transaction incorrectly fails:

```csharp
[Fact]
public async Task Recharge_WithCorrectAmount_ShouldSucceed_ButFails()
{
    // Setup: Create side chain with 75 token balance and 100 arrears
    var chainId = await CreateSideChain();
    var oldBalance = 75;
    var arrearsAmount = 100; 
    var indexingPrice = 50;
    
    // User calculates correct recharge amount: arrears + indexing - oldBalance
    var correctRechargeAmount = arrearsAmount + indexingPrice - oldBalance; // = 75
    
    // Expected: Should succeed (75+75=150, minus 100 arrears = 50 ≥ 50)
    // Actual: Fails because assertion checks: 75 + 50 >= 100 + 50 (125 >= 150) ✗
    
    var result = await CrossChainContractStub.Recharge.SendAsync(new RechargeInput
    {
        ChainId = chainId,
        Amount = correctRechargeAmount
    });
    
    // This assertion will fail, proving the bug
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```
