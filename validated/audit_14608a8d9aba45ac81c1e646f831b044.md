# Audit Report

## Title
Incorrect Threshold Check in Secret Sharing Reconstruction Defeats Byzantine Fault Tolerance

## Summary
The AEDPoS consensus contract's secret sharing reconstruction logic incorrectly requires 100% of miners to provide decrypted pieces before attempting reconstruction, instead of the mathematically sufficient 2/3 threshold defined by Shamir's Secret Sharing algorithm. This allows any single malicious validator to prevent forced revelation of their InValue by providing incomplete encrypted pieces, breaking the commit-reveal scheme's security guarantees and enabling manipulation of consensus randomness and mining order.

## Finding Description

The vulnerability exists in the `RevealSharedInValues` method where secret reconstruction is performed. The system correctly calculates a 2/3 threshold (`minimumCount`) [1](#0-0)  but then incorrectly validates that ALL miners (100%) have provided decrypted pieces before attempting reconstruction. [2](#0-1) 

The secret reconstruction algorithm itself correctly uses the `minimumCount` threshold parameter [3](#0-2)  but this code is never reached when DecryptedPieces.Count < minersCount.

**Attack Execution Path:**

1. **Round N**: Malicious validator provides incomplete EncryptedPieces in their `UpdateValue` transaction (e.g., only encrypting for 14 out of 21 validators)
2. **Round N+1**: Only the 14 validators with encrypted pieces can decrypt and add to DecryptedPieces
3. **Round N+1**: When `RevealSharedInValues` executes, it checks if DecryptedPieces.Count (14) < minersCount (21) and skips reconstruction
4. **Result**: The malicious validator's PreviousInValue is never forcibly revealed through secret reconstruction

**Why Existing Protections Fail:**

1. **No EncryptedPieces completeness validation**: The `UpdateValueValidationProvider` does not validate that miners provide complete encrypted pieces. [4](#0-3) 

2. **Hash.Empty explicitly allowed**: PreviousInValue is permitted to be Hash.Empty, bypassing forced revelation requirements. [5](#0-4) 

3. **Storage without validation**: EncryptedPieces are stored directly without completeness checks. [6](#0-5) 

4. **Evil miner detection insufficient**: The system only detects evil miners based on missed time slots, not secret sharing non-participation. [7](#0-6) 

## Impact Explanation

This vulnerability breaks critical consensus security guarantees with HIGH severity:

**1. Mining Order Manipulation**: The signature value (computed from InValue) determines mining order for the next round. [8](#0-7)  The signature is calculated from InValue using XOR operations. [9](#0-8) [10](#0-9)  Without forced revelation, a malicious validator can avoid verification of their signature computation, allowing them to manipulate their mining position.

**2. Randomness Manipulation**: The commit-reveal scheme requires miners to commit to an InValue (via OutValue hash) and later reveal it. The secret sharing mechanism exists specifically to force revelation even if a miner refuses to cooperate. By defeating this mechanism, miners can selectively choose whether to reveal based on whether the outcome benefits them.

**3. Byzantine Fault Tolerance Defeated**: Shamir's Secret Sharing is mathematically designed to tolerate up to 1/3 Byzantine (malicious) participants. [11](#0-10)  The incorrect threshold check requiring 100% participation effectively reduces this tolerance to 0%, as a single malicious validator can prevent reconstruction.

**4. Consensus Fairness Compromised**: All network participants suffer from compromised consensus fairness, while the malicious validator gains unfair advantages in block production scheduling and associated rewards.

## Likelihood Explanation

The likelihood is **HIGH** due to the following factors:

**Attacker Capabilities**: Any validator in the active miner set can execute this attack. No special privileges beyond being an elected validator are required.

**Attack Complexity**: LOW
- The attacker simply provides incomplete EncryptedPieces in their UpdateValue transaction [12](#0-11) 
- No complex cryptographic manipulation required
- No timing dependencies or race conditions
- The attack is undetectable at validation time since EncryptedPieces completeness is never checked

**Feasibility**: The attack is immediately executable when:
1. Attacker is an active validator (realistic for any elected miner)
2. Secret sharing is enabled (standard operational configuration)

**Detection Difficulty**: The attack is extremely difficult to detect because:
- Off-chain observers cannot distinguish between network-delayed pieces and deliberately withheld pieces
- No on-chain slashing mechanism exists for incomplete secret sharing participation
- Evil miner detection only tracks missed time slots, not secret sharing compliance

## Recommendation

Fix the threshold check to use the mathematically correct `minimumCount` value instead of requiring 100% participation:

```csharp
// In AEDPoSContract_SecretSharing.cs, line 36
// Change from:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// To:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

Additionally, consider adding validation in `UpdateValueValidationProvider` to ensure miners provide encrypted pieces for all active validators, or implement slashing penalties for incomplete secret sharing participation.

## Proof of Concept

The vulnerability can be proven by examining the test case that demonstrates Shamir's Secret Sharing works correctly with only the threshold number of pieces: [13](#0-12) 

This test confirms that reconstruction works with `threshold` pieces (not `totalParts`), yet the contract code at line 36 requires `minersCount` (equivalent to `totalParts`) instead of `minimumCount` (equivalent to `threshold`), creating the vulnerability where a single non-cooperating miner defeats the entire secret sharing mechanism.

## Notes

The vulnerability affects a core consensus security mechanism. The secret sharing system was designed to provide Byzantine fault tolerance by allowing reconstruction with 2/3 participation, but the implementation error requires 100% participation, completely defeating this security property. This is a critical design flaw that undermines the consensus protocol's security guarantees and should be addressed immediately.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** protobuf/aedpos_contract.proto (L210-210)
```text
    map<string, bytes> encrypted_pieces = 8;
```

**File:** test/AElf.Cryptography.Tests/SecretSharingTest.cs (L57-66)
```csharp
    public void SharingTest(string str, int threshold, int totalParts)
    {
        var bytes = Encoding.UTF8.GetBytes(str);
        var parts = SecretSharingHelper.EncodeSecret(bytes, threshold, totalParts);
        Assert.Equal(totalParts, parts.Count);

        var result = SecretSharingHelper.DecodeSecret(parts.Take(threshold).ToList(),
            Enumerable.Range(1, threshold).ToList(), threshold);
        Assert.Equal(bytes, result);
    }
```
