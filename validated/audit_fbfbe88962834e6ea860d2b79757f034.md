# Audit Report

## Title
Referendum Organizations Can Be Permanently Bricked With Invalid Proposer Addresses

## Summary
The Referendum contract's organization validation fails to verify that addresses in the ProposerWhiteList contain valid (non-empty) ByteString values. An attacker can create organizations with whitelists containing only addresses with empty ByteString values, which pass validation but are permanently unusable since no valid proposer can create proposals and the whitelist cannot be modified without executing a proposal.

## Finding Description

The vulnerability exists in the organization validation logic during creation. When `CreateOrganization` is called, it validates the organization using the `Validate()` method [1](#0-0) , which checks whether the ProposerWhiteList is empty but never validates individual address validity [2](#0-1) .

The `Empty()` extension method only checks if the count is zero [3](#0-2) . This allows an attacker to add Address objects with `Value = ByteString.Empty` (protobuf3 default) to satisfy the non-empty requirement.

The ProposerWhiteList contains a repeated Address field [4](#0-3) , and Address itself is defined as a bytes wrapper in protobuf [5](#0-4) .

When users attempt to create proposals, authorization is enforced via `AssertIsAuthorizedProposer` [6](#0-5) , which checks if the proposer exists in the whitelist using `Contains()` [7](#0-6) . This check uses protobuf equality comparison [8](#0-7) , where addresses with valid ByteString values will never equal addresses with empty ByteString values.

The recovery mechanism is blocked because `ChangeOrganizationProposerWhiteList` requires `Context.Sender` to be the organization address itself [9](#0-8) , which can only occur through virtual inline calls during proposal execution. Since no proposals can be created, the whitelist cannot be updated, permanently bricking the organization.

Notably, other contracts in the codebase implement proper address validation. The MultiToken contract validates addresses with `AssertValidInputAddress` that checks for null and empty values [10](#0-9) , but the Referendum contract lacks this validation for whitelist addresses.

## Impact Explanation

**Operational Impact - Permanent DoS:**
- Any user can create permanently unusable Referendum organizations at minimal gas cost
- Organization addresses are deterministic based on input parameters [11](#0-10) , allowing attackers to pre-occupy addresses that legitimate users intend to create
- Once created, organizations cannot be deleted or recovered (no deletion mechanism exists in the contract)
- State bloat from accumulation of unusable organizations

**Governance Impact:**
- Complete DoS of Referendum governance functionality for affected organizations
- No admin override or recovery mechanism exists
- Violates the fundamental governance invariant that organizations with non-empty whitelists must allow authorized proposers to create proposals

The severity is **HIGH** because it enables permanent, unrecoverable DoS of critical governance infrastructure with minimal attack cost and no privileged access required.

## Likelihood Explanation

**Entry Point:** The `CreateOrganization` method is publicly accessible [12](#0-11) .

**Attack Feasibility:**
- In protobuf3 C#, creating an Address with empty ByteString is trivial: `new Address()` defaults to `Value = ByteString.Empty` per protobuf3 semantics
- The attacker constructs a `CreateOrganizationInput` with valid parameters except the ProposerWhiteList contains only invalid addresses
- Single transaction execution with standard gas cost
- No special permissions required

**Economic Rationality:**
- Attack cost: Only transaction gas fees (same as normal organization creation)
- Impact: Permanent bricking of organization functionality
- High impact-to-cost ratio makes this economically viable for griefing attacks

The likelihood is **HIGH** due to public accessibility, trivial execution, and minimal cost.

## Recommendation

Add individual address validation to the `Validate()` method in Referendum_Helper.cs. The validation should check that each address in the ProposerWhiteList has a non-empty ByteString value, similar to how MultiToken validates addresses:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for individual addresses in whitelist
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

This mirrors the validation pattern already used in MultiToken's `AssertValidInputAddress` method.

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithEmptyAddresses_ShouldBrickOrganization()
{
    // Create organization with invalid (empty) addresses in whitelist
    var invalidAddress = new Address(); // Empty ByteString.Empty by default
    
    var createInput = new CreateOrganizationInput
    {
        TokenSymbol = "ELF",
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { invalidAddress } // Empty address passes count > 0 check
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalRejectionThreshold = 0,
            MaximalAbstentionThreshold = 0
        }
    };
    
    // Organization creation succeeds (validates only count, not individual addresses)
    var organizationAddress = await ReferendumContractStub.CreateOrganization.SendAsync(createInput);
    organizationAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attempt to create proposal with valid address fails
    var validProposer = DefaultSender; // Any valid address
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ContractMethodName = "Transfer",
        ToAddress = TokenContractAddress,
        Params = ByteString.Empty,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    
    // This will fail with "Unauthorized to propose" because valid address != empty address
    var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(proposalInput);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose");
    
    // Organization is permanently bricked - no way to update whitelist without executing a proposal
    // ChangeOrganizationProposerWhiteList requires Context.Sender == organizationAddress
    // which only happens during proposal execution, but proposals cannot be created
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L55-55)
```csharp
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L211-216)
```csharp
    public override Address CalculateOrganizationAddress(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```
