# Audit Report

## Title
Stale Continuous Block Counter Bypasses Severe Status Emergency Limit

## Summary
The AEDPoS consensus contract contains a Time-Of-Check-Time-Of-Use (TOCTOU) vulnerability where the validation phase uses a stale `LatestPubkeyToTinyBlocksCount` counter from state that was set before Severe emergency status detection. This allows miners to produce up to 8 blocks during Severe status instead of the intended 1-block emergency limit, completely undermining the safety mechanism designed to prevent the chain from advancing too far ahead of the Last Irreversible Block (LIB).

## Finding Description

The AEDPoS consensus implements an emergency brake where `GetMaximumBlocksCount()` returns 1 when the blockchain enters Severe status (current round number ≥ LIB round + 8). [1](#0-0) 

However, the validation logic creates a TOCTOU vulnerability through this execution flow:

**Validation Phase (BEFORE Execution):**

When `ValidateConsensusBeforeExecution` is called, it invokes `ValidateBeforeExecution` which creates a `ConsensusValidationContext` containing the **stale** `LatestPubkeyToTinyBlocksCount` value from state. [2](#0-1) 

The `ContinuousBlocksValidationProvider` validates this counter but only rejects blocks when `BlocksCount < 0`. [3](#0-2) 

**Execution Phase (AFTER Validation):**

After validation passes, the consensus transaction calls `ProcessConsensusInformation` which evaluates the current blockchain status via `GetMaximumBlocksCount()` and returns 1 for Severe status, then calls `ResetLatestProviderToTinyBlocksCount(1)`. [4](#0-3) 

**The Critical Flaw:**

When `ResetLatestProviderToTinyBlocksCount` is called with the new emergency limit (1), it only **decrements** the existing counter by 1 if the same miner continues producing blocks. [5](#0-4) 

The new limit is only applied when a **different** miner takes over. [6](#0-5) 

**Concrete Attack Scenario:**

1. Normal operation: Miner A has `LatestPubkeyToTinyBlocksCount = {Pubkey: A, BlocksCount: 7}` (maximum normal value, since `MaximumTinyBlocksCount = 8`). [7](#0-6) 

2. System enters Severe status (R ≥ R_LIB + 8). [8](#0-7) 

3. Miner A produces Block N through N+7:
   - Each validation reads stale counter from state (7→6→5→4→3→2→1→0), all pass since ≥ 0
   - Each execution decrements by 1
   - Total: 8 blocks produced

4. Block N+8: Validation reads -1, finally fails

**Result:** Miner A produces 8 blocks during Severe emergency status instead of 1.

## Impact Explanation

Severe status is a critical safety mechanism triggered when the blockchain becomes dangerously out of sync - specifically when current round number is at least 8 rounds ahead of the Last Irreversible Block round. The system fires an `IrreversibleBlockHeightUnacceptable` event and sets `IsPreviousBlockInSevereStatus` to true, indicating emergency conditions. [9](#0-8) 

**Concrete Harm:**

1. **Chain Safety Compromised:** The emergency limit exists to prevent the chain from advancing too far ahead of LIB. When bypassed, the chain continues advancing 8x faster than intended during this critical period, increasing fork risk and chain reorganization vulnerability.

2. **Emergency Response Ineffective:** The system detects the dangerous condition and attempts to limit block production to 1, but the stale counter allows miners to ignore this limit, rendering the emergency brake mechanism ineffective.

3. **Quantified Violation:** With maximum pre-emergency `BlocksCount = 7`, a miner can produce 8 blocks instead of 1 block during Severe status - an **8x violation** of the emergency safety limit.

4. **Affects All Participants:** Chain instability affects finality guarantees and transaction irreversibility for all network participants, not just the miner producing blocks.

## Likelihood Explanation

**Preconditions (All Realistic):**

1. **Miner Producing Consecutive Blocks:** Normal consensus operation. Any miner can naturally accumulate BlocksCount up to 7 by producing consecutive blocks.

2. **System Enters Severe Status:** Occurs when network conditions cause LIB to lag by 8+ rounds. Common causes include network partitions, consensus delays, or chain fork resolution.

3. **Same Miner Continues:** The miner producing blocks when Severe status triggers naturally continues mining - this is expected consensus behavior.

**No Special Permissions Required:**

The vulnerability affects legitimate miners operating normally within consensus rules. No malicious intent or manipulation needed - it triggers automatically during normal consensus operation when timing conditions align.

**Probability: HIGH**

This vulnerability will trigger naturally whenever a miner is producing consecutive blocks and network conditions cause LIB lag triggering Severe status. The issue is architectural and cannot be avoided through operational procedures.

## Recommendation

The validation logic should check against the **current** maximum blocks count limit, not just whether the counter is negative. Modify the validation flow to:

1. Call `GetMaximumBlocksCount()` during validation phase to get the current emergency limit
2. Compare `LatestPubkeyToTinyBlocksCount.BlocksCount` against this current limit
3. Reject blocks when the miner has already reached or exceeded the current limit

Alternative approach: When Severe status is detected, immediately reset `LatestPubkeyToTinyBlocksCount.BlocksCount` to 0 (or the new limit - 1) instead of decrementing the existing value, ensuring the emergency limit takes effect immediately.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task SevereStatus_StaleCounter_AllowsEightBlocks()
{
    // Setup: Miner A has BlocksCount = 7 from producing consecutive blocks
    var minerA = "MinerAPubkey";
    State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
    {
        Pubkey = minerA,
        BlocksCount = 7
    };
    
    // Setup: System enters Severe status (R >= R_LIB + 8)
    var currentRound = new Round { RoundNumber = 100, ConfirmedIrreversibleBlockRoundNumber = 92 };
    State.Rounds[100] = currentRound;
    
    // Miner A attempts to produce 8 blocks during Severe status
    int blocksProduced = 0;
    for (int i = 0; i < 8; i++)
    {
        // Validation phase - reads stale counter from state
        var context = new ConsensusValidationContext
        {
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            SenderPubkey = minerA
        };
        
        var validationResult = new ContinuousBlocksValidationProvider()
            .ValidateHeaderInformation(context);
            
        if (!validationResult.Success)
            break;
            
        // Execution phase - GetMaximumBlocksCount() returns 1 (Severe), but only decrements
        var maxBlocks = GetMaximumBlocksCount(); // Returns 1
        Assert.Equal(1, maxBlocks); // Severe limit
        
        ResetLatestProviderToTinyBlocksCount(maxBlocks);
        blocksProduced++;
    }
    
    // VULNERABILITY: Miner A produced 8 blocks instead of 1
    Assert.Equal(8, blocksProduced); // Should be 1, but is 8
}
```

## Notes

This is a critical consensus integrity vulnerability that compromises the blockchain's emergency safety mechanisms. The TOCTOU issue occurs because validation uses a snapshot of state from before the emergency was detected, while execution applies the new emergency rules but only decrements the old counter. The fix requires either checking the current limit during validation or immediately resetting the counter when emergency status is detected, rather than gradually decrementing it.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-129)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
