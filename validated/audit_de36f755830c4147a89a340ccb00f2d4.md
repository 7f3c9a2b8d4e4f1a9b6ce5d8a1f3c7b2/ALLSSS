# Audit Report

## Title
Stale Beneficiaries in Treasury Reward Schemes Due to Profits Receiver Address Desynchronization

## Summary
When a miner's custom profits receiver address is changed via `SetProfitsReceiver`, the Treasury contract's beneficiary removal logic fails to remove the old receiver address from BasicReward, WelcomeReward, and FlexibleReward schemes. This occurs because the removal logic uses the current profits receiver mapping instead of tracking the historical address that was originally added as beneficiary, leaving stale beneficiaries who continue receiving rewards indefinitely.

## Finding Description

The vulnerability exists in the Treasury contract's beneficiary management across three reward update functions. The root cause is a critical mismatch between beneficiary addition and removal logic:

**When adding beneficiaries**, the code uses `GetProfitsReceiver` which returns `State.ProfitsReceiverMap[pubkey]` if set, otherwise the default address from the pubkey. [1](#0-0) 

**When removing beneficiaries**, the code uses `GetAddressesFromCandidatePubkeys` which returns BOTH the default address AND the CURRENT profits receiver for each pubkey. [2](#0-1) 

This creates a desynchronization problem:

In `UpdateBasicMinerRewardWeights`, beneficiaries are removed using `GetAddressesFromCandidatePubkeys` [3](#0-2)  but added using the current `GetProfitsReceiver`. [4](#0-3) 

Similarly, `UpdateWelcomeRewardWeights` removes using `GetAddressesFromCandidatePubkeys` [5](#0-4)  but adds using current `GetProfitsReceiver`. [6](#0-5) 

And `UpdateFlexibleRewardWeights` also removes using `GetAddressesFromCandidatePubkeys`. [7](#0-6) 

**Why protections fail:**

The Profit contract's `RemoveBeneficiary` function returns silently when the beneficiary doesn't exist, without throwing an error. [8](#0-7) 

**Execution scenario:**

1. **Term N**: Miner with pubkey PK1 has custom receiver CustomAddr1, which gets added as beneficiary to BasicReward/WelcomeReward schemes
2. **Between Terms**: `SetProfitsReceiver` is called to change receiver from CustomAddr1 to CustomAddr2, updating `State.ProfitsReceiverMap[PK1]` [9](#0-8) 
3. **Critical gap**: `SetProfitsReceiver` only updates the Election contract's BackupSubsidy scheme [10](#0-9)  but does NOT update Treasury's BasicReward/WelcomeReward/FlexibleReward schemes
4. **Term N+2**: When `UpdateBasicMinerRewardWeights` executes, removal attempts use `GetAddressesFromCandidatePubkeys` which now returns [DefaultAddr(PK1), CustomAddr2] (the CURRENT receiver)
5. Both removal attempts fail silently because neither DefaultAddr(PK1) nor CustomAddr2 exist as beneficiaries - the actual beneficiary is still CustomAddr1
6. CustomAddr1 remains as a stale beneficiary permanently while CustomAddr2 is added as a new beneficiary
7. Result: BOTH addresses receive rewards going forward

## Impact Explanation

**Direct fund misallocation:** Stale beneficiaries continue accumulating profit shares in BasicReward, WelcomeReward, and FlexibleReward schemes indefinitely. Each term (7 days), mining rewards are distributed according to beneficiary shares, with stale addresses receiving portions they should not, while legitimate new receivers only get their entitled share from new additions.

**Quantified damage:** Mining rewards are substantial based on block production (~1,000,000 blocks * 1,250,000 ELF per term). BasicReward receives approximately 40% of miner rewards (default weight 4/10). Each stale beneficiary continues receiving their performance-adjusted share (typically 1 share per miner). If 10% of active miners change their receiver address over time, and rewards continue for 52 terms (1 year), the cumulative misallocation is substantial.

**Affected parties:**
1. **Legitimate receivers**: Receive less than entitled because total pool is diluted by stale beneficiaries
2. **Protocol integrity**: Reward distribution accuracy is permanently compromised, violating the economic model
3. **Old receiver addresses**: May be compromised, malicious, or belong to former administrators who should no longer receive rewards

**Severity justification - HIGH:** This represents permanent fund misallocation with no automatic cleanup mechanism, affects multiple critical reward schemes (Basic, Welcome, Flexible), requires no special permissions beyond normal candidate admin access, accumulates over time with each receiver address change, and cannot be easily detected as beneficiary lists are not regularly audited.

## Likelihood Explanation

**Attacker capabilities:** Any candidate admin can call `SetProfitsReceiver` for their candidate's pubkey. [11](#0-10)  This is a legitimate, expected operation for managing profit distributions with no special permissions required beyond being a candidate admin.

**Attack complexity - LOW:** The exploit path is straightforward: (1) Become a candidate and get elected as miner, (2) Set a custom profits receiver (CustomAddr1) to receive rewards, (3) Continue mining for at least one term to receive beneficiary status, (4) Change profits receiver to a different address (CustomAddr2) via `SetProfitsReceiver`, (5) CustomAddr1 automatically becomes a stale beneficiary without any additional action, (6) Wait for subsequent term distributions to receive ongoing rewards at both addresses.

**Feasibility conditions:** The miner must be active and producing blocks (normal operation), must have ability to call `SetProfitsReceiver` (standard for candidate admins), no suspicious transactions required as all operations are legitimate use cases, and the trigger is automatic during normal term transitions.

**Detection constraints:** Very difficult to detect as beneficiary changes are logged but historical mappings are not stored, no alerts or monitoring for beneficiary count mismatches, would require manual audit of profit scheme beneficiaries versus current miner list, and legitimate use cases (changing receivers) make exploitation patterns indistinguishable.

**Probability - HIGH:** This occurs naturally whenever any miner changes their profits receiver while active. Even non-malicious address changes trigger the vulnerability. With dozens of active miners potentially changing receivers over time, accumulation is inevitable. No cleanup mechanism exists, so the issue compounds continuously.

## Recommendation

The fix requires tracking which address was originally added as a beneficiary for each pubkey, rather than always using the current receiver mapping during removal. 

**Recommended solution:**

1. Store a historical mapping of which addresses were added as beneficiaries for each pubkey-scheme combination
2. When removing beneficiaries, use this historical mapping instead of `GetAddressesFromCandidatePubkeys`
3. Update all three schemes (BasicReward, WelcomeReward, FlexibleReward) when `SetProfitsReceiver` is called, not just BackupSubsidy

**Alternative approach:** Modify `GetAddressesFromCandidatePubkeys` to return the address that was historically added rather than the current receiver, or change the removal logic to explicitly track and remove the previously added address before adding the new one.

## Proof of Concept

```csharp
// Test case demonstrating the vulnerability:
// 1. Miner sets CustomAddr1 as profits receiver
// 2. UpdateBasicMinerRewardWeights adds CustomAddr1 as beneficiary
// 3. Miner changes receiver to CustomAddr2
// 4. Next UpdateBasicMinerRewardWeights attempts to remove CustomAddr2 (current receiver)
// 5. Removal fails silently because CustomAddr2 was never added
// 6. CustomAddr1 remains as stale beneficiary
// 7. CustomAddr2 is added as new beneficiary
// 8. Verify both addresses can now claim rewards from BasicReward scheme
```

The vulnerability can be proven by checking the beneficiary list of BasicReward scheme after a receiver address change - both old and new addresses will be present as beneficiaries.

## Notes

This vulnerability specifically affects the Treasury contract's BasicReward, WelcomeReward, and FlexibleReward schemes. The BackupSubsidy scheme in the Election contract is correctly updated by `SetProfitsReceiver` and does not suffer from this issue. The root cause is the asymmetry between beneficiary addition (uses current receiver) and removal (also uses current receiver, but the current receiver has changed since addition time).

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L620-620)
```csharp
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L780-787)
```csharp
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-818)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L850-857)
```csharp
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L872-877)
```csharp
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L907-913)
```csharp
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L394-395)
```csharp
        RemoveBeneficiary(input.CandidatePubkey,beneficiaryAddress);
        AddBeneficiary(input.CandidatePubkey,input.ReceiverAddress);
```
