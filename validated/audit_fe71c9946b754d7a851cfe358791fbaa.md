# Audit Report

## Title
Unbounded Profit Detail Accumulation Causes Gas Griefing and Operational DoS

## Summary
The Profit contract's `ClaimProfits` function processes a maximum of 10 profit details per transaction, but there is no upper bound on how many details can accumulate for a single beneficiary. This design flaw forces users with numerous profit details—particularly active voters in the Election system—to make multiple transactions to claim all their profits, resulting in excessive gas costs and poor user experience.

## Finding Description

The vulnerability stems from a mismatch between the profit detail accumulation mechanism and the claiming mechanism.

**Accumulation Without Limits**: When the `AddBeneficiary` method is called, it unconditionally appends a new `ProfitDetail` to the beneficiary's detail list [1](#0-0) . There is no check or enforcement of a maximum number of active details per beneficiary.

**Processing Limitation**: The `ClaimProfits` function explicitly limits processing to 10 profit details per transaction [2](#0-1) , where the limit is defined as a constant [3](#0-2) .

**Real-World Trigger Path - Election Voting**: The Election contract's `Vote` method creates one profit detail per vote by calling `AddBeneficiaryToVoter` [4](#0-3) , which directly invokes the Profit contract's `AddBeneficiary` method [5](#0-4) . The code comment explicitly states "one vote, one profit detail" [6](#0-5) .

**Insufficient Cleanup**: The cleanup logic in `AddBeneficiary` only removes details that have already been fully claimed AND are past their due period [7](#0-6) . Similarly, `ClaimProfits` only removes details after they are completely processed [8](#0-7) . Neither mechanism prevents the accumulation of new active details.

**Authorization Context**: Only the scheme manager or TokenHolder contract can add beneficiaries [9](#0-8) . While this prevents arbitrary external addition, it doesn't prevent accumulation through legitimate use (voting) or by a compromised/malicious manager.

**Missed Consolidation Opportunity**: The TokenHolder contract demonstrates a consolidation mechanism that removes existing details before adding new ones [10](#0-9) . However, the Election contract bypasses this consolidation by calling the Profit contract directly, allowing unbounded detail accumulation.

## Impact Explanation

**Gas Griefing**: An active voter with 1,000 profit details must invoke `ClaimProfits` 100 separate times (1,000 ÷ 10) to claim all accumulated profits. Each transaction incurs gas fees. If each transaction costs 0.01 ELF, the user spends 1 ELF in transaction fees just to access their rightful profits—a significant economic burden.

**Operational Denial of Service**: Requiring 100 separate transactions creates severe user experience friction:
- Time-consuming process (multiple block confirmations)
- Increased complexity and potential for user errors
- Risk that profits may expire before all can be claimed if the `ProfitReceivingDuePeriodCount` limit is reached

**Affected User Base**: 
- Active voters in the Election system (encouraged and legitimate behavior)
- Beneficiaries in any profit scheme with a compromised or malicious manager
- Long-term participants who accumulate details over extended periods

**Severity Justification**: This is a **Medium severity** issue. While funds are not directly stolen or permanently lost, the operational disruption and financial waste (gas costs) are substantial, especially for ecosystem participants who are actively contributing (voting). The issue degrades protocol usability and penalizes good actors.

## Likelihood Explanation

**Two Distinct Paths**:

1. **Normal Usage (High Likelihood)**: Active participation in the Election system naturally creates this scenario. Each vote adds a profit detail, and there's no mechanism to consolidate them. A voter participating in 1,000 votes over time will inevitably accumulate 1,000 details. This requires no malicious actor and occurs through encouraged protocol behavior.

2. **Malicious Manager (Medium Likelihood)**: A compromised scheme manager could deliberately spam `AddBeneficiary` calls for a victim address with minimal shares, artificially inflating their detail count. This requires manager-level access but is straightforward to execute once obtained.

**Preconditions**: 
- Normal path: User participates in voting (no special conditions)
- Malicious path: Attacker controls or compromises a scheme manager role

**Detection**: The accumulation is observable on-chain through profit detail queries, but there's no preventive mechanism in the contract logic.

**Assessment**: The likelihood is **MEDIUM to HIGH** because the normal usage path alone (active voting) guarantees this issue will manifest for engaged users. The malicious path adds additional risk but is secondary to the fundamental design problem.

## Recommendation

Implement a consolidation mechanism in the Profit contract or modify the Election contract's integration:

**Option 1 - Profit Contract Enhancement**: Add a consolidation step in `AddBeneficiary` that merges existing details for the same beneficiary when adding new ones (similar to the TokenHolder pattern). When adding a new detail, check if existing details exist, sum their shares, and create a single consolidated detail.

**Option 2 - Election Contract Modification**: Modify the Election contract to use a consolidation approach when adding voters to the welfare scheme. Before calling `AddBeneficiary`, check for existing details and consolidate them.

**Option 3 - Maximum Detail Limit**: Enforce a maximum number of active profit details per beneficiary (e.g., 100). When this limit is reached, either reject new additions or force consolidation.

**Option 4 - Batch Claiming Enhancement**: Increase the `ProfitReceivingLimitForEachTime` constant significantly (e.g., from 10 to 100) to reduce the number of required transactions, though this doesn't solve the fundamental unbounded accumulation issue.

The recommended solution is **Option 1** as it addresses the root cause while maintaining backward compatibility and preventing the issue across all profit schemes, not just Election.

## Proof of Concept

```csharp
// Simplified test demonstrating the issue
[Fact]
public async Task ActiveVoter_Accumulates_Unbounded_ProfitDetails()
{
    // Setup: Initialize Election and Profit contracts
    var voter = Accounts[1].Address;
    var candidate = ValidationDataCenterKeyPairs[0].PublicKey.ToHex();
    
    // Simulate active voter making 100 votes over time
    for (int i = 0; i < 100; i++)
    {
        var voteAmount = 100_00000000; // 100 ELF
        var lockTime = 90 * 86400; // 90 days
        
        await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
        {
            CandidatePubkey = candidate,
            Amount = voteAmount,
            EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime)
        });
    }
    
    // Verify: Get profit details for the voter
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            SchemeId = WelfareSchemeId,
            Beneficiary = voter
        });
    
    // Assert: Voter has 100 separate profit details (one per vote)
    profitDetails.Details.Count.ShouldBe(100);
    
    // Verify: Claiming profits only processes 10 details per transaction
    await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = WelfareSchemeId
    });
    
    // After one claim, details should reduce by max 10
    var detailsAfterClaim = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            SchemeId = WelfareSchemeId,
            Beneficiary = voter
        });
    
    // Still has 90+ details remaining, requiring 9 more transactions
    detailsAfterClaim.Details.Count.ShouldBeGreaterThan(90);
}
```

## Notes

- The issue manifests naturally through legitimate Election participation without requiring any malicious actor
- The TokenHolder contract demonstrates that a consolidation solution is feasible within the AElf contract architecture
- The 10-detail processing limit is a mitigation for gas costs per transaction but inadvertently creates the gas griefing vector when combined with unbounded accumulation
- The `MaximumProfitReceivingPeriodCount` mechanism limits periods claimed per detail but doesn't address the detail count issue
- This affects all profit schemes where beneficiaries are added multiple times, not just Election, though Election is the most prominent real-world case

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-773)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-804)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L371-382)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L443-443)
```csharp
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L46-56)
```csharp
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }
```
