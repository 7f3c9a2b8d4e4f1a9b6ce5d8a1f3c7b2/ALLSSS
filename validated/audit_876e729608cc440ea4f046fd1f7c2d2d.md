# Audit Report

## Title
Evil Miners Can Propose Cross-Chain Indexing Data After Being Banned Due to Missing BannedPubkey Validation

## Summary
The cross-chain indexing authorization mechanism fails to validate whether miners have been marked as evil in the Election contract's `BannedPubkeyMap`. This creates a one-round timing window where detected evil miners can still propose and release cross-chain indexing data before being fully removed from the consensus round, potentially compromising cross-chain data integrity.

## Finding Description

The vulnerability arises from a race condition in the consensus round transition mechanism combined with an insufficient authorization check in cross-chain operations.

**Authorization Check Weakness:**
The cross-chain indexing authorization uses `CheckCrossChainIndexingPermission`, which delegates to `IsCurrentMiner` without validating against `BannedPubkeyMap`: [1](#0-0) 

The `IsCurrentMiner` function only verifies if the pubkey exists in the current round's miner list and checks time slot validity, but never validates against the Election contract's `BannedPubkeyMap`: [2](#0-1) 

**Round Transition Timing Vulnerability:**
The critical flaw occurs in the round transition sequence within `ProcessNextRound`. The pre-generated `nextRound` is obtained from input BEFORE evil miners are detected and marked: [3](#0-2) 

The sequence is: (1) extract pre-generated nextRound from input (line 110), (2) detect evil miners and mark them in `BannedPubkeyMap` (lines 139-154), (3) add the pre-generated nextRound which still contains evil miners (line 156).

**Next Round Generation Gap:**
When generating the next round, `GetMinerReplacementInformation` is called to identify evil miners for replacement: [4](#0-3) 

However, this happens DURING round generation (before `ProcessNextRound` executes). The Election contract's `GetEvilMinersPubkeys` checks `BannedPubkeyMap`: [5](#0-4) 

But evil miners are only marked in `BannedPubkeyMap` AFTER the round generation during `ProcessNextRound`: [6](#0-5) 

**Cross-Chain Entry Points:**
Both critical cross-chain indexing methods use the insufficient authorization check: [7](#0-6) [8](#0-7) 

**Evil Miner Detection Threshold:**
Evil miners are detected when they accumulate 4,320 missed time slots (3 days at 1 slot per minute): [9](#0-8) [10](#0-9) 

## Impact Explanation

**Cross-Chain Data Integrity Compromise:** Evil miners who have been detected and banned can still propose and release cross-chain indexing data for one complete consensus round. While cross-chain proposals require governance approval from the CrossChainIndexingController organization, a banned miner should not have the ability to propose at all once detected as malicious. This allows potential submission of fraudulent cross-chain block data including invalid merkle tree roots, incorrect block heights, and malicious transaction status information.

**Consensus System Trust Violation:** The system explicitly detects and bans malicious miners through the evil node detection mechanism, yet the authorization system continues to trust them for critical cross-chain operations. This undermines the security guarantees provided by the evil node detection system.

**Affected Parties:** All chains relying on cross-chain indexing integrity, including side chains trusting parent chain data and parent chains trusting side chain data indexed by evil miners during the vulnerability window.

## Likelihood Explanation

**Attack Practicality:** The attack is highly practical - an attacker operates a miner node and intentionally accumulates 4,320 missed time slots over 3 days. Upon detection and banning at round transition, they immediately call `ProposeCrossChainIndexing` during round N+1. No special privileges beyond being an existing miner are required.

**Preconditions:** Attacker must be an active miner and accumulate sufficient missed time slots to trigger evil detection. The timing must be coordinated to act within the one-round window.

**Detection Difficulty:** The attack is difficult to detect in real-time because the miner appears legitimate to the `IsCurrentMiner` check, and cross-chain proposals follow the normal governance flow.

**Economic Feasibility:** The cost is reasonable - the attacker loses their miner position but gains the ability to submit potentially malicious cross-chain data before complete removal. For high-value cross-chain attacks, this trade-off may be economically rational.

## Recommendation

Add a `BannedPubkeyMap` validation check in the `IsCurrentMiner` function or create a separate validation method for cross-chain operations:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    
    // Check if miner is banned in Election contract
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var isBanned = State.ElectionContract.IsPubkeyBanned.Call(new StringValue { Value = pubkey });
        if (isBanned.Value) return false;
    }
    
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;
    
    // ... rest of existing validation logic
}
```

Alternatively, perform the evil miner detection and `BannedPubkeyMap` marking BEFORE generating the next round, ensuring that `GetMinerReplacementInformation` has access to the updated banned list.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a miner with accumulated missed time slots exceeding `TolerableMissedTimeSlotsCount`
2. Trigger round transition via `ProcessNextRound` which marks the miner as evil
3. Verify the miner is in `BannedPubkeyMap` 
4. Verify the miner is still in the next round's miner list
5. Successfully call `ProposeCrossChainIndexing` from the banned miner's address
6. Confirm the authorization check passes despite the miner being banned

The test would demonstrate that `IsCurrentMiner` returns `true` for a banned miner during the one-round window between detection and removal from the active miner list.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-221)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;

        Context.LogDebug(() =>
            $"Extra block producer of previous round: {currentRound.ExtraBlockProducerOfPreviousRound}");

        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }

        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }

        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }

        // Check saving extra block time slot.
        var nextArrangeMiningTime =
            currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
        var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
        if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
            Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]SAVING");
            return true;
        }

        // If current round is the first round of current term.
        if (currentRound.RoundNumber == 1)
        {
            Context.LogDebug(() => "First round");

            var latestMinedInfo =
                currentRound.RealTimeMinersInformation.Values.OrderByDescending(i => i.Order)
                    .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
            if (latestMinedInfo != null)
            {
                var minersCount = currentRound.RealTimeMinersInformation.Count;
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
                {
                    Context.LogDebug(() => "[CURRENT MINER]FIRST ROUND");
                    return true;
                }
            }
        }

        Context.LogDebug(() => "[CURRENT MINER]NOT MINER");

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
