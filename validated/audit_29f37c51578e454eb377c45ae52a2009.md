# Audit Report

## Title
Vote Manipulation Through Member Removal After Rejection

## Summary
The Association contract allows organizations to manipulate proposal outcomes by removing members after they have cast rejection votes. The `IsProposalRejected()` function only counts rejections from current members rather than members at the time of voting, enabling proposals that should be rejected to be released by strategically removing dissenting voters.

## Finding Description

The vulnerability exists in the critical interaction between vote recording and threshold validation:

**Vote Recording:** When a member casts a rejection vote, the system verifies they are a current member and adds their address to the proposal's rejection list. [1](#0-0) 

**Dynamic Threshold Calculation:** When checking if a proposal is rejected during release, the system counts only rejections from addresses that are currently in the organization member list, not those who were members when they voted. The filtering logic `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` dynamically re-evaluates vote validity based on current membership. [2](#0-1) 

**Unrestricted Member Removal:** Organizations can remove members at any time without any checks for active proposals or existing votes. [3](#0-2) 

**Root Cause:** The fundamental issue is that vote validity is re-evaluated at proposal release time based on current membership rather than being immutably recorded at vote time. This allows past votes from removed members to be retroactively invalidated.

**Why Protections Fail:** The organization validation only checks structural constraints (member count meets thresholds, no duplicates) but contains no logic to prevent member manipulation during active voting periods. [4](#0-3) 

The release function relies on `IsReleaseThresholdReached`, which calls `IsProposalRejected` to check rejection thresholds. [5](#0-4) 

## Impact Explanation

**Concrete Harm:**
- Organizations can force through proposals that legitimately reached rejection thresholds by removing dissenting members after they vote
- Breaks the fundamental integrity of the governance system where votes should be final once cast
- Enables unauthorized proposal execution by manipulating the apparent vote count

**Severity Justification (HIGH):**
- Directly violates the "Authorization & Governance" critical invariant requiring correct organization threshold enforcement
- Allows bypassing rejection thresholds entirely through membership manipulation
- No limit on the number of proposals that can be manipulated
- Affects all Association-governed organizations in the AElf ecosystem

**Affected Parties:**
- Organization members whose rejection votes can be retroactively invalidated
- External parties relying on Association governance decisions
- Smart contracts controlled by manipulated Association organizations

## Likelihood Explanation

**Attacker Capabilities:**
The exploit requires organization-level control, meaning the organization itself (through a separate approved proposal) must execute the member removal. This is realistic because:
- Organizations can create proposals to modify their own membership
- A coalition controlling approval thresholds can remove dissenting members
- This is the intended attack surface for governance manipulation

**Attack Complexity:**
Low - requires only standard contract operations in sequence:
1. Wait for rejection votes on target proposal
2. Create and approve a proposal to remove those members
3. Release the member removal proposal
4. Release the original proposal (now no longer rejected)

**Feasibility Conditions:**
- Target proposal must have accumulated sufficient rejections to be blocked
- Attacker coalition must control enough approval votes to remove dissenting members
- All steps use public contract methods with no special permissions required

**Economic Rationality:**
If the proposal being forced through provides value (e.g., treasury withdrawal, contract upgrade, parameter change), the cost of creating and approving the member removal proposal is justified by the gain.

## Recommendation

The fix should ensure that votes remain valid based on membership at the time of voting, not at the time of release. Consider these approaches:

1. **Snapshot-based voting:** Record a snapshot of valid voters when the proposal is created, and validate votes against that snapshot
2. **Prevent member removal during active voting:** Add checks in `RemoveMember` to prevent removal of members who have voted on active proposals
3. **Lock vote validity:** Once a vote is cast and validated, mark it as permanently valid regardless of future membership changes

Example fix for approach #2:
```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    
    // NEW: Check if member has voted on any active proposals
    Assert(!HasActiveProposalVotes(input), 
        "Cannot remove member with votes on active proposals.");
    
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    // ... rest of function
}
```

## Proof of Concept

```csharp
[Fact]
public void VoteManipulation_RemoveMemberAfterRejection_Test()
{
    // Setup: Create organization with 5 members
    var members = new[] { Member1, Member2, Member3, Member4, Member5 };
    var org = CreateOrganizationWithMembers(members, 
        minApproval: 2, maxRejection: 1); // Reject if >1 rejection
    
    // Step 1: Create proposal
    var proposalId = CreateProposal(org);
    
    // Step 2: Members 1 and 2 reject the proposal (exceeds threshold)
    Reject(proposalId, Member1);
    Reject(proposalId, Member2);
    
    // Verify proposal is rejected
    Assert.True(IsProposalRejected(proposalId));
    
    // Step 3: Malicious organization removes Member1 (who rejected)
    RemoveMember(org, Member1);
    
    // Step 4: Now only 1 rejection counts (Member2), proposal no longer rejected
    Assert.False(IsProposalRejected(proposalId));
    
    // Step 5: Proposal can be released despite originally having 2 rejections
    Release(proposalId); // Should fail but succeeds - VULNERABILITY
    
    Assert.True(ProposalWasExecuted(proposalId));
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
