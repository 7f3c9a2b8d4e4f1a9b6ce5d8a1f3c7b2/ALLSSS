# Audit Report

## Title
Unvalidated External Callbacks Enable Denial-of-Service on Token Operations

## Summary
The MultiToken contract allows token creators to specify arbitrary callback contract addresses in the `ExternalInfo` field without validation. These callbacks are automatically invoked during Transfer, Lock, and Unlock operations. A malicious callback that fails causes the entire token operation to fail and roll back due to AElf's inline transaction failure propagation, resulting in complete denial-of-service for all token holders.

## Finding Description

The TokenContract's `CreateToken` method directly accepts and stores `ExternalInfo` from user input without validating callback contract addresses. [1](#0-0) 

Three callback keys are defined for token operations: [2](#0-1) 

When tokens are transferred, the contract invokes callbacks without address validation via `Context.SendInline`: [3](#0-2) 

Similar unvalidated callback invocations occur during lock operations: [4](#0-3) 

And unlock operations: [5](#0-4) 

These callbacks are invoked AFTER state modifications in the Transfer method: [6](#0-5) 

Lock method: [7](#0-6) 

And Unlock method: [8](#0-7) 

**Critical flaw:** AElf's transaction execution model fails the parent transaction if any inline transaction fails. The `IsSuccessful()` method recursively checks all inline traces: [9](#0-8) 

When an inline transaction fails, the entire operation including all state changes is rolled back, leaving the token effectively non-transferable for all holders.

**Contrast with proper validation:** The contract properly validates `LockWhiteList` addresses must be system contracts: [10](#0-9) 

However, no equivalent validation exists for callback addresses in `ExternalInfo`.

## Impact Explanation

**High Severity - Complete Token Operation DoS:**

1. **All holders affected**: Any user attempting to transfer, lock, or unlock the malicious token will have their transaction fail completely
2. **Funds effectively frozen**: Tokens become non-transferable, trapping value for all holders
3. **DeFi protocol breakage**: If integrated into DEXs, lending protocols, or other DeFi systems, those integrations become non-functional
4. **Cascade failures**: Multi-token transactions fail if they include the malicious token
5. **Unrecoverable**: The malicious callback is permanently stored in the token's immutable `ExternalInfo`

This breaks the fundamental security guarantee that legitimate token holders can freely transfer their assets. While not direct theft, it achieves the same economic outcome: users lose access to their token value.

## Likelihood Explanation

**High Likelihood:**

**Attacker Requirements (all easily obtainable):**
1. SEED NFT for token creation (purchasable on market)
2. Deploy malicious callback contract (trivial: single method that reverts)
3. Create token with callback in ExternalInfo
4. Distribute tokens (airdrops, sales, legitimate-looking marketing)

**Attack Complexity: Very Low**
- No special permissions required
- No trusted role compromise needed
- Single transaction to create malicious token
- Victims trigger DoS automatically by attempting normal operations

**Detection Difficulty: Very High**
- Pre-deployment: Impossible to distinguish from legitimate token
- Post-deployment: Only discovered when users try to transfer
- ExternalInfo is opaque during token creation

**Economic Viability:**
- Cost: One SEED NFT + minimal gas fees
- Impact: Unlimited victims
- Persistent: Cannot be fixed without creating new token
- Use cases: Competitor disruption, exit scams, ransom attacks

## Recommendation

Implement callback address validation during token creation:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    AssertValidCreateInput(input, symbolType);
    
    // Validate callback addresses in ExternalInfo
    if (input.ExternalInfo != null && input.ExternalInfo.Value.Count > 0)
    {
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var callbackKeys = new[] { 
            TokenContractConstants.TransferCallbackExternalInfoKey,
            TokenContractConstants.LockCallbackExternalInfoKey,
            TokenContractConstants.UnlockCallbackExternalInfoKey 
        };
        
        foreach (var key in callbackKeys)
        {
            if (input.ExternalInfo.Value.ContainsKey(key))
            {
                var callbackInfo = JsonParser.Default.Parse<CallbackInfo>(
                    input.ExternalInfo.Value[key]);
                Assert(systemContractAddresses.Contains(callbackInfo.ContractAddress),
                    $"Callback contract address must be a system contract. Key: {key}");
            }
        }
    }
    
    // Rest of existing CreateToken logic...
}
```

Alternatively, maintain a whitelist of approved callback contracts similar to the LockWhiteList mechanism.

## Proof of Concept

```csharp
[Fact]
public async Task DoS_Via_Malicious_Callback_Test()
{
    // Setup: Deploy malicious callback contract that always reverts
    var maliciousContract = await DeployMaliciousCallbackContract();
    
    // Attacker creates token with malicious callback
    var createInput = new CreateInput
    {
        Symbol = "DOS",
        TokenName = "DoS Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = AttackerAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {
                    TokenContractConstants.TransferCallbackExternalInfoKey,
                    new CallbackInfo
                    {
                        ContractAddress = maliciousContract,
                        MethodName = "AlwaysRevert"
                    }.ToString()
                }
            }
        }
    };
    
    await TokenContractStub.Create.SendAsync(createInput);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "DOS",
        Amount = 1000,
        To = VictimAddress
    });
    
    // Victim attempts to transfer their tokens
    var transferResult = await TokenContractAsVictim.Transfer.SendWithExceptionAsync(
        new TransferInput
        {
            To = AnotherAddress,
            Symbol = "DOS",
            Amount = 100
        });
    
    // Assert: Transaction fails due to callback failure
    transferResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    
    // Assert: Victim's balance unchanged (operation rolled back)
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = VictimAddress,
        Symbol = "DOS"
    });
    balance.Balance.ShouldBe(1000); // Still has original amount, cannot transfer
}
```

This demonstrates how a token with a malicious callback permanently DoS's all transfer operations for innocent holders.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L95-98)
```csharp
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Select(m => m.Value);
        var isSystemContractAddress = input.LockWhiteList.All(l => systemContractAddresses.Contains(l));
        Assert(isSystemContractAddress, "Addresses in lock white list should be system contract addresses");
        foreach (var address in input.LockWhiteList) State.LockWhiteLists[input.Symbol][address] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-15)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```
