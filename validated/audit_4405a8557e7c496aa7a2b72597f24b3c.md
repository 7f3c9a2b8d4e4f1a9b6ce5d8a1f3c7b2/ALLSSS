# Audit Report

## Title
Evil Nodes Bypass Punishment During Term Transitions Due to Missing Banned Pubkey Check in GetVictories Fallback Logic

## Summary
The Election contract's `GetVictories` method contains a critical vulnerability in its fallback logic that allows banned miners (marked as evil nodes) to continue participating in consensus during term transitions. When insufficient valid candidates are available, the method selects backup miners from initial miners without checking `State.BannedPubkeyMap`, completely bypassing the punishment mechanism.

## Finding Description

The vulnerability exists in the `GetVictories` method's fallback selection logic. When valid candidates are insufficient to fill all miner slots during a term transition, the method falls back to selecting backup miners from current miners and initial miners without verifying whether these nodes have been banned. [1](#0-0) 

The fallback logic directly adds miners from `currentMiners` and `State.InitialMiners` without checking `State.BannedPubkeyMap`. When a node is marked as evil, the `UpdateCandidateInformation` method sets the banned flag and removes the node from candidates, but crucially does NOT remove it from `State.InitialMiners`: [2](#0-1) 

The correct implementation exists in the same file. The `GetMinerReplacementInformation` method properly filters banned pubkeys when selecting from initial miners: [3](#0-2) 

During term transitions, the consensus contract calls `TryToGetVictories` to obtain the new miner list: [4](#0-3) 

This calls the vulnerable `GetVictories` method in the Election contract. The method is invoked during the generation of the first round of a new term: [5](#0-4) 

The returned miner list is then directly used to set the new term's miners without additional validation: [6](#0-5) 

The miner replacement mechanism that could potentially catch banned miners only activates during same-term round transitions, NOT during term changes: [7](#0-6) 

## Impact Explanation

This vulnerability has CRITICAL impact on network security and integrity:

1. **Consensus Integrity Violation**: Banned miners (evil nodes) that should be excluded from consensus continue participating in block production across multiple terms, completely defeating the punishment mechanism designed to maintain network security.

2. **Reward Misallocation**: Banned miners continue earning mining rewards despite being marked as malicious actors. The term transition process includes reward distribution: [8](#0-7) 

3. **Long-term Attack Persistence**: Malicious nodes can continue attacking the network across multiple terms without consequences, as long as candidate participation remains low.

4. **Undermined Governance**: The evil node detection and punishment mechanism becomes ineffective, as banned nodes automatically return during term transitions.

The impact affects network security, legitimate miners facing unfair competition, token holders whose rewards fund banned nodes, and overall network trustworthiness.

## Likelihood Explanation

The likelihood of this vulnerability being triggered is HIGH:

**Reachable Entry Point**: Term transitions occur automatically based on blockchain time through the public consensus mechanism. No special privileges are required beyond the normal mining process.

**Feasible Preconditions**:
1. At least one miner marked as evil (realistic - happens through `UpdateCandidateInformation` called by consensus contract when detecting evil behavior or via emergency response organization)
2. Valid candidates < required miners count (realistic during low participation periods, especially in early network stages or periods of low voter engagement)
3. Term transition occurs (happens regularly in normal operation - every term period)

**Automatic Trigger**: The vulnerability triggers deterministically during normal term transitions when insufficient candidates exist. No attacker action is required beyond the initial evil behavior that caused the ban.

**Silent Execution**: The issue occurs without errors or events that would alert operators, making it difficult to detect without explicit monitoring of the banned pubkey map versus active miner lists.

## Recommendation

Add a banned pubkey check to the `GetVictories` fallback logic. The fix should filter out banned initial miners similar to how `GetMinerReplacementInformation` does:

In `ViewMethods.cs`, modify the fallback logic at lines 67-69 to include the banned check:

```csharp
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value
            .Select(k => k.ToHex())
            .Where(k => !State.BannedPubkeyMap[k])  // ADD THIS CHECK
            .Where(k => !backups.Contains(k)));
```

This ensures that banned miners from the initial miner list cannot be selected as backups during term transitions when valid candidates are insufficient.

## Proof of Concept

```csharp
[Fact]
public async Task GetVictories_Should_Exclude_Banned_InitialMiners_When_Insufficient_Candidates()
{
    // Setup: Initialize with initial miners
    await InitializeElectionContract();
    
    // Mark one of the initial miners as evil
    var evilMinerPubkey = InitialCoreDataCenterKeyPairs.First().PublicKey.ToHex();
    await ConsensusStub.UpdateCandidateInformation.SendAsync(new UpdateCandidateInformationInput
    {
        Pubkey = evilMinerPubkey,
        IsEvilNode = true
    });
    
    // Verify the miner is banned
    var isBanned = await ElectionStub.GetCandidateInformation.CallAsync(new StringValue { Value = evilMinerPubkey });
    isBanned.ShouldBeNull(); // Removed from candidates
    
    // Trigger term transition with insufficient valid candidates
    await NextTermWithInsufficientCandidates();
    
    // Get victories for new term
    var victories = await ElectionStub.GetVictories.CallAsync(new Empty());
    
    // BUG: Banned miner appears in victory list
    victories.Value.Select(p => p.ToHex()).ShouldNotContain(evilMinerPubkey);
    // This assertion FAILS - proving the vulnerability
}
```

## Notes

The vulnerability is particularly severe because:

1. **Design Inconsistency**: The codebase already demonstrates awareness of this issue in `GetMinerReplacementInformation`, which correctly filters banned miners. This makes the missing check in `GetVictories` a clear oversight.

2. **Defense in Depth Failure**: The miner replacement mechanism (`GetMinerReplacementInformation`) provides protection during same-term round transitions but is explicitly skipped during term transitions, creating a security gap.

3. **State Inconsistency**: `UpdateCandidateInformation` removes evil nodes from the `Candidates` list but not from `InitialMiners`, creating an inconsistent state that the fallback logic fails to handle properly.

4. **Production Impact**: This is not a theoretical issue - it can occur naturally during periods of low network participation without any malicious action required after the initial evil node detection.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-77)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-242)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-309)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-191)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
