# Audit Report

## Title
Candidate Admin Separation Invariant Can Be Bypassed Through AnnounceElectionFor

## Summary
The Election contract enforces an invariant that "Candidate cannot be others' admin" in the `AnnounceElection` method, but this critical check is absent from `AnnounceElectionFor` and `SetCandidateAdmin`. This allows any candidate to bypass the restriction and become an admin for multiple candidates, centralizing control over candidate slots and violating the intended decentralization guarantees of the election system.

## Finding Description

The Election contract maintains two related state mappings for managing candidate administration relationships: `CandidateAdmins` (pubkey → admin address) and `ManagedCandidatePubkeysMap` (admin address → list of managed pubkeys). [1](#0-0) 

The `AnnounceElection` method explicitly enforces the separation invariant through a validation check that prevents addresses already managing candidates from becoming candidates themselves. [2](#0-1) 

However, the `AnnounceElectionFor` method completely omits this validation check, allowing the admin parameter to be set without verifying whether that admin is already a candidate. [3](#0-2) 

Similarly, `SetCandidateAdmin` allows changing a candidate's admin without checking if the new admin is already a candidate. [4](#0-3) 

**Exploitation Sequence:**
1. Alice calls `AnnounceElection(Alice)` - The check at line 102 passes because `ManagedCandidatePubkeysMap[Alice]` is initially null
2. After execution, Alice is a candidate and `ManagedCandidatePubkeysMap[Alice]` contains only Alice's pubkey
3. Alice calls `AnnounceElectionFor(BobPubkey, Alice)` - No validation prevents Alice from managing additional candidates
4. Result: `ManagedCandidatePubkeysMap[Alice]` now contains both Alice's and Bob's pubkeys, violating the invariant

Both methods are publicly accessible RPC endpoints. [5](#0-4) 

## Impact Explanation

The candidate admin role carries significant privileges that enable centralization of control:

**Authorization Control:**
- The admin can unilaterally set profit receivers for all managed candidates via the Treasury contract's `SetProfitsReceiver` method. [6](#0-5) 

- The admin can force any managed candidate to quit the election. [7](#0-6) 

- The admin can replace candidate public keys at will. [8](#0-7) 

**Governance Impact:**
- A single entity can control multiple candidate slots while appearing as separate candidates
- The admin can redirect mining rewards from managed candidates to their own address
- This undermines the decentralized election process by allowing vote manipulation through multiple controlled candidates
- Managed candidates lose autonomy over their candidacy, profits, and operational decisions

**Economic Impact:**
By setting profit receivers for managed candidates to their own address, the attacker can extract BackupSubsidy rewards earned by infrastructure they don't operate, effectively stealing mining rewards from legitimate node operators.

## Likelihood Explanation

**Accessibility:** Both `AnnounceElection` and `AnnounceElectionFor` are public RPC methods callable by any user without special privileges, as confirmed in the proto definition. [9](#0-8) 

**Execution Requirements:** 
- Cost: Multiple candidate deposits (ElectionContractConstants.LockTokenForElection per candidate, typically 100,000 ELF)
- Prerequisites: Sufficient token balance for deposits
- No timing constraints or complex state preconditions required

**Detection:** The vulnerability can be detected by querying managed pubkeys for candidate addresses using the `GetManagedPubkeys` view method. [10](#0-9) 

**Probability:** HIGH - The bypass requires only two simple transaction calls with no coordination or timing requirements. Any user with sufficient tokens can execute this attack immediately.

## Recommendation

Add the same invariant check to both `AnnounceElectionFor` and `SetCandidateAdmin` methods:

```csharp
// In AnnounceElectionFor, before line 128:
Assert(State.ManagedCandidatePubkeysMap[admin] == null, "Candidate cannot be others' admin.");

// In SetCandidateAdmin, before line 42:
Assert(State.ManagedCandidatePubkeysMap[input.Admin] == null, "New admin cannot be a candidate managing others.");
```

This ensures the separation invariant is enforced consistently across all admin assignment paths.

## Proof of Concept

```csharp
[Fact]
public async Task BypassCandidateAdminSeparationInvariant()
{
    // Step 1: Alice announces election for herself
    var aliceKeyPair = ValidationDataCenterKeyPairs[0];
    var aliceStub = GetElectionContractTester(aliceKeyPair);
    var aliceAddress = Address.FromPublicKey(aliceKeyPair.PublicKey);
    
    await aliceStub.AnnounceElection.SendAsync(aliceAddress);
    
    // Verify Alice is a candidate and manages herself
    var aliceManagedBefore = await ElectionContractStub.GetManagedPubkeys.CallAsync(aliceAddress);
    aliceManagedBefore.Value.Count.ShouldBe(1);
    
    // Step 2: Alice uses AnnounceElectionFor to manage another candidate (Bob)
    var bobKeyPair = ValidationDataCenterKeyPairs[1];
    
    await aliceStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = bobKeyPair.PublicKey.ToHex(),
        Admin = aliceAddress
    });
    
    // Verify the invariant is violated: Alice is both a candidate AND manages multiple candidates
    var aliceManagedAfter = await ElectionContractStub.GetManagedPubkeys.CallAsync(aliceAddress);
    aliceManagedAfter.Value.Count.ShouldBe(2); // Alice manages both herself and Bob
    
    // Verify Alice can exercise admin privileges over Bob (e.g., quit election)
    var quitResult = await aliceStub.QuitElection.SendAsync(new StringValue 
    { 
        Value = bobKeyPair.PublicKey.ToHex() 
    });
    quitResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

**Notes:**
- The invariant "Candidate cannot be others' admin" is explicitly enforced in `AnnounceElection` but not in alternative admin assignment paths
- This creates an exploitable inconsistency that allows centralization of candidate control
- The admin role grants significant economic and governance powers, making this bypass a high-severity issue
- The vulnerability is easily detectable on-chain but may not be noticed until exploited

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-73)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }

    /// <summary>
    ///     Admin address -> Pubkey
    /// </summary>
    public MappedState<Address, PubkeyList> ManagedCandidatePubkeysMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L102-102)
```csharp
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** protobuf/election_contract.proto (L36-39)
```text
    rpc AnnounceElection (aelf.Address) returns (google.protobuf.Empty) {
    }
    rpc AnnounceElectionFor (AnnounceElectionForInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L427-430)
```csharp
    public override PubkeyList GetManagedPubkeys(Address input)
    {
        return State.ManagedCandidatePubkeysMap[input];
    }
```
