# Audit Report

## Title
Insufficient Fee Protection for Unconfigured Methods in Genesis Contract

## Summary
The Genesis contract's `GetMethodFee` implementation returns null for unconfigured methods instead of default fees, causing the fee collection system to skip base method fees entirely. This allows expensive operations like `DeployUserSmartContract` to be executed with only minimal transaction size fees if governance fails to configure them, enabling economic DoS attacks through under-priced contract deployment proposals.

## Finding Description

The Genesis contract implements a dangerous default behavior for unconfigured method fees that diverges from other system contracts. When `GetMethodFee` is called for an unconfigured method, it returns null (or the value from state storage, which is null if not set). [1](#0-0) 

This null return propagates to the fee charging system in the MultiToken contract. When `methodFees` is null, the fee dictionary remains empty and base fee charging is skipped. [2](#0-1) 

The critical issue occurs in `ChargeTransactionFeesToBill` where base fees are only charged when the fee dictionary is non-empty. When `fee.Count == 0`, base fee charging is completely skipped. [3](#0-2) 

Only transaction size fees based on byte count are charged, which are significantly lower than method-specific base fees (typically 1-10 ELF). [4](#0-3) 

This affects expensive public operations like `DeployUserSmartContract`, which is callable by any user on mainnet without permission checks. On mainnet (where `Context.Variables.NativeSymbol == primaryTokenSymbol`), the method returns early without any permission checks, making it publicly accessible. [5](#0-4) 

This design contrasts sharply with other system contracts like Profit and Vote, which return default fees (1-10 ELF) for unconfigured methods. [6](#0-5) [7](#0-6) 

Test evidence shows fees are configured for `DeploySmartContract` but not for `DeployUserSmartContract`. [8](#0-7) 

While rate limiting exists per contract hash (72 hours), it doesn't prevent an attacker from proposing different contracts, as the rate limiting is based on the hash of the entire input. [9](#0-8) 

## Impact Explanation

**Economic Impact:**
- Users pay only transaction size fees (typically 0.01-0.1 ELF based on bytes) instead of base method fees (1-10 ELF)
- Contract deployments become 10-100x cheaper than intended
- Attackers can spam governance system with cheap proposals at minimal cost

**Operational Impact:**
- Economic DoS: Flood governance with numerous cheap contract deployment proposals
- Overwhelm code check proposal system requiring BPs to validate each submission
- Degrade network performance through under-priced state-changing operations
- Create unfair economic advantage for exploiters over legitimate users

**Affected Parties:**
- Network validators facing increased computational load without adequate compensation
- Governance system burdened with proposal queue spam
- Legitimate users who properly pay fees for other operations

The severity is MEDIUM because while it doesn't result in direct fund theft, it enables significant economic exploitation and operational DoS of the governance system through systematically under-priced operations.

## Likelihood Explanation

**Preconditions:**
- Governance must fail to explicitly configure fees for `DeployUserSmartContract` via `SetMethodFee`
- Method remains publicly accessible on mainnet (currently true)

**Attack Complexity: LOW**
- No special permissions required
- Direct method invocation
- Simple transaction construction

**Feasibility: MEDIUM-HIGH**
- Test evidence shows `DeployUserSmartContract` fees are not configured in test suites
- Genesis contract's lack of default fees (unlike Profit/Vote) makes oversight more likely
- User contract deployment is a relatively newer feature that may have been overlooked during initial fee configuration
- Once discovered, exploitation is trivial and repeatable

**Detection:**
- Monitoring can detect unusual spikes in contract deployment proposals
- Low fee collection relative to operation count would be observable
- However, detection cannot prevent initial exploitation

The likelihood is rated MEDIUM-HIGH because the precondition (unconfigured fees) is plausible given test evidence and design inconsistencies, and exploitation requires no special capabilities once the precondition is met.

## Recommendation

Implement default fees in the Genesis contract's `GetMethodFee` method, similar to Profit and Vote contracts:

1. Add a default case that returns reasonable base fees (e.g., 1-10 ELF) for unconfigured methods
2. Explicitly configure fees for `DeployUserSmartContract` through governance
3. Consider implementing per-user rate limiting in addition to per-hash limiting

The fix should modify `BasicContractZeroContract_ACS1_TransactionFeeProvider.cs` to include a default fee return similar to:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    var fees = State.TransactionFees[input.Value];
    if (fees != null) return fees;
    
    // Return default fees for unconfigured methods
    return new MethodFees
    {
        Fees = { new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 } }
    };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task DeployUserSmartContract_WithoutConfiguredFees_ChargesOnlySizeFee()
{
    // Verify DeployUserSmartContract has no configured fees
    var methodFee = await BasicContractZeroStub.GetMethodFee.CallAsync(new StringValue
    {
        Value = nameof(BasicContractZeroStub.DeployUserSmartContract)
    });
    methodFee.ShouldBeNull(); // Or empty fees
    
    // Get initial balance
    var initialBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultSender,
        Symbol = "ELF"
    });
    
    // Deploy user contract
    var code = ByteString.CopyFrom(File.ReadAllBytes(typeof(TestContract).Assembly.Location));
    await BasicContractZeroStub.DeployUserSmartContract.SendAsync(new UserContractDeploymentInput
    {
        Category = 0,
        Code = code
    });
    
    // Check final balance - should only be reduced by size fee (~0.01-0.1 ELF)
    var finalBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultSender,
        Symbol = "ELF"
    });
    
    var feePaid = initialBalance.Balance - finalBalance.Balance;
    feePaid.ShouldBeLessThan(1_00000000); // Less than 1 ELF (only size fee paid)
    // Expected: Should have paid base fee of 1-10 ELF plus size fee
}
```

## Notes

This vulnerability demonstrates a critical design inconsistency between the Genesis contract and other system contracts (Profit, Vote) in handling unconfigured method fees. The Genesis contract's decision to return null allows the fee charging system to skip base fees entirely, creating an economic vulnerability for governance-protected operations like contract deployment. The issue is particularly concerning for `DeployUserSmartContract`, which is publicly accessible on mainnet and creates proposals that require Block Producer validation, making it an effective vector for economic DoS attacks.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-47)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L278-283)
```csharp
        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L292-297)
```csharp
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-323)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var methodFees = State.TransactionFees[input.Value];
        if (methodFees != null) return methodFees;

        switch (input.Value)
        {
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var tokenAmounts = State.TransactionFees[input.Value];
        if (tokenAmounts != null) return tokenAmounts;

        switch (input.Value)
        {
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/TransactionFeeProviderTests.cs (L109-122)
```csharp
    [Fact]
    public async Task Genesis_FeeProvider_Test()
    {
        await ExecuteProposalForParliamentTransaction(ContractZeroAddress, MethodName, new MethodFees
        {
            MethodName = nameof(BasicContractZeroStub.DeploySmartContract),
            Fees = { TokenAmount }
        });
        var result = await BasicContractZeroStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = nameof(BasicContractZeroStub.DeploySmartContract)
        });
        result.Fees.First().ShouldBe(TokenAmount);
    }
```
