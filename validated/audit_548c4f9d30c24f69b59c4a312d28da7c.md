# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass via RecoverFromUpdateValue Timing Issue

## Summary
A critical validation bypass exists in the AEDPoS consensus mechanism where `RecoverFromUpdateValue` modifies the `baseRound` object before validation occurs, causing the `LibInformationValidationProvider` to compare a malicious `ImpliedIrreversibleBlockHeight` value against itself. This allows any miner to inject arbitrarily low implied LIB heights into consensus state, compromising blockchain finality guarantees.

## Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior, where the order of operations defeats the security check.

**The Flawed Execution Sequence:**

1. **Premature State Recovery**: When validating UpdateValue behavior, the `baseRound` is first fetched from persistent state storage [1](#0-0) , and then `RecoverFromUpdateValue` is immediately called on this `baseRound` object before any validation occurs [2](#0-1) 

2. **Value Corruption**: The recovery method directly mutates the `baseRound` by copying `ImpliedIrreversibleBlockHeight` from the attacker-provided round into the base round for the sender's pubkey [3](#0-2) 

3. **Ineffective Validation**: The `LibInformationValidationProvider` attempts to validate that the base round's `ImpliedIrreversibleBlockHeight` is not greater than the provided round's value [4](#0-3) . However, since the recovery has already copied the provided value into baseRound, this check becomes a tautology comparing the malicious value against itself (X > X, which is always false, allowing validation to pass).

4. **Unvalidated Persistence**: The malicious `ImpliedIrreversibleBlockHeight` from the attacker's input is then written directly to persistent state without effective validation [5](#0-4) 

**Attack Execution:**

A malicious miner can provide any arbitrarily low `ImpliedIrreversibleBlockHeight` value in their `UpdateValueInput` message. The validation that should enforce monotonic increase becomes ineffective due to the premature mutation of the reference point.

**Impact on LIB Calculation:**

The corrupted `ImpliedIrreversibleBlockHeight` values are subsequently used to calculate the Last Irreversible Block height. The calculation collects these values from miners who have produced blocks, sorts them, and selects the value at position `(count-1)/3` to ensure 2/3 consensus [6](#0-5) [7](#0-6) 

## Impact Explanation

**Severity: HIGH - Consensus Integrity Breach**

This vulnerability directly compromises the blockchain's finality mechanism. The `ImpliedIrreversibleBlockHeight` is a critical consensus parameter that determines which blocks are considered irreversible. By injecting fraudulently low values:

1. **Finality Degradation**: Malicious miners can prevent the LIB from advancing properly, leaving the chain in an uncertain state where blocks remain reversible longer than intended.

2. **2/3 Threshold Attack**: While a single miner's impact is limited by the 2/3 consensus mechanism, repeated attacks over multiple rounds or collusion among multiple miners can significantly lower the calculated LIB height.

3. **Cross-Chain Implications**: Systems relying on LIB heights for cross-chain operations or irreversible confirmations will be affected by the manipulated values.

4. **Security Guarantee Violation**: The fundamental security guarantee that `ImpliedIrreversibleBlockHeight` can only increase is violated, breaking a core consensus invariant.

## Likelihood Explanation

**Probability: HIGH - Trivially Exploitable**

**Attacker Profile:**
- Must be an elected miner (realistic in any DPoS system)
- No special privileges beyond normal mining rights required
- Can execute during their regular time slot

**Attack Complexity:**
- **LOW**: Simply requires providing a lower-than-legitimate value in the `implied_irreversible_block_height` field of `UpdateValueInput`
- The validation bypass is automatic due to the code flow - no timing windows or race conditions to exploit
- No sophisticated techniques required

**Detection Difficulty:**
- The malicious value appears legitimate to all validation logic
- No automatic detection mechanism exists in the current codebase
- Would only be noticed through manual state inspection or observing abnormal LIB progression patterns

**Operational Feasibility:**
- Occurs during normal UpdateValue behavior (every block production)
- No additional preconditions or setup required
- Fully within the capabilities of any standard mining node

## Recommendation

The fix requires reordering the validation flow to preserve the original state for comparison:

1. **Option 1 - Clone Before Recovery**: Create a deep copy of the baseRound before calling `RecoverFromUpdateValue`, then use the unmodified copy for validation while using the recovered version for subsequent processing.

2. **Option 2 - Validate Before Recovery**: Move the LIB validation logic to execute before the `RecoverFromUpdateValue` call, directly comparing the stored state against the provided round.

3. **Option 3 - Explicit Field Validation**: Extract and cache the original `ImpliedIrreversibleBlockHeight` value from baseRound before recovery, then perform validation using this cached value.

**Recommended Implementation (Option 2):**

In `AEDPoSContract_Validation.cs`, reorder the operations:

```csharp
// Validate BEFORE recovery
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,  // Original unmodified state
    // ... other fields
};

// Add validators including LibInformationValidationProvider
var service = new HeaderInformationValidationService(validationProviders);
var validationResult = service.ValidateInformation(validationContext);

if (!validationResult.Success)
    return validationResult;

// ONLY recover after successful validation
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

## Proof of Concept

This vulnerability can be demonstrated by having a miner submit an `UpdateValue` transaction with an `ImpliedIrreversibleBlockHeight` value lower than their previous value. The validation will pass despite violating the monotonic increase invariant, and the lower value will be persisted to state, subsequently affecting LIB calculations in the following rounds.

The test would:
1. Initialize consensus with a miner having `ImpliedIrreversibleBlockHeight = 100`
2. Submit UpdateValue with `ImpliedIrreversibleBlockHeight = 50`
3. Verify that validation passes (when it should fail)
4. Verify that state now contains the value 50
5. Verify that subsequent LIB calculations use the corrupted value

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-249)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-33)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
