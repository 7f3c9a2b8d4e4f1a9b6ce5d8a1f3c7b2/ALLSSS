# Audit Report

## Title
Vote Counting Inconsistency Allows Proposals to Pass with Insufficient Current Member Participation

## Summary
The Association contract contains a critical inconsistency in vote counting logic where `MinimalVoteThreshold` checks count votes from removed members, while `MinimalApprovalThreshold` checks correctly filter by current membership. This allows proposals to be released with artificially inflated participation metrics, undermining governance integrity.

## Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals` method where approval counts are filtered by current organization membership, but the total vote count is not. [1](#0-0) 

The approval threshold check correctly uses `.Count(organization.OrganizationMemberList.Contains)` to filter by current membership.

However, the minimal vote threshold check does not apply membership filtering: [2](#0-1) 

This counts ALL addresses in the proposal's vote lists without verifying current membership status.

In contrast, other threshold checks in the same file correctly filter by membership: [3](#0-2) [4](#0-3) 

**Root Cause:** When members vote, membership is verified at voting time: [5](#0-4) 

However, if members are subsequently removed via the `RemoveMember` function: [6](#0-5) 

Their addresses remain in the proposal's vote lists but are no longer in `organization.OrganizationMemberList`. At release time, the inconsistent filtering causes their votes to count toward `MinimalVoteThreshold` but not toward specific approval/rejection/abstention thresholds.

The proposal release process invokes this flawed logic: [7](#0-6) 

## Impact Explanation

This vulnerability directly violates governance invariants by allowing proposals to execute without the intended level of current member participation:

**Attack Scenario:**
- Organization with 10 current members
- Thresholds: `MinimalVoteThreshold = 9`, `MinimalApprovalThreshold = 5`
- Attacker obtains 5 approvals from current members (satisfies filtered approval check)
- Attacker obtains 4 additional votes from other members
- Attacker removes those 4 voters via a separate proposal
- Original proposal releases with 9 total votes (unfiltered) despite only 5/10 (50%) current member participation

**Consequences:**
- `MinimalVoteThreshold` parameter becomes meaningless as it accepts non-member votes
- Organizations lose ability to enforce minimum current member participation
- Governance decisions executed without democratic mandate
- All Association-based governance in the AElf ecosystem affected

## Likelihood Explanation

**Attack Complexity:** Medium
- Requires coordinating member removal timing with proposal release
- Uses only standard, legitimate contract methods
- No special privileges required beyond normal governance participation

**Feasibility:**
- Organizations commonly use `MinimalVoteThreshold` for participation requirements
- Time gap between voting and release allows member removal (normal operation)
- Member removal is legitimate governance action that cannot be blocked
- No warnings or checks detect counting of non-member votes

**Probability:** High in adversarial scenarios where attackers have minority governance control or during governance disputes, as the attack exploits intended functionality without triggering protections.

## Recommendation

Modify the `CheckEnoughVoteAndApprovals` method to filter the total vote count by current membership, consistent with other threshold checks:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership
    var totalCurrentMemberVotes = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalCurrentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteCountingInconsistency_RemovedMembersVotesStillCountTowardMinimalVoteThreshold()
{
    // Setup: Create organization with 10 members
    var members = Accounts.Take(10).Select(a => a.Address).ToList();
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { members }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5,  // Need 5 approvals
            MinimalVoteThreshold = 9,       // Need 9 total votes (90% participation)
            MaximalAbstentionThreshold = 10,
            MaximalRejectionThreshold = 10
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { members[0] }
        }
    };
    var orgAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    var organizationAddress = orgAddress.Output;

    // Step 1: Create proposal P1
    var proposalId = await CreateProposalAsync(organizationAddress, members[0]);

    // Step 2: Get 5 approvals from members 0-4
    for (int i = 0; i < 5; i++)
    {
        var stub = GetAssociationContractTester(Accounts[i].KeyPair);
        await stub.Approve.SendAsync(proposalId);
    }

    // Step 3: Get 4 rejections from members 5-8
    for (int i = 5; i < 9; i++)
    {
        var stub = GetAssociationContractTester(Accounts[i].KeyPair);
        await stub.Reject.SendAsync(proposalId);
    }

    // At this point: 5 approvals + 4 rejections = 9 votes total

    // Step 4: Remove members 5-8 via governance proposal
    for (int i = 5; i < 9; i++)
    {
        var removalProposal = await CreateRemoveMemberProposalAsync(organizationAddress, members[i]);
        // Approve and release removal proposal...
        await ExecuteRemovalProposal(removalProposal, organizationAddress);
    }

    // Step 5: Try to release P1
    // BUG: This succeeds despite only 5/6 current members voting (83% not 90%)
    // because removed members' votes still count toward MinimalVoteThreshold
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId);
    
    // VULNERABILITY: Proposal releases successfully
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Expected: Should fail because only 5 current members voted (5/6 = 83% < 90%)
    // Actual: Succeeds because 9 total votes counted (including 4 removed members)
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
