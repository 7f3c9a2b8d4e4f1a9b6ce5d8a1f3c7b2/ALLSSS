# Audit Report

## Title
Unvalidated Secret Sharing Reveals Allow Consensus State Corruption and Mining Order Manipulation

## Summary
The AEDPoS consensus contract accepts revealed InValues from trigger information without cryptographic verification, allowing malicious miners to inject arbitrary `PreviousInValue` data for other miners. This corrupts consensus state, manipulates mining order calculations, and pollutes the signature aggregation mechanism.

## Finding Description

The vulnerability exists in the secret sharing revelation mechanism where revealed InValues for other miners are accepted without validation. The `UpdateLatestSecretPieces()` function only checks if a miner's `PreviousInValue` is currently empty or null, but performs no cryptographic verification: [1](#0-0) 

These revealed values originate from the miner's local node and are included in trigger information that flows into the contract. A malicious miner can modify their local `SecretSharingService` to return arbitrary fake values, which then get persisted to on-chain state via `PerformSecretSharing()`: [2](#0-1) 

In contrast, the legitimate `RevealSharedInValues()` function performs proper cryptographic reconstruction using Shamir's Secret Sharing with threshold validation: [3](#0-2) 

The `UpdateValueValidationProvider` only validates the sender's own `PreviousInValue`, not the revealed values for other miners: [4](#0-3) 

When a victim miner fails to produce a block and the round transitions via `NextRound`, the `SupplyCurrentRoundInformation()` function uses the corrupted `PreviousInValue` to calculate their signature: [5](#0-4) 

This fake signature then determines the victim's mining order in the next round through signature-to-order conversion: [6](#0-5) 

Furthermore, signature calculation aggregates all miners' signatures via XOR operations, meaning fake signatures pollute future calculations: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation**: The attack directly corrupts on-chain consensus state by setting incorrect `PreviousInValue` and `Signature` fields for victim miners. This violates the fundamental consensus invariant that each miner's signature must be cryptographically derived from their genuine InValue.

**Mining Order Manipulation**: The corrupted signature determines the victim's `SupposedOrderOfNextRound`, directly controlling when they can produce blocks in subsequent rounds. An attacker can systematically target specific miners to alter the mining schedule, potentially gaining unfair advantages.

**Signature Chain Pollution**: Since signatures are aggregated via XOR operations when calculating new signatures, injecting fake signatures pollutes this cryptographic chain, propagating corruption forward through multiple rounds.

**State Pollution Persistence**: Once a fake `PreviousInValue` is set, the victim cannot correct it until they successfully produce a block with their real value, causing incorrect derived values to persist through multiple rounds.

## Likelihood Explanation

**Attacker Profile**: Any authorized miner in the consensus pool can execute this attack by modifying their local node software to return fake values in `GetRevealedInValues()`.

**Attack Complexity**: Low - the attacker simply modifies their `SecretSharingService` implementation to return arbitrary values. No complex cryptographic operations or precise timing requirements are needed.

**Preconditions Met Naturally**: The attack requires the victim to miss their time slot (common in distributed networks due to connectivity issues or load) and the attacker to produce a block before the victim (feasible given mining order rotation).

**Detection Difficulty**: The attack is difficult to detect because no on-chain validation flags fake revealed values, and corrupted state appears as legitimate consensus data.

**Economic Feasibility**: The attack cost is minimalâ€”only the gas cost of producing a normal block. Given that missed time slots occur regularly in distributed networks, attack opportunities are frequent.

## Recommendation

Implement cryptographic verification for revealed InValues in `UpdateLatestSecretPieces()` similar to `RevealSharedInValues()`. The fix should:

1. Verify that sufficient encrypted and decrypted pieces exist (minimum threshold)
2. Perform Shamir's Secret Sharing reconstruction using `SecretSharingHelper.DecodeSecret()`
3. Validate the reconstructed value matches the hash of the revealed InValue
4. Only accept revealed values that pass cryptographic verification

Alternatively, remove the revealed values from trigger information entirely and rely only on on-chain cryptographic reconstruction via `RevealSharedInValues()` during `NextRound` transitions.

## Proof of Concept

A malicious miner can execute the attack as follows:

1. Modify `SecretSharingService.GetRevealedInValues()` to return fake values: `{victimPubkey: fakeHash}`
2. Wait for victim to miss their time slot
3. Produce an `UpdateValue` block - the fake revealed value flows through trigger information
4. Contract accepts it via `UpdateLatestSecretPieces` without validation
5. Fake value is persisted via `PerformSecretSharing`
6. When `NextRound` is called, `SupplyCurrentRoundInformation` uses the fake value
7. Victim's signature is calculated from fake `PreviousInValue`, determining wrong mining order
8. Fake signature pollutes XOR aggregation affecting all future signature calculations

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-52)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
