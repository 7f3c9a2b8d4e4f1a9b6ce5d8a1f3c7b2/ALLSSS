# Audit Report

## Title
Last Irreversible Block (LIB) Advancement Halts in Two-Miner Networks With Single Round Participation Gap

## Summary
In a 2-miner AEDPoS network, the LIB calculation mechanism requires both miners to have participated in two consecutive rounds for finality to advance. If either miner misses a single round, the LIB calculator fails its consensus threshold check and returns zero, preventing irreversible block height advancement until two consecutive rounds of full participation occur.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates LIB height based on a cross-round consensus requirement. [1](#0-0) 

The core issue stems from the filtering logic that requires miners to have participated in BOTH the current and previous rounds. The method first retrieves miners who mined in the current round, then uses their pubkeys to filter implied irreversible heights from the previous round. [2](#0-1) 

For a 2-miner network, `MinersCountOfConsent` is calculated as `(2 * 2 / 3) + 1 = 2`, requiring both miners. [3](#0-2) 

The `GetMinedMiners()` method returns only miners where `SupposedOrderOfNextRound != 0`, which is set during normal consensus data processing. [4](#0-3) 

Miners who miss their time slot will not have this field set, as it is only assigned when a miner successfully produces a block and applies consensus data. [5](#0-4) 

When the consensus threshold check fails, `libHeight = 0` is returned and no `IrreversibleBlockFound` event is fired. [6](#0-5) 

**Concrete Scenario:**
- Round N: Miners A and B both mine successfully
- Round N+1: Only Miner A mines (B misses the round)
- Round N+2: Both miners A and B mine
- During Round N+2 LIB calculation: `GetMinedMiners()` returns [A, B], but `GetSortedImpliedIrreversibleBlockHeights([A, B])` on Round N+1 only finds A's data (since B didn't mine in N+1), returning 1 height
- Check: 1 < 2 fails, `libHeight = 0`

The contract allows 2-miner configurations without validation during initialization. [7](#0-6) [8](#0-7) 

## Impact Explanation

**Operational Impact:**
- **Finality Halted**: LIB advancement stops until two consecutive rounds of 100% miner participation occur
- **Cross-Chain Operations Affected**: Cross-chain mechanisms relying on LIB for merkle path validation and synchronization are blocked, as the system processes `NewIrreversibleBlockFoundEvent` to update cross-chain data
- **State Pruning Disabled**: Node state cleanup operations depending on LIB advancement cannot proceed
- **Self-Recovering But Fragile**: System recovers after sustained participation, but any intermittent issues cause repeated failures

**Severity: Medium**

The chain continues producing blocks (safety preserved), but the complete halt of finality advancement represents a liveness failure affecting transaction irreversibility guarantees and dependent systems. While self-recovering, the requirement for sustained 100% participation in 2-miner networks creates operational fragility.

## Likelihood Explanation

**In 2-Miner Networks: High**
- No minimum miner count validation prevents this configuration
- Any operational issue (network delays, maintenance, hardware failures) triggers the condition
- No attacker requiredâ€”normal operational events cause it
- Recovery requires multiple consecutive rounds of perfect participation

**In Production Networks: Low to Medium**

The protocol defines `SupposedMinersCount = 17`, suggesting production deployments should use more miners. [9](#0-8) 

However, this is not enforced as a minimum requirement during initialization, leaving 2-miner networks as a valid but fragile configuration primarily suited for testing environments.

## Recommendation

**1. Enforce Minimum Miner Count During Initialization**

Add validation in the `FirstRound` method to reject configurations with insufficient miners:

```csharp
public override Empty FirstRound(Round input)
{
    Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");
    
    // Add minimum miner count validation
    const int minimumMinersCount = 3;
    Assert(input.RealTimeMinersInformation.Count >= minimumMinersCount, 
        $"Insufficient miners. Minimum required: {minimumMinersCount}");
    
    // ... rest of initialization
}
```

**2. Adjust LIB Calculation for Small Networks**

Modify the threshold calculation to handle edge cases:

```csharp
public void Deconstruct(out long libHeight)
{
    if (_currentRound.IsEmpty || _previousRound.IsEmpty) 
    {
        libHeight = 0;
        return;
    }

    var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
    
    // Adjust threshold for small networks or use alternative calculation
    var requiredCount = Math.Max(1, _currentRound.MinersCountOfConsent);
    
    if (impliedIrreversibleHeights.Count < requiredCount)
    {
        libHeight = 0;
        return;
    }

    libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
}
```

**3. Document Configuration Requirements**

Add clear documentation that 2-miner configurations are not suitable for production use and should only be used for testing with the understanding that missed blocks will halt finality.

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Halts_With_Single_Missed_Round_In_TwoMiner_Network()
{
    // Setup: Initialize a 2-miner network
    var minerA = SampleKeyPairs[0];
    var minerB = SampleKeyPairs[1];
    
    // Round N: Both miners participate
    await ProduceBlockAsync(minerA);
    await ProduceBlockAsync(minerB);
    var libAfterRoundN = await GetCurrentLIBHeightAsync();
    
    // Round N+1: Only miner A participates (B misses)
    await ProduceBlockAsync(minerA);
    // Miner B does not produce a block
    
    // Round N+2: Both miners participate again
    await ProduceBlockAsync(minerA);
    await ProduceBlockAsync(minerB);
    
    // Verify: LIB should have advanced but doesn't
    var libAfterRoundN2 = await GetCurrentLIBHeightAsync();
    
    // Expected: LIB = 0 (halted) because miner B missed Round N+1
    libAfterRoundN2.ShouldBe(0);
    
    // Verify: Only after another complete round does LIB advance
    await ProduceBlockAsync(minerA);
    await ProduceBlockAsync(minerB);
    var libAfterRoundN3 = await GetCurrentLIBHeightAsync();
    libAfterRoundN3.ShouldBeGreaterThan(0);
}
```

## Notes

This vulnerability represents a legitimate operational concern in small-miner deployments. While the chain maintains safety (blocks continue to be produced), the liveness property for finality is compromised. The self-recovering nature prevents permanent failure, but the fragility makes 2-miner configurations unsuitable for production use where reliability of finality is critical for cross-chain operations and state management.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-282)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
