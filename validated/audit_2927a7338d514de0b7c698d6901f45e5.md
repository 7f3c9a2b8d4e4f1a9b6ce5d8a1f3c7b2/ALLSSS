# Audit Report

## Title
Case-Insensitive Token Uniqueness Check Bypassed in Cross-Chain Token Creation

## Summary
The `CrossChainCreateToken` function performs only a case-sensitive token existence check, while the normal `Create` flow enforces case-insensitive uniqueness. This inconsistency allows tokens with symbols differing only in case (e.g., "ABC" and "abc") to coexist on the same chain, causing balance fragmentation, operational confusion, and SymbolSeedMap conflicts.

## Finding Description

**Root Cause - Case-Sensitive vs Case-Insensitive Checks:**

The normal token creation flow calls `CheckTokenExists`, which enforces case-insensitive uniqueness by checking both `State.TokenInfos[symbol]` (case-sensitive) and `State.InsensitiveTokenExisting[symbol.ToUpper()]` (case-insensitive). [1](#0-0)  This validation is called during normal token creation. [2](#0-1) 

When a token is registered via `RegisterTokenInfo`, both the case-sensitive `TokenInfos` map and the case-insensitive `InsensitiveTokenExisting` tracking state are updated. [3](#0-2) 

However, `CrossChainCreateToken` only checks `State.TokenInfos[tokenInfo.Symbol] == null`, which is case-sensitive, completely bypassing the case-insensitive validation enforced in the normal flow. [4](#0-3) 

**Storage Implementation:**

All token-related state maps use the exact symbol string as the key without normalization. The state definitions show `MappedState<string, TokenInfo> TokenInfos` and `MappedState<Address, string, long> Balances`. [5](#0-4) 

This means "ABC" and "abc" are stored as completely separate keys, maintaining distinct balances and token information.

**SymbolSeedMap Conflict:**

The SymbolSeedMap consistently uses `.ToUpper()` for both writes and reads. During SEED NFT creation, it stores mappings using `State.SymbolSeedMap[ownedSymbol.ToUpper()]`. [6](#0-5)  When checking for existing SEED NFTs, it reads using the same normalization. [7](#0-6)  During normal token creation, SEED NFT validation also uses uppercase normalization. [8](#0-7) 

If both "ABC" and "abc" tokens exist, they conflict when used in SEED NFT operations since both normalize to the same uppercase key "ABC".

## Impact Explanation

**Critical Protocol Invariant Violated:**

The protocol's fundamental assumption that token symbols are case-insensitively unique is broken. The existence of the `InsensitiveTokenExisting` state variable demonstrates this design intent. [9](#0-8) 

This creates multiple concrete harms:

1. **Balance Fragmentation**: User balances are split across case variants (e.g., `State.Balances[user]["ABC"]` vs `State.Balances[user]["abc"]`), making total holdings opaque and potentially causing funds to appear "lost" to users and contracts expecting consolidated balances.

2. **SymbolSeedMap Corruption**: When both "ABC" and "abc" are used in NFT creation flows, they share the same `SymbolSeedMap["ABC"]` entry, causing one to overwrite the other's SEED mapping. This breaks the one-time-use SEED NFT enforcement and could allow unauthorized token creation or prevent legitimate token creation.

3. **Cross-Chain State Divergence**: Parent and child chains can have different token uniqueness states - parent chain with "ABC" only, child chain with both "ABC" and "abc" - violating cross-chain consistency guarantees.

4. **Contract Integration Failures**: Smart contracts and dApps assuming case-insensitive symbol resolution will interact with incorrect token variants, causing failed transactions, misrouted funds, and broken allowances.

**Severity: Medium** - No direct fund theft, but significant operational disruption, state integrity violation, and potential for user fund confusion. The vulnerability requires cross-chain conditions but has measurable impact on token accounting and NFT creation mechanisms.

## Likelihood Explanation

**Feasibility: Medium**

**Preconditions:**
1. Token with specific casing exists on child chain (e.g., "abc" created via normal `Create`)
2. Token with different casing exists on parent chain (e.g., "ABC")
3. Cross-chain registration initiated from parent to child

**Execution Path:**
1. Parent chain has token "ABC" (created normally with case-insensitive check)
2. Attacker creates token "abc" on child chain via normal `Create` flow (passes case-insensitive check since "ABC" doesn't exist on child yet)
3. User initiates legitimate cross-chain registration from parent to child
4. `CrossChainCreateToken` checks `State.TokenInfos["ABC"] == null` - passes (only "abc" exists)
5. `RegisterTokenInfo` called for "ABC"
6. Both "ABC" and "abc" now coexist on child chain

**Accessibility:**

`CrossChainCreateToken` is a public method callable by anyone with valid cross-chain merkle proof. [10](#0-9) 

**Complexity:** Medium - requires cross-chain operation setup but no privileged access. Attacker only needs to time token creation on child chain before cross-chain sync occurs, which is a race condition in normal protocol operations.

**Detection:** Low - duplicate tokens are visible in contract state but require explicit case-sensitive queries to detect. Most UIs and explorers would normalize symbols, masking the issue.

## Recommendation

Add case-insensitive validation to `CrossChainCreateToken` by calling `CheckTokenExists` before registering the token:

```csharp
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    CheckTokenExists(tokenInfo.Symbol);  // Add this line
    RegisterTokenInfo(tokenInfo);
    // ... rest of the code
}
```

This ensures consistent validation across all token creation paths and maintains the protocol's case-insensitive uniqueness invariant.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task CrossChainCreateToken_CaseInsensitivity_Bypass()
{
    // Setup: Create token "abc" on child chain
    var childTokenStub = GetTokenContractTester(ChildChainId);
    await childTokenStub.Create.SendAsync(new CreateInput
    {
        Symbol = "abc",
        TokenName = "Test Token Lower",
        TotalSupply = 1000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true
    });
    
    // Verify "abc" exists and "ABC" doesn't
    var abcInfo = await childTokenStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "abc" });
    Assert.NotNull(abcInfo.Symbol);
    
    // Setup: Create token "ABC" on parent chain
    var parentTokenStub = GetTokenContractTester(ParentChainId);
    await parentTokenStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ABC",
        TokenName = "Test Token Upper",
        TotalSupply = 2000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true
    });
    
    // Cross-chain sync "ABC" from parent to child
    await RegisterAndValidateTokenInfoOnChildChain(parentTokenStub, "ABC");
    
    // Vulnerability: Both "abc" and "ABC" now exist on child chain
    var ABCInfo = await childTokenStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ABC" });
    Assert.NotNull(ABCInfo.Symbol); // "ABC" exists
    
    var abcInfoAfter = await childTokenStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "abc" });
    Assert.NotNull(abcInfoAfter.Symbol); // "abc" still exists
    
    // Both tokens coexist, violating case-insensitive uniqueness invariant
}
```

## Notes

This vulnerability represents a fundamental inconsistency in validation logic between normal and cross-chain token creation paths. The protocol clearly intends case-insensitive uniqueness (evidenced by the `InsensitiveTokenExisting` state and `CheckTokenExists` method), but `CrossChainCreateToken` bypasses this critical check. The impact extends beyond simple state inconsistency to concrete operational failures in balance tracking and SEED NFT management.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L59-59)
```csharp
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-87)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-478)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L16-19)
```csharp
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
    public MappedState<string, string> SymbolSeedMap { get; set; }
    public MappedState<Address, string, long> Balances { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L51-51)
```csharp
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L59-59)
```csharp
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];
```
