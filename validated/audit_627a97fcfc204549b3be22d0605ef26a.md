# Audit Report

## Title
Pending Proposals from Removed Proposers Can Still Be Executed After Whitelist Changes

## Summary
The governance contracts (Parliament, Association, and Referendum) validate proposer authorization only at proposal creation time. When a proposer is removed from the whitelist via `ChangeOrganizationProposerWhiteList()`, their pending proposals remain executable because the `Release()` function does not re-validate authorization status, allowing removed proposers to execute previously created proposals and undermining the whitelist security model.

## Finding Description

The vulnerability exists across all three governance contract implementations and breaks the fundamental security guarantee that whitelist removal revokes all proposal privileges.

**Authorization at Creation Time:**

In Parliament, proposal creation validates proposer authorization through `AssertIsAuthorizedProposer`, which checks if the proposer is in the whitelist or is a parliament member: [1](#0-0) [2](#0-1) 

The same pattern exists in Association: [3](#0-2) [4](#0-3) 

And in Referendum: [5](#0-4) [6](#0-5) 

**No Re-validation at Release Time:**

When releasing a proposal in Parliament, the function only verifies that the caller is the original proposer without re-validating their current authorization status: [7](#0-6) 

Association has the same flaw: [8](#0-7) 

As does Referendum: [9](#0-8) 

**Whitelist Updates Don't Invalidate Pending Proposals:**

The `ChangeOrganizationProposerWhiteList` function updates the whitelist without any validation or cleanup of pending proposals from removed addresses: [10](#0-9) [11](#0-10) [12](#0-11) 

**Attack Sequence:**
1. Attacker (legitimate proposer) creates proposal with far-future expiration
2. Malicious behavior is detected, governance removes them from whitelist  
3. Removed proposer cannot create NEW proposals (correctly blocked by authorization check)
4. However, their OLD proposal continues to collect votes
5. Once vote threshold is reached, removed proposer calls `Release()` successfully
6. The proposal executes despite proposer no longer being authorized

The only mechanism to remove proposals is `ClearProposal`, which requires the proposal to be expired: [13](#0-12) 

This provides no defense against approved proposals from removed proposers.

## Impact Explanation

**High Severity - Governance Authorization Bypass**

This vulnerability directly undermines the core security model of AElf's governance system. The whitelist mechanism exists specifically to control who can propose and execute governance actions. When an address is removed from the whitelist—typically due to discovered malicious behavior, compromised private keys, or loss of trust—the expectation is that ALL their governance privileges are immediately revoked.

However, removed proposers retain the ability to execute any proposals they created while authorized. Depending on the proposal's content, this could enable:
- Unauthorized system configuration changes
- Fund transfers or treasury manipulation  
- Contract upgrades or deployments
- Changes to consensus parameters
- Modification of fee structures

The impact extends across all organizations using these three core governance contracts:
- **Parliament**: Controls critical system governance including the default organization that manages protocol-level decisions
- **Association**: Used for multi-signature governance in organizational settings
- **Referendum**: Enables token-weighted voting for community governance

A single compromised or malicious proposer can "time-bomb" the system by creating benign-looking proposals before their removal, then executing them later to bypass the whitelist protection.

## Likelihood Explanation

**Medium-High Likelihood**

The attack has low complexity and realistic preconditions:

**Attacker Profile:**
- Must initially be a legitimate authorized proposer (in whitelist or parliament member)
- Could be an insider threat or a compromised authorized address  
- No special permissions required beyond normal proposal flow

**Attack Feasibility:**
- Zero cost to maintain pending proposals
- Proposals can have far-future expiration times
- No blockchain state manipulation required
- Standard transaction flow using public methods

**Economic Rationality:**
Highly rational for a malicious actor. Once they suspect they might be removed (or after committing malicious acts), they can pre-emptively create proposals that will execute after their removal. The attack has zero ongoing cost and cannot be easily detected until execution.

**Detection Difficulty:**
The pending proposal appears completely legitimate in the system. Governance would need to manually track all pending proposals and cross-reference them against whitelist changes to identify this threat proactively.

## Recommendation

Add proposer authorization re-validation in the `Release()` method for all three governance contracts. The fix should call `AssertIsAuthorizedProposer` before executing the proposal:

```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    
    // Re-validate proposer authorization
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, proposalInfo.Proposer);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of execution logic
}
```

This ensures that proposer authorization is checked both at proposal creation AND at execution time, preventing removed proposers from executing their old proposals.

Alternatively, implement a proposal invalidation mechanism when proposers are removed from whitelists, or allow organizations to explicitly cancel approved proposals.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_CanStillReleaseOldProposal()
{
    // Setup: Create organization with proposer in whitelist
    var proposer = Accounts[1].Address;
    var organization = await CreateOrganizationWithProposerWhitelist(new[] { proposer });
    
    // Proposer creates a proposal
    var proposalId = await CreateProposalAsProposer(organization, proposer);
    
    // Organization members approve the proposal
    await ApproveProposal(proposalId);
    
    // Governance removes proposer from whitelist
    await RemoveProposerFromWhitelist(organization, proposer);
    
    // Verify: Proposer cannot create NEW proposals (authorization check works)
    var createNewResult = await CreateProposalAsProposer(organization, proposer);
    createNewResult.Should().Fail().WithMessage("Unauthorized to propose");
    
    // Vulnerability: Removed proposer CAN still release their OLD approved proposal
    var releaseResult = await ReleaseProposalAsProposer(proposalId, proposer);
    releaseResult.Should().Succeed(); // This should fail but doesn't!
    
    // The proposal executes despite proposer being removed from whitelist
    VerifyProposalExecuted(proposalId);
}
```

## Notes

This vulnerability affects all three core governance contracts identically. The authorization model assumes that once a proposal is created legitimately and reaches approval threshold, the proposer's ongoing authorization status is irrelevant. However, this breaks the security expectation that whitelist removal immediately revokes all governance privileges, leaving organizations vulnerable to "time bomb" proposals from removed proposers with no available mitigation mechanism other than waiting for proposal expiration.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```
