# Audit Report

## Title
Incomplete Evil Miner Replacement Due to Insufficient Alternative Candidates

## Summary
The AEDPoS consensus contract contains a critical logic flaw in its miner replacement mechanism where the replacement loop only processes as many replacements as there are alternative candidates available, not the total count of evil miners requiring replacement. When the Election contract returns fewer alternatives than evil miners, the unreplaced evil miners persist in subsequent consensus rounds, degrading network liveness and block production capacity.

## Finding Description

The vulnerability exists in the interaction between the Election and Consensus contracts during mid-term evil miner replacement within the same term.

**Evil Miner Detection**: The system identifies evil miners as those who have missed at least 4320 time slots (representing 3 days at 1 time slot per minute). [1](#0-0) 

The detection mechanism checks if miners have exceeded this threshold. [2](#0-1) 

**Replacement Candidate Selection**: The Election contract's `GetMinerReplacementInformation` method attempts to source replacement candidates from election snapshot candidates (excluding initial and current miners) and uses initial miners as fallback when needed. [3](#0-2) 

The function returns `MinerReplacementInformation` containing two lists: `EvilMinerPubkeys` (all banned miners) and `AlternativeCandidatePubkeys` (available replacements). Critically, these lists can have different counts when the candidate pool is exhausted.

**The Core Vulnerability**: In the consensus contract's `GenerateNextRoundInformation` method, the replacement loop only iterates for `AlternativeCandidatePubkeys.Count` iterations, not `EvilMinerPubkeys.Count`. [4](#0-3) 

When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, only the first N evil miners (where N equals the alternative count) are removed from `currentRound.RealTimeMinersInformation`. The remaining evil miners at higher indices persist in the dictionary.

These unreplaced evil miners are then carried forward to the next round because `Round.GenerateNextRoundInformation` copies all miners from the current round's `RealTimeMinersInformation` dictionary to build the next round. [5](#0-4) 

This violates the consensus invariant that all scheduled miners must be capable of producing blocks.

## Impact Explanation

**Consensus Integrity Degradation**: Unreplaced evil miners remain in the active miner schedule but cannot produce blocks. In a typical 21-miner AEDPoS network, if 10 miners become evil but only 3 get replaced, 7 unreliable miners occupy consensus slots. This represents approximately 33% reduction in effective block production capacity, causing:
- Increased block times as the network waits for evil miners who won't respond
- Potential consensus stalls if too many time slots are wasted consecutively
- Degraded transaction throughput affecting all network users

**Network Liveness Risk**: With sufficient unreplaced evil miners, the network may struggle to meet the Byzantine fault tolerance threshold needed for block finalization. This creates an operational denial-of-service condition where the blockchain cannot reliably process transactions or advance state.

**Affected Parties**: All network participants including validators, end users, dApps, treasury operations, profit distributions, and cross-chain indexing mechanisms that depend on stable consensus.

**Severity Assessment**: HIGH - This directly compromises the core consensus mechanism's integrity. While no funds are immediately stolen, the network's fundamental ability to function is severely impaired, potentially leading to complete service disruption.

## Likelihood Explanation

**Trigger Conditions**: The vulnerability activates under realistic network stress scenarios:
1. Multiple miners simultaneously fail or go offline for 3+ days due to infrastructure outages, coordinated attacks, or natural disasters
2. The election candidate pool becomes depleted because most eligible candidates are already serving as active miners or have been previously banned
3. The initial miner fallback list is exhausted or overlaps with current/banned miners

**Feasibility**: MEDIUM-HIGH probability because:
- The condition occurs automatically without requiring attacker privileges or special actions
- Mature blockchain networks naturally develop stable miner sets over time, reducing the available candidate pool
- Infrastructure failures affecting multiple data centers can cause simultaneous miner outages
- An adversary could accelerate the condition through sustained attacks against active miners, though this is not necessary for the vulnerability to manifest

**Detection Difficulty**: The degradation is observable through network monitoring but may not trigger immediate alarms since the network continues operating at reduced capacity rather than failing completely. This subtle degradation can persist unnoticed until it reaches critical thresholds that impact user experience.

## Recommendation

Modify the replacement loop to ensure all evil miners are handled, even when insufficient alternatives are available:

```csharp
// In GenerateNextRoundInformation method
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
{
    var replacementCount = Math.Min(
        minerReplacementInformation.AlternativeCandidatePubkeys.Count,
        minerReplacementInformation.EvilMinerPubkeys.Count
    );
    
    // Replace evil miners with available alternatives
    for (var i = 0; i < replacementCount; i++)
    {
        var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
        var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
        
        // ... existing replacement logic ...
        
        currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
        currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
    }
    
    // Remove remaining evil miners that couldn't be replaced
    for (var i = replacementCount; i < minerReplacementInformation.EvilMinerPubkeys.Count; i++)
    {
        var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
        UpdateCandidateInformation(evilMinerPubkey,
            currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
            currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);
        currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
    }
    
    isMinerListChanged = true;
}
```

Alternatively, force a term change when evil miners cannot be replaced, triggering a complete miner list refresh through the election process.

## Proof of Concept

```csharp
[Fact]
public void Test_IncompleteEvilMinerReplacement()
{
    // Setup: Create a consensus round with 10 evil miners
    var currentRound = new Round
    {
        RoundNumber = 100,
        TermNumber = 5,
        RealTimeMinersInformation = new Dictionary<string, MinerInRound>()
    };
    
    // Add 10 evil miners
    for (int i = 0; i < 10; i++)
    {
        var evilMiner = $"evil_miner_{i}";
        currentRound.RealTimeMinersInformation[evilMiner] = new MinerInRound
        {
            Pubkey = evilMiner,
            MissedTimeSlots = 5000, // Exceeds 4320 threshold
            Order = i + 1
        };
    }
    
    // Mock Election contract to return only 3 alternatives for 10 evil miners
    var minerReplacementInfo = new MinerReplacementInformation();
    for (int i = 0; i < 10; i++)
    {
        minerReplacementInfo.EvilMinerPubkeys.Add($"evil_miner_{i}");
    }
    for (int i = 0; i < 3; i++) // Only 3 alternatives
    {
        minerReplacementInfo.AlternativeCandidatePubkeys.Add($"replacement_{i}");
    }
    
    // Execute the vulnerable replacement loop logic
    for (var i = 0; i < minerReplacementInfo.AlternativeCandidatePubkeys.Count; i++)
    {
        var alternativeCandidatePubkey = minerReplacementInfo.AlternativeCandidatePubkeys[i];
        var evilMinerPubkey = minerReplacementInfo.EvilMinerPubkeys[i];
        
        currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
        currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, new MinerInRound
        {
            Pubkey = alternativeCandidatePubkey,
            Order = i + 1
        });
    }
    
    // Verify: 7 evil miners remain unreplaced
    var remainingEvilMiners = currentRound.RealTimeMinersInformation.Keys
        .Where(k => k.StartsWith("evil_miner_"))
        .ToList();
    
    Assert.Equal(7, remainingEvilMiners.Count); // VULNERABILITY: 7 evil miners still in consensus
    Assert.Contains("evil_miner_3", remainingEvilMiners);
    Assert.Contains("evil_miner_9", remainingEvilMiners);
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Silent Degradation**: The network continues functioning but at reduced capacity, making the issue less obvious than a complete failure.

2. **Compounding Effect**: Once evil miners accumulate in the active set, they continue missing time slots in subsequent rounds, further degrading performance.

3. **No Automatic Recovery**: Without manual intervention or a term change, unreplaced evil miners persist indefinitely in the consensus schedule.

4. **Realistic Trigger**: The scenario of depleted candidate pools is not theoretical - mature networks with stable validator sets naturally face this constraint.

The fix requires either: (a) ensuring all evil miners are removed even without replacements, accepting temporarily reduced miner count, or (b) triggering an emergency term change to force complete miner list refresh through election.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```
