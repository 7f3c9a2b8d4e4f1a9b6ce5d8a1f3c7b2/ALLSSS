# Audit Report

## Title
Unvalidated Cross-Miner Secret Sharing Pollution in AEDPoS Consensus

## Summary
A malicious miner can inject arbitrary `DecryptedPieces` and `MinersPreviousInValues` for all other miners through the `UpdateValue` transaction without cryptographic or authorization validation. This corrupts the secret sharing reconstruction process used for consensus randomness and mining order determination, enabling consensus manipulation across the entire round.

## Finding Description

The AEDPoS consensus contract accepts `UpdateValueInput` containing `DecryptedPieces` and `MinersPreviousInValues` fields that are intended to share secret information across miners. However, the contract blindly trusts this attacker-controlled input without any validation.

**Vulnerable Code Path:**

The `UpdateValue` method processes input through `ProcessConsensusInformation`, which performs only basic permission checks to verify the sender is an authorized miner. [1](#0-0) 

The input is then processed by `PerformSecretSharing` which directly writes attacker-controlled data to all other miners' state without any validation. [2](#0-1) 

**Validation Gap:**

The validation system adds only `UpdateValueValidationProvider` for UpdateValue behavior. [3](#0-2) 

This validator only checks the attacker's own `OutValue`, `Signature`, and `PreviousInValue` fields. It performs NO validation of the `DecryptedPieces` or `MinersPreviousInValues` dictionaries that affect other miners' state. [4](#0-3) 

**Intended vs Actual Behavior:**

The `MinersPreviousInValues` is intended to be populated from the current round state, extracting existing `PreviousInValue` fields. [5](#0-4) 

However, the contract unconditionally accepts and writes whatever values the attacker provides, with no verification that they match the actual current state.

**Consensus Impact:**

The corrupted `DecryptedPieces` are later used by `RevealSharedInValues` to reconstruct other miners' secret `InValues` using Shamir's Secret Sharing. [6](#0-5) 

The compromised `PreviousInValue` fields are used to calculate signatures during block production. [7](#0-6) 

These signatures directly determine mining order for subsequent rounds through modulo calculation. [8](#0-7) 

## Impact Explanation

**CRITICAL** - This vulnerability breaks core consensus security guarantees:

1. **Mining Order Manipulation**: By injecting fake `MinersPreviousInValues`, the attacker directly overwrites other miners' `PreviousInValue` fields. Since these values are used to calculate signatures that determine mining order, the attacker can influence which miners produce blocks in what order during subsequent rounds, potentially creating favorable schedules.

2. **Randomness Corruption**: The secret sharing mechanism is designed to generate unpredictable consensus randomness through cryptographic reconstruction. Poisoned `DecryptedPieces` allow the attacker to corrupt this reconstruction, biasing or predicting random values.

3. **Consensus DoS**: Invalid decrypted pieces cause secret sharing reconstruction to produce incorrect results, potentially breaking consensus flow when honest miners cannot properly validate blocks or calculate their mining schedules.

4. **Complete Round Pollution**: A single transaction from one malicious miner corrupts the consensus state for ALL miners in the round. The modified state is persisted through `TryToUpdateRoundInformation`. [9](#0-8) 

The attack violates the fundamental "miner schedule integrity" and "correct round transitions" invariants required for secure consensus operation.

## Likelihood Explanation

**HIGH** - The attack is highly feasible:

**Attacker Requirements:**
- Must be an authorized miner (realistic in a DPoS system where miners can become malicious or be compromised)
- Must control a mining node to submit `UpdateValue` transactions
- Secret sharing must be enabled (checked via Configuration contract) [10](#0-9) 

**Attack Simplicity:**
- LOW complexity - only requires crafting arbitrary byte arrays in `UpdateValueInput` dictionaries
- No timing requirements or race conditions needed
- Deterministic execution guaranteed by the contract logic
- No additional economic cost beyond normal block production

**Detection Difficulty:**
- The poisoned data appears syntactically valid at transaction time
- No validation failure occurs during transaction execution
- Corruption only manifests during secret sharing reconstruction or when victims use corrupted values
- No immediate alerts to honest miners about the state pollution

## Recommendation

Implement cryptographic validation of cross-miner secret sharing data:

1. **Validate DecryptedPieces**: Verify that each decrypted piece corresponds to the sender's encrypted piece for that target miner. This requires checking the decryption proof against the previously stored encrypted pieces.

2. **Validate MinersPreviousInValues**: Either:
   - Remove this field entirely from `UpdateValueInput` and compute it on-chain from current state
   - OR require cryptographic proofs that the provided values match the current round state

3. **Add Authorization Check**: Ensure miners can only update their own consensus data, not other miners' fields.

4. **Enhance UpdateValueValidationProvider**: Add validation methods for `DecryptedPieces` and `MinersPreviousInValues` to the validation provider, rejecting transactions that attempt to corrupt other miners' state.

Example fix for `PerformSecretSharing`:
```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round, string publicKey)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    
    // FIXED: Only add decrypted pieces for miners that have corresponding encrypted pieces
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
    {
        if (round.RealTimeMinersInformation[decryptedPreviousInValue.Key].EncryptedPieces.ContainsKey(publicKey))
        {
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
        }
    }

    // FIXED: Remove this - compute from current state instead of trusting input
    // foreach (var previousInValue in input.MinersPreviousInValues)
    //     round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UpdateValue_MinersPreviousInValues_Pollution_Attack()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeConsensusAsync();
    await BootMinerProduceFirstBlock();
    
    // Get current round and identify attacker and victim miners
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var attackerPubkey = InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex();
    var victimPubkey = InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex();
    
    // Attacker crafts malicious UpdateValueInput with fake PreviousInValue for victim
    var maliciousInput = currentRound.ExtractInformationToUpdateConsensus(attackerPubkey, randomNumber);
    var fakePreviousInValue = HashHelper.ComputeFrom("ATTACKER_CONTROLLED_VALUE");
    maliciousInput.MinersPreviousInValues[victimPubkey] = fakePreviousInValue;
    
    // Execute attack
    KeyPairProvider.SetKeyPair(InitialCoreDataCenterKeyPairs[0]);
    await AEDPoSContractStub.UpdateValue.SendAsync(maliciousInput);
    
    // Verify: Victim's PreviousInValue was poisoned
    var roundAfterAttack = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var victimInfo = roundAfterAttack.RealTimeMinersInformation[victimPubkey];
    
    // Assert that attacker successfully overwrote victim's PreviousInValue
    victimInfo.PreviousInValue.ShouldBe(fakePreviousInValue);
    
    // This fake value will be used to calculate victim's signature and mining order
    // in subsequent rounds, demonstrating the consensus manipulation capability
}
```

## Notes

The vulnerability exists because the AEDPoS consensus contract trusts miners to provide honest secret sharing data for other miners. In a Byzantine threat model where miners can be malicious, this trust assumption is invalid. The contract must cryptographically verify that cross-miner data matches the expected values derived from each miner's own committed secrets.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
