# Audit Report

## Title
Vote ID Collision Causing Permanent Denial of Service for Specific Candidate Vote Counts

## Summary
The Election contract's vote ID generation mechanism creates deterministic IDs based on a candidate's current active vote count when the optional `Token` field is omitted. Since `LockTimeMap` entries are never cleaned up during withdrawal while vote counts can cycle back to previous values, this creates permanent "poisoned" vote count values that block all future votes, resulting in a critical DoS vulnerability.

## Finding Description

The vulnerability arises from the interaction between vote ID generation, collision detection, and incomplete cleanup during withdrawal.

**Vote ID Generation Logic:**
When the optional `Token` field is not provided (the standard usage pattern), `GenerateVoteId()` generates vote IDs deterministically by hashing the contract address, candidate's public key, and the candidate's **current** `ObtainedActiveVotedVotesAmount`. [1](#0-0) 

**Vote Creation with Collision Check:**
The `Vote()` function generates a vote ID and asserts that no vote with this ID already exists by checking `State.LockTimeMap[voteId] == 0`. If the check passes, it stores the lock time in the map. [2](#0-1) 

**Missing Cleanup in Withdrawal:**
The `Withdraw()` function decreases the candidate's `ObtainedActiveVotedVotesAmount`, allowing the vote count to return to previous values. [3](#0-2) 

However, while `WeightsAlreadyFixedMap` is explicitly cleaned up during withdrawal, the `LockTimeMap` entry is never removed. [4](#0-3) 

The entire `Withdraw()` function never clears or removes `LockTimeMap` entries. [5](#0-4) 

**Root Cause:**
Vote ID generation depends on a mutable value (`ObtainedActiveVotedVotesAmount`) that decreases through withdrawals and can cycle back to previous values. However, the collision-detection map (`LockTimeMap`) persists indefinitely, creating vote ID collisions across different time periods.

**Attack Scenario:**
1. Candidate has 0 active votes
2. Alice votes 100 tokens → generates voteId based on count=0, stores in `LockTimeMap`
3. Candidate now has 100 active votes
4. Lock period expires, Alice withdraws → candidate returns to 0 active votes
5. `LockTimeMap[voteId]` still contains the old lock time
6. Bob attempts to vote when count=0 → generates identical voteId
7. Vote fails: `Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.")`

## Impact Explanation

**Denial of Service Impact:**
- Legitimate users are permanently blocked from voting for candidates whenever the active vote count returns to a previously-used value
- An attacker can deliberately "poison" sequential vote count values (0, 1, 2, ..., N) by voting minimal amounts at each count level and withdrawing
- Attack cost is minimal since tokens are fully returned after withdrawal (only gas fees required)
- These poisoned values remain unusable forever as there is no mechanism to clear `LockTimeMap` entries

**System-Wide Impact:**
- Breaks core voting functionality which is fundamental to AElf's governance system
- Candidates cannot receive new votes at certain vote count thresholds
- The election system's integrity is compromised as vote distribution becomes artificially constrained
- Vote count 0 is especially critical as it's the starting state for all candidates

This constitutes a HIGH severity issue because it enables permanent DoS of a core protocol function with minimal attacker cost.

## Likelihood Explanation

**Natural Occurrence:**
This vulnerability will manifest naturally through normal operations. As users vote and withdraw over time, vote counts naturally fluctuate. When a candidate's vote count decreases through withdrawals and later returns to a previous value through new votes, collisions will occur automatically without any malicious intent.

**Attack Complexity:**
LOW - The attack requires only:
- Access to the public `Vote()` function (no privileges needed)
- Minimal token amounts (even 1 token per count value)
- Waiting for minimum lock periods to expire
- Calling public `Withdraw()` function

**Economic Rationality:**
- Attack cost is near zero: tokens are fully returned after withdrawal
- Only transaction gas fees are consumed
- High impact (DoS of voting) relative to minimal cost makes this highly exploitable

**Probability Assessment:**
HIGH - The vulnerability will trigger through legitimate usage patterns as the system matures and users regularly vote and withdraw. The standard test helper confirms the `Token` field is not used in normal voting operations. [6](#0-5) 

## Recommendation

Add cleanup of `LockTimeMap` entries during withdrawal to prevent vote ID reuse:

```csharp
public override Empty Withdraw(Hash input)
{
    // ... existing validation and update logic ...
    
    // Add this cleanup before returning:
    State.LockTimeMap.Remove(input);
    
    return new Empty();
}
```

Alternatively, modify `GenerateVoteId()` to include a unique component that doesn't cycle (e.g., a global vote counter or timestamp) to ensure vote IDs remain unique across time.

## Proof of Concept

```csharp
[Fact]
public async Task VoteIdCollision_CausesDoS_Test()
{
    const long amount = 100;
    const int lockTime = 90 * 24 * 60 * 60; // 90 days minimum

    var candidateKeyPair = ValidationDataCenterKeyPairs[0];
    await AnnounceElectionAsync(candidateKeyPair);
    
    var voter1 = VoterKeyPairs[0];
    var voter2 = VoterKeyPairs[1];
    var candidatePubkey = candidateKeyPair.PublicKey.ToHex();

    // Step 1: Voter1 votes when candidate has 0 votes
    var voteResult1 = await VoteToCandidateAsync(voter1, candidatePubkey, lockTime, amount);
    voteResult1.Status.ShouldBe(TransactionResultStatus.Mined);
    var voteId1 = Hash.Parser.ParseFrom(voteResult1.ReturnValue);

    // Step 2: Fast forward past lock time
    await AdvanceTime(lockTime + 1);

    // Step 3: Voter1 withdraws, returning candidate vote count to 0
    var electionStub1 = GetElectionContractTester(voter1);
    var withdrawResult = await electionStub1.Withdraw.SendAsync(voteId1);
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 4: Voter2 attempts to vote when count is back to 0
    // This should succeed but will fail due to vote ID collision
    var electionStub2 = GetElectionContractTester(voter2);
    var voteResult2 = await electionStub2.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidatePubkey,
        Amount = amount,
        EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime)
        // Note: Token field is omitted (standard usage)
    });

    // Expected: Success
    // Actual: Fails with "Vote already exists." due to LockTimeMap collision
    voteResult2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult2.TransactionResult.Error.ShouldContain("Vote already exists.");
}
```

## Notes

The vulnerability is confirmed by verifying that `LockTimeMap` is never cleared anywhere in the codebase - grep searches show zero instances of `LockTimeMap.Remove` or `LockTimeMap[...] = 0`. The explicit cleanup of `WeightsAlreadyFixedMap` in the same withdrawal function demonstrates that the developers understood cleanup was necessary, making the missing `LockTimeMap` cleanup a genuine oversight rather than intentional design.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-679)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }

        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Election.Tests/ElectionContractTestHelpers.cs (L92-104)
```csharp
    private async Task<TransactionResult> VoteToCandidateAsync(ECKeyPair voterKeyPair, string candidatePublicKey,
        long lockTime, long amount)
    {
        var electionStub = GetElectionContractTester(voterKeyPair);
        var voteResult = (await electionStub.Vote.SendAsync(new VoteMinerInput
        {
            CandidatePubkey = candidatePublicKey,
            Amount = amount,
            EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime)
        })).TransactionResult;

        return voteResult;
    }
```
