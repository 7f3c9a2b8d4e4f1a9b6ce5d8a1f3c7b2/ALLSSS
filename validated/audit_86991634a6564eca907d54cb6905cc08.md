# Audit Report

## Title
Incorrect Miner Count Calculation When Current Round Has Fewer Than Initial Miners

## Summary
The `GetMinersCount()` function contains a conditional logic error that prevents time-based miner count auto-increase when the current round has fewer than 17 miners. This causes the Election contract to select fewer block producers than intended based on blockchain age, reducing network decentralization.

## Finding Description

The vulnerability exists in the `GetMinersCount(Round input)` private method used internally by the consensus contract to calculate the target number of miners. [1](#0-0) 

The function uses a ternary operator that checks `input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount` (where SupposedMinersCount = 17). [2](#0-1) 

When this condition is true (current round has < 17 miners), the function returns `Math.Min(17, MaximumMinersCount)` and completely bypasses the time-based auto-increase calculation. When false, it correctly calculates `17 + (blockchain_age / MinerIncreaseInterval * 2)`.

This incorrect value is propagated to the Election contract through two code paths:

1. During term transitions via `UpdateMinersCountToElectionContract()` [3](#0-2) , which is called in `ProcessNextTerm()` [4](#0-3) 

2. When round 1 completes in `ProcessNextRound()` [5](#0-4) 

The Election contract stores this value [6](#0-5)  and uses it to determine how many miners to select in `GetVictories()`. [7](#0-6) 

Evidence that this is unintended: The codebase contains a separate `GetAutoIncreasedMinersCount()` method [8](#0-7)  that correctly calculates auto-increase unconditionally, suggesting the conditional logic in `GetMinersCount()` is a bug.

## Impact Explanation

**Reduced Block Producers**: When blockchain age suggests 25 miners but current round has only 15 miners, the function returns 17 instead of 25. The Election contract then selects only 17 miners for the next term, resulting in 8 fewer block producers than intended.

**Reduced Data Center Slots**: The validation data center count is calculated as `MinersCount * 5` [9](#0-8) , so incorrect miners count (17 instead of 25) caps data center participation at 85 instead of 125 (40 fewer slots).

**Consensus Security**: Fewer block producers reduces network decentralization, making the network more vulnerable to censorship, collusion, and attacks. This directly undermines the security model of the DPoS consensus.

**Persistent Effect**: Once the incorrect count is set in the Election contract, it persists until the next term transition when conditions change, potentially affecting multiple terms.

## Likelihood Explanation

**Trigger Conditions**:
1. Blockchain has been running long enough that auto-increased count exceeds 17 (with default MinerIncreaseInterval of 31536000 seconds = 1 year [10](#0-9) , this happens after 1 year)
2. Current round has fewer than 17 active miners (`RealTimeMinersInformation.Count < 17`)

**Realistic Scenarios**:
- **Bootstrap Phase**: Testnet or sidechain deployments starting with < 17 initial miners (tests use 5 initial miners [11](#0-10) )
- **Temporary Issues**: Network problems, power outages, or maintenance causing some miners to be offline/miss rounds temporarily
- **Election Failures**: Insufficient valid candidates in Election contract causing `GetVictories()` to return fewer than 17 miners [12](#0-11) 

**Probability**: Medium-Low for mainnet (which likely starts with 17+ miners), Medium-High for testnets and sidechains (which may start with fewer miners).

## Recommendation

Replace the conditional logic with an unconditional time-based calculation:

```csharp
private int GetMinersCount(Round input)
{
    if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;
    
    if (!TryToGetRoundInformation(1, out _)) return 0;
    
    // Always calculate auto-increased count based on blockchain age
    var autoIncreasedCount = AEDPoSContractConstants.SupposedMinersCount.Add(
        (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
        .Div(State.MinerIncreaseInterval.Value).Mul(2));
    
    return Math.Min(autoIncreasedCount, State.MaximumMinersCount.Value);
}
```

This ensures the miners count is always based on blockchain age, independent of current round participation, matching the behavior of the existing `GetAutoIncreasedMinersCount()` method.

## Proof of Concept

The vulnerability can be demonstrated by creating a scenario where:
1. Initialize blockchain with 5 miners
2. Advance blockchain time by 1 year (MinerIncreaseInterval)
3. Ensure current round has < 17 miners
4. Call term transition which invokes `GetMinersCount()`
5. Verify Election contract receives 17 instead of expected 19

The existing test `AEDPoSContract_ChangeMinersCount_Test` validates the auto-increase mechanism [13](#0-12) , but doesn't cover the scenario where `RealTimeMinersInformation.Count < SupposedMinersCount` during the calculation, which would expose this bug.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-135)
```csharp
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L157-157)
```csharp
        State.MinersCount.Value = input.MinersCount;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```

**File:** test/AElf.Contracts.Economic.TestBase/EconomicContractsTestConstants.cs (L11-11)
```csharp
    public const int InitialCoreDataCenterCount = 5;
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L24-136)
```csharp
    [IgnoreOnCIFact]
    public async Task AEDPoSContract_ChangeMinersCount_Test()
    {
        const int termIntervalMin = 31536000 / 60;

        var maxCount = ValidationDataCenterKeyPairs.Count;
        await InitializeCandidates(maxCount);

        var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());

        var randomHashes = Enumerable.Range(0, EconomicContractsTestConstants.InitialCoreDataCenterCount)
            .Select(_ => HashHelper.ComputeFrom("randomHashes")).ToList();
        var triggers = Enumerable.Range(0, EconomicContractsTestConstants.InitialCoreDataCenterCount).Select(i =>
            new AElfConsensusTriggerInformation
            {
                Pubkey = ByteString.CopyFrom(InitialCoreDataCenterKeyPairs[i].PublicKey),
                InValue = randomHashes[i]
            }).ToDictionary(t => t.Pubkey.ToHex(), t => t);

        var voter = GetElectionContractTester(VoterKeyPairs[0]);
        foreach (var candidateKeyPair in ValidationDataCenterKeyPairs)
        {
            var voteResult = await voter.Vote.SendAsync(new VoteMinerInput
            {
                CandidatePubkey = candidateKeyPair.PublicKey.ToHex(),
                Amount = 10 + new Random().Next(1, 10),
                EndTimestamp = TimestampHelper.GetUtcNow().AddDays(100)
            });
            voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }

        byte[] randomNumber;
        foreach (var minerInRound in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
        {
            var currentKeyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == minerInRound.Pubkey);

            KeyPairProvider.SetKeyPair(currentKeyPair);

            BlockTimeProvider.SetBlockTime(minerInRound.ExpectedMiningTime);

            var tester = GetAEDPoSContractStub(currentKeyPair);
            var headerInformation =
                (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggers[minerInRound.Pubkey]
                    .ToBytesValue())).ToConsensusHeaderInformation();

            randomNumber = await GenerateRandomProofAsync(currentKeyPair);
            // Update consensus information.
            var toUpdate =
                headerInformation.Round.ExtractInformationToUpdateConsensus(minerInRound.Pubkey,
                    ByteString.CopyFrom(randomNumber));
            await tester.UpdateValue.SendAsync(toUpdate);
        }

        var changeTermTime = BlockchainStartTimestamp.ToDateTime();
        BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());

        var nextTermInformation = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Behaviour = AElfConsensusBehaviour.NextRound,
                Pubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey)
            }.ToBytesValue())).ToConsensusHeaderInformation();

        var nextRoundInput = NextRoundInput.Parser.ParseFrom(nextTermInformation.Round.ToByteArray());
        randomNumber = await GenerateRandomProofAsync(BootMinerKeyPair);
        nextRoundInput.RandomNumber = ByteString.CopyFrom(randomNumber);
        await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
        changeTermTime = BlockchainStartTimestamp.ToDateTime().AddMinutes(termIntervalMin).AddSeconds(10);
        BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());

        nextTermInformation = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Behaviour = AElfConsensusBehaviour.NextTerm,
                Pubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey)
            }.ToBytesValue())).ToConsensusHeaderInformation();

        var nextTermInput = NextTermInput.Parser.ParseFrom(nextTermInformation.Round.ToByteArray());
        randomNumber = await GenerateRandomProofAsync(BootMinerKeyPair);
        nextTermInput.RandomNumber = ByteString.CopyFrom(randomNumber);
        var transactionResult = await AEDPoSContractStub.NextTerm.SendAsync(nextTermInput);
        transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMinerStub = GetAEDPoSContractStub(ValidationDataCenterKeyPairs[0]);
        var termCount = 0;
        var minerCount = 0;
        while (minerCount < maxCount)
        {
            var currentRound = await newMinerStub.GetCurrentRoundInformation.CallAsync(new Empty());
            var firstPubKey = currentRound.RealTimeMinersInformation.Keys.First();
            var keypair = ValidationDataCenterKeyPairs.First(o => o.PublicKey.ToHex() == firstPubKey);
            newMinerStub = GetAEDPoSContractStub(keypair);

            minerCount = currentRound.RealTimeMinersInformation.Count;
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);

            changeTermTime = BlockchainStartTimestamp.ToDateTime()
                .AddMinutes((termCount + 2).Mul(termIntervalMin)).AddSeconds(10);
            BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());
            var nextRoundInformation = (await newMinerStub.GetConsensusExtraData.CallAsync(
                new AElfConsensusTriggerInformation
                {
                    Behaviour = AElfConsensusBehaviour.NextTerm,
                    Pubkey = ByteStringHelper.FromHexString(currentRound.RealTimeMinersInformation.ElementAt(0).Value
                        .Pubkey)
                }.ToBytesValue())).ToConsensusHeaderInformation();
            nextTermInput = NextTermInput.Parser.ParseFrom(nextRoundInformation.Round.ToByteArray());
            randomNumber = await GenerateRandomProofAsync(keypair);
            nextTermInput.RandomNumber = ByteString.CopyFrom(randomNumber);
            await newMinerStub.NextTerm.SendAsync(nextTermInput);
            termCount++;
        }
    }
```
