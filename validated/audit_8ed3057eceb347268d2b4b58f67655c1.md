# Audit Report

## Title
Missing LIB Round Number Validation Allows Consensus State Corruption in NextTerm/NextRound Operations

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockRoundNumber` remains less than the current `RoundNumber` when processing `NextTerm` and `NextRound` operations. A malicious miner can inject consensus state where the Last Irreversible Block (LIB) round number equals or exceeds the current round number, violating the fundamental invariant that LIB must lag behind the current round. This causes permanent consensus state corruption and mining status miscalculations.

## Finding Description

The vulnerability exists in the selective application of validation providers during consensus round transitions. The validation framework applies different providers based on the consensus behavior type. [1](#0-0) 

For `NextTerm` behavior, only `RoundTerminateValidationProvider` is applied, which validates round number increment, term number increment, and InValue nullity, but completely omits LIB constraint validation. [2](#0-1) 

The `LibInformationValidationProvider`, which handles LIB validation for `UpdateValue` operations, only checks that LIB values don't regress (go backwards), but never validates the critical invariant that `ConfirmedIrreversibleBlockRoundNumber < RoundNumber`. [3](#0-2) 

**Attack Execution:**

1. A malicious miner with block production rights crafts a `NextTermInput` or `NextRoundInput` with:
   - Valid `RoundNumber = currentRound.RoundNumber + 1` (passes validation)
   - Invalid `ConfirmedIrreversibleBlockRoundNumber >= RoundNumber` (no validation exists)

2. The malicious input passes validation because `LibInformationValidationProvider` is not applied to NextTerm/NextRound behaviors.

3. The corrupted round is stored in state via `ProcessNextTerm`. [4](#0-3) 

4. The input is converted to a Round object without additional validation, and stored directly. [5](#0-4) [6](#0-5) 

5. The corrupted LIB values persist and propagate to all subsequent rounds because `GenerateNextRoundInformation` blindly copies these fields without validation. [7](#0-6) 

## Impact Explanation

**Severity: HIGH - Critical Consensus Invariant Violation**

**Consensus State Corruption:**
The blockchain consensus state permanently contains the logically impossible condition where `ConfirmedIrreversibleBlockRoundNumber >= RoundNumber`. This fundamentally violates the consensus protocol's invariant that the Last Irreversible Block must always lag behind the current round, as irreversibility is determined retrospectively after sufficient confirmations.

**Persistent Propagation:**
The corruption is permanent and self-perpetuating. Since `GenerateNextRoundInformation` copies LIB values from previous rounds without validation, the invalid state propagates indefinitely through the consensus mechanism.

**Mining Status Miscalculation:**
The `BlockchainMiningStatusEvaluator` determines blockchain health by comparing `_libRoundNumber` (from `ConfirmedIrreversibleBlockRoundNumber`) against `_currentRoundNumber` using arithmetic assumptions that `_libRoundNumber < _currentRoundNumber`. [8](#0-7) 

When the invariant is violated (`_libRoundNumber >= _currentRoundNumber`), the status evaluation logic produces incorrect results: [9](#0-8) 

- **Abnormal status** (line 123-125) requires `_libRoundNumber.Add(2) < _currentRoundNumber`, which would be false
- **Severe status** (line 127-128) requires `_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold)`, which would also be false
- The blockchain status would always return **Normal** even during actual consensus issues
- Block production limits would be incorrectly calculated as maximum values
- `IrreversibleBlockHeightUnacceptable` events would never fire when they should

## Likelihood Explanation

**Probability: MEDIUM - Requires Miner Privileges**

**Attacker Requirements:**
- Must be an active miner in the current miner list (controlled via election/governance)
- Must wait for scheduled time slot to produce a NextTerm or NextRound block  
- Must be capable of crafting custom consensus transaction input (requires modified node software)

**Attack Complexity:**
The attack is technically simple - merely requires modifying the `ConfirmedIrreversibleBlockRoundNumber` field in the NextTermInput/NextRoundInput to an invalid value. No sophisticated cryptographic attacks, timing exploits, or multi-transaction coordination required.

**Execution Feasibility:**
While honest miners use `GenerateConsensusTransactions` to create consensus data, there is no cryptographic binding or merkle commitment preventing a malicious miner from crafting arbitrary input. The consensus contract itself validates the input, and as demonstrated, that validation is insufficient. A compromised miner running modified node software can execute this attack with certainty during their mining turn.

**Detection Difficulty:**
The corruption does not cause immediate failures or reverts - it silently corrupts state. The mining status miscalculations may not be obvious until specific threshold conditions are met. This makes detection challenging without explicit invariant monitoring.

## Recommendation

Add explicit validation to ensure `ConfirmedIrreversibleBlockRoundNumber < RoundNumber` for all round transitions:

**Option 1:** Apply `LibInformationValidationProvider` to NextTerm/NextRound behaviors and enhance it to check the invariant:

```csharp
// In LibInformationValidationProvider.cs
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    
    // Existing regression checks...
    
    // NEW: Validate LIB round number must be less than current round number
    if (providedRound.ConfirmedIrreversibleBlockRoundNumber >= providedRound.RoundNumber)
    {
        validationResult.Message = "LIB round number must be less than current round number.";
        return validationResult;
    }
    
    // Rest of validation...
}
```

**Option 2:** Create a dedicated validation provider for LIB invariant checks and apply it to all consensus behaviors.

**Option 3:** Add validation in `AddRoundInformation` before storing:

```csharp
private void AddRoundInformation(Round round)
{
    Assert(round.ConfirmedIrreversibleBlockRoundNumber < round.RoundNumber,
           "Invalid LIB round number: must be less than current round number.");
    
    State.Rounds.Set(round.RoundNumber, round);
    // Rest of method...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousLIBRoundNumber_CausesConsensusStateCorruption()
{
    // Setup: Initialize consensus with a valid round
    // Assume current state: RoundNumber = 10, TermNumber = 2, ConfirmedIrreversibleBlockRoundNumber = 8
    
    // Malicious miner crafts NextTerm input with invalid LIB round number
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = 11,  // Valid increment: currentRound.RoundNumber + 1
        TermNumber = 3,    // Valid increment: currentTerm + 1
        ConfirmedIrreversibleBlockRoundNumber = 11,  // INVALID: >= RoundNumber
        ConfirmedIrreversibleBlockHeight = 1000,
        RealTimeMinersInformation = { /* valid miner info */ },
        RandomNumber = ByteString.CopyFrom(/* valid random bytes */)
    };
    
    // Execute NextTerm - this should fail but doesn't due to missing validation
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousNextTermInput);
    
    // Vulnerability: Transaction succeeds despite violating invariant
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify corrupted state is stored
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RoundNumber.ShouldBe(11);
    currentRound.ConfirmedIrreversibleBlockRoundNumber.ShouldBe(11);  // Corrupted: >= RoundNumber
    
    // Verify impact: GetMaximumBlocksCount always returns max due to broken status evaluation
    var maxBlocks = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocks.Value.ShouldBe(AEDPoSContractConstants.MaximumTinyBlocksCount);  // Always max, even during issues
    
    // Verify propagation: Next round copies corrupted values
    // (Would require simulating another round transition to demonstrate)
}
```

## Notes

This vulnerability represents a critical failure in consensus invariant enforcement. The AEDPoS protocol fundamentally assumes that the Last Irreversible Block (LIB) always lags behind the current round, as irreversibility is determined retrospectively after sufficient miner confirmations. The validation framework's selective application of providers creates a gap where this invariant can be violated during term and round transitions, leading to permanent state corruption that undermines blockchain health monitoring and block production controls.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L161-196)
```csharp

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-71)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-37)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```
