# Audit Report

## Title
Missing Validation of DecryptedPieces Content Allows Corruption of Secret Sharing Reconstruction

## Summary
The AEDPoS consensus contract's `RevealSharedInValues` function only validates the count of `DecryptedPieces` but not their content, allowing malicious miners to submit empty or corrupted byte arrays. When used in Shamir's Secret Sharing reconstruction, these corrupted pieces produce incorrect `PreviousInValue` hashes that are never validated against the original `OutValue` commitment, breaking the cryptographic commit-reveal scheme and corrupting consensus randomness.

## Finding Description

The vulnerability exists in the secret sharing reconstruction mechanism used as a fallback when miners fail to reveal their `InValue`. The attack exploits missing content validation at multiple layers:

**Root Cause - Count-Only Validation:** The `RevealSharedInValues` method only validates that sufficient `DecryptedPieces` exist by count, never checking if the byte arrays contain valid cryptographic material. [1](#0-0) 

**Storage Without Validation:** When miners submit `UpdateValueInput`, the `PerformSecretSharing` method unconditionally stores `DecryptedPieces` without any content validation. [2](#0-1) 

**Validation Provider Gap:** The `UpdateValueValidationProvider` validates `OutValue`, `Signature`, and `PreviousInValue` hash relationships, but completely ignores `DecryptedPieces` content. [3](#0-2) 

**Attack Execution:** During round transitions, `RevealSharedInValues` extracts all `DecryptedPieces` and passes them to `SecretSharingHelper.DecodeSecret` for Lagrange interpolation reconstruction. [4](#0-3) 

**Corruption Mechanism:** In the reconstruction algorithm, each piece is converted to `BigInteger`. Empty byte arrays become `BigInteger(0)`, producing mathematically incorrect Lagrange interpolation results. [5](#0-4) 

**Critical Missing Check:** The reconstructed `PreviousInValue` is set directly without validating that `Hash(reconstructed_InValue) == committed_OutValue`, breaking the cryptographic commitment guarantee. [6](#0-5) 

**Downstream Impact:** The corrupted `PreviousInValue` is later used by `SupplyCurrentRoundInformation` to calculate signatures for offline miners. [7](#0-6) 

**Signature Corruption:** The signature calculation XORs the corrupted `PreviousInValue` with all miner signatures, producing wrong randomness. [8](#0-7) 

**Mining Order Manipulation:** The corrupted signature directly affects mining order calculation through modulo arithmetic. [9](#0-8) 

## Impact Explanation

**Consensus Integrity Breach:** AEDPoS relies on a commit-reveal scheme where `OutValue = Hash(InValue)` must be verifiable. The secret sharing mechanism serves as a cryptographic fallback to reconstruct `InValues` when miners are offline. By corrupting this reconstruction without any validation against the original commitment, attackers break the fundamental cryptographic guarantee that prevents miners from changing their random number contributions after seeing others' values.

**Randomness Manipulation:** The `CalculateSignature` method generates consensus randomness by XORing all miners' signatures derived from their `InValues`. Corrupted `InValues` lead to wrong signatures, directly affecting block producer selection order. While not fully controllable (requires coordination and affects offline miners), this undermines the unpredictability property essential for fair consensus.

**Affected Parties:** All miners whose `InValues` must be reconstructed via secret sharing (typically offline miners), and the entire network suffers from degraded randomness quality during periods when secret sharing reconstruction is needed.

## Likelihood Explanation

**Attack Requirements:** The threshold is set to 2/3 of miners for encrypted pieces, but all miners' decrypted pieces are required for reconstruction. [10](#0-9) 

Any participating miner can submit `UpdateValueInput` with corrupted `DecryptedPieces` through normal block production. The attack requires:
- Being an active miner (realistic for Byzantine actors)
- Secret sharing being enabled (standard configuration)
- Target miners being offline (common occurrence)

**Attack Complexity:** Low - attackers simply provide `DecryptedPieces` with correct count but empty/malformed `ByteString` values. No cryptographic sophistication required.

**Detection Difficulty:** The system is designed to be permissive about missing `InValues`, using fake values when necessary. [11](#0-10) 

This design philosophy masks the corruption, as count validation passes and empty values don't trigger obvious failures.

## Recommendation

Add cryptographic validation in `RevealSharedInValues` to verify reconstructed InValues match original OutValue commitments:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate reconstructed InValue matches committed OutValue
if (anotherMinerInPreviousRound.OutValue != null && 
    anotherMinerInPreviousRound.OutValue != Hash.Empty)
{
    if (revealedInValue != anotherMinerInPreviousRound.OutValue)
    {
        // Reconstruction failed - don't use corrupted value
        Context.LogDebug(() => $"Secret sharing reconstruction failed validation for {publicKeyOfAnotherMiner}");
        continue;
    }
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

Additionally, add content validation in `PerformSecretSharing` to reject empty DecryptedPieces:

```csharp
foreach (var decryptedPreviousInValue in input.DecryptedPieces)
{
    if (decryptedPreviousInValue.Value == null || decryptedPreviousInValue.Value.IsEmpty)
    {
        Context.LogDebug(() => "Invalid empty DecryptedPiece detected");
        continue;
    }
    round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
        .Add(publicKey, decryptedPreviousInValue.Value);
}
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a round with multiple miners where one miner commits an `OutValue` but goes offline
2. Have a malicious miner submit `UpdateValue` with empty/corrupted `DecryptedPieces` (correct count but invalid content)
3. Trigger `RevealSharedInValues` during `NextRound` transition
4. Verify that the reconstructed `PreviousInValue` does NOT match `Hash(original_InValue) == OutValue`
5. Show that the corrupted value is used in signature calculation, affecting mining order

The core issue is that no validation exists to check: `HashHelper.ComputeFrom(reconstructed_InValue) == committed_OutValue` after secret sharing reconstruction.

**Notes:**
- This vulnerability only manifests when secret sharing reconstruction is needed (offline miners)
- The `UpdateValueValidationProvider` only validates explicitly provided `PreviousInValue`, not reconstructed ones
- The missing validation breaks the cryptographic commitment property fundamental to secure consensus
- While practical impact is limited to scenarios involving offline miners, the integrity guarantee violation is critical

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L48-51)
```csharp
            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L203-210)
```csharp
            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
