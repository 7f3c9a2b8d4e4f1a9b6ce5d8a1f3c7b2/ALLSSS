# Audit Report

## Title
Incorrect Miner Count Used for Secret Sharing Validation Across Term Transitions

## Summary
The `RevealSharedInValues()` function uses the current round's miner count to validate decrypted pieces from the previous round. When miner count changes during term transitions, this causes validation failures (preventing legitimate InValue revelation) or incorrect secret reconstruction with insufficient shares, breaking the consensus protocol's secret sharing mechanism.

## Finding Description

The vulnerability exists in the secret sharing validation logic that spans term transitions. The core issue is that `RevealSharedInValues()` validates `DecryptedPieces` from a previous round using the current round's miner count, creating a semantic mismatch when the miner list changes between terms. [1](#0-0) 

The function captures `minersCount` from the current round, then uses this to validate the previous round's data: [2](#0-1) 

When DecryptedPieces are generated, they're based on the round's own miner count: [3](#0-2) 

During term transitions, the miner list can change via governance elections: [4](#0-3) [5](#0-4) 

The function is called during NextRound transitions: [6](#0-5) 

**Why existing protections fail:**

The `IsMinerListJustChanged` flag only prevents new secret sharing from being initiated: [7](#0-6) 

But it does NOT prevent `RevealSharedInValues` from executing with mismatched miner counts. The line 30 filter only ensures miners exist in both rounds, but doesn't fix the count validation issue: [8](#0-7) 

## Impact Explanation

**Scenario 1 - Miner Count Increases (Y > X):**
- Previous round (last of old term) had X miners
- Current round (first of new term) has Y miners where Y > X
- DecryptedPieces.Count ≤ X (generated based on previous round's miner count)
- Line 36 requires DecryptedPieces.Count ≥ Y
- Validation always fails even with all available pieces
- PreviousInValue cannot be revealed via secret sharing
- Subsequent UpdateValue validation fails for legitimate miners: [9](#0-8) 

**Scenario 2 - Miner Count Decreases (Y < X):**
- If Y ≤ DecryptedPieces.Count < X, validation incorrectly passes
- `minimumCount = Y × 2/3` (calculated from new term's miner count)
- Original secret threshold was `X × 2/3` (from old term)
- If Y × 2/3 < X × 2/3, Shamir's Secret Sharing reconstruction uses insufficient shares
- This produces a deterministic but INCORRECT value
- The incorrect PreviousInValue breaks subsequent consensus validation

**Who is affected:**
- All miners during the first NextRound after a term transition with miner count change
- The consensus protocol's randomness and integrity guarantees
- Block production continuity across term boundaries

## Likelihood Explanation

**Reachable Entry Point:**
The function is called automatically during normal consensus operations when producing blocks for NextRound transitions: [10](#0-9) 

**Feasible Preconditions:**
Miner count changes occur through governance-controlled term transitions. The election contract provides new miner lists: [11](#0-10) 

**Execution Practicality:**
- Deterministic trigger: automatically occurs during first NextRound after term transition with miner count change
- No special permissions required beyond normal miner operations
- No attacker action needed - this is a protocol logic error

**Probability:**
While miner count changes are infrequent (governance-controlled), they are a designed feature of the protocol. When they occur, the vulnerability is guaranteed to trigger, affecting all miners attempting to reveal shared InValues.

## Recommendation

Modify `RevealSharedInValues()` to use the previous round's miner count for validating that round's DecryptedPieces:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");

    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

    // FIX: Use previousRound's miner count for validation and threshold calculation
    var previousMinersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = previousMinersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;

    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        if (pair.Key == publicKey) continue;
        if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

        var publicKeyOfAnotherMiner = pair.Key;
        var anotherMinerInPreviousRound = pair.Value;

        if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
        // FIX: Validate against previousRound's miner count
        if (anotherMinerInPreviousRound.DecryptedPieces.Count < previousMinersCount) continue;

        // ... rest of the secret reconstruction logic
    }
}
```

Additionally, consider adding an explicit check to skip secret revelation when `IsMinerListJustChanged` is true for the previous round, as the secret sharing data may be incomplete during term transitions.

## Proof of Concept

A valid test would demonstrate:
1. Create a term with X miners (e.g., 5 miners)
2. Each miner generates and shares secret pieces (DecryptedPieces.Count = 5)
3. Trigger term transition to new term with Y miners (e.g., 7 miners)
4. Execute NextRound for the second round of new term
5. Observe that `RevealSharedInValues` validation fails at line 36 because it checks `5 < 7`
6. Verify that PreviousInValue is not revealed even though all 5 pieces are available

The test would require setting up the full consensus infrastructure with election contract integration to demonstrate the miner count change scenario and the resulting validation failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-22)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L30-30)
```csharp
            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-242)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-189)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```
