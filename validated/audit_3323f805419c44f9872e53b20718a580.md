# Audit Report

## Title
Side Chain Donation Tracking Overwrites Multi-Symbol Donations in Same Block

## Summary
The `Donate()` function in the AEDPoS side chain dividends pool contains a critical logic error where donation records are permanently overwritten when multiple different token symbols are donated within the same block. The flawed conditional logic creates a new `Dividends` object instead of appending to the existing one, resulting in irreversible loss of previously recorded donations for that block height.

## Finding Description

The vulnerability exists in the donation tracking logic within the side chain dividends pool. [1](#0-0) 

The root cause lies in the conditional statement that checks whether the current donation symbol already exists in the record for this block height. The condition has two negation paths that lead to the else block:

1. `currentReceivedDividends == null` - Correctly creates a new object when no record exists for this block
2. `currentReceivedDividends != null && !ContainsKey(input.Symbol)` - **INCORRECTLY creates a new object, overwriting all existing data**

When scenario 2 occurs (a donation record exists but doesn't contain the new symbol), the else block creates a completely new `Dividends` object containing only the current donation symbol. This new object is then written to state, effectively erasing all other symbol donations previously recorded for that block height.

The `Dividends` message type is intentionally designed as a map structure to support multiple token symbols. [2](#0-1) 

The state variable `SideChainReceivedDividends` maps block heights to dividend records. [3](#0-2) 

**Concrete Exploit Scenario:**
- Block 1000, Transaction 1: User A donates 1000 ELF → State stores `{ELF: 1000}`
- Block 1000, Transaction 2: User B donates 500 USDT → Condition evaluates to false (record exists but doesn't contain USDT) → Else block executes → State overwrites to `{USDT: 500}` → **ELF donation record is permanently lost**

The `Donate()` method is publicly accessible without special permissions, only requiring token availability for method fees. [4](#0-3) 

The same vulnerability pattern exists in the Treasury contract with an even more restrictive condition that only properly accumulates the native symbol when it already exists in the record. [5](#0-4) 

## Impact Explanation

**Critical State Corruption:**
- Donation records for entire token symbols are permanently erased from blockchain state
- The `GetDividends` view function returns incorrect historical data as it directly reads from the corrupted state [6](#0-5) 
- TokenHolder profit distribution calculations that depend on accurate dividend data become unreliable
- Economic analytics and governance metrics based on donation history are compromised

**Direct Financial Impact:**
- Donors lose recognition of their contributions in the permanent blockchain record
- Historical queries for donation amounts return incomplete data, potentially affecting auditing and transparency
- Side chain operators lose accurate tracking capabilities for economic decisions

**Severity Justification:** 
This is CRITICAL because:
1. The bug destroys permanent state data with no recovery mechanism
2. It occurs deterministically under normal usage patterns (no malicious intent needed)
3. Lost donation records cannot be recovered through any on-chain mechanism
4. The corrupted state affects downstream profit calculations and economic tracking
5. No on-chain detection or alerting mechanism exists - events fire correctly masking the corruption [7](#0-6) 

## Likelihood Explanation

**Reachable Entry Point:**
The `Donate()` method is a public function implementing the ACS10 standard, accessible to any user with token balance and approval.

**Trivial Preconditions:**
- Any two users call `Donate()` with different token symbols in the same block
- Only requires token balance, approval, and passing the `IsTokenAvailableForMethodFee` check
- No special permissions, complex timing requirements, or elaborate setup needed

**Execution Practicality:**
- On moderately active side chains, multiple donations per block is expected normal behavior
- AEDPoS block times (~4 seconds) make concurrent transactions highly probable
- The bug triggers automatically during normal protocol usage without any malicious actions required
- Users performing legitimate donations will unknowingly trigger data loss with no warning

**Attack Complexity:** VERY LOW
- No sophisticated manipulation or deep protocol knowledge needed
- Occurs naturally through normal protocol usage patterns
- Can be accidentally triggered by any users or deliberately exploited
- No way for users to prevent or detect the issue before it occurs

**Detection Difficulty:**
- Donation events fire correctly, creating a false appearance of success and masking the state corruption
- Data loss only discovered when querying historical records after the fact
- No transaction reverts or error conditions exist to alert users

**Probability Assessment:** HIGH - This will occur regularly on any production side chain with multi-token support and moderate transaction volume.

## Recommendation

Fix the conditional logic to properly handle all three cases:

```csharp
var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];

// Initialize new Dividends object if none exists for this height
if (currentReceivedDividends == null)
{
    currentReceivedDividends = new Dividends();
}

// Add or update the symbol amount
if (currentReceivedDividends.Value.ContainsKey(input.Symbol))
{
    // Symbol exists - accumulate the amount
    currentReceivedDividends.Value[input.Symbol] = 
        currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
}
else
{
    // Symbol doesn't exist - add new entry
    currentReceivedDividends.Value[input.Symbol] = input.Amount;
}

State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;
```

Apply the same fix to the Treasury contract's `Donate()` method, removing the overly restrictive condition that only handles native symbol accumulation.

## Proof of Concept

```csharp
[Fact]
public async Task SideChainDividendPool_MultiSymbolDonation_OverwritesBug_Test()
{
    // Setup: Create and issue two different tokens
    const string tokenSymbol1 = "ELF";
    const string tokenSymbol2 = "USDT";
    
    await CreateAndIssueTokenAsync(tokenSymbol2, 1000000);
    
    // Get initial balance
    var balance1 = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = BootMinerAddress,
        Symbol = tokenSymbol1
    });
    var balance2 = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = BootMinerAddress,
        Symbol = tokenSymbol2
    });
    
    // Approve donations
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ConsensusContractAddress,
        Symbol = tokenSymbol1,
        Amount = 1000
    });
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ConsensusContractAddress,
        Symbol = tokenSymbol2,
        Amount = 500
    });
    
    // Get current height
    var currentHeight = (await BlockchainService.GetChainAsync()).BestChainHeight;
    
    // Donate first symbol
    await AEDPoSContractStub.Donate.SendAsync(new DonateInput
    {
        Symbol = tokenSymbol1,
        Amount = 1000
    });
    
    // Donate second symbol IN THE SAME BLOCK
    await AEDPoSContractStub.Donate.SendAsync(new DonateInput
    {
        Symbol = tokenSymbol2,
        Amount = 500
    });
    
    // Query dividends for the block
    var dividends = await AEDPoSContractStub.GetDividends.CallAsync(
        new Int64Value { Value = currentHeight });
    
    // BUG: Only USDT should be present, ELF donation was overwritten
    dividends.Value.Count.ShouldBe(1);  // Should be 2, but bug causes overwrite
    dividends.Value.ContainsKey(tokenSymbol2).ShouldBeTrue();
    dividends.Value.ContainsKey(tokenSymbol1).ShouldBeFalse();  // LOST!
    dividends.Value[tokenSymbol2].ShouldBe(500);
    
    // The first donation is permanently lost from blockchain state
}
```

## Notes

This vulnerability affects both the AEDPoS side chain dividends pool and the Treasury contract. The Treasury variant has an even more restrictive condition that only properly handles native symbol accumulation, making it fail in additional scenarios. Both implementations violate the intended design of the `Dividends` protobuf message type, which is explicitly structured as a map to support multiple token symbols per block height. The bug represents a fundamental data integrity violation that compromises the reliability of economic tracking on AElf side chains.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-42)
```csharp
    public override Empty Donate(DonateInput input)
    {
        EnsureTokenContractAddressSet();

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L66-72)
```csharp
        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L74-89)
```csharp
        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L130-134)
```csharp
    public override Dividends GetDividends(Int64Value input)
    {
        Assert(Context.CurrentHeight > input.Value, "Cannot query dividends of a future block.");
        return State.SideChainReceivedDividends[input.Value];
    }
```

**File:** protobuf/acs10.proto (L65-68)
```text
message Dividends {
    // The dividends, symbol -> amount.
    map<string, int64> value = 1;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L57-57)
```csharp
    public MappedState<long, Dividends> SideChainReceivedDividends { get; set; }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L225-239)
```csharp
            var donatesOfCurrentBlock = State.DonatedDividends[Context.CurrentHeight];
            if (donatesOfCurrentBlock != null && Context.Variables.NativeSymbol == input.Symbol &&
                donatesOfCurrentBlock.Value.ContainsKey(Context.Variables.NativeSymbol))
                donatesOfCurrentBlock.Value[Context.Variables.NativeSymbol] = donatesOfCurrentBlock
                    .Value[Context.Variables.NativeSymbol].Add(input.Amount);
            else
                donatesOfCurrentBlock = new Dividends
                {
                    Value =
                    {
                        { input.Symbol, input.Amount }
                    }
                };

            State.DonatedDividends[Context.CurrentHeight] = donatesOfCurrentBlock;
```
