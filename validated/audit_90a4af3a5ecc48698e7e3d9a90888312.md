# Audit Report

## Title
Empty Pubkey Candidate Registration Causes Consensus Failure During Term Transition

## Summary
The Election Contract's `AnnounceElectionFor` method lacks validation to prevent registration of empty pubkey strings. When an empty pubkey candidate receives sufficient votes and is elected as a miner, the subsequent term transition fails with an `IndexOutOfRangeException` in `GenerateFirstRoundOfNewTerm`, halting blockchain consensus indefinitely.

## Finding Description

**Root Cause:**

The Election Contract allows registration of candidates with empty pubkey strings. In `AnnounceElectionFor`, the input pubkey is converted to a byte array without length validation: [1](#0-0) 

The `ByteArrayHelper.HexStringToByteArray("")` returns an empty byte array `byte[0]`: [2](#0-1) 

This empty byte array is then passed to the internal `AnnounceElection` method, which creates an empty `ByteString` and adds it to the candidates list without any length validation: [3](#0-2) 

Users can vote for this empty candidate because the validation only checks if the candidate exists and is current: [4](#0-3) [5](#0-4) 

**Attack Path:**

During term transitions, the Consensus Contract prepares block header data by calling `GetConsensusExtraDataForNextTerm`, which invokes `GenerateFirstRoundOfNextTerm`: [6](#0-5) 

This method retrieves the new miner list from the Election Contract via `TryToGetVictories`: [7](#0-6) [8](#0-7) 

The Election Contract returns top-voted candidates, which may include the empty pubkey if it has sufficient votes: [9](#0-8) 

The Consensus Contract then calls `MinerList.GenerateFirstRoundOfNewTerm`, which attempts to sort miners by accessing the first byte of each pubkey: [10](#0-9) 

When `miner` is an empty `ByteString` (length = 0), the indexing operation `miner[0]` throws an `IndexOutOfRangeException`, crashing the term generation process.

## Impact Explanation

**Direct Harm:**
- Complete denial of service of the blockchain's consensus mechanism
- The blockchain cannot transition to new terms, preventing miner list updates
- Block production may halt entirely if all current miners lose authorization
- All consensus-dependent operations (block validation, finalization, cross-chain communication) become impossible

**Protocol Damage:**
- Indefinite blockchain freeze requiring emergency intervention or hard fork
- Loss of network liveness and availability for all users
- Potential economic losses from halted transactions and frozen funds
- Severe reputational damage to the blockchain network

**Affected Parties:**
- All network participants (users, dApps, validators)
- The entire AElf mainchain or affected sidechain

This is **HIGH severity** because it completely disables the consensus mechanism, affecting the entire blockchain network and requiring emergency measures to resolve.

## Likelihood Explanation

**Attacker Capabilities Required:**
1. Lock 100,000 ELF tokens as candidate registration deposit
2. Acquire or coordinate sufficient voting power to place the empty pubkey in the top N miners (typically requires millions of locked ELF tokens depending on network participation)

**Attack Complexity:**
- **Low technical complexity**: Single contract call to register empty pubkey, standard voting operations
- **High economic cost**: Requires substantial capital (100K ELF deposit + voting power)
- **Medium coordination**: Can be executed by single wealthy actor or requires coordinating multiple voters

**Feasibility Conditions:**
- Attacker must either control significant voting power directly or manipulate voters
- Voting period allows accumulation of votes over time
- Network must not detect and mitigate the empty candidate before term transition

**Probability Assessment:**
**MEDIUM likelihood** because the entry point is unrestricted (public method) and while the economic barrier is high, it remains feasible for well-funded attackers. The one-time cost can cause persistent DoS until fixed, and there is no technical complexity barrier.

## Recommendation

Add pubkey length validation in the `AnnounceElectionFor` method before processing:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // Add validation
    Assert(pubkeyBytes.Length > 0, "Pubkey cannot be empty.");
    Assert(pubkeyBytes.Length == 33 || pubkeyBytes.Length == 65, "Invalid pubkey length.");
    
    var address = Address.FromPublicKey(pubkeyBytes);
    AnnounceElection(pubkeyBytes);
    // ... rest of method
}
```

Additionally, add a defensive check in `GenerateFirstRoundOfNewTerm` to prevent array access exceptions:

```csharp
var sortedMiners =
    (from obj in Pubkeys
            .Where(miner => miner.Length > 0) // Add filter
            .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
        orderby obj.Value descending
        select obj.Key).ToList();
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPubkeyCandidate_CausesConsensusFailure()
{
    // 1. Register candidate with empty pubkey
    var result = await ElectionContractStub.AnnounceElectionFor.SendAsync(
        new AnnounceElectionForInput
        {
            Pubkey = "", // Empty string
            Admin = DefaultSender
        });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 2. Vote for the empty candidate
    var voteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = "",
        Amount = 1000_00000000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(90)
    });
    
    voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 3. Simulate term transition - this should throw IndexOutOfRangeException
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // This will crash when trying to generate first round
    Should.Throw<Exception>(() => 
    {
        var minerList = new MinerList { Pubkeys = { victories.Value } };
        minerList.GenerateFirstRoundOfNewTerm(4000, TimestampHelper.GetUtcNow());
    });
}
```

## Notes

This vulnerability demonstrates a critical input validation failure at the intersection of the Election and Consensus contracts. The lack of pubkey length validation allows an economically motivated attacker to permanently halt consensus by registering and promoting an invalid candidate. The fix requires defense-in-depth: input validation at registration, voting validation, and defensive programming in the consensus layer to handle malformed data gracefully.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-126)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L313-318)
```csharp
    private void AssertValidCandidateInformation(CandidateInformation candidateInformation)
    {
        Assert(candidateInformation != null, "Candidate not found.");
        // ReSharper disable once PossibleNullReferenceException
        Assert(candidateInformation.IsCurrentCandidate, "Candidate quited election.");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-425)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-19)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```
