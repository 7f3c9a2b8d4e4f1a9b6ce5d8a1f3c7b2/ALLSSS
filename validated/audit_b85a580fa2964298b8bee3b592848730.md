# Audit Report

## Title
VoteId Reuse Vulnerability in Delegated Voting Enables Vote Inflation and State Inconsistency

## Summary
The Vote contract's `Vote()` function lacks validation to prevent reusing the same `VoteId` in delegated voting mode (IsLockToken=false). This allows sponsors to call `Vote()` multiple times with identical VoteId values, causing each call to increment voting results while only storing the final record, creating inconsistent state between VotingRecords and VotingResults.

## Finding Description

The vulnerability exists in the vote processing logic where VoteId uniqueness is not enforced for delegated voting scenarios.

In the `Vote()` function, when processing votes for delegated voting items (IsLockToken=false), the validation logic only checks that the sponsor is the caller and that VoteId is non-null. [1](#0-0) 

The voting record is stored by directly assigning to the state mapping, which overwrites any existing record with the same VoteId without first checking for existence. [2](#0-1) 

Subsequently, `UpdateVotingResult()` unconditionally adds the vote amount to the results, increments the voters count, and adds to the total votes amount - regardless of whether this VoteId was previously counted. [3](#0-2) 

For delegated voting items, no tokens are locked since the locking logic only executes when IsLockToken is true. [4](#0-3) 

This creates a state inconsistency where:
- Multiple calls with the same VoteId add to VotingResults multiple times
- Only the final VotingRecord is stored
- VotingResults.VotesAmount exceeds the actual sum of VotingRecord amounts
- Withdrawal operations cannot properly clean up the inflated vote counts

## Impact Explanation

**Integrity Violation**: The fundamental invariant that VotingResults should match the sum of VotingRecords is violated. This breaks the trustworthiness of voting data stored in the contract. The state mappings become inconsistent, with VotingResults tracking phantom votes that don't correspond to actual VotingRecords.

**Vote Inflation**: A sponsor can inflate vote counts arbitrarily without any token backing. For example, calling Vote(VoteId="X", Amount=1000, Option="A") followed by Vote(VoteId="X", Amount=2000, Option="B") results in total votes of 3000 in VotingResults but only one record with amount 2000 in VotingRecords.

**Broken Withdrawal**: The Withdraw function retrieves the VotingRecord by VoteId and subtracts only that recorded amount from VotingResults. [5](#0-4)  Since only the final record exists, earlier vote amounts that were added to VotingResults become phantom votes that can never be withdrawn.

**Impact on Calling Contracts**: Any legitimate contract using delegated voting that has a bug causing VoteId reuse would suffer from vote inflation. While well-designed contracts like the Election contract protect against this by validating VoteId uniqueness themselves [6](#0-5) , the lack of validation in the Vote contract creates a dangerous footgun for contract developers.

## Likelihood Explanation

**High Exploitability**: The Register() function is public, allowing any actor to create a voting item with IsLockToken=false and become the sponsor. [7](#0-6) 

The sponsor then has complete control over VoteId and Amount parameters when calling Vote() for their delegated voting item. No special privileges or complex state manipulation is required - just sequential transactions reusing the same VoteId.

**No Economic Cost**: Since IsLockToken=false means no tokens are locked, there is no economic barrier to exploitation. The sponsor can inflate vote counts without locking any collateral.

**Detection Difficulty**: The inflated vote counts appear legitimate in the VotingResult state. Only forensic comparison of individual VotingRecords against aggregated VotingResults would reveal the discrepancy.

The primary impact is limited to voting items created by the attacker themselves, unless external systems rely on these results or legitimate contracts have bugs that cause VoteId reuse.

## Recommendation

Add VoteId uniqueness validation in the `AssertValidVoteInput` method for delegated voting:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    if (!votingItem.IsLockToken)
    {
        Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
        Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
        Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        // ADD THIS CHECK:
        Assert(State.VotingRecords[input.VoteId] == null, "Vote Id already exists.");
    }
    else
    {
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        input.Voter = Context.Sender;
        input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
    }

    return votingItem;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteId_Reuse_Causes_Vote_Inflation()
{
    // Setup: Register a delegated voting item (IsLockToken=false)
    var votingItemId = await RegisterDelegatedVotingItem();
    
    var voteId = HashHelper.ComputeFrom("reused_vote_id");
    var voter = DefaultSender;
    
    // First vote with VoteId="X", Amount=1000, Option="A"
    await VoteContract.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = voteId,
        Voter = voter,
        Amount = 1000,
        Option = "OptionA"
    });
    
    // Second vote with SAME VoteId="X", Amount=2000, Option="B"
    await VoteContract.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = voteId,
        Voter = voter,
        Amount = 2000,
        Option = "OptionB"
    });
    
    // Verify state inconsistency
    var votingRecord = await VoteContract.GetVotingRecord.CallAsync(voteId);
    var votingResult = await VoteContract.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    
    // VotingRecord only has the final amount
    votingRecord.Amount.ShouldBe(2000);
    votingRecord.Option.ShouldBe("OptionB");
    
    // But VotingResults has both amounts added
    votingResult.VotesAmount.ShouldBe(3000); // 1000 + 2000
    votingResult.VotersCount.ShouldBe(2);
    
    // Withdrawal only removes 2000, leaving 1000 phantom votes
    await VoteContract.Withdraw.SendAsync(new WithdrawInput { VoteId = voteId });
    
    votingResult = await VoteContract.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    
    // Phantom votes remain
    votingResult.VotesAmount.ShouldBe(1000); // Should be 0, but 1000 remains
}
```

## Notes

The vulnerability is confirmed through code analysis:

1. **No VoteId uniqueness check**: The validation for delegated voting only checks sponsor authorization and non-null values, but never verifies if the VoteId has been used before.

2. **State overwrite behavior**: Direct assignment to `State.VotingRecords[input.VoteId]` overwrites any existing record without detection.

3. **Unconditional result updates**: The `UpdateVotingResult()` function always adds to totals, creating cumulative inflation when the same VoteId is reused.

4. **Incomplete cleanup**: Withdrawal only subtracts the final recorded amount, leaving phantom votes from earlier calls with the same VoteId.

While the primary AElf system contract (Election) implements its own VoteId uniqueness check, the Vote contract itself should enforce this constraint to prevent misuse by other integrators or future contracts.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L193-220)
```csharp
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-433)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```
