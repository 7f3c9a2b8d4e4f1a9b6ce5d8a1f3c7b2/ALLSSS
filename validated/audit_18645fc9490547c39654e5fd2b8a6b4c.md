# Audit Report

## Title
Missing Authorization on SetPrimaryTokenSymbol Allows Permanent Primary Token Hijacking

## Summary
The `SetPrimaryTokenSymbol()` function in the MultiToken contract lacks any authorization check, allowing any address to permanently set the chain's primary token symbol to an arbitrary valid token. This creates a critical initialization vulnerability where an attacker can front-run legitimate chain setup, causing permanent breakage of transaction fee calculations, contract deployment authorization, and fee token weight validation with no recovery mechanism.

## Finding Description

The `SetPrimaryTokenSymbol()` function performs only two validations before permanently setting the chain's primary token symbol: [1](#0-0) 

The function verifies that (1) the primary token hasn't been set yet, and (2) the input symbol corresponds to a valid existing token. **Critically, there is no authorization check** on `Context.Sender` to verify who can call this privileged function.

This stands in stark contrast to other administrative functions in the same contract that properly implement authorization controls: [2](#0-1) 

The primary token symbol is used throughout critical system operations:

**Transaction fee calculation** - The size fee charging logic directly retrieves and uses the primary token symbol: [3](#0-2) 

**Contract deployment authorization** - The Genesis contract uses primary token comparison to determine deployment permissions: [4](#0-3) 

**Fee token weight validation** - Setting alternative fee tokens requires the primary token to be included with weight=1: [5](#0-4) 

During normal initialization, `SetPrimaryTokenSymbol` is called by system contracts as part of genesis transaction sequences: [6](#0-5) 

However, the vulnerability exists because **after TokenContract deployment but before initialization completes**, or in any scenario where the primary token is not set atomically during deployment, the function remains publicly callable without any authorization checks. Any address monitoring the chain initialization can front-run the legitimate setup call.

## Impact Explanation

**Critical System Breakage:**

1. **Transaction Fee Mechanism Failure**: If an incorrect token is set as primary, the fee calculation logic will charge transaction size fees in the wrong token. This could enable free transactions (if users don't hold the wrong primary token) or break fee collection entirely, as the early-exit checks at lines 29-32 and 59-62 of TokenContract_Fees.cs only skip fees if the primary token is null, not if it's wrong.

2. **Contract Deployment Authorization Bypass**: The deployment authorization check compares the primary token symbol against the native symbol to determine if the deployer needs Parliament whitelist permission. Setting an incorrect primary token can manipulate this security control, either incorrectly requiring whitelist permission on public chains or incorrectly allowing unrestricted deployment on exclusive side chains.

3. **Permanent Irreversible Lock**: The one-time-only constraint (`State.ChainPrimaryTokenSymbol.Value == null`) means that once an attacker sets an incorrect primary token, it **cannot be corrected through any mechanism** - the chain is permanently misconfigured with no governance recovery path.

4. **Fee Configuration Validation Failure**: The `SetSymbolsToPayTxSizeFee` function requires the primary token to be included in the fee token list with a 1:1 weight ratio. If the wrong primary token is set, this validation will fail or pass incorrectly, breaking the ability to configure alternative fee tokens properly.

**Affected Parties:**
- All users attempting to submit transactions face incorrect fee charging
- Chain operators cannot properly configure the fee system or deployment controls  
- Governance has no mechanism to recover from the attack once executed

**Severity Justification:**
This is HIGH severity because it enables permanent operational denial-of-service of critical chain functions (transaction processing, contract deployment, fee configuration) with no recovery mechanism, affecting the entire chain ecosystem.

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker only needs the ability to monitor chain initialization and submit transactions during the vulnerability window
- No special privileges, keys, or system access required
- Must have knowledge of when the TokenContract is deployed but before `SetPrimaryTokenSymbol` is called

**Attack Complexity:**
- LOW - Requires a single transaction call with any valid token symbol as input
- Any token that exists on the chain can be used (including resource tokens)
- No complex state manipulation, race conditions, or multi-step exploitation required

**Feasibility Conditions:**
The vulnerability window exists in several realistic scenarios:
- During genesis block creation, if initialization transactions are not atomic
- If the initialization sequence fails partway through and requires retry
- Custom or manual initialization sequences that deploy contracts separately from calling initialization methods
- Any gap between TokenContract deployment and the `SetPrimaryTokenSymbol` call

**Detection and Prevention:**
- The attack is trivially detectable (the `ChainPrimaryTokenSymbolSet` event is emitted), but the damage is **irreversible** once the transaction is executed
- No existing test coverage validates that unauthorized addresses are blocked from calling this function

**Probability Assessment:**
MEDIUM-HIGH likelihood during the chain initialization phase, particularly for:
- New side chain deployments
- Custom initialization sequences  
- Any scenario where initialization is not completed in a single atomic transaction

## Recommendation

Add proper authorization to the `SetPrimaryTokenSymbol` function to restrict it to privileged system contracts only. The most secure approach is to require that the caller is the Genesis contract (Contract Zero) or the Economic contract:

```csharp
public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
{
    // Add authorization check
    var genesisContract = Context.GetZeroSmartContractAddress();
    var economicContract = Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName);
    Assert(Context.Sender == genesisContract || Context.Sender == economicContract, 
        "No permission to set primary token symbol.");
    
    Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

    State.ChainPrimaryTokenSymbol.Value = input.Symbol;
    Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
    return new Empty();
}
```

Alternatively, implement an initialization flag similar to other system contracts and only allow this function to be called during the initialization phase before the chain is marked as initialized.

## Proof of Concept

```csharp
[Fact]
public async Task UnauthorizedAddress_CanSetPrimaryTokenSymbol_Vulnerability()
{
    // Create a token that an attacker will use as the "wrong" primary token
    var attackerToken = "ATTACK";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = attackerToken,
        TokenName = "Attacker Token",
        TotalSupply = 100_000_000_00000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true,
        Owner = DefaultSender
    });
    
    // Simulate attacker (any random address) calling SetPrimaryTokenSymbol
    var attackerAddress = Accounts[1].Address;
    var attackerStub = GetTokenContractStub(Accounts[1].KeyPair);
    
    // VULNERABILITY: Any address can set the primary token symbol
    var result = await attackerStub.SetPrimaryTokenSymbol.SendAsync(
        new SetPrimaryTokenSymbolInput { Symbol = attackerToken }
    );
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify the wrong token is now permanently set as primary
    var primaryToken = await TokenContractStub.GetPrimaryTokenSymbol.CallAsync(new Empty());
    primaryToken.Value.ShouldBe(attackerToken);
    
    // IMPACT: Cannot be changed - legitimate initialization now fails
    var legitimateResult = await TokenContractStub.SetPrimaryTokenSymbol.SendWithExceptionAsync(
        new SetPrimaryTokenSymbolInput { Symbol = NativeTokenInfo.Symbol }
    );
    legitimateResult.TransactionResult.Error.ShouldContain("Failed to set primary token symbol");
    
    // IMPACT: Transaction fee calculation now uses wrong token
    // IMPACT: Contract deployment authorization check now uses wrong comparison
    // IMPACT: Chain is permanently misconfigured with no recovery
}
```

This test demonstrates that any address can successfully call `SetPrimaryTokenSymbol` and permanently lock the primary token to an incorrect value, with no authorization check preventing the attack.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L139-147)
```csharp
    public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
    {
        Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

        State.ChainPrimaryTokenSymbol.Value = input.Symbol;
        Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L462-467)
```csharp
    public override Empty AddAddressToCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap[input] = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L375-390)
```csharp
    private bool ChargeSizeFee(ChargeTransactionFeesInput input, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {

        Context.LogDebug(() => "ChargeSizeFee Start");

        //If delegation != null,from address->delegateeAddress
        // Size Fee is charged in primary token, elf.
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
        //Get primary token balance
        GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
            out var symbolChargedForBaseFee, out var amountChargedForBaseFee, out var amountChargedForBaseAllowance,
            out var availableBalance, out var availableAllowance);
        var txSizeFeeAmount = input.TransactionSizeFee;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L621-642)
```csharp
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L85-93)
```csharp
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol
                    }.ToByteString()
                });
            }
```
