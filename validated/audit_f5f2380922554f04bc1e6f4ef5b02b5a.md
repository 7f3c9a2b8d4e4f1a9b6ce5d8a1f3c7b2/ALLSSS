# Audit Report

## Title
Privilege Escalation via Replacement Chain Break When Reusing Initial Miner Replacement Pubkeys

## Summary
The `PerformReplacement` function unconditionally overwrites critical state mappings (`CandidateReplacementMap` and `InitialPubkeyMap`) without validating whether the new pubkey has already been used as a replacement target. This allows an attacker controlling any candidate to hijack admin control over replacement pubkeys created when initial miners rotate their keys, resulting in unauthorized privilege escalation and broken replacement chain integrity.

## Finding Description

The vulnerability exists in the `PerformReplacement` private function where state maps are unconditionally overwritten without checking if the `newPubkey` parameter has previously been used as a replacement target: [1](#0-0) 

The root cause is a combination of three design issues:

**1. Initial State Separation**: During contract initialization, initial miners are NOT automatically added to the Candidates list: [2](#0-1) 

**2. Conditional Candidate Addition**: When replacing a pubkey, the new pubkey is only added to Candidates if the old pubkey was already in Candidates: [3](#0-2) 

Similarly for InitialMiners: [4](#0-3) 

**3. Insufficient Validation**: The only checks preventing pubkey reuse validate that the new pubkey is not already a candidate and not banned: [5](#0-4) [6](#0-5) 

**Attack Scenario:**

When initial miner A (controlled by AdminA) is replaced by pubkey B:
- B is added to InitialMiners but NOT to Candidates (because A was not in Candidates)
- Only A is banned; B remains unbanned
- `InitialPubkeyMap[B] = A` is set

An attacker controlling candidate X (with admin AdminX) can then call `ReplaceCandidatePubkey(X, B)`. This passes all validation checks because:
- B is NOT in Candidates (only in InitialMiners)  
- B is NOT banned (only A was banned)

The call to `PerformReplacement(X, B)` then overwrites:
- `CandidateReplacementMap[B] = X` (was A)
- `InitialPubkeyMap[B] = X` (was A)

**Admin Resolution Corruption**: The `GetCandidateAdmin` function resolves admin control by looking up the initial pubkey via `InitialPubkeyMap`: [7](#0-6) 

After the attack, `GetCandidateAdmin(B)` returns `CandidateAdmins[X]` (AdminX) instead of `CandidateAdmins[A]` (AdminA), resulting in unauthorized admin control transfer.

## Impact Explanation

**Authorization Bypass Severity: HIGH**

This vulnerability enables privilege escalation without requiring compromise of any trusted role. The concrete harms include:

1. **Loss of Legitimate Control**: The original admin (AdminA) permanently loses control over their replacement pubkey (B)

2. **Unauthorized Admin Powers**: The attacker (AdminX) gains ability to:
   - Call `SetCandidateAdmin` to modify B's admin: [8](#0-7) 
   
   - Call `ReplaceCandidatePubkey` to replace B with another pubkey under attacker's control
   - Execute any admin-restricted operations associated with the pubkey

3. **Replacement Chain Corruption**: The historical mapping that B replaced A is permanently lost, breaking audit trails and the replacement tracking mechanism: [9](#0-8) 

4. **Consensus Integrity Risk**: If B is an active validator/miner, the wrong party gains control over a consensus participant, potentially impacting network security

This violates the critical security invariant that admin control should remain with the rightful owner through the entire replacement chain.

## Likelihood Explanation

**Likelihood Assessment: MEDIUM-HIGH**

**Attacker Prerequisites:**
- Must control a candidate (requires 100,000 ELF stake via `AnnounceElection`)
- Must identify an initial miner that has replaced their pubkey
- No special permissions required beyond candidate admin rights

**Attack Complexity: LOW**
- Replacement events are publicly logged via the `CandidatePubkeyReplaced` event
- Candidates and InitialMiners lists are publicly queryable
- Attack executes in a single transaction

**Realistic Trigger Conditions:**
1. Initial miners performing key rotation is a legitimate operational need for security
2. The vulnerability window opens immediately when an initial miner replaces their key
3. The window persists indefinitely (initial miner replacement pubkeys cannot announce election)

**Economic Viability:**
- Cost: 100,000 ELF stake to become a candidate
- Benefit: Control over an initial miner's validator operations and associated privileges
- The attacker sacrifices their candidate but gains a potentially more valuable asset

**Probability:** Initial miner key rotation is expected operational behavior, creating persistent vulnerability windows that can be exploited by any candidate.

## Recommendation

Add validation in `ReplaceCandidatePubkey` to prevent reusing pubkeys that have already been used as replacement targets:

```csharp
// Before line 184 in ReplaceCandidatePubkey
Assert(State.CandidateReplacementMap[input.NewPubkey] == null, 
    "New pubkey has already been used as a replacement.");
```

This ensures that once a pubkey is used as a replacement target, it cannot be reused in subsequent replacements, preserving the integrity of replacement chains and admin mappings.

Alternatively, add validation to check if the new pubkey exists in InitialMiners but not in Candidates:
```csharp
var initialMiners = State.InitialMiners.Value;
var isInInitialMiners = initialMiners.Value.Contains(newPubkeyBytes);
var isInCandidates = candidates.Value.Contains(newPubkeyBytes);
Assert(!(isInInitialMiners && !isInCandidates), 
    "Cannot reuse a replacement pubkey that is an initial miner but not a candidate.");
```

## Proof of Concept

```csharp
[Fact]
public async Task PrivilegeEscalation_ReuseInitialMinerReplacement_Test()
{
    // Setup: Get initial miner A and its admin
    var initialMinerA = InitialCoreDataCenterKeyPairs.First();
    var adminA = ValidationDataCenterKeyPairs.First();
    var adminAAddress = Address.FromPublicKey(adminA.PublicKey);
    
    // Setup: Set admin for initial miner A
    var parliamentStub = GetParliamentContractTester(BootMinerKeyPair);
    await parliamentStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = initialMinerA.PublicKey.ToHex(),
        Admin = adminAAddress
    });
    
    // Step 1: AdminA replaces initial miner A with pubkey B
    var pubkeyB = ValidationDataCenterKeyPairs.Skip(1).First();
    var adminAStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, adminA);
    await adminAStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = initialMinerA.PublicKey.ToHex(),
        NewPubkey = pubkeyB.PublicKey.ToHex()
    });
    
    // Verify: AdminA controls pubkey B
    var adminBeforeAttack = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = pubkeyB.PublicKey.ToHex() });
    adminBeforeAttack.ShouldBe(adminAAddress);
    
    // Step 2: Attacker announces candidate X
    var attackerCandidate = ValidationDataCenterKeyPairs.Skip(2).First();
    var attackerAdmin = ValidationDataCenterKeyPairs.Skip(3).First();
    var attackerAdminAddress = Address.FromPublicKey(attackerAdmin.PublicKey);
    await AnnounceElectionAsync(attackerCandidate, attackerAdminAddress);
    
    // Step 3: Attacker replaces their candidate X with pubkey B
    var attackerStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, attackerAdmin);
    await attackerStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = attackerCandidate.PublicKey.ToHex(),
        NewPubkey = pubkeyB.PublicKey.ToHex()
    });
    
    // Verify: Attacker now controls pubkey B (Privilege Escalation!)
    var adminAfterAttack = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = pubkeyB.PublicKey.ToHex() });
    adminAfterAttack.ShouldBe(attackerAdminAddress); // Changed from adminAAddress!
    
    // Verify: AdminA has lost control - cannot perform admin operations
    var result = await adminAStub.QuitElection.SendAsync(
        new StringValue { Value = pubkeyB.PublicKey.ToHex() });
    result.TransactionResult.Error.ShouldContain("No permission");
    
    // Verify: Attacker can perform admin operations
    await attackerStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = pubkeyB.PublicKey.ToHex(),
        Admin = attackerAdminAddress // Attacker can change admin
    });
}
```

This test demonstrates the complete privilege escalation attack where an attacker gains unauthorized admin control over an initial miner's replacement pubkey by exploiting the unconditional overwrite in `PerformReplacement`.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L26-38)
```csharp
        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L177-178)
```csharp
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-197)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L221-226)
```csharp
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L282-289)
```csharp
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-42)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L75-88)
```csharp
    /// <summary>
    ///     Pubkey -> Newest pubkey
    /// </summary>
    public MappedState<string, string> CandidateReplacementMap { get; set; }

    /// <summary>
    ///     Pubkey -> Initial pubkey (First round initial miner pubkey or first announce election pubkey)
    /// </summary>
    public MappedState<string, string> InitialPubkeyMap { get; set; }

    /// <summary>
    ///     Initial pubkey -> Newest pubkey
    /// </summary>
    public MappedState<string, string> InitialToNewestPubkeyMap { get; set; }
```
