# Audit Report

## Title
LIB Height Can Decrease During NextRound and NextTerm Transitions Due to Missing Validation

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) height during `NextRound` and `NextTerm` transitions, allowing any elected miner to decrease the LIB height and violate the fundamental consensus invariant that finality can only move forward.

## Finding Description

The vulnerability consists of three interconnected defects in the consensus validation flow:

**1. Missing LIB Validation for NextRound/NextTerm**

The validation logic in `ValidateBeforeExecution` only applies `LibInformationValidationProvider` for `UpdateValue` behavior. For `NextRound` and `NextTerm` behaviors, this critical validator is omitted: [1](#0-0) 

The `LibInformationValidationProvider` contains the check that prevents LIB from decreasing by validating that the provided round's `ConfirmedIrreversibleBlockHeight` is not less than the base round's value: [2](#0-1) 

**2. Hash Validation Excludes ConfirmedIrreversibleBlockHeight**

The `GetCheckableRound` method used for consensus hash validation explicitly excludes LIB-related fields. It only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`: [3](#0-2) 

This allows `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` to be modified without detection during the hash comparison in `ValidateConsensusAfterExecution`: [4](#0-3) 

**3. Direct State Save Without LIB Validation**

The `ProcessNextRound` method converts the `NextRoundInput` to a Round object and saves it directly without any LIB validation: [5](#0-4) 

The `NextRoundInput.ToRound()` method includes the LIB fields provided by the caller: [6](#0-5) 

The Round is then saved directly via `AddRoundInformation`: [7](#0-6) 

**Attack Execution Path:**

1. When generating next round information normally, the current LIB is copied to the new round: [8](#0-7) 

2. A malicious miner scheduled to produce a `NextRound` or `NextTerm` block constructs a `NextRoundInput` with a decreased `ConfirmedIrreversibleBlockHeight` value

3. The miner calls the public `NextRound` method with this malicious input: [9](#0-8) 

4. The modified block passes validation because:
   - `LibInformationValidationProvider` is not applied for NextRound/NextTerm
   - Hash validation doesn't include the modified LIB field
   - No assertions check LIB monotonicity in the processing logic

5. The manipulated Round is saved to state with the decreased LIB height

## Impact Explanation

**Critical Consensus Invariant Violation:**
- LIB (Last Irreversible Block) represents the blockchain finality boundary - blocks below this height are considered permanently finalized and irreversible
- Decreasing LIB violates the fundamental consensus guarantee that finality only moves forward
- This breaks the core security model where confirmed blocks cannot be reorganized

**Cross-Chain Security Impact:**
- Cross-chain indexing and verification rely on LIB for security guarantees
- Decreasing LIB could invalidate previously accepted cross-chain transactions
- May enable double-spending attacks across chains if transactions were confirmed based on the original LIB

**Systemic Impact:**
- Applications and users relying on block finality guarantees lose security assurances
- Smart contracts depending on finality (e.g., time-locked operations, irreversible settlements) become vulnerable
- Treasury distributions, profit calculations, and other consensus-dependent operations may be compromised

The severity is **CRITICAL** because it breaks a fundamental blockchain invariant that underpins the entire security model.

## Likelihood Explanation

**Attacker Requirements:**
- Attacker must be an elected miner in the consensus miner list
- Must be scheduled to produce a NextRound or NextTerm block during their assigned time slot
- No additional privileges beyond normal miner status required

**Attack Complexity:**
- **Very Low**: Simply construct a `NextRoundInput` with a decreased `ConfirmedIrreversibleBlockHeight` field
- No cryptographic manipulation required
- No complex state race conditions to exploit
- The attack is deterministic and reproducible

**Feasibility:**
- NextRound transitions occur regularly (every round, typically every few minutes)
- NextTerm transitions occur periodically (every term, typically daily/weekly)
- Any miner will eventually be scheduled for these transitions
- The only precondition check is miner list membership, which malicious miners satisfy

**Detection:**
- No validation checks will catch the manipulation
- No events or logs specifically track LIB monotonicity violations
- Attack succeeds silently unless external monitoring tracks LIB progression
- Standard consensus validation passes the malicious block

The likelihood is **HIGH** because any malicious miner can execute this attack with 100% success rate during their regularly scheduled NextRound/NextTerm block production.

## Recommendation

Add `LibInformationValidationProvider` to the validation providers for NextRound and NextTerm behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

This ensures that the LIB monotonicity check is applied consistently across all consensus behaviors that can modify the LIB height in state.

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Can_Decrease_Via_NextRound()
{
    // Setup: Initialize consensus with initial LIB height of 100
    var initialRound = GenerateFirstRound();
    initialRound.ConfirmedIrreversibleBlockHeight = 100;
    await InitialConsensus(initialRound);
    
    // Attacker is an elected miner
    var attackerKeyPair = MinerKeyPairs[0];
    
    // Generate next round with DECREASED LIB (from 100 to 50)
    var maliciousNextRound = GenerateNextRound(initialRound);
    maliciousNextRound.ConfirmedIrreversibleBlockHeight = 50; // DECREASED!
    
    var nextRoundInput = NextRoundInput.Create(maliciousNextRound, GenerateRandomNumber());
    
    // Execute NextRound transaction as attacker
    var result = await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // PASSES!
    
    // Verify LIB decreased in state
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.ConfirmedIrreversibleBlockHeight.ShouldBe(50); // VULNERABILITY: LIB went backwards!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-113)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-71)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
