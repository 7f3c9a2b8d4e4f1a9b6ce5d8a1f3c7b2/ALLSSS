# Audit Report

## Title
Unfair Extra Block Producer Selection Due to Unvalidated TuneOrderInformation Manipulation

## Summary
Miners can manipulate extra block producer selection by providing arbitrary `TuneOrderInformation` values in `UpdateValue` transactions without any validation. This allows creation of duplicate `FinalOrderOfNextRound` values that cause gaps in the mining order sequence, triggering a `.First()` fallback that systematically favors miners with the lowest order values, resulting in unfair consensus reward distribution.

## Finding Description

The AEDPoS consensus mechanism contains a critical validation gap that allows miners to manipulate the extra block producer selection process through unvalidated `TuneOrderInformation` fields in `UpdateValue` transactions.

**Technical Root Cause:**

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` fields, completely ignoring the `TuneOrderInformation` content [1](#0-0) . This allows miners to provide arbitrary values that are directly applied to all miners' `FinalOrderOfNextRound` without any checks [2](#0-1) .

**Attack Mechanism:**

1. A malicious miner calls `UpdateValue` with crafted `TuneOrderInformation` that sets multiple miners to identical `FinalOrderOfNextRound` values (e.g., both Miner A and Miner B to order 3)

2. When `GenerateNextRoundInformation` processes the next round, it sorts miners by `FinalOrderOfNextRound` in ascending order and assigns each their order value [3](#0-2) 

3. The duplicate orders create gaps in the sequence - if orders are [1, 3, 3, 4] for 5 miners, the `occupiedOrders` list contains these values, and `ableOrders` becomes [2, 5], creating a gap at order 2 [4](#0-3) 

4. When `CalculateNextExtraBlockProducerOrder` calculates a value that falls in this gap, no miner has that order, causing the `FirstOrDefault` to return null [5](#0-4) 

5. The fallback uses `.First()` on the dictionary values, which returns the first inserted miner (those with lowest `FinalOrderOfNextRound` due to the OrderBy on line 26) [6](#0-5) 

**Why Existing Protections Fail:**

The `NextRoundMiningOrderValidationProvider` that could detect duplicate orders is only applied to `NextRound` behavior, not `UpdateValue` [7](#0-6) . Even if it were applied, it uses `.Distinct()` on `MinerInRound` objects which performs reference equality checks, not value equality on the `FinalOrderOfNextRound` field [8](#0-7) .

Furthermore, `ValidateConsensusAfterExecution` has a broken validation where it calls `RecoverFromUpdateValue` which returns the modified `currentRound` object, then compares this object's hash to itself, causing the validation to always pass [9](#0-8) [10](#0-9) .

## Impact Explanation

**High Severity - Consensus Reward Manipulation**

This vulnerability directly impacts consensus fairness and reward distribution:

- **Reward Misallocation**: Extra block producers receive additional block production rewards. By systematically biasing selection toward miners with lowest `FinalOrderOfNextRound`, attackers gain unfair economic advantage

- **Consensus Integrity Violation**: The extra block producer role is designed to be distributed fairly based on cryptographic randomness from miner signatures. This manipulation creates deterministic bias, undermining the core fairness guarantee of the AEDPoS consensus mechanism

- **Cumulative Effect**: Over many rounds, the biased selection compounds, creating significant imbalances in reward distribution that can affect network decentralization

- **Protocol-Level Impact**: While no user funds are directly stolen, the protocol's consensus fairness guarantee is broken, which is a critical security property for a blockchain's legitimacy

## Likelihood Explanation

**High Likelihood**

- **Easy Execution**: Any elected miner can execute this attack by modifying their node to generate `UpdateValue` transactions with crafted `TuneOrderInformation`. The public `UpdateValue` method accepts arbitrary input [11](#0-10) 

- **No Validation Barrier**: The complete absence of `TuneOrderInformation` validation means the attack succeeds immediately without any cryptographic or logical barriers

- **Low Detection Risk**: The manipulation appears as normal consensus behavior since `TuneOrderInformation` is an expected field. Without explicit monitoring of order distributions, detection is difficult

- **Repeatable**: The attack can be executed in every round without triggering any alarms or penalties

- **Verified Permission**: Only miners in the current or previous round can call `UpdateValue`, which is within the threat model since miners are the attack vector [12](#0-11) 

## Recommendation

**Implement Strict TuneOrderInformation Validation**

Add validation in `UpdateValueValidationProvider` to verify that `TuneOrderInformation` values:

1. Match the expected values derived from the current round state (comparing against what `ExtractInformationToUpdateConsensus` would produce)
2. Do not create duplicate `FinalOrderOfNextRound` values across all miners
3. Only include miners that actually have order conflicts requiring tuning

Additionally, fix the broken `ValidateConsensusAfterExecution` logic to properly compare the expected Round state against the actual post-execution state by avoiding the self-comparison issue in the hash check.

Example validation logic to add:
```csharp
private bool ValidateTuneOrderInformation(ConsensusValidationContext validationContext)
{
    var providedTuneInfo = validationContext.ExtraData.Round.RealTimeMinersInformation
        .Where(m => m.Value.FinalOrderOfNextRound != m.Value.SupposedOrderOfNextRound)
        .ToDictionary(m => m.Key, m => m.Value.FinalOrderOfNextRound);
    
    // Check for duplicates
    var orders = providedTuneInfo.Values.ToList();
    if (orders.Count != orders.Distinct().Count())
        return false;
    
    // Verify against base round expectations
    var expectedTuneInfo = validationContext.BaseRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
        .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
    
    return providedTuneInfo.SequenceEqual(expectedTuneInfo);
}
```

## Proof of Concept

A proof of concept would involve:

1. Set up a test network with multiple miners
2. Modify miner node A to generate `UpdateValue` transactions with `TuneOrderInformation` setting miners B and C to the same `FinalOrderOfNextRound` value
3. Submit the transaction and observe it passes validation
4. In the next round generation, verify that gaps appear in the mining order
5. When extra block producer selection falls in a gap, observe that `.First()` consistently selects the miner with the lowest order
6. Repeat across multiple rounds and measure the disproportionate selection of low-order miners as extra block producers
7. Calculate the unfair reward distribution resulting from the biased selection

The vulnerability is confirmed by code analysis showing the complete absence of validation for `TuneOrderInformation` content combined with the deterministic `.First()` fallback behavior when order gaps exist.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L13-17)
```csharp
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-62)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L63-63)
```csharp
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-86)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L90-101)
```csharp
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-32)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
