# Audit Report

## Title
Secret Sharing Revealed In Values Discarded and Recomputed on Every Call, Wasting Gas

## Summary
During NextRound consensus transitions, the contract performs expensive Shamir's Secret Sharing reconstruction to reveal miners' withheld in values, but writes these revealed values to a non-persisted in-memory copy of the current round. The values are completely discarded when only the separately-created next round is persisted, breaking the anti-withholding protection mechanism and wasting gas on every NextRound transition.

## Finding Description

The consensus contract implements a secret sharing mechanism to prevent miners from withholding their in values, which are critical for consensus randomness generation. During NextRound transitions, `RevealSharedInValues` reconstructs withheld in values using Shamir's Secret Sharing. However, a critical ordering flaw causes these revealed values to be permanently lost.

The execution flow begins when `GetConsensusExtraData` or `GenerateConsensusTransactions` is invoked [1](#0-0) , calling `GetConsensusBlockExtraData` which retrieves `currentRound` from state as a deserialized copy [2](#0-1) .

For NextRound behavior, `GetConsensusExtraDataForNextRound` is invoked [3](#0-2) . This method first creates `nextRound` by calling `GenerateNextRoundInformation` at line 176, then calls `RevealSharedInValues(currentRound, pubkey)` at line 189 [4](#0-3) .

The critical flaw is that `RevealSharedInValues` performs expensive cryptographic operations and writes revealed in values to `currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue` [5](#0-4) , but `nextRound` was already created with fresh `MinerInRound` objects that do NOT copy `PreviousInValue` fields [6](#0-5) .

The method returns `nextRound` (not `currentRound`) [7](#0-6) , which is eventually persisted via `AddRoundInformation` [8](#0-7)  without the revealed in values.

## Impact Explanation

**Consensus Security Impact**: The secret sharing mechanism is designed to prevent miners from withholding their in values during normal block production (UpdateValue behavior). When a miner fails to reveal their in value, other miners should be able to reconstruct it via Shamir's Secret Sharing during the NextRound transition. However, since the revealed values are discarded, miners who withheld their in values cannot be held accountable in NextRound scenarios. This completely breaks the anti-withholding protection for this critical consensus transition, undermining the randomness generation security model.

**Gas Waste Impact**: Every NextRound transition wastes significant computational resources performing Shamir's Secret Sharing reconstruction [9](#0-8) . The computation involves iterating through all miners, reconstructing orders from decrypted pieces, and performing expensive cryptographic operations via `SecretSharingHelper.DecodeSecret`, all producing no persisted result.

**Repeated Call Impact**: Both entry points `GetConsensusExtraData` and `GenerateConsensusTransactions` [10](#0-9)  can be invoked multiple times for the same round, with each invocation recomputing the entire secret sharing reconstruction from scratch, multiplying the gas waste.

## Likelihood Explanation

**Reachability**: The issue is triggered on every NextRound consensus transition through the public ACS4 methods, which are standard entry points called by the consensus system during normal block production flow.

**Frequency**: NextRound transitions occur regularly at the end of each consensus round when the extra block producer generates the transition block. With secret sharing enabled via the configuration contract [11](#0-10) , every such transition wastes gas on this broken computation.

**Preconditions**: The only precondition is that secret sharing must be enabled, which is the intended production mode for preventing in value withholding attacks. No special attacker capabilities or privileges are required—this is a design flaw manifesting during normal consensus operation.

## Recommendation

Move the `RevealSharedInValues` call to occur BEFORE `GenerateNextRoundInformation`, so that revealed values are present in `currentRound` when `nextRound` is generated. Then modify the `Round.GenerateNextRoundInformation` method to copy `PreviousInValue` fields from the current round's miners to the next round's miners:

```csharp
// In GetConsensusExtraDataForNextRound, change order:
RevealSharedInValues(currentRound, pubkey); // Call FIRST
GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

// In Round_Generation.cs, add PreviousInValue copying:
nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
{
    Pubkey = minerInRound.Pubkey,
    Order = order,
    ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
    ProducedBlocks = minerInRound.ProducedBlocks,
    MissedTimeSlots = minerInRound.MissedTimeSlots,
    PreviousInValue = RealTimeMinersInformation[minerInRound.Pubkey].PreviousInValue // ADD THIS
};
```

## Proof of Concept

The vulnerability can be demonstrated by tracing through a NextRound transition with secret sharing enabled:

1. Call `GetConsensusExtraData` with NextRound behavior trigger
2. Observe that `currentRound` is retrieved from state as a copy
3. Observe that `nextRound` is created with new `MinerInRound` objects without `PreviousInValue`
4. Observe that `RevealSharedInValues` writes to the already-discarded `currentRound`
5. Observe that only `nextRound` is returned and persisted
6. Verify that revealed in values are not present in the persisted round

The gas waste can be measured by comparing transaction costs for NextRound transitions with and without the secret sharing computation—the wasted computation provides zero benefit to the persisted state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-74)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }

    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L40-43)
```csharp
            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-189)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L198-203)
```csharp
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-53)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```
