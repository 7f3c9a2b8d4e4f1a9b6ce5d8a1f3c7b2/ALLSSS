# Audit Report

## Title
Missing LIB Validation in NextRound/NextTerm Allows Manipulation of Consensus Irreversible Block Height

## Summary
The `LibInformationValidationProvider` is only applied to `UpdateValue` consensus behavior, leaving `NextRound` and `NextTerm` behaviors without validation of Last Irreversible Block (LIB) height fields. A malicious miner can artificially inflate `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` when producing NextRound or NextTerm blocks, causing the consensus contract to store manipulated LIB values that suppress legitimate LIB updates until real consensus catches up, delaying blockchain finality.

## Finding Description

The AEDPoS consensus contract has a critical validation gap that allows miners to manipulate Last Irreversible Block (LIB) tracking, which is fundamental to blockchain finality guarantees.

**Validation Gap in Consensus Behaviors**

The validation logic in `ValidateBeforeExecution` selectively applies different validation providers based on consensus behavior. For `UpdateValue` behavior, the validation chain includes `LibInformationValidationProvider` that checks LIB fields don't regress. However, for `NextRound` and `NextTerm` behaviors, only `RoundTerminateValidationProvider` is used, which validates round/term number increments but NOT LIB fields. [1](#0-0) 

The `LibInformationValidationProvider` validates that provided LIB values don't decrease below stored values: [2](#0-1) 

**NextRound/NextTerm Include Full LIB Data**

Both `NextRoundInput` and `NextTermInput` include and preserve LIB fields through their `Create()` and `ToRound()` methods: [3](#0-2) [4](#0-3) 

The same pattern exists for `NextTermInput`: [5](#0-4) [6](#0-5) 

**Direct Storage Without Validation**

When processing NextRound, the input is converted to a Round object and stored without validating LIB fields: [7](#0-6) [8](#0-7) 

The `AddRoundInformation` method stores the round directly to state: [9](#0-8) 

**Legitimate LIB Update Suppression**

The LIB calculation and update logic in `ProcessUpdateValue` only advances LIB if the calculated value exceeds the stored value: [10](#0-9) 

The check at line 272 prevents LIB updates when an inflated stored value exceeds the legitimately calculated LIB. The `IrreversibleBlockFound` event is only fired when this condition passes, meaning network-wide finality tracking is suppressed.

**UpdateValue Validation is Ineffective**

The simplified Round used for UpdateValue behavior validation omits LIB fields entirely: [11](#0-10) 

Since `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` are not set in the simplified round, they default to 0, causing the `LibInformationValidationProvider` validation to short-circuit at the first condition check without performing actual validation.

**Attack Execution Path**

1. Miner becomes extra block producer (rotates among miners)
2. System generates NextRound data with legitimate LIB values via `GenerateNextRoundInformation`: [12](#0-11) 
3. Attacker modifies the Round object before creating `NextRoundInput`, inflating LIB values to arbitrary high numbers
4. Block passes validation (no `LibInformationValidationProvider` for NextRound)
5. `ProcessNextRound` stores manipulated values to state
6. Subsequent `ProcessUpdateValue` calls cannot advance LIB due to the suppression check, as the inflated stored value exceeds all legitimately calculated values

## Impact Explanation

**HIGH SEVERITY - Consensus Integrity Violation**

1. **Delayed Finality**: The Last Irreversible Block height is a critical consensus parameter that determines when blocks become irreversible. By artificially inflating this value, legitimate LIB updates calculated from miner consensus are suppressed for an extended period, creating a finality gap where blocks that should become irreversible remain in a reversible state.

2. **Event Suppression**: No `IrreversibleBlockFound` events are fired during the suppression period. This event is consumed by the blockchain service to update the chain's system-wide LIB marker, so the entire network's finality tracking is affected.

3. **Mining Parameter Manipulation**: The inflated LIB directly affects `GetMaximumBlocksCount`, which uses stored LIB values to evaluate blockchain mining status: [13](#0-12) 
   
   This can cause incorrect throttling or allowance of block production based on falsified consensus state.

4. **Cross-Chain Impact**: Cross-chain operations depend on accurate LIB heights for parent/side chain indexing and merkle proof verification. An artificially inflated LIB could cause cross-chain message verification to incorrectly accept or reject proofs.

## Likelihood Explanation

**MEDIUM-HIGH - Feasible for Any Miner**

1. **Accessible Entry Point**: Any valid miner in the current round can execute this attack when they become the extra block producer. The extra block producer role rotates through miners, providing regular opportunities.

2. **Low Attack Requirements**: 
   - Attacker only needs to be a valid miner (standard participation requirement)
   - No special privileges required beyond normal miner capabilities
   - Attack is a simple data modification before transaction creation

3. **No Technical Barriers**: The miner controls the Round object passed to `NextRoundInput.Create()` during transaction generation. Since validation doesn't check LIB fields for NextRound/NextTerm, the malicious transaction will be accepted.

4. **Difficult Detection**: Without comparing the consensus contract's LIB against the blockchain service's LIB or analyzing event logs for gaps in `IrreversibleBlockFound` events, the manipulation is difficult to detect.

5. **Economic Rationality**: Low cost (just modification of header data) with high impact (delays finality for all network participants, potentially enabling double-spend windows or disrupting cross-chain operations).

## Recommendation

Add `LibInformationValidationProvider` to the validation chain for both `NextRound` and `NextTerm` behaviors:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add this
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add this
        break;
}
```

Additionally, ensure that `GenerateNextRoundInformation` is the authoritative source for LIB values in NextRound/NextTerm transitions, and consider adding explicit checks that provided LIB values match expected values from the current round state.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanInflateLIB_ViaNextRound()
{
    // Setup: Advance to a round where LIB has been established
    await BootMinerChangeRoundAsync();
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var legitimateLIB = currentRound.ConfirmedIrreversibleBlockHeight;
    Assert.True(legitimateLIB > 0);
    
    // Attack: Malicious miner creates NextRoundInput with inflated LIB
    var maliciousNextRound = currentRound.Clone();
    maliciousNextRound.RoundNumber++;
    maliciousNextRound.ConfirmedIrreversibleBlockHeight = legitimateLIB + 1000000; // Inflate by 1 million
    maliciousNextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber + 500000;
    
    var maliciousInput = NextRoundInput.Create(maliciousNextRound, GenerateRandomBytes());
    
    // Submit malicious NextRound transaction
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Verify: Inflated LIB is stored
    var updatedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(legitimateLIB + 1000000, updatedRound.ConfirmedIrreversibleBlockHeight);
    
    // Verify: Subsequent UpdateValue cannot advance LIB
    await ProduceNormalBlock(); // This should calculate legitimate LIB
    var roundAfterUpdate = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // LIB remains at inflated value because ProcessUpdateValue check fails
    Assert.Equal(legitimateLIB + 1000000, roundAfterUpdate.ConfirmedIrreversibleBlockHeight);
}
```

## Notes

This vulnerability represents a fundamental gap in consensus validation that allows miners to manipulate a critical finality parameter. While the attack requires the attacker to be a valid miner (with economic stake), the impact on network finality tracking is severe and affects all participants. The fix is straightforward: extend existing LIB validation to cover all consensus behaviors that include LIB fields, not just UpdateValue.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-34)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-37)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);
```
