# Audit Report

## Title
Unvalidated Other Miners' PreviousInValues Allow Cryptographic Commit-Reveal Bypass in Secret Sharing

## Summary
The AEDPoS consensus contract fails to validate `PreviousInValue` entries for other miners during secret sharing, allowing a malicious block producer to set arbitrary values that violate the fundamental commit-reveal cryptographic invariant. While the sender's own `PreviousInValue` is validated against their previous `OutValue` commitment, values for other miners in `input.MinersPreviousInValues` are applied directly to consensus state without cryptographic verification.

## Finding Description

The AEDPoS consensus protocol relies on a commit-reveal scheme where miners commit to random values via `OutValue = Hash(InValue)` in round N, then reveal the preimage as `PreviousInValue` in round N+1. The invariant `Hash(PreviousInValue) == OutValue_from_previous_round` MUST hold for all miners to ensure consensus integrity.

**Vulnerability Flow**:

1. During block production, `UpdateLatestSecretPieces()` sets `PreviousInValue` for other miners from `triggerInformation.RevealedInValues` without validation [1](#0-0) 

2. These unvalidated values are extracted into `MinersPreviousInValues` [2](#0-1) 

3. Validation only checks the **sender's** `PreviousInValue` using `validationContext.SenderPubkey`, not other miners [3](#0-2) 

4. `PerformSecretSharing()` blindly applies all values from the input map to consensus state [4](#0-3) 

5. Post-execution validation only checks hash consistency between header and state, not cryptographic correctness [5](#0-4) 

**Why Existing Protections Fail**: 

The validation logic explicitly uses `validationContext.SenderPubkey` to check only the sender's value against their previous `OutValue`. There is no loop or validation mechanism for other miners' entries in the `MinersPreviousInValues` map.

## Impact Explanation

**Severity: HIGH - Consensus Cryptographic Invariant Violation**

This vulnerability breaks the fundamental security guarantee of the AEDPoS commit-reveal mechanism:

1. **Signature Calculation Corruption**: Incorrect `PreviousInValue` entries are used in `CalculateSignature()` which XORs the value with all miners' signatures [6](#0-5) 

2. **Mining Order Manipulation**: The corrupted signatures directly determine `SupposedOrderOfNextRound` via modulo arithmetic [7](#0-6) 

3. **Consensus Randomness Compromise**: The commit-reveal scheme ensures unpredictable randomness for mining schedules. Bypassing verification allows manipulation of this randomness.

4. **State Integrity**: Incorrect values are permanently committed to blockchain state and used for consensus calculations.

**Affected Parties**: All miners whose `PreviousInValue` is incorrectly set by the attacker, affecting mining order fairness and consensus randomness for the entire network.

## Likelihood Explanation

**Likelihood: HIGH (for motivated miner attacker)**

**Attacker Requirements**:
- Must be in current miner list with valid block production rights [8](#0-7) 
- Must have secret sharing enabled (checked during execution) [9](#0-8) 

**Attack Complexity**: LOW
- Attacker simply modifies `RevealedInValues` in their `AElfConsensusTriggerInformation` during off-chain block production
- Provides arbitrary hash values instead of cryptographically correct ones
- No race conditions, timing attacks, or cryptographic sophistication required

**Detection Difficulty**: HIGH
- Values appear format-valid (correct hash type)
- Validation ensures internal consistency but not cryptographic correctness
- Other nodes would need to actively compare against their records of previous round `OutValues` to detect the manipulation

## Recommendation

Add validation to verify ALL miners' `PreviousInValue` entries against their previous round `OutValue` commitments:

**In `UpdateLatestSecretPieces()`**: Add cryptographic validation before setting values:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
        (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
         updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
    {
        // ADD VALIDATION: Check against previous round OutValue
        if (TryToGetPreviousRoundInformation(out var prevRound) &&
            prevRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = prevRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
            {
                Context.LogDebug(() => $"Invalid PreviousInValue for miner {revealedInValue.Key}");
                continue; // Skip invalid value
            }
        }
        updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**Alternatively, in `ValidateBeforeExecution()`**: Add a validation provider that checks all `MinersPreviousInValues` entries, not just the sender's.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy AEDPoS contract with secret sharing enabled
2. Setup a miner list with at least 2 miners (Attacker and Victim)
3. In round N, both miners publish their `OutValue` commitments
4. In round N+1, Attacker's turn to produce block:
   - Attacker modifies `RevealedInValues` in trigger information
   - Sets Victim's `PreviousInValue` to arbitrary hash that does NOT satisfy `Hash(value) == Victim.OutValue_from_round_N`
5. Block is accepted because validation only checks Attacker's own `PreviousInValue`
6. Victim's `PreviousInValue` in state now contains incorrect value
7. This incorrect value affects signature calculation and mining order for round N+2

**Test Verification**: Check that `round.RealTimeMinersInformation[victimPubkey].PreviousInValue` does NOT satisfy `HashHelper.ComputeFrom(PreviousInValue) == previousRound.RealTimeMinersInformation[victimPubkey].OutValue` after the attack block is processed.

---

## Notes

This is a consensus-level security vulnerability that violates critical cryptographic invariants in the AEDPoS protocol. While it doesn't directly steal funds, it compromises the integrity of the consensus mechanism by allowing manipulation of mining order and consensus randomness. The vulnerability exists because validation was designed to check the sender's own values (to prevent self-cheating) but overlooked that the sender could also provide incorrect values for other participants in the secret sharing protocol.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
