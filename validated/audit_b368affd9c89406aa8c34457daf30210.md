# Audit Report

## Title
Bypass of Continuous Blocks Validation via Arbitrary Round Number in Block Headers

## Summary
The AEDPoS consensus validation system fails to verify that the miner-provided round number in block headers matches the actual state round number for `UpdateValue` and `TinyBlock` consensus behaviors. This allows malicious miners to bypass the continuous blocks limit check by setting an arbitrary round number, defeating the fork prevention mechanism without compromising state-level round progression.

## Finding Description

The AEDPoS consensus validation pipeline applies different validators based on consensus behavior type. The `RoundTerminateValidationProvider`, which validates round number consistency, is only registered for `NextRound` and `NextTerm` behaviors. [1](#0-0) 

For `UpdateValue` and `TinyBlock` behaviors, no validator checks whether `ProvidedRound.RoundNumber` matches the actual state round number. The `UpdateValueValidationProvider` only validates OutValue and PreviousInValue fields, never checking round number consistency. [2](#0-1) 

The `RoundTerminateValidationProvider` explicitly validates round number progression only for round-terminating behaviors. [3](#0-2) 

The `ContinuousBlocksValidationProvider` uses `ProvidedRound.RoundNumber` from the miner-controlled block header to determine whether to enforce continuous blocks limits. [4](#0-3) 

The `ProvidedRound` value comes directly from the consensus extra data in the block header without validation against state for `UpdateValue` and `TinyBlock` behaviors. [5](#0-4) 

When a miner exceeds their continuous blocks quota, `GetConsensusCommand` detects negative `BlocksCount` and forces `NextRound` behavior to prevent forks. [6](#0-5) 

**Attack Scenario:**

1. Miner produces excessive consecutive blocks, causing `LatestPubkeyToTinyBlocksCount.BlocksCount` to become negative
2. `GetConsensusCommand` returns `NextRound` behavior to enforce the limit
3. Malicious miner ignores this command and crafts an `UpdateValue` or `TinyBlock` transaction with `ProvidedRound.RoundNumber = 1` in the block header
4. Validation runs `ContinuousBlocksValidationProvider`, which evaluates `ProvidedRound.RoundNumber > 2` as false (since 1 is not > 2)
5. The continuous blocks check is entirely skipped, and the block is accepted
6. Miner continues producing unlimited consecutive blocks

**Why State-Level Round Skipping Cannot Occur:**

The actual state round number is protected by strict sequential validation. The `TryToUpdateRoundNumber` method enforces that round numbers can only increment by exactly 1. [7](#0-6) 

Both `ProcessUpdateValue` and `ProcessTinyBlock` retrieve the current round from state and update it in place without calling `TryToUpdateRoundNumber`, preventing state-level round manipulation. [8](#0-7) [9](#0-8) 

The recovery methods used during validation do not validate round number consistency either. [10](#0-9) 

## Impact Explanation

The continuous blocks mechanism is explicitly designed to "avoid too many forks" as documented in the codebase. [11](#0-10) 

Its purpose is "to prevent one miner produces too many continues blocks (which may cause problems to other parts)" according to the validation context documentation. [12](#0-11) 

The default maximum continuous blocks count is 8 blocks per miner. [13](#0-12) 

Bypassing this protection allows a malicious miner to:

1. **Violate consensus invariants** - produce unlimited consecutive blocks beyond the 8-block limit, breaking the intended consensus fairness model
2. **Increase fork risk** - the system dynamically adjusts `MaximumBlocksCount` during abnormal mining conditions specifically to prevent forks, but this defense mechanism is completely defeated
3. **Enable potential DoS** - excessive consecutive blocks from a single miner can destabilize the chain and cause synchronization issues for other nodes attempting to follow the canonical chain
4. **Centralize block production** - allows one miner to dominate block creation, undermining the decentralized consensus model that AEDPoS aims to provide

## Likelihood Explanation

**High Likelihood:**

- Any consensus miner can craft malicious block headers with arbitrary `ProvidedRound.RoundNumber` values
- No cryptographic validation or authorization barriers prevent this exploitation
- The attack only requires deviating from the consensus command returned by `GetConsensusCommand` - a purely client-side check
- The vulnerability is always exploitable whenever a miner exceeds their continuous blocks quota
- The validation logic explicitly uses the unvalidated `ProvidedRound.RoundNumber` from the block header

The only limiting factor is that the attacker must be an active consensus miner, but no additional privileges or special chain state conditions are required beyond normal mining participation.

## Recommendation

Add round number validation for `UpdateValue` and `TinyBlock` consensus behaviors. The fix should register `RoundTerminateValidationProvider` or create a dedicated validator for these behaviors that verifies:

```
ProvidedRound.RoundNumber == BaseRound.RoundNumber
```

Alternatively, modify `ContinuousBlocksValidationProvider` to use `BaseRound.RoundNumber` instead of `ProvidedRound.RoundNumber` for the round number check, ensuring it uses the validated state round number rather than the miner-provided value:

```csharp
if (validationContext.BaseRound.RoundNumber > 2 && // Use BaseRound instead of ProvidedRound
    validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
{
    // ... existing validation logic
}
```

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up a test miner that has exceeded the continuous blocks limit (`LatestPubkeyToTinyBlocksCount.BlocksCount < 0`)
2. Creating an `UpdateValue` consensus transaction with `ProvidedRound.RoundNumber = 1` while the actual state round is greater than 2
3. Calling `ValidateConsensusBeforeExecution` with this crafted header
4. Observing that validation succeeds despite the negative `BlocksCount`, as the continuous blocks check is bypassed

The test would verify that a block with manipulated round number passes validation when it should be rejected for exceeding continuous blocks limits.

## Notes

This vulnerability demonstrates a discrepancy between client-side consensus command generation (`GetConsensusCommand`) and server-side validation (`ValidateBeforeExecution`). While the consensus command system correctly identifies when a miner should transition to `NextRound` behavior, the validation system fails to enforce this requirement for `UpdateValue` and `TinyBlock` behaviors, allowing miners to ignore the protocol's guidance and bypass safety limits.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L34-38)
```csharp
    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-21)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
