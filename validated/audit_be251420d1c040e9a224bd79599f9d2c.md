# Audit Report

## Title
Division-by-Zero Consensus Halt via Unchecked MinerIncreaseInterval

## Summary
The `SetMinerIncreaseInterval()` function lacks positive value validation, allowing Parliament governance to set `MinerIncreaseInterval` to zero. This triggers division-by-zero exceptions during consensus round/term transitions, permanently halting the blockchain with no recovery mechanism except hard fork.

## Finding Description
The `SetMinerIncreaseInterval()` function only validates that the new value does not exceed the current value but fails to ensure it is positive. [1](#0-0) 

When `MinerIncreaseInterval` is set to zero, division-by-zero exceptions occur in two critical locations:

**Location 1**: `GetAutoIncreasedMinersCount()` performs unchecked division using the `Div()` extension method. [2](#0-1) 

**Location 2**: `GetMinersCount(Round input)` also performs unchecked division. [3](#0-2) 

The `Div()` extension method directly uses the division operator without zero-checking, throwing `DivideByZeroException` when the divisor is zero. [4](#0-3) 

Test suite confirms this behavior. [5](#0-4) 

**Critical failure paths**:

During first round transitions, `ProcessNextRound` calls `GetMinersCount()` which triggers the division-by-zero. [6](#0-5) 

During term transitions, `UpdateMinersCountToElectionContract` calls `GetMinersCount()` which also triggers division-by-zero. [7](#0-6) 

Authorization is controlled by `MaximumMinersCountController` which defaults to Parliament's default organization. [8](#0-7) 

**Critical Issue**: Once set to zero, the value becomes **unrecoverable** through governance because the validation check `input.Value <= State.MinerIncreaseInterval.Value` would require any new value to be â‰¤ 0, creating a permanent trap.

## Impact Explanation
Setting `MinerIncreaseInterval` to zero causes immediate and permanent blockchain halt:

1. **Total consensus failure**: Block production stops completely as miners cannot execute round/term transitions without encountering unhandled `DivideByZeroException`
2. **Permanent DoS**: The blockchain becomes non-functional with no recovery path via governance (the validation prevents setting positive values once zero is set)
3. **Protocol-wide impact**: All network operations cease - no transactions, blocks, governance, or cross-chain operations
4. **Requires hard fork**: Only solution is chain rollback or hard fork to restore functionality

The severity is **CRITICAL** because it represents total system failure with complete loss of blockchain liveness. This is not just a governance misconfiguration - it creates an **unrecoverable state** that breaks the fundamental availability guarantee of the blockchain.

## Likelihood Explanation
The vulnerability is executable through standard governance:

**Requirements**:
- Parliament default organization control (2/3 miner approval)
- Single proposal with `SetMinerIncreaseInterval(0)`

**Scenarios**:
- Malicious governance majority
- Configuration error during parameter updates
- Boundary value testing without proper safeguards

While governance-gated, this crosses into security territory because:
1. Similar parameter `SetMaximumMinersCount` HAS positive value validation [9](#0-8)  showing the pattern exists but was not applied here
2. The test suite demonstrates decreasing intervals is valid [10](#0-9)  but doesn't test the zero boundary
3. Creates an **irreversible** failure state

## Recommendation
Add positive value validation to `SetMinerIncreaseInterval()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

This follows the same pattern as `SetMaximumMinersCount` and prevents the unrecoverable zero-value trap.

## Proof of Concept
```csharp
[Fact]
public async Task SetMinerIncreaseInterval_Zero_Causes_DivisionByZero()
{
    // Setup: Initialize contracts and governance
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    var defaultOrganization = await ParliamentStubs.First()
        .GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Set MinerIncreaseInterval to 0 via governance
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 0 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganization
    });
    
    // Verify it was set to 0
    var interval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    interval.Value.ShouldBe(0);
    
    // Now attempt round transition - this will throw DivideByZeroException
    var exception = await Should.ThrowAsync<DivideByZeroException>(async () =>
    {
        await BlockMiningService.MineBlockToNextTermAsync();
    });
    
    // Blockchain is now halted - cannot recover via governance
    // because setting any positive value would fail the <= 0 check
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-136)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L108-147)
```csharp
    [Fact]
    public async Task SetMinerIncreaseIntervalTest()
    {
        InitialContracts();
        await BlockMiningService.MineBlockToNextTermAsync();

        InitialAcs3Stubs();
        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
        var minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        
        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
    }
```
