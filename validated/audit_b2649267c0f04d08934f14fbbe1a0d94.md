# Audit Report

## Title
Insufficient OutValue Validation Allows Miners to Bypass Consensus Participation Requirements

## Summary
The AEDPoS consensus validation only checks that `OutValue` is non-null and contains bytes, but fails to validate that these bytes represent a valid hash or that `OutValue` equals `Hash(InValue)`. Miners can submit `Hash.Empty` or arbitrary hash values as their `OutValue`, bypass validation, gain mining credit, and manipulate their next round mining order without properly participating in the consensus secret-sharing mechanism.

## Finding Description

The AEDPoS consensus relies on a commit-reveal scheme where miners commit to a secret value by publishing its hash (`OutValue`) and later reveal the secret (`InValue`). However, the validation logic has critical gaps:

**Insufficient Current Round Validation:**

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are non-null and contain bytes [1](#0-0) , but never verifies that `OutValue` equals `HashHelper.ComputeFrom(InValue)` for the current round.

**Hash.Empty Bypass:**

`Hash.Empty` is defined as 32 zero bytes [2](#0-1) , which passes the `Value.Any()` check. Additionally, when a miner submits `previousInValue == Hash.Empty`, validation explicitly returns `true` without performing hash verification [2](#0-1) .

**Miner Control Over Values:**

The `RecoverFromUpdateValue()` method directly copies `OutValue` and `Signature` from the miner-provided Round information [3](#0-2) . These values are then extracted and set in state without validation [4](#0-3) [5](#0-4) .

**Mining Credit Without Work:**

The system identifies miners who have mined by checking `SupposedOrderOfNextRound != 0` [6](#0-5) . This value is set based on the signature through modulo arithmetic [7](#0-6) [8](#0-7) , allowing miners to gain mining credit without proper consensus participation.

**Attack Execution:**
1. Miner creates block with UpdateValue behavior
2. Sets `OutValue = Hash.Empty` and `Signature = chosen_value` in block header Round information
3. Validation passes (only checks non-null and has bytes)
4. State is updated with these arbitrary values
5. `SupposedOrderOfNextRound` is calculated based on arbitrary signature
6. Miner is counted as having mined and can manipulate next round position
7. In next round, miner submits `PreviousInValue = Hash.Empty` to bypass verification

## Impact Explanation

**Consensus Integrity Violation:**
The AEDPoS consensus relies on a commit-reveal scheme for random number generation and miner ordering. By allowing miners to submit arbitrary `OutValue` and `Signature` values, the fundamental security assumptions of the consensus mechanism are broken. Miners can fake participation without contributing to the secret-sharing mechanism, compromising the randomness and fairness of block production.

**Mining Order Manipulation:**
The next round mining order is determined by modulo arithmetic on the signature value [7](#0-6) . By submitting arbitrary signature values, miners can position themselves favorably in future rounds, breaking the fairness of mining order determination.

**Mining Credit Without Work:**
Miners are counted as having "actually mined" based on `SupposedOrderOfNextRound != 0` [6](#0-5) . This affects reward distribution calculations [9](#0-8)  and breaks the assumption that miners with non-null OutValue performed valid consensus work.

**Severity:** High - This fundamentally breaks the consensus security model, allowing manipulation of mining order and undermining the commit-reveal scheme that ensures fairness and randomness in the network.

## Likelihood Explanation

**Attacker Capabilities:**
The attacker must be a registered miner in the current round, which is achievable through normal election and staking mechanisms. Once registered, the attacker has full control over the block header contents they produce.

**Attack Complexity:**
Low - The attack only requires modifying the `OutValue` and `Signature` fields in the block header's Round information to arbitrary values (e.g., `Hash.Empty`). No cryptographic breaking or complex manipulation is required.

**Execution Practicality:**
Highly practical - The validation logic in `ValidateBeforeExecution` [10](#0-9)  calls `UpdateValueValidationProvider` which only performs superficial checks. The miner controls the Round information included in the block header.

**Detection Difficulty:**
Difficult - `Hash.Empty` values might appear as failed or inactive miners, making them hard to distinguish from legitimate missed blocks without deep statistical analysis of miner behavior patterns over time.

**Likelihood:** High - The attack is technically simple, practically executable, and difficult to detect.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify the current round's OutValue-InValue relationship:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Existing checks
    if (minerInRound.OutValue == null || minerInRound.Signature == null)
        return false;
    if (!minerInRound.OutValue.Value.Any() || !minerInRound.Signature.Value.Any())
        return false;
    
    // NEW: Reject Hash.Empty
    if (minerInRound.OutValue == Hash.Empty)
        return false;
    
    // NEW: Validate current round OutValue against InValue if available
    // (Note: InValue is not published in current round, so this requires protocol change
    // to include InValue in UpdateValueInput for verification)
    
    return true;
}
```

Additionally, remove the Hash.Empty bypass in `ValidatePreviousInValue`:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    // ... existing checks ...
    
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    // REMOVE: if (previousInValue == Hash.Empty) return true;
    
    // Always validate the hash relationship
    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

**Note:** Complete fix requires protocol-level changes to include InValue in the validation input for current round verification.

## Proof of Concept

The vulnerability can be demonstrated by observing that:

1. A miner can construct a block with `OutValue = Hash.Empty` in the Round information
2. The validation in `NewConsensusInformationFilled()` only checks `OutValue != null && OutValue.Value.Any()` [1](#0-0) 
3. `Hash.Empty` contains 32 bytes, so `Value.Any()` returns true
4. No validation verifies `OutValue == Hash(InValue)` for the current round
5. The miner's `SupposedOrderOfNextRound` is set based on their signature [8](#0-7) 
6. The miner is counted as having mined [6](#0-5) 
7. In the next round, submitting `PreviousInValue = Hash.Empty` bypasses verification [2](#0-1) 

A complete test would require integration testing with the full AElf node infrastructure to construct and validate blocks with modified consensus headers, which is beyond the scope of smart contract unit tests.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L16-17)
```csharp
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L37-38)
```csharp
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L128-128)
```csharp
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-42)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```
