# Audit Report

## Title
Proposer Whitelist Validation Bypass Allows Organization DoS via Empty Addresses

## Summary
The Referendum contract's proposer whitelist validation only verifies the count of addresses without checking their validity, allowing an attacker to set a whitelist containing empty addresses that pass validation but permanently break proposal authorization, causing irreversible denial-of-service of the organization's governance capabilities.

## Finding Description

The vulnerability exists in the proposer whitelist validation mechanism. The `Empty()` extension method only checks if the whitelist count is zero, without validating that addresses have non-empty `Value` fields. [1](#0-0) 

The `Validate()` function relies on this flawed check when validating organization state: [2](#0-1) 

When `ChangeOrganizationProposerWhiteList` is called, it updates the whitelist and validates using `Validate(organization)`, but this only ensures count > 0, not content validity: [3](#0-2) 

Other contracts in the codebase properly validate addresses by checking both null and empty Value: [4](#0-3) [5](#0-4) 

**Attack Execution:**

1. Authorized proposer creates a proposal calling `ChangeOrganizationProposerWhiteList` with `ProposerWhiteList { Proposers = { new Address() } }`
2. Proposal gets approved through token-weighted voting and released
3. Validation passes because count = 1 > 0
4. All subsequent `CreateProposal` calls fail at authorization: [6](#0-5) [7](#0-6) 

The `Contains()` method uses protobuf Address equality. An empty Address (with `Value = ByteString.Empty`) will never equal any valid address: [8](#0-7) 

The Address type is a protobuf partial class where `new Address()` creates an instance with empty `Value` field: [9](#0-8) 

## Impact Explanation

**HIGH Severity** - This causes permanent, irreversible denial-of-service:

- **Operational Impact**: The organization becomes completely unable to create new proposals. All `CreateProposal` calls will fail with "Unauthorized to propose" because no valid address matches empty addresses.

- **Governance Impact**: The organization cannot execute governance actions requiring new proposals, including attempts to fix the whitelist itself. Core governance capability is permanently lost.

- **Affected Parties**: All members lose governance rights and cannot participate in decision-making.

The test suite confirms empty whitelists (count=0) should be rejected: [10](#0-9) 

The prevalence of proper address validation elsewhere confirms this is an unintended security gap.

## Likelihood Explanation

**MEDIUM Likelihood** - The attack is feasible but requires specific conditions:

**Requirements:**
- Must be an authorized proposer in the target Referendum organization
- Must convince token holders to approve the malicious proposal through token-weighted voting

**Feasibility:**
- LOW technical complexity: Simply create a proposal with `new Address()` in the whitelist
- Protobuf supports default instantiation, allowing empty Address objects
- Could be disguised in a complex proposal or executed by compromised proposer account

This represents a credible threat in scenarios involving malicious insiders, compromised proposer accounts, or social engineering to get voters to approve seemingly legitimate proposals.

## Recommendation

Add address validity validation in the `Validate()` method to check that all addresses in the proposer whitelist have non-empty `Value` fields:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || 
        organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || 
        organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for address validity
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");
    // ... rest of validation
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ProposerWhitelist_EmptyAddress_DoS_Test()
{
    // Create organization with valid proposer
    var organizationAddress = await CreateOrganizationAsync(5000, 5000, 10000, 10000, new[] { DefaultSender });
    
    // Create proposal to change whitelist to empty address
    var emptyAddressWhitelist = new ProposerWhiteList
    {
        Proposers = { new Address() } // Empty address with no Value
    };
    
    var changeProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        emptyAddressWhitelist,
        nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList),
        organizationAddress,
        ReferendumContractAddress
    );
    
    // Approve and release the malicious proposal
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, changeProposalId);
    await ApproveAsync(Accounts[3].KeyPair, changeProposalId);
    var releaseResult = await ReferendumContractStub.Release.SendAsync(changeProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify organization is now permanently DoS'd
    var createProposalInput = new CreateProposalInput
    {
        ToAddress = TokenContractAddress,
        ContractMethodName = "Test",
        Params = ByteString.CopyFromUtf8("Test"),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = organizationAddress
    };
    
    // Even the original proposer cannot create proposals anymore
    var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
    
    // No valid address can create proposals - permanent DoS
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-94)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-56)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-145)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-540)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

```

**File:** src/AElf.Types/Types/Address.cs (L7-18)
```csharp
    public partial class Address : ICustomDiagnosticMessage, IComparable<Address>
    {
        private string _formattedAddress;

        // Make private to avoid confusion
        private Address(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            Value = ByteString.CopyFrom(bytes);
        }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L774-788)
```csharp
        // invalid proposal whitelist
        {
            var organizationAddress = await CreateOrganizationAsync();
            var newProposalWhitelist = new ProposerWhiteList();
            var changeProposerWhitelistProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                newProposalWhitelist,
                nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList), organizationAddress,
                ReferendumContractAddress);
            var keyPair = Accounts[3].KeyPair;
            await ApproveAllowanceAsync(keyPair, 5000, changeProposerWhitelistProposalId);
            await ApproveAsync(keyPair, changeProposerWhitelistProposalId);
            var ret = await ReferendumContractStub.Release.SendWithExceptionAsync(
                changeProposerWhitelistProposalId);
            ret.TransactionResult.Error.ShouldContain("Invalid organization");
        }
```
