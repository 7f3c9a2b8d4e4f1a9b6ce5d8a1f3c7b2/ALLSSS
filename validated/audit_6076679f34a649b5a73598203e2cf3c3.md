# Audit Report

## Title
Byzantine Fault Tolerance Violation in Last Irreversible Block Height Calculation Due to Insufficient Confirmation Threshold

## Summary
The Last Irreversible Block (LIB) height calculation uses an index selection formula that results in blocks being marked as irreversible with fewer confirmations than required for Byzantine fault tolerance. When exactly `MinersCountOfConsent` miners participate, the selected LIB is confirmed by only `(count - floor((count-1)/3))` miners, which is less than the BFT-required `(n - floor((n-1)/3))` miners for networks with n ≥ 5 miners where n is not divisible by 3.

## Finding Description

The vulnerability exists in the LIB calculation logic where the index selection formula considers the number of participating miners (`count`) rather than ensuring the selected height has confirmations from the total number of miners required for BFT safety. [1](#0-0) 

The threshold `MinersCountOfConsent` is calculated correctly as `floor(n * 2 / 3) + 1`: [2](#0-1) 

However, the LIB selection at index `floor((count-1)/3)` creates a critical issue. When the sorted list contains implied irreversible heights from exactly `MinersCountOfConsent` miners, selecting the element at this index means only `(count - floor((count-1)/3))` miners have confirmed that height or higher, which is insufficient for BFT safety.

**Root Cause:** The index formula uses the participating miner count (`count`) instead of ensuring the selected height has confirmations from at least `(n - floor((n-1)/3))` miners.

**Mathematical Proof:**

For **n=5 total miners**:
- Byzantine tolerance: f = floor(4/3) = 1
- BFT requires: 5 - 1 = **4 confirmations**
- MinersCountOfConsent = floor(10/3) + 1 = **4 miners**
- When exactly 4 miners report: index = (4-1)/3 = 1
- Confirmations = 4 - 1 = **3 miners**
- **3 < 4 → Violates BFT**

For **n=7 total miners**:
- Byzantine tolerance: f = floor(6/3) = 2
- BFT requires: 7 - 2 = **5 confirmations**
- MinersCountOfConsent = floor(14/3) + 1 = **5 miners**
- When exactly 5 miners report: index = (5-1)/3 = 1
- Confirmations = 5 - 1 = **4 miners**
- **4 < 5 → Violates BFT**

The LIB is calculated and stored during block processing: [3](#0-2) 

Each miner sets their `ImpliedIrreversibleBlockHeight` to the current block height during block production: [4](#0-3) 

The existing validation only checks that LIB doesn't decrease, not that it has sufficient confirmations: [5](#0-4) 

## Impact Explanation

**Consensus Safety Violation:** The LIB mechanism provides finality guarantees by marking blocks as irreversible. By allowing blocks to be marked irreversible with insufficient confirmations, the system violates its Byzantine fault tolerance guarantees, which are fundamental to blockchain security.

**Attack Scenario (n=7 miners):**
1. Two Byzantine miners (within the f=2 tolerance) strategically abstain from mining
2. Five honest miners (meeting `MinersCountOfConsent` threshold) participate and provide heights
3. LIB is calculated using only 4 confirmations (57% vs required 71.4%)
4. Byzantine miners can create conflicting forks from that height since consensus wasn't truly reached
5. This enables potential double-spend attacks and breaks cross-chain finality

**Affected Parties:**
- Cross-chain bridges relying on LIB for transfer finality
- Exchanges crediting deposits after LIB confirmation
- Smart contracts making irreversible decisions based on LIB
- End users expecting transaction finality

This is **HIGH severity** because it undermines the fundamental consensus safety guarantee, allowing Byzantine miners to potentially create chain forks and double-spend attacks.

## Likelihood Explanation

**Attacker Requirements:**
- Control f = floor((n-1)/3) miners (standard Byzantine assumption)
- Coordinate abstention behavior (trivial - simply don't mine)
- No privileged access required beyond normal miner capabilities

**Attack Feasibility:** HIGH
- Byzantine miners can force exactly `MinersCountOfConsent` participation by abstaining
- Abstention is indistinguishable from legitimate network issues or downtime
- The vulnerability triggers automatically once the participation condition is met
- No complex timing or coordination required

**Detection Difficulty:** HIGH
- No validation checks the actual confirmation count
- Byzantine behavior (not mining) appears identical to honest nodes with connectivity issues
- The system operates normally from a state perspective

**Probability:** Medium-to-High
- Common for networks with n ≥ 5 miners (most production deployments)
- Network instability naturally creates conditions where some miners don't participate
- Byzantine miners can deliberately engineer this scenario

## Recommendation

The index selection formula should ensure the selected height has confirmations from at least `(n - floor((n-1)/3))` miners, regardless of the participating miner count.

**Option 1:** Adjust the index calculation to account for total miners:
```csharp
var requiredConfirmations = _currentRound.RealTimeMinersInformation.Count - 
    (_currentRound.RealTimeMinersInformation.Count - 1) / 3;
var index = impliedIrreversibleHeights.Count - requiredConfirmations;
if (index < 0) 
{
    libHeight = 0;
    return;
}
libHeight = impliedIrreversibleHeights[index];
```

**Option 2:** Increase `MinersCountOfConsent` threshold to ensure sufficient confirmations even when using the `(count-1)/3` formula.

**Option 3:** Add validation to reject LIB updates that don't have sufficient confirmations from the total miner set.

## Proof of Concept

```csharp
// Test case demonstrating BFT violation for n=5 miners
[Fact]
public void LIB_Calculation_Violates_BFT_With_Five_Miners()
{
    // Setup: 5 total miners
    var totalMiners = 5;
    var byzantineTolerance = (totalMiners - 1) / 3; // f = 1
    var requiredConfirmations = totalMiners - byzantineTolerance; // 5 - 1 = 4
    var minersCountOfConsent = (totalMiners * 2) / 3 + 1; // 4
    
    // Byzantine attack: 1 miner abstains, exactly 4 participate
    var participatingMiners = minersCountOfConsent; // 4 miners
    var sortedHeights = new List<long> { 100, 200, 300, 400 };
    
    // Calculate LIB using current formula
    var index = (participatingMiners - 1) / 3; // (4-1)/3 = 1
    var selectedLIB = sortedHeights[index]; // height 200
    
    // Calculate actual confirmations
    var actualConfirmations = participatingMiners - index; // 4 - 1 = 3
    
    // Assert BFT violation
    Assert.True(actualConfirmations < requiredConfirmations, 
        $"BFT violated: {actualConfirmations} confirmations < {requiredConfirmations} required");
    Assert.Equal(200, selectedLIB);
    Assert.Equal(3, actualConfirmations); // Only 3 miners confirmed height 200
    Assert.Equal(4, requiredConfirmations); // But 4 confirmations needed for BFT
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
