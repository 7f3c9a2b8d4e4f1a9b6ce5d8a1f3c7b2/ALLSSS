# Audit Report

## Title
Missing Minimum Participation Threshold Validation for Consensus Round Termination

## Summary
The AEDPoS consensus mechanism allows rounds to be terminated without validating that the minimum participation threshold (MinersCountOfConsent = 2/3 + 1 of total miners) has been reached. This enables consensus state transitions with fewer than the Byzantine Fault Tolerance requirement, undermining the security guarantees of the protocol.

## Finding Description

The AEDPoS consensus protocol explicitly defines `MinersCountOfConsent` as the Byzantine Fault Tolerance threshold (2/3 + 1 miners). [1](#0-0) 

However, this threshold is only enforced for Last Irreversible Block (LIB) height calculation [2](#0-1)  and for determining term change timing [3](#0-2) , but NOT for validating whether round termination should be allowed at all.

**Round Termination Flow Without Participation Check:**

1. **Command Generation**: The `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` generates consensus commands without any participation threshold validation. [4](#0-3) 

2. **Behavior Selection**: The `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` only checks time-based conditions for term changes, not participation thresholds. [5](#0-4) 

3. **Validation**: The `RoundTerminateValidationProvider` only validates structural properties (round/term number increments and in-value nullness), with no participation check. [6](#0-5) 

4. **Processing**: Both `ProcessNextRound` [7](#0-6)  and `ProcessNextTerm` [8](#0-7)  proceed to update consensus state without checking if sufficient miners participated.

The `GetMinedMiners()` method identifies participating miners (those with `SupposedOrderOfNextRound != 0`). [9](#0-8) 

However, a comprehensive search of the codebase confirms that there is no validation comparing `GetMinedMiners().Count` against `MinersCountOfConsent` before allowing round termination. The only uses of `MinersCountOfConsent` are in its definition, LIB calculation, and term change timing - never for round termination eligibility.

The `SolitaryMinerDetection` check [10](#0-9)  only prevents a single miner from mining alone for multiple consecutive rounds, but does not enforce the 2/3+1 participation threshold.

## Impact Explanation

**HIGH Severity** - This directly undermines the fundamental security model of the consensus protocol:

1. **BFT Violation**: The system can make consensus state transitions (round increments, block production) with fewer than 2/3 + 1 miner participation. In a network with N miners, rounds can be terminated with as few as 2 participating miners (due to `SolitaryMinerDetection`), violating Byzantine Fault Tolerance requirements.

2. **Network Partition Risk**: During network partitions, different segments can independently terminate rounds and produce blocks with insufficient participation. When the partition heals, reconciling these divergent chain states becomes problematic, potentially requiring manual intervention.

3. **Finality Degradation**: While LIB correctly won't advance without sufficient participation, new blocks continue to be produced and rounds advance without proper consensus guarantees. This creates uncertainty about transaction finality - transactions are being included in blocks that may never become irreversible.

4. **Safety Property Violation**: The core BFT safety property - that state transitions require 2/3+1 agreement - is violated for round transitions. This contradicts the explicit definition and intended use of `MinersCountOfConsent` as the BFT threshold.

## Likelihood Explanation

**MEDIUM-HIGH** - This vulnerability can be triggered naturally without malicious intent:

1. **Natural Triggers**: Network instability, node failures, maintenance windows, or connectivity issues commonly reduce participation below the threshold in distributed networks, automatically exposing this vulnerability.

2. **No Special Privileges Required**: Any miner selected as extra block producer among the participating miners can terminate the round by calling `NextRound` or `NextTerm` - no trusted role compromise needed. [11](#0-10) 

3. **Automatic Exploitation**: When participation drops below the threshold, the extra block producer simply follows normal protocol to terminate the round - the vulnerability is automatically exploitable without deliberate attack.

4. **Production Likelihood**: Temporary participation drops are realistic and expected in geographically distributed blockchain networks, especially during infrastructure maintenance or regional connectivity issues.

## Recommendation

Add participation threshold validation before allowing round termination. Specifically:

1. **In `RoundTerminateValidationProvider`**: Add a check to ensure `GetMinedMiners().Count >= MinersCountOfConsent` before accepting `NextRound` or `NextTerm` behaviors.

2. **In `ProcessNextRound` and `ProcessNextTerm`**: Add an assertion at the beginning to verify sufficient participation before updating state.

Example fix for `RoundTerminateValidationProvider.ValidationForNextRound`:
```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Check participation threshold
    var minedMiners = validationContext.BaseRound.GetMinedMiners();
    if (minedMiners.Count < validationContext.BaseRound.MinersCountOfConsent)
        return new ValidationResult { Message = "Insufficient miner participation for round termination." };
    
    // Existing validations...
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

## Proof of Concept

To demonstrate this vulnerability, create a test scenario where:

1. Initialize a network with N miners (e.g., 10 miners)
2. Have only 2 miners produce blocks in a round (less than MinersCountOfConsent = 7)
3. Have one of these 2 miners (as extra block producer) call `NextRound`
4. Observe that the round terminates successfully despite insufficient participation
5. Verify that `GetMinedMiners().Count < MinersCountOfConsent` but round advanced anyway
6. Confirm that LIB does not advance (expected) but rounds continue incrementing (vulnerability)

The test would verify that consensus state (round number) advances without the required 2/3+1 participation threshold, violating the BFT security model explicitly defined by `MinersCountOfConsent`.

**Notes**

This vulnerability represents a fundamental inconsistency in the consensus security model. While the system correctly prevents finality (LIB advancement) without 2/3+1 participation, it allows consensus state transitions (round termination, block production) with insufficient participation. This violates the Byzantine Fault Tolerance guarantees that `MinersCountOfConsent` is explicitly designed to enforce, creating a safety vs. liveness tradeoff that was not properly balanced in the current implementation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
