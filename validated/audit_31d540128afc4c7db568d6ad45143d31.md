# Audit Report

## Title
Unvalidated ActualMiningTimes in RecoverFromTinyBlock Enables Term Change Manipulation and Consensus Corruption

## Summary
The AEDPoS consensus contract fails to validate that miner-provided `ActualMiningTime` timestamps in `TinyBlockInput` transactions match the actual block production time (`Context.CurrentBlockTime`). Since `ActualMiningTimes` is excluded from round hash verification and directly affects critical consensus decisions like term changes, malicious miners can provide arbitrary timestamps within their time slots to manipulate consensus behavior and corrupt the blockchain's temporal integrity.

## Finding Description

The vulnerability exists across multiple validation layers that fail to verify timestamp authenticity:

**Root Cause Analysis:**

1. **No Validation in ProcessTinyBlock**: The `ProcessTinyBlock` method directly adds the provided `ActualMiningTime` to blockchain state without comparing it against `Context.CurrentBlockTime`. [1](#0-0) 

2. **RecoverFromTinyBlock Blindly Merges Data**: The recovery function adds provided timestamps without any validation against actual block time. [2](#0-1) 

3. **Hash Verification Excludes ActualMiningTimes**: The `GetCheckableRound` method explicitly clears `ActualMiningTimes` before computing hashes, meaning manipulated timestamps bypass integrity verification. [3](#0-2) 

4. **Validation Uses Corrupted Data**: The `RecoverFromTinyBlock` is called BEFORE validation providers run, so validators check against already-corrupted data. [4](#0-3) 

5. **TimeSlotValidationProvider Checks Manipulated Timestamps**: The validator checks if the miner respects their time slot but uses the already-recovered (potentially fake) timestamps from `baseRound`. [5](#0-4) 

**Attack Flow:**
1. Authorized miner constructs a `TinyBlockInput` with `ActualMiningTime` set to a fake timestamp (e.g., start of their time slot instead of actual block time)
2. Miner includes transaction in their block with header timestamp set to actual time
3. During validation, `RecoverFromTinyBlock` merges the fake timestamp into `baseRound`
4. `TimeSlotValidationProvider` validates using the fake timestamp (passes if within time slot)
5. Hash verification doesn't catch it (`ActualMiningTimes` excluded from hash)
6. `ProcessTinyBlock` persists fake timestamp to permanent state
7. Future consensus decisions use corrupted timestamp data

## Impact Explanation

**Critical Consensus Corruption:**

1. **Term Change Manipulation**: The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` to determine when to trigger term changes. Miners can delay term changes by providing timestamps earlier in their slot, keeping themselves in power longer and postponing election updates and treasury releases, or advance term changes by providing timestamps later in their slot, triggering premature elections. [6](#0-5) 

2. **Governance Disruption**: Term changes trigger critical governance operations including election snapshots and treasury releases. Manipulated timing affects governance voting periods and financial distributions. [7](#0-6) 

3. **Consensus Command Generation Corruption**: Future consensus behavior depends on `ActualMiningTimes` count and values. Manipulated timestamps corrupt tiny block limit calculations and time slot determinations. [8](#0-7) 

The mining interval is typically 4 seconds, allowing miners to manipulate timestamps by 3-4 seconds per block. [9](#0-8) 

With the two-thirds consensus requirement, coordinated manipulation by 12 out of 17 miners could significantly delay or advance term changes. [10](#0-9) 

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the current miner list (verified by PreCheck)
- Must have normal block production capabilities
- Can construct arbitrary transaction parameters (standard capability)

**Attack Complexity: LOW**
1. Miner is already authorized to call `UpdateTinyBlockInformation` via standard consensus flow
2. Miner manually constructs `TinyBlockInput` with fake `ActualMiningTime` (within their time slot to pass validation)
3. Transaction executes successfully, persisting fake timestamp
4. No cryptographic signature on timestamps themselves
5. No comparison with `Context.CurrentBlockTime` anywhere in the validation or execution path

**Feasibility: HIGH**
- No cryptographic barriers exist
- No timestamp verification logic exists in the codebase
- Manipulation limited only by time slot duration (4-8 seconds), which is sufficient for meaningful impact
- Single miner can corrupt their own timestamps; coordinated miners can amplify effects

**Detection: DIFFICULT**
- Observers only see final persisted timestamps
- Cannot distinguish legitimate delays from malicious manipulation without off-chain block time comparison
- No events or logs expose the discrepancy

## Recommendation

Add validation in `ProcessTinyBlock` to ensure the provided `ActualMiningTime` matches the actual block production time:

```csharp
private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // ADDED: Validate ActualMiningTime matches Context.CurrentBlockTime
    Assert(tinyBlockInput.ActualMiningTime == Context.CurrentBlockTime, 
        "Provided ActualMiningTime must match block production time.");
    
    minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
    minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
    minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

    Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
}
```

This ensures that the persisted `ActualMiningTime` accurately reflects when the block was actually produced, preventing manipulation of term change timing.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. Deploy AEDPoS consensus contract with 17 miners
2. Miner produces tiny block at time T_actual (e.g., T_start + 3.5s into their 4s slot)
3. Miner sets block header timestamp to T_actual
4. Miner constructs `TinyBlockInput` with `ActualMiningTime = T_start` (start of slot)
5. Transaction successfully validates because T_start < T_start + 4s (passes `TimeSlotValidationProvider`)
6. `ProcessTinyBlock` persists T_start to state (3.5 second discrepancy)
7. `NeedToChangeTerm` uses T_start for term change calculation
8. Over many blocks, accumulated manipulation delays term change by significant duration
9. Treasury release and election snapshot timing is affected

The test would verify that a miner can provide an `ActualMiningTime` different from `Context.CurrentBlockTime`, and that this manipulated timestamp is persisted and used in term change decisions without detection.

## Notes

This vulnerability affects the temporal integrity of the AEDPoS consensus mechanism. While individual manipulation is constrained to the mining interval (4 seconds), coordinated manipulation by multiple miners meeting the two-thirds threshold can significantly impact governance timing. The issue is particularly concerning because `ActualMiningTimes` is intentionally excluded from hash verification (to allow mutable execution history), but this design choice creates a security gap where miners can provide unverified timestamps that affect critical consensus decisions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-218)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L148-163)
```csharp
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```
