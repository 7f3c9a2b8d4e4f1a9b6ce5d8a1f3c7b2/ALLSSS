# Audit Report

## Title
Retroactive Vote Manipulation Through Dynamic Membership Changes in Association Contract

## Summary
The Association contract's vote counting mechanism evaluates votes based on current membership status rather than membership status at the time of voting, enabling retroactive invalidation of votes through membership changes.

## Finding Description

The vulnerability exists in a temporal inconsistency between vote recording and vote counting in the Association contract.

**Vote Recording Phase:**
When members cast votes via `Approve()`, `Reject()`, or `Abstain()`, the contract verifies membership at vote time using `AssertIsAuthorizedOrganizationMember()` [1](#0-0)  and records the vote permanently by adding the voter's address to the proposal's approval, rejection, or abstention lists [2](#0-1) .

**Vote Counting Phase:**
When `Release()` is called, it invokes `IsReleaseThresholdReached()` to verify if the proposal can be executed [3](#0-2) . 

The critical flaw lies in the vote counting functions that filter votes against the **current** membership list. The `CheckEnoughVoteAndApprovals()` method counts approvals only from current members [4](#0-3) .

Similarly, rejection and abstention counts are filtered through current membership [5](#0-4) [6](#0-5) .

The `Contains()` method checks against the organization's current member list [7](#0-6) .

**Membership Manipulation:**
Organizations can modify membership through `AddMember()` and `RemoveMember()` methods callable by the organization address itself (via governance proposals) [8](#0-7) [9](#0-8) .

**Attack Scenario:**
1. Organization with 7 members (A, B, C, D, E, F, G) has MinimalApprovalThreshold=4
2. Proposal P1 receives 4 approvals from members A, B, C, D
3. Organization passes separate proposal P2 to remove member B via `RemoveMember()`
4. When `Release(P1)` is attempted, only 3 approvals count (A, C, D remain members)
5. P1 cannot be released despite legitimately meeting the threshold when votes were cast

## Impact Explanation

**Governance Integrity Compromise:**
- Proposals that legitimately reached approval thresholds can be prevented from passing by removing approving members
- Proposals that should fail can be made to pass by removing rejecting members
- Organization members' votes are retroactively invalidated without their knowledge or consent

**Affected Parties:**
- Organization members whose votes are nullified after casting them
- Proposers whose proposals fail due to manipulation
- The entire governance process integrity for Association organizations

**Severity: Medium** - While it requires passing a membership change proposal first (which itself requires threshold votes), such changes are legitimate operations that mask the manipulation. The impact is governance integrity compromise rather than direct fund loss.

## Likelihood Explanation

**Attacker Capabilities:**
An attacker with majority control can pass membership change proposals and systematically manipulate pending proposals through strategic member removal/addition.

**Attack Complexity:**
Low - only requires calling standard `AddMember`/`RemoveMember` through governance proposals. No complex transaction sequences or external dependencies required.

**Detection Constraints:**
- Membership changes appear as legitimate governance actions
- The connection between membership changes and vote invalidation is not transparent
- No events or warnings indicate that existing votes are being invalidated

**Likelihood: Medium-High** - Once an attacker gains governance majority, membership changes are expected operations, making the attack vector unobvious. The lack of vote immutability protection makes this exploitable whenever membership changes occur during active proposal voting periods.

## Recommendation

Implement vote snapshotting to preserve membership status at the time of voting:

1. **Store Membership Snapshot:** When a proposal is created, record the current organization member list hash or timestamp
2. **Lock Membership for Active Proposals:** Prevent membership changes while proposals are pending, OR
3. **Validate Against Historical Membership:** During vote counting, validate votes against the membership list that existed when each vote was cast

Recommended implementation approach:
- Add a `memberListVersion` field to `ProposalInfo` that captures the organization's member list state when the proposal is created
- During vote counting, verify that voters were members at the time the proposal was created, not just current members
- Alternatively, prevent `AddMember()` and `RemoveMember()` operations when active proposals exist for that organization

## Proof of Concept

```csharp
[Fact]
public async Task RetroactiveVoteManipulation_Test()
{
    // Setup organization with 7 members, threshold = 4
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { MemberA, MemberB, MemberC, MemberD, MemberE, MemberF, MemberG }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 4,
            MinimalVoteThreshold = 4,
            MaximalAbstentionThreshold = 7,
            MaximalRejectionThreshold = 7
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { MemberA } }
    };
    var orgAddress = await AssociationContractStub.CreateOrganization.SendAsync(createInput);
    
    // Create proposal P1
    var proposalId = await CreateProposalAsync(orgAddress.Output);
    
    // Get 4 approvals from A, B, C, D
    await ApproveAsync(MemberA, proposalId);
    await ApproveAsync(MemberB, proposalId);
    await ApproveAsync(MemberC, proposalId);
    await ApproveAsync(MemberD, proposalId);
    
    // Verify proposal can be released (4 approvals meets threshold)
    var canRelease = await GetProposal(proposalId);
    canRelease.ToBeReleased.ShouldBeTrue();
    
    // Create and execute proposal P2 to remove MemberB
    var removeProposalId = await CreateRemoveMemberProposalAsync(orgAddress.Output, MemberB);
    await ApproveAsync(MemberA, removeProposalId);
    await ApproveAsync(MemberC, removeProposalId);
    await ApproveAsync(MemberD, removeProposalId);
    await ApproveAsync(MemberE, removeProposalId);
    await ReleaseAsync(MemberA, removeProposalId);
    
    // Now P1 cannot be released despite having 4 legitimate approvals
    var canReleaseAfter = await GetProposal(proposalId);
    canReleaseAfter.ToBeReleased.ShouldBeFalse(); // Only 3 approvals count now (A, C, D)
    
    // Attempting to release P1 fails
    var releaseResult = await ReleaseAsync(MemberA, proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
}
```

**Notes:**
This vulnerability affects the core governance integrity of Association organizations. While it requires majority control to execute, this is precisely the scenario where governance safeguards are most critical. The temporal inconsistency between vote recording and counting creates an exploitable window where legitimate votes can be retroactively invalidated through membership changes. Organizations using the Association contract for critical decisions should be aware that pending proposals can be manipulated through strategic membership modifications.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L37-37)
```csharp
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
