# Audit Report

## Title
Evil Nodes Bypass Punishment During Term Transitions Due to Missing Banned Pubkey Check in GetVictories Fallback Logic

## Summary
The Election contract's `GetVictories` method contains a critical vulnerability in its fallback logic that allows banned miners (marked as evil nodes) to continue participating in consensus during term transitions. When insufficient valid candidates are available, the method selects backup miners from current miners and initial miners without checking `State.BannedPubkeyMap`, completely bypassing the punishment mechanism.

## Finding Description

The vulnerability exists in the Election contract's `GetVictories` method fallback logic. When valid candidates are insufficient to fill all miner slots during a term transition, the method falls back to selecting backup miners from `currentMiners` and `State.InitialMiners` without verifying whether these nodes have been banned. [1](#0-0) 

The fallback logic directly adds miners from these sources without checking `State.BannedPubkeyMap`. When a node is marked as evil, the `UpdateCandidateInformation` method sets the banned flag and removes the node from candidates, but critically does NOT remove it from `State.InitialMiners`: [2](#0-1) 

The correct implementation exists in the same file. The `GetMinerReplacementInformation` method properly filters banned pubkeys when selecting from initial miners: [3](#0-2) 

During term transitions, the consensus contract calls `TryToGetVictories` to obtain the new miner list: [4](#0-3) 

This calls the vulnerable `GetVictories` method in the Election contract: [5](#0-4) 

The returned miner list is then directly used to set the new term's miners without additional validation: [6](#0-5) 

Critically, the miner replacement mechanism that could catch banned miners only activates during same-term round transitions, NOT during term changes: [7](#0-6) 

## Impact Explanation

This vulnerability has CRITICAL impact on network security and integrity:

1. **Consensus Integrity Violation**: Banned miners (evil nodes) that should be excluded from consensus continue participating in block production across multiple terms, completely defeating the punishment mechanism designed to maintain network security.

2. **Reward Misallocation**: Banned miners continue earning mining rewards despite being marked as malicious actors. The term transition process includes reward distribution: [8](#0-7) 

3. **Long-term Attack Persistence**: Malicious nodes can continue attacking the network across multiple terms without consequences, as long as candidate participation remains low.

4. **Undermined Governance**: The evil node detection and punishment mechanism becomes ineffective, as banned nodes automatically return during term transitions.

The impact affects network security, legitimate miners facing unfair competition, token holders whose rewards fund banned nodes, and overall network trustworthiness.

## Likelihood Explanation

The likelihood of this vulnerability being triggered is HIGH:

**Reachable Entry Point**: Term transitions occur automatically based on blockchain time through the public consensus mechanism: [9](#0-8) 

**Feasible Preconditions**:
1. At least one miner marked as evil - realistic, happens through `UpdateCandidateInformation` called by consensus contract when detecting evil behavior or via emergency response organization
2. Valid candidates < required miners count - realistic during low participation periods
3. Term transition occurs - happens regularly in normal operation

**Automatic Trigger**: The vulnerability triggers deterministically during normal term transitions when insufficient candidates exist. The consensus contract processes term transitions automatically: [10](#0-9) 

**Silent Execution**: The issue occurs without errors or events that would alert operators, making it difficult to detect without explicit monitoring of the banned pubkey map versus active miner lists.

## Recommendation

Add a banned pubkey check in the `GetVictories` fallback logic, consistent with the implementation in `GetMinerReplacementInformation`. The fix should be applied at lines 68-69 of ViewMethods.cs:

```csharp
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !State.BannedPubkeyMap[k])  // Add this check
            .Where(k => !backups.Contains(k)));
```

Additionally, consider filtering `currentMiners` at line 66 to exclude banned miners:

```csharp
var backups = currentMiners
    .Where(k => !State.BannedPubkeyMap[k])  // Add this check
    .Where(k => !validCandidates.Contains(k))
    .ToList();
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Initialize the blockchain with initial miners
2. Mark one miner as evil using `UpdateCandidateInformation` with `IsEvilNode = true`
3. Ensure valid candidates count is less than required miners count
4. Trigger a term transition by calling `NextTerm`
5. Observe that the banned miner is included in the new term's miner list via the `GetVictories` fallback logic
6. Verify that the banned miner can produce blocks and earn rewards in the new term

The test would validate that the banned status in `State.BannedPubkeyMap[pubkey]` is not checked during the fallback selection in `GetVictories`, allowing the previously banned miner to return to the active miner set.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-76)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-280)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L41-44)
```csharp
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
