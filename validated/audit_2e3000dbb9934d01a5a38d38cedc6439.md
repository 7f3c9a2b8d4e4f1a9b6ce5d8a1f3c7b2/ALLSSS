# Audit Report

## Title
ProposerWhiteList Validation Bypass Allows Creation of Permanently Bricked Referendum Organizations

## Summary
The Referendum contract fails to validate that addresses in the ProposerWhiteList contain non-empty value fields. This allows attackers to create organizations with malformed addresses that pass validation but permanently prevent proposal creation, resulting in complete denial-of-service of governance functionality for affected organizations.

## Finding Description

The vulnerability exists in the organization validation logic. [1](#0-0) 

The root cause is that the validation only checks if the ProposerWhiteList is non-empty using a count-based method. [2](#0-1) 

The Address protobuf message structure allows empty bytes values in protobuf3. [3](#0-2) 

While C# Address constructors enforce 32-byte length requirements, protobuf deserialization bypasses these constructors and directly populates the Value field. [4](#0-3) 

The codebase demonstrates the correct validation pattern in TokenContract. [5](#0-4) 

This proper validation uses the IsNullOrEmpty() extension method. [6](#0-5) 

**Attack Execution:**

1. Attacker crafts a CreateOrganizationInput with ProposerWhiteList containing Address objects with empty value fields
2. The organization is created via the public CreateOrganization() method [7](#0-6) 
3. When legitimate users attempt to create proposals, AssertIsAuthorizedProposer() is invoked [8](#0-7) 
4. The authorization check uses Contains() which compares Address equality [9](#0-8) 
5. Address equality comparison uses protobuf's Equals() method which compares ByteString values [10](#0-9) 
6. Valid addresses (32 bytes) never match addresses with empty bytes, causing all proposal creations to fail

Transaction-level validation only checks if Address objects are null, not if their value fields are empty. [11](#0-10) 

## Impact Explanation

This vulnerability enables complete denial-of-service of governance functionality for affected Referendum organizations. Once an organization is created with malformed addresses in the ProposerWhiteList, no legitimate user can ever create proposals for that organization. The governance mechanism becomes permanently non-functional since the Contains() check will always fail when comparing valid addresses against empty-valued addresses.

While this attack does not result in fund loss, governance functionality is critical for protocol operations. Organizations relying on Referendum-based governance for parameter updates, upgrades, or treasury management would lose this capability entirely. The impact is permanent unless the contract is upgraded, as there is no mechanism to fix already-created organizations with invalid whitelists.

## Likelihood Explanation

The likelihood is medium-to-high based on the following factors:

**Attacker Capabilities:** Any user can call the public CreateOrganization() method without special permissions. The attacker must understand protobuf message structure to craft Address objects with empty value fields, which requires medium technical knowledge.

**Attack Complexity:** The attack requires manually constructing protobuf messages, but this is achievable with standard protobuf libraries. The transaction-level validation only checks for null Address objects, not empty value fields, allowing the malformed input to pass through.

**Economic Rationality:** The attack cost is minimal (only transaction gas fees). While there is no direct economic benefit to the attacker, this enables griefing attacks against specific governance operations or organizations.

**Detection:** Bricked organizations would only be discovered when the first proposal creation attempt fails. There is no proactive detection mechanism to identify organizations with invalid whitelists before they are used.

## Recommendation

Add individual address validation in the Referendum contract's Validate() method to check that each address in the ProposerWhiteList has a non-empty value field:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for individual addresses
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

This follows the validation pattern already used in TokenContract and ensures all addresses contain valid 32-byte values before the organization is created.

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithEmptyAddressValue_ShouldBrickOrganization()
{
    // Create organization with address containing empty bytes value
    var malformedAddress = new Address { Value = ByteString.Empty };
    var input = new CreateOrganizationInput
    {
        TokenSymbol = "ELF",
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { malformedAddress }
        }
    };
    
    // Organization creation should succeed (but shouldn't)
    var organizationAddress = await ReferendumContractStub.CreateOrganization.SendAsync(input);
    organizationAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attempt to create proposal with valid address - this will fail
    var validProposer = DefaultSender; // Valid 32-byte address
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ContractMethodName = "Transfer",
        ToAddress = TokenContractAddress,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        Params = new TransferInput { To = DefaultSender, Symbol = "ELF", Amount = 100 }.ToByteString()
    };
    
    // This should fail with "Unauthorized to propose" even though we're using a valid address
    var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(proposalInput);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose");
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** src/AElf.Types/Types/Address.cs (L12-18)
```csharp
        private Address(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            Value = ByteString.CopyFrom(bytes);
        }
```

**File:** src/AElf.Types/Types/Address.cs (L96-99)
```csharp
        public static bool operator ==(Address address1, Address address2)
        {
            return address1?.Equals(address2) ?? ReferenceEquals(address2, null);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L34-37)
```csharp
        public static bool IsNullOrEmpty(this ByteString byteString)
        {
            return byteString == null || byteString.IsEmpty;
        }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** src/AElf.Types/Types/Transaction.cs (L19-31)
```csharp
        public bool VerifyFields()
        {
            if (To == null || From == null)
                return false;

            if (RefBlockNumber < 0)
                return false;

            if (string.IsNullOrEmpty(MethodName))
                return false;

            return true;
        }
```
