# Audit Report

## Title
NFT Collection Creation Bypass Allows Non-Zero Decimals Through Direct TokenContract Call

## Summary
The NFT contract enforces `Decimals = 0` for NFT collections, but this invariant can be bypassed by calling `TokenContract.Create` directly with NFT collection symbols (ending in "-0") and non-zero decimals. The TokenContract only validates decimals within [0, 18] for NFT collections, not that they equal zero, allowing creation of divisible "NFTs" that violate the fundamental NFT indivisibility property.

## Finding Description

The NFT contract's `Create` method correctly hardcodes `Decimals = 0` when creating NFT protocols [1](#0-0) , ensuring NFT collections are non-divisible.

However, the `TokenContract.Create` method is publicly accessible and can be called directly by any user possessing a valid SEED NFT [2](#0-1) . The method routes token creation based on symbol patterns through `GetSymbolType`.

The symbol type classification is purely pattern-based. Symbols ending with "-0" are classified as `SymbolType.NftCollection` [3](#0-2)  where the collection suffix is defined as "0" [4](#0-3) .

For NFT collections, `CreateNFTCollection` simply delegates to `CreateToken` without additional validation [5](#0-4) .

The `CreateToken` method validates decimals only through `AssertValidCreateInput`, which permits any value between 0 and 18 [6](#0-5) [7](#0-6) .

Only SEED NFT items (within SEED-0 collection) have explicit `Decimals == 0` validation [8](#0-7) . This validation does NOT prevent SEED NFTs from having `OwnedSymbol` values ending in "-0" (NFT collection format), as it only checks that the owned symbol is not of type `SymbolType.Nft` (individual NFT items), allowing `SymbolType.NftCollection` to pass [9](#0-8) .

The SEED NFT validation only checks ownership, OwnedSymbol match, and expiration, but not decimals requirements [10](#0-9) .

**Attack Flow:**
1. Create SEED NFT (e.g., SEED-1) with `ExternalInfo["__seed_owned_symbol"] = "ABC-0"`
2. Call `TokenContract.Create` with `Symbol = "ABC-0"` and `Decimals = 8`
3. System classifies "ABC-0" as NFT collection, validates SEED, and creates token with `Decimals = 8`
4. Result: NFT collection exists with non-zero decimals, making it divisible

## Impact Explanation

**Protocol Invariant Violation**: NFTs are fundamentally non-fungible and indivisible tokens. The protocol design enforces `Decimals = 0` for all NFT collections to guarantee uniqueness and prevent fractional ownership. Creating NFT collections with `Decimals > 0` breaks this core invariant, allowing fractional NFT amounts (e.g., 0.5 of an NFT with `Decimals = 8` represented as 50000000 smallest units).

**Ecosystem Confusion**: dApps, wallets, and NFT marketplaces rely on symbol patterns (symbols ending in "-0" for collections) to identify and handle NFTs. These divisible tokens will be incorrectly treated as proper NFTs, causing:
- Incorrect display/accounting in NFT galleries and marketplaces
- Failed assumptions in smart contracts expecting indivisible NFT units
- User deception when purchasing apparent NFTs that are actually divisible

**Operational Impact**: Once created, these malformed NFT collections can be issued [11](#0-10)  and transferred [12](#0-11)  in fractional amounts via standard token operations, violating the NFT uniqueness guarantee.

## Likelihood Explanation

**Reachable Entry Point**: `TokenContract.Create` is a public method callable by any user with a valid SEED NFT.

**Feasible Preconditions**: 
- Attacker must acquire a SEED NFT for the target symbol via normal SEED NFT acquisition mechanisms
- No special privileges required beyond standard SEED NFT ownership
- SEED creation validation allows OwnedSymbol ending in "-0" because it only rejects `SymbolType.Nft`, not `SymbolType.NftCollection`

**Execution Steps**:
1. Acquire/create SEED NFT with `OwnedSymbol = "ABC-0"`
2. Call `TokenContract.Create(Symbol="ABC-0", Decimals=8, ...)`
3. System validates SEED NFT and burns it
4. Token created with `Decimals = 8`
5. Attacker can now issue/transfer fractional amounts

## Recommendation

Add explicit validation in `CreateNFTCollection` to enforce `Decimals = 0` for NFT collections:

```csharp
private Empty CreateNFTCollection(CreateInput input)
{
    Assert(input.Decimals == 0, "NFT collections must have Decimals = 0.");
    return CreateToken(input, SymbolType.NftCollection);
}
```

Additionally, strengthen SEED NFT validation to prevent OwnedSymbol values with NFT collection format ("-0" suffix) unless explicitly intended for collection creation through the proper NFT contract path.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create a SEED NFT with `ExternalInfo["__seed_owned_symbol"] = "TEST-0"`
2. Call `TokenContract.Create` with `Symbol="TEST-0"` and `Decimals=8`
3. Verify the token is created with `Decimals=8`
4. Issue fractional amounts (e.g., 0.5 tokens = 50000000 smallest units)
5. Transfer fractional amounts successfully
6. Confirm the NFT collection symbol pattern "TEST-0" but with divisible behavior

## Notes

The vulnerability exists because there are two separate paths to create tokens with NFT collection symbols:
1. **NFT Contract path**: Properly enforces `Decimals = 0`
2. **TokenContract.Create path**: Only validates `Decimals âˆˆ [0, 18]`

The SEED NFT validation gap (only rejecting `SymbolType.Nft` instead of all non-token types) enables attackers to create SEED NFTs with collection-format OwnedSymbol values, which can then be used to create malformed NFT collections through the direct TokenContract path.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L26-26)
```csharp
            Decimals = 0, // Fixed
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L6-6)
```csharp
    public const int MaxDecimals = 18;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L22-22)
```csharp
    public const string CollectionSymbolSuffix = "0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-52)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```
