# Audit Report

## Title
RemoveSubScheme Fails to Update CachedDelayTotalShares, Causing Profit Dilution in Delayed Distribution Schemes

## Summary
The `RemoveSubScheme` method in the Profit contract contains a critical accounting bug that fails to update `CachedDelayTotalShares` when removing sub-schemes from schemes with delayed distribution enabled. This creates a permanent mismatch between current share counts and cached future period shares, causing all beneficiaries to receive diluted profits in subsequent distributions.

## Finding Description
When a sub-scheme is added via `AddSubScheme`, it internally calls `AddBeneficiary` with `EndPeriod=long.MaxValue`, which increases the parent scheme's `TotalShares`. [1](#0-0) 

During profit distribution on schemes with `DelayDistributePeriodCount > 0`, the current `TotalShares` value is cached for future periods in the `CachedDelayTotalShares` map. [2](#0-1) 

When `RemoveSubScheme` is called, it correctly reduces `TotalShares` but completely omits updating the `CachedDelayTotalShares` entries. [3](#0-2) 

In stark contrast, `RemoveBeneficiary` properly handles both: it reduces `TotalShares` AND iterates through all cached delay periods to subtract the removed shares from each cached entry. [4](#0-3) 

When beneficiaries later claim profits via `ClaimProfits`, the profit calculation in `ProfitAllPeriods` uses `distributedProfitsInformation.TotalShares` as the denominator. [5](#0-4)  If this value comes from stale cached data with inflated share counts, all beneficiaries receive proportionally less than their entitled amounts.

## Impact Explanation
This vulnerability breaks the fundamental accounting invariant that profit distributions must use accurate share ratios. When a sub-scheme with S shares is removed from a scheme with total T shares and delay period D:

1. Future periods P through P+D retain cached value of T (inflated)
2. Actual current shares should be T-S (correct)
3. Each beneficiary with B shares receives: `profit * B / T` instead of `profit * B / (T-S)`
4. Dilution factor: `(T-S) / T` of entitled profit
5. Missing profits: `profit * S / T` remains permanently locked in the period's virtual address

**Real-World Impact:** The Treasury contract actively uses `RemoveSubScheme` in three critical functions: `ResetWeight` when adjusting dividend pool weights [6](#0-5) , `UpdateWelcomeRewardWeights` when managing miner rewards [7](#0-6) , and `UpdateFlexibleRewardWeights` for flexible reward adjustments [8](#0-7) . 

The Welfare scheme explicitly has `DelayDistributePeriodCount = 1` configured during initialization. [9](#0-8)  Any weight adjustment operations on schemes with delayed distribution will trigger this bug, causing system-wide profit dilution affecting all miners, voters, and subsidy recipients.

## Likelihood Explanation
**Trigger Conditions:**
- Requires scheme manager authority (Treasury contract for system schemes, which is legitimate operational authority)
- Target scheme must have `DelayDistributePeriodCount > 0` (Welfare scheme has this enabled)
- Manager calls `AddSubScheme` then later `RemoveSubScheme` during routine operations

**Operational Reality:** The Treasury contract performs weight adjustments as part of normal governance operations. Every call to `SetDividendPoolWeightSetting` or `SetMinerRewardWeightSetting` triggers `ResetWeight`, which removes and re-adds sub-schemes with new weights. These are routine maintenance operations expected to occur regularly as the system adapts to changing tokenomics requirements.

**Detection Difficulty:** The bug manifests as unexplained profit shortfalls that only appear in future periods (after the delay), making it extremely difficult to correlate with the original `RemoveSubScheme` call. There is no on-chain indicator that cached shares are stale.

Given that the Treasury contract is designed to regularly adjust weights and the affected schemes have delayed distribution enabled by default, the likelihood of triggering this bug in production is **HIGH**.

## Recommendation
The `RemoveSubScheme` method must be updated to match the behavior of `RemoveBeneficiary` by iterating through and updating all cached delay total shares entries. Add the following logic after line 152 in `RemoveSubScheme`:

```csharp
// Update cached delay shares for all future periods
if (scheme.DelayDistributePeriodCount > 0)
{
    for (var period = scheme.CurrentPeriod; 
         period < scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount); 
         period++)
    {
        if (scheme.CachedDelayTotalShares.ContainsKey(period))
        {
            scheme.CachedDelayTotalShares[period] = 
                scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
        }
    }
}
```

This ensures that when a sub-scheme is removed, all future cached periods are corrected to reflect the reduced share count, maintaining accounting consistency.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveSubScheme_ShouldUpdateCachedDelayTotalShares_ButDoesNot()
{
    // Setup: Create parent scheme with 3-period delay
    var creator = GetProfitContractTester(Accounts[0].KeyPair);
    var parentSchemeId = await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = 3
    });
    
    // Create sub-scheme 
    var subSchemeId = await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true
    });
    
    // Add beneficiary with 100 shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = parentSchemeId.Output,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = Accounts[1].Address,
            Shares = 100
        },
        EndPeriod = long.MaxValue
    });
    
    // Add sub-scheme with 500 shares - TotalShares becomes 600
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId.Output,
        SubSchemeId = subSchemeId.Output,
        SubSchemeShares = 500
    });
    
    // Distribute period 1 - caches TotalShares=600 for period 4
    await ContributeAndDistribute(creator, 1000, 1);
    
    // Remove sub-scheme - TotalShares becomes 100, but cache remains 600
    await creator.RemoveSubScheme.SendAsync(new RemoveSubSchemeInput
    {
        SchemeId = parentSchemeId.Output,
        SubSchemeId = subSchemeId.Output
    });
    
    var scheme = await creator.GetScheme.CallAsync(parentSchemeId.Output);
    
    // Current TotalShares correctly updated to 100
    scheme.TotalShares.ShouldBe(100);
    
    // BUG: CachedDelayTotalShares[4] still has 600 instead of 100
    scheme.CachedDelayTotalShares[4].ShouldBe(100); // This will FAIL
    
    // When period 4 distributes, it will use 600 as denominator
    // Beneficiary will receive: 1000 * 100 / 600 = 166 instead of 1000
    // Missing profit: 833 tokens locked forever
}
```

This test demonstrates that after removing a sub-scheme with 500 shares, the current `TotalShares` is correctly reduced to 100, but the cached value for future period 4 remains at 600, causing a 6x profit dilution for all beneficiaries.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-257)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L56-67)
```csharp
        for (var i = 0; i < 7; i++)
        {
            var index = i;
            Context.LogDebug(() => profitItemNameList[index]);
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L520-540)
```csharp
    private void ResetWeight(Hash parentSchemeId, Hash subSchemeId, int oldWeight,
        int newWeight)
    {
        if (oldWeight == newWeight)
            return;

        // old weight equals 0 indicates the subScheme has not been registered
        if (oldWeight > 0)
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });

        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = parentSchemeId,
            SubSchemeId = subSchemeId,
            SubSchemeShares = newWeight
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L848-862)
```csharp
    private void UpdateWelcomeRewardWeights(Round previousTermInformation, List<string> newElectedMiners)
    {
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L893-904)
```csharp
    private void UpdateFlexibleRewardWeights(Round previousTermInformation)
    {
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.WelfareHash.Value
        });
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
```
