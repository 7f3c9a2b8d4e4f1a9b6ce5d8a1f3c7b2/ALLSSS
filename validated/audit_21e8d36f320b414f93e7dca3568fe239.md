# Audit Report

## Title
Voluntary Key Rotation Bypasses Performance Penalties in Miner Reward Distribution

## Summary
The Treasury contract incorrectly applies the `IsReplacedEvilMiner` penalty-bypass flag to voluntary key rotations instead of evil miner replacements. This allows underperforming miners to double their Basic Miner Reward shares by rotating their public key, circumventing the quadratic performance penalty system designed to enforce reliable block production.

## Finding Description

The vulnerability stems from inverted logic in miner replacement tracking across the Election, Consensus, and Treasury contracts.

**Voluntary Key Rotation Flow (Incorrect Behavior):**

When a miner admin calls `ReplaceCandidatePubkey`, the method updates all candidate state and triggers consensus updates. [1](#0-0) 

The Election contract calls `RecordCandidateReplacement` on the AEDPoS contract, which copies the complete `MinerInRound` information including the `ProducedBlocks` field to the new pubkey. [2](#0-1) 

Critically, when the Consensus contract notifies Treasury via `RecordMinerReplacement`, it does not set the `IsOldPubkeyEvil` field, causing it to default to false. [3](#0-2) 

However, the Treasury contract unconditionally sets `IsReplacedEvilMiner[newPubkey] = true` regardless of the `IsOldPubkeyEvil` parameter value. [4](#0-3) 

**Evil Miner Replacement Flow (Missing Flag):**

When `GenerateNextRoundInformation` detects evil miners, it creates fresh `MinerInRound` objects with only basic consensus fields. The `ProducedBlocks` field defaults to 0. [5](#0-4) 

Critically, this flow never calls `RecordMinerReplacement` on the Treasury contract, so evil miner replacements never receive the `IsReplacedEvilMiner` flag.

**Reward Distribution (Bypass Logic):**

At term end, `UpdateBasicMinerRewardWeights` distributes rewards. Miners with `IsReplacedEvilMiner` set receive shares equal to their `ProducedBlocks` directly, bypassing the penalty calculation. [6](#0-5) 

Normal miners undergo quadratic penalty calculation where underperformers receive reduced shares. [7](#0-6) 

The comment suggests this bypass is intended for "new miners" who joined mid-term, but the implementation applies it to voluntary rotations that preserve full performance history.

## Impact Explanation

**Direct Fund Misallocation:**

For a miner producing 200 blocks when average is 400:
- Normal path: `CalculateShares(200, 400) = 200² / 400 = 100 shares`
- After key rotation: `200 shares` directly
- Result: 100% reward increase (100 excess shares)

For miners at 40% performance (160 blocks when average is 400):
- Normal path: `160² / 400 = 64 shares`
- After rotation: `160 shares`
- Result: 150% reward increase (96 excess shares)

The Basic Miner Reward represents a significant portion of treasury distribution. Over multiple terms with strategic rotations, underperforming miners can maintain reward levels equivalent to high-performing miners, directly diluting rewards from honest participants. This undermines the consensus economic model's core invariant: block production reliability must correlate with reward allocation to ensure network stability and proper incentive alignment.

## Likelihood Explanation

**Attack Requirements:**
- Attacker controls candidate admin account (normal operational requirement for miners)
- Single transaction calling `ReplaceCandidatePubkey` with new pubkey
- No timing restrictions beyond term boundaries  
- No cost beyond standard transaction fees [8](#0-7) 

**Execution Scenario:**
1. Miner monitors `ProducedBlocks` during term
2. If performance falls below 80% of expected average, execute key rotation
3. New pubkey inherits all consensus data including poor block production count
4. `IsReplacedEvilMiner` flag ensures penalty bypass at term end
5. Flag cleared after one-time use, ready for next term exploitation

**Detection Difficulty:**
Key rotations are legitimate operational needs (security key updates, hardware migration). Distinguishing malicious penalty avoidance from genuine operations is nearly impossible without correlating performance metrics with rotation timing across multiple terms.

**Feasibility:** High - publicly callable method, deterministic outcome, zero operational risk.

## Recommendation

Modify `RecordMinerReplacement` to only set `IsReplacedEvilMiner` when the replacement is genuinely for an evil miner:

```csharp
public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only AEDPoS Contract can record miner replacement.");

    if (!input.IsOldPubkeyEvil)
    {
        var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
        State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
        State.LatestMinedTerm.Remove(input.OldPubkey);
    }
    else
    {
        var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
        replaceCandidates.Value.Add(input.NewPubkey);
        State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        
        // Only set flag when replacing an evil miner
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
    }

    return new Empty();
}
```

Additionally, ensure `GenerateNextRoundInformation` calls `RecordMinerReplacement` with `IsOldPubkeyEvil = true` when replacing evil miners.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy contracts with standard configuration
2. Start term with multiple miners
3. Have one miner produce significantly fewer blocks than average (e.g., 200 when average is 400)
4. Before term end, miner admin calls `ReplaceCandidatePubkey(underperformingPubkey, newPubkey)`
5. Verify `IsReplacedEvilMiner[newPubkey]` is set to true
6. At term end, call `UpdateBasicMinerRewardWeights`
7. Verify the new pubkey receives 200 shares instead of the penalized 100 shares
8. Compare with a miner at same performance who didn't rotate (receives 100 shares)

The test would show the rotated miner receiving double the shares despite identical performance, confirming the bypass mechanism.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L573-599)
```csharp
    public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only AEDPoS Contract can record miner replacement.");

        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L799-822)
```csharp
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```
