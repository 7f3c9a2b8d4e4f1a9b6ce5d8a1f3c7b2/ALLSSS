# Audit Report

## Title
NextTerm Round Validation Bypass via RoundIdForValidation Manipulation Leading to Consensus DoS

## Summary
A malicious miner can bypass critical time-slot validation during term transitions by manipulating the `RoundIdForValidation` field in `NextTermInput`. This allows storing a malformed consensus round without `ExpectedMiningTime` values to chain state, causing a permanent denial of service on the entire consensus mechanism.

## Finding Description

The vulnerability exists in the interaction between round creation, the `RoundId` property fallback logic, and validation checks during NextTerm transitions.

**Root Cause:**

The `NextTermInput.ToRound()` method directly copies the mutable `RoundIdForValidation` field without validation: [1](#0-0) 

**Exploitable Fallback Logic:**

The `Round.RoundId` property computes the round ID as the sum of all miners' `ExpectedMiningTime.Seconds` when available. If any miner lacks `ExpectedMiningTime`, it falls back to the `RoundIdForValidation` field: [2](#0-1) 

**Validation Bypass:**

The `TimeSlotValidationProvider` only invokes `CheckRoundTimeSlots()` when it detects a NEW round by comparing `ProvidedRound.RoundId != BaseRound.RoundId`. An attacker can make these equal by crafting a Round with no `ExpectedMiningTime` set (causing `RoundId` to fall back to `RoundIdForValidation`) and setting `RoundIdForValidation` to match the current round's `RoundId`: [3](#0-2) 

**Missing Structural Validation:**

The `RoundTerminateValidationProvider` for NextTerm only validates round/term number incrementing and `InValue` nullability. It does NOT validate that `ExpectedMiningTime` is properly set for all miners: [4](#0-3) 

**Legitimate Round Structure:**

Legitimate rounds generated via `GenerateFirstRoundOfNewTerm()` always populate `ExpectedMiningTime` for all miners, making them distinguishable from malformed rounds: [5](#0-4) 

**Malformed Round Persistence:**

The malformed round bypasses validation and is stored to state via `ProcessNextTerm()` which calls `AddRoundInformation()`: [6](#0-5) [7](#0-6) 

## Impact Explanation

**Complete Consensus Halt:**

Once the malformed round is stored, the consensus mechanism becomes permanently broken:

1. **Mining Interval Calculation Fails:** The `GetMiningInterval()` method requires `ExpectedMiningTime` for the first two miners. Without these values, attempting to calculate the interval will cause a null reference exception: [8](#0-7) 

This method is used extensively in consensus command generation strategies via the `MiningInterval` property: [9](#0-8) 

2. **Time Slot Validation Fails:** Any subsequent attempt to validate rounds via `CheckRoundTimeSlots()` explicitly checks for null `ExpectedMiningTime` and returns a validation failure: [10](#0-9) 

**Severity:** HIGH - The entire blockchain network becomes non-operational. All block production halts, requiring manual chain intervention (hard fork or state recovery) to restore functionality. This affects all nodes, all transactions, and all dependent systems.

## Likelihood Explanation

**Attacker Requirements:**

The attacker must be a current or previous miner, as verified by `PreCheck()`: [11](#0-10) 

This is a realistic threat model - malicious miners are a known concern in consensus systems.

**Attack Complexity:** LOW

The attacker needs to:
1. Query the current round's `RoundId` (public state)
2. Craft a `NextTermInput` protobuf message with:
   - `RoundNumber` = current + 1 (passes validation)
   - `TermNumber` = current + 1 (passes validation)
   - `RealTimeMinersInformation` with miner entries but NO `ExpectedMiningTime` values
   - `RoundIdForValidation` = current round's `RoundId` value
3. Submit via the `NextTerm()` public method during their valid time slot: [12](#0-11) 

**No Economic Barriers:** The attack requires only one malicious transaction. There is no staking loss, slashing, or financial cost to the attacker.

**Detection Difficulty:** The malformed round passes all validation checks before execution. The consensus break only becomes apparent when subsequent operations attempt to use the malformed round data.

## Recommendation

Add explicit validation to ensure `ExpectedMiningTime` is set for all miners in `NextTermInput` before storing the round. Modify `RoundTerminateValidationProvider.ValidationForNextTerm()` to include:

```csharp
// Validate that all miners have ExpectedMiningTime set
if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.ExpectedMiningTime == null))
    return new ValidationResult { Message = "All miners must have ExpectedMiningTime set in NextTerm round." };
```

Alternatively, prevent `RoundIdForValidation` manipulation by computing it internally rather than accepting it from input, or add validation that `RoundIdForValidation` must be zero or must not match the current round's `RoundId` for new term transitions.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousMiner_CanBypassValidation_AndBreakConsensus()
{
    // 1. Setup: Initialize consensus with valid miners
    await InitializeConsensusContract();
    var currentRound = await GetCurrentRound();
    var currentRoundId = currentRound.RoundId; // Non-zero value from ExpectedMiningTime sums
    
    // 2. Attack: Malicious miner crafts NextTermInput
    var maliciousInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        RoundIdForValidation = currentRoundId, // KEY: Set to match current round
        // Add miners but WITHOUT ExpectedMiningTime - causing RoundId fallback
        RealTimeMinersInformation = 
        {
            { "miner1", new MinerInRound { Pubkey = "miner1", Order = 1 } },
            { "miner2", new MinerInRound { Pubkey = "miner2", Order = 2 } }
            // Note: No ExpectedMiningTime set!
        },
        RandomNumber = ByteString.CopyFrom(new byte[32])
    };
    
    // 3. Execute: Submit malicious NextTerm (should fail but doesn't)
    var result = await ConsensusContract.NextTerm(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 4. Verify: Malformed round is stored in state
    var newRound = await GetCurrentRound();
    newRound.RoundNumber.ShouldBe(currentRound.RoundNumber + 1);
    newRound.RealTimeMinersInformation["miner1"].ExpectedMiningTime.ShouldBeNull();
    
    // 5. Impact: Consensus is now broken - GetMiningInterval() will throw
    var exception = Should.Throw<NullReferenceException>(() => newRound.GetMiningInterval());
    
    // 6. All subsequent block production fails - consensus DoS achieved
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-42)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L35-43)
```csharp
        protected MinerInRound MinerInRound => CurrentRound.RealTimeMinersInformation[Pubkey];
        protected int Order => CurrentRound.GetMiningOrder(Pubkey);
        protected int MiningInterval => CurrentRound.GetMiningInterval();

        /// <summary>
        ///     Producing time of every (tiny) block at most.
        /// </summary>
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
