# Audit Report

## Title
Unauthorized PreviousInValue Manipulation Breaks VRF Commit-Reveal Protocol in AEDPoS Consensus

## Summary
The AEDPoS consensus contract allows a malicious miner to inject arbitrary `PreviousInValue` data for other miners during block production without cryptographic validation. While the sender's own `PreviousInValue` is validated against their previous round's `OutValue`, values injected for other miners are trusted unconditionally, breaking the VRF commit-reveal protocol and enabling consensus randomness manipulation.

## Finding Description

The AEDPoS protocol implements a commit-reveal scheme where each miner commits to an `InValue` via `OutValue = Hash(InValue)` in one round, then reveals it as `PreviousInValue` in subsequent rounds. This revelation should be cryptographically verified to ensure `Hash(PreviousInValue) == OutValue` from the previous round.

**Vulnerability Flow:**

**1. Unvalidated Injection During Block Production**

When generating consensus extra data, `UpdateLatestSecretPieces` directly sets other miners' `PreviousInValue` from `triggerInformation.RevealedInValues` without any cryptographic validation: [1](#0-0) 

The `RevealedInValues` originates from node-side `SecretSharingService.GetRevealedInValues()`: [2](#0-1) 

A malicious node operator can modify their `SecretSharingService` implementation to return arbitrary values instead of legitimate secret-sharing-derived values from `RevealPreviousInValues`: [3](#0-2) 

**2. Propagation via Block Header**

The injected fake values are included in the simplified round sent in the block header: [4](#0-3) 

**3. Unconditional Overwrite During Validation**

During `ValidateBeforeExecution`, `RecoverFromUpdateValue` unconditionally overwrites ALL miners' `PreviousInValue` from the provided round data without validation: [5](#0-4) [6](#0-5) 

**4. Insufficient Validation**

The `UpdateValueValidationProvider` ONLY validates the sender's `PreviousInValue` cryptographically, completely ignoring all other miners: [7](#0-6) 

Note that line 38 restricts validation to `validationContext.SenderPubkey` only, and line 48 performs the cryptographic check `HashHelper.ComputeFrom(previousInValue) == previousOutValue` exclusively for the sender.

**5. State Persistence During Execution**

The transaction input extracts the corrupted `PreviousInValue` values from the round: [8](#0-7) 

During execution, `PerformSecretSharing` unconditionally applies these fake values to all miners without any validation: [9](#0-8) 

These fake values persist to blockchain state through `TryToUpdateRoundInformation`.

## Impact Explanation

**Critical Consensus Integrity Compromise:**

1. **VRF Commit-Reveal Protocol Violation**: The protocol's security depends on miners being unable to forge other miners' revealed in-values. By allowing arbitrary injection without verifying `Hash(PreviousInValue) == OutValue` for non-sender miners, the cryptographic binding between commitment and revelation is completely broken.

2. **Randomness Manipulation**: `PreviousInValue` values directly influence consensus signatures through `CalculateSignature`: [10](#0-9) 

These signatures determine mining order in subsequent rounds and feed into VRF-based random number generation. An attacker can influence randomness by setting arbitrary `PreviousInValues` for other miners, affecting validator selection, election outcomes, and any protocol operations dependent on consensus randomness.

3. **State Corruption Propagation**: Once injected, fake `PreviousInValues` persist in blockchain state and propagate to subsequent blocks through the `MinersPreviousInValues` collection mechanism, compounding the integrity compromise.

4. **No Cryptographic Proof**: There exists no verification that the party setting another miner's `PreviousInValue` actually knows the corresponding `InValue` or that it satisfies the hash relationship with that miner's `OutValue`.

## Likelihood Explanation

**High Likelihood:**

- **Minimal Attack Prerequisites**: Attacker needs only one miner position (standard in DPoS) and ability to modify their own node software (standard threat model for malicious operators).

- **Trivial Execution**: Attacker modifies `SecretSharingService.GetRevealedInValues()` to return fabricated values, then produces blocks normally during scheduled time slots. No complex exploit sequence required.

- **Explicit Validation Gap**: The contract explicitly validates only the sender's `PreviousInValue` cryptographically. The validation code contains no checks for other miners' values, making this a design-level oversight rather than an edge case.

- **No Detection Mechanism**: No contract-side verification distinguishes legitimate secret-sharing-derived values from attacker-injected values. The protocol blindly trusts the block producer for all non-sender miner data.

- **Strong Economic Incentive**: Manipulating consensus randomness provides substantial advantages in validator selection, determining mining schedules, influencing election outcomes, and creating predictable/controllable random values for protocol operations.

## Recommendation

Implement cryptographic validation for ALL miners' `PreviousInValue` fields, not just the sender's. In `UpdateLatestSecretPieces`, before setting any miner's `PreviousInValue`, verify:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        // Verify against previous round's OutValue
        if (TryToGetPreviousRoundInformation(out var previousRound) &&
            previousRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
            {
                // Skip or reject invalid revealed in-value
                Context.LogDebug(() => $"Invalid revealed in-value for {revealedInValue.Key}");
                continue;
            }
        }
        
        if (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
            updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null)
        {
            updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
        }
    }
}
```

Additionally, add similar validation in `RecoverFromUpdateValue` and `PerformSecretSharing` to enforce the cryptographic guarantee at all entry points.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy a modified AElf node where `SecretSharingService.GetRevealedInValues()` returns fabricated hash values for other miners
2. When the malicious miner produces a block during their time slot, inject fake `RevealedInValues` 
3. Observe that `UpdateValueValidationProvider` validation passes (only checks sender)
4. Verify fake `PreviousInValue` values persist to state via `PerformSecretSharing`
5. Confirm these fake values influence `CalculateSignature` output, affecting subsequent round order

The critical code path demonstrating lack of validation:
- Node injects fake values → `UpdateLatestSecretPieces` applies without validation → `GetUpdateValueRound` includes in block header → `ValidateBeforeExecution` only checks sender → `PerformSecretSharing` persists to state

## Notes

This vulnerability represents a fundamental breach of the VRF commit-reveal protocol's security assumptions. The validation asymmetry (cryptographic verification for sender, blind trust for others) creates an exploitable gap that undermines consensus randomness integrity. The fix requires extending cryptographic validation to ALL miners' `PreviousInValue` fields across all code paths where they are set or updated.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L84-93)
```csharp
    public Dictionary<string, Hash> GetRevealedInValues(long roundId)
    {
        _revealedInValues.TryGetValue(roundId, out var revealedInValues);
        Logger.LogDebug($"[GetRevealedInValues]Round id: {roundId}");
        if (revealedInValues != null)
            Logger.LogDebug($"Revealed {revealedInValues.Count} in values for round of id {roundId}");

        _revealedInValues.Remove(roundId);
        return revealedInValues ?? new Dictionary<string, Hash>();
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-184)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        var revealedInValues = new Dictionary<string, Hash>();

        foreach (var pair in round.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == selfPubkey) continue;

            var pubkey = pair.Key;
            var minerInRound = pair.Value;

            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
        }

        _revealedInValues[secretSharingInformation.CurrentRoundId] = revealedInValues;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
