# Audit Report

## Title
Unbounded Nested Loop Complexity in Consensus Round Update Causes Block Production Denial of Service

## Summary
The `ApplyNormalConsensusData` function contains nested loops with O(conflicts × positions × minersCount) complexity that can exceed AElf's execution branch threshold of 15,000, causing block production failures when miner counts reach 100+. This creates a consensus-level denial of service where miners cannot generate valid consensus extra data, disrupting the blockchain's core availability guarantee.

## Finding Description

The vulnerability exists in the consensus round update logic where miners' next-round order assignments are calculated and conflicts are resolved. The critical nested loop structure is found in the conflict resolution algorithm: [1](#0-0) 

The outer `foreach` loop iterates over miners with duplicate `FinalOrderOfNextRound` values. For each conflict, the inner `for` loop searches up to `2 * minersCount` positions. Inside that loop, the `All()` method checks all miners to verify position availability, creating O(conflicts × positions_searched × minersCount) complexity.

This function is invoked during normal block production when miners generate consensus extra data through the ACS4 interface: [2](#0-1) [3](#0-2) 

The critical enabler is that `SetMaximumMinersCount` lacks upper bound validation: [4](#0-3) 

AElf enforces execution limits through branch counting that throws an exception when exceeded: [5](#0-4) [6](#0-5) 

The order assignment uses hash-based modulo, creating natural collision probability: [7](#0-6) [8](#0-7) 

With 100 miners, realistic scenarios exceed the threshold:
- 1 conflict searching 150 positions: 1 × 150 × 100 = 15,000 branches (at limit)
- 2 conflicts searching 100 positions: 2 × 100 × 100 = 20,000 branches (exceeds by 33%)

## Impact Explanation

When the branch threshold is exceeded, `RuntimeBranchThresholdExceededException` is thrown, causing the miner's `GetConsensusExtraData` call to fail. This prevents the miner from generating valid consensus extra data, causing their block production attempt to fail.

If multiple miners experience this condition simultaneously (highly likely given the deterministic nature of hash collisions), the chain suffers:

- **Block production delays or complete halts** - consensus cannot progress
- **Transaction confirmation delays** - affecting all network users
- **Consensus mechanism disruption** - core availability guarantee broken
- **Operational unavailability** - requires emergency governance intervention to reduce miner count

This represents **HIGH severity** as it causes denial of service to the blockchain's core consensus mechanism. While it requires governance to set parameters enabling the condition, consensus availability is a critical security property. Unlike fund loss vulnerabilities, this impacts the entire network's operational integrity.

## Likelihood Explanation

**Preconditions:**
1. Governance must set `MaximumMinersCount` to 100+ (a legitimate network scaling action)
2. Order conflicts must occur among miners (natural hash collisions)

**Likelihood Assessment: MEDIUM-HIGH**

As the network matures and scales, governance will naturally increase miner counts toward 100+ to accommodate growth and decentralization. The hash-based order assignment creates collision probability that increases with miner count (birthday problem dynamics).

With 100 miners, each producing blocks:
- Hash-based order assignment creates natural collisions without malicious intent
- Probability of conflicts increases as O(n²) with miner count
- No special permissions or attack coordination required
- Failure is deterministic once parameters cross the threshold
- The comment "Multiple conflicts is unlikely" (line 29) becomes invalid at scale

Early stage networks with the default 17 miners are safe, but the risk increases sharply as networks scale to 50-100+ miners - a natural evolutionary path for a successful blockchain.

## Recommendation

Add an upper bound validation to `SetMaximumMinersCount` to prevent miner counts that could trigger branch threshold violations:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    // Add upper bound based on branch threshold safety margin
    Assert(input.Value > 0 && input.Value <= 50, 
        "Invalid max miners count. Must be between 1 and 50.");
    
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");
    
    // ... rest of method
}
```

The bound should be calculated based on:
- Branch threshold (15,000)
- Expected conflict rate
- Average positions searched per conflict
- Safety margin (recommend 50 miners as conservative limit)

Alternatively, optimize the conflict resolution algorithm to use a more efficient data structure (HashSet) for position availability checking, reducing complexity from O(n) to O(1) per check.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Set MaximumMinersCount to 100
2. Simulate consensus round with miners producing blocks
3. Trigger order conflicts through controlled signatures
4. Observe RuntimeBranchThresholdExceededException during GetConsensusExtraData call
5. Verify block production failure

The vulnerability is deterministic given sufficient miner count and natural hash collision patterns during normal block production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-58)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-22)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-35)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```
