# Audit Report

## Title
Signature Manipulation in First Round of Term Allows Mining Order Prediction

## Summary
During the first round of each consensus term, miners can manipulate their `InValue` to control signature calculation, which directly determines their mining order in the subsequent round. This breaks the randomness guarantee of the AEDPoS consensus mechanism and enables strategic positioning for transaction ordering advantages.

## Finding Description

The vulnerability exists in the consensus block extra data generation logic. During normal rounds, a miner's signature for the next round is calculated by XORing their previous `InValue` with all signatures from the previous round, providing cryptographic randomness. [1](#0-0) 

However, during the first round of a new term, this recalculation is bypassed. The code checks if it's the first round of the current term, and if so, skips the secure signature derivation. [2](#0-1)  The `IsFirstRoundOfCurrentTerm` method returns true when the previous round's term number differs from the current term number or when the round number is 1. [3](#0-2) 

When the first round check passes, the signature remains as the simple concatenation of `OutValue` and `InValue`. [4](#0-3) 

This signature directly determines the mining order for the next round through a modulo operation. [5](#0-4) 

The `FinalOrderOfNextRound` value is then used when generating the next round to assign actual mining positions. [6](#0-5) 

Critically, the validation logic does not verify that `InValue` was correctly generated through the secret sharing mechanism. It only checks that `OutValue` and `Signature` are non-empty, and that `PreviousInValue` matches the previous round's `OutValue`. [7](#0-6) 

Additionally, during the first round of a new term, the `IsMinerListJustChanged` flag is set to true. [8](#0-7)  This prevents the `SecretSharingInformation` event from firing. [9](#0-8) 

Without the `SecretSharingInformation` event, the proper `InValue` generation through secret sharing does not occur, as the event triggers `AddSharingInformationAsync` which generates the secure InValue. [10](#0-9) 

A malicious miner can exploit this by:
1. Running modified node software during the first round of a term
2. Brute-forcing different `InValue` candidates offline
3. Calculating `signature = ConcatAndCompute(Hash(InValue), InValue)` for each
4. Finding an `InValue` where `GetAbsModulus(signature.ToInt64(), minersCount) + 1` equals their desired order
5. Injecting this custom `InValue` through their node's trigger information
6. The contract accepts it without validation, assigning them their chosen position in round 2

## Impact Explanation

**Consensus Integrity Violation**: The vulnerability breaks a fundamental security property of the AEDPoS consensus mechanism - the unpredictability of mining order. Mining order is supposed to be determined through cryptographic randomness (secret sharing and signature aggregation), but this vulnerability allows deterministic manipulation.

**Strategic Advantage**: By controlling their position in round 2 of each term, an attacker gains:
- **First-miner privilege**: Ability to be the first to propose blocks, enabling transaction ordering control
- **MEV extraction**: Priority access to transaction ordering for maximum extractable value
- **Front-running capability**: Ability to observe pending transactions and order their own advantageously
- **Unfair competitive edge**: Systematic advantage over honest miners who follow the protocol

**Recurring Exploitation**: While limited to the first round of each term, this occurs at every term transition during validator set changes, making it a regularly exploitable condition rather than a one-time event.

## Likelihood Explanation

**Attacker Prerequisites**: The attacker must be an elected validator participating in the first round of a term. Since term transitions occur during regular validator elections, any elected validator can exploit this vulnerability.

**Technical Feasibility**: 
- **Trivial computation**: Brute-forcing hash values to find a favorable `InValue` takes milliseconds on standard hardware
- **No cryptographic barrier**: The signature formula is deterministic and publicly known; finding a desired signature is a simple search problem
- **Easy implementation**: Node software is open-source, and the InValue comes from off-chain trigger information that miners control

**Execution Path**:
1. Attacker modifies their node software to override the normal `InValue` generation
2. During first round of term, pre-computes multiple `InValue` candidates
3. Selects `InValue` that produces desired mining order
4. Node provides this `InValue` in the consensus trigger information
5. Contract validates only that values are non-empty (no correctness check)
6. Attacker receives desired position in round 2

**Detection Impossibility**: There is no on-chain mechanism to distinguish between a legitimately generated `InValue` and a manipulated one, as the contract performs no validation of `InValue` correctness.

**Economic Incentive**: The benefits (first-miner advantages, MEV opportunities) far exceed the costs (negligible computation), creating strong economic motivation for exploitation.

## Recommendation

Implement validation of `InValue` during the first round of each term. Options include:

1. **Mandatory Secret Sharing**: Fire the `SecretSharingInformation` event even when `IsMinerListJustChanged` is true, ensuring proper InValue generation through the secret sharing mechanism.

2. **Signature Validation**: Always use `CalculateSignature(previousInValue)` with XOR aggregation, even during the first round of a term. For the first round, use a deterministic seed derived from the previous term's final round data.

3. **InValue Commitment Scheme**: Require miners to commit to their InValue before the term starts (e.g., in the last round of the previous term), preventing post-hoc manipulation.

4. **Add InValue Validation**: In `UpdateValueValidationProvider`, verify that the InValue was properly generated by checking it against secret sharing data or a commitment made in a previous round.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploying a test environment with the AEDPoS consensus contract
2. Initiating a term transition to create the first round of a new term
3. Having a malicious validator compute multiple InValue candidates
4. Testing each with `signature = HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(inValue), inValue)`
5. Finding an InValue where `GetAbsModulus(signature.ToInt64(), minersCount) + 1` equals the desired order (e.g., 1)
6. Providing this InValue when producing a block in round 1
7. Verifying that the validator receives position 1 in round 2

The test would verify that no validation prevents the custom InValue from being accepted and that the mining order is successfully manipulated.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-72)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L27-34)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber)
    {
        termNumber = 1;
        return (TryToGetTermNumber(out termNumber) &&
                TryToGetPreviousRoundInformation(out var previousRound) &&
                previousRound.TermNumber != termNumber) ||
               (TryToGetRoundNumber(out var roundNumber) && roundNumber == 1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L39-61)
```csharp
    public async Task AddSharingInformationAsync(SecretSharingInformation secretSharingInformation)
    {
        try
        {
            var selfPubkey = (await _accountService.GetPublicKeyAsync()).ToHex();

            if (!secretSharingInformation.PreviousRound.RealTimeMinersInformation.ContainsKey(selfPubkey)) return;

            var newInValue = await GenerateInValueAsync(secretSharingInformation);
            Logger.LogDebug(
                $"Add in value {newInValue} for round id {secretSharingInformation.CurrentRoundId}");
            _inValueCache.AddInValue(secretSharingInformation.CurrentRoundId, newInValue);

            if (secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count == 1) return;

            await CollectPiecesWithSecretSharingAsync(secretSharingInformation, newInValue, selfPubkey);
            RevealPreviousInValues(secretSharingInformation, selfPubkey);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error in AddSharingInformationAsync.");
        }
    }
```
