# Audit Report

## Title
Consensus Failure via Malformed Signature in NextRound Transition

## Summary
A malicious authorized miner can submit a `NextRoundInput` with `MinerInRound` objects containing malformed `Signature` fields (Hash objects with ByteString values shorter than 8 bytes). This bypasses NextRound validation and gets stored in contract state. When subsequent miners attempt to generate the next round, the `CalculateNextExtraBlockProducerOrder()` function calls `signature.ToInt64()` on the malformed signature, causing `BitConverter.ToInt64()` to throw an `ArgumentException`, permanently halting consensus progression.

## Finding Description

The vulnerability exists in the consensus round generation logic where signature byte length is not validated during NextRound transactions.

**Root Cause**: The `CalculateNextExtraBlockProducerOrder()` function performs a null check on signatures but does not validate that the underlying ByteString has sufficient length for Int64 conversion: [1](#0-0) 

The check `m.Signature != null` passes when a Hash object exists, even if its `Value` ByteString is empty or has fewer than 8 bytes. When `signature.ToInt64()` is called, it chains through the Hash type implementation: [2](#0-1) 

This calls `ByteExtensions.ToInt64()` which directly invokes `BitConverter.ToInt64()` without any length validation: [3](#0-2) 

The .NET `BitConverter.ToInt64()` method requires exactly 8 bytes and throws `ArgumentException` if provided with a shorter array.

**Validation Gap**: The `UpdateValueValidationProvider` correctly validates that signatures have non-empty ByteString values: [4](#0-3) 

However, this validator is **only applied to UpdateValue behavior**, not to NextRound: [5](#0-4) 

For NextRound, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are used, neither of which validates signature byte length.

**Attack Execution Path**:

1. An authorized miner (validated by `PreCheck()`) calls `NextRound()`: [6](#0-5) 

2. The input is converted to a Round object and stored to state: [7](#0-6) 

3. The poisoned round is persisted via `AddRoundInformation()`: [8](#0-7) 

4. When generating subsequent rounds, the poisoned round is retrieved and processed: [9](#0-8) 

5. The `GenerateNextRoundInformation()` method calls `CalculateNextExtraBlockProducerOrder()`: [10](#0-9) 

6. The exception is thrown when attempting to convert the malformed signature to Int64, halting the entire round generation process.

The `NextRoundInput` protobuf structure includes `MinerInRound` objects that can contain signature fields: [11](#0-10) 

Where `MinerInRound` includes: [12](#0-11) 

## Impact Explanation

**Consensus Halt**: Once a malformed round is stored in state, all subsequent attempts to generate consensus extra data fail with an unhandled exception. This prevents any miner from producing blocks beyond the poisoned round.

**Complete Blockchain DoS**: The consensus mechanism becomes permanently inoperable. No transactions can be processed, no blocks can be produced, and the blockchain is effectively frozen.

**Affected Parties**:
- All block producers (miners) who cannot generate valid consensus data
- All blockchain users whose transactions cannot be processed
- The entire network which loses liveness

**Severity**: HIGH - This represents a complete consensus integrity violation. A single malicious or compromised miner can permanently halt the blockchain with a simple malformed message that passes all validation checks.

## Likelihood Explanation

**Attacker Requirements**:
- Must be an authorized miner in the current or previous round's miner list
- This requires being an elected miner, which is a permissioned but obtainable role in AEDPoS

**Attack Complexity**: LOW
- Simply construct a `NextRoundInput` protobuf message with `Signature = new Hash()` or any Hash with `Value.Length < 8`
- No cryptographic complexity or timing requirements
- Single transaction execution

**Detection**: The attack would be immediately evident when the next miner attempts round generation, but by that point the malformed data is already persisted in state.

**Overall Likelihood**: MEDIUM-HIGH for scenarios involving a compromised or malicious elected miner. The attack is trivial to execute once miner status is obtained.

## Recommendation

Add signature byte length validation to the `NextRound` validation flow:

1. **Create a new validation provider** or extend `NextRoundMiningOrderValidationProvider` to validate that all non-null signatures in the provided round have sufficient byte length:

```csharp
// In NextRoundMiningOrderValidationProvider or new SignatureValidationProvider
private bool ValidateSignatureLengths(ConsensusValidationContext validationContext)
{
    var providedRound = validationContext.ProvidedRound;
    foreach (var miner in providedRound.RealTimeMinersInformation.Values)
    {
        if (miner.Signature != null && miner.Signature.Value.Length < 8)
        {
            return false;
        }
    }
    return true;
}
```

2. **Apply this validation to NextRound behavior** in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new SignatureValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

3. **Alternative defensive fix**: Add a length check in `CalculateNextExtraBlockProducerOrder()` before calling `ToInt64()`:

```csharp
var signature = firstPlaceInfo.Signature;
if (signature.Value.Length < 8)
    return 1; // Default to first miner if signature is malformed
var sigNum = signature.ToInt64();
```

The first approach (validation) is preferred as it prevents malformed data from entering state, while the defensive fix only mitigates the crash.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MalformedSignature_Should_Halt_Consensus()
{
    // Setup: Get authorized miner context
    var authorizedMinerKeyPair = InitialMinersKeyPairs[0];
    var consensusStub = GetConsensusContractStub(authorizedMinerKeyPair);
    
    // Get current round
    var currentRound = await consensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Create malicious NextRoundInput with malformed signature
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        // Add miner with malformed signature (empty or < 8 bytes)
        RealTimeMinersInformation = 
        {
            [authorizedMinerKeyPair.PublicKey.ToHex()] = new MinerInRound
            {
                Pubkey = authorizedMinerKeyPair.PublicKey.ToHex(),
                Order = 1,
                Signature = new Hash { Value = ByteString.CopyFrom(new byte[4]) }, // Only 4 bytes
                FinalOrderOfNextRound = 1
            }
        }
    };
    
    // Submit the malicious NextRound transaction - should succeed
    var result = await consensusStub.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attempt to generate next round - should throw ArgumentException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await consensusStub.GetConsensusExtraData.CallAsync(new BytesValue
        {
            Value = new AElfConsensusTriggerInformation
            {
                Pubkey = ByteString.CopyFrom(authorizedMinerKeyPair.PublicKey),
                Behaviour = AElfConsensusBehaviour.NextRound
            }.ToByteString()
        });
    });
    
    // Verify consensus is halted
    exception.InnerException.ShouldBeOfType<ArgumentException>();
    exception.Message.ShouldContain("BitConverter");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** src/AElf.Types/Types/Hash.cs (L105-108)
```csharp
        public long ToInt64()
        {
            return ToByteArray().ToInt64(true);
        }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L53-57)
```csharp
        public static long ToInt64(this byte[] bytes, bool bigEndian)
        {
            var needReverse = !bigEndian ^ BitConverter.IsLittleEndian;
            return BitConverter.ToInt64(needReverse ? bytes.Reverse().ToArray() : bytes, 0);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L36-40)
```csharp
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** protobuf/aedpos_contract.proto (L458-480)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
```
