# Audit Report

## Title
Missing LIB Height Upper Bound Validation in NextRound Allows Future Block Height Attacks

## Summary
The AEDPoS consensus contract's `NextRound` method accepts arbitrary `ConfirmedIrreversibleBlockHeight` values without validating they don't exceed the current block height. The validation flow for NextRound behavior explicitly excludes the `LibInformationValidationProvider`, allowing malicious miners to inject fake future LIB heights that persist in state and corrupt critical consensus calculations.

## Finding Description

**Root Cause - Unvalidated LIB Copying:**

The `NextRoundInput.Create()` method directly copies the `ConfirmedIrreversibleBlockHeight` from the provided Round object without any validation. [1](#0-0) 

**Missing Validation Provider:**

The consensus validation architecture applies different validation providers based on behavior type. For `UpdateValue` behavior, the `LibInformationValidationProvider` is added to validate LIB consistency. [2](#0-1) 

However, for `NextRound` behavior, only these providers are registered: MiningPermissionValidationProvider, TimeSlotValidationProvider, ContinuousBlocksValidationProvider, NextRoundMiningOrderValidationProvider, and RoundTerminateValidationProvider. [3](#0-2) 

**Insufficient Validation Logic:**

Even if `LibInformationValidationProvider` were applied, it only checks that LIB doesn't decrease (comparing against previous round values), not that it doesn't exceed the current block height. [4](#0-3) 

**Direct Storage Without Recalculation:**

The `ProcessNextRound` method converts the input directly to a Round object and stores it without recalculating or validating the LIB height. [5](#0-4) 

The `AddRoundInformation` method performs simple state storage without any validation. [6](#0-5) 

**Persistence Mechanism:**

The fake LIB persists indefinitely because `ProcessUpdateValue` only updates the stored LIB when the newly calculated LIB is higher than the current stored value. [7](#0-6) 

If an attacker sets LIB to a very high future value (e.g., current_height + 1000000), it won't be overwritten until the blockchain naturally progresses to that height.

**Attack Execution Path:**

1. Attacker is an elected miner assigned to produce the NextRound extra block
2. Attacker crafts a `NextRoundInput` with modified `ConfirmedIrreversibleBlockHeight` set to a future value
3. Attacker calls the public `NextRound` method during their assigned time slot [8](#0-7) 
4. Validation passes (no LIB upper bound check exists)
5. Fake LIB is stored in contract state
6. All subsequent consensus operations use the corrupted LIB value

## Impact Explanation

**Critical Consensus State Corruption:**

The `GetMaximumBlocksCount` method uses `ConfirmedIrreversibleBlockHeight` to evaluate blockchain mining status. [9](#0-8) 

With a fake future LIB height:
- The distance calculation (`currentHeight.Sub(libBlockHeight)`) becomes negative or wraps around
- Blockchain mining status evaluation (Normal/Abnormal/Severe) becomes incorrect
- The `IrreversibleBlockHeightUnacceptable` event may be falsely triggered or suppressed
- Block production limits are miscalculated, affecting consensus performance

**Fundamental Invariant Violation:**

The Last Irreversible Block (LIB) is a fundamental consensus safety guarantee representing blocks that have achieved finality and cannot be reverted. Storing future fictional LIB heights violates this core property and could cascade to:
- Cross-chain operations that rely on LIB for merkle proof verification
- Block validators making incorrect finality assessments
- Consensus safety assumptions being violated

**Network-Wide Impact:**

All network participants operating on the corrupted consensus state are affected, as the fake LIB persists in the shared blockchain state.

## Likelihood Explanation

**Attacker Profile:**
Any elected miner in the current consensus round can execute this attack. Being an elected miner is the only prerequisite - no additional special permissions are required.

**Attack Complexity: LOW**

The attack requires only:
1. Obtaining legitimately generated next round data (via public view methods)
2. Modifying the `ConfirmedIrreversibleBlockHeight` field to a future value
3. Submitting the modified transaction during the assigned NextRound time slot

**Technical Feasibility: HIGH**

The attack is fully executable because:
- `NextRound` is a public method with no authorization beyond miner list membership
- Validation explicitly lacks LIB height upper bound checks
- The ConsensusValidationContext exposes the attacker's provided Round data directly for validation [10](#0-9) 
- No other validation layer exists to catch this manipulation

**Detection Difficulty: MODERATE**

The fake LIB would be visible in round state queries but might not trigger immediate alarms without active monitoring of LIB progression patterns against actual block heights.

## Recommendation

**Primary Fix: Add LIB Upper Bound Validation**

Add `LibInformationValidationProvider` to the NextRound validation flow and enhance it to validate upper bounds:

```csharp
// In AEDPoSContract_Validation.cs, add to NextRound case:
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;

// In LibInformationValidationProvider.cs, add upper bound check:
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    
    // Add upper bound validation
    if (providedRound.ConfirmedIrreversibleBlockHeight > validationContext.CurrentBlockHeight)
    {
        validationResult.Message = "LIB height cannot exceed current block height.";
        return validationResult;
    }
    
    // Existing checks...
    if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
        providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
        (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
         baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
    {
        validationResult.Message = "Incorrect lib information.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Secondary Fix: Recalculate LIB in ProcessNextRound**

Instead of blindly trusting the provided LIB, recalculate it from the current round state before storing:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Recalculate LIB from current state instead of trusting input
    if (TryToGetCurrentRoundInformation(out var currentRound) && 
        TryToGetPreviousRoundInformation(out var previousRound))
    {
        new LastIrreversibleBlockHeightCalculator(currentRound, previousRound)
            .Deconstruct(out var calculatedLib);
        nextRound.ConfirmedIrreversibleBlockHeight = calculatedLib;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber;
    }
    
    // Rest of the method...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_FutureLIBHeight_ShouldBeRejected()
{
    // Arrange: Setup consensus with elected miners
    var miners = await InitializeConsensusAsync();
    var currentHeight = await GetCurrentBlockHeightAsync();
    var extraBlockMiner = miners.First();
    
    // Generate legitimate next round data
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var nextRoundData = GenerateNextRoundData(currentRound);
    
    // Act: Malicious miner modifies LIB to future value
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = nextRoundData.RoundNumber,
        RealTimeMinersInformation = { nextRoundData.RealTimeMinersInformation },
        ConfirmedIrreversibleBlockHeight = currentHeight + 1000000, // Future height
        ConfirmedIrreversibleBlockRoundNumber = nextRoundData.ConfirmedIrreversibleBlockRoundNumber,
        // ... other fields
    };
    
    // Submit NextRound with fake LIB
    await extraBlockMiner.NextRound(maliciousInput);
    
    // Assert: Verify fake LIB was stored (vulnerability confirmed)
    var storedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    storedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(currentHeight + 1000000);
    
    // Verify GetMaximumBlocksCount is corrupted
    var maxBlocksCount = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    // Calculation will be incorrect due to negative distance
}
```

**Notes:**

This vulnerability represents a critical consensus integrity issue. The absence of LIB upper bound validation in the NextRound flow creates a persistent state corruption vector that any elected miner can exploit. The fix requires both adding proper validation and potentially recalculating LIB values rather than trusting miner-provided inputs for this critical consensus parameter.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-282)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```
