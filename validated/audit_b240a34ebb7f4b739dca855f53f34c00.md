# Audit Report

## Title
Configuration Mismatch: Hardcoded TinyBlocksCount Causes Incorrect Mining Time Limits During Dynamic Block Count Adjustments

## Summary
The AEDPoS consensus contract uses a hardcoded `TinyBlocksCount = 8` constant for calculating mining time limits, while the actual maximum blocks count is dynamically adjusted via `GetMaximumBlocksCount()` based on blockchain status. During Severe blockchain status, miners are restricted to 1 block per time slot but receive mining time limits calculated for 8 blocks, resulting in only 12.5% of the proportional time allocation.

## Finding Description

The vulnerability stems from an architectural mismatch between two consensus subsystems that evolved independently:

**1. Hardcoded Timing Calculations:**

The `CommandStrategyBase` class defines mining time limits using a hardcoded constant [1](#0-0) .

This constant derives the time slot interval per block [2](#0-1) .

Which then calculates the default mining time limit [3](#0-2) .

**2. Dynamic Block Count Adjustment:**

Meanwhile, `GetMaximumBlocksCount()` dynamically determines the actual maximum blocks based on blockchain status [4](#0-3) .

During Severe status (when current round ≥ LIB round + 8), it returns 1 [5](#0-4) .

**3. The Mismatch:**

The behavior provider correctly uses the dynamic value to restrict block production [6](#0-5) .

This is called with the dynamic `GetMaximumBlocksCount()` value [7](#0-6) .

However, when generating consensus commands for UpdateValue blocks (the main consensus block), the static `DefaultBlockMiningLimit` is used [8](#0-7) .

For comparison, term-ending blocks receive the full proportional time [9](#0-8) .

The constant originates from the contract constants [10](#0-9) .

## Impact Explanation

**Consensus Integrity Violation:**

During Severe blockchain status—specifically designed as a recovery mechanism when LIB lags significantly—miners receive `(MiningInterval / 8) * 3/5` milliseconds for their single allowed block. This is the same time allocation as one tiny block during normal 8-block production, representing only 12.5% of the proportional allocation they would receive if the system correctly adjusted timing to match the reduced block count.

**Quantified Impact:**
- Normal term-ending blocks: `MiningInterval * 3/5` (60% of interval)
- Severe status single blocks: `MiningInterval * 3/40` (7.5% of interval)
- Shortfall: 87.5% reduction from proportional allocation

**System-Wide Consequences:**

The blockchain enters Severe status to protect against forks during consensus stress. However, this mismatch creates a negative feedback loop:
1. Network stress causes LIB lag → Severe status triggered
2. Miners restricted to 1 block but given 1/8th proportional time
3. Insufficient mining time prevents timely block production
4. LIB advancement stalls further, prolonging Severe status
5. Extended consensus degradation may require manual intervention

This directly violates the consensus guarantee that Severe status should facilitate recovery, not hinder it.

## Likelihood Explanation

**Automatic Trigger Path:**

Severe status activation is deterministic and requires no adversarial action [11](#0-10) .

**Realistic Preconditions:**

The LIB lag threshold (8 rounds) can occur during:
- Network latency spikes or partitions
- High transaction volume overwhelming validators
- Temporary validator coordination failures
- Infrastructure issues affecting subset of miners

These are operational scenarios that occur in production blockchain networks under stress, not theoretical edge cases.

**Invocation Path:**

The mismatch executes automatically through the normal consensus flow without requiring any specific transaction or attacker action. Every consensus command generation during Severe status produces the incorrect time limit [12](#0-11) .

## Recommendation

Replace the hardcoded `TinyBlocksCount` constant with a dynamic parameter in `CommandStrategyBase` that receives the actual maximum blocks count from `GetMaximumBlocksCount()`. This ensures timing calculations remain proportional to the actual block count restriction.

**Suggested Fix:**

1. Modify `NormalBlockCommandStrategy` to accept and pass `maximumBlocksCount` parameter
2. Update `CommandStrategyBase` to use this dynamic value instead of the hardcoded constant
3. Calculate `TinyBlockSlotInterval` as `MiningInterval.Div(maximumBlocksCount)` instead of `MiningInterval.Div(TinyBlocksCount)`
4. This ensures `DefaultBlockMiningLimit` scales proportionally: when `maximumBlocksCount = 1`, the limit becomes `MiningInterval * 3/5` (matching term-ending blocks)

## Proof of Concept

The vulnerability is demonstrated through the code execution path:

1. During network stress, LIB lags by 8+ rounds
2. Miner calls `GetConsensusCommand()` 
3. Code evaluates blockchain status, determines Severe status, returns `maximumBlocksCount = 1`
4. Behaviour provider restricts miner to 1 block
5. `NormalBlockCommandStrategy` generates command with `LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit`
6. `DefaultBlockMiningLimit = MiningInterval / 8 * 3 / 5` (based on hardcoded TinyBlocksCount=8)
7. Miner receives only 7.5% of interval time instead of 60%
8. Insufficient time prevents timely block production, prolonging Severe status

This sequence is fully automatic and requires no specific test transaction—it occurs naturally during consensus stress conditions in the production network.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L17-17)
```csharp
        private const int TinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-42)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L60-60)
```csharp
        protected int LastBlockOfCurrentTermMiningLimit => MiningInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L39-46)
```csharp
        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L39-39)
```csharp
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L34-37)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();
```
