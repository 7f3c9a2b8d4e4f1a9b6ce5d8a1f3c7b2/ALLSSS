# Audit Report

## Title
Period Boundary Validation Bypass Causes Permanent Share Dilution in Profit Distribution

## Summary
The `AddBeneficiary` and `FixProfitDetail` methods in the Profit contract fail to validate that `EndPeriod >= StartPeriod`, allowing profit details with inverted period boundaries to be created. When schemes use delayed distribution (`DelayDistributePeriodCount > 0`), these malformed details have their shares permanently added to `TotalShares` but are filtered out during profit claims, causing irreversible dilution of all legitimate beneficiaries' profits. The Treasury's CitizenWelfare scheme uses delayed distribution and is directly affected.

## Finding Description

The vulnerability exists in the period boundary validation logic of the Profit contract. The `AddBeneficiary` method validates that the user-provided `EndPeriod` is at least the current period [1](#0-0) , but then calculates `StartPeriod` by adding `DelayDistributePeriodCount` to the current period [2](#0-1) . There is no validation that the resulting `StartPeriod` is less than or equal to `EndPeriod`.

**Attack Scenario:**
1. A scheme has `CurrentPeriod = 100` and `DelayDistributePeriodCount = 50`
2. Manager calls `AddBeneficiary` with `EndPeriod = 120`
3. Validation passes: `120 >= 100` ✓
4. System calculates: `StartPeriod = 100 + 50 = 150`
5. Result: `StartPeriod (150) > EndPeriod (120)` - invalid state created

The shares from this malformed detail are immediately added to the scheme's `TotalShares` [3](#0-2) .

When `ClaimProfits` is called, malformed details are filtered out by the `availableDetails` check that requires `EndPeriod >= StartPeriod` when `LastProfitPeriod == 0` [4](#0-3) . Since these details never make it into `availableDetails`, they are never added to `profitableDetails` [5](#0-4) , and consequently never make it into `profitDetailsToRemove` [6](#0-5) . Only shares from `profitDetailsToRemove` are subtracted from `TotalShares`, leaving the malformed detail's shares permanently inflating the denominator.

The `FixProfitDetail` method has the same issue - it allows independent modification of `StartPeriod` and `EndPeriod` without validating their relationship [7](#0-6) .

## Impact Explanation

**Direct Economic Impact:**
When orphaned shares remain in `TotalShares`, all profit distributions use an inflated denominator. For example:
- Legitimate beneficiary Alice: 1,000 shares
- Malformed beneficiary Bob: 9,000 shares (StartPeriod > EndPeriod)
- `TotalShares = 10,000`, but only Alice can claim
- Distribution of 100,000 tokens: Alice receives `(1,000 / 10,000) × 100,000 = 10,000`
- Alice gets 10% instead of 100%, losing 90,000 tokens
- The 90,000 unclaimed tokens remain locked in period-specific virtual addresses indefinitely

**Affected Systems:**
The Treasury's CitizenWelfare scheme uses `DelayDistributePeriodCount = 1` [8](#0-7) , making it directly vulnerable. This affects citizen welfare distributions, a core economic mechanism of the AElf chain.

**Severity: HIGH**
- Causes permanent, irreversible fund lockup
- Affects core Treasury/Welfare economic distributions
- Impact compounds with each distribution period
- No recovery mechanism exists for locked funds

## Likelihood Explanation

**Unintentional Trigger:**
Scheme managers may not understand that `DelayDistributePeriodCount` affects the `StartPeriod` calculation. When adding beneficiaries with reasonable-looking end periods, they can inadvertently create invalid states. For a scheme with `DelayDistributePeriodCount = 50`, any `EndPeriod` less than `CurrentPeriod + 50` creates the vulnerability.

**Intentional Exploitation:**
A malicious or compromised scheme manager can deliberately:
1. Use `AddBeneficiary` to add beneficiaries with strategically chosen `EndPeriod` values to dilute legitimate beneficiaries
2. Use `FixProfitDetail` to modify existing valid profit details into invalid ones

**Feasibility: HIGH**
- Entry points are public methods callable by scheme managers (trusted but not infallible)
- Precondition met: Treasury's Welfare scheme has `DelayDistributePeriodCount = 1`
- Single transaction execution
- Difficult to detect without deep state inspection
- No warning or error returned to indicate the invalid state creation

## Recommendation

Add validation in both `AddBeneficiary` and `FixProfitDetail` to ensure `EndPeriod >= StartPeriod`:

**For AddBeneficiary** (after line 180):
```csharp
Assert(input.EndPeriod >= scheme.CurrentPeriod,
    $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

// Add this validation AFTER calculating StartPeriod:
var calculatedStartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
Assert(input.EndPeriod >= calculatedStartPeriod,
    $"Invalid end period. End Period must be >= {calculatedStartPeriod} (CurrentPeriod + DelayDistributePeriodCount).");
```

**For FixProfitDetail** (after line 301):
```csharp
Assert(newDetail.EndPeriod >= newDetail.StartPeriod,
    "Invalid period boundaries. EndPeriod must be >= StartPeriod.");
```

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_PeriodBoundaryBypass_ShareDilution_Test()
{
    const int delayDistributePeriodCount = 50;
    const long legitimateShares = 1000;
    const long malformedShares = 9000;
    const long distributeAmount = 100000;
    
    var creator = Creators[0];
    var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    var legitBeneficiary = Accounts[0].Address;
    
    // Create scheme with DelayDistributePeriodCount = 50
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        ProfitReceivingDuePeriodCount = 100,
        DelayDistributePeriodCount = delayDistributePeriodCount
    });
    
    var createdSchemeIds = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds;
    _schemeId = createdSchemeIds.First();
    
    var scheme = await creator.GetScheme.CallAsync(_schemeId);
    var currentPeriod = scheme.CurrentPeriod; // Should be 1
    
    // Add legitimate beneficiary with valid EndPeriod
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = _schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = legitBeneficiary,
            Shares = legitimateShares
        },
        EndPeriod = currentPeriod + 100 // Valid: 101 >= (1 + 50) = 51
    });
    
    // Add malformed beneficiary: EndPeriod < (CurrentPeriod + DelayDistributePeriodCount)
    // This should fail but doesn't due to missing validation
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = _schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = Accounts[1].Address,
            Shares = malformedShares
        },
        EndPeriod = currentPeriod + 20 // Invalid: 21 < (1 + 50) = 51
        // StartPeriod will be 51, EndPeriod will be 21 -> StartPeriod > EndPeriod
    });
    
    // Check TotalShares includes both legitimate and malformed shares
    scheme = await creator.GetScheme.CallAsync(_schemeId);
    scheme.TotalShares.ShouldBe(legitimateShares + malformedShares); // 10000
    
    // Distribute profits for period 51 (after delay period passes)
    for (int i = 1; i <= 51; i++)
    {
        await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = _schemeId,
            Symbol = ProfitContractTestConstants.NativeTokenSymbol,
            Amount = distributeAmount
        });
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = _schemeId,
            Period = i,
            AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 0 } }
        });
    }
    
    // Legitimate beneficiary claims profits
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = legitBeneficiary,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    await Accounts[0].ProfitStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = _schemeId,
        Beneficiary = legitBeneficiary
    });
    
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = legitBeneficiary,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    var received = balanceAfter - balanceBefore;
    
    // Legitimate beneficiary should receive 100% (100,000) but receives only 10% (10,000)
    // because TotalShares = 10,000 instead of 1,000
    received.ShouldBe(distributeAmount * legitimateShares / (legitimateShares + malformedShares)); // 10,000
    received.ShouldNotBe(distributeAmount); // Should be 100,000 but isn't
    
    // 90,000 tokens remain locked in the scheme's period virtual address permanently
    var lockedAmount = distributeAmount - received;
    lockedAmount.ShouldBe(90000);
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L188-189)
```csharp
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L299-301)
```csharp
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L767-767)
```csharp
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-792)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```
