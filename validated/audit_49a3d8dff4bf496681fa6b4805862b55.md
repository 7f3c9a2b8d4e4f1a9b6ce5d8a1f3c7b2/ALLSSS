# Audit Report

## Title
Off-by-One Error in Profit Detail Cleanup Causes Permanent Loss of Unclaimed Profits

## Summary
The `AddBeneficiary` method in the Profit contract uses an incorrect comparison operator (`>=` instead of `>`) when cleaning up expired profit details, causing beneficiaries to permanently lose their final period's unclaimed profits. This inconsistency with the `ClaimProfits` method's cleanup logic creates a critical vulnerability where time-limited beneficiaries lose funds they are entitled to claim.

## Finding Description
The vulnerability exists in the cleanup logic that removes old profit details. The contract maintains profit details for beneficiaries, tracking which periods they can claim through the `LastProfitPeriod` and `EndPeriod` fields.

**Key semantic fact:** `LastProfitPeriod` represents the **next** period to claim, not the last claimed period. After claiming period N, the contract sets `LastProfitPeriod = N + 1`. [1](#0-0) 

The claiming loop iterates from `LastProfitPeriod` to `maxProfitPeriod` (inclusive), meaning when `LastProfitPeriod == EndPeriod`, that period is still claimable. [2](#0-1) 

**The bug:** In `AddBeneficiary`, the cleanup condition uses `>=` to check if a detail should be removed. [3](#0-2)  This incorrectly removes details where `LastProfitPeriod == EndPeriod`, even though the beneficiary can still claim that final period.

**Proof of inconsistency:** The `ClaimProfits` method correctly uses strict inequality `>` for its cleanup logic. [4](#0-3)  This confirms that details should only be removed when `LastProfitPeriod > EndPeriod`.

The view methods also confirm this interpretation, filtering available details using `EndPeriod >= LastProfitPeriod`, which includes the equality case. [5](#0-4) 

**Attack scenario:**
1. Beneficiary added with `EndPeriod = 10`
2. Beneficiary claims periods 1-9, setting `LastProfitPeriod = 10`
3. Period 10 cannot be claimed yet (only periods up to `CurrentPeriod - 1` are claimable) [6](#0-5) 
4. Time advances beyond `EndPeriod + ProfitReceivingDuePeriodCount` (default 10 periods) [7](#0-6) 
5. Any `AddBeneficiary` call triggers cleanup
6. The condition `LastProfitPeriod (10) >= EndPeriod (10)` evaluates to true
7. The detail is permanently deleted, preventing period 10 from ever being claimed

## Impact Explanation
**Severity: HIGH** due to guaranteed fund loss under realistic conditions.

**Direct impact:**
- Beneficiaries permanently lose their final period's profits
- No recovery mechanism exists once the detail is deleted
- Funds remain locked in the scheme's virtual address, unclaimable

**Affected users:**
- Any beneficiary with time-limited participation (`EndPeriod != long.MaxValue`)
- Common in voting rewards, staking programs, and time-bound profit schemes
- Particularly impacts users who claim regularly but miss the narrow window for their final period

**Quantified loss:**
- If periods distribute 100 ELF each and a beneficiary has 10 periods, they lose 100 ELF (10% of total)
- Scales with the number of affected beneficiaries and period amounts
- In high-value schemes, this represents substantial cumulative losses

## Likelihood Explanation
**Probability: HIGH** - This occurs naturally during normal protocol operations without any malicious actor.

**Entry point:** The public `AddBeneficiary` method [8](#0-7)  is called routinely when new participants join profit schemes.

**Realistic preconditions:**
1. Users claim profits periodically (e.g., weekly) rather than every period
2. The final period becomes claimable after their last claim
3. The 10-period grace window expires before they realize they have one more period to claim
4. New beneficiaries are added (triggering cleanup) before the victim claims their final period

**Why it's likely:**
- Users cannot claim period N until `CurrentPeriod > N`, creating a natural delay
- The grace period of 10 periods can pass quickly in active schemes
- Users naturally assume they've claimed everything after their `EndPeriod` passes
- No warning or notification system alerts users about unclaimed final periods

## Recommendation
Change the cleanup condition in `AddBeneficiary` from `>=` to `>` to match the logic in `ClaimProfits`:

```csharp
// Current (buggy) code at line 204-206:
var oldProfitDetails = currentProfitDetails.Details.Where(
    d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
         d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();

// Fixed code:
var oldProfitDetails = currentProfitDetails.Details.Where(
    d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod > d.EndPeriod &&
         d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
```

This ensures consistency with `ClaimProfits` and preserves the invariant that beneficiaries can claim all periods through their `EndPeriod`.

## Proof of Concept
```csharp
[Fact]
public async Task AddBeneficiary_PrematureCleanup_LosesFinalPeriod()
{
    const int endPeriod = 10;
    const long shares = 100;
    const long amountPerPeriod = 100;
    
    var creator = Creators[0];
    var beneficiary = Normal[0];
    var beneficiaryAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);
    
    // Create scheme with default 10-period grace
    var schemeId = await CreateSchemeAsync();
    
    // Add beneficiary with EndPeriod = 10
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiaryAddress, Shares = shares },
        EndPeriod = endPeriod
    });
    
    // Distribute profits for periods 1-10
    for (var i = 1; i <= endPeriod; i++)
    {
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = i,
            AmountsMap = { { "ELF", amountPerPeriod } }
        });
    }
    
    // Beneficiary claims periods 1-9 (period 10 not yet claimable as CurrentPeriod = 10)
    // After claiming period 9, LastProfitPeriod becomes 10
    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    
    var detailsBefore = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress
    });
    detailsBefore.Details[0].LastProfitPeriod.ShouldBe(10L); // Next period to claim is 10
    detailsBefore.Details[0].EndPeriod.ShouldBe(endPeriod);
    
    // Advance time by 11 more periods (beyond grace period)
    for (var i = 11; i <= 21; i++)
    {
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = i,
            AmountsMap = { { "ELF", amountPerPeriod } }
        });
    }
    
    // Add new beneficiary, triggering cleanup
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = Accounts[1].Address, Shares = 50 }
    });
    
    // BUG: Original beneficiary's detail should exist (can still claim period 10)
    // but it's been removed by the buggy >= comparison
    var detailsAfter = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress
    });
    detailsAfter.Details.Count.ShouldBe(0); // Detail incorrectly removed!
    
    // Beneficiary permanently lost period 10's profits (100 ELF)
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-158)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-206)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L856-856)
```csharp
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-860)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L113-116)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L6-6)
```csharp
    public const int DefaultProfitReceivingDuePeriodCount = 10;
```
