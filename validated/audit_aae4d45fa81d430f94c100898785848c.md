# Audit Report

## Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Enables Consensus Halt via LIB Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miners report their current block height as `ImpliedIrreversibleBlockHeight`, only checking that values don't decrease. This allows colluding Byzantine miners (>1/3) to prevent Last Irreversible Block (LIB) progression, triggering automatic chain rollbacks and causing complete loss of liveness—violating fundamental Byzantine Fault Tolerance guarantees.

## Finding Description

The consensus protocol expects honest miners to set `ImpliedIrreversibleBlockHeight = Context.CurrentHeight` when producing blocks: [1](#0-0) 

However, the `LibInformationValidationProvider` only validates that values don't decrease, not that they equal the current block height: [2](#0-1) 

The `UpdateValueValidationProvider` performs no validation of `ImpliedIrreversibleBlockHeight` at all, only checking `OutValue` and `Signature`: [3](#0-2) 

Malicious miners can exploit this by modifying their node software to report stale `ImpliedIrreversibleBlockHeight` values in their `UpdateValue` transactions. The value is stored directly from input without additional validation: [4](#0-3) 

The LIB calculation sorts implied heights from all miners and selects the value at position `(count-1)/3`: [5](#0-4) [6](#0-5) 

If more than 1/3 of miners report stale values, the element at the 1/3 position remains low, preventing LIB progression. The system detects this condition after `max(8, MaximumTinyBlocksCount)` rounds and enters "Severe" status: [7](#0-6) 

This fires the `IrreversibleBlockHeightUnacceptable` event: [8](#0-7) 

The event processor triggers an automatic rollback to the stale LIB height: [9](#0-8) 

After rollback, malicious miners continue their behavior, creating an infinite rollback loop that prevents any forward progress.

The existing evil miner detection mechanism only penalizes missed time slots, not incorrect LIB reporting: [10](#0-9) [11](#0-10) 

Malicious miners producing blocks normally are never flagged as evil, despite reporting incorrect consensus data.

## Impact Explanation

This vulnerability causes **complete loss of blockchain liveness**:

1. **Blockchain Halt**: The infinite rollback loop prevents the chain from making forward progress. After each rollback to the stale LIB height, the malicious miners continue reporting stale values, retriggering the rollback mechanism.

2. **Transaction Loss**: All transactions included in blocks after the stale LIB are orphaned during each rollback, making it impossible to finalize any new transactions.

3. **Service Unavailability**: Users cannot execute transactions, smart contracts become unusable, dApps stop functioning, and the entire blockchain ecosystem becomes non-functional.

4. **BFT Property Violation**: The system uses 2/3 consensus thresholds, indicating BFT design: [12](#0-11) 

However, it fails to maintain liveness under 1/3 Byzantine miners—violating the fundamental guarantee that BFT systems must provide. This is an **invariant enforcement failure**: the protocol assumes miners will honestly report `ImpliedIrreversibleBlockHeight = Context.CurrentHeight` but does not enforce this critical invariant through validation.

## Likelihood Explanation

**Attack Requirements:**
- Control of >1/3 elected miners (approximately 7 out of 21 typical miners)
- Ability to modify node software to report stale values
- No need to compromise cryptographic keys or break protocol rules

**Attack Complexity:**
- Medium-low: Requires coordination among multiple miners and software modifications
- Technically straightforward: Miners simply provide stale but monotonically non-decreasing values
- No detection mechanism specifically identifies this behavior

**Economic Considerations:**
- Miners risk reputation and potential governance intervention
- However, no immediate automated penalty exists for incorrect LIB reporting
- Evil miner detection only targets missed blocks, not consensus data integrity

**Probability Assessment:**
Medium-low in practice due to collusion requirements, but **HIGH from a protocol design perspective** because BFT consensus systems must tolerate up to f < n/3 Byzantine nodes without losing liveness. This vulnerability demonstrates the protocol fails to meet its own BFT security guarantees.

## Recommendation

Add validation in `LibInformationValidationProvider` or `UpdateValueValidationProvider` to enforce that `ImpliedIrreversibleBlockHeight` equals or is very close to `Context.CurrentHeight`:

```csharp
// In LibInformationValidationProvider or as a new validator
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    // Allow small lag (e.g., 1-2 blocks) for network delays, but reject stale values
    var maxAcceptableLag = 2;
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue &&
        providedHeight > 0 &&
        Context.CurrentHeight - providedHeight > maxAcceptableLag)
    {
        validationResult.Message = "ImpliedIrreversibleBlockHeight is too far behind current height.";
        return validationResult;
    }
}
```

Alternatively, add explicit evil miner detection for incorrect LIB reporting:

```csharp
// In Round.TryToDetectEvilMiners or similar
var currentHeight = Context.CurrentHeight;
var staleLIBMiners = RealTimeMinersInformation.Values
    .Where(m => m.ImpliedIrreversibleBlockHeight > 0 && 
                currentHeight - m.ImpliedIrreversibleBlockHeight > AcceptableLagThreshold)
    .Select(m => m.Pubkey).ToList();
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task LIB_Manipulation_Via_Stale_ImpliedIrreversibleBlockHeight()
{
    // Setup: Initialize consensus with 7 miners (>1/3 of 21 typical miners will be malicious)
    var miners = await InitializeConsensusWithMiners(21);
    var maliciousMinerCount = 8; // >1/3
    
    // Step 1: Advance chain to block 1000
    await ProduceNormalBlocksToHeight(1000);
    
    // Step 2: Malicious miners freeze their ImpliedIrreversibleBlockHeight at 1000
    var frozenHeight = 1000L;
    for (int i = 0; i < maliciousMinerCount; i++)
    {
        miners[i].SetImpliedIrreversibleBlockHeight(frozenHeight);
    }
    
    // Step 3: Continue producing blocks - LIB should get stuck
    await ProduceNormalBlocksToHeight(1100);
    
    // Verify: LIB is stuck at frozen height because (count-1)/3 position has stale value
    var currentRound = await GetCurrentRound();
    var libCalculator = new LastIrreversibleBlockHeightCalculator(currentRound, previousRound);
    libCalculator.Deconstruct(out var libHeight);
    
    // LIB should be stuck at or near frozen height (1000), not progressing to 1100
    Assert.True(libHeight <= frozenHeight + 10, 
        $"LIB should be stuck near {frozenHeight}, but is {libHeight}");
    
    // Step 4: After max(8, MaximumTinyBlocksCount) rounds, Severe status triggers
    await ProduceBlocksUntilSevereStatus();
    
    // Verify: IrreversibleBlockHeightUnacceptable event was fired
    var events = await GetFiredEvents();
    Assert.Contains(events, e => e is IrreversibleBlockHeightUnacceptable);
    
    // Verify: Chain rollback was triggered
    var chainAfterRollback = await GetChainHeight();
    Assert.True(chainAfterRollback <= libHeight, 
        "Chain should have rolled back to LIB");
    
    // Step 5: Malicious miners continue behavior after rollback
    // This creates infinite loop - chain cannot progress
    Assert.True(true, "Attack successful: LIB manipulation prevents consensus");
}
```

**Notes:**
- While governance intervention through the emergency response organization could theoretically remove malicious miners, this requires manual intervention and does not constitute an automated protocol defense
- The vulnerability exists at the smart contract validation layer, making it a protocol-level design flaw rather than an implementation bug
- The attack exploits the gap between an assumed invariant (miners report current height) and actual enforcement (only non-decreasing check)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-50)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockHeightUnacceptableLogEventProcessor.cs (L49-65)
```csharp
    protected override async Task ProcessLogEventAsync(Block block, LogEvent logEvent)
    {
        var distanceToLib = new IrreversibleBlockHeightUnacceptable();
        distanceToLib.MergeFrom(logEvent);

        if (distanceToLib.DistanceToIrreversibleBlockHeight > 0)
        {
            Logger.LogDebug($"Distance to lib height: {distanceToLib.DistanceToIrreversibleBlockHeight}");
            Logger.LogDebug("Will rollback to lib height.");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var chain = await _blockchainService.GetChainAsync();
                    await _blockchainService.ResetChainToLibAsync(chain);
                }, KernelConstants.UpdateChainQueueName);
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
