# Audit Report

## Title
Maximum Blocks Count Can Return Zero Leading to Severe Throughput Degradation in Abnormal Status

## Summary
The `GetMaximumBlocksCount()` function in the AEDPoS consensus contract returns 0 when the blockchain is in Abnormal status and no miners appear in both of the last two rounds. This prevents miners from producing tiny blocks, reducing maximum throughput by 87.5% (from 8 blocks to 1 block per time slot) during periods when the network is already under stress.

## Finding Description

When the blockchain enters **Abnormal mining status** (LIB is 2-7 rounds behind current round), the `GetMaximumBlocksCount()` function calculates a dynamic maximum based on miners who successfully mined in the previous two rounds. [1](#0-0) 

The calculation retrieves mined miner lists from the previous two rounds and finds their intersection: [2](#0-1) 

When `minersOfLastTwoRounds` equals 0 (no common miners between rounds N-1 and N-2), the calculated `factor` becomes 0. The `Ceiling` function returns 0 for a zero numerator, [3](#0-2)  leading to `Math.Min(MaximumTinyBlocksCount, 0)` returning 0. [4](#0-3) 

This zero value is used in consensus behavior determination. In `ConsensusBehaviourProviderBase`, the condition to allow TinyBlock production checks if `ActualMiningTimes.Count < _maximumBlocksCount`. [5](#0-4)  When `_maximumBlocksCount` is 0, this condition is always false (since Count â‰¥ 0), preventing TinyBlock behavior. The same check appears at another location. [6](#0-5) 

This behavior is **inconsistent** with Severe status handling, which explicitly returns 1 as a minimum to maintain basic block production. [7](#0-6) 

The vulnerability is triggered when `GetMinedMiners()` returns empty lists for one or both of the previous two rounds. This occurs when no miners have `SupposedOrderOfNextRound != 0` in a round. [8](#0-7)  These lists are recorded during round transitions. [9](#0-8) 

## Impact Explanation

**Severe Throughput Degradation:**
Under normal conditions, `MaximumTinyBlocksCount` is configured as 8, [10](#0-9)  allowing miners to produce up to 8 tiny blocks per time slot. When this bug returns 0, miners can only produce 1 UPDATE_VALUE block per time slot, [11](#0-10)  representing an **87.5% reduction** in maximum throughput.

**Operational Denial-of-Service:**
- Transaction backlog accumulates as the network cannot process its normal transaction load
- Users experience severe delays or complete inability to submit transactions
- Critical governance proposals and time-sensitive operations may fail
- The network becomes effectively unusable for its intended purpose despite consensus mechanisms continuing to operate

**Compounding Effect:**
This bug manifests precisely when the blockchain is **already under stress** (Abnormal status indicates LIB is falling behind), exacerbating the degradation when higher throughput is most needed for recovery.

## Likelihood Explanation

**Entry Point:**
The function is invoked during standard consensus command generation for TinyBlock production. [12](#0-11) 

**Preconditions:**
1. Blockchain must enter Abnormal status (LIB is 2-7 rounds behind current round) - this occurs naturally during network partitioning, high latency, or miner failures
2. No miners from round N-1 also mined in round N-2, resulting in zero intersection

**Feasibility:**
These conditions are **highly feasible** during network stress scenarios:
- Abnormal status is a designed state for handling degraded network conditions
- When miners fail to produce blocks (due to network issues, downtime, or synchronization problems), their `SupposedOrderOfNextRound` remains 0
- Empty or non-overlapping mined miner lists occur naturally when different subsets of miners successfully produce blocks across consecutive rounds
- The scenario requires no attacker - it happens through natural network dynamics

The deterministic code path makes this reproducible whenever the preconditions are met.

## Recommendation

Modify the Abnormal status handling in `GetMaximumBlocksCount()` to enforce a minimum return value of 1, consistent with Severe status handling:

```csharp
if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
{
    var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
    var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
    var minersOfLastTwoRounds = previousRoundMinedMinerList
        .Intersect(previousPreviousRoundMinedMinerList).Count();
    var factor = minersOfLastTwoRounds.Mul(
        blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
            (int)currentRoundNumber.Sub(libRoundNumber)));
    var count = Math.Max(1, Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
        Ceiling(factor, currentRound.RealTimeMinersInformation.Count)));
    Context.LogDebug(() => $"Maximum blocks count tune to {count}");
    return count;
}
```

This ensures that even when no miners overlap between the last two rounds, the network can still produce at least 1 tiny block per time slot, maintaining basic throughput during recovery.

## Proof of Concept

The vulnerability can be demonstrated by creating a test scenario where:
1. Set up a blockchain with multiple miners
2. Advance to Abnormal status (LIB 2-7 rounds behind)
3. Have different miners mine in rounds N-1 and N-2 with no overlap
4. Verify that `GetMaximumBlocksCount()` returns 0
5. Confirm that miners cannot produce TinyBlock behavior

The bug is triggered through the deterministic code path when `MinedMinerListMap` entries for consecutive rounds have zero intersection, which naturally occurs during network stress when different subsets of miners succeed in producing blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L44-47)
```csharp
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L48-54)
```csharp
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L81-85)
```csharp
    private static int Ceiling(int num1, int num2)
    {
        var flag = num1 % num2;
        return flag == 0 ? num1.Div(num2) : num1.Div(num2).Add(1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L123-125)
```csharp
            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-230)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L39-46)
```csharp
        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```
