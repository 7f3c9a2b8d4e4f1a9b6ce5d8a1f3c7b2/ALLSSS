# Audit Report

## Title
Consensus Permanent DoS via Unconstrained LIB Injection in NextTerm/NextRound Transactions

## Summary
The AEDPoS consensus contract lacks Last Irreversible Block (LIB) validation for `NextTerm` and `NextRound` transaction behaviors. A malicious miner can inject arbitrarily high `ConfirmedIrreversibleBlockHeight` values during term/round transitions, permanently corrupting consensus state and halting all block production until a hard fork is deployed.

## Finding Description

The validation logic applies different validation providers based on consensus behavior. For `UpdateValue` behavior, `LibInformationValidationProvider` is correctly included to ensure LIB values cannot decrease. However, for `NextTerm` and `NextRound` behaviors, this critical validation is omitted. [1](#0-0) 

The `RoundTerminateValidationProvider` applied to `NextTerm` only validates round/term number increments and InValue nullness, but does NOT validate LIB values: [2](#0-1) 

When processing `NextTerm`, the transaction input's LIB values are directly copied to the new round without validation through the `ToRound()` method: [3](#0-2) 

This corrupted round is then persisted to blockchain state: [4](#0-3) [5](#0-4) 

The same vulnerability exists in `NextRound` transactions with identical ToRound() logic: [6](#0-5) 

Once the LIB is corrupted with a very high value, all subsequent `UpdateValue` transactions fail validation because `LibInformationValidationProvider` rejects backward LIB movement: [7](#0-6) 

This creates a permanent consensus deadlock. When a miner's `OutValue` is `null` (first block in time slot), the consensus system returns `UpdateValue` behavior: [8](#0-7) 

Without `UpdateValue` succeeding, `OutValue` remains `null`, and `TinyBlock` production requires `OutValue != null`: [9](#0-8) 

Critically, the round hash validation does not include LIB fields, meaning modified LIB values bypass hash-based integrity checks: [10](#0-9) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability enables a complete denial-of-service attack on the entire blockchain with permanent consequences:

- **Blockchain Halt:** All block production ceases immediately once miners attempt to produce blocks after the corrupted term/round transition
- **Transaction Impossibility:** No transactions can be included in blocks, effectively freezing all on-chain activity
- **Hard Fork Required:** The only recovery mechanism is deploying a hard fork with corrected state, requiring coordinated emergency response
- **Economic Damage:** All trading, DeFi operations, and smart contract executions are halted indefinitely
- **No Automated Recovery:** Unlike temporary network issues, this corruption is permanent in the blockchain state

The attack breaks the fundamental consensus invariant that Last Irreversible Block height must monotonically increase. Once violated through state corruption rather than legitimate consensus, the system cannot self-recover.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible with minimal barriers:

**Attacker Prerequisites:**
- Must be an active miner in the current consensus round (miners are elected through governance, making this a realistic semi-privileged threat model)

**Attack Complexity: LOW**
1. Wait for legitimate term/round transition period
2. Call `GenerateConsensusTransactions` to obtain valid `NextTermInput`/`NextRoundInput`
3. Modify the `ConfirmedIrreversibleBlockHeight` field to a very high value (e.g., `Int64.MaxValue - 1000`)
4. Sign and submit the modified transaction

**Technical Feasibility:**
- No cryptographic challenges or timing races
- Validation gap is systematic and architectural, not a race condition
- Attack is deterministic and 100% reproducible
- Transaction appears valid until corruption manifests in subsequent rounds
- Economic cost is minimal (only standard transaction gas fees)

## Recommendation

Add `LibInformationValidationProvider` to the validation providers list for both `NextRound` and `NextTerm` behaviors in `ValidateBeforeExecution`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

Additionally, consider adding an upper bound check on `ConfirmedIrreversibleBlockHeight` to ensure it cannot exceed the current blockchain height by an unreasonable margin.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_CanInjectArbitrarilyHighLIB_CausesConsensusHalt()
{
    // Setup: Initialize consensus with valid round
    await InitializeConsensusAsync();
    var initialRound = await GetCurrentRoundAsync();
    var legitimateLIB = initialRound.ConfirmedIrreversibleBlockHeight;
    
    // Attack: Miner creates NextTermInput with corrupted LIB
    var nextTermInput = await GenerateValidNextTermInputAsync();
    nextTermInput.ConfirmedIrreversibleBlockHeight = long.MaxValue - 1000; // Inject corrupted LIB
    
    // Execute malicious NextTerm transaction
    var result = await MinerExecuteAsync(AEDPoSContractStub.NextTerm, nextTermInput);
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Transaction succeeds
    
    // Verify corruption persisted
    var corruptedRound = await GetCurrentRoundAsync();
    corruptedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(long.MaxValue - 1000);
    
    // Impact: All subsequent UpdateValue transactions fail
    var updateValueInput = await GenerateValidUpdateValueInputAsync();
    updateValueInput.Round.ConfirmedIrreversibleBlockHeight = legitimateLIB + 100; // Real LIB
    
    var updateResult = await MinerExecuteAsync(AEDPoSContractStub.UpdateValue, updateValueInput);
    updateResult.Status.ShouldBe(TransactionResultStatus.Failed); // Validation fails
    updateResult.Error.ShouldContain("Incorrect lib information"); // LIB validation rejects backward movement
    
    // Consensus is permanently halted - no blocks can be produced
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-114)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }

        /// <summary>
        ///     If this miner come to a new round, normally, there are three possible behaviour:
        ///     UPDATE_VALUE (most common)
        ///     TINY_BLOCK (happens if this miner is mining blocks for extra block time slot of previous round)
        ///     NEXT_ROUND (only happens in first round)
        /// </summary>
        /// <returns></returns>
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```
