# Audit Report

## Title
Missing Uniqueness Validation for FinalOrderOfNextRound in UpdateValue Operations

## Summary
The AEDPoS consensus contract lacks on-chain validation to ensure uniqueness of `FinalOrderOfNextRound` values during `UpdateValue` operations. While off-chain conflict detection exists, the on-chain execution path directly assigns mining orders without re-validating uniqueness, creating a vulnerability where duplicate orders could corrupt consensus round generation under distributed system timing conditions.

## Finding Description

The vulnerability stems from a defense-in-depth failure in the consensus order assignment mechanism:

**Off-chain Conflict Detection:**
During block generation, `GetConsensusExtraDataToPublishOutValue()` calls `ApplyNormalConsensusData()` which performs conflict detection on a local copy of the round state. [1](#0-0)  The method checks for existing miners with the same `FinalOrderOfNextRound` and reassigns conflicting miners to available slots. [2](#0-1) 

**On-chain Execution Without Validation:**
When `ProcessUpdateValue()` executes on-chain, it directly assigns `FinalOrderOfNextRound` from the input without re-validating uniqueness: [3](#0-2)  It then applies tuning information if provided, but if off-chain conflict detection missed a conflict (due to stale state reads), no correction occurs. [4](#0-3) 

**Insufficient Validation:**
The `UpdateValueValidationProvider` only validates OutValue, Signature, and PreviousInValue correctness - it performs no uniqueness checks on mining orders. [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` contains a bug where it calls `.Distinct()` on `MinerInRound` objects rather than on the order values themselves, making it ineffective at detecting duplicate orders. [6](#0-5)  Additionally, this validator is only registered for `NextRound` behavior, not for `UpdateValue` operations. [7](#0-6) 

**Tuning Information Mechanism:**
The `TuneOrderInformation` is extracted from miners whose `FinalOrderOfNextRound` differs from `SupposedOrderOfNextRound` in the off-chain computed round. [8](#0-7)  If two miners independently calculate the same order based on the same initial state, neither will detect a conflict, resulting in empty tuning information for both.

## Impact Explanation

Duplicate `FinalOrderOfNextRound` values directly corrupt the next round generation logic. The `GenerateNextRoundInformation()` method orders miners by `FinalOrderOfNextRound` and assigns these values directly as the `Order` field for the next round. [9](#0-8) 

With duplicate orders:
- Multiple miners are assigned to the same mining slot
- The `occupiedOrders` collection calculation becomes incorrect [10](#0-9) 
- Available slot assignment for non-mining miners fails
- Round scheduling integrity is violated
- Consensus round transitions become undefined

This breaks the fundamental AEDPoS invariant that each miner must have a unique sequential mining order. The order calculation uses `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, [11](#0-10)  which creates natural collision probability as miners' signatures are independently computed.

## Likelihood Explanation

While the vulnerability requires specific timing conditions, it represents a defense-in-depth failure for a consensus-critical invariant:

**Timing Window Exists:**
In distributed blockchain systems, consensus transaction generation occurs off-chain based on each node's current state view. [12](#0-11)  If network latency or block propagation delays cause miners to generate their consensus transactions from the same base state, both could calculate identical orders without detecting conflicts in their local copies.

**Probabilistic Collisions:**
The modulo operation creates inherent collision probability - with N miners, any two miners have approximately 1/N chance of calculating the same order. [13](#0-12)  Over many rounds, collisions become statistically probable.

**No Safety Net:**
Even if rare, the complete absence of on-chain validation means there is no safety mechanism to catch and prevent duplicate orders from corrupting consensus state. For consensus-critical invariants, validation should exist at multiple layers regardless of expected trigger probability.

## Recommendation

Implement on-chain uniqueness validation for `FinalOrderOfNextRound` values in `ProcessUpdateValue()`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // Validate uniqueness before assignment
    var proposedOrder = updateValueInput.SupposedOrderOfNextRound;
    var existingMinerWithSameOrder = currentRound.RealTimeMinersInformation.Values
        .FirstOrDefault(m => m.Pubkey != _processingBlockMinerPubkey && 
                            m.FinalOrderOfNextRound == proposedOrder);
    
    Assert(existingMinerWithSameOrder == null, 
        $"Mining order {proposedOrder} already assigned to {existingMinerWithSameOrder?.Pubkey}");
    
    minerInRound.FinalOrderOfNextRound = proposedOrder;
    // ... rest of method
}
```

Additionally, fix the `NextRoundMiningOrderValidationProvider` to check for duplicate order values:

```csharp
var distinctOrderCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select the order values
    .Distinct()
    .Count();
```

And register the order validation for UpdateValue behavior in the validation pipeline.

## Proof of Concept

A test demonstrating the vulnerability would require:
1. Setting up a round with multiple miners
2. Having two miners independently call UpdateValue with the same SupposedOrderOfNextRound
3. Verifying both orders are accepted without validation failure
4. Showing the corrupted state when GenerateNextRoundInformation() is called

The core issue is that duplicate FinalOrderOfNextRound assignments are not prevented by the current validation logic during UpdateValue operations, creating a risk to consensus integrity if timing conditions allow duplicate orders to be submitted.

## Notes

While the likelihood of this occurring in a well-functioning network with proper time slot spacing may be low, the absence of validation for a consensus-critical invariant represents a security design flaw. Defense-in-depth principles dictate that critical invariants should be validated at all execution layers, not solely rely on off-chain conflict detection that operates on potentially stale state. Even rare consensus failures can have severe consequences for blockchain integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L247-247)
```csharp
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-92)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L61-74)
```csharp
    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```
