# Audit Report

## Title
Unvalidated Cross-Miner Secret Sharing Pollution in AEDPoS Consensus

## Summary
A malicious miner can inject arbitrary `DecryptedPieces` and `MinersPreviousInValues` for all other miners through the `UpdateValue` transaction without cryptographic or authorization validation. This corrupts the secret sharing reconstruction process used for consensus randomness and mining order determination, enabling consensus manipulation across the entire round.

## Finding Description

The AEDPoS consensus contract accepts `UpdateValueInput` containing `DecryptedPieces` and `MinersPreviousInValues` fields that are intended to share secret information across miners. However, the contract blindly trusts this attacker-controlled input without any validation.

**Vulnerable Code Path:**

The `UpdateValue` method accepts arbitrary input from any miner [1](#0-0) . After basic permission checks [2](#0-1) , the input is processed by `PerformSecretSharing` which directly writes attacker-controlled data to all other miners' state [3](#0-2) .

**Validation Gap:**

The `UpdateValueValidationProvider` only validates the attacker's own `OutValue`, `Signature`, and `PreviousInValue` fields [4](#0-3) . It performs no validation of the `DecryptedPieces` or `MinersPreviousInValues` dictionaries that affect other miners' state. The validation configuration confirms this limitation [5](#0-4) .

**Consensus Impact:**

The corrupted `DecryptedPieces` are later used by `RevealSharedInValues` to reconstruct other miners' secret `InValues` using Shamir's Secret Sharing [6](#0-5) . These reconstructed values become `PreviousInValue` fields, which are then used to calculate signatures [7](#0-6) . The signatures directly determine mining order for subsequent rounds [8](#0-7) .

## Impact Explanation

**CRITICAL** - This vulnerability breaks core consensus security guarantees:

1. **Mining Order Manipulation**: By injecting fake decrypted pieces, the attacker influences signature calculations that determine which miners produce blocks in what order during the next round, potentially creating favorable schedules.

2. **Randomness Corruption**: The secret sharing mechanism is designed to generate unpredictable consensus randomness. Poisoned pieces allow the attacker to bias or predict these random values.

3. **Consensus DoS**: Invalid decrypted pieces cause secret sharing reconstruction to produce incorrect results, potentially breaking consensus flow when honest miners cannot validate blocks.

4. **Complete Round Pollution**: A single transaction from one malicious miner corrupts the consensus state for ALL miners in the round, persisting until term change.

The attack affects the fundamental "miner schedule integrity" and "correct round transitions" invariants required for secure consensus operation.

## Likelihood Explanation

**HIGH** - The attack is highly feasible:

**Attacker Requirements:**
- Must be an authorized miner (realistic in a DPoS system where miners can become malicious)
- Must control a mining node to submit `UpdateValue` transactions
- Secret sharing must be enabled [9](#0-8) 

**Attack Simplicity:**
- LOW complexity - only requires crafting arbitrary byte arrays in `UpdateValueInput`
- No timing requirements or race conditions
- Deterministic execution guaranteed
- No additional economic cost beyond normal block production

**Detection Difficulty:**
- The poisoned data appears valid at transaction time
- Corruption only manifests during secret sharing reconstruction
- No immediate validation failure alerts honest miners

## Recommendation

Add cryptographic validation for cross-miner secret sharing data:

1. **Verify Decrypted Pieces**: Each `DecryptedPieces` entry should be validated against the corresponding `EncryptedPieces` using the decryption key verification. The contract should verify that the attacker possesses the private key that can decrypt the pieces they claim to have decrypted.

2. **Validate Authority**: Check that the submitting miner has the cryptographic authority to provide decrypted pieces for specific target miners (i.e., they should have received and be able to decrypt pieces that were encrypted for them).

3. **Add Reconstruction Verification**: During `RevealSharedInValues`, add checks that reconstructed `InValues` match expected cryptographic properties or hash to known `OutValues` from previous rounds.

4. **Implement Threshold Validation**: Rather than accepting a single miner's claims about all other miners' pieces, require threshold agreement from multiple miners about shared secrets.

Example validation structure:
```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round, string publicKey)
{
    // Validate each decrypted piece before accepting
    foreach (var decryptedPiece in input.DecryptedPieces)
    {
        if (!ValidateDecryptedPiece(decryptedPiece, publicKey, round))
            continue; // Skip invalid pieces
        
        round.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces
            .Add(publicKey, decryptedPiece.Value);
    }
    
    // Only allow updating PreviousInValue if cryptographically valid
    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        if (!ValidatePreviousInValueAuthority(previousInValue, publicKey, round))
            continue; // Skip unauthorized updates
            
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
}
```

## Proof of Concept

A proof of concept would require:

1. Setting up an AEDPoS test environment with multiple miners and secret sharing enabled
2. Creating a malicious miner that calls `UpdateValue` with crafted `DecryptedPieces` containing arbitrary bytes for all other miners
3. Observing that the transaction succeeds and the fake pieces are stored in other miners' state
4. Triggering `RevealSharedInValues` during a round transition
5. Verifying that the reconstructed `InValues` are incorrect, leading to manipulated mining order

The core vulnerability is confirmed by code analysis showing no cryptographic validation exists in the processing path from `UpdateValue` input to state storage in `PerformSecretSharing`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-44)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
