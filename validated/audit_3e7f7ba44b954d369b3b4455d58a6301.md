# Audit Report

## Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
When a manager calls `CreateScheme` multiple times, the new scheme overwrites the previous one in TokenHolderContract storage. Existing users who locked tokens under the original scheme cannot withdraw because the `Withdraw` function queries locked amounts using the new scheme's symbol, which returns zero balance for tokens locked under the different original symbol, leaving funds permanently inaccessible.

## Finding Description

The TokenHolderContract allows managers to create profit-sharing schemes where users lock tokens to receive profit distributions. The vulnerability occurs due to three interacting design flaws:

**Root Cause 1: Unrestricted Scheme Overwriting**

The `CreateScheme` method directly overwrites the scheme stored at `State.TokenHolderProfitSchemes[Context.Sender]` without any validation to prevent duplicate calls or check for existing user registrations. [1](#0-0) 

Each call to `CreateScheme` creates a new profit scheme in the Profit contract with a unique schemeId, but overwrites the TokenHolderProfitScheme metadata including the critical `Symbol` field. [2](#0-1) 

**Root Cause 2: Deterministic Lock ID Generation**

Lock IDs are generated deterministically based only on the manager address and user address, making them identical across different schemes with the same manager. [3](#0-2) 

When users register, tokens are locked with the current scheme's symbol, and the lock ID mapping persists in `State.LockIds[manager][user]`. [4](#0-3) 

**Root Cause 3: Symbol Mismatch in Withdrawal**

The `Withdraw` function retrieves the CURRENT scheme (which may have a different symbol than when the user registered), then queries the locked amount using this current scheme's symbol with the old lock ID. [5](#0-4) 

The critical flaw is in how `GetLockedAmount` works: it computes the virtual address from the lock ID and then queries the balance of a SPECIFIC symbol at that virtual address. [6](#0-5) 

Since the virtual address calculation doesn't include the symbol (it's only based on sender, user address, and lock ID), but the balance query IS symbol-specific, tokens locked under one symbol become invisible when queried with a different symbol. [7](#0-6) [8](#0-7) 

**Attack Scenario:**
1. Manager creates scheme with Symbol="ELF", MinimumLockMinutes=1000
2. User registers and locks 10,000 ELF tokens at virtual address V
3. Manager calls `CreateScheme` again with Symbol="USDT", MinimumLockMinutes=10
4. User calls `Withdraw`:
   - Retrieves current scheme (Symbol="USDT")
   - Queries `GetLockedAmount(lockId, "USDT")` â†’ returns 0 (virtual address V has ELF, not USDT)
   - Unlocks 0 USDT tokens
   - Removes lock ID mapping permanently [9](#0-8) 
   - Original 10,000 ELF remains locked at virtual address V permanently

## Impact Explanation

**HIGH Severity** - Direct and permanent loss of user funds with no standard recovery mechanism:

1. **Permanent Fund Lock**: Users completely lose access to their locked tokens. The withdrawal function returns zero balance and removes the lock ID mapping, eliminating the normal path to retrieve funds.

2. **Multi-User Impact**: When a manager overwrites a scheme, ALL users who registered under the original scheme are simultaneously affected. For a popular staking scheme, this could impact hundreds of users.

3. **No Administrative Recovery**: There is no function in the contract to recover these locked funds. The tokens remain at the virtual address indefinitely with no authority able to unlock them.

4. **Undetectable by Users**: Users have no way to detect this vulnerability before locking funds. The withdrawal only fails after the manager has already overwritten the scheme.

## Likelihood Explanation

**HIGH Likelihood** - Simple to trigger, both accidentally and maliciously:

1. **Public Entry Point**: The `CreateScheme` method is publicly accessible to any address with no access control preventing multiple calls. [10](#0-9) 

2. **Low Complexity**: The attack requires only two standard contract calls by the manager with no complex state manipulation or timing requirements.

3. **Accidental Trigger**: A manager might innocently call `CreateScheme` a second time to update scheme parameters (e.g., changing minimum lock duration or auto-distribute thresholds), not realizing it creates a new scheme and breaks existing user locks.

4. **Malicious Scenario**: A malicious manager could deliberately lock user funds to prevent withdrawals, gaining time advantage in profit distributions or causing financial harm.

5. **No Warning**: The contract provides no warnings or checks to prevent this scenario, making it easy to trigger unintentionally.

## Recommendation

Add a check in `CreateScheme` to prevent overwriting an existing scheme that has registered users:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation to prevent scheme overwriting
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(existingScheme == null, "Scheme already exists for this manager. Cannot overwrite existing scheme.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, include the symbol in the lock ID generation to make locks symbol-specific, or add a separate update method that validates no breaking changes to the symbol field.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwrite_CausesPermanentTokenLock()
{
    // Setup: Manager creates initial scheme with ELF
    var manager = Accounts[0].Address;
    var user = Accounts[1].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1000
    });
    
    // User locks 10000 ELF tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 10000
    });
    
    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        LockId = lockId,
        Symbol = "ELF"
    });
    Assert.Equal(10000, lockedAmount.Amount);
    
    // VULNERABILITY: Manager overwrites scheme with USDT
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 10
    });
    
    // Fast forward time past minimum lock period
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(1001));
    
    // User attempts withdrawal - gets 0 tokens back
    await TokenHolderContractStub.Withdraw.SendAsync(manager);
    
    // Verify: ELF tokens still locked at virtual address but lock ID mapping removed
    var stillLocked = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        LockId = lockId,
        Symbol = "ELF"
    });
    Assert.Equal(10000, stillLocked.Amount); // Tokens still locked
    
    // Lock ID mapping no longer exists - funds permanently inaccessible
    var lockIdMapping = await TokenHolderContractStub.GetScheme.CallAsync(manager);
    Assert.Null(lockIdMapping.LockIds[user]); // Mapping removed
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-166)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-225)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L238-238)
```csharp
        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L118-124)
```csharp
    public override Address GetVirtualAddressForLocking(GetVirtualAddressForLockingInput input)
    {
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        return virtualAddress;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```
