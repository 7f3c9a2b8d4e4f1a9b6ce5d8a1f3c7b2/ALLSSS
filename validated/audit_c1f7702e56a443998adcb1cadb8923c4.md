# Audit Report

## Title
Branch Count DoS in Association Contract via Large Organization Member Lists

## Summary
The Association contract contains a critical vulnerability where organizations with large member lists (5,000-10,000+ members) can be created successfully but become permanently non-functional once proposals receive multiple votes. The O(M×N) nested iteration complexity in threshold validation functions causes branch count limit exceptions, resulting in complete governance DoS.

## Finding Description

The vulnerability stems from inefficient threshold validation logic in the `IsReleaseThresholdReached` helper method and its dependent functions. [1](#0-0) 

Three critical functions perform nested iterations with O(M×N) complexity:

1. **IsProposalRejected** uses `Count()` with a predicate that calls `Contains()` for each rejection: [2](#0-1) 

2. **IsProposalAbstained** performs the same pattern for abstentions: [3](#0-2) 

3. **CheckEnoughVoteAndApprovals** repeats this for approvals: [4](#0-3) 

The `OrganizationMemberList.Contains()` method performs a linear search through the `RepeatedField<Address>`: [5](#0-4) 

where `organization_members` is defined as a protobuf repeated field: [6](#0-5) 

Each iteration consumes branch counts tracked by AElf's ExecutionObserver. The branch count threshold is set to 15,000: [7](#0-6) 

When the branch count is exceeded, the ExecutionObserver throws a `RuntimeBranchThresholdExceededException`: [8](#0-7) 

**Attack Vector:**

The `GetProposal` view function calls `IsReleaseThresholdReached`: [9](#0-8) 

and the `Release` function does the same: [10](#0-9) 

With 10,000 organization members and just 2 votes, the nested iterations consume 20,000 branch counts (2 × 10,000), exceeding the 15,000 limit and causing a `RuntimeBranchThresholdExceededException`.

**Why Existing Protections Fail:**

Organization creation validation only checks for duplicates using `AnyDuplicate()`: [11](#0-10) 

which uses `GroupBy` with O(N) complexity: [12](#0-11) 

The transaction size limit is 5MB: [13](#0-12) 

allowing 10,000+ addresses (~340KB). No maximum member list size validation exists in the code.

## Impact Explanation

**HIGH SEVERITY - Complete Governance DoS**

Once triggered, this vulnerability causes:

1. **Permanent GetProposal Failure**: The view function becomes unusable for checking proposal status, breaking all UI/monitoring tools
2. **Permanent Release Failure**: Proposals cannot be executed even if approved, blocking all governance actions
3. **Organization Paralysis**: The organization becomes completely non-functional with no recovery mechanism

**Quantified Impact:**
- 10,000 members + 2 votes = 20,000 branches (33% over limit)
- 7,500 members + 2 votes = 15,000 branches (at limit)
- 5,000 members + 3 votes = 15,000 branches (at limit)

All members lose governance rights, and any protocols depending on the organization for critical operations (treasury management, parameter updates, contract upgrades) are frozen indefinitely.

## Likelihood Explanation

**HIGH LIKELIHOOD**

**Attacker Requirements:**
- Access to public `CreateOrganization` function (no special permissions required)
- Ability to generate 10,000 addresses (trivial with sequential key generation)
- Minimal transaction fees

**Attack Complexity: LOW**
1. Generate 10,000 addresses
2. Call `CreateOrganization` with large `OrganizationMemberList` (passes validation)
3. Wait for legitimate proposal activity (2-3 votes)
4. All subsequent `GetProposal` and `Release` calls fail permanently

**Feasibility Factors:**
- Transaction size easily accommodates 10,000+ addresses
- No maximum member list validation
- Attack works with organization's own legitimate voting activity
- Hard to detect during creation
- No mitigation path once triggered

The vulnerability can occur maliciously (attacker creates trap organizations) or accidentally (legitimate organizations with large membership).

## Recommendation

Implement a maximum member count validation in the `Validate` method:

```csharp
private const int MaxOrganizationMemberCount = 1000;

private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate() ||
        organization.OrganizationMemberList.Count() > MaxOrganizationMemberCount)
        return false;
    // ... rest of validation
}
```

Alternatively, optimize the threshold checking logic by converting the organization member list to a `HashSet<Address>` for O(1) lookup instead of O(N) linear search, which would reduce the complexity from O(M×N) to O(M).

## Proof of Concept

```csharp
[Fact]
public async Task BranchCountDoS_WithLargeMemberList_ShouldFailGetProposal()
{
    // Generate 10,000 unique member addresses
    var memberAddresses = new List<Address>();
    for (int i = 0; i < 10000; i++)
    {
        memberAddresses.Add(Address.FromPublicKey(CryptoHelper.GenerateKeyPair().PublicKey));
    }
    
    // Create organization with 10,000 members
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList 
        { 
            OrganizationMembers = { memberAddresses } 
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = 10000,
            MaximalRejectionThreshold = 10000
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } }
    };
    
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Create a proposal
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ToAddress = AssociationContractAddress,
        ContractMethodName = nameof(AssociationContractStub.ChangeOrganizationThreshold),
        Params = new ProposalReleaseThreshold().ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    });
    
    // Have 2 members vote (approval)
    await AssociationContractStub.Approve.SendAsync(proposalId.Output);
    var member2Stub = GetAssociationContractStub(memberAddresses[0]);
    await member2Stub.Approve.SendAsync(proposalId.Output);
    
    // Attempt to call GetProposal - should throw RuntimeBranchThresholdExceededException
    // with 10,000 members × 2 votes = 20,000 branch counts (exceeds 15,000 limit)
    var exception = await Assert.ThrowsAsync<RuntimeBranchThresholdExceededException>(
        async () => await AssociationContractStub.GetProposal.CallAsync(proposalId.Output)
    );
    
    exception.Message.ShouldContain("Contract branch threshold 15000 exceeded");
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** protobuf/association_contract.proto (L105-108)
```text
message OrganizationMemberList {
    // The address of organization members.
    repeated aelf.Address organization_members = 1;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L24-27)
```csharp
    public static bool AnyDuplicate(this OrganizationMemberList organizationMemberList)
    {
        return organizationMemberList.OrganizationMembers.GroupBy(m => m).Any(g => g.Count() > 1);
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```
