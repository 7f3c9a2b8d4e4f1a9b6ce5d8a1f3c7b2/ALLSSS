# Audit Report

## Title
Authorization Bypass: Unauthorized Miners Can Gain Extra Block Production Rights Through Premature NextRound Execution

## Summary
The AEDPoS consensus mechanism fails to validate which miner is authorized to terminate the current round. Any miner whose time slot has passed can mine a NextRound block and automatically receive `ExtraBlockProducerOfPreviousRound` status, granting them extended block production privileges in the subsequent round that should only go to the legitimately designated extra block producer.

## Finding Description

The vulnerability stems from three critical flaws in the round termination logic:

**1. Unrestricted NextRound Behavior Assignment**

When any miner's time slot has passed and they haven't met other conditions, `GetConsensusBehaviour()` returns the result of `GetConsensusBehaviourToTerminateCurrentRound()` without checking if the miner is the designated extra block producer. [1](#0-0) 

**2. Unconditional Privilege Assignment**

When processing a NextRound block, the system unconditionally assigns the terminating miner's pubkey to `ExtraBlockProducerOfPreviousRound`: [2](#0-1) 

This value is then preserved through the NextRoundInput conversion: [3](#0-2) 

And processed without validation: [4](#0-3) 

**3. Extended Block Production Rights**

Miners with their pubkey matching `ExtraBlockProducerOfPreviousRound` receive extended privileges to produce additional tiny blocks beyond the normal limit: [5](#0-4) 

They also receive privileges to produce tiny blocks before the round starts: [6](#0-5) 

**Why Existing Validations Fail:**

- **PreCheck**: Only verifies the miner is in the current or previous miner list, not whether they are the designated extra block producer: [7](#0-6) 

- **RoundTerminateValidationProvider**: Only validates round number increment and that InValues are null, without checking authorization: [8](#0-7) 

- **TimeSlotValidationProvider**: For NextRound (new round ID), only validates the NEW round's time slot structure via `CheckRoundTimeSlots()`, not whether the sender is authorized to terminate the round: [9](#0-8) 

- **MiningPermissionValidationProvider**: Only checks if sender is in the miner list: [10](#0-9) 

- **NextRoundMiningOrderValidationProvider**: Only validates that miners who determined next round order match those who mined blocks, but doesn't check sender authorization: [11](#0-10) 

**Attack Execution:**

1. The system deterministically selects one extra block producer per round using `CalculateNextExtraBlockProducerOrder()`: [12](#0-11) 

2. Any miner whose time slot has passed can obtain NextRound behavior and mine a NextRound block by modifying their node

3. The NextRound transaction is publicly accessible: [13](#0-12) 

4. The attacker gains extended mining rights in the next round due to their `ExtraBlockProducerOfPreviousRound` status

## Impact Explanation

**Consensus Fairness Violation:**
This vulnerability breaks the fundamental fairness invariant of AEDPoS where block production opportunities should be deterministically distributed. The attacker gains `(_maximumBlocksCount + blocksBeforeCurrentRound)` block production rights instead of the standard `_maximumBlocksCount`, while the legitimate extra block producer loses their rightful privileges.

**Quantified Damage:**
- With typical configuration (_maximumBlocksCount = 8), the attacker gains up to 8 extra tiny blocks per successful exploit
- Repeated exploitation across rounds accumulates unfair advantage
- Additional block production translates to disproportionate mining rewards and transaction fee revenue
- Enables potential transaction censorship and MEV extraction through extra blocks

**Security Guarantee Broken:**
Violates the consensus invariant requiring correct round transitions and time-slot validation, miner schedule integrity by allowing unauthorized privilege escalation in the mining schedule.

## Likelihood Explanation

**Attacker Prerequisites (Realistic):**
- Must be in the current miner list (standard requirement for consensus participation)
- Requires running modified node software to bypass client-side timing constraints
- Needs reasonable network connectivity to propagate blocks

**Attack Complexity (Moderate):**
1. Modify node to obtain NextRound behavior when time slot passes
2. Monitor for when own time slot passes
3. Immediately mine and broadcast NextRound block
4. Win propagation race against legitimate extra block producer

**Feasibility Factors:**
- Attack window opens when any miner's time slot passes
- No cryptographic or economic barriers prevent execution
- Success depends on network latency and block propagation timing
- Difficult to distinguish from legitimate fallback scenarios (offline extra block producer)

**Assessment: HIGH**
Any miner can attempt this attack with reasonable success probability. The modified node software is straightforward to implement, and the attack can be repeated across rounds. The absence of on-chain authorization validation makes prevention challenging.

## Recommendation

Add validation to verify that only the designated extra block producer can successfully mine NextRound blocks. This should be implemented in the validation pipeline:

1. Create a new validation provider `ExtraBlockProducerValidationProvider` that checks:
   - The sender's pubkey matches the current round's designated extra block producer (identified by `IsExtraBlockProducer` flag)
   - The `ExtraBlockProducerOfPreviousRound` field in NextRoundInput matches the sender's pubkey

2. Add this provider to the validation pipeline for NextRound behavior in `ValidateBeforeExecution()`: [14](#0-13) 

3. Retrieve the designated extra block producer information: [15](#0-14) 

## Proof of Concept

The vulnerability can be demonstrated by showing that:
1. Any miner whose time slot passes receives NextRound behavior without IsExtraBlockProducer validation
2. The NextRound method processes the input without checking sender authorization
3. The validation pipeline has no provider checking if the sender is the designated extra block producer
4. The sender's pubkey is unconditionally assigned to ExtraBlockProducerOfPreviousRound

A test would need to:
- Setup a round with multiple miners where miner A is designated as extra block producer
- Have miner B (whose time slot has passed but is not the extra block producer) call NextRound
- Verify the transaction succeeds and miner B gains ExtraBlockProducerOfPreviousRound status in the next round
- Verify miner B can then produce extended tiny blocks in the next round

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```
