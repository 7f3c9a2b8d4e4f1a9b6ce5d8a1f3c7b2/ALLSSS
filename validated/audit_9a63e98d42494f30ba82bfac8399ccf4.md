# Audit Report

## Title
Secret Sharing Threshold Validation Requires 100% Participation Instead of Configured 2/3 Threshold

## Summary
The AEDPoS consensus contract implements Shamir's t-of-n secret sharing with a 2/3 threshold but incorrectly validates that 100% of miners must participate before attempting secret reconstruction. This defeats the fault-tolerance purpose of threshold cryptography and enables any single miner to prevent all other miners from having their `PreviousInValue` revealed through a zero-cost griefing attack.

## Finding Description

The vulnerability stems from a critical mismatch between the cryptographic threshold configuration and the validation logic used before secret reconstruction.

**Threshold Configuration (2/3):**
The system correctly calculates the threshold as two-thirds of miners: [1](#0-0) 

The calculated `minimumCount` represents the cryptographic threshold required for Shamir's Secret Sharing reconstruction (2/3 of total miners).

**Incorrect Validation (100%):**
However, the validation logic requires 100% of miners to have submitted their decrypted pieces before attempting reconstruction: [2](#0-1) 

This check requires `DecryptedPieces.Count >= minersCount` (100% participation) even though `minimumCount` (2/3) was calculated earlier. The `continue` statement skips secret reconstruction entirely if this condition fails.

**Cryptographic Function Uses Correct Threshold:**
The actual secret reconstruction correctly uses the 2/3 threshold: [3](#0-2) 

This proves the cryptographic scheme only needs `minimumCount` shares, not `minersCount` shares, to successfully reconstruct the secret.

**Attack Execution:**
When miners submit their consensus data via `UpdateValue`, the `PerformSecretSharing` method stores `DecryptedPieces` without any validation: [4](#0-3) 

A malicious miner can simply omit their `DecryptedPieces` for target miners during their `UpdateValue` transaction. When `RevealSharedInValues` later attempts to reconstruct secrets, it will skip any miner whose `DecryptedPieces.Count < minersCount`, even though reconstruction would succeed with `minimumCount` pieces.

**Data Collection Without Validation:**
The `ExtractInformationToUpdateConsensus` function collects decrypted pieces but performs no threshold validation: [5](#0-4) 

**Fallback Mechanism:**
When `PreviousInValue` cannot be revealed through secret sharing, the system explicitly allows it to remain null or empty: [6](#0-5) 

The comment explicitly states "It is permissible for miners not publish their in values." This deterministic fallback is predictable and allows selective revelation manipulation.

**No Punishment Mechanism:**
Evil miner detection only checks `MissedTimeSlots`, not failure to submit `DecryptedPieces`: [7](#0-6) 

The `TryToDetectEvilMiners` method only identifies miners who exceed the tolerable missed time slots count. It does not check whether miners have submitted their required `DecryptedPieces`, making this a completely undetectable and unpunishable attack vector.

**Validation Provider Allows Empty PreviousInValue:**
The UpdateValue validation provider explicitly allows null or empty `PreviousInValue`: [8](#0-7) 

While this allows the system to continue operating, it undermines the commit-reveal randomness scheme's integrity when revelation is blocked by the 100% requirement.

## Impact Explanation

**1. Defeats Threshold Cryptography Design:**
Shamir's Secret Sharing is specifically designed to provide fault tolerance - secrets can be reconstructed with only t-of-n shares. By requiring n-of-n participation, the implementation completely defeats this core cryptographic property. The system paid the computational cost of implementing threshold cryptography but receives none of its benefits.

**2. Zero-Cost Griefing Attack:**
Any single malicious miner can prevent ALL other miners from having their `PreviousInValue` revealed by simply omitting their `DecryptedPiece` submissions during their `UpdateValue` transaction. This is a powerful griefing vector with:
- Zero economic cost to the attacker
- No on-chain evidence of malicious intent
- Affects all other miners simultaneously
- No risk of detection or punishment

**3. Consensus Randomness Manipulation:**
The commit-reveal scheme relies on miners committing to secret values (`InValue`) by publishing `OutValue = Hash(InValue)` and later revealing them. When revelation fails due to the 100% requirement:
- The system falls back to null/empty `PreviousInValue` 
- This weakens the randomness guarantees that secure block producer selection
- Attackers can selectively prevent revelation to manipulate mining order
- The predictable fallback behavior enables strategic exploitation

**4. Breaks Protocol Security Assumptions:**
The AEDPoS consensus depends on unpredictable randomness for:
- Block producer scheduling
- Round transitions
- Mining reward distribution
By allowing a single miner to block randomness revelation, the protocol's security model is fundamentally compromised.

**Severity: HIGH** - Breaks fundamental cryptographic assumptions, enables zero-cost griefing affecting the entire miner set, and undermines consensus randomness security with no detection mechanism.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the consensus set (reachable privilege in a permissioned consensus system)
- No special permissions beyond standard block production rights
- No additional stake or authority requirements

**Attack Complexity:**
- **Trivial execution**: Attacker simply omits `DecryptedPieces` from their `UpdateValue` input
- **Passive attack**: Omission rather than active manipulation
- **No timing constraints**: Can be executed at any time during the round
- **No coordination needed**: Single malicious actor is sufficient

**Feasibility:**
- Attack succeeds with just one malicious miner out of the entire set
- Works even if 99% of miners are honest (requires only n-1 pieces to fail the `>= minersCount` check)
- No economic cost - the attacker's transaction is still valid and processes normally
- No on-chain evidence of malicious behavior

**Detection Impossibility:**
- Indistinguishable from legitimate network issues or temporary unavailability
- No mechanism to prove deliberate withholding versus technical difficulties  
- Evil miner detection explicitly does not check for missing `DecryptedPieces`
- Validation logic allows empty `PreviousInValue` without raising alerts

**Incentive Structure:**
Rational adversarial miners are strongly incentivized to execute this attack to:
- Prevent competitors from proper `PreviousInValue` verification
- Create consensus instability for competitive advantage
- Manipulate randomness generation for favorable mining schedules
- Reduce the security of the overall consensus mechanism

**Probability: HIGH** - Any rational adversarial miner can and would exploit this with zero risk and significant competitive benefits.

## Recommendation

Fix the validation logic to use the configured threshold instead of requiring 100% participation:

```csharp
// In RevealSharedInValues method, line 36 should be:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This simple change aligns the validation with both:
1. The threshold calculation (`minimumCount = minersCount * 2 / 3`)
2. The actual cryptographic reconstruction (`SecretSharingHelper.DecodeSecret(..., minimumCount)`)

Additional recommendations:
1. Consider adding evil miner detection for consistently missing `DecryptedPieces` submissions
2. Add validation to ensure minimum threshold participation before accepting `UpdateValue` transactions
3. Implement warnings or events when secret reconstruction fails due to insufficient participation
4. Consider penalizing miners who repeatedly fail to submit required cryptographic shares

## Proof of Concept

The vulnerability can be demonstrated by examining the flow:

1. **Setup**: Configure a consensus round with N miners and 2/3 threshold
2. **Attack**: A malicious miner produces their block via `UpdateValue` but omits `DecryptedPieces` for target victim(s)
3. **Verification**: 
   - Check that `PerformSecretSharing` stores the incomplete data without validation
   - Observe `RevealSharedInValues` skips reconstruction due to line 36 check
   - Confirm victim's `PreviousInValue` remains null/empty
   - Verify no evil miner detection triggers
4. **Impact**: Victim's committed random value cannot be revealed despite sufficient honest participants (2/3+) having submitted their shares

The attack succeeds because the validation check `DecryptedPieces.Count < minersCount` requires 100% participation, while the cryptographic scheme only needs `minimumCount` (2/3) to successfully reconstruct the secret.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-293)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-46)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```
