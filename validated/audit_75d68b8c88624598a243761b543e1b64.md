# Audit Report

## Title
3-Miner Configuration Creates Zero Fault Tolerance for Last Irreversible Block Advancement

## Summary
The AEDPoS consensus contract's `MinersCountOfConsent` formula requires unanimous participation from all 3 miners when exactly 3 miners are configured, providing zero fault tolerance for Last Irreversible Block (LIB) advancement. When any single miner experiences downtime, LIB height stops advancing indefinitely, halting transaction finality and blocking cross-chain operations.

## Finding Description

The consensus protocol calculates the Byzantine Fault Tolerance threshold using the formula `RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1)`. [1](#0-0) 

With exactly 3 miners, integer division yields: 3 ร 2 รท 3 + 1 = 2 + 1 = 3, requiring all three miners to participate for LIB advancement.

The `LastIrreversibleBlockHeightCalculator` enforces this threshold during LIB calculation. It retrieves miners who produced blocks in the current round, then checks if their count meets `MinersCountOfConsent`. If insufficient miners participated, it sets `libHeight = 0`, preventing blocks from becoming irreversible. [2](#0-1) 

During block production, the system invokes this calculator to determine the new LIB height. If the calculated `libHeight` exceeds the current confirmed height, it fires an `IrreversibleBlockFound` event to advance finality. Otherwise, LIB remains frozen. [3](#0-2) 

The `SetMaximumMinersCount` method permits configuring any positive miner count, including 3, without enforcing a minimum threshold for fault tolerance. [4](#0-3) 

Test suites explicitly validate 3-miner configurations as acceptable scenarios, confirming this is not an edge case but a supported deployment model. [5](#0-4) 

While `SolitaryMinerDetection` prevents a single miner from producing blocks indefinitely when isolated, it only activates when exactly one miner mines alone for multiple consecutive rounds. It does not address the LIB liveness issue when 2 out of 3 miners continue producing blocks but cannot satisfy the unanimous consensus requirement. [6](#0-5) 

## Impact Explanation

**Operational Denial of Service:**

When LIB advancement halts, the blockchain maintains safety properties (no invalid blocks accepted) but loses liveness guarantees:

- **Transaction Finality Blocked**: All transactions remain in an unfinalized state. Users and applications awaiting finality confirmations experience indefinite delays.

- **Cross-Chain Operations Stalled**: Cross-chain protocols verify data using irreversible block heights. The system uses constants like `LibHeightOffsetForCrossChainIndex` to determine when cross-chain indexing can proceed safely. With LIB frozen, cross-chain bridges cannot advance, blocking token transfers and message passing between chains.

- **Network Synchronization Degraded**: Peers use LIB as the authoritative checkpoint for chain state consistency. Without advancing LIB, nodes may diverge in their view of finalized state.

- **Cascading Protocol Impact**: While block production continues through DPoS consensus, dependent protocols requiring finality guarantees experience operational disruptions. High-value operations that mandate irreversible confirmations cannot complete.

**Affected Parties:**
- End users awaiting transaction finality for critical operations
- Cross-chain protocols requiring irreversible block proofs
- Applications with finality-dependent business logic
- Network operators monitoring chain health

**Severity Justification**: Medium severity reflects the availability impact without direct fund loss. The vulnerability affects liveness (transaction finality) rather than safety (fund security), but creates significant operational disruption for production networks.

## Likelihood Explanation

**Preconditions:**
- Blockchain configured with exactly 3 miners via `SetMaximumMinersCount` or genesis configuration
- Normal operational environment where 100% uptime is not guaranteed

**Trigger Scenarios (Common Operational Events):**
- Miner software crash or panic requiring restart
- Scheduled maintenance windows (software updates, hardware servicing)  
- Network partitions isolating one miner from peers
- Resource exhaustion (memory leaks, disk space, CPU saturation)
- Infrastructure provider outages (cloud zone failures, ISP issues)

**Feasibility Analysis:**
- The 3-miner configuration is explicitly supported without warnings or constraints
- Test coverage validates this scenario as acceptable
- Single-node failures represent routine operational events, not sophisticated attacks
- No attacker privileges or capabilities required
- Industry-standard distributed systems experience single-node failures frequently (typical availability: 99.9% means ~8 hours downtime per year per node)

**Detection and Recovery:**
- Immediately observable through `ConfirmedIrreversibleBlockHeight` metric freezing
- Requires bringing the offline miner back online and resuming block production
- No automatic recovery mechanism exists

For production networks deployed with 3 miners, this represents a realistic and recurring operational risk rather than a theoretical vulnerability.

## Recommendation

**Immediate Mitigation:**
Enforce a minimum miner count that provides at least single-node fault tolerance. For Byzantine Fault Tolerance with the formula `Count * 2 / 3 + 1`:
- 4 miners: requires 3 for consensus (tolerates 1 failure)
- 5 miners: requires 4 for consensus (tolerates 1 failure)  
- 7 miners: requires 5 for consensus (tolerates 2 failures)

**Recommended Fix:**
Modify `SetMaximumMinersCount` validation to enforce a minimum threshold of 4 miners:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    // Add minimum threshold validation
    const int MinimumMinersCountForFaultTolerance = 4;
    Assert(input.Value >= MinimumMinersCountForFaultTolerance, 
        $"Minimum miners count must be at least {MinimumMinersCountForFaultTolerance} for fault tolerance.");
    
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");
    
    // ... rest of implementation
}
```

**Additional Considerations:**
- Add documentation warning about fault tolerance implications of different miner counts
- Consider requiring governance approval with explicit acknowledgment for configurations below 7 miners
- Implement monitoring alerts when LIB advancement stalls

## Proof of Concept

The following test demonstrates the vulnerability by configuring 3 miners and verifying that LIB advancement requires unanimous participation:

```csharp
[Fact]
public async Task ThreeMinerConfig_SingleMinerOffline_LIBStopsAdvancing()
{
    // Setup: Configure system with exactly 3 miners
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    var defaultOrganizationAddress = 
        await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Set maximum miners count to 3
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMaximumMinersCount),
        Params = new Int32Value { Value = 3 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });
    
    await BlockMiningService.MineBlockToNextTermAsync();
    
    // Verify MinersCountOfConsent = 3 (unanimous requirement)
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minersCountOfConsent = currentRound.RealTimeMinersInformation.Count * 2 / 3 + 1;
    minersCountOfConsent.ShouldBe(3);
    
    // Record initial LIB height
    var initialLib = currentRound.ConfirmedIrreversibleBlockHeight;
    
    // Simulate: Only 2 out of 3 miners produce blocks (1 offline)
    // Mine blocks with reduced miner set
    await BlockMiningService.MineBlockWithReducedMinersAsync(2);
    
    // Verify: LIB does not advance with only 2 miners
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.ConfirmedIrreversibleBlockHeight.ShouldBe(initialLib); // LIB frozen
    
    // Verify: LIB only advances when all 3 miners participate
    await BlockMiningService.MineBlockWithAllMinersAsync();
    var finalRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    finalRound.ConfirmedIrreversibleBlockHeight.ShouldBeGreaterThan(initialLib); // LIB advances
}
```

This test validates that:
1. Setting 3 miners creates `MinersCountOfConsent = 3` (unanimous requirement)
2. LIB remains frozen when only 2 miners participate
3. LIB only advances when all 3 miners produce blocks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-30)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L26-29)
```csharp
    [Theory]
    [InlineData(7)]
    [InlineData(3)]
    public async Task SetMaximumMinersCountTest(int targetMinersCount)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```
