# Audit Report

## Title
Symbol Alias Normalization Inconsistency in ModifyBalance Causes Token Supply Accounting Errors

## Summary
The `ModifyBalance` function contains a critical asymmetry: it reads balances using normalized symbols (via `GetActualTokenSymbol`) but writes balances using raw input symbols without normalization. When `Issue`, `Burn`, or `Lock` functions are called with token aliases instead of actual symbols, balances are written to incorrect storage keys, breaking the fundamental invariant that total supply must equal the sum of all balances.

## Finding Description

The root cause lies in `ModifyBalance`'s inconsistent symbol handling. The function reads the current balance by calling `GetBalance`, which internally normalizes the symbol parameter [1](#0-0) 

The `GetBalance` function calls `GetActualTokenSymbol` to resolve aliases to their actual token symbols [2](#0-1) 

However, `ModifyBalance` then writes the updated balance directly to `State.Balances[address][symbol]` using the raw symbol parameter without any normalization [3](#0-2) 

Token aliases are created via `SetSymbolAlias`, which maps an alias to an actual NFT item symbol [4](#0-3) 

**Vulnerable Entry Points:**

1. **Issue function** - Passes raw `input.Symbol` directly to `ModifyBalance` without normalization [5](#0-4) 

2. **Burn function** - Passes raw `symbol` parameter directly to `ModifyBalance` without normalization [6](#0-5) 

3. **Lock function** - Passes raw `input.Symbol` to `DoTransfer`, which calls `ModifyBalance` without normalization [7](#0-6) 

**Why Existing Protections Fail:**

While `Transfer` and `TransferFrom` properly normalize symbols by calling `AssertValidToken` and using the returned `tokenInfo.Symbol` [8](#0-7)  and [9](#0-8) , the vulnerable functions (`Issue`, `Burn`, `Lock`) either don't call `AssertValidToken` or ignore its returned normalized symbol, passing the raw input symbol to `ModifyBalance`.

The `GetTokenInfo` helper function used by `AssertValidToken` does resolve aliases [10](#0-9) , but the vulnerable entry points fail to use this resolved symbol.

## Impact Explanation

**Critical Supply Accounting Violation:**

The most severe impact occurs with `Burn`:
1. User has 100 tokens of "TOKEN-1" stored at `State.Balances[user]["TOKEN-1"]`
2. Alias "ALIAS-1" maps to "TOKEN-1" via `State.SymbolAliasMap`
3. User calls `Burn(symbol: "ALIAS-1", amount: 100)`
4. `ModifyBalance` reads balance from `State.Balances[user]["TOKEN-1"]` (100 tokens) via normalized path
5. `ModifyBalance` writes 0 to `State.Balances[user]["ALIAS-1"]` (wrong storage key!)
6. Token supply is reduced by 100
7. User retains 100 tokens at `State.Balances[user]["TOKEN-1"]` (unchanged)

**Result:** The protocol's fundamental invariant `sum(all_balances) == total_supply` is violated. The supply is reduced while the user maintains full access to their tokens.

**Additional Impacts:**

- **Issue with alias**: Newly minted tokens become permanently inaccessible as they're stored under the wrong storage key (DoS of issued tokens)
- **Lock with alias**: Locked tokens are stored in the virtual address under the wrong key, making them unrecoverable via `Unlock` (permanent fund lock)
- **Economic manipulation**: Any supply-based calculations for governance weights, reward distributions, or price discovery become incorrect
- **Treasury/Profit accounting**: Distribution mechanisms relying on accurate supply metrics produce wrong results

## Likelihood Explanation

**Highly Likely to Occur:**

- **Reachable Entry Points**: `Issue`, `Burn`, and `Lock` are public functions directly callable by any user meeting standard authorization requirements
- **Feasible Preconditions**: 
  - Token aliases are legitimate features set by NFT collection owners/issuers via `SetSymbolAlias` (authorized by design)
  - `Burn` only requires user to own burnable tokens
  - `Issue` requires issuer authorization (standard)
  - `Lock` requires lock whitelist permission (standard)
- **Zero Attack Cost**: The `Burn` attack costs nothing - user "burns" tokens while keeping them
- **No Special Privileges**: Beyond normal token operations, no elevated permissions needed
- **User Error Likely**: Even without malicious intent, legitimate users calling these functions with aliases will trigger the bug
- **Detection Difficulty**: Transactions appear normal; only deep state inspection reveals the storage key mismatch

## Recommendation

Normalize the symbol parameter in `ModifyBalance` before writing to storage:

```csharp
private void ModifyBalance(Address address, string symbol, long addAmount)
{
    var actualSymbol = GetActualTokenSymbol(symbol); // Normalize first
    var before = GetBalance(address, actualSymbol);
    if (addAmount < 0 && before < -addAmount)
        Assert(false,
            $"{address}. Insufficient balance of {actualSymbol}. Need balance: {-addAmount}; Current balance: {before}");

    var target = before.Add(addAmount);
    State.Balances[address][actualSymbol] = target; // Write to normalized key
}
```

Alternatively, ensure all entry points normalize symbols before calling `ModifyBalance`:
- `Issue`: Use `tokenInfo.Symbol` from `AssertValidToken` result
- `Burn`: Use `tokenInfo.Symbol` from `AssertValidToken` result  
- `Lock`: Use `tokenInfo.Symbol` from `AssertValidToken` result

## Proof of Concept

```csharp
[Fact]
public async Task SymbolAlias_Burn_SupplyAccountingError()
{
    // Setup: Create NFT collection and item with alias
    const string collectionSymbol = "TEST-0";
    const string itemSymbol = "TEST-1"; 
    const string aliasSymbol = "ALIAS";
    const long amount = 100;
    
    // Create NFT collection
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = collectionSymbol,
        TokenName = "TEST Collection",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        Owner = DefaultSender
    });
    
    // Create NFT item
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = itemSymbol,
        TokenName = "TEST Item",
        TotalSupply = amount,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        Owner = DefaultSender
    });
    
    // Issue tokens to user
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = itemSymbol,
        Amount = amount,
        To = DefaultSender
    });
    
    // Set alias
    await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = itemSymbol,
        Alias = aliasSymbol
    });
    
    // Verify initial state
    var balanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultSender,
        Symbol = itemSymbol
    });
    balanceBefore.Balance.ShouldBe(amount);
    
    var tokenInfoBefore = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = itemSymbol
    });
    var supplyBefore = tokenInfoBefore.Supply;
    
    // Execute attack: Burn using alias instead of actual symbol
    await TokenContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = aliasSymbol,  // Using alias, not actual symbol
        Amount = amount
    });
    
    // Verify broken invariant
    var balanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultSender,
        Symbol = itemSymbol
    });
    
    var tokenInfoAfter = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = itemSymbol
    });
    
    // VULNERABILITY: User still has full balance but supply was reduced
    balanceAfter.Balance.ShouldBe(amount); // Still 100!
    tokenInfoAfter.Supply.ShouldBe(supplyBefore - amount); // Reduced by 100
    
    // Invariant violated: sum(balances) > supply
    Assert.True(balanceAfter.Balance > tokenInfoAfter.Supply);
}
```

## Notes

This vulnerability affects the core token accounting system and breaks a critical protocol invariant. The asymmetric read-write behavior in `ModifyBalance` combined with the legitimate alias feature creates an exploitable state corruption. The issue is particularly severe because:

1. It can be triggered unintentionally by users legitimately using aliases
2. The `Burn` variant allows supply deflation without actual token destruction
3. The `Lock` variant permanently strands tokens in virtual addresses
4. All supply-dependent protocol mechanisms become unreliable

The fix requires consistent symbol normalization in either `ModifyBalance` itself or all its entry points.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```
