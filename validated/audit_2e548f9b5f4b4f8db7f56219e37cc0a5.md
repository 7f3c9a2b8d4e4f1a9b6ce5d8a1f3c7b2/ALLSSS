# Audit Report

## Title 
Governance Lockout via Extreme Threshold Configuration Enabled by Insufficient Validation Bounds

## Summary
The Parliament contract allows organizations to set threshold configurations that create mathematically impossible approval requirements (100% approval with 0% tolerance for any abstention or rejection), resulting in permanent governance lockout. An attacker with temporary majority control can permanently disable governance by passing a single malicious threshold change proposal.

## Finding Description

The Parliament contract's threshold validation logic permits extreme configurations that violate the fundamental requirement that governance must remain functional. The `Validate` method enforces only basic mathematical constraints (sum of thresholds ≤ 100%, approval > 0) but imposes no practical upper bounds on approval requirements or lower bounds on tolerance thresholds. [1](#0-0) 

This allows setting `MinimalApprovalThreshold = 10000` (100%), `MinimalVoteThreshold = 10000` (100%), `MaximalAbstentionThreshold = 0`, and `MaximalRejectionThreshold = 0`. Test cases explicitly confirm this configuration passes validation: [2](#0-1) 

When proposals are evaluated for release, the threshold checking logic creates impossible requirements. The rejection check blocks proposals if ANY member rejects: [3](#0-2) 

The abstention check blocks proposals if ANY member abstains: [4](#0-3) 

The approval check requires ALL parliament members to approve: [5](#0-4) 

With extreme thresholds (MinimalApprovalThreshold=10000, MaximalRejectionThreshold=0, MaximalAbstentionThreshold=0), the evaluation logic requires:
- `approvedMemberCount * 10000 >= 10000 * parliamentMembers.Count` → ALL members must approve
- `rejectionMemberCount * 10000 > 0` → ANY rejection blocks the proposal
- `abstentionMemberCount * 10000 > 0` → ANY abstention blocks the proposal

This creates a scenario where every parliament member must actively approve (100% participation and agreement), with not a single member rejecting, abstaining, or being offline—mathematically impossible in a decentralized system with independent actors.

The `ChangeOrganizationThreshold` method can be executed via proposal since it requires `Context.Sender` to equal the organization address, which only occurs when called through a released proposal: [6](#0-5) 

An attacker controlling the default 66.67% of miners can:
1. Create a proposal calling `ChangeOrganizationThreshold` with extreme values
2. Approve it with their controlled majority
3. Release the proposal (meeting current 66.67% threshold)
4. Permanently lock governance once the threshold change executes

The emergency response organization provides no protection. It must be created via proposal (requiring Context.Sender == DefaultOrganizationAddress): [7](#0-6) 

The emergency response organization has no special authority to override other organizations' thresholds and is itself just another Parliament organization with 90% approval threshold: [8](#0-7) 

## Impact Explanation

**Severity: HIGH**

Once extreme thresholds are set, the organization experiences complete governance failure:
- No future proposal can ever achieve 100% unanimous approval with zero tolerance
- Protocol cannot respond to security incidents requiring governance action
- Critical upgrades and parameter adjustments become permanently impossible
- All stakeholders dependent on governance functionality are affected

The impact is permanent because no recovery mechanism exists—you cannot pass a proposal to fix the thresholds when no proposal can pass. The emergency response organization cannot override threshold changes for other organizations, and can itself be attacked the same way.

This represents a complete DoS of the governance layer, affecting the protocol's ability to evolve, respond to threats, or perform any governance-controlled operations.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Attacker Requirements:**
- Temporary control of 66.67% of current miners (default approval threshold)
- Ability to create and approve a single proposal

**Feasibility Factors:**
- Attack complexity is LOW: single proposal with straightforward parameters
- Configuration explicitly passes contract validation (proven in test suite)
- Attack requires only temporary control to execute, but creates permanent damage
- Attacker can disguise threshold change within a proposal batch to reduce detection
- Once executed, damage persists even after attacker loses control

**Realistic Attack Vectors:**
- Validator collusion during governance attack
- Temporary stake concentration
- Coordinated miner bribery
- Exploitation during miner set transitions

The 66.67% control requirement is within established threat models for high-stakes governance attacks, especially considering the permanent nature of the damage relative to the temporary control needed.

## Recommendation

Implement practical bounds on threshold configurations to ensure governance remains functional:

1. **Add maximum approval threshold constraint**: Limit `MinimalApprovalThreshold` to a reasonable maximum (e.g., 9000 = 90%) to ensure proposals can pass with realistic supermajority support.

2. **Add minimum tolerance thresholds**: Require `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` to be at least a minimum value (e.g., 500 = 5%) to provide tolerance for offline nodes or dissenting opinions.

3. **Add feasibility validation**: Ensure that `MinimalApprovalThreshold + MaximalRejectionThreshold + MaximalAbstentionThreshold < AbstractVoteTotal` to guarantee at least one valid state exists where proposals can pass.

Modified validation logic:
```csharp
private bool Validate(Organization organization)
{
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    const int MaxAllowedApprovalThreshold = 9000; // 90% maximum
    const int MinRequiredToleranceThreshold = 500; // 5% minimum tolerance
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= MaxAllowedApprovalThreshold && // NEW
           proposalReleaseThreshold.MaximalAbstentionThreshold >= MinRequiredToleranceThreshold && // MODIFIED
           proposalReleaseThreshold.MaximalRejectionThreshold >= MinRequiredToleranceThreshold && // MODIFIED
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task GovernanceLockout_ViaExtremeThresholds_Test()
{
    // Setup: Create organization with default thresholds (66.67% approval)
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 6667,
            MinimalVoteThreshold = 7500,
            MaximalAbstentionThreshold = 2000,
            MaximalRejectionThreshold = 2000
        }
    };
    
    var organizationAddress = await ParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    organizationAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attack Step 1: Create proposal to change thresholds to extreme values
    var extremeThresholds = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 10000, // 100% approval required
        MinimalVoteThreshold = 10000,
        MaximalAbstentionThreshold = 0,    // Zero tolerance for abstention
        MaximalRejectionThreshold = 0      // Zero tolerance for rejection
    };
    
    var proposalId = await CreateProposalAsync(
        organizationAddress.Output,
        nameof(ParliamentContractStub.ChangeOrganizationThreshold),
        extremeThresholds
    );
    
    // Attack Step 2: Approve with 66.67% majority (2 out of 3 miners)
    await ApproveWithMinersAsync(proposalId, InitialMinersKeyPairs.Take(2));
    
    // Attack Step 3: Release proposal
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Governance is now permanently locked
    var newProposalId = await CreateProposalAsync(
        organizationAddress.Output,
        nameof(ParliamentContractStub.ChangeOrganizationThreshold),
        createOrganizationInput.ProposalReleaseThreshold // Try to revert to safe thresholds
    );
    
    // Even with ALL miners approving, proposal cannot pass
    await ApproveWithMinersAsync(newProposalId, InitialMinersKeyPairs);
    
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(newProposalId);
    proposal.ToBeReleased.ShouldBeFalse(); // LOCKED: Cannot release even with 100% approval
    
    // Attempting release will fail
    var attemptRelease = await ParliamentContractStub.Release.SendWithExceptionAsync(newProposalId);
    attemptRelease.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    attemptRelease.TransactionResult.Error.ShouldContain("Not approved");
}
```

## Notes

The default organization thresholds are defined as 66.67% approval: [9](#0-8) 

The vulnerability affects the proposal release flow where threshold checks are evaluated: [10](#0-9) 

No administrative override or recovery mechanism exists in the codebase to forcefully change an organization's thresholds once they are set to extreme values. The only modification path is through the `ChangeOrganizationThreshold` method which itself requires passing a proposal under the locked thresholds.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L187-196)
```csharp
        {
            createOrganizationInput.ProposalReleaseThreshold = proposalReleaseThreshold;
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L203-210)
```csharp
    public override Empty CreateEmergencyResponseOrganization(Empty input)
    {
        Assert(State.EmergencyResponseOrganizationAddress.Value == null,
            "Emergency Response Organization already exists.");
        AssertSenderAddressWith(State.DefaultOrganizationAddress.Value);
        CreateEmergencyResponseOrganization();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-9)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
```
