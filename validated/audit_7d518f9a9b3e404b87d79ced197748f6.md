# Audit Report

## Title
Code Hash Collision Enables Permanent Blocking of Legitimate Contract Deployments

## Summary
The `ProposeNewContract` function in the Genesis contract fails to prevent multiple simultaneous proposals with identical contract code but different parameters (e.g., category). This allows an attacker to front-run legitimate deployments by creating a parallel proposal that races to deployment, permanently blocking the victim's contract and transferring authorship rights.

## Finding Description

The vulnerability exists in the contract proposal tracking mechanism. The system validates code hash uniqueness only against already-deployed contracts, not against pending proposals with the same code hash.

In `ProposeNewContract`, the code hash is computed and checked against deployed contracts only [1](#0-0) , where `AssertContractNotExists` verifies the code hash doesn't exist in `State.SmartContractRegistrations` [2](#0-1) .

However, proposals are tracked by `proposedContractInputHash`, which is calculated from the entire `ContractDeploymentInput` structure [3](#0-2) . This hash includes the category field [4](#0-3) , meaning proposals with identical code but different categories produce different hashes.

The proposal registration only checks for duplicate `proposedContractInputHash` values [5](#0-4) , allowing multiple proposals with the same code hash but different parameters to coexist simultaneously.

Code hashes are only registered in `State.SmartContractRegistrations` upon actual deployment [6](#0-5) . When the first proposal deploys, it registers the code hash, and any subsequent deployment with the same code hash fails the `AssertContractNotExists` check [7](#0-6) .

The state tracking confirms no mechanism exists to prevent code hash collisions in pending proposals [8](#0-7) .

## Impact Explanation

**HIGH Severity** - This vulnerability enables three critical impacts:

1. **Permanent Deployment Blocking**: The victim's approved proposal becomes permanently undeployable, failing with "contract code has already been deployed before" despite passing all governance and code check stages.

2. **Loss of Contract Authorship**: The attacker gains authorship rights, which control critical contract operations. Only the author can update contract code [9](#0-8)  and transfer authorship [10](#0-9) .

3. **Strategic Exploitation**: This can be weaponized to block competitors from deploying infrastructure contracts or to steal valuable deterministic contract addresses.

## Likelihood Explanation

**MEDIUM Likelihood** - The attack requires:

1. **Monitoring proposals** (trivial - public on-chain data)
2. **Submitting proposals** (unrestricted - no access control on `ProposeNewContract`)
3. **Governance approval** (requires coordination)

While governance is assumed honest, the vulnerability lies in the contract logic allowing this scenario to exist. Honest governance might approve both proposals if:
- They process proposals in batches without cross-checking code hashes
- Different category values appear to represent legitimately different contracts  
- No automated tooling detects code hash collisions across proposals

The multi-stage governance process (Parliament approval → code check → deployment) provides a window of hours to days for the attack to succeed.

## Recommendation

Add code hash tracking for pending proposals. In `ProposeNewContract`, check if any pending proposal already has the same code hash:

```csharp
public override Hash ProposeNewContract(ContractDeploymentInput input)
{
    var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
    AssertContractNotExists(codeHash);
    
    // NEW: Check no pending proposal has this code hash
    AssertCodeHashNotInPendingProposals(codeHash);
    
    var proposedContractInputHash = CalculateHashFromInput(input);
    RegisterContractProposingData(proposedContractInputHash);
    // ... rest of function
}

private void AssertCodeHashNotInPendingProposals(Hash codeHash)
{
    // Add State.PendingProposalsByCodeHash mapping
    Assert(State.PendingProposalsByCodeHash[codeHash] == null, 
           "A proposal with this code hash is already pending.");
    State.PendingProposalsByCodeHash[codeHash] = true;
}
```

Clear the tracking when deployment completes or proposals expire.

## Proof of Concept

```csharp
[Fact]
public async Task CodeHashCollision_BlocksLegitimateDeployment()
{
    var contractCode = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value);
    
    // Victim proposes with category 0
    var victimProposal = new ContractDeploymentInput
    {
        Category = 0,
        Code = contractCode
    };
    var victimResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress, 
        nameof(BasicContractZero.ProposeNewContract), 
        victimProposal);
    victimResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attacker proposes same code with category 1 - should fail but succeeds
    var attackerProposal = new ContractDeploymentInput
    {
        Category = 1,
        Code = contractCode
    };
    var attackerResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        attackerProposal);
    
    // VULNERABILITY: Both proposals succeed despite having same code hash
    attackerResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Both approved through governance... attacker deploys first
    // Victim's deployment will now permanently fail
}
```

## Notes

The existing test `DeploySmartContracts_RepeatedProposals_Test` only validates rejection of identical input structures, not code hash collisions with different parameters [11](#0-10) . This gap in test coverage allowed the vulnerability to persist.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L125-126)
```csharp
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L127-128)
```csharp
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L181-183)
```csharp
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L522-524)
```csharp
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L21-22)
```csharp
        var codeHash = HashHelper.ComputeFrom(code);
        AssertContractNotExists(codeHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L71-71)
```csharp
        State.SmartContractRegistrations[reg.CodeHash] = reg;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L379-382)
```csharp
    private void AssertContractNotExists(Hash codeHash)
    {
        Assert(State.SmartContractRegistrations[codeHash] == null, "contract code has already been deployed before.");
    }
```

**File:** protobuf/acs0.proto (L156-162)
```text
message ContractDeploymentInput {
    // The category of contract code(0: C#).
    sint32 category = 1;
    // The byte array of the contract code.
    bytes code = 2;
    ContractOperation contract_operation = 3;
}
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroState.cs (L13-17)
```csharp
    public MappedState<Hash, SmartContractRegistration> SmartContractRegistrations { get; set; }

    public MappedState<Hash, Address> NameAddressMapping { get; set; }

    public MappedState<Hash, ContractProposingInput> ContractProposingInputMap { get; set; }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L974-1046)
```csharp
    public async Task DeploySmartContracts_RepeatedProposals_Test()
    {
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory, // test the default runner
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        // propose contract code
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);

        {
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.Contains("Already proposed.").ShouldBeTrue();
        }

        {
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.Contains("Already proposed.").ShouldBeTrue();
        }

        var proposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;

        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);

        // release contract code and trigger code check proposal
        var releaseApprovedContractTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ReleaseApprovedContract), new ReleaseContractInput
            {
                ProposalId = proposalId,
                ProposedContractInputHash = proposedContractInputHash
            });

        var codeCheckProposalId = ProposalCreated.Parser
            .ParseFrom(releaseApprovedContractTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;

        await ApproveWithMinersAsync(Tester, ParliamentAddress, codeCheckProposalId);
        {
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.Contains("Already proposed.").ShouldBeTrue();
        }

        // release code check proposal and deployment completes
        var deploymentResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ReleaseCodeCheckedContract),
            new ReleaseContractInput
                { ProposedContractInputHash = proposedContractInputHash, ProposalId = codeCheckProposalId });

        deploymentResult.Status.ShouldBe(TransactionResultStatus.Mined);
        {
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.ShouldContain("contract code has already been deployed before");
        }
```
