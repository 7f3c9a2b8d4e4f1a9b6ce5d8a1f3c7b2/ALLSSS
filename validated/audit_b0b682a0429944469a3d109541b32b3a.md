# Audit Report

## Title
Missing Mining Interval Validation in Next Round Consensus Transition

## Summary
The consensus validation logic fails to verify that the mining interval in submitted next round data matches the configured `State.MiningInterval.Value` parameter. A malicious miner can submit next round information with arbitrarily modified mining intervals, causing permanent consensus timing disruption that persists across all subsequent rounds.

## Finding Description

The AEDPoS consensus contract stores a fixed mining interval parameter that is set during initialization. However, the validation logic for next round transitions does not enforce that submitted round data respects this configured value.

The `ValidationForNextRound()` function only performs two checks: [1](#0-0) 

The mining interval parameter is defined in contract state: [2](#0-1) 

And set during initialization: [3](#0-2) 

The only time-related validation is `CheckRoundTimeSlots()`, which only ensures internal consistency: [4](#0-3) 

When generating future rounds, the system calculates the mining interval from the current round's timing rather than using the configured state value: [5](#0-4) 

This calculated interval is then used to set expected mining times in the next round: [6](#0-5) 

**Attack Scenario**: A malicious miner can modify all `ExpectedMiningTime` values in next round data to use any interval (e.g., 8000ms instead of 4000ms). As long as the intervals remain internally consistent, all validation passes. The corrupted interval then propagates to all future rounds via `GetMiningInterval()`.

## Impact Explanation

**Consensus Timing Disruption**: The mining interval is a fundamental consensus parameter that determines block production rate. Changing it from 4000ms to 8000ms halves network throughput, while changing it to 2000ms doubles it, affecting all network participants.

**Permanent Cumulative Drift**: Since `GetMiningInterval()` calculates from the stored round data rather than `State.MiningInterval.Value`, the manipulated interval persists indefinitely. Each subsequent round inherits the corrupted timing, creating permanent protocol deviation.

**Protocol Invariant Violation**: The mining interval should remain fixed per the initialization configuration. This vulnerability allows arbitrary modification of a core consensus parameter, breaking the fundamental assumption that consensus timing parameters are immutable.

**Network-Wide Impact**: All validators, block producers, and dependent systems are affected when consensus timing deviates from expected parameters. Applications relying on predictable block times may malfunction.

## Likelihood Explanation

**Direct Entry Point**: Any active miner can produce blocks containing consensus extra data with NextRound behavior. The validation is performed via the standard block validation pipeline: [7](#0-6) 

**Low Attack Complexity**: The attacker only needs to:
1. Generate legitimate next round data via standard consensus mechanism
2. Modify all `ExpectedMiningTime` values proportionally to establish a different interval
3. Include the modified data in their block's consensus extra data

**Standard Preconditions**: The attacker must be an active miner in the rotation, which is a standard participant role obtained through the election process, not a privileged position requiring system compromise.

**Subtle Detection**: The attack produces internally consistent round data that passes all existing validations. Without comparing against `State.MiningInterval.Value`, the manipulation is not detected by the validation logic.

## Recommendation

Add validation to compare the submitted mining interval against the stored configuration:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
        
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate mining interval matches configured value
    var providedInterval = extraData.Round.GetMiningInterval();
    var expectedInterval = State.MiningInterval.Value;
    if (providedInterval != expectedInterval)
        return new ValidationResult { 
            Message = $"Mining interval {providedInterval}ms does not match expected {expectedInterval}ms." 
        };
    
    return new ValidationResult { Success = true };
}
```

Alternatively, modify `CheckRoundTimeSlots()` to accept and validate against an expected interval parameter.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanModifyMiningInterval_Test()
{
    // Setup: Initialize consensus with 4000ms interval
    await InitializeConsensus(miningInterval: 4000);
    await ProduceNormalBlocks(rounds: 2);
    
    // Get current round
    var currentRound = await GetCurrentRoundInformation();
    Assert.Equal(4000, currentRound.GetMiningInterval());
    
    // Malicious miner generates next round with doubled interval (8000ms)
    currentRound.GenerateNextRoundInformation(
        Context.CurrentBlockTime, 
        BlockchainStartTimestamp, 
        out var maliciousNextRound);
    
    // Modify all ExpectedMiningTime values to use 8000ms interval
    var startTime = Context.CurrentBlockTime;
    var order = 1;
    foreach (var miner in maliciousNextRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        miner.ExpectedMiningTime = startTime.AddMilliseconds(8000 * order);
        order++;
    }
    
    // Submit the malicious round
    var input = NextRoundInput.Create(maliciousNextRound, randomNumber);
    await AEDPoSContract.NextRound(input);
    
    // Verify the manipulated interval was accepted
    var newRound = await GetCurrentRoundInformation();
    Assert.Equal(8000, newRound.GetMiningInterval()); // Vulnerability: 8000ms instead of 4000ms
    
    // Verify the corruption persists to subsequent rounds
    await ProduceNextRound();
    var subsequentRound = await GetCurrentRoundInformation();
    Assert.Equal(8000, subsequentRound.GetMiningInterval()); // Cumulative drift confirmed
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L28-28)
```csharp
    public ReadonlyState<int> MiningInterval { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L83-83)
```csharp
        State.MiningInterval.Value = input.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-56)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```
