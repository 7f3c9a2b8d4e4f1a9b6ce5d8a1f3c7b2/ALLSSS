# Audit Report

## Title
Missing Validation of TuneOrderInformation Allows Miners to Corrupt Next Round Mining Schedule

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract directly applies `TuneOrderInformation` values from miner-submitted `UpdateValueInput` without validating that order values are within the valid range [1, minersCount] or checking for duplicates. This allows a malicious miner to inject arbitrary order values that corrupt the mining schedule, causing non-deterministic round generation across nodes and consensus DoS.

## Finding Description

The vulnerability exists in the consensus update flow where mining order information for the next round is processed without validation.

When a miner produces a block, they submit an `UpdateValue` transaction containing an `UpdateValueInput` message. This message includes a `tune_order_information` map that allows setting order values for multiple miners [1](#0-0) .

In `ProcessUpdateValue`, these values are directly applied to the current round state without any validation [2](#0-1) .

The validation system for `UpdateValue` behavior only checks cryptographic values (OutValue, Signature, PreviousInValue), not the order information [3](#0-2) .

The `NextRoundMiningOrderValidationProvider` has a critical bug - it calls `.Distinct()` on `MinerInRound` objects instead of on the order values themselves [4](#0-3) . Since `MinerInRound` is a protobuf-generated class with multiple properties [5](#0-4) , each miner's object is always distinct even when they have identical `FinalOrderOfNextRound` values.

When generating the next round, the corrupted `FinalOrderOfNextRound` values are used directly to determine mining order [6](#0-5) . The `OrderBy` operation becomes non-deterministic when duplicate order values exist, because the source sequence comes from dictionary values [7](#0-6)  which have non-deterministic iteration order.

More critically, if an attacker sets out-of-range order values (e.g., all miners set to order 999), the `BreakContinuousMining` function attempts to find a miner with `Order == 1` and throws an exception when none exists [8](#0-7) , causing consensus to halt.

## Impact Explanation

This vulnerability breaks consensus integrity with severe network-wide consequences:

**1. Non-Deterministic Round Generation**: When a malicious miner sets duplicate order values (e.g., two miners with `FinalOrderOfNextRound` = 3), different nodes will generate different `nextRound` objects because `OrderBy` preserves the relative order from the source dictionary, which has non-deterministic iteration order. This causes block hash mismatches and consensus failure.

**2. Consensus DoS**: By setting all miners' `FinalOrderOfNextRound` to values greater than `minersCount`, the attacker causes `GenerateNextRoundInformation` to throw an exception when attempting to find a miner with `Order == 1`. This halts all NextRound generation attempts, stopping block production entirely.

**3. Mining Schedule Corruption**: Out-of-range order values push affected miners' `ExpectedMiningTime` far into the future through the calculation `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))` [9](#0-8) , effectively excluding them from consensus.

**4. No Recovery Mechanism**: Once the round state is corrupted, there is no validation or recovery mechanism to detect and correct these values.

## Likelihood Explanation

The vulnerability is highly exploitable:

**Attacker Requirements**: The attacker must be an elected miner in the current miner list, verified by `PreCheck()` [10](#0-9) .

**Attack Complexity**: Low. The attacker only needs to modify their consensus client to craft a custom `UpdateValueInput` with malicious `TuneOrderInformation` values and submit it during their legitimate mining time slot.

**Method Accessibility**: The `UpdateValue` method is publicly accessible [11](#0-10) .

**No Prevention**: The validation providers added for `UpdateValue` behavior are only `UpdateValueValidationProvider` and `LibInformationValidationProvider` [12](#0-11) . Neither validates the order values, and `NextRoundMiningOrderValidationProvider` is only added for NextRound behavior [13](#0-12) .

**Probability**: High. Any malicious miner can execute this attack during their time slot with only transaction fee costs.

## Recommendation

Add comprehensive validation for `TuneOrderInformation` before applying values:

```csharp
// In ProcessUpdateValue, before line 259:
var minersCount = currentRound.RealTimeMinersInformation.Count;
var usedOrders = new HashSet<int>();

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate order is in valid range
    if (tuneOrder.Value < 1 || tuneOrder.Value > minersCount)
    {
        Assert(false, $"Invalid order value {tuneOrder.Value}. Must be between 1 and {minersCount}.");
    }
    
    // Check for duplicates
    if (!usedOrders.Add(tuneOrder.Value))
    {
        Assert(false, $"Duplicate order value {tuneOrder.Value} in TuneOrderInformation.");
    }
    
    // Verify the key corresponds to a valid miner in current round
    if (!currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key))
    {
        Assert(false, $"Invalid miner public key {tuneOrder.Key} in TuneOrderInformation.");
    }
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

Additionally, fix `NextRoundMiningOrderValidationProvider` to check distinctness of order VALUES:

```csharp
// In NextRoundMiningOrderValidationProvider.cs:
var orderValues = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
var distinctCount = orderValues.Distinct().Count();
if (distinctCount != orderValues.Count || 
    distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound.";
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanCorruptMiningSchedule_WithInvalidTuneOrderInformation()
{
    // Setup: Initialize consensus with 3 miners
    var minerKeys = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(minerKeys);
    
    // Miner1 produces a malicious UpdateValue with duplicate orders
    var maliciousUpdateValue = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("sig"),
        SupposedOrderOfNextRound = 1,
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        TuneOrderInformation = 
        {
            { "miner1", 999 },  // Out of range order
            { "miner2", 999 },  // Duplicate order
            { "miner3", 2 }
        }
    };
    
    // Attack: Submit malicious UpdateValue (should be rejected but isn't)
    await ExecuteUpdateValueAsMiner("miner1", maliciousUpdateValue);
    
    // Verify: Round state is corrupted with invalid orders
    var round = await GetCurrentRound();
    Assert.Equal(999, round.RealTimeMinersInformation["miner1"].FinalOrderOfNextRound);
    Assert.Equal(999, round.RealTimeMinersInformation["miner2"].FinalOrderOfNextRound);
    
    // Impact: NextRound generation fails with exception
    await Assert.ThrowsAsync<InvalidOperationException>(async () => 
        await TriggerNextRound("miner3")); // Throws at First(i => i.Order == 1)
}
```

### Citations

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L13-17)
```csharp
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```
