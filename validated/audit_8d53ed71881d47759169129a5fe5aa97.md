# Audit Report

## Title
Missing Signature Verification Allows Miner Order Manipulation in Next Round

## Summary
The AEDPoS consensus mechanism fails to verify that the signature value provided by miners is correctly computed, allowing malicious miners to manipulate their mining order in the next round. The signature determines mining positions deterministically, but validation only checks for non-null values without recomputing and verifying correctness against the expected `previousRound.CalculateSignature(PreviousInValue)` calculation.

## Finding Description

The vulnerability exists in the consensus data application and validation flow. When a miner produces a block, their signature value should be deterministically calculated using the previous round's state. [1](#0-0) 

The signature calculation occurs in the consensus extra data generation. [2](#0-1) 

However, the `ApplyNormalConsensusData` function directly accepts and uses the signature parameter without verification, immediately converting it to calculate the mining order. [3](#0-2) 

The calculated order directly determines the miner's final position. [4](#0-3) 

The validation flow through `UpdateValueValidationProvider` only performs a non-null check on the signature field. [5](#0-4) 

It validates that `PreviousInValue` hashes correctly to the previous round's `OutValue`, but never recomputes the signature to verify `CalculateSignature(PreviousInValue) == providedSignature`. [6](#0-5) 

When the `UpdateValue` transaction executes, it directly assigns the unverified signature from the input. [7](#0-6) 

**Attack Vector:**

Since `GetConsensusExtraData` and `GenerateConsensusTransactions` are view methods, [8](#0-7)  a malicious miner can:

1. Call these methods locally to obtain correctly calculated consensus data
2. Modify the signature value before block creation to achieve a desired mining order
3. Submit the block with the manipulated signature  
4. Pass validation since only non-null checks are performed

The manipulated signature becomes part of the round state and directly determines the miner's position in the next round through `FinalOrderOfNextRound`, which is used to schedule mining times. [9](#0-8) 

The post-execution validation also fails to detect manipulation because `RecoverFromUpdateValue` copies the manipulated signature from the header into the current round state. [10](#0-9) 

## Impact Explanation

**Critical Consensus Integrity Violation:**
This vulnerability breaks a fundamental invariant of the AEDPoS consensus mechanism - that mining order is determined by cryptographically secure, unpredictable randomness. By allowing miners to choose their position in the next round, the system loses its fairness guarantees.

**Economic Impact:**
- Miners mining earlier in a round collect more transaction fees due to earlier access to the transaction pool
- Strategic positioning enables MEV (Maximal Extractable Value) opportunities
- Earlier miners have higher influence on the Last Irreversible Block height calculations, affecting finality

**Randomness Pollution:**
The manipulated signature becomes part of the round state and is used by `CalculateSignature` in subsequent rounds, affecting randomness calculations for multiple future rounds and potentially compounding the attacker's advantage.

**Undetectable Attack:**
The manipulated signature appears valid in all respects (proper format, non-null) and leaves no trace in validation failures, making the attack impossible to detect without implementing signature recomputation verification.

## Likelihood Explanation

**High Likelihood:**
- Any miner in the consensus set can execute this attack
- Requires only modification of node software to alter consensus extra data before block submission  
- No special privileges beyond normal mining rights required
- Zero additional cost beyond normal block production
- No risk of detection or penalty under current validation logic

**Low Complexity:**
The attacker simply needs to:
1. Intercept the consensus extra data generation output
2. Calculate which signature values yield favorable orders via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. Replace the correct signature with the chosen value
4. Submit the block normally with modified consensus data

**Economic Rationality:**
With zero cost and risk, rational miners are incentivized to exploit this for competitive advantage in fee collection and strategic block positioning.

## Recommendation

Add signature verification in `UpdateValueValidationProvider` to recompute and validate the signature:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var publicKey = validationContext.SenderPubkey;
    var providedRound = validationContext.ExtraData.Round;
    
    if (!providedRound.RealTimeMinersInformation.ContainsKey(publicKey))
        return false;
    
    var minerInRound = providedRound.RealTimeMinersInformation[publicKey];
    if (minerInRound.Signature == null || minerInRound.PreviousInValue == null)
        return true; // Skip if not applicable
    
    // Recompute expected signature
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(
        minerInRound.PreviousInValue);
    
    // Verify it matches provided signature
    return minerInRound.Signature == expectedSignature;
}
```

Then call this method in `ValidateHeaderInformation`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };
    
    if (!ValidateSignature(validationContext))
        return new ValidationResult { Message = "Incorrect signature value." };

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test consensus round with multiple miners
2. Generating correct consensus data via `GetConsensusExtraData`  
3. Modifying the signature value in the returned data
4. Submitting block with modified signature
5. Observing that validation passes and the manipulated signature determines next round order

Due to the complexity of the full consensus flow and requirement for integration testing with block production infrastructure, a complete executable PoC would require substantial test harness setup. However, the code analysis clearly demonstrates that:

- `ApplyNormalConsensusData` uses signature without verification (line 13, 19-21)
- `UpdateValueValidationProvider` only checks non-null (line 31-32)  
- `ProcessUpdateValue` assigns unverified input (line 244)
- No signature recomputation validation exists anywhere in the validation chain

The attack path is straightforward and requires no special conditions beyond being an active miner.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L88-92)
```csharp
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-21)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-244)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-75)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }

    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-17)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
```
