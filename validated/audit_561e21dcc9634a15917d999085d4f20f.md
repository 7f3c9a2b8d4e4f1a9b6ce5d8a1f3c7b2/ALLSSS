# Audit Report

## Title
UpdateValueValidationProvider Allows Manipulation of Next-Round Mining Order

## Summary
The `UpdateValueValidationProvider` fails to validate that `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values match the deterministic calculation based on miner signatures. A malicious miner can provide arbitrary order values in their block header, manipulating the mining order for the next round and breaking consensus fairness.

## Finding Description

The vulnerability exists in the consensus validation flow for `UpdateValue` behavior. The validation only checks that `OutValue` and `Signature` are filled, and that `PreviousInValue` hashes correctly. [1](#0-0) 

It does NOT validate the `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` fields that determine the next round's mining order.

These order values should be deterministically calculated from miner signatures using the formula: [2](#0-1) 

When honest miners generate blocks, they correctly calculate these values through `ApplyNormalConsensusData`. However, when the consensus transaction is processed, `ProcessUpdateValue` directly applies order values from the input without validation: [3](#0-2) 

When the next round is generated, miners are ordered by their `FinalOrderOfNextRound` values, directly using the manipulated values: [4](#0-3) 

The validation adds `UpdateValueValidationProvider` for UpdateValue behavior but this provider lacks order validation: [5](#0-4) 

## Impact Explanation

**Consensus Integrity Violation**: The attack allows complete control over mining order for the next round, breaking a critical consensus invariant. Mining order determines block reward distribution, transaction ordering (potential MEV opportunities), and network fairness.

**Quantified Damage**: 
- Attacker can guarantee themselves position 1 in every round, maximizing block rewards
- Honest miners are pushed to unfavorable positions  
- The randomness mechanism preventing predictable ordering is completely bypassed
- Over multiple rounds, the attacker accumulates significantly more rewards than their fair share

**Affected Parties**: All network participants. Honest miners receive reduced rewards, users experience potential transaction ordering manipulation, and the overall security model of AEDPoS consensus is compromised.

## Likelihood Explanation

**Attacker Capabilities**: Any current miner can execute this attack. Requirements:
- Mining slot (already possessed)
- Ability to construct custom block headers with manipulated Round data
- Valid signature, OutValue, and PreviousInValue (standard requirements)

**Attack Complexity**: Low. The attacker:
1. Generates valid consensus values (OutValue, Signature, PreviousInValue) normally
2. Modifies the `Round` structure in block header to set desired order values
3. Submits the block

**Feasibility**: Always feasible when the attacker has a mining slot. No special preconditions required.

**Detection**: Difficult because manipulated blocks pass all validation checks and the impact only becomes visible when the next round starts.

**Economic Rationality**: Highly rational. Zero cost (just different header data), with benefits including preferential mining positions and increased block rewards.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that order values match the deterministic calculation:

```csharp
private bool ValidateOrderValues(ConsensusValidationContext validationContext)
{
    var providedRound = validationContext.ProvidedRound;
    var pubkey = validationContext.SenderPubkey;
    
    if (!providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;
        
    var minerInfo = providedRound.RealTimeMinersInformation[pubkey];
    var signature = minerInfo.Signature;
    
    if (signature == null) return false;
    
    var minersCount = providedRound.RealTimeMinersInformation.Count;
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    // Validate the miner's own order matches the calculation
    if (minerInfo.SupposedOrderOfNextRound != expectedOrder)
        return false;
        
    // Validate FinalOrderOfNextRound values for all miners
    // by reconstructing the conflict resolution logic
    
    return true;
}
```

And call this validation in `ValidateHeaderInformation`.

## Proof of Concept

A test demonstrating the vulnerability would:
1. Create a mining scenario with multiple miners
2. Have a malicious miner construct an `UpdateValueInput` with valid `OutValue`, `Signature`, `PreviousInValue`
3. But set arbitrary `SupposedOrderOfNextRound` and `TuneOrderInformation` values (e.g., setting themselves to order 1 and others to higher orders)
4. Submit this via `UpdateValue` method
5. Verify the block passes validation
6. Generate next round and verify the manipulated order is applied
7. Demonstrate the attacker consistently gets favorable positions

The test would validate that the current implementation allows this manipulation to succeed, confirming the consensus fairness violation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-261)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-37)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
