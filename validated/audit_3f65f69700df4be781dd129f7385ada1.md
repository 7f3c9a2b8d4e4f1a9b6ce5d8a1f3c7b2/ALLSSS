# Audit Report

## Title
EnableConnector DepositBalance Overwrite Vulnerability Leading to Fund Lock and Sell DoS

## Summary
The `EnableConnector` function in the TokenConverter contract directly overwrites `State.DepositBalance` with a newly calculated value, completely ignoring any existing balance accumulated from previous buy transactions. This publicly callable function lacks authorization checks and duplicate call prevention, allowing any attacker to repeatedly reset the deposit balance, causing permanent fund lock and complete denial of service for sell operations.

## Finding Description

The vulnerability exists in the `EnableConnector` function where deposit balance accounting is fundamentally broken through direct state assignment.

**Root Cause - Direct Assignment Instead of Increment:** [1](#0-0) 

This line performs a direct assignment (`=`) that completely overwrites any existing deposit balance. In contrast, the `Buy` function correctly increments the balance: [2](#0-1) 

When users purchase tokens through `Buy`, the deposit balance correctly accumulates base tokens. However, calling `EnableConnector` on an already-enabled connector resets this accumulated value to whatever `GetNeededDeposit` calculates, without considering the current balance.

**Missing Protection #1 - No Duplicate Call Prevention:**

The `EnableConnector` function has no check to prevent re-enabling already active connectors. Compare this to `UpdateConnector`: [3](#0-2) 

This explicit guard prevents updating after activation, but `EnableConnector` lacks any similar protection, allowing repeated calls on active connectors.

**Missing Protection #2 - No Authorization Requirement:** [4](#0-3) 

The entire `EnableConnector` function is publicly callable with no authorization check. In contrast, critical management functions like `UpdateConnector`, `AddPairConnector`, and `SetFeeRate` all require controller authority: [5](#0-4) 

**Manipulable Calculation:**

The `GetNeededDeposit` calculation depends on user-controlled `AmountToTokenConvert`: [6](#0-5) 

An attacker can manipulate this parameter to minimize `needDeposit.NeedAmount`, potentially reducing it to near-zero or zero, allowing them to overwrite large accumulated balances with minimal values.

**Attack Execution Path:**

1. Connector pair exists with `IsPurchaseEnabled = true` and accumulated `DepositBalance = 5000` from user trading
2. Attacker crafts `ToBeConnectedTokenInfo` with appropriate `AmountToTokenConvert` to minimize deposit calculation
3. Attacker calls public `EnableConnector` function (no authorization check stops this)
4. Function calculates `needDeposit.NeedAmount = 100` based on manipulated input
5. Line 297 overwrites: `State.DepositBalance[(NT)RESOURCE] = 100` (was 5000)
6. **4900 base tokens become permanently unaccounted for**

## Impact Explanation

**Permanent Fund Lock:**

The difference between the actual accumulated balance and the overwritten value becomes permanently locked in the contract with no state variable tracking it. These funds cannot be recovered through normal contract operations since all balance accounting now references the incorrect, artificially reduced value.

**Complete Sell Denial of Service:**

The `Sell` function subtracts from `DepositBalance`: [7](#0-6) 

With `DepositBalance = 100` but actual contract holding 5000 base tokens, any user attempting to sell tokens worth more than 100 base tokens will trigger arithmetic underflow in the `.Sub()` operation, causing transaction revert. This creates complete DoS of sell functionality for the affected connector pair, trapping all token holders.

**Affected Parties:**
- All existing token holders who purchased through `Buy` and wish to exit positions
- The protocol's market integrity and liquidity mechanisms
- Future users unable to interact with the compromised connector pair

This breaks the fundamental security guarantee that user deposits are accurately tracked and redeemable.

## Likelihood Explanation

**High Likelihood due to:**

1. **No Privileges Required:** Any user can call `EnableConnector` - it's a public function with zero authorization checks
2. **Low Attack Complexity:** Single function call with easily calculable parameters
3. **Common Precondition:** Active connector pairs with trading volume exist in normal operation
4. **Minimal Attack Cost:** Attacker only needs access to some resource tokens (obtainable through initial purchase), and these tokens remain in the contract, not consumed
5. **High Economic Incentive:** 
   - Attack cost is minimal (temporary token transfer)
   - Impact is severe (lock large sums + market DoS)
   - Profit opportunities via shorting affected tokens or manipulating prices by removing sell liquidity
6. **Difficult Detection:** Attack appears as legitimate `EnableConnector` call in logs without obvious malicious indicators

The combination of public access, no duplicate call prevention, and direct balance overwrite makes this vulnerability easily exploitable in production environments.

## Recommendation

Implement three critical protections:

1. **Add Duplicate Activation Check:**
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // ADD THIS CHECK
    Assert(!fromConnector.IsPurchaseEnabled && !toConnector.IsPurchaseEnabled, 
        "Connector is already enabled.");
    
    // ... rest of function
}
```

2. **Add Authorization Requirement:**
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    // ADD THIS CHECK
    AssertPerformedByConnectorController();
    
    // ... rest of function
}
```

3. **Use Addition Instead of Assignment:**
```csharp
// Change from:
State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;

// To:
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

Additionally, ensure connector state persistence:
```csharp
State.Connectors[toConnector.Symbol] = toConnector;
State.Connectors[fromConnector.Symbol] = fromConnector;
```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Overwrites_DepositBalance_Vulnerability()
{
    // Setup: Initialize and create token
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "VULN";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 100_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });

    // First Enable: Legitimate activation
    var firstEnableInput = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 50_000_000
    };
    await DefaultStub.EnableConnector.SendAsync(firstEnableInput);
    
    // Users buy tokens, accumulating DepositBalance
    await DefaultStub.Buy.SendAsync(new BuyInput { Symbol = tokenSymbol, Amount = 10_000_000 });
    var depositConnectorSymbol = "(NT)" + tokenSymbol;
    var balanceAfterBuy = State.DepositBalance[depositConnectorSymbol];
    balanceAfterBuy.ShouldBeGreaterThan(0); // e.g., 1000 base tokens accumulated

    // Attack: Attacker calls EnableConnector again with manipulated input
    var attackInput = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 40_000_000 // Manipulated to minimize needDeposit
    };
    
    // This should fail but doesn't due to missing checks
    var attackResult = await DefaultStub.EnableConnector.SendAsync(attackInput);
    attackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify vulnerability: DepositBalance overwritten to lower value
    var balanceAfterAttack = State.DepositBalance[depositConnectorSymbol];
    balanceAfterAttack.ShouldBeLessThan(balanceAfterBuy); // Funds now locked!
    
    // Verify DoS: Sell operations fail due to underflow
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = tokenSymbol,
        Amount = 5_000_000
    });
    sellResult.TransactionResult.Error.ShouldContain("underflow"); // Sell is now broken
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```
