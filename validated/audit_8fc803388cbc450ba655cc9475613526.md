# Audit Report

## Title
Scheme Manager Can Dilute User Profits by Adding Phantom Shares Without Token Locking

## Summary
The TokenHolder contract allows scheme managers to add beneficiaries with arbitrary profit shares without requiring token locking, while regular users must lock tokens to receive shares. This creates an exploitable asymmetry where managers can dilute legitimate users' profits by adding phantom shares immediately before distribution, enabling direct theft of user funds.

## Finding Description

The TokenHolder contract implements two fundamentally different paths for becoming a profit beneficiary, creating a critical economic imbalance:

**Regular User Path (RegisterForProfits):** Users must lock tokens to participate in profit distribution. The function enforces a 1:1 correspondence between locked token amount and profit shares allocated. [1](#0-0) 

**Manager Path (AddBeneficiary):** The scheme manager can directly add any beneficiary with arbitrary shares without any token locking requirement. The only authorization check validates that the caller is the scheme manager. [2](#0-1) 

The underlying Profit contract's authorization mechanism permits both the scheme manager and the TokenHolder contract to add beneficiaries, but performs no validation of economic backing for the added shares. [3](#0-2) 

When profits are distributed, all shares are treated equally using proportional allocation based on the formula `(shares / totalShares) × totalAmount`, with no distinction between shares backed by locked tokens and unbacked phantom shares. [4](#0-3) 

**Critical Timing Vulnerability:** TokenHolder schemes do not set `DelayDistributePeriodCount` when created via `CreateScheme`, meaning it defaults to 0. [5](#0-4) 

When adding beneficiaries, the `StartPeriod` is calculated as `CurrentPeriod + DelayDistributePeriodCount`. With the default value of 0, newly added shares participate in the current period's distribution immediately. [6](#0-5) 

The manager has exclusive control over distribution timing through the `DistributeProfits` method, enabling atomic addition of phantom shares followed by immediate profit distribution in the same transaction sequence. [7](#0-6) 

## Impact Explanation

This vulnerability enables direct theft of user funds through profit dilution. When legitimate users lock tokens to receive profit shares based on a 1:1 correspondence, a malicious manager can add themselves as a beneficiary with massive unbacked shares, proportionally reducing each user's profit allocation.

**Concrete Attack Scenario:**
- User A locks 1,000 tokens via `RegisterForProfits` → receives 1,000 shares
- 10,000 tokens are contributed as profits to the scheme
- Malicious manager calls `AddBeneficiary` adding themselves with 9,000 phantom shares (zero tokens locked)
- Manager immediately calls `DistributeProfits`
- Total shares in scheme: 10,000 (1,000 legitimate + 9,000 phantom)
- User A receives: (1,000/10,000) × 10,000 = 1,000 tokens (should have been 10,000)
- Manager receives: (9,000/10,000) × 10,000 = 9,000 tokens (with zero economic contribution)

The attack scales linearly with profit amounts and can completely drain user profit entitlements. The scheme manager role is not a privileged system position requiring governance approval - any address can create a scheme and become its manager simply by calling the public `CreateScheme` method. [8](#0-7) 

This violates the fundamental economic invariant established by `RegisterForProfits` that profit shares should correspond to locked economic value in a 1:1 ratio.

## Likelihood Explanation

The attack has HIGH likelihood due to:

**Low Complexity:** Requires only two transactions - `AddBeneficiary` specifying the manager's address and desired share amount, followed by `DistributeProfits`. No complex state manipulation or timing attacks needed.

**Full Control:** The manager has complete unilateral control over both beneficiary addition and distribution timing through the authorization checks in the contract, eliminating any front-running risk or coordination constraints.

**Zero Cost:** No token locking, economic stake, or gas expenditure beyond normal transaction fees required for the attack. The manager risks nothing while gaining proportional profit share equal to the phantom shares added.

**Difficult Detection:** Users cannot predict when the manager will add beneficiaries or trigger distribution. The attack is only observable post-execution when users discover reduced profit amounts upon claiming.

**Economic Rationality:** For any scheme where managers have financial incentive to maximize personal profits, this attack is economically rational with guaranteed success and zero risk.

**No Privilege Required:** Anyone can create schemes and become manager without authorization checks, governance approval, or multi-signature requirements, meaning this vulnerability is not limited to compromised privileged accounts.

## Recommendation

Implement one of the following mitigations:

**Option 1 - Require Token Locking for AddBeneficiary:**
Modify `AddBeneficiary` to require the manager to lock tokens proportional to the shares being added, enforcing the same 1:1 correspondence as `RegisterForProfits`.

**Option 2 - Set Non-Zero DelayDistributePeriodCount:**
Configure `DelayDistributePeriodCount` to a non-zero value (e.g., 1 or more periods) when creating TokenHolder schemes, preventing newly added shares from participating in the current period's distribution. This gives users time to detect and react to malicious beneficiary additions.

**Option 3 - Remove Manager AddBeneficiary Privilege:**
Remove the manager's ability to call `AddBeneficiary` directly, requiring all beneficiaries to register through `RegisterForProfits` with token locking. This enforces uniform economic backing for all profit shares.

**Recommended Solution:** Implement Option 3 for strongest security, or combine Options 1 and 2 for defense-in-depth if manager flexibility is required for legitimate use cases.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeManager_Can_Dilute_User_Profits_With_Phantom_Shares()
{
    // Setup: Create scheme and contribute profits
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 10000
    });

    // User locks 1000 tokens to register for profits
    var userStub = GetTokenHolderContractTester(UserKeyPairs.First());
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000
    });

    // Verify user has 1000 shares
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(scheme.SchemeId);
    profitScheme.TotalShares.ShouldBe(1000);

    // ATTACK: Manager adds themselves with 9000 phantom shares (no token locking)
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Shares = 9000
    });

    // Total shares now 10000 (1000 legitimate + 9000 phantom)
    profitScheme = await ProfitContractStub.GetScheme.CallAsync(scheme.SchemeId);
    profitScheme.TotalShares.ShouldBe(10000);

    // Manager distributes profits
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = Starter,
        AmountsMap = { { "ELF", 0L } }
    });

    // User claims their diluted profits
    var userProfitStub = GetTester<ProfitContractImplContainer.ProfitContractImplStub>(
        ProfitContractAddress, UserKeyPairs.First());
    await userProfitStub.ClaimProfits.SendAsync(new Profit.ClaimProfitsInput
    {
        SchemeId = scheme.SchemeId
    });

    // Manager claims their stolen profits
    await ProfitContractStub.ClaimProfits.SendAsync(new Profit.ClaimProfitsInput
    {
        SchemeId = scheme.SchemeId
    });

    // Verify profit dilution: User only gets 1000 (10%) instead of 10000 (100%)
    var userBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses.First(),
        Symbol = "ELF"
    })).Balance;
    
    var managerBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = Starter,
        Symbol = "ELF"
    })).Balance;

    // User should have received all 10000 profits but only got 1000 (diluted to 10%)
    // Manager stole 9000 profits (90%) without locking any tokens
    userBalance.ShouldBeLessThan(10000); // Diluted profits
    managerBalance.ShouldBeGreaterThan(9000); // Stolen profits through phantom shares
}
```

## Notes

This vulnerability represents a critical flaw in the economic model of the TokenHolder contract. While users who call `RegisterForProfits` must lock tokens with a strict 1:1 token-to-share correspondence, the scheme manager can bypass this requirement entirely through `AddBeneficiary`. This asymmetry enables the manager to dilute user profits arbitrarily without any economic stake or risk.

The vulnerability is particularly severe because:
1. No authorization beyond scheme creation is required (anyone can become a manager)
2. The attack is atomic and undetectable until after execution
3. There are no built-in delays or governance controls to protect users
4. The impact scales with the size of contributed profits

Users who lock tokens in good faith expecting proportional profit distribution based on their locked amount will have their rewards diluted by unbacked phantom shares added by the manager.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-176)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L188-188)
```csharp
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
