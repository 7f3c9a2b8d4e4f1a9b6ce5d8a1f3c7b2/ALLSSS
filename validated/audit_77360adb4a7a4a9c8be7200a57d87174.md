# Audit Report

## Title
Approval Count Race Condition: Membership Changes Can Invalidate Legitimately Approved Proposals

## Summary
The Association contract contains a governance vulnerability where legitimately approved proposals can become permanently un-releaseable if approving members are removed from the organization between approval and release. This occurs because the contract recounts approvals against current membership at release time rather than preserving the approval state from when votes were cast.

## Finding Description

When members vote to approve a proposal, their addresses are stored in the proposal's approval list. [1](#0-0)  However, at release time, the system validates approval thresholds by filtering these stored addresses against the **current** organization membership. [2](#0-1) 

This creates a critical vulnerability where:

1. **ProposalX** is created and receives sufficient approvals to meet `MinimalApprovalThreshold` (e.g., 3 approvals from members A, B, C)
2. An attacker with voting power creates **ProposalY** to remove member B via the `RemoveMember` method [3](#0-2) 
3. ProposalY is approved and released, executing the member removal
4. When ProposalX attempts release, the threshold validation fails [4](#0-3)  because the approval recount excludes B's vote (only 2 approvals now count)

The `Validate` method called during member removal only verifies mathematical constraints (that thresholds remain theoretically achievable with the new member count) but does not protect existing approved proposals. [5](#0-4) 

Additionally, the `Release` method can only be called by the original proposer [6](#0-5) , creating a predictable vulnerability window where attackers know when to execute member removal proposals.

## Impact Explanation

This vulnerability breaks the fundamental governance invariant that **approved proposals remain approved until expiration**. The impacts include:

**Operational Impact:**
- Legitimately approved proposals meeting all requirements can be retroactively invalidated
- Critical governance actions (security patches, emergency responses, configuration updates) can be blocked indefinitely
- No recovery mechanism exists without re-adding removed members, which itself requires proposing and approving a new proposal

**Strategic Impact:**
- In contentious governance scenarios, competing factions can systematically block each other's proposals
- Governance deadlock becomes possible when multiple factions employ this tactic
- The attack has asymmetric effectiveness - blocking proposals is easier than passing them

**Severity: HIGH**
While this doesn't directly cause fund loss, it breaks critical governance availability. For organizations managing significant value or critical system parameters, the ability to block governance execution is a severe security issue. Organizations requiring timely governance for security operations face critical risk.

## Likelihood Explanation

**Attacker Requirements:**
The attack requires sufficient voting power within the organization to approve and release a member removal proposal. This is achievable by:
- Organization insiders with voting rights
- Coalitions of members
- Not feasible for external attackers

**Attack Complexity: MODERATE**
- Requires coordinating two proposals (target proposal + member removal)
- Timing window exists between proposal approval and release (when proposer hasn't called Release yet)
- No special technical skills required beyond understanding governance flow
- Can be executed through standard contract methods

**Feasibility:**
- **High feasibility** in organizations with active governance and competing interests
- Can occur **accidentally** through legitimate membership management that inadvertently invalidates pending proposals
- More probable when organizations have frequent membership changes or long proposal review periods
- **No on-chain detection or prevention mechanism exists**

**Economic Rationality:**
- Low cost if attacker already has voting rights
- High strategic value in contentious governance
- Particularly attractive when blocking costs less than defeating a proposal through normal voting

## Recommendation

Implement one of the following solutions:

**Solution 1: Snapshot-Based Validation (Recommended)**
Store a membership snapshot with each proposal at creation time and validate approvals against that snapshot rather than current membership:

```csharp
// In ProposalInfo, add:
OrganizationMemberList MembershipSnapshot

// At proposal creation:
proposal.MembershipSnapshot = organization.OrganizationMemberList.Clone();

// At release time in CheckEnoughVoteAndApprovals:
var approvedMemberCount = proposal.Approvals.Count(proposal.MembershipSnapshot.Contains);
```

**Solution 2: Protect Existing Proposals During Member Removal**
In the `Validate` method called by `RemoveMember`, check all pending proposals to ensure they remain valid after the member removal:

```csharp
// In RemoveMember method, before validation:
foreach (var pendingProposal in GetPendingProposals(organization))
{
    var newApprovalCount = pendingProposal.Approvals
        .Where(a => a != input) // Exclude member being removed
        .Count(organization.OrganizationMemberList.Contains);
    
    Assert(newApprovalCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold,
        "Member removal would invalidate existing approved proposals");
}
```

**Solution 3: Lock Membership During Active Proposals**
Prevent member removal while any approved proposals are pending release.

## Proof of Concept

```csharp
[Fact]
public async Task MemberRemoval_InvalidatesApprovedProposal_Test()
{
    // Setup: Create organization with 5 members and MinimalApprovalThreshold = 3
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Reviewer1, Reviewer2, Reviewer3, 
                                   Accounts[4].Address, Accounts[5].Address }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 3,
            MinimalVoteThreshold = 3,
            MaximalAbstentionThreshold = 2,
            MaximalRejectionThreshold = 2
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { Reviewer1 } }
    };
    
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Step 1: Create ProposalX targeting some action
    var proposalXInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ContractMethodName = "SomeMethod",
        ToAddress = TokenContractAddress,
        Params = ByteString.Empty,
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1)
    };
    var proposalXId = await AssociationContractStub.CreateProposal.SendAsync(proposalXInput);
    
    // Step 2: Get 3 approvals from Reviewer1, Reviewer2, Reviewer3
    var reviewer1Stub = GetAssociationContractTester(Reviewer1KeyPair);
    var reviewer2Stub = GetAssociationContractTester(Reviewer2KeyPair);
    var reviewer3Stub = GetAssociationContractTester(Reviewer3KeyPair);
    
    await reviewer1Stub.Approve.SendAsync(proposalXId.Output);
    await reviewer2Stub.Approve.SendAsync(proposalXId.Output);
    await reviewer3Stub.Approve.SendAsync(proposalXId.Output);
    
    // Verify ProposalX is approved (ToBeReleased = true)
    var proposalX = await AssociationContractStub.GetProposal.CallAsync(proposalXId.Output);
    proposalX.ToBeReleased.ShouldBeTrue(); // Has 3 approvals, meets threshold
    
    // Step 3: Create and approve ProposalY to remove Reviewer2
    var proposalYInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ContractMethodName = nameof(AssociationContractStub.RemoveMember),
        ToAddress = AssociationContractAddress,
        Params = Reviewer2.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1)
    };
    var proposalYId = await AssociationContractStub.CreateProposal.SendAsync(proposalYInput);
    
    // Approve and release ProposalY (removing Reviewer2)
    await reviewer1Stub.Approve.SendAsync(proposalYId.Output);
    await reviewer3Stub.Approve.SendAsync(proposalYId.Output);
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(proposalYId.Output);
    await reviewer1Stub.Release.SendAsync(proposalYId.Output);
    
    // Step 4: Verify ProposalX is no longer releaseable
    var proposalXAfterRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalXId.Output);
    proposalXAfterRemoval.ToBeReleased.ShouldBeFalse(); // Now only 2 valid approvals (Reviewer2 removed)
    proposalXAfterRemoval.ApprovalCount.ShouldBe(3); // Still shows 3 stored approvals
    
    // Step 5: Attempt to release ProposalX - should fail
    var releaseResult = await reviewer1Stub.Release.SendWithExceptionAsync(proposalXId.Output);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved.");
    
    // VULNERABILITY CONFIRMED: 
    // Legitimately approved ProposalX became un-releaseable due to membership change
}
```

**Notes:**
- This vulnerability affects all Association organizations using member removal
- The issue can occur accidentally during legitimate membership management
- Similar patterns should be checked in Parliament and Referendum contracts
- The vulnerability enables governance denial-of-service without requiring fund access

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L186-186)
```csharp
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
