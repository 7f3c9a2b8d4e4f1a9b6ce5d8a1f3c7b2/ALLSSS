# Audit Report

## Title
Unvalidated RevealedInValues Allow PreviousInValue Poisoning Leading to Miner DoS

## Summary
The AEDPoS consensus contract accepts `RevealedInValues` from block producers without cryptographic validation and uses them to set other miners' `PreviousInValue` fields. A malicious consensus miner can inject fake revealed values to permanently poison victim miners' `PreviousInValue`, causing their subsequent blocks to fail validation and enabling targeted denial-of-service attacks.

## Finding Description

The vulnerability exists in the secret sharing mechanism's trust model. When a miner produces a block, they provide `RevealedInValues` for other miners in their trigger information. The contract applies these values without verifying they match the cryptographic reconstruction from shared secret pieces.

**Root Cause**: The `UpdateLatestSecretPieces()` function unconditionally applies `RevealedInValues` from trigger information to other miners' `PreviousInValue` fields without any validation. [1](#0-0) 

The trigger information is created off-chain by the block producer's node software, making it trivially modifiable: [2](#0-1) [3](#0-2) 

**Missing Validation**: The consensus validation only checks the block producer's own `PreviousInValue`, not the `RevealedInValues` they provide for other miners: [4](#0-3) 

Line 38 uses `validationContext.SenderPubkey`, validating only the block producer's data, not the revealed values for other miners.

**Why Victim Cannot Recover**: Once a `PreviousInValue` is poisoned, the conditional update logic in `ApplyNormalConsensusData` prevents correction: [5](#0-4) 

The check only sets `PreviousInValue` if it's `Hash.Empty` or `null`. Since the poisoned value is neither, legitimate updates are blocked.

**Propagation Mechanism**: Poisoned values propagate through block headers. When creating the simplified round for the header, all miners' `PreviousInValue` fields are included: [6](#0-5) 

During validation, these values are unconditionally applied to all miners: [7](#0-6) 

**Attack Execution Flow**:
1. Victim miner misses a round (their `PreviousInValue` becomes `Hash.Empty`)
2. Malicious miner M modifies their node software to inject `RevealedInValues[Victim] = FakeHash`
3. M produces a block, triggering `UpdateLatestSecretPieces` which applies `FakeHash` to victim's `PreviousInValue`
4. Block passes validation (only M's own `PreviousInValue` is validated, not the revealed values)
5. When victim attempts to mine, `ApplyNormalConsensusData` cannot overwrite the poisoned value
6. Victim's block contains `FakeHash` in the round data (propagated via `GetUpdateValueRound`)
7. Validation checks `hash(FakeHash) == Victim's previous OutValue`, which fails
8. Victim's block is rejected with "Incorrect previous in value"

The legitimate secret sharing reconstruction process occurs off-chain and uses Shamir's Secret Sharing: [8](#0-7) 

However, the on-chain contract never verifies that the provided `RevealedInValues` match this reconstruction.

## Impact Explanation

**Consensus Integrity**: Malicious miners can arbitrarily exclude specific victim miners from block production, violating the fairness guarantees of the AEDPoS consensus mechanism. This enables targeted censorship of competing miners.

**Economic Impact**: Victim miners lose block production rewards for every rejected block. The `ProducedBlocks` counter is not incremented while `MissedTimeSlots` increases, damaging their reputation metrics and potentially affecting future mining slot assignments.

**Operational Impact**: Network throughput degrades if multiple miners are targeted simultaneously. The attack creates unpredictability in consensus operations. Poisoned values can cascade across multiple rounds as they propagate through the block header round data.

**Systemic Risk**: The attack is persistent - victims cannot recover without missing another complete round (resetting their `PreviousInValue` to `Hash.Empty`), which compounds their reward losses and reputation damage.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must be an authorized consensus miner, which is within the adversarial threat model for consensus systems. They must modify their node software to inject fake `RevealedInValues` - a trivial code change requiring no cryptographic expertise.

**Attack Complexity**: LOW - The attacker only needs to modify the trigger information generation before producing a block. No timing precision, multi-step coordination, or complex state manipulation is required.

**Feasibility Conditions**:
- Victim must have missed mining in a previous round (common due to network issues, maintenance, node restarts, or prior attacks)
- Attacker must produce a block before victim in the subsequent round (probability increases with miner count inequality)
- Secret sharing must be enabled (deployment configuration): [9](#0-8) 

**Detection Difficulty**: While theoretically detectable by comparing on-chain `RevealedInValues` with legitimate secret sharing reconstruction from available decrypted pieces, detection is post-facto. No in-contract prevention mechanism exists, and victims have no automated recourse once poisoned.

**Incentives**: Malicious miners in competitive scenarios have strong economic incentives to exclude competitors, with zero cost and direct benefit (reduced competition for block rewards).

**Probability**: MEDIUM-HIGH - Miners routinely miss rounds due to operational realities. The attack is simple, undetectable in real-time, and economically rational for competitive miners.

## Recommendation

Implement on-chain cryptographic validation of `RevealedInValues` against the available decrypted pieces:

1. In `UpdateLatestSecretPieces`, verify each revealed in value can be reconstructed from the decrypted pieces using Shamir's Secret Sharing (`SecretSharingHelper.DecodeSecret`)
2. Only apply revealed in values that pass cryptographic verification
3. Alternatively, remove the ability for miners to provide `RevealedInValues` in trigger information and only allow on-chain revelation via the existing `RevealSharedInValues` method

Example validation logic:
```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key)) continue;
    
    var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
    
    // Verify the revealed value can be reconstructed from decrypted pieces
    if (TryReconstructInValue(targetMiner, revealedInValue.Value, updatedRound))
    {
        if (targetMiner.PreviousInValue == Hash.Empty || targetMiner.PreviousInValue == null)
            targetMiner.PreviousInValue = revealedInValue.Value;
    }
}
```

## Proof of Concept

Due to the complexity of the AEDPoS consensus system and the requirement for multi-node interaction, a full PoC requires:

1. Deploy a test network with multiple consensus miners
2. Modify one miner's `AEDPoSTriggerInformationProvider` to inject fake `RevealedInValues`
3. Have the victim miner miss a round (set `PreviousInValue` to `Hash.Empty`)
4. Malicious miner produces a block with poisoned values
5. Victim attempts to mine - block will fail validation with "Incorrect previous in value" message

The vulnerability can be confirmed by examining the contract logic flow documented above with the provided citations. The missing validation at the critical `UpdateLatestSecretPieces` checkpoint allows unverified off-chain data to poison on-chain consensus state.

---

## Notes

This vulnerability represents a fundamental trust assumption violation in the AEDPoS secret sharing mechanism. While the off-chain `SecretSharingService` performs legitimate cryptographic reconstruction, the on-chain contract blindly trusts the `RevealedInValues` provided by block producers without verifying they match the cryptographic commitments in the shared secret pieces. This creates an asymmetry where honest miners perform expensive cryptographic operations while malicious miners can inject arbitrary values with no validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** protobuf/aedpos_contract.proto (L342-343)
```text
    // The revealed InValues.
    map<string, aelf.Hash> revealed_in_values = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-183)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        var revealedInValues = new Dictionary<string, Hash>();

        foreach (var pair in round.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == selfPubkey) continue;

            var pubkey = pair.Key;
            var minerInRound = pair.Value;

            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
        }

        _revealedInValues[secretSharingInformation.CurrentRoundId] = revealedInValues;
```
