# Audit Report

## Title
Authorization Bypass in Contract Update Proposals for Genesis-Authored Contracts

## Summary
The `AssertAuthorityByContractInfo` method in the Genesis contract contains a logic flaw that allows any address to create update proposals for contracts authored by Genesis. The vulnerability exists because the authorization check evaluates `contractInfo.Author == Context.Self` (comparing the stored author against the Genesis address) instead of validating that the caller has proper authority, bypassing the intended author-only restriction at the proposal stage.

## Finding Description

The security issue exists in the authorization validation logic for contract update proposals. When `ProposeUpdateContract` is invoked, it performs an authority check through `AssertAuthorityByContractInfo`: [1](#0-0) 

The authorization method contains flawed conditional logic: [2](#0-1) 

**Root Cause Analysis:**

The condition `contractInfo.Author == Context.Self` checks whether the contract's stored author equals the Genesis contract address, rather than checking whether the caller (`Context.Sender`) has proper authority. When executing within the Genesis contract context, `Context.Self` always refers to the Genesis contract address.

**How Genesis-Authored Contracts Are Created:**

During contract deployment by non-whitelisted proposers, the author assignment logic executes: [3](#0-2) 

When `isProposerInWhiteList` is false, the method returns `Context.Self` (Genesis address), causing the deployed contract to have Genesis as its author: [4](#0-3) 

**Test Evidence:**

Production tests confirm contracts can be deployed with Genesis as author: [5](#0-4) 

Side chain tests demonstrate the EXPECTED behavior - unauthorized proposers should be rejected: [6](#0-5) 

**Why the Check Fails:**

For Genesis-authored contracts where `contractInfo.Author == Genesis address`:
- When code executes in Genesis context: `Context.Self == Genesis address`
- The condition `contractInfo.Author == Context.Self` evaluates to `TRUE`
- The OR operator short-circuits, bypassing the second condition
- The assertion passes regardless of `Context.Sender` value

The correct logic should check: `Context.Sender == Context.Self || address == contractInfo.Author` (validating the CALLER, not the AUTHOR field).

## Impact Explanation

**Authorization Invariant Violation:** The system design expects only contract authors to propose updates, as evidenced by test expectations and the secondary authorization path checking `Context.Sender == contractInfo.Author`. This vulnerability breaks that invariant for Genesis-authored contracts.

**Affected Contract Population:** All contracts deployed through the governance process by non-whitelisted proposers have `author = Genesis` and are susceptible to unauthorized proposal creation by any address.

**Operational Consequences:**
- **Governance Spam:** Attackers can flood the governance system with malicious update proposals at minimal cost (transaction fees only)
- **Resource Drain:** Legitimate governance participants must expend effort reviewing and rejecting unauthorized proposals
- **Social Engineering Risk:** High proposal volume may lead to governance fatigue, potentially allowing malicious proposals to pass through reduced scrutiny

**Severity Limitation:** Actual contract updates still require full governance approval through the code check and release process. The vulnerability bypasses authorization only at the proposal creation stage, not execution, preventing direct unauthorized modifications.

## Likelihood Explanation

**Public Attack Surface:** `ProposeUpdateContract` is a publicly accessible method with no rate limiting: [7](#0-6) 

**Realistic Preconditions:**
- Genesis-authored contracts exist in production environments
- Default system configuration enables `ContractDeploymentAuthorityRequired`
- No additional barriers prevent proposal creation beyond the flawed authorization check

**Low Attack Complexity:**
1. Identify any Genesis-authored contract address (via chain explorer or contract deployment events)
2. Construct malicious contract update code
3. Call `ProposeUpdateContract` with target address and malicious code
4. Authorization check passes automatically

**Economic Feasibility:** Attack cost is minimal - only standard transaction fees. No token holdings, staking, or special permissions required.

## Recommendation

Modify the authorization check to validate the CALLER's authority rather than the contract's AUTHOR field:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    // Check if CALLER is Genesis (special case) OR if CALLER is the contract author
    Assert(address == Context.Self || address == contractInfo.Author, "No permission.");
}
```

This change ensures:
- Genesis contract itself can propose updates (for system contract maintenance)
- Contract authors can propose updates to their contracts
- Unauthorized addresses cannot create proposals regardless of the contract's author field

## Proof of Concept

```csharp
[Fact]
public async Task UnauthorizedProposeUpdateContract_GenesisAuthoredContract_Test()
{
    // Deploy a contract with Genesis as author (simulating non-whitelisted proposer)
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };
    
    var deployedAddress = await DeployAsync(Tester, ParliamentAddress, BasicContractZeroAddress, contractDeploymentInput);
    
    // Verify contract has Genesis as author
    var contractInfo = ContractInfo.Parser.ParseFrom(
        await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), 
            deployedAddress));
    contractInfo.Author.ShouldBe(BasicContractZeroAddress); // Genesis address
    
    // Unauthorized user (AnotherUserKeyPair) attempts to propose update
    var unauthorizedTester = Tester.CreateNewContractTester(AnotherUserKeyPair);
    var updateInput = new ContractUpdateInput
    {
        Address = deployedAddress,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicFunction")).Value)
    };
    
    // VULNERABILITY: This should fail with "No permission" but succeeds
    var result = await unauthorizedTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeUpdateContract), 
        updateInput);
    
    // Expected: result.Status.ShouldBe(TransactionResultStatus.Failed);
    // Expected: result.Error.ShouldContain("No permission.");
    // Actual: result.Status.ShouldBe(TransactionResultStatus.Mined); // VULNERABILITY DEMONSTRATED
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-183)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L248-259)
```csharp
        var creator = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].Indexed[0]).Author;
        creator.ShouldBe(BasicContractZeroAddress);
        var deployAddress = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].NonIndexed).Address;
        deployAddress.ShouldNotBeNull();

        var contractVersion = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].NonIndexed).Version;
        contractVersion.ShouldBe(1);
        var contractInfo = ContractInfo.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), deployAddress));
        contractInfo.Version.ShouldBe(1);
        contractInfo.Author.ShouldBe(BasicContractZeroAddress);
        contractInfo.IsUserContract.ShouldBeFalse();
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1175-1187)
```csharp
        {
            var noPermissionProposingTx = await SideChainTester.GenerateTransactionAsync(SideBasicContractZeroAddress,
                nameof(BasicContractZero.ProposeUpdateContract), AnotherMinerKeyPair, new ContractUpdateInput
                {
                    Address = deployAddress,
                    Code = ByteString.Empty
                });
            var blockReturnSet = await SideChainTester.MineAsync(new List<Transaction> { noPermissionProposingTx });
            var noPermissionProposingTxResult =
                blockReturnSet.TransactionResultMap[noPermissionProposingTx.GetHash()];
            noPermissionProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            noPermissionProposingTxResult.Error.ShouldContain("No permission.");
        }
```
