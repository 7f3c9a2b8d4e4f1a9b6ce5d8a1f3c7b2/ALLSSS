# Audit Report

## Title 
Token Issuer Modification Never Persisted to Storage - Old Issuer Retains All Privileges

## Summary
The `ModifyTokenIssuerAndOwner()` function in the MultiToken contract modifies the token issuer and owner fields in a local memory copy but fails to persist these changes to contract storage. This renders the entire token ownership transfer mechanism completely non-functional - the old issuer retains 100% of issuing privileges while the new issuer gains none.

## Finding Description

The vulnerability exists in the `ModifyTokenIssuerAndOwner()` function which retrieves `tokenInfo` from storage, modifies the `Issuer` and `Owner` fields in memory, but critically fails to persist the changes back to storage. [1](#0-0) 

The function modifies `tokenInfo.Issuer` and `tokenInfo.Owner` in memory at lines 655-656 but never calls `SetTokenInfo()` to persist these changes. The contract uses a `MappedState<string, TokenInfo>` storage pattern where all modifications must be explicitly persisted via the `SetTokenInfo()` helper method. [2](#0-1) 

**Evidence from Correct Implementations:**

All other functions that modify `tokenInfo` correctly call `SetTokenInfo()`:

1. The `Issue()` function modifies supply fields and correctly persists changes at line 167: [3](#0-2) 

2. The `CrossChainReceiveToken()` function modifies supply and correctly persists at line 622: [4](#0-3) 

3. The `SetSymbolAlias()` function modifies external info and correctly persists at line 766: [5](#0-4) 

**Why Authorization Checks Fail:**

When `Issue()` is called, it validates the caller against the issuer stored in persistent storage. The authorization check at line 160 compares `Context.Sender` against `tokenInfo.Issuer`: [6](#0-5) 

Since `ModifyTokenIssuerAndOwner()` never updates storage, the authorization check at line 160 continues to pass for the old issuer and fails for the new issuer. The `GetTokenInfo()` helper used by `AssertValidToken()` retrieves from persistent storage: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Direct Authorization Impact:**
- The token issuer modification function is completely non-functional despite appearing to succeed
- Old issuer retains 100% of token issuance privileges indefinitely 
- New issuer receives 0% privileges despite successful transaction execution
- Token creators cannot transfer control to new addresses, DAOs, or governance structures as intended

**Operational Impact:**
- Breaks the entire token ownership transfer mechanism
- Creates dangerous false sense of security - function executes without error but has no effect
- Users believe they have transferred issuer rights when they have not
- Violates critical protocol invariant for token authorization and governance control

**Who Is Affected:**
- All token creators attempting to use `ModifyTokenIssuerAndOwner()`
- Projects relying on transferring token control to DAOs or new addresses
- Any governance structure expecting issuer changes to be effective
- Token migration scenarios requiring issuer updates

## Likelihood Explanation

**Trigger Conditions:**
- Function is publicly callable by any current token issuer
- No special permissions or state required beyond being the current issuer
- No external dependencies or timing constraints

**Reproducibility:**
- 100% certain - every single execution fails to persist changes
- No attacker action required - this is a functional bug affecting all legitimate users
- Zero complexity - bug triggers automatically on every call

**Feasibility:**
The existing test suite validates only error cases and never verifies functional correctness: [9](#0-8) 

The tests check validation logic but never verify that issuer modifications actually persist and work, which is why this critical bug went undetected.

## Recommendation

Add a call to `SetTokenInfo()` after modifying the token information to persist the changes to storage:

```csharp
public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
{
    Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
    Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
    Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

    var tokenInfo = GetTokenInfo(input.Symbol);

    Assert(tokenInfo != null, "Token is not found.");
    Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
    Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
    
    tokenInfo.Issuer = input.Issuer;
    tokenInfo.Owner = input.Owner;
    
    // ADD THIS LINE:
    SetTokenInfo(tokenInfo);

    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ModifyTokenIssuerAndOwner_Should_Persist_Changes()
{
    // Create a test token without owner
    var symbol = "TEST";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true
    });
    
    // Verify original issuer
    var tokenInfoBefore = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    tokenInfoBefore.Issuer.ShouldBe(DefaultAddress);
    tokenInfoBefore.Owner.ShouldBeNull();
    
    // Modify issuer and owner
    var newIssuer = UserAddress;
    var newOwner = User2Address;
    await TokenContractStub.ModifyTokenIssuerAndOwner.SendAsync(new ModifyTokenIssuerAndOwnerInput
    {
        Symbol = symbol,
        Issuer = newIssuer,
        Owner = newOwner
    });
    
    // Verify changes were persisted
    var tokenInfoAfter = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    
    // BUG: These assertions will FAIL because changes were not persisted
    tokenInfoAfter.Issuer.ShouldBe(newIssuer); // FAILS - still DefaultAddress
    tokenInfoAfter.Owner.ShouldBe(newOwner);   // FAILS - still null
    
    // Verify new issuer can issue tokens
    var issueResult = await TokenContractStubUser.Issue.SendWithExceptionAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = 1000,
        To = UserAddress
    });
    
    // BUG: This will fail with "Sender is not allowed to issue token"
    // because the issuer was never updated in storage
    issueResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    issueResult.TransactionResult.Error.ShouldContain("Sender is not allowed to issue token");
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-168)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L619-623)
```csharp
        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L763-767)
```csharp
        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L12-16)
```csharp
    /// <summary>
    /// WARNING: Use GetTokenInfo & SetTokenInfo to operate TokenInfos
    /// due to token symbol alias feature.
    /// </summary>
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L1828-1900)
```csharp
    {
        var result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput());
        result.TransactionResult.Error.ShouldContain("Invalid input symbol.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST"
        });
        result.TransactionResult.Error.ShouldContain("Invalid input issuer.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Invalid input owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Token is not found.");
        
        result = await TokenContractStubUser.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Only token issuer can set token issuer and owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Can only set token which does not have owner.");
        
        var output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeTrue();
        
        result = await TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled.SendWithExceptionAsync(
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        result.TransactionResult.Error.ShouldContain("Unauthorized behavior.");
        
        var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            defaultParliament, nameof(TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled),
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        await ApproveWithMinersAsync(proposalId);
        await ParliamentContractStub.Release.SendAsync(proposalId);
        
        output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeFalse();
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Set token issuer and owner disabled.");

    }
```
