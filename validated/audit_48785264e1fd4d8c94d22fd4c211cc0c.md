# Audit Report

## Title
Case-Insensitive Token Uniqueness Bypass via CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function implements only case-sensitive token existence checking, while normal token creation enforces case-insensitive uniqueness. This inconsistency allows attackers to create duplicate tokens with different casing (e.g., "ABC-0" and "abc-0") through cross-chain operations, violating the protocol's fundamental token uniqueness invariant.

## Finding Description

The MultiToken contract establishes case-insensitive token uniqueness through the `State.InsensitiveTokenExisting` mapping, which stores symbols in uppercase. [1](#0-0) 

Normal token creation via `CreateToken` properly enforces this invariant by calling `CheckTokenExists` through the validation chain. [2](#0-1) 

The `CheckTokenExists` function performs dual validation: it checks both the case-sensitive `State.TokenInfos[symbol]` mapping and the case-insensitive `State.InsensitiveTokenExisting[symbol.ToUpper()]` mapping. [3](#0-2) 

However, `CrossChainCreateToken` bypasses this protection by using only a case-sensitive check at line 506 that verifies `State.TokenInfos[tokenInfo.Symbol] == null` without checking `State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()]`. [4](#0-3) 

When the check passes, `RegisterTokenInfo` is called, which creates a separate entry in `State.TokenInfos` with the different casing while setting the same uppercase key in `State.InsensitiveTokenExisting`. [5](#0-4) 

This results in two distinct tokens ("ABC-0" and "abc-0") with separate balance and allowance mappings, as these use the symbol string as the key. [6](#0-5) 

Since `GetTokenInfo` performs case-sensitive lookups without normalization, users querying for "ABC-0" will not find "abc-0" and vice versa. [7](#0-6) 

## Impact Explanation

**Protocol Invariant Violation**: The fundamental guarantee that token symbols are case-insensitively unique is broken. This is a core protocol invariant that all token operations depend on.

**State Fragmentation**: If token "ABC-0" exists, an attacker can create "abc-0" as a completely separate token with independent:
- Token information (issuer, owner, supply, decimals)
- Balance mappings for all addresses
- Allowance mappings between addresses
- Lock whitelist configurations

**User Confusion**: Users and dApps expecting case-insensitive token identification will interact with the wrong token, as token lookups use exact case matching.

**NFT Collection Fragmentation**: For NFT collections, this creates parallel namespaces where "ABC-0" and "abc-0" can each issue their own items (ABC-1, ABC-2 vs abc-1, abc-2), fragmenting what should be a unified collection.

**Cross-Chain Consistency**: Multi-chain deployments will face inconsistencies when case variants exist on different chains, breaking cross-chain transfer assumptions.

## Likelihood Explanation

**Entry Point**: `CrossChainCreateToken` is a public RPC method accessible to any caller with valid cross-chain proof. [8](#0-7) 

**Prerequisites**:
1. Token contract must be registered in `State.CrossChainTransferWhiteList` for the source chain - this is standard in multi-chain setups [9](#0-8) 
2. Valid merkle proof and cross-chain verification required [10](#0-9) 
3. Attacker must be able to create token on source chain

**Feasibility**: In legitimate multi-chain environments where parent/side chains are properly registered (normal operation), the attack is straightforward once prerequisites are met. The attacker creates a case-variant token on Chain A, then submits `CrossChainCreateToken` on Chain B with valid proof.

**Assessment**: MEDIUM likelihood - feasible in multi-chain deployments where chains are legitimately connected and source chain allows token creation.

## Recommendation

Add case-insensitive existence check in `CrossChainCreateToken` before calling `RegisterTokenInfo`. The fix should be:

```csharp
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    // Add this check to match CheckTokenExists behavior
    Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
           "Token already exists.");
    
    RegisterTokenInfo(tokenInfo);
    // ... rest of the code
}
```

This ensures `CrossChainCreateToken` enforces the same case-insensitive uniqueness guarantee as normal token creation.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitive_Bypass_Test()
{
    await GenerateSideChainAsync();
    await RegisterMainChainTokenContractAddressOnSideChainAsync();
    
    // Create "ABC-0" token on main chain
    var upperCaseSymbol = "ABC-0";
    var createTransaction = await CreateTransactionForTokenCreation(
        TokenContractStub, DefaultAccount.Address, upperCaseSymbol, TokenContractAddress);
    var blockExecutedSet = await MineAsync(new List<Transaction> { createTransaction });
    blockExecutedSet.TransactionResultMap[createTransaction.GetHash()].Status
        .ShouldBe(TransactionResultStatus.Mined);
    
    // Create "abc-0" token on side chain (different case)
    var lowerCaseSymbol = "abc-0";
    var sideCreateTransaction = await CreateTransactionForTokenCreation(
        SideChainTokenContractStub, SideChainTestKit.DefaultAccount.Address, 
        lowerCaseSymbol, SideTokenContractAddress);
    var sideBlockExecutedSet = await SideChainTestKit.MineAsync(
        new List<Transaction> { sideCreateTransaction });
    sideBlockExecutedSet.TransactionResultMap[sideCreateTransaction.GetHash()].Status
        .ShouldBe(TransactionResultStatus.Mined);
    
    // Cross-chain create "abc-0" on main chain (should fail but currently succeeds)
    var sideTokenInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = lowerCaseSymbol });
    var tokenValidationTransaction = CreateTokenInfoValidationTransaction(
        sideTokenInfo, SideChainTokenContractStub);
    var executedSet = await SideChainTestKit.MineAsync(
        new List<Transaction> { tokenValidationTransaction });
    
    var merklePath = GetTransactionMerklePathAndRoot(tokenValidationTransaction, out var blockRoot);
    await IndexSideChainTransactionAsync(executedSet.Height, blockRoot, blockRoot);
    
    var crossChainCreateTokenInput = new CrossChainCreateTokenInput
    {
        FromChainId = SideChainId,
        ParentChainHeight = executedSet.Height,
        TransactionBytes = tokenValidationTransaction.ToByteString(),
        MerklePath = merklePath
    };
    
    // This should fail with "Token already exists" but currently succeeds
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(
        crossChainCreateTokenInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Both tokens now exist on main chain with different casing
    var upperToken = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = upperCaseSymbol });
    var lowerToken = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = lowerCaseSymbol });
    
    upperToken.ShouldNotBeNull();
    lowerToken.ShouldNotBeNull();
    upperToken.Symbol.ShouldBe(upperCaseSymbol);
    lowerToken.Symbol.ShouldBe(lowerCaseSymbol);
    // Vulnerability confirmed: Two distinct tokens with case-variant symbols
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L19-20)
```csharp
    public MappedState<Address, string, long> Balances { get; set; }
    public MappedState<Address, Address, string, long> Allowances { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L488-488)
```csharp
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** protobuf/token_contract.proto (L75-77)
```text
    // The side chain creates tokens.
    rpc CrossChainCreateToken(CrossChainCreateTokenInput) returns (google.protobuf.Empty) {
    }
```
