# Audit Report

## Title
Orphaned AssembledNftsMap Entries Enable Permanent Locking of NFTs When Assembled Tokens Are Burned

## Summary
The NFT contract's `Burn` method lacks validation to prevent burning assembled NFTs and fails to clean up `AssembledNftsMap` entries. When a minter directly burns an assembled NFT instead of calling `Disassemble`, all component NFTs/FTs locked during assembly become permanently irrecoverable, as they remain in the contract's balance with no mechanism to retrieve them.

## Finding Description

The vulnerability exists in the `Burn` method's failure to account for assembled NFTs that contain locked components.

**The Assemble/Disassemble Pattern:**

When users create composite NFTs via `Assemble`, component NFTs are transferred to `Context.Self` (the contract address) [1](#0-0)  and tracked in `AssembledNftsMap` [2](#0-1) .

The `Disassemble` method correctly handles cleanup by: (1) burning the assembled NFT, (2) retrieving locked components from `AssembledNftsMap`, (3) transferring them back to the receiver, and (4) removing the map entry [3](#0-2) .

**The Vulnerability:**

The `Burn` method only validates that the protocol is burnable and that the caller has sufficient balance AND is a minter [4](#0-3) . Critically, the entire `Burn` method contains NO reference to `AssembledNftsMap` or `AssembledFtsMap` - it performs no checks to detect assembled NFTs and no cleanup of map entries [5](#0-4) .

**Why Recovery is Impossible:**

Once an assembled NFT is burned directly:
1. The NFT's balance becomes 0 [6](#0-5) 
2. The locked components remain in `Context.Self`'s balance
3. The `AssembledNftsMap` entry persists as an orphaned record (defined at [7](#0-6) )
4. `Disassemble` cannot be called because it first calls `Burn`, which will fail when the balance is already 0 [8](#0-7) 
5. No emergency withdrawal or administrative rescue mechanism exists in the contract

## Impact Explanation

**HIGH severity** due to:

1. **Permanent Asset Loss**: All NFTs and FTs locked in an assembled NFT become permanently irrecoverable when the assembled NFT is burned directly. The assets remain in the contract's balance but are inaccessible by any method.

2. **No Recovery Mechanism**: The NFT contract contains no emergency withdrawal functionality or administrative override to retrieve orphaned assets.

3. **Broken Invariant**: This violates the fundamental lock/unlock correctness guarantee - assets that are locked together should always be retrievable through the proper unlock mechanism.

4. **Potential Value Loss**: Locked NFTs may have substantial value (rare collectibles, utility NFTs with access rights, etc.), and third parties who transferred valuable NFTs to a minter for assembly lose their assets permanently.

## Likelihood Explanation

**MEDIUM-HIGH probability** because:

1. **Low Attack Complexity**: A single direct call to `Burn` on an assembled NFT triggers the vulnerability - no complex transaction sequencing required.

2. **Realistic Preconditions**: 
   - The caller must be a minter (automatically true for anyone who assembled NFTs, as `Assemble` calls `PerformMint` [9](#0-8)  which requires minter permission [10](#0-9) )
   - The protocol must have `IsBurnable = true` (common configuration)
   - The caller must own the assembled NFT (natural state after assembling)

3. **High User Error Probability**: Users may not understand the critical difference between `Burn` and `Disassemble`. Natural user behavior when wanting to "destroy" an NFT is to call `Burn`, with no warning in the code or interface that this is unsafe for assembled NFTs.

4. **No Protection**: The contract provides no guard rails - `Burn` treats assembled NFTs identically to regular NFTs.

## Recommendation

Add validation in the `Burn` method to prevent burning assembled NFTs:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add this check
    Assert(State.AssembledNftsMap[tokenHash] == null && State.AssembledFtsMap[tokenHash] == null,
        "Cannot burn assembled NFT directly. Use Disassemble method instead.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    // ... rest of existing code
}
```

Alternatively, automatically call the disassembly logic within `Burn` when an assembled NFT is detected, but the simpler and safer approach is to enforce use of the dedicated `Disassemble` method.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_LocksComponentsPermanently_Test()
{
    // Setup: Create protocol and mint initial NFTs
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    
    var componentTokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Alias = "Component NFT",
        Owner = DefaultAddress,
        Uri = $"{BaseUri}component"
    })).Output;

    // Approve ELF for FT assembly
    await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = long.MaxValue
    });

    // Assemble: Lock component NFT + 100 ELF into assembled NFT
    var assembledTokenHash = (await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledNfts = new AssembledNfts
        {
            Value = { [componentTokenHash.ToHex()] = 1 }
        },
        AssembledFts = new AssembledFts
        {
            Value = { ["ELF"] = 100 }
        }
    })).Output;

    // Verify component NFT is now owned by contract
    var contractComponentBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        TokenHash = componentTokenHash,
        Owner = NFTContractAddress
    })).Balance;
    contractComponentBalance.ShouldBe(1);

    // Get assembled NFT info to burn it
    var assembledNftInfo = await NFTContractStub.GetNFTInfoByTokenHash.CallAsync(assembledTokenHash);
    
    // VULNERABILITY: Burn assembled NFT directly instead of calling Disassemble
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = assembledNftInfo.Symbol,
        TokenId = assembledNftInfo.TokenId,
        Amount = 1
    });

    // Verify assembled NFT balance is now 0
    var assembledBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        TokenHash = assembledTokenHash,
        Owner = DefaultAddress
    })).Balance;
    assembledBalance.ShouldBe(0);

    // IMPACT: Component NFT still locked in contract, but no way to retrieve it
    var stillLockedComponentBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        TokenHash = componentTokenHash,
        Owner = NFTContractAddress
    })).Balance;
    stillLockedComponentBalance.ShouldBe(1); // Still locked!

    // Attempting Disassemble fails because balance is already 0
    var disassembleResult = await NFTContractStub.Disassemble.SendWithExceptionAsync(new DisassembleInput
    {
        Symbol = assembledNftInfo.Symbol,
        TokenId = assembledNftInfo.TokenId
    });
    disassembleResult.TransactionResult.Error.ShouldContain("No permission"); // Burn fails due to 0 balance

    // PERMANENT LOSS: Component NFT is permanently locked in contract with no recovery mechanism
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L128-131)
```csharp
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L175-175)
```csharp
        var nftMinted = PerformMint(mingInput, true);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-178)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-225)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```
