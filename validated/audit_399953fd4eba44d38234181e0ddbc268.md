# Audit Report

## Title
Organization Member List Manipulation Allows Governance Bypass Through Post-Creation Vote Manipulation

## Summary
The Association contract fails to snapshot the organization member list at proposal creation time, allowing dynamic membership changes to manipulate voting outcomes on active proposals. Members added after proposal creation can vote on existing proposals, and removed members' votes can be retroactively invalidated during threshold checks.

## Finding Description

The Association contract contains a critical governance flaw where voting authorization and vote counting both check against the current organization member list rather than a snapshot captured at proposal creation time.

**Flaw 1: Dynamic Authorization Check**

When members vote on proposals, the contract verifies membership against the live organization state. [1](#0-0)  The authorization helper queries the current member list: [2](#0-1) 

This means anyone added to the organization after a proposal's creation can immediately vote on that proposal, violating the governance principle that voting rights are determined at proposal creation time.

**Flaw 2: Vote Counting Filters by Current Membership**

During proposal release, the threshold calculation filters all votes by checking if voters still exist in the current member list:
- Rejections are filtered: [3](#0-2) 
- Abstentions are filtered: [4](#0-3)   
- Approvals are filtered: [5](#0-4) 

If a member is removed from the organization, their previously-cast vote becomes invisible to the threshold calculation, effectively erasing their participation.

**Root Cause: No Member Snapshot**

The ProposalInfo structure only stores a reference to the organization address, not the member list state at creation time: [6](#0-5) 

**Attack Vector: Member Modification Functions**

The organization can modify its membership through three functions, all callable by the organization itself via proposal execution:
- [7](#0-6) 
- [8](#0-7) 
- [9](#0-8) 

**Exploitation Scenario:**

1. Organization has 5 members (A,B,C,D,E) with thresholds: MinimalApprovalThreshold=2, MaximalRejectionThreshold=1
2. Controversial Proposal P1 is created
3. Voting: A,B approve (2), D,E reject (2) - P1 fails due to rejections > threshold
4. Organization creates Proposal P2 to remove member D
5. P2 passes with A,B,C approving
6. After D's removal, when P1's release is checked, rejection count becomes 1 (only E remains in member list)
7. P1 now passes: rejections(1) ≤ MaximalRejectionThreshold(1), approvals(2) ≥ MinimalApprovalThreshold(2)

Alternatively, new members can be added who then vote on existing proposals they had no stake in when those proposals were created.

## Impact Explanation

This vulnerability enables complete governance bypass with critical consequences:

**Governance Integrity Violation**: The fundamental principle that voting rights and vote weight are fixed at proposal creation time is violated. This makes all governance outcomes potentially unreliable.

**Vote Manipulation**: An organization controlling enough votes to pass one proposal (for membership changes) can manipulate any other pending proposal's outcome by:
- Adding favorable members who vote to support failing proposals
- Removing opposing members to invalidate their rejection votes

**Threshold Circumvention**: The carefully-designed approval/rejection thresholds become meaningless when the effective voter base can be retroactively modified.

**Systemic Impact**: All Association-based governance decisions (treasury allocations, parameter changes, contract upgrades) are affected. This undermines trust in the entire governance framework.

The severity is CRITICAL because it breaks core governance guarantees without requiring any privilege escalation or system compromise.

## Likelihood Explanation

This vulnerability has HIGH likelihood of exploitation:

**Low Barrier to Entry**: Any organization that can pass one proposal (to modify membership) can exploit this. No special privileges or system-level access required.

**Simple Execution**: The attack uses standard, documented functions (`AddMember`, `RemoveMember`, `CreateProposal`, `Release`). No complex exploitation technique needed.

**Natural Opportunity**: In contested governance scenarios, it's common to have multiple pending proposals with different voting patterns. This creates natural opportunities for manipulation.

**Validation Constraints Are Weak**: The validation logic [10](#0-9)  allows adding members freely (increasing member count loosens constraints) and removing members as long as thresholds remain valid for the new count.

**Detection Difficulty**: Member modifications appear as legitimate governance actions. There's no on-chain indicator distinguishing malicious timing-based manipulation from normal operations.

**Realistic Precondition**: Organizations routinely manage membership changes. The attacker needs only to time these changes strategically around pending proposals.

## Recommendation

Implement member list snapshotting at proposal creation time:

**Solution 1: Store Member Snapshot in ProposalInfo**
Modify the ProposalInfo structure to store a snapshot of the organization member list at creation:
```protobuf
message ProposalInfo {
    // ... existing fields ...
    OrganizationMemberList member_list_snapshot = 14;
}
```

Update proposal creation to capture the snapshot: [11](#0-10) 

Update voting authorization to check against the snapshot instead of current state.

Update all vote counting logic to use the snapshotted member list instead of the current organization member list.

**Solution 2: Block Member Changes During Active Voting**
Alternatively, prevent member modifications when proposals are pending by adding checks in `AddMember`, `RemoveMember`, and `ChangeMember` to revert if any non-expired proposals exist for the organization.

**Solution 3: Decouple Vote Validity from Current Membership**  
Change vote counting to honor all votes from addresses that were valid members at the time they voted, regardless of current membership status. This requires timestamping membership changes and comparing against vote receipt times.

The recommended approach is **Solution 1** (member snapshot) as it provides the clearest governance semantics and prevents both attack vectors.

## Proof of Concept

```csharp
[Fact]
public async Task MemberListManipulation_AllowsGovernanceBypass_Test()
{
    // Setup: Create organization with 5 members and specific thresholds
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 2,
        minimalVoteThreshold: 2, 
        maximalAbstentionThreshold: 0,
        maximalRejectionThreshold: 1,
        Reviewer1); // Reviewer1,2,3 are members

    // Create controversial Proposal P1 (treasury transfer)
    var proposalP1 = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Initial voting: 2 approvals, 2 rejections
    await ApproveAsync(Reviewer1KeyPair, proposalP1);
    await ApproveAsync(Reviewer2KeyPair, proposalP1);
    await RejectAsync(Reviewer3KeyPair, proposalP1);
    
    // Add a 4th member via another proposal
    var newMember = Accounts[4].Address;
    var addMemberProposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair,
        newMember,
        nameof(AssociationContractStub.AddMember),
        organizationAddress);
    
    // Pass the AddMember proposal
    await ApproveAsync(Reviewer1KeyPair, addMemberProposal);
    await ApproveAsync(Reviewer2KeyPair, addMemberProposal);
    
    await TransferToOrganizationAddressAsync(organizationAddress);
    var reviewer1Stub = GetAssociationContractTester(Reviewer1KeyPair);
    await reviewer1Stub.Release.SendAsync(addMemberProposal);
    
    // Exploit: New member votes on old proposal P1
    await RejectAsync(Accounts[4].KeyPair, proposalP1);
    
    // P1 now has 2 rejections (exceeds MaximalRejectionThreshold=1)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalP1);
    proposal.RejectionCount.ShouldBe(2); // But member was added AFTER proposal creation
    proposal.ToBeReleased.ShouldBeFalse(); // Should not be releasable due to excess rejections
    
    // However, if we had removed Reviewer3 instead, their rejection would be ignored
    // proving votes can be retroactively invalidated
}
```

## Notes

This vulnerability affects the fundamental governance mechanism in the Association contract. The current implementation treats the member list as a live reference rather than a point-in-time snapshot, which is a critical design flaw in any voting system. 

While the validation constraints [10](#0-9)  prevent some extreme manipulations (e.g., removing so many members that thresholds become unsatisfiable), they don't prevent the core issue: members can be added or removed to influence pending proposals.

The vulnerability is exacerbated by the fact that vote counting actively filters by current membership rather than simply checking voter eligibility at vote-time. This means removing a member doesn't just prevent them from voting in the future—it retroactively erases their past votes from threshold calculations.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L127-128)
```csharp
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L42-44)
```csharp
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-51)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```
