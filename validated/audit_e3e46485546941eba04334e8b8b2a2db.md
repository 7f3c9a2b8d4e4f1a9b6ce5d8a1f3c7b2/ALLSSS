# Audit Report

## Title
Transaction Fee Free Allowance Overflow Causes DoS Due to Missing Sum Validation

## Summary
The MultiToken contract's transaction fee free allowance system allows parliament to configure multiple threshold symbols that grant allowances for the same token. When calculating total allowances, the system sums these values using checked arithmetic without validating that the cumulative sum stays within `long.MaxValue` bounds. If the sum exceeds `long.MaxValue`, an `OverflowException` is thrown during transaction fee charging, causing a denial-of-service for affected users.

## Finding Description

The transaction fee system stores threshold-based free allowance configurations in state [1](#0-0) , where each threshold symbol can grant free allowances for multiple fee tokens.

When a user qualifies for multiple threshold symbols (by holding sufficient balances in each), the system calculates their total available allowances by summing across all qualified thresholds [2](#0-1) . The summation uses the `.Add()` extension method, which implements checked arithmetic that throws `OverflowException` when the result exceeds type bounds [3](#0-2) .

Parliament configures these allowances via `ConfigTransactionFeeFreeAllowances` [4](#0-3) . The validation only checks that individual allowance amounts are non-negative (line 1241), but **does not validate that the sum of allowances across all threshold symbols for any given token stays within `long.MaxValue`** (9,223,372,036,854,775,807).

The `GetFreeFeeAllowanceAmount` method is called during transaction fee charging through multiple code paths, including base fee calculation [5](#0-4)  and size fee calculation [6](#0-5) . When overflow occurs, the exception propagates through the call stack, causing the entire transaction fee charging operation to fail.

Test evidence confirms that multiple threshold symbols granting allowances for the same token is a supported design pattern [7](#0-6) , where both ELF and USDT thresholds grant allowances for the same NativeTokenSymbol.

## Impact Explanation

Users who hold sufficient balances to qualify for multiple threshold symbols, where the cumulative allowances for any fee token exceed `long.MaxValue`, experience complete denial-of-service. Every transaction they attempt to submit will fail during the pre-execution fee charging phase with an `OverflowException`.

This is classified as **Medium severity** because:
- **No fund loss**: Users' token balances remain intact
- **Operational disruption**: Affected users cannot perform any on-chain transactions
- **Governance-dependent**: Requires parliament misconfiguration rather than a direct exploit
- **Reversible**: Parliament can reconfigure allowances to fix the issue
- **Limited scope**: Only affects users qualifying for multiple high-value thresholds

However, for the affected users, the impact is severe as they are completely locked out from all contract interactions until parliament reconfigures the allowances.

## Likelihood Explanation

**Preconditions:**
- Parliament must configure multiple threshold symbols
- The cumulative allowances for at least one fee token must exceed `long.MaxValue`
- A user must hold sufficient balances to qualify for multiple thresholds

**Feasibility Assessment:**

With tokens using 8 decimals, `long.MaxValue` represents approximately 92.2 billion tokens. Realistic scenarios that could trigger this:

1. **Scenario 1**: Parliament configures 10 threshold symbols, each granting 10 billion tokens allowance for ELF fees → Total: 100 billion > 92.2 billion
2. **Scenario 2**: Parliament configures 100 threshold symbols, each granting 1 billion tokens → Total: 100 billion > 92.2 billion

While parliament is a trusted governance body, configuration errors are realistic:
- Human error when setting allowance values
- Thinking in "human-readable" amounts without considering decimal precision
- Lack of warnings or validation when configuring
- No tooling to preview cumulative effects across thresholds

The test suite demonstrates that multiple thresholds for the same token is an intended feature, making this scenario architecturally supported but mathematically unsafe.

**Probability: Low-Medium** - Requires specific configuration mistakes, but the system provides no safeguards to prevent this.

## Recommendation

Add validation in `ConfigTransactionFeeFreeAllowances` to ensure the cumulative sum of allowances for each fee token across all configured threshold symbols does not exceed `long.MaxValue`:

```csharp
public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
{
    AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
    Assert(input.Value != null && input.Value.Count > 0, "Invalid input");

    // ... existing code ...

    // NEW VALIDATION: Check cumulative allowances per symbol
    var cumulativeAllowances = new Dictionary<string, long>();
    
    // Include existing configurations
    var existingSymbols = State.TransactionFeeFreeAllowancesSymbolList.Value?.Symbols ?? new RepeatedField<string>();
    foreach (var symbol in existingSymbols)
    {
        var config = State.TransactionFeeFreeAllowancesConfigMap[symbol];
        if (config?.FreeAllowances?.Map != null)
        {
            foreach (var (feeSymbol, allowance) in config.FreeAllowances.Map)
            {
                if (!cumulativeAllowances.ContainsKey(feeSymbol))
                    cumulativeAllowances[feeSymbol] = 0;
                cumulativeAllowances[feeSymbol] = cumulativeAllowances[feeSymbol].Add(allowance.Amount);
            }
        }
    }
    
    // Add new configurations
    foreach (var allowances in input.Value!)
    {
        if (allowances.TransactionFeeFreeAllowances?.Value != null)
        {
            foreach (var allowance in allowances.TransactionFeeFreeAllowances.Value)
            {
                if (!cumulativeAllowances.ContainsKey(allowance.Symbol))
                    cumulativeAllowances[allowance.Symbol] = 0;
                    
                // Check before adding
                Assert(cumulativeAllowances[allowance.Symbol] <= long.MaxValue - allowance.Amount,
                    $"Cumulative allowance for {allowance.Symbol} would exceed long.MaxValue");
                    
                cumulativeAllowances[allowance.Symbol] = cumulativeAllowances[allowance.Symbol].Add(allowance.Amount);
            }
        }
    }

    // ... rest of existing code ...
}
```

Alternatively, consider using unchecked arithmetic with saturation (clamping to `long.MaxValue`) instead of throwing exceptions, though validation is the safer approach.

## Proof of Concept

```csharp
[Fact]
public async Task TransactionFeeAllowanceOverflow_CausesDoS_Test()
{
    await SetPrimaryTokenSymbolAsync();
    await CreateTokenAsync(DefaultSender, "USDT");
    
    // Issue large balances to qualify for both thresholds
    await IssueTokenToDefaultSenderAsync(NativeTokenSymbol, 1_00000000);
    await IssueTokenToDefaultSenderAsync("USDT", 1_00000000);
    
    // Configure two thresholds, each granting 5×10^18 allowance for ELF fees
    // Total: 10×10^18 > long.MaxValue (9.22×10^18)
    const long hugeAllowance = 5_000_000_000_000_000_000L; // 5×10^18
    
    await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
        new ConfigTransactionFeeFreeAllowancesInput
        {
            Value =
            {
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = NativeTokenSymbol,
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value =
                        {
                            new TransactionFeeFreeAllowance
                            {
                                Symbol = NativeTokenSymbol,
                                Amount = hugeAllowance
                            }
                        }
                    },
                    RefreshSeconds = 600,
                    Threshold = 1_00000000
                },
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = "USDT",
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value =
                        {
                            new TransactionFeeFreeAllowance
                            {
                                Symbol = NativeTokenSymbol,
                                Amount = hugeAllowance
                            }
                        }
                    },
                    RefreshSeconds = 600,
                    Threshold = 1_00000000
                }
            }
        });
    
    // Set method fee
    var methodFee = new MethodFees
    {
        MethodName = nameof(TokenContractContainer.TokenContractStub.Transfer),
        Fees =
        {
            new MethodFee
            {
                Symbol = NativeTokenSymbol,
                BasicFee = 100
            }
        }
    };
    await TokenContractImplStub.SetMethodFee.SendAsync(methodFee);
    
    // Attempt to charge transaction fees - this will throw OverflowException
    var chargeInput = new ChargeTransactionFeesInput
    {
        MethodName = nameof(TokenContractContainer.TokenContractStub.Transfer),
        ContractAddress = TokenContractAddress
    };
    
    // This should throw OverflowException during GetFreeFeeAllowanceAmount summation
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await TokenContractStub.ChargeTransactionFees.SendAsync(chargeInput);
    });
    
    exception.Message.ShouldContain("Overflow");
}
```

**Notes:**
- This vulnerability requires parliament misconfiguration rather than a malicious attack, placing it in the governance risk category
- The use of checked arithmetic is correct for preventing silent overflow, but the missing validation at configuration time creates a DoS vector
- The issue demonstrates the importance of validating cumulative effects in multi-threshold systems, not just individual values
- Parliament can fix affected users by reconfiguring allowances, but users are blocked until this occurs

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L50-50)
```csharp
    public MappedState<string, TransactionFeeFreeAllowanceConfig> TransactionFeeFreeAllowancesConfigMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L457-459)
```csharp
            ? GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbolToPayTxFee)
                .Sub(amountChargedForBaseAllowance)
            : GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbolToPayTxFee);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L728-728)
```csharp
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1224-1266)
```csharp
    public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Value != null && input.Value.Count > 0, "Invalid input");

        State.TransactionFeeFreeAllowancesSymbolList.Value ??= new TransactionFeeFreeAllowancesSymbolList
        {
            Symbols = { new RepeatedField<string>() }
        };

        foreach (var allowances in input.Value!)
        {
            ValidateToken(allowances.Symbol);
            Assert(
                allowances.TransactionFeeFreeAllowances?.Value != null &&
                allowances.TransactionFeeFreeAllowances.Value.Count > 0,
                "Invalid input allowances");
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");

            var config = new TransactionFeeFreeAllowanceConfig
            {
                Symbol = allowances.Symbol,
                Threshold = allowances.Threshold,
                RefreshSeconds = allowances.RefreshSeconds,
                FreeAllowances = new TransactionFeeFreeAllowanceMap()
            };

            foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
            {
                config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
            }

            State.TransactionFeeFreeAllowancesConfigMap[allowances.Symbol] = config;

            if (!State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Contains(allowances.Symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Add(allowances.Symbol);
            }
        }

        return new Empty();
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest_FreeAllowance.cs (L574-614)
```csharp
        await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = NativeTokenSymbol,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = freeAmountELF
                                }
                            }
                        },
                        RefreshSeconds = refreshSecondsELF,
                        Threshold = thresholdELF
                    },
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = USDT,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = freeAmountUSDT
                                }
                            }
                        },
                        RefreshSeconds = refreshSecondsUSDT,
                        Threshold = thresholdUSDT
                    }
                }
            });
```
