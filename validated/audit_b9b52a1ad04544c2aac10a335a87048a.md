# Audit Report

## Title
Side Chain Miner List Synchronization Delay Creates Conflict of Interest Allowing Replaced Miners to Maintain Control

## Summary
Side chains rely on governance-controlled cross-chain indexing to update their miner lists from the main chain. However, the current side chain miners (who are being replaced) control every step of this update process through Parliament governance, creating a conflict of interest where miners can block their own replacement indefinitely.

## Finding Description

Side chains always use NextRound consensus behavior and never transition terms independently. [1](#0-0)  

When generating the next round, side chains check if the main chain miner list has changed and only update when `State.MainChainCurrentMinerList` differs from the current miners. [2](#0-1) 

The `State.MainChainCurrentMinerList` value is only updated when the CrossChain contract calls `UpdateInformationFromCrossChain`, which can only be invoked by the CrossChain contract itself. [3](#0-2) [4](#0-3) 

However, the cross-chain indexing process has multiple governance gates controlled by current side chain miners:

1. **Proposing requires current miner permission**: [5](#0-4) 

2. **Proposal must be approved by Parliament organization**: The proposal goes through Parliament governance where current miners are the members. [6](#0-5) [7](#0-6) 

3. **Releasing requires current miner permission**: [8](#0-7) 

4. **Approval threshold is 66.67%**: [9](#0-8) [10](#0-9) 

5. **Proposals expire after 120 seconds**: [11](#0-10) 

The critical flaw is that "current miner" checks use the side chain's own consensus state, not the main chain's. [12](#0-11)  This means the OLD miners (who were replaced on the main chain) remain as current miners on the side chain and control the entire governance process for their own replacement.

## Impact Explanation

**Consensus Integrity Violation**: The fundamental design assumption is that main chain and side chains share the same consensus participants. This synchronization dependency breaks that invariant, allowing side chains to operate with miners who are no longer authorized on the main chain.

**Conflict of Interest**: Miners replaced on the main chain (potentially for malicious behavior or poor performance) must approve their own removal from the side chain. They control:
- Whether to propose indexing (100% gatekeeper control)
- Parliament voting (initially 100% of voting power)
- Whether to release approved proposals (100% gatekeeper control)
- Continuing to earn side chain rewards during any delay

**No Forcing Mechanism**: There is no automatic update mechanism, time-based trigger, or escalation path. The entire process depends on cooperation from the miners being replaced.

**Indefinite Control**: Old miners can block updates by:
- Not calling `ProposeCrossChainIndexing`
- Voting against proposals (only 33.34% needed to block the 66.67% threshold)
- Not calling `ReleaseCrossChainIndexingProposal`
- Repeatedly letting proposals expire

## Likelihood Explanation

**Automatic Trigger**: This situation occurs automatically on every main chain term transition when miners change. No special attacker setup is required.

**High Frequency**: Main chain term changes happen regularly (every few days based on election periods), making this a recurring issue.

**Strong Incentives**: Old miners have financial incentive to delay (continue earning rewards) and operational incentive to maintain control, especially if they were replaced for malicious behavior.

**No Technical Barriers**: The attack requires no sophisticated capabilitiesâ€”simply not cooperating with the governance process or coordinating with 33.34% of old miners to block approval.

## Recommendation

Implement a forcing mechanism for side chain miner updates:

1. **Time-based auto-approval**: Allow proposals to auto-execute after a reasonable delay (e.g., 24 hours) if not actively rejected
2. **Main chain enforcement**: Add a mechanism for the main chain to force-update side chain miner lists after a grace period
3. **Emergency governance path**: Create an alternative approval path using main chain miners or a dedicated cross-chain governance body
4. **Consensus validation**: Add checks to reject blocks from unauthorized miners based on main chain state

The core issue is that the "current miners" used for authorization should reflect the main chain's authoritative miner set, not the side chain's potentially stale state.

## Proof of Concept

```csharp
// Scenario: Main chain transitions to new term with Miners [A, B, C]
// Side chain still has old miners [X, Y, Z]

// Step 1: Old miner X tries to propose cross-chain indexing (succeeds)
// AssertAddressIsCurrentMiner(X) passes because X is still in side chain's current round

// Step 2: Parliament vote requires 66.67% approval
// Parliament members = GetCurrentMinerList() = [X, Y, Z] (old miners)
// Old miners X, Y, Z can vote to reject or simply not vote

// Step 3: Even if approved, release requires current miner
// Old miner must call ReleaseCrossChainIndexingProposal

// Step 4: If no one cooperates, proposal expires after 120 seconds
// State.MainChainCurrentMinerList is never updated
// Side chain continues with old miners [X, Y, Z] indefinitely

// Attack vector: Old miners simply don't call ProposeCrossChainIndexing
// or coordinate 34% to vote against approval
// Result: Side chain operates with unauthorized miners permanently
```

## Notes

This vulnerability represents a fundamental architectural flaw in the cross-chain consensus synchronization design. The assumption that miners will cooperate in their own replacement is violated when those miners have been replaced for malicious behavior or poor performance. The lack of any forcing mechanism converts what should be a temporary synchronization delay into a potential indefinite divergence between main chain and side chain consensus participants.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-133)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-38)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L55-61)
```csharp
        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-19)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L390-418)
```csharp
    private void ProposeCrossChainBlockData(CrossChainDataDto crossChainDataDto, Address proposer)
    {
        var crossChainIndexingController = GetCrossChainIndexingController();
        foreach (var chainId in crossChainDataDto.GetChainIdList())
        {
            Assert(!TryGetIndexingProposal(chainId, out _), "Chain indexing already proposed.");
            var proposalToken =
                HashHelper.ConcatAndCompute(Context.PreviousBlockHash, ConvertChainIdToHash(chainId));
            var proposalCreationInput = new CreateProposalBySystemContractInput
            {
                ProposalInput = new CreateProposalInput
                {
                    Params = new AcceptCrossChainIndexingProposalInput
                    {
                        ChainId = chainId
                    }.ToByteString(),
                    ContractMethodName = nameof(AcceptCrossChainIndexingProposal),
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(CrossChainIndexingProposalExpirationTimePeriod),
                    OrganizationAddress = crossChainIndexingController.OwnerAddress,
                    ToAddress = Context.Self,
                    Token = proposalToken
                },
                OriginProposer = Context.Sender
            };

            Context.SendInline(crossChainIndexingController.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                    .CreateProposalBySystemContract), proposalCreationInput);
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-5)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Constants.cs (L5-5)
```csharp
    private const int CrossChainIndexingProposalExpirationTimePeriod = 120;
```
