# Audit Report

## Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
When a manager calls `CreateScheme` multiple times with different token symbols, the new scheme overwrites the previous one, but existing user lock records persist with the old scheme's token symbol. Users cannot withdraw their locked tokens because the `Withdraw` function queries locked amounts using the new scheme's symbol with the old lock ID, returning zero balance and leaving original tokens permanently locked.

## Finding Description

The TokenHolder contract allows managers to create profit schemes by calling `CreateScheme`, which stores scheme metadata including the token symbol without any validation to prevent multiple calls by the same manager. [1](#0-0) 

The scheme data is stored at `State.TokenHolderProfitSchemes[Context.Sender]` and can be overwritten when `CreateScheme` is called again.

When users register for profits via `RegisterForProfits`, their tokens are locked using the scheme's current symbol, and a deterministic lock ID is generated based solely on the manager and user addresses (not the symbol). [2](#0-1) 

The MultiToken contract's `Lock` method transfers tokens to a virtual address computed from Context.Sender, the user address, and the lock ID. [3](#0-2) 

Critically, the virtual address computation does NOT depend on the token symbol. [4](#0-3) 

When the manager later calls `CreateScheme` again with a different symbol, it overwrites the scheme metadata but leaves the lock ID mappings intact. When users attempt to withdraw via the `Withdraw` method, it retrieves the NEW scheme with the NEW symbol. [5](#0-4) 

The critical flaw occurs in `GetLockedAmount`, which queries the token balance at the virtual address for the specified symbol. [6](#0-5) 

Since the tokens were locked with the OLD symbol but the query uses the NEW symbol, it returns zero even though the original tokens remain at the virtual address. The `Unlock` operation then proceeds with zero amount, and the lock ID mapping is removed, leaving the original tokens permanently locked with no recovery mechanism.

## Impact Explanation

This vulnerability results in HIGH severity impact because:

1. **Permanent Fund Loss**: Users lose access to all their locked tokens with no recovery mechanism. Once `Withdraw` executes, it removes the lock ID mapping, preventing any future withdrawal attempts or re-registration.

2. **Wide Scope**: All users who registered under the original scheme are affected simultaneously when the manager overwrites it. For staking schemes, this can involve substantial amounts per user.

3. **No Administrative Recovery**: The tokens remain locked at a virtual address computed from the lock ID, but with the wrong symbol mapping. There is no admin function to recover these funds, and the lock ID mapping has been deleted.

4. **User Helplessness**: Users have no way to detect this issue before attempting withdrawal, and cannot prevent the manager from overwriting the scheme after they've already locked their tokens.

## Likelihood Explanation

This vulnerability has HIGH likelihood because:

1. **Public Accessibility**: The `CreateScheme` method is publicly accessible to any address without special privileges or validation checks.

2. **Simple Trigger Path**: Exploitation requires only two standard contract calls by the manager - no complex state manipulation or timing requirements.

3. **Realistic Scenarios**:
   - **Accidental**: A manager may legitimately want to "update" scheme parameters and call `CreateScheme` again, unaware it will lock user funds
   - **Malicious**: A manager can intentionally trap user funds by changing the symbol after users have registered

4. **No Validation**: There are no checks preventing duplicate `CreateScheme` calls or validating symbol consistency during withdrawal.

## Recommendation

Add validation in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager.");
    
    // ... rest of the implementation
}
```

Alternatively, validate symbol consistency in `Withdraw` before calling `GetLockedAmount`, or include the symbol in the lock ID generation to prevent symbol mismatches.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwritingCausesTokenLock_Test()
{
    // Manager creates initial scheme with ELF token
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // Fund contribution to initialize scheme
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 1
    });
    
    // User registers and locks 1000 ELF tokens
    var userStub = GetTokenHolderContractTester(UserKeyPairs.First());
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000_00000000
    });
    
    var userAddress = UserAddresses.First();
    var balanceBeforeLock = (await GetTokenContractTester(UserKeyPairs.First()).GetBalance.CallAsync(
        new GetBalanceInput { Owner = userAddress, Symbol = "ELF" })).Balance;
    
    // Manager overwrites scheme with different symbol (APP instead of ELF)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "APP",  // Different symbol!
        MinimumLockMinutes = 1
    });
    
    // User attempts to withdraw after minimum lock time
    await userStub.Withdraw.SendAsync(Starter);
    
    // User's ELF balance unchanged - tokens remain locked
    var balanceAfterWithdraw = (await GetTokenContractTester(UserKeyPairs.First()).GetBalance.CallAsync(
        new GetBalanceInput { Owner = userAddress, Symbol = "ELF" })).Balance;
    
    balanceAfterWithdraw.ShouldBe(balanceBeforeLock); // Tokens NOT returned
    
    // Lock ID mapping deleted - user cannot withdraw again
    var lockId = await userStub.GetLockId.CallAsync(new GetLockIdInput 
    { 
        SchemeManager = Starter,
        Beneficiary = userAddress 
    });
    lockId.ShouldBeNull(); // Lock ID removed, tokens permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-209)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L118-124)
```csharp
    public override Address GetVirtualAddressForLocking(GetVirtualAddressForLockingInput input)
    {
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        return virtualAddress;
    }
```
