# Audit Report

## Title
TokenHolder Lock-Beneficiary State Desynchronization Allows Capital Lockup Without Profit Accrual

## Summary
The `RemoveBeneficiary` function in TokenHolderContract can remove a user's beneficiary status from the profit scheme without unlocking their tokens, creating a state where users' capital remains locked but earns no profits. This violates the core TokenHolder contract invariant that locked tokens should always earn proportional profit shares.

## Finding Description

When a user calls `RegisterForProfits`, three state changes occur atomically: tokens are locked via TokenContract, a lockId mapping is stored, and the user is added as a beneficiary to the profit scheme. [1](#0-0) 

However, when the scheme manager calls `RemoveBeneficiary`, only the beneficiary status is removed from the Profit contract. [2](#0-1) 

The function does NOT:
- Unlock the tokens from the Token contract
- Remove the `State.LockIds` mapping  
- Clear the `State.LockTimestamp` entry

This creates a desynchronization where the beneficiary status is removed but the token lock state remains unchanged. Users cannot withdraw until the minimum lock period expires, as enforced by the check in the `Withdraw` function. [3](#0-2) 

The scheme is created with `CanRemoveBeneficiaryDirectly = true`, explicitly allowing immediate beneficiary removal by the manager. [4](#0-3) 

In the Profit contract, when a beneficiary has already been removed, subsequent calls to `RemoveBeneficiary` return gracefully without error, allowing the `Withdraw` function to succeed even after premature beneficiary removal. [5](#0-4) 

The design clearly shows atomic coupling: `RegisterForProfits` couples locking with beneficiary addition, and `Withdraw` couples unlocking with beneficiary removal. [6](#0-5) 

However, `RemoveBeneficiary` breaks this coupling by only affecting beneficiary status without synchronizing the token lock state.

## Impact Explanation

**Direct Financial Impact:**
- Users lose expected profit distributions during the remaining lock period. For example, if a scheme distributes 10% APY and tokens remain locked for 30 days after `RemoveBeneficiary` is called, users lose approximately 0.83% of their locked capital value in missed profits.
- Opportunity cost: Users cannot deploy their capital elsewhere (staking, liquidity provision, trading) during the forced lock period without profit accrual.

**Operational Impact:**
- Violates the fundamental TokenHolder contract invariant that locked tokens should always earn profit shares proportional to their locked amount.
- Undermines user trust in the staking mechanism as capital can be locked without compensation.

**Who is Affected:**
- Any user who has called `RegisterForProfits` and can be arbitrarily removed by the scheme manager before their minimum lock period expires.
- Impact is particularly severe for schemes with long `MinimumLockMinutes` values as defined in the scheme configuration. [7](#0-6) 

## Likelihood Explanation

**Attacker Capabilities:**
- Requires scheme manager privileges, which is a realistic role as all TokenHolder profit schemes have managers by design.
- Single function call execution with no additional preconditions or complex setup required.

**Attack Complexity:**
- Trivial: One transaction calling `RemoveBeneficiary(beneficiary=victim, amount=0)` as documented in the protobuf definition. [8](#0-7) 
- Can be executed against any registered user at any time.

**Feasibility Conditions:**
- Scheme must exist (normal operation)
- User must be registered via `RegisterForProfits` (normal operation)  
- Caller must be the scheme manager (by design, enforced by `GetValidScheme(Context.Sender)`)

**Probability Assessment:**
- Malicious scenario: Scheme manager can directly execute this attack with immediate effect.
- Accidental scenario: Scheme managers may not realize that calling `RemoveBeneficiary` on users who registered via `RegisterForProfits` leaves their tokens locked.
- Either scenario results in the same harmful outcome for users.

This is a high-probability vulnerability given the low barriers to exploitation and realistic attacker model (scheme managers are not listed as trusted roles in the threat model).

## Recommendation

Modify the `RemoveBeneficiary` function to detect when a beneficiary has locked tokens via `RegisterForProfits` and automatically unlock those tokens. The fix should:

1. Check if `State.LockIds[input.SchemeManager][input.Beneficiary]` exists
2. If it exists, call `State.TokenContract.Unlock` to unlock the tokens
3. Remove the `State.LockIds` mapping
4. Clear the `State.LockTimestamp` entry
5. Then proceed with removing the beneficiary from the profit scheme

Alternatively, add a check that prevents calling `RemoveBeneficiary` on users who have locked tokens via `RegisterForProfits`, requiring those users to call `Withdraw` themselves after the minimum lock period.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_Leaves_Tokens_Locked_Test()
{
    var lockAmount = 1000L;
    var minimumLockMinutes = 30; // 30 minutes lock
    
    // Create scheme with minimum lock period
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = minimumLockMinutes
    });
    
    // User registers for profits (locks tokens + becomes beneficiary)
    await UserTokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });
    
    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = User,
        Symbol = "ELF",
        LockId = /* lockId from State.LockIds[Starter][User] */
    });
    lockedAmount.Amount.ShouldBe(lockAmount);
    
    // Verify user is beneficiary
    var schemeId = (await TokenHolderContractStub.GetScheme.CallAsync(Starter)).SchemeId;
    var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = User
    });
    profitDetail.Details.Count.ShouldBe(1);
    
    // Manager removes beneficiary (amount=0 means full removal)
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = User,
        Amount = 0
    });
    
    // VULNERABILITY: User is no longer beneficiary but tokens remain locked
    var profitDetailAfter = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = User
    });
    profitDetailAfter.Details.Count.ShouldBe(0); // Beneficiary removed
    
    var lockedAmountAfter = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = User,
        Symbol = "ELF",
        LockId = /* lockId */
    });
    lockedAmountAfter.Amount.ShouldBe(lockAmount); // STILL LOCKED!
    
    // User cannot withdraw until minimum lock period expires
    // During this time, user's capital is locked but earning NO profits
}
```

## Notes

The vulnerability specifically affects users who registered via `RegisterForProfits` (which locks their tokens). It does not affect beneficiaries added by the manager via `AddBeneficiary` (which doesn't lock tokens). The root cause is that `RemoveBeneficiary` was designed for the latter case but is also callable on the former case, creating the desynchronization issue.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-24)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-97)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-176)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L230-243)
```csharp
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** protobuf/token_holder_contract.proto (L27-29)
```text
    // Removes a beneficiary from a scheme.
    // Note: amount > 0: update the weight of the beneficiary, amount = 0: remove the beneficiary.
    rpc RemoveBeneficiary (RemoveTokenHolderBeneficiaryInput) returns (google.protobuf.Empty) {
```

**File:** protobuf/token_holder_contract.proto (L66-67)
```text
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
```
