# Audit Report

## Title
NextTerm Miner List Injection - Arbitrary Consensus Takeover via Unvalidated RealTimeMinersInformation Keys

## Summary
The AEDPoS consensus contract's `ProcessNextTerm` function accepts miner public keys directly from `NextTermInput.RealTimeMinersInformation` without validating them against the Election Contract's authoritative `GetVictories` result. A malicious current-term miner can inject arbitrary miner keys during NextTerm block production, completely bypassing the election system and permanently taking over consensus.

## Finding Description

The vulnerability exists in the consensus term transition validation architecture, where miner list integrity is assumed but never verified.

**Vulnerable Execution Flow:**

The `NextTerm` method calls `ProcessConsensusInformation`, which routes to `ProcessNextTerm`: [1](#0-0) 

In `ProcessNextTerm`, the input is converted to a Round object via `ToRound()`, which blindly copies the `RealTimeMinersInformation` dictionary without validation: [2](#0-1) [3](#0-2) 

The function then extracts miner public keys directly from this unvalidated data: [4](#0-3) 

The `SetMinerList` function only checks whether the miner list was previously set, performing NO validation of key authenticity or correspondence with Election Contract results: [5](#0-4) 

**Missing Pre-Execution Validation:**

Pre-execution validation for NextTerm behavior only adds `RoundTerminateValidationProvider`: [6](#0-5) 

This provider only validates term/round number increments, completely omitting miner list validation: [7](#0-6) 

**Circular Post-Execution Validation:**

Post-execution validation compares the header round hash against current state, but this is circular validation since the state was just updated FROM the header data during execution: [8](#0-7) 

The validation retrieves `currentRound` from state (which was just set by `ProcessNextTerm` via `AddRoundInformation`), then compares it against the header - they match by design, making this validation meaningless for detecting malicious miner lists.

**Correct Design Intent (Bypassed):**

The system correctly retrieves legitimate election winners via `TryToGetVictories` during honest consensus extra data GENERATION: [9](#0-8) 

This calls the Election Contract's `GetVictories`: [10](#0-9) 

However, this validation occurs ONLY during data generation by honest block producers, NOT during validation or execution by all nodes. A malicious miner can modify their node to bypass this check.

**Access Control (Insufficient):**

The only access control is that the sender must be in the current/previous round miner list: [11](#0-10) 

This allows any current miner to produce a NextTerm block, but doesn't validate the content of that block.

## Impact Explanation

**Critical Consensus Integrity Breach:**

This vulnerability enables complete takeover of the AElf consensus mechanism:

- **Permanent Control**: The attacker installs themselves and accomplices as the exclusive miner set. Once in control, they can perpetually re-elect themselves in every subsequent term transition, maintaining permanent control.

- **Election System Bypass**: All token holder votes become meaningless. Legitimate election winners determined by `GetVictories` are permanently excluded from consensus participation.

- **Network Security Collapse**: The entire delegated proof-of-stake security model is compromised. The network's security assumption that miners are elected by stake-weighted voting is violated.

**Cascading Attack Vectors:**

Once controlling consensus, the attacker can:
- **Transaction Censorship**: Block specific transactions or entire addresses from being included in blocks
- **Treasury Manipulation**: Control the timing and execution of treasury releases tied to term numbers
- **Governance Attacks**: Manipulate proposal execution timing to bypass time-lock safeguards
- **Chain Reorganization**: With majority miner control, perform reorg attacks for double-spending
- **Cross-Chain Exploits**: Manipulate cross-chain merkle root reporting and indexing heights

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current-term miner (~17 miners on mainchain, any one can attack)
- Ability to modify their own node software (standard operational capability)
- Wait for their designated NextTerm block production time slot

**Attack Complexity: LOW**
- Single modification to bypass `TryToGetVictories` check or directly craft malicious `NextTermInput`
- No cryptographic attacks, timing races, or complex state manipulation required
- Single malicious block achieves permanent compromise

**Opportunity Windows:**
- Term transitions occur every 604,800 seconds (~7 days) on mainchain
- Multiple miners can attempt the attack during their NextTerm slots
- Dozens of opportunities per year

**Detection Limitations:**
- No pre-execution validation checks miner list against Election Contract
- Post-execution validation is circular (header vs. state updated from header)
- Off-chain monitoring could detect the mismatch, but malicious state is already committed to consensus and accepted by all nodes

**Probability Assessment: HIGH**

The combination of low technical barriers (simple node modification), regular opportunity windows (weekly term transitions), multiple potential attackers (any current miner), and catastrophic impact makes this a high-probability critical threat.

## Recommendation

Implement mandatory Election Contract cross-validation during pre-execution validation for NextTerm blocks:

```csharp
// In ValidateBeforeExecution, for NextTerm case:
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    // ADD THIS NEW VALIDATOR:
    validationProviders.Add(new MinerListElectionValidationProvider());
    break;
```

Create `MinerListElectionValidationProvider` that:
1. Extracts the proposed miner list from `extraData.Round.RealTimeMinersInformation.Keys`
2. Calls `State.ElectionContract.GetVictories.Call(new Empty())` to get authoritative election winners
3. Verifies the proposed list exactly matches the election winners (order-independent set comparison)
4. Returns validation failure if mismatch detected

This ensures every node independently validates that NextTerm blocks contain only legitimately elected miners, closing the validation gap.

## Proof of Concept

A proof of concept would require:
1. Setting up a test network with multiple miners and the Election Contract
2. Modifying one miner's node to inject arbitrary keys in `NextTermInput.RealTimeMinersInformation`
3. Producing a NextTerm block during that miner's time slot
4. Observing that the block is accepted by all nodes despite containing non-elected miners
5. Verifying the malicious miner list is installed in `State.MinerListMap` and used for subsequent consensus

The vulnerability is confirmed by code analysis showing the complete absence of Election Contract validation in the pre-execution, execution, and post-execution paths for NextTerm blocks.

## Notes

This is a fundamental architectural vulnerability in the consensus validation framework. The design assumes honest block generation (where `TryToGetVictories` is called) but fails to enforce this invariant during validation. The post-execution validation's circular comparison (state vs. header when state came from header) represents a critical misunderstanding of validation principles. Any consensus-critical data must be validated against authoritative sources during pre-execution validation, not assumed to be honest or validated circularly post-execution.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-127)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```
