# Audit Report

## Title
Last Irreversible Block Height Calculation Fails When Miner Set Changes Due to Mismatched Consensus Threshold

## Summary
The `LastIrreversibleBlockHeightCalculator` in the AEDPoS consensus contract uses the current round's miner count to calculate the `MinersCountOfConsent` threshold, but collects implied irreversible block heights from the previous round. When the miner set changes significantly between rounds (especially at term transitions), new miners have no entries in the previous round, making it impossible to meet the threshold, causing LIB to fail advancing and blocking cross-chain operations that depend on block finality.

## Finding Description

The vulnerability exists in the LIB (Last Irreversible Block) calculation logic where a logical inconsistency occurs between the data source and the threshold calculation.

The `LastIrreversibleBlockHeightCalculator` is invoked during normal block production in the `ProcessUpdateValue` method [1](#0-0) . The calculator collects miners who have mined in the current round, then attempts to fetch their implied heights from the previous round [2](#0-1) .

The critical flaw is that `MinersCountOfConsent` is calculated as `(count * 2 / 3) + 1` based on the **current round's** miner count [3](#0-2) , but the threshold check compares against data from the **previous round** [4](#0-3) .

The `GetSortedImpliedIrreversibleBlockHeights` method filters miners by public keys that exist in the previous round's `RealTimeMinersInformation` [5](#0-4) . When new miners are elected at term transitions, they won't have entries in the previous round.

**Execution Path:**

1. When a term changes via `NextTerm`, new miners are elected through the Election contract and can differ completely from previous miners [6](#0-5) 

2. The first round of the new term is generated with the new miner set and `IsMinerListJustChanged = true` [7](#0-6) 

3. During block production, miners call `UpdateValue` which updates their `ImpliedIrreversibleBlockHeight` in the **current round** [8](#0-7) 

4. The LIB calculator is invoked, collecting miners who have mined and looking up their implied heights from the **previous round** [9](#0-8) 

**Why Protections Fail:**

The `IsMinerListJustChanged` flag is set during term transitions [10](#0-9) , but this flag is **not checked** in the `LastIrreversibleBlockHeightCalculator`. The calculator blindly applies the current round's threshold to previous round's data without accounting for miner set changes.

**Concrete Example:**
- Previous round (Term N): 5 miners {A, B, C, D, E}, MinersCountOfConsent = 4
- New round (Term N+1): 7 miners {A, B, C, F, G, H, I}, MinersCountOfConsent = 5  
- When calculating LIB: Only miners A, B, C can contribute implied heights from previous round (max 3)
- Check: 3 < 5 fails, so `libHeight = 0`
- LIB cannot advance because the threshold of 5 can never be met with only 3 continuing miners

## Impact Explanation

**Consensus/Cross-Chain Integrity Impact:**
- LIB fails to advance for the entire round following a miner set change, violating the core consensus invariant that LIB must progress with block production
- Cross-chain operations that depend on irreversible block confirmation are blocked [11](#0-10) 
- Transaction finality guarantees are delayed until the next round when all miners have entries in the previous round
- The `IrreversibleBlockFound` event is not fired when LIB calculation returns 0, preventing downstream systems from confirming finality

**Operational Impact:**
- Denial of Service on cross-chain indexing and verification flows that wait for LIB advancement
- If miner set changes are frequent (through term changes or evil miner replacement), LIB advancement can be significantly degraded over multiple rounds
- Parent/side-chain communication is disrupted during affected rounds, breaking the cross-chain architecture

**Severity Justification:**
This is a **HIGH** severity issue because:
1. It breaks the fundamental consensus invariant that LIB must continuously advance with block production
2. Cross-chain operations are core functionality in AElf's multi-chain architecture, and their blocking affects the entire network
3. The issue occurs naturally without attacker intervention at every term change with significant miner turnover
4. The election system allows complete miner set replacement through voting, making worst-case scenarios achievable in normal operation

## Likelihood Explanation

**Feasible Preconditions:**
- Occurs naturally at term transitions when elected miners change through the election contract [12](#0-11) 
- No special attacker capabilities required - happens during normal consensus operations
- Election contract allows arbitrary miner set changes based on vote weights from token holders

**Execution Practicality:**
- Happens automatically during normal consensus operations at term boundaries
- Term changes occur periodically (every term period as defined in the protocol)
- The first round generation with new miners sets `IsMinerListJustChanged` flag but no special handling exists in LIB calculation [13](#0-12) 

**Probability Assessment:**
- Guaranteed to occur when: `(new_miners - overlap_miners) > (old_miners / 3)` 
- With election-based miner selection, significant turnover is expected during competitive elections
- Higher probability when miner count increases between terms (e.g., 5 to 7 miners with only 3 overlapping)
- No detection or mitigation mechanisms exist in the codebase to handle this scenario

## Recommendation

Modify the `LastIrreversibleBlockHeightCalculator` to check the `IsMinerListJustChanged` flag and use an adjusted threshold when the miner set has changed. The threshold should be calculated based on the intersection of miners between rounds rather than the current round's full miner count.

**Recommended Fix:**

```csharp
public void Deconstruct(out long libHeight)
{
    if (_currentRound.IsEmpty || _previousRound.IsEmpty) 
    {
        libHeight = 0;
        return;
    }

    var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
    
    // Use intersection-based threshold when miner list just changed
    var requiredConsent = _currentRound.IsMinerListJustChanged 
        ? (impliedIrreversibleHeights.Count * 2 / 3) + 1  // Based on overlap miners
        : _currentRound.MinersCountOfConsent;              // Based on current round
    
    if (impliedIrreversibleHeights.Count < requiredConsent)
    {
        libHeight = 0;
        return;
    }

    libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
}
```

Alternatively, preserve the LIB from the previous term explicitly and skip LIB advancement for the first round after miner set changes, allowing it to resume in subsequent rounds.

## Proof of Concept

The following test demonstrates the vulnerability when miner set changes at term transition:

```csharp
[Fact]
public async Task LIB_Fails_To_Advance_After_Miner_Set_Change()
{
    // Setup: Initialize with 5 miners in term 1
    await InitializeCandidates(5);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // All 5 miners mine blocks in round 1
    foreach (var minerInRound in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        var keyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == minerInRound.Pubkey);
        KeyPairProvider.SetKeyPair(keyPair);
        BlockTimeProvider.SetBlockTime(minerInRound.ExpectedMiningTime);
        
        var tester = GetAEDPoSContractStub(keyPair);
        var randomNumber = await GenerateRandomProofAsync(keyPair);
        var toUpdate = firstRound.ExtractInformationToUpdateConsensus(minerInRound.Pubkey, ByteString.CopyFrom(randomNumber));
        await tester.UpdateValue.SendAsync(toUpdate);
    }
    
    // Record LIB from round 1
    var libBeforeTermChange = (await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty()))
        .ConfirmedIrreversibleBlockHeight;
    libBeforeTermChange.ShouldBeGreaterThan(0);
    
    // Change to term 2 with 7 miners (only 3 overlap with term 1)
    await VoteForNewMiners(7); // Elect 7 miners: {A, B, C, F, G, H, I}
    BlockTimeProvider.SetBlockTime(GetTermChangeTime());
    var nextTermInput = await GetNextTermInput();
    await AEDPoSContractStub.NextTerm.SendAsync(nextTermInput);
    
    var secondTermRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    secondTermRound.IsMinerListJustChanged.ShouldBeTrue();
    secondTermRound.RealTimeMinersInformation.Count.ShouldBe(7);
    
    // Have 5 new miners mine blocks in term 2, round 1
    foreach (var minerInRound in secondTermRound.RealTimeMinersInformation.Values.Take(5).OrderBy(m => m.Order))
    {
        var keyPair = GetKeyPairForMiner(minerInRound.Pubkey);
        KeyPairProvider.SetKeyPair(keyPair);
        BlockTimeProvider.SetBlockTime(minerInRound.ExpectedMiningTime);
        
        var tester = GetAEDPoSContractStub(keyPair);
        var randomNumber = await GenerateRandomProofAsync(keyPair);
        var toUpdate = secondTermRound.ExtractInformationToUpdateConsensus(minerInRound.Pubkey, ByteString.CopyFrom(randomNumber));
        await tester.UpdateValue.SendAsync(toUpdate);
    }
    
    // Verify: LIB should have advanced but it doesn't
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Bug: LIB remains at previous value because:
    // - MinersCountOfConsent = 7 * 2/3 + 1 = 5
    // - But only 3 miners (A, B, C) have entries in previous round
    // - 3 < 5, so LIB calculation returns 0 and doesn't advance
    currentRound.ConfirmedIrreversibleBlockHeight.ShouldBe(libBeforeTermChange); // LIB stuck at old value
    
    // Expected: LIB should advance based on the 3 overlapping miners' consensus
    // Actual: LIB fails to advance for the entire round
}
```

**Notes**

The vulnerability is confirmed through code analysis of the AEDPoS consensus contract. The mismatch between using the current round's `MinersCountOfConsent` threshold while fetching data from the previous round creates an unavoidable failure scenario when miner sets change significantly. The `IsMinerListJustChanged` flag exists to signal this condition but is not utilized in the LIB calculation logic. This represents a critical design flaw in the consensus finality mechanism that affects cross-chain operations and transaction finality guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-269)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L275-278)
```csharp
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L14-14)
```csharp
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```
