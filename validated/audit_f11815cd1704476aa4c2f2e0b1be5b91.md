# Audit Report

## Title
Hash Input Collision Vulnerability in NFT Token Hash Calculation

## Summary
The `CalculateTokenHash()` function concatenates symbol and tokenId without a delimiter, enabling different (symbol, tokenId) pairs from separate NFT protocols to produce identical hash values. Combined with inadequate cross-chain validation, this allows attackers to cause denial of service or cross-protocol state corruption depending on the `IsTokenIdReuse` configuration.

## Finding Description

The vulnerability exists in the hash calculation mechanism that generates unique identifiers for NFTs. The `CalculateTokenHash` method directly concatenates the symbol string with the tokenId without any delimiter or separator. [1](#0-0) 

NFT protocol symbols follow the format `{2-char-prefix}{numeric-suffix}` where the numeric suffix starts at 9 digits minimum but can vary in length as more protocols are created. [2](#0-1) [3](#0-2) 

The critical vulnerability lies in the cross-chain token creation path. While normal token creation validates symbol length, `CrossChainCreateToken` bypasses this validation by only calling `RegisterTokenInfo`, which performs regex validation but no length checks. [4](#0-3) [5](#0-4) [6](#0-5) 

The NFT `CrossChainCreate` method accepts protocols from other chains with minimal validation, only checking that the first 2 characters match a valid NFT type. [7](#0-6) 

Without a delimiter, different (symbol, tokenId) combinations produce identical hash inputs:
- Protocol A: symbol="AR123456789", tokenId=12 → hash input="AR12345678912"
- Protocol B: symbol="AR1234567891", tokenId=2 → hash input="AR12345678912"

The resulting tokenHash collision causes both protocols to share the same state mappings. When minting, the `PerformMint` method checks for existing NFTs but only at the hash level, not validating protocol ownership. [8](#0-7) 

When `IsTokenIdReuse=false`, the assertion at lines 395-396 blocks legitimate mints from the second protocol. When `IsTokenIdReuse=true`, the code at lines 433-437 updates the existing NFT without verifying it belongs to the same protocol.

The vulnerability affects all state mappings keyed by tokenHash, including `NftInfoMap`, `BalanceMap`, and `AllowanceMap`. [9](#0-8) 

## Impact Explanation

**Scenario 1 - Denial of Service (IsTokenIdReuse=false):**
When a hash collision occurs between two different protocols, the second protocol's mint attempt fails with "Token id already exists" error even though it's a completely different NFT protocol. This permanently blocks that specific (symbol, tokenId) combination in the affected protocol, preventing legitimate NFT creation.

**Scenario 2 - Cross-Protocol State Corruption (IsTokenIdReuse=true):**
The collision causes Protocol B's mint operation to update Protocol A's NFT state:
- Protocol B's minter is added to Protocol A's NFT minters list (line 436)
- Quantity counters are incorrectly aggregated across unrelated protocols (line 435)
- Balance mappings become shared between different protocol NFTs (line 441)
- The NFT's symbol field shows Protocol A's symbol despite having mixed state from both protocols (line 419)

This violates the fundamental invariant that each NFT must have unique, isolated state within its protocol, corrupting the integrity of NFT ownership and metadata tracking.

## Likelihood Explanation

**Attack Vector:** The most feasible attack path is through cross-chain protocol creation:
1. Attacker monitors existing NFT protocols and their tokenId usage on the mainchain
2. Attacker creates a token on a sidechain with a deliberately crafted symbol length that will collide when combined with a specific tokenId
3. Attacker uses `CrossChainCreateToken` to sync the malicious token to mainchain, bypassing symbol length validation
4. Attacker uses NFT `CrossChainCreate` to create the protocol on mainchain
5. Attacker mints an NFT with the collision-inducing tokenId

**Attacker Capabilities:** Any user who can create tokens on sidechains and sync them to mainchain via the cross-chain mechanism can execute this attack. The cross-chain validation gap makes this realistic.

**Cost vs Benefit:** Protocol creation has associated costs (token creation fees, cross-chain operation fees), but the ability to cause DoS on competitor protocols or corrupt state for protocols with `IsTokenIdReuse=true` may justify these costs for malicious actors targeting specific valuable NFT collections.

## Recommendation

Add a delimiter to the hash calculation to prevent collisions from different (symbol, tokenId) pairs:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}");
}
```

Additionally, add symbol length validation to `CrossChainCreateToken`:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation ...
    
    var tokenInfo = new TokenInfo { ... };
    
    // Add length validation before registering
    var symbolType = GetSymbolType(tokenInfo.Symbol);
    CheckSymbolLength(tokenInfo.Symbol, symbolType);
    
    RegisterTokenInfo(tokenInfo);
    // ... rest of method ...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task HashCollision_CausesStateCorruption_Test()
{
    // Create first protocol with 11-char symbol (AR + 9 digits)
    var protocol1Symbol = "AR123456789";
    await CreateProtocolViaMainchain(protocol1Symbol);
    
    // Create second protocol via cross-chain with 12-char symbol (AR + 10 digits)
    var protocol2Symbol = "AR1234567891";
    await CreateProtocolViaCrossChain(protocol2Symbol);
    
    // Mint NFT from Protocol 1 with tokenId=12
    await MintNFT(protocol1Symbol, tokenId: 12, owner: User1);
    
    // Calculate hashes - they should be different but are identical
    var hash1 = await NFTContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = protocol1Symbol, TokenId = 12 });
    var hash2 = await NFTContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = protocol2Symbol, TokenId = 2 });
    
    hash1.ShouldBe(hash2); // COLLISION DETECTED
    
    // Verify state corruption: Protocol 2 mint affects Protocol 1 NFT
    await MintNFT(protocol2Symbol, tokenId: 2, owner: User2);
    
    var nftInfo = await NFTContractStub.GetNFTInfoByTokenHash.CallAsync(hash1);
    nftInfo.Symbol.ShouldBe(protocol1Symbol); // Shows Protocol 1 symbol
    nftInfo.Minters.Count.ShouldBe(2); // But has minters from both protocols!
}
```

## Notes

The vulnerability is rooted in two design flaws:
1. **Missing delimiter in hash calculation** - The core issue enabling collisions
2. **Insufficient cross-chain validation** - The practical attack vector that makes exploitation feasible

While natural collisions between mainchain-created protocols may be rare due to deterministic symbol generation, the cross-chain creation path provides a realistic attack vector where an adversary can craft symbols specifically to cause collisions with existing protocols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-463)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);

        var nftMinted = new NFTMinted
        {
            Symbol = input.Symbol,
            ProtocolName = protocolInfo.ProtocolName,
            TokenId = tokenId,
            Metadata = nftMetadata,
            Owner = owner,
            Minter = Context.Sender,
            Quantity = quantity,
            Alias = input.Alias,
            BaseUri = protocolInfo.BaseUri,
            Uri = input.Uri ?? string.Empty,
            Creator = protocolInfo.Creator,
            NftType = protocolInfo.NftType,
            TotalQuantity = nftInfo.Quantity,
            TokenHash = tokenHash
        };
        Context.Fire(nftMinted);

        return nftMinted;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-116)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }

    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-50)
```csharp
﻿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}

```
