# Audit Report

## Title
Approved Proposals Can Be Cleared Before Execution Due to Missing Release Threshold Check

## Summary
The `ClearProposal` function in Parliament, Association, and Referendum contracts allows anyone to permanently delete fully approved proposals after expiration without verifying if they reached their release threshold. This enables governance disruption where approved proposals ready for execution can be deleted simply because the proposer failed to call `Release` before expiration.

## Finding Description

The `ClearProposal` function across all three governance contracts contains a critical logic gap. In the Parliament contract, the function only validates proposal existence and expiration before deletion: [1](#0-0) 

The identical vulnerability exists in Association: [2](#0-1) 

And Referendum: [3](#0-2) 

In contrast, the `Release` method properly checks if the proposal has reached its release threshold before execution. For Parliament: [4](#0-3) 

The `IsReleaseThresholdReached` function performs comprehensive validation of approval counts, rejection thresholds, and abstention thresholds. For Parliament: [5](#0-4) 

For Association: [6](#0-5) 

For Referendum: [7](#0-6) 

The `GetProposal` view function correctly exposes the `ToBeReleased` status. For Parliament: [8](#0-7) 

**Attack Execution Path:**
1. Proposer creates proposal with typical 1-2 day expiration (as seen in tests)
2. Governance members vote and proposal reaches release threshold (`ToBeReleased = true`)
3. Proposer delays calling `Release` (busy, network congestion, waiting for more votes, key issues)
4. Proposal expires (current time >= ExpiredTime)
5. Any address calls `ClearProposal`
6. Approved proposal is permanently deleted from state

The proposal must be recreated and all voting repeated from scratchâ€”there is no recovery mechanism.

## Impact Explanation

**Governance Integrity Violation:**
This vulnerability breaks the fundamental governance invariant that proposals which achieve consensus should be executable. The current implementation creates a race condition where approved proposals can be deleted rather than executed, effectively nullifying the democratic voting process.

**Operational Consequences:**
- **Critical proposals at risk:** System upgrades, parameter changes, emergency responses, and fund transfers that achieved approval can be permanently deleted
- **Resource waste:** All time and effort spent by governance participants in voting becomes wasted
- **Griefing vector:** Malicious actors can deliberately monitor for expiring approved proposals and delete them
- **No recovery path:** Deleted proposals must be completely recreated and revoted, potentially missing time-sensitive windows
- **Trust erosion:** Governance participants lose confidence when their approved decisions can be arbitrarily deleted

**Affected Scope:**
All three primary governance mechanisms (Parliament for miners, Association for multi-sig, Referendum for token holders) are vulnerable, meaning the entire AElf governance stack is compromised.

## Likelihood Explanation

**Attack Requirements:**
- **No privileges needed:** The `ClearProposal` method is publicly callable by any address (comment in code states "anyone can clear proposal if it is expired")
- **Zero cost:** Only gas fees required, no economic stake or permission needed
- **Low complexity:** Single transaction after waiting for expiration

**Realistic Preconditions:**
Test code confirms proposals typically have 1-2 day expiration windows: [9](#0-8) 

**Plausible Scenarios:**
1. **Network congestion:** High transaction volume delays proposer's `Release` transaction past expiration
2. **Proposer unavailability:** Proposer monitoring intermittently, missing narrow window between approval and expiration
3. **Strategic waiting:** Proposer intentionally waiting for additional votes to strengthen consensus, accidentally exceeding expiration
4. **Key management:** Proposer temporarily loses access to signing keys
5. **Malicious griefing:** Attacker monitors blockchain for high-value proposals nearing expiration and deliberately deletes them

**Testing Gap:**
Existing tests validate that expired proposals can be cleared but do NOT test the scenario where APPROVED proposals are cleared: [10](#0-9) 

This test verifies clearance of expired proposals but never checks if the proposal had reached release threshold first.

## Recommendation

Add a release threshold check to `ClearProposal` to prevent deletion of approved proposals:

```csharp
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
    
    // ADDED: Prevent clearing of approved proposals
    var organization = State.Organizations[proposal.OrganizationAddress];
    if (organization != null)
    {
        Assert(!IsReleaseThresholdReached(proposal, organization), 
               "Cannot clear approved proposal. Use Release instead.");
    }
    
    State.Proposals.Remove(input);
    return new Empty();
}
```

This ensures:
1. Expired proposals that did NOT reach approval threshold can still be cleared (garbage collection)
2. Expired proposals that DID reach approval threshold cannot be cleared and remain executable via `Release`
3. Proposers maintain control over approved proposals even after expiration

Apply this fix identically to Parliament, Association, and Referendum contracts.

## Proof of Concept

```csharp
[Fact]
public async Task ClearProposal_DeletesApprovedProposal_Vulnerability()
{
    // Setup: Create organization with low approval threshold
    var minimalApprovalThreshold = 6667;
    var maximalAbstentionThreshold = 2000;
    var maximalRejectionThreshold = 3000;
    var minimalVoteThreshold = 8000;
    var organizationAddress = await CreateOrganizationAsync(minimalApprovalThreshold,
        maximalAbstentionThreshold, maximalRejectionThreshold, minimalVoteThreshold);
    
    // Create proposal with 1 day expiration
    var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Get enough approvals to reach release threshold
    foreach (var minerKeyPair in InitialMinersKeyPairs.Take(7))
    {
        var stub = GetParliamentContractTester(minerKeyPair);
        await stub.Approve.SendAsync(proposalId);
    }
    
    // Verify proposal is approved and ready to release
    var proposalBeforeExpiry = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
    Assert.True(proposalBeforeExpiry.ToBeReleased); // Proposal IS approved
    
    // Time passes, proposal expires before proposer calls Release
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddDays(2));
    
    // VULNERABILITY: Anyone can clear the approved proposal
    var attackerStub = GetParliamentContractTester(InitialMinersKeyPairs[0]);
    var clearResult = await attackerStub.ClearProposal.SendAsync(proposalId);
    Assert.Equal(TransactionResultStatus.Mined, clearResult.TransactionResult.Status);
    
    // Verify: Approved proposal is permanently deleted
    var proposalAfterClear = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
    Assert.Equal(new ProposalOutput(), proposalAfterClear); // Proposal is gone
    
    // Proposer cannot execute the approved proposal anymore
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(proposalId);
    Assert.Contains("Invalid proposal", releaseResult.TransactionResult.Error);
}
```

This test demonstrates that a fully approved proposal (ToBeReleased = true) can be permanently deleted by any address after expiration, preventing its execution.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L225-248)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = Validate(proposal) && IsReleaseThresholdReached(proposal, organization),
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L263-270)
```csharp
        var blockTime = BlockTimeProvider.GetBlockTime();
        var createProposalInput = new CreateProposalInput
        {
            ToAddress = Accounts[0].Address,
            Params = ByteString.CopyFromUtf8("Test"),
            ExpiredTime = blockTime.AddDays(1),
            OrganizationAddress = organizationAddress
        };
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L924-945)
```csharp
    public async Task Clear_ExpiredProposal_Test()
    {
        // await InitializeParliamentContracts();

        var minimalApprovalThreshold = 6667;
        var maximalAbstentionThreshold = 2000;
        var maximalRejectionThreshold = 3000;
        var minimalVoteThreshold = 8000;
        var organizationAddress = await CreateOrganizationAsync(minimalApprovalThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, minimalVoteThreshold);
        var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);

        ParliamentContractStub = GetParliamentContractTester(InitialMinersKeyPairs[0]);
        BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddDays(5));
        var error = await ParliamentContractStub.Approve.CallWithExceptionAsync(proposalId);
        error.Value.ShouldContain("Invalid proposal.");

        var clear = await ParliamentContractStub.ClearProposal.SendAsync(proposalId);
        clear.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
        proposal.ShouldBe(new ProposalOutput());
    }
```
