# Audit Report

## Title
Pending Proposals from Removed Proposers Can Still Be Executed After Whitelist Changes

## Summary
The governance contracts (Parliament, Association, and Referendum) validate proposer authorization only at proposal creation time. When a proposer is removed from the whitelist via `ChangeOrganizationProposerWhiteList()`, their pending proposals remain executable because the `Release()` function does not re-validate authorization status. This allows removed proposers to execute previously created proposals even after being removed, undermining the whitelist security model.

## Finding Description

The vulnerability exists across all three governance contract implementations and breaks the fundamental security guarantee that whitelist removal revokes all proposal privileges.

**Authorization at Creation Time:**

When creating a proposal in Parliament, the contract validates proposer authorization through `AssertIsAuthorizedProposer` [1](#0-0) , which checks if the proposer is in the whitelist or is a parliament member [2](#0-1) .

The same pattern exists in Association [3](#0-2)  where authorization is checked via the whitelist [4](#0-3) .

Referendum follows the identical pattern [5](#0-4)  with whitelist validation [6](#0-5) .

**No Re-validation at Release Time:**

When releasing a proposal in Parliament, the function only verifies that the caller is the original proposer, without re-validating their current authorization status [7](#0-6) .

Association has the same flaw [8](#0-7)  as does Referendum [9](#0-8) .

**Whitelist Updates Don't Invalidate Pending Proposals:**

The `ChangeOrganizationProposerWhiteList` function in Parliament [10](#0-9) , Association [11](#0-10) , and Referendum [12](#0-11)  all update the whitelist without any validation or cleanup of pending proposals from removed addresses.

**Attack Sequence:**
1. Attacker (legitimate proposer) creates proposal with far-future expiration
2. Malicious behavior is detected, governance removes them from whitelist
3. Removed proposer cannot create NEW proposals (correctly blocked by authorization check)
4. However, their OLD proposal continues to collect votes
5. Once vote threshold is reached, removed proposer calls `Release()` successfully
6. The proposal executes despite proposer no longer being authorized

## Impact Explanation

**High Severity - Governance Authorization Bypass**

This vulnerability directly undermines the core security model of AElf's governance system. The whitelist mechanism exists specifically to control who can propose and execute governance actions. When an address is removed from the whitelist - typically due to discovered malicious behavior, compromised private keys, or loss of trust - the expectation is that ALL their governance privileges are immediately revoked.

However, due to this flaw, removed proposers retain the ability to execute any proposals they created while authorized. Depending on the proposal's content, this could enable:
- Unauthorized system configuration changes
- Fund transfers or treasury manipulation
- Contract upgrades or deployments
- Changes to consensus parameters
- Modification of fee structures

The impact extends across all organizations using these three core governance contracts:
- **Parliament**: Controls critical system governance including the default organization that manages protocol-level decisions
- **Association**: Used for multi-signature governance in organizational settings
- **Referendum**: Enables token-weighted voting for community governance

A single compromised or malicious proposer can "time-bomb" the system by creating benign-looking proposals before their removal, then executing them later to bypass the whitelist protection.

## Likelihood Explanation

**Medium-High Likelihood**

The attack has low complexity and realistic preconditions:

**Attacker Profile:**
- Must initially be a legitimate authorized proposer (in whitelist or parliament member)
- Could be an insider threat or a compromised authorized address
- No special permissions required beyond normal proposal flow

**Attack Feasibility:**
- Zero cost to maintain pending proposals
- Proposals can have far-future expiration times
- No blockchain state manipulation required
- Standard transaction flow using public methods

**Economic Rationality:**
Highly rational for a malicious actor. Once they suspect they might be removed (or after committing malicious acts), they can pre-emptively create proposals that will execute after their removal. The attack has zero ongoing cost and cannot be easily detected until execution.

**Detection Difficulty:**
The pending proposal appears completely legitimate in the system. Governance would need to manually track all pending proposals and cross-reference them against whitelist changes to identify this threat proactively. The test suite confirms that removed proposers cannot create new proposals [13](#0-12)  but does not validate that they cannot release old ones.

## Recommendation

Add authorization re-validation in the `Release()` method for all three governance contracts. Before executing the proposal, re-check if the proposer is still authorized:

**For Parliament:**
In the `Release()` method, add a call to `AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, proposalInfo.Proposer)` before executing the proposal.

**For Association and Referendum:**
Similarly, add authorization re-validation in their respective `Release()` methods.

This ensures that even if a proposal was created while the proposer was authorized, it can only be released if the proposer remains authorized at release time.

Alternatively, when removing a proposer from the whitelist via `ChangeOrganizationProposerWhiteList()`, iterate through all pending proposals and invalidate or remove those created by the removed proposer.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_CanStill_Release_OldProposal_Test()
{
    // 1. Create organization with Reviewer1 in whitelist
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 1,
        minimalVoteThreshold: 1, 
        maximalAbstentionThreshold: 1,
        maximalRejectionThreshold: 1,
        proposer: Reviewer1);
    
    // 2. Reviewer1 creates a proposal while authorized
    var proposalId = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, 
        someValidAction,
        organizationAddress);
    
    // 3. Proposal gets approved by organization members
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    
    // 4. Organization removes Reviewer1 from whitelist
    var newWhitelist = new ProposerWhiteList { Proposers = { Reviewer2 } };
    var changeProposalId = await CreateAssociationProposalAsync(
        Reviewer1KeyPair,
        newWhitelist,
        nameof(AssociationContractStub.ChangeOrganizationProposerWhiteList),
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, changeProposalId);
    await associationContractStub.Release.SendAsync(changeProposalId);
    
    // 5. Verify Reviewer1 cannot create NEW proposals (expected behavior)
    var newProposalAttempt = await associationContractStub.CreateProposal.SendWithExceptionAsync(
        new CreateProposalInput { OrganizationAddress = organizationAddress, ... });
    newProposalAttempt.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
    
    // 6. BUG: Reviewer1 CAN still release their OLD proposal created before removal
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendAsync(proposalId);
    
    // This succeeds when it should fail - vulnerability confirmed
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This test demonstrates that after a proposer is removed from the whitelist, they can still release proposals created while they were authorized, bypassing the whitelist security control.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-65)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-111)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L790-839)
```csharp
    public async Task Change_OrganizationProposalWhitelist_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);

        var proposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer2 }
        };

        var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
        var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair, proposerWhiteList,
            nameof(associationContractStub.ChangeOrganizationProposerWhiteList), organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, changeProposalId);
        var releaseResult = await associationContractStub.Release.SendAsync(changeProposalId);
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        await TransferToOrganizationAddressAsync(organizationAddress);
        var transferInput = new TransferInput
        {
            Symbol = "ELF",
            Amount = 100,
            To = Reviewer1,
            Memo = "Transfer"
        };
        associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
        var createProposalInput = new CreateProposalInput
        {
            ContractMethodName = nameof(TokenContractStub.Approve),
            ToAddress = TokenContractAddress,
            Params = transferInput.ToByteString(),
            ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
            OrganizationAddress = organizationAddress
        };
        var result = await associationContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");

        //Verify association proposal
        var verifyResult = await associationContractStub.ValidateProposerInWhiteList.CallAsync(
            new ValidateProposerInWhiteListInput
            {
                OrganizationAddress = organizationAddress,
                Proposer = Reviewer2
            });
        verifyResult.Value.ShouldBeTrue();
    }
```
