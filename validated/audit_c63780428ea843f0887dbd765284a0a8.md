# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTermInput Allows Reward Manipulation

## Summary
The AEDPoS consensus contract fails to validate the `ExtraBlockProducerOfPreviousRound` field during term transitions, allowing a malicious miner producing a NextTerm block to arbitrarily grant tiny block production privileges to any miner, thereby inflating their `ProducedBlocks` count and manipulating reward distribution.

## Finding Description

The vulnerability exists across multiple layers of consensus validation that collectively fail to ensure integrity of the `ExtraBlockProducerOfPreviousRound` field.

**Validation Gap Chain:**

1. The `NextTermInput.Create()` method blindly copies `ExtraBlockProducerOfPreviousRound` from the input Round without validation. [1](#0-0) 

2. The `RoundTerminateValidationProvider` for NextTerm transitions only validates round number increment, term number increment, and that InValues are null—completely omitting validation of `ExtraBlockProducerOfPreviousRound`. [2](#0-1) 

3. The `GetCheckableRound()` method used for hash-based validation explicitly excludes `ExtraBlockProducerOfPreviousRound`, including only `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`. [3](#0-2) 

**Exploitation Mechanism:**

When `ExtraBlockProducerOfPreviousRound` matches a miner's pubkey and current time is before the round start time, that miner is granted permission to produce tiny blocks. [4](#0-3) [5](#0-4) 

Each tiny block produced increments the miner's `ProducedBlocks` counter. [6](#0-5) 

**Expected vs. Actual Behavior:**

While `GenerateFirstRoundOfNextTerm()` correctly sets `ExtraBlockProducerOfPreviousRound` to the sender's pubkey, [7](#0-6)  there is no enforcement that the actual `NextTermInput` received matches this expected value.

The `ProcessNextTerm` method converts the input to a Round object and stores it via `AddRoundInformation` without validating `ExtraBlockProducerOfPreviousRound`. [8](#0-7) 

**Reward Impact:**

The total mined blocks (sum of all miners' `ProducedBlocks`) is used to calculate mining rewards donated to Treasury, [9](#0-8)  and individual `ProducedBlocks` counts are reported to the Election contract where they influence reward distribution and reputation. [10](#0-9) 

## Impact Explanation

**Direct Financial Impact:**

The vulnerability enables manipulation of mining rewards through the following attack chain:

1. **Privilege Grant**: A malicious miner producing a NextTerm block can set `ExtraBlockProducerOfPreviousRound` to any miner's pubkey (including a colluding party)

2. **Extra Mining Opportunities**: The beneficiary miner gains ability to produce tiny blocks before the round officially starts—a privilege that bypasses normal time slot restrictions

3. **Inflated Block Count**: Each tiny block increments the beneficiary's `ProducedBlocks` counter, artificially inflating their mining contribution

4. **Reward Misallocation**: The inflated `ProducedBlocks` count affects:
   - Total mining reward calculations (donated to Treasury based on sum of all `ProducedBlocks`)
   - Individual miner statistics reported to Election contract
   - Proportional reward distribution based on mining contribution
   - Miner reputation and voting weight in governance

**Attack Scenarios:**

- **Collusion**: Attacker sets field to colluding miner's pubkey, both share extra rewards
- **Self-enrichment**: If the NextTerm transaction sender differs from the consensus block producer, attacker could set to their own alternative identity
- **Consensus Disruption**: Setting to non-existent pubkey could prevent transition block production

**Affected Parties:**

- Legitimate extra block producer loses rightful mining privileges and rewards
- Honest miners receive proportionally reduced rewards when attacker inflates block counts
- Protocol integrity compromised as rewards no longer reflect actual work performed

## Likelihood Explanation

**Attack Prerequisites:**

The attacker must be selected to produce the NextTerm block, which is a standard consensus role that rotates among miners during term transitions. This is not an exceptional privilege but rather a normal operational requirement that provides regular attack opportunities.

**Execution Steps:**

1. Attacker's turn to produce NextTerm block arrives (happens regularly at term transitions)
2. Attacker calls `GetConsensusExtraData` which returns properly formatted Round data with correct `ExtraBlockProducerOfPreviousRound`
3. Before submitting the transaction, attacker modifies the `ExtraBlockProducerOfPreviousRound` field to beneficiary's pubkey
4. Modified block passes all validation:
   - `MiningPermissionValidationProvider` verifies sender is in miner list (passes)
   - `RoundTerminateValidationProvider` validates round/term numbers and InValues (passes)
   - No validator checks `ExtraBlockProducerOfPreviousRound`
5. `ProcessNextTerm` executes, storing manipulated Round to state
6. Beneficiary miner exploits extra mining privileges in subsequent blocks

**Detection Difficulty:**

The manipulation is undetectable through normal validation because:
- Validation does not regenerate expected Round data to compare against
- The field is explicitly excluded from hash-based integrity checks in `GetCheckableRound()`
- Block appears valid to all consensus validators
- No on-chain audit trail of expected vs. actual value

**Economic Rationality:**

The attack is economically rational because:
- **Cost**: Minimal (just modifying one field before block submission)
- **Benefit**: Direct increase in mining rewards through extra block production
- **Risk**: Low detection probability due to validation gaps
- **Frequency**: Every term transition provides an attack opportunity

## Recommendation

Add validation in `RoundTerminateValidationProvider` for NextTerm behavior to verify that `ExtraBlockProducerOfPreviousRound` matches the transaction sender's pubkey:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD THIS VALIDATION:
    // Verify ExtraBlockProducerOfPreviousRound matches the actual block producer
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != extraData.SenderPubkey.ToHex())
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match transaction sender." };

    return new ValidationResult { Success = true };
}
```

Alternatively, include `ExtraBlockProducerOfPreviousRound` in `GetCheckableRound()` so it's covered by hash-based validation in `ValidateConsensusAfterExecution`.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task ExtraBlockProducerOfPreviousRound_CanBeManipulated_Test()
{
    // Setup: Initialize consensus with miners Alice, Bob, Charlie
    var miners = new[] { "Alice", "Bob", "Charlie" };
    await InitializeConsensusAsync(miners);
    
    // Step 1: Reach a point where Alice should produce NextTerm block
    await AdvanceToNextTermTransition();
    
    // Step 2: Alice gets proper consensus extra data
    var properData = await ConsensusStub.GetConsensusExtraData.CallAsync(
        new BytesValue { Value = AlicePubkey });
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(properData.Value);
    
    // Verify it correctly sets ExtraBlockProducerOfPreviousRound to Alice
    headerInfo.Round.ExtraBlockProducerOfPreviousRound.ShouldBe(AliceHex);
    
    // Step 3: Alice maliciously modifies it to Bob
    headerInfo.Round.ExtraBlockProducerOfPreviousRound = BobHex;
    
    // Step 4: Submit manipulated NextTerm transaction
    var nextTermInput = NextTermInput.Create(headerInfo.Round, RandomNumber);
    var result = await ConsensusStub.NextTerm.SendAsync(nextTermInput);
    
    // Step 5: Verify transaction succeeds (vulnerability: no validation caught it)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 6: Verify Bob now has extra block producer privilege
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.ExtraBlockProducerOfPreviousRound.ShouldBe(BobHex); // Manipulated value persisted!
    
    // Step 7: Bob can now produce tiny blocks before round starts (privilege exploitation)
    var bobCommand = await ConsensusStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = BobPubkey });
    bobCommand.ArrangedMiningTime.ShouldBeLessThan(currentRound.GetRoundStartTime()); // Before round starts!
    bobCommand.Behaviour.ShouldBe(AElfConsensusBehaviour.TinyBlock); // Granted tiny block privilege!
    
    // Step 8: Bob produces extra tiny blocks, inflating his ProducedBlocks count
    await BobStub.UpdateTinyBlockInformation.SendAsync(new TinyBlockInput { ... });
    
    var bobMinerInfo = currentRound.RealTimeMinersInformation[BobHex];
    bobMinerInfo.ProducedBlocks.ShouldBeGreaterThan(ExpectedNormalBlocks); // Inflated!
    
    // Step 9: Verify rewards are miscalculated using inflated ProducedBlocks
    var totalReward = await GetTotalMiningReward();
    totalReward.ShouldBeGreaterThan(ExpectedReward); // Total rewards inflated!
    
    // Vulnerability confirmed: ExtraBlockProducerOfPreviousRound can be manipulated
    // to grant arbitrary miners extra mining privileges and inflate their rewards
}
```

## Notes

This is a critical consensus vulnerability affecting the core reward distribution mechanism. The attack is practical, economically motivated, and difficult to detect post-facto. Every term transition presents an exploitation opportunity, making this a recurring threat rather than a one-time issue.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
