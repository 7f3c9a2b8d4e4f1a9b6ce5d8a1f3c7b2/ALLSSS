# Audit Report

## Title
Integer Division Vulnerability in Mining Interval Validation Enables Permanent Denial of Service

## Summary
The AEDPoS consensus validation logic accepts mining intervals as low as 1ms, which when combined with integer division calculations for block execution timeouts, results in all timeout limits becoming 0ms. A malicious miner producing a NextTerm block can craft consensus data with 1ms mining intervals that passes validation, causing immediate cancellation of all user transaction processing and permanently rendering the blockchain unusable.

## Finding Description

**Root Cause:**
The `CheckRoundTimeSlots()` method only validates that `baseMiningInterval > 0`, allowing mining intervals as low as 1ms. [1](#0-0) 

**Vulnerable Integer Division:**
The mining limit calculations use integer division without minimum threshold enforcement. [2](#0-1) 

The `Div` method performs standard C# integer division with no rounding protection. [3](#0-2) 

**Attack Vector:**
When a miner produces a NextTerm block, the consensus extra data is generated using the stored mining interval. [4](#0-3) 

The miner can modify the Round's `ExpectedMiningTime` values in the consensus extra data before including it in the block. The only validation checks are:
- Round/term number increments [5](#0-4) 
- Time slot validation which only calls `CheckRoundTimeSlots()` [6](#0-5) 

There is no cryptographic signature verification on the Round data itself. [7](#0-6) 

**Execution Flow:**
The modified round is stored during NextTerm processing. [8](#0-7) 

Subsequent blocks calculate mining intervals from the stored Round's `ExpectedMiningTime` values. [9](#0-8) 

These mining limits are used to create timeout values. [10](#0-9) 

When `BlockExecutionTime` is 0ms, the cancellation token is immediately cancelled. [11](#0-10) 

User transactions are executed with the cancelled token and are therefore skipped. [12](#0-11) 

## Impact Explanation

**Severity: CRITICAL**

After the malicious NextTerm block is accepted:
- **All user transactions are permanently blocked** - The chain produces blocks but skips all user transactions due to immediate cancellation
- **System transactions still execute** - The chain continues producing blocks with consensus transactions only
- **No recovery without hard fork** - The malicious round is permanently stored in state
- **All network participants affected** - Users cannot transfer tokens, interact with dApps, or perform any blockchain operations
- **Economic impact is total** - The blockchain becomes economically worthless as no value transfer is possible

This breaks the fundamental security guarantee that legitimate user transactions will be processed by the blockchain.

## Likelihood Explanation

**Probability: MEDIUM to HIGH**

**Attacker Requirements:**
- Must be a legitimate miner in the active miner set
- Must be scheduled to produce a NextTerm block (occurs periodically based on PeriodSeconds configuration)

**Attack Complexity: LOW**
1. Wait for NextTerm block assignment
2. Generate consensus data via `GetConsensusExtraData()`
3. Modify Round protobuf to set all `ExpectedMiningTime` values 1ms apart
4. Include modified data in block header
5. Sign and broadcast block

**Feasibility:**
- No cryptographic signatures prevent Round data modification
- Validation only checks `baseMiningInterval > 0`, which 1ms satisfies
- Attack is undetectable until after execution
- Economically rational for attackers seeking to disrupt competing chains or extort network

## Recommendation

**Fix 1: Enforce Minimum Mining Interval**
Add a minimum threshold check in `CheckRoundTimeSlots()`:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    // FIX: Enforce minimum mining interval of 1000ms (1 second)
    const int MinimumMiningInterval = 1000;
    if (baseMiningInterval < MinimumMiningInterval)
        return new ValidationResult { Message = $"Mining interval must be at least {MinimumMiningInterval}ms.\n{this}" };

    // Rest of validation...
}
```

**Fix 2: Add Cryptographic Signature on Round Data**
Implement a signature mechanism where the consensus contract signs the Round data during generation, and validators verify this signature during validation.

## Proof of Concept

This vulnerability requires integration testing with a full AElf node setup. A simplified test would:

```csharp
[Fact]
public async Task MaliciousNextTermBlock_CausesUserTransactionDoS()
{
    // Setup: Initialize consensus with legitimate miners
    // Arrange miner to produce NextTerm block
    
    // Act: Miner creates NextTerm block with 1ms mining intervals
    // - Generate consensus data
    // - Modify Round.RealTimeMinersInformation[].ExpectedMiningTime to be 1ms apart
    // - Include in block header
    // - Sign and execute block
    
    // Assert: Verify modified round is stored
    var storedRound = await GetCurrentRound();
    Assert.Equal(1, storedRound.GetMiningInterval());
    
    // Assert: Verify subsequent user transactions are cancelled
    var userTx = GenerateUserTransaction();
    var result = await MineBlockWithTransaction(userTx);
    Assert.False(result.TransactionResultMap.ContainsKey(userTx.GetHash()));
    Assert.True(result.Block.Body.TransactionIds.Count > 0); // System txs only
}
```

The vulnerability requires modifying consensus data at the block production level, which cannot be easily tested in a unit test without access to the full mining infrastructure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L46-47)
```csharp
        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-60)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

        protected int MinersCount => CurrentRound.RealTimeMinersInformation.Count;

        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);

        /// <summary>
        ///     If this tiny block is the last one of current time slot, give half of producing time for mining.
        /// </summary>
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);

        /// <summary>
        ///     If this block is of consensus behaviour NEXT_TERM, the producing time is MiningInterval,
        ///     so the limitation of mining is 8 times than DefaultBlockMiningLimit.
        /// </summary>
        protected int LastBlockOfCurrentTermMiningLimit => MiningInterval.Mul(3).Div(5);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L21-24)
```csharp
    public static int Div(this int a, int b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-33)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L36-40)
```csharp
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L50-62)
```csharp
            using var cts = new CancellationTokenSource();
            var expirationTime = blockTime + requestMiningDto.BlockExecutionTime;
            if (expirationTime < TimestampHelper.GetUtcNow())
            {
                cts.Cancel();
            }
            else
            {
                var ts = (expirationTime - TimestampHelper.GetUtcNow()).ToTimeSpan();
                if (ts.TotalMilliseconds > int.MaxValue) ts = TimeSpan.FromMilliseconds(int.MaxValue);

                cts.CancelAfter(ts);
            }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockExecutingService.cs (L69-81)
```csharp
        if (!cancellationToken.IsCancellationRequested && cancellable.Count > 0)
        {
            cancellableReturnSets = await _transactionExecutingService.ExecuteAsync(
                new TransactionExecutingDto
                {
                    BlockHeader = blockHeader,
                    Transactions = cancellable,
                    PartialBlockStateSet = returnSetCollection.ToBlockStateSet()
                },
                cancellationToken);
            returnSetCollection.AddRange(cancellableReturnSets);
            Logger.LogTrace("Executed cancellable txs");
        }
```
