# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Allows Arbitrary Public Key Hijacking

## Summary
The `AnnounceElectionFor` function lacks authorization checks, allowing any caller to announce election for arbitrary public keys and assign themselves as admin. This enables attackers to gain permanent administrative control over candidates they don't own, manipulate elections, and prevent legitimate owners from ever registering their public keys as candidates.

## Finding Description

The vulnerability exists in the `AnnounceElectionFor` function which accepts an arbitrary `pubkey` string and `admin` address parameter without verifying that the caller has permission to announce election for that public key. [1](#0-0) 

The function directly assigns the provided `admin` parameter (defaulting to `Context.Sender` when null) as the candidate admin without any consent mechanism from the public key owner. [2](#0-1) 

The internal validation in the private `AnnounceElection(byte[] pubkeyBytes)` method only checks pubkey eligibility status - not an initial miner, not already announced, and not banned - but never validates that the caller has authorization to announce for this public key. [3](#0-2) 

**Contrast with Secure Implementation:**

The alternative `AnnounceElection(Address input)` method uses cryptographic signature verification via `Context.RecoverPublicKey()` to ensure only the private key owner can announce their candidacy. [4](#0-3) 

This secure pattern of signature-based ownership verification is completely absent from `AnnounceElectionFor`, creating the authorization bypass.

## Impact Explanation

**1. Unauthorized Administrative Control**

An attacker gains full admin privileges over candidates they don't own. The admin role controls critical operations:

- **Quit Election**: Only the admin can quit election for a candidate. [5](#0-4) 

- **Replace Public Key**: Only the admin can replace a candidate's public key. [6](#0-5) 

- **Set Profit Receivers**: The Treasury contract verifies that only the candidate's admin can set profit receivers. [7](#0-6) 

**2. Permanent Registration DoS**

Once a pubkey is announced as a candidate, the legitimate owner cannot register it because the check prevents re-announcement while `IsCurrentCandidate` is true. [8](#0-7) 

Even after the attacker quits (setting `IsCurrentCandidate` to false), they can immediately re-announce before the legitimate owner, creating a persistent griefing attack.

**3. Election Manipulation**

- Attackers can strategically quit elections to manipulate the miner selection process during term changes
- Voters may vote for hijacked candidates believing they're legitimate, locking tokens for candidates controlled by attackers  
- The data center ranking system can be manipulated by controlling when candidates participate

**4. Reputation and Trust Damage**

Attackers can register well-known public keys (from other blockchains, public figures, etc.) as candidates under their control, creating confusion and damaging the election system's integrity.

**Severity:** CRITICAL - Breaks fundamental authorization invariant allowing unauthorized control over election candidates and manipulation of the consensus mechanism.

## Likelihood Explanation

**Attacker Capabilities Required:**
- 100,000 ELF for the candidate lock [9](#0-8) 
- Ability to call a public contract method
- Knowledge of target public key hex strings

**Attack Complexity:** TRIVIAL
- Single transaction call with two parameters: arbitrary pubkey and attacker's address as admin
- No special timing, race conditions, or complex state setup required

**Economic Cost:** MINIMAL

The attacker locks 100,000 ELF but retrieves it when quitting. The sponsor (attacker) is recorded in `CandidateSponsorMap` [10](#0-9)  and receives the refund when the admin quits. [11](#0-10) 

The attacker's net cost is zero plus transaction fees.

**Detection Difficulty:** HIGH

The hijacked registration appears legitimate on-chain. Users cannot easily distinguish between legitimate candidate registrations and malicious hijackings without off-chain verification of ownership.

**Probability:** HIGH - The vulnerability is easily discoverable, trivial to exploit, and economically rational for attackers seeking to manipulate elections or grief legitimate candidates.

## Recommendation

Add authorization checks to `AnnounceElectionFor` to verify the caller has permission to announce for the provided public key. Consider one of these approaches:

**Option 1: Require Signature Proof**
Require the caller to provide a signature from the public key owner proving consent.

**Option 2: Restrict to Authorized Sponsors**
Maintain a whitelist of authorized sponsors (similar to Parliament governance) and verify the caller is authorized.

**Option 3: Add Two-Step Process**
Allow the legitimate owner to claim/approve their candidacy after sponsorship, with ability to reject unauthorized announcements.

**Option 4: Remove Vulnerable Function**
If sponsorship without consent is not a required feature, consider removing `AnnounceElectionFor` entirely and require all candidates to use the secure `AnnounceElection(Address input)` method that includes signature verification.

The most secure approach is Option 4, as it eliminates the authorization bypass entirely while maintaining the ability for candidates to announce with custom admin addresses.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Authorization_Bypass_Test()
{
    // Attacker and victim use different key pairs
    var victimKeyPair = ValidationDataCenterKeyPairs[0];
    var attackerKeyPair = ValidationDataCenterKeyPairs[1];
    
    // Attacker calls AnnounceElectionFor with victim's public key
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimKeyPair.PublicKey.ToHex(),
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey) // Attacker sets themselves as admin
    });
    
    // Verify attacker is now admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Verify victim cannot re-announce (DoS)
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.AnnounceElection.SendWithExceptionAsync(
        Address.FromPublicKey(victimKeyPair.PublicKey));
    result.TransactionResult.Error.ShouldContain("already announced election");
    
    // Verify only attacker can quit (admin control)
    var quitResult = await victimStub.QuitElection.SendWithExceptionAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    quitResult.TransactionResult.Error.ShouldContain("Only admin can quit election");
    
    // Attacker can quit successfully and get refund
    await attackerStub.QuitElection.SendAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
}
```

## Notes

The vulnerability is confirmed through analysis of the actual contract code. The `AnnounceElectionFor` function was likely intended as a sponsorship mechanism where third parties could help candidates announce, but it was implemented without proper authorization controls. The contrast with the secure `AnnounceElection(Address input)` method that uses `Context.RecoverPublicKey()` demonstrates that the developers understood the need for cryptographic verification in other contexts but failed to apply it here.

The `SetCandidateAdmin` function cannot be used by victims to recover control because it checks that the caller must already be the current admin. [12](#0-11)  Once an attacker sets themselves as admin via `AnnounceElectionFor`, only Parliament intervention can change it.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L245-245)
```csharp
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
