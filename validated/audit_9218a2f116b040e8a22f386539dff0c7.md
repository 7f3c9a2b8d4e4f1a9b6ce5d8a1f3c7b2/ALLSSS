# Audit Report

## Title
Arithmetic Overflow in Bancor Payment Calculation Causes Token Converter DoS

## Summary
The `GetAmountToPayFromReturn` method performs unchecked decimal-to-long casting after exponential calculations that can produce values exceeding `Long.MaxValue`. With overflow checking enabled, this throws `OverflowException` and causes denial-of-service of the `Buy` and `EnableConnector` functions for token pairs with extreme weight ratios and low connector balances.

## Finding Description

The vulnerability exists in the Bancor payment calculation formula which computes the required payment amount using exponential operations. [1](#0-0) 

The calculation involves three terms: `x = toConnectorBalance / (toConnectorBalance - amountToReceive)`, `y = toConnectorWeight / fromConnectorWeight`, and the final result `fromConnectorBalance * (x^y - 1)`. When connector weights have extreme ratios, the exponential term grows rapidly and can exceed the maximum value representable by the `long` type.

Individual connector weights are validated to be strictly between 0 and 1, but their ratio is unbounded. [2](#0-1) 

For example, with `toConnectorWeight = 0.95` and `fromConnectorWeight = 0.05`, the ratio `y = 19`. If `toConnectorBalance = 10,000`, `amountToReceive = 9,000`, and `fromConnectorBalance = 100`:
- `x = 10,000 / 1,000 = 10`
- `x^y = 10^19 = 10,000,000,000,000,000,000`
- Result: `100 * 10^19 = 10^21`
- This exceeds `Long.MaxValue ≈ 9.2 × 10^18`

The TokenConverter contract is compiled with overflow checking enabled. [3](#0-2) 

This configuration causes the cast to throw `OverflowException` rather than silently truncating, resulting in transaction reversion.

The vulnerable method is invoked in two critical paths:

**Buy Operation**: Users purchasing tokens trigger the overflow when attempting to buy large amounts. [4](#0-3) 

**EnableConnector Operation**: Connector initialization calculates needed deposits using the same formula. [5](#0-4) 

## Impact Explanation

**Severity: HIGH** - This causes complete operational failure of the TokenConverter's core functionality.

1. **Buy Function DoS**: Users cannot purchase tokens when the calculation overflows, effectively freezing the market for that token pair. All buy attempts fail with `OverflowException`.

2. **EnableConnector DoS**: New connector pairs cannot be initialized if the deposit calculation overflows, preventing market creation or recovery from the DoS state.

3. **No User Workaround**: Users have no way to avoid the overflow - the calculation is deterministic based on contract state. They cannot adjust their inputs to prevent the error once preconditions are met.

4. **Governance Required for Recovery**: Only the connector controller (Parliament organization) can modify connector parameters to resolve the issue, introducing significant delay and coordination overhead.

5. **Cascading Vulnerability**: Multiple token pairs using similar weight configurations become vulnerable simultaneously during low-liquidity conditions.

While no funds are directly lost, the protocol's primary functionality is completely disabled for affected pairs, constituting a critical availability failure.

## Likelihood Explanation

**Likelihood: HIGH** - The preconditions can occur through normal market operations without malicious intent.

**Precondition 1 - Extreme Weight Ratio** (Realistic):
- Weight ratios like `0.95 / 0.05 = 19` or `0.9 / 0.1 = 9` are mathematically valid
- Both individual weights pass validation (between 0 and 1)
- No documentation or code warnings against extreme ratios
- Could be set during experimental markets or governance errors

**Precondition 2 - Low Connector Balance** (Common):
- Deposit connector balances naturally deplete through sell operations
- No minimum balance requirements are enforced in the contract
- Low-liquidity markets regularly experience near-zero balances
- Common during market stress or after large sell-offs

**Precondition 3 - Large Purchase Attempt** (Normal):
- Users attempting to buy significant portions of available tokens is standard arbitrage behavior
- No way for users to predict overflow threshold before transaction submission
- High demand scenarios naturally produce these conditions

**Attack Complexity**: None - this occurs organically without requiring attacker coordination or privileged access. Both `Buy` and `EnableConnector` are public methods callable by any address.

**Reproducibility**: Deterministic - once market conditions create the preconditions, every subsequent buy attempt fails until governance intervenes.

## Recommendation

Implement pre-calculation validation to detect potential overflow before performing the cast:

1. **Add bounds checking on weight ratio**: Limit the maximum allowed ratio between connector weights (e.g., ratio must be ≤ 10) during connector initialization and updates.

2. **Validate calculation result range**: Before casting to long, check if the decimal result exceeds `Long.MaxValue` and revert with a descriptive error message.

3. **Add try-catch for overflow**: Wrap the calculation in a try-catch block to handle `OverflowException` gracefully and provide actionable error messages to users.

4. **Implement circuit breaker**: Add minimum balance thresholds for deposit connectors to prevent extreme x values.

Example fix for the validation approach:

```csharp
// In GetAmountToPayFromReturn, replace line 93:
var result = bf * (Exp(y * Ln(x)) - decimal.One);
Assert(result <= (decimal)long.MaxValue, "Calculation exceeds maximum value. Adjust connector parameters or reduce purchase amount.");
return (long)result;
```

## Proof of Concept

```csharp
[Fact]
public void BancorOverflow_DoS_Test()
{
    // Configure extreme but valid weight ratio
    var toConnectorWeight = 0.95m;    // Valid: 0 < 0.95 < 1
    var fromConnectorWeight = 0.05m;  // Valid: 0 < 0.05 < 1
    // Ratio: 0.95 / 0.05 = 19 (extreme but passes validation)
    
    // Low connector balance from market depletion
    var fromConnectorBalance = 100L;
    
    // Large purchase scenario
    var toConnectorBalance = 10000L;
    var amountToReceive = 9000L;
    
    // This should throw OverflowException
    Should.Throw<OverflowException>(() => 
        BancorHelper.GetAmountToPayFromReturn(
            fromConnectorBalance, 
            fromConnectorWeight,
            toConnectorBalance, 
            toConnectorWeight,
            amountToReceive));
}
```

**Notes**

This vulnerability demonstrates a gap between individual parameter validation and compound calculation safety. While each connector weight individually passes the (0, 1) range check, their ratio—which directly determines the exponential growth rate—remains unbounded. The mathematical properties of the Bancor formula combined with C#'s overflow checking create a deterministic DoS condition that affects protocol availability without requiring attacker privileges or fund loss. The issue is exacerbated by the lack of minimum balance requirements, allowing market conditions to naturally create overflow-prone states.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L81-84)
```csharp
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```
