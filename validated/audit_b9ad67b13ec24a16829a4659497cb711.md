# Audit Report

## Title
Token Alias Resolution Mismatch in ACS2 Resource Path Declaration Enables Parallel Execution Race Conditions

## Summary
The `TransferFrom` method's ACS2 resource path provider declares state paths using unresolved input symbols (including aliases), while actual execution resolves aliases and modifies different state paths. This mismatch allows the parallel execution scheduler to incorrectly classify conflicting transactions as non-conflicting, enabling allowance double-spending and balance corruption for NFT tokens with aliases.

## Finding Description

The vulnerability arises from a fundamental disconnect between resource path declaration and actual state modification when token aliases are used.

**Path Declaration Phase:**

When `GetResourceInfo` is invoked for `TransferFrom`, it parses the transaction parameters and uses `args.Symbol` directly without alias resolution [1](#0-0) . The balance paths and allowance paths via `AddPathForAllowance` all use this unresolved symbol.

The `AddPathForAllowance` method declares write paths using the raw symbol parameter [2](#0-1) . Critically, it calls `GetSymbolType(symbol)` on the unresolved alias. The `GetSymbolType` implementation splits symbols by the NFT separator '-' [3](#0-2) . For an alias like "TP" (representing NFT "TP-31175"), it returns `SymbolType.Token` instead of `SymbolType.Nft`, causing the code to skip adding NFT collection allowance paths ("TP-*").

**Actual Execution Phase:**

During execution, `TransferFrom` calls `AssertValidToken` which resolves aliases [4](#0-3) . The `GetTokenInfo` method performs this resolution by checking `State.SymbolAliasMap` [5](#0-4) , returning the actual symbol (e.g., "TP-31175" for alias "TP").

The resolved symbol is then passed to `DoTransferFrom` [6](#0-5) . This method calls `GetAllowance`, which determines the symbol type using the resolved actual symbol. For "TP-31175", `GetSymbolType` correctly returns `SymbolType.Nft` [7](#0-6) , causing it to check NFT collection allowances ("TP-*"). Balance modifications and allowance updates all use the resolved symbol.

**Root Cause:**

ACS2 path declaration occurs at transaction scheduling time using raw input, while execution occurs later using resolved symbols. Token aliases are a supported feature for NFT items, as evidenced by test coverage [8](#0-7)  showing `TransferFrom` working with aliases.

## Impact Explanation

**Allowance Double-Spending:**
An attacker with an approved allowance can submit two `TransferFrom` transactions: one using the alias ("TP") and one using the actual symbol ("TP-31175"). The ACS2 path provider declares different resource paths for each transaction, allowing parallel execution. Both transactions can read the same allowance value before either deducts it, enabling transfer of double the approved amount. This directly violates the allowance enforcement invariant.

**Balance Corruption:**
Similarly, balance state paths are declared differently but modified identically, allowing concurrent modifications that can lead to incorrect final balances through lost updates.

**Affected Assets:**
All NFT tokens with aliases are vulnerable. The `SetSymbolAlias` functionality is specifically designed for NFT items [9](#0-8)  and actively tested. NFT assets often have high individual value, making this economically significant.

## Likelihood Explanation

**Entry Point:**
`TransferFrom` is a public method accessible to any user with approved allowances.

**Preconditions:**
1. NFT token has an alias set (supported feature)
2. Token owner has approved an allowance 
3. Spender submits two transactions in the same block using different symbol representations

**Execution Feasibility:**
The test suite demonstrates aliases working with transfers and approvals. No special privileges are requiredâ€”any approved spender can exploit this. The parallel execution system will classify these as non-conflicting due to the path mismatch.

**Economic Viability:**
Attack cost is minimal (two transaction fees), while benefit is stealing tokens beyond approved amounts. For valuable NFTs, this is highly attractive.

## Recommendation

Resolve token aliases in the ACS2 `GetResourceInfo` method before declaring resource paths. Modify `TokenContract_ACS2_StatePathsProvider.cs` to call `GetActualTokenSymbol` on input symbols before using them to construct state paths. This ensures path declaration matches actual execution state access patterns.

```csharp
case nameof(TransferFrom):
{
    var args = TransferFromInput.Parser.ParseFrom(txn.Params);
    // Resolve alias before declaring paths
    var actualSymbol = GetActualTokenSymbol(args.Symbol);
    var resourceInfo = new ResourceInfo
    {
        WritePaths =
        {
            GetPath(nameof(TokenContractState.Balances), args.From.ToString(), actualSymbol),
            GetPath(nameof(TokenContractState.Balances), args.To.ToString(), actualSymbol),
            GetPath(nameof(TokenContractState.LockWhiteLists), actualSymbol, txn.From.ToString())
        },
        // ... rest of the code using actualSymbol
    };
    AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), actualSymbol);
    // ... rest remains the same
}
```

## Proof of Concept

The provided test case `ApproveAndTransferFromViaAlias_Test` [8](#0-7)  demonstrates the successful use of aliases with `TransferFrom`. To prove the vulnerability, submit two parallel `TransferFrom` transactions (one with alias "TP", one with actual symbol "TP-31175") against the same approved allowance. Both will execute successfully, doubling the spending beyond the approved amount due to the ACS2 path mismatch preventing conflict detection.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L71-82)
```csharp
    private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, symbol));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetAllSymbolIdentifier()));
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L204-238)
```csharp
    public async Task ApproveAndTransferFromViaAlias_Test()
    {
        await CreateTokenWithAlias_Test();

        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "TP-31175",
            Amount = 1,
            To = DefaultAddress
        });

        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Symbol = "TP",
            Amount = 1,
            Spender = User1Address
        });

        await TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
        {
            Symbol = "TP",
            Amount = 1,
            From = DefaultAddress,
            To = User2Address,
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User2Address,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }
    }
```
