# Audit Report

## Title
Input Collision Vulnerability in Token Hash Calculation Allows Cross-Protocol Balance Manipulation

## Summary
The NFT contract's `CalculateTokenHash` function concatenates symbol and tokenId without a delimiter, enabling different (symbol, tokenId) pairs to produce identical hashes. This causes multiple distinct tokens to share storage slots for balances, allowances, and metadata, enabling unauthorized token transfers and balance theft.

## Finding Description

The vulnerability originates in the `CalculateTokenHash` function which computes token identifiers through direct string concatenation without any delimiter. [1](#0-0) 

This creates input collisions where distinct tokens produce identical hashes:
- Symbol="AR123456789", tokenId=0 → hash("AR1234567890")
- Symbol="AR1234567", tokenId=890 → hash("AR1234567890")

All critical state mappings use this colliding tokenHash as the primary key. The BalanceMap stores token balances indexed by tokenHash [2](#0-1) , the AllowanceMap stores approved amounts [3](#0-2) , and the NftInfoMap stores token metadata [4](#0-3) .

**Exploitation Sequence:**

1. Attacker acquires a seed NFT for symbol "AR1234567" through secondary market. To create a token with specific symbol, the MultiToken contract requires either whitelist access or seed NFT ownership. [5](#0-4) 

2. Attacker creates token "AR1234567" in MultiToken contract using the seed NFT, becoming the issuer.

3. Attacker calls `CrossChainCreate` to register the protocol in NFT contract. This method is permissionless with no sender authorization checks [6](#0-5)  and only validates that the symbol doesn't already exist in NFT contract and that the token exists in MultiToken - there is NO collision detection. The attacker automatically becomes a minter through this registration. [7](#0-6) 

4. Attacker mints NFTs with tokenId=890, calculating the collision to match existing valuable NFT at "AR123456789", tokenId=0. The minting operation calculates the tokenHash and updates the shared balance pool. [8](#0-7) [9](#0-8) 

5. Attacker executes transfers using their colliding token. The `Transfer` method computes the same tokenHash [10](#0-9)  and the DoTransfer function operates on the shared balance pool. [11](#0-10)  The balance checks pass because the pool is shared, enabling theft.

The vulnerability affects all balance-dependent operations including Transfer, TransferFrom, Approve, Burn, and Recast.

## Impact Explanation

**Direct Financial Loss:**
- Attackers can transfer arbitrary token amounts from the shared balance pool that they don't legitimately own
- Legitimate holders lose control over their balances as multiple protocols share the same storage slot
- Balance queries aggregate values across different protocols, returning incorrect information [12](#0-11) 

**Protocol Integrity:**
- Breaks fundamental token accounting invariant: each unique token should have isolated state
- Multiple NFT protocols become entangled through shared storage
- Secondary markets and DeFi integrations receive incorrect balance data

**Severity: HIGH** - The vulnerability enables direct theft of user funds. While exploitation requires seed NFT acquisition, once conditions are met, attackers can steal arbitrary amounts. The design flaw is permanent and affects all core token operations, not just view functions.

## Likelihood Explanation

**Attack Prerequisites:**
1. Acquire seed NFT for calculated symbol (e.g., "AR1234567" to collide with "AR123456789")
2. Create token in MultiToken contract (requires seed NFT ownership) [13](#0-12) 
3. Register via `CrossChainCreate` (permissionless, no collision detection)
4. Mint with calculated tokenId (attacker is automatically minter)
5. Execute transfers to exploit shared balance

**Feasibility Assessment:**
- **Attack Complexity: MEDIUM** - Requires understanding of concatenation vulnerability and straightforward mathematical calculation to determine collision parameters
- **Technical Barriers: LOW** - No cryptographic attacks needed; pure input manipulation
- **Economic Barriers: VARIABLE** - Depends on seed NFT market availability and pricing
  - If seed NFTs are tradeable/purchasable: HIGH feasibility
  - If tightly controlled: LOWER feasibility (but vulnerability persists)

**Detection:**
- Collision is observable on-chain through duplicate tokenHashes
- No automatic runtime prevention mechanism exists
- Vulnerability requires code review to identify before exploitation

**Probability: MEDIUM** - While preconditions exist, the core flaw is exploitable given resources for seed NFT acquisition. The permanent nature means risk increases over time as more protocols deploy and seed NFT markets mature.

## Recommendation

Add a delimiter between symbol and tokenId in the hash calculation to prevent collisions:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");
}
```

Additionally, implement collision detection in `CrossChainCreate` by maintaining a registry of all existing tokenHashes and checking for duplicates before registration.

## Proof of Concept

```csharp
[Fact]
public async Task TokenHashCollision_EnablesBalanceTheft()
{
    // Setup: Create legitimate token "AR123456789" with tokenId=0
    var legitimateSymbol = "AR123456789";
    var legitimateTokenId = 0L;
    
    // Attacker creates colliding token "AR1234567" with tokenId=890
    var attackerSymbol = "AR1234567";
    var attackerTokenId = 890L;
    
    // Calculate hashes - they should collide
    var legitimateHash = await NFTContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = legitimateSymbol, TokenId = legitimateTokenId });
    var attackerHash = await NFTContractStub.CalculateTokenHash.CallAsync(
        new CalculateTokenHashInput { Symbol = attackerSymbol, TokenId = attackerTokenId });
    
    // Verify collision
    legitimateHash.ShouldBe(attackerHash); // Both produce hash("AR1234567890")
    
    // This proves distinct tokens share the same storage slot, enabling balance manipulation
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L23-23)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-393)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L441-441)
```csharp
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-17)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L22-22)
```csharp
    public MappedState<Hash, Address, long> BalanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L30-30)
```csharp
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L110-113)
```csharp
        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L32-42)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var balance = State.BalanceMap[tokenHash][input.Owner];
        return new GetBalanceOutput
        {
            Owner = input.Owner,
            Balance = balance,
            TokenHash = tokenHash
        };
    }
```
