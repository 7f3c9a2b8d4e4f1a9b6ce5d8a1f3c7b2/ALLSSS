# Audit Report

## Title
Critical Consensus Takeover: NextTerm Miner List Bypass Enables Arbitrary Miner Installation

## Summary
The AEDPoS consensus contract's `NextTerm` transaction processing lacks validation that the proposed miner list matches the Election contract's `GetVictories()` results. A malicious extra block producer can install arbitrary miners for the next term, completely bypassing the election/governance system and achieving total blockchain control.

## Finding Description

The vulnerability exists in the term transition mechanism where miner lists are updated based on election results. The security guarantee that should be enforced is: **only miners elected through the Election contract's voting system can be installed as consensus miners for a new term**.

**Root Cause Analysis:**

The `NextTermInput.Create()` method directly copies `RealTimeMinersInformation` from the provided Round parameter without any validation. [1](#0-0) 

During execution, `ProcessNextTerm()` extracts the miner list directly from the unvalidated input and stores it in state. The method converts the input to a Round object and then extracts miners from `RealTimeMinersInformation.Keys` without validating against election results. [2](#0-1) 

**Why Existing Protections Fail:**

1. **Pre-execution validation** only validates structural properties (round/term number increments, null InValues) via `RoundTerminateValidationProvider`. It checks that the term number increments by 1 and inherits round number validation from NextRound, but never validates the miner list against election results. [3](#0-2) 

The validation service for NextTerm behavior only adds the `RoundTerminateValidationProvider`, which performs no election validation. [4](#0-3) 

2. **Post-execution validation** retrieves the current round information AFTER the state has already been updated with malicious miners. Since `ProcessNextTerm` has already written the malicious miner list to state before post-validation runs, the comparison compares poisoned state against itself. [5](#0-4) 

3. **Election contract integration** exists only in the honest generation path where `GenerateFirstRoundOfNextTerm` calls `TryToGetVictories`. This method properly retrieves election results from the Election contract. [6](#0-5) 

The `TryToGetVictories` method correctly calls the Election contract to get legitimately elected miners. [7](#0-6) 

This validation is **never enforced during NextTerm processing** - it's only used when honest nodes generate consensus data via `GetConsensusExtraDataForNextTerm`. [8](#0-7) 

**Attack Execution:**

A malicious miner can:
1. Wait until assigned as extra block producer at term end. The `MainChainConsensusBehaviourProvider` determines when to trigger NextTerm based on whether the term needs to change. [9](#0-8) 

2. Construct a `Round` with attacker-controlled public keys as miners
3. Create `NextTermInput` with this malicious Round
4. The block passes all validations (only structural checks exist)
5. Execution installs attacker's miners for the next term

The `PreCheck` method only verifies the sender is in the current/previous miner list, allowing a current miner to propose arbitrary future miners. [10](#0-9) 

## Impact Explanation

**CRITICAL - Complete Blockchain Takeover:**

- The attacker can install 100% attacker-controlled nodes as the miner set for the next term
- Once controlling all miners, the attacker achieves complete blockchain control:
  - Censor any transactions
  - Rewrite blockchain history  
  - Halt the chain at will
  - Manipulate all governance mechanisms (Parliament/Association/Referendum)
  - Control all economic mechanisms (Treasury, token issuance, rewards)
  
- The election/voting system becomes completely meaningless as vote results are ignored
- All staked tokens and voting weights become worthless
- All token holders who voted in elections are disenfranchised
- The fundamental DPoS security model is broken

This violates the core security invariant that **only elected miners can participate in consensus**.

## Likelihood Explanation

**HIGH - Routinely Exploitable by Any Current Miner:**

**Attacker Prerequisites:**
- Be a current miner (achievable through normal election initially)
- Wait for rotation to extra block producer position at term end
- Modify node software to construct malicious `NextTermInput`

**Attack Complexity:** LOW
- No cryptographic barriers
- No economic barriers beyond normal block production
- Extra block producer role rotates among all current miners
- Attack is undetectable until after execution (state already poisoned during post-validation)

**Feasibility:** 
- The extra block producer position regularly rotates among miners
- Any term transition provides an opportunity
- The authorization check allows current miners to pass while installing arbitrary future miners

## Recommendation

Add validation in `ProcessNextTerm` to verify the proposed miner list matches the Election contract's `GetVictories()` results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL: Validate miner list matches election results
    if (State.IsMainChain.Value && TryToGetVictories(out var expectedMiners))
    {
        var proposedMiners = new HashSet<string>(nextRound.RealTimeMinersInformation.Keys);
        var electedMiners = new HashSet<string>(
            expectedMiners.Pubkeys.Select(p => p.ToHex())
        );
        
        Assert(proposedMiners.SetEquals(electedMiners), 
            "Proposed miner list does not match election results.");
    }
    
    // ... rest of existing logic
}
```

This ensures that only legitimately elected miners can be installed during term transitions, closing the validation gap between generation and execution paths.

## Proof of Concept

A malicious miner can exploit this by:

1. Monitoring for term transition timing when they are the extra block producer
2. Constructing a malicious `NextTermInput` with arbitrary miner public keys in `RealTimeMinersInformation`
3. Submitting the `NextTerm` transaction with this crafted input
4. The transaction passes `PreCheck` (sender is current miner) and `RoundTerminateValidationProvider` (only checks structural properties)
5. `ProcessNextTerm` installs the malicious miner list without validation
6. Post-execution validation compares against already-poisoned state and passes
7. Attacker now controls 100% of miners for the next term

The vulnerability is exploitable because there is no point in the execution flow where the proposed miner list is validated against `Election.GetVictories()`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-101)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-233)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
