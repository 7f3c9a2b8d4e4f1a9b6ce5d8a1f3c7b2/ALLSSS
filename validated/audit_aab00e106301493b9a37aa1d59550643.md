# Audit Report

## Title
Case-Insensitive Token Uniqueness Bypass via CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function fails to enforce case-insensitive token uniqueness, allowing creation of duplicate tokens with different casing (e.g., "ABC-0" and "abc-0"). This bypasses the protocol's fundamental invariant that token symbols must be case-insensitively unique.

## Finding Description

The MultiToken contract enforces case-insensitive token uniqueness through the `State.InsensitiveTokenExisting` mapping, which stores normalized (uppercase) symbol keys. [1](#0-0) 

Normal token creation properly validates this invariant by calling `CheckTokenExists`, which performs both case-sensitive and case-insensitive checks. [2](#0-1) 

The `CheckTokenExists` function validates token existence using two mechanisms: checking `GetTokenInfo(symbol)` for the exact symbol and asserting `!State.InsensitiveTokenExisting[symbol.ToUpper()]` to prevent case variants. [3](#0-2) 

However, `CrossChainCreateToken` bypasses this protection entirely. It only checks `State.TokenInfos[tokenInfo.Symbol] == null` (case-sensitive) before calling `RegisterTokenInfo`. [4](#0-3) 

When `RegisterTokenInfo` is called, it sets both `State.TokenInfos[tokenInfo.Symbol]` with the exact casing and `State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true`. [5](#0-4) 

This creates two distinct token entries ("ABC-0" and "abc-0") with separate state. The balance and allowance mappings use the symbol string as a key, meaning `State.Balances[address]["ABC-0"]` is completely separate from `State.Balances[address]["abc-0"]`. [6](#0-5) 

Token lookups via `GetTokenInfo` perform case-sensitive searches in `State.TokenInfos[symbolOrAlias]`, so queries for "ABC-0" will not find "abc-0". [7](#0-6) 

## Impact Explanation

**Critical Protocol Invariant Violation**: The system's fundamental guarantee of case-insensitive token uniqueness is broken. This invariant is explicitly enforced in normal token creation paths and is essential for token identification integrity.

**State Fragmentation**: When token "ABC-0" exists, an attacker can create "abc-0" as a completely independent token with:
- Separate token metadata (issuer, owner, total supply, decimals)
- Independent balance mappings for all addresses  
- Distinct allowance configurations
- Different lock whitelist settings

**User and dApp Confusion**: Applications expecting case-insensitive token resolution will interact with unintended tokens. A user searching for "ABC-0" cannot discover "abc-0" exists, leading to asset loss and confusion.

**NFT Collection Fragmentation**: For NFT collections, this enables parallel namespaces where "ABC-0" and "abc-0" can each mint their own item series (ABC-1, ABC-2 vs abc-1, abc-2), fragmenting what should be unified collections.

**Cross-Chain Integrity**: Multi-chain deployments face severe consistency issues when case variants exist on different chains, breaking assumptions for cross-chain transfers and token reconciliation.

## Likelihood Explanation

**Entry Point**: `CrossChainCreateToken` is a publicly accessible method that can be called by any address with valid cross-chain verification data. [8](#0-7) 

**Prerequisites**:
1. Source chain's token contract must be registered in `State.CrossChainTransferWhiteList[fromChainId]` - this is standard configuration in legitimate multi-chain setups. [9](#0-8) 
2. Valid merkle proof and cross-chain verification required through the CrossChain contract. [10](#0-9) 
3. Attacker must be able to create a token on the source chain (typically unrestricted for fungible tokens)

**Attack Execution**: In production multi-chain environments where parent/side chains are properly connected (normal operation), the attack is straightforward:
1. Observe that token "ABC-0" exists on destination chain
2. Create case-variant token "abc-0" on source chain
3. Submit `CrossChainCreateToken` transaction on destination chain with valid merkle proof
4. Bypass succeeds, creating duplicate token

**Assessment**: MEDIUM likelihood - feasible in any multi-chain deployment where chains are legitimately interconnected and the source chain permits token creation. Does not require compromised privileges or system failures.

## Recommendation

Modify `CrossChainCreateToken` to call `CheckTokenExists` before calling `RegisterTokenInfo`, matching the validation used in normal token creation:

```csharp
var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    CheckTokenExists(tokenInfo.Symbol);  // Add this line
    RegisterTokenInfo(tokenInfo);
    // ... rest of the code
}
```

This ensures cross-chain token creation enforces the same case-insensitive uniqueness invariant as local token creation.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitiveBypass_Test()
{
    // Setup: Create token "ABC-0" on destination chain via normal Create
    var createResult = await MainChainTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ABC-0",
        TokenName = "ABC Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true
    });
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Create case-variant token "abc-0" on side chain
    var sideCreateResult = await SideChainTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "abc-0",  // Different case
        TokenName = "abc Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true
    });

    // Prepare cross-chain proof for "abc-0"
    var validateTx = await SideChainTokenContractStub.ValidateTokenInfoExists.SendAsync(
        new ValidateTokenInfoExistsInput { Symbol = "abc-0", /* ... */ });
    
    var merklePath = GetMerklePath(/* ... */);

    // Exploit: CrossChainCreateToken accepts "abc-0" even though "ABC-0" exists
    var crossChainResult = await MainChainTokenContractStub.CrossChainCreateToken.SendAsync(
        new CrossChainCreateTokenInput
        {
            FromChainId = SideChainId,
            TransactionBytes = validateTx.Transaction.ToByteString(),
            MerklePath = merklePath,
            ParentChainHeight = CurrentHeight
        });
    
    // Vulnerability: Both tokens now exist independently
    crossChainResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var tokenABC = await MainChainTokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ABC-0" });
    var tokenabc = await MainChainTokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "abc-0" });
    
    tokenABC.Symbol.ShouldBe("ABC-0");
    tokenabc.Symbol.ShouldBe("abc-0");
    // Two distinct tokens exist, violating case-insensitive uniqueness invariant
}
```

## Notes

This vulnerability fundamentally breaks the token identification system. The `InsensitiveTokenExisting` state variable was explicitly designed to prevent this exact scenario, but `CrossChainCreateToken` does not utilize it. The fix is straightforward: enforce the same validation rules across all token creation entry points.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L19-20)
```csharp
    public MappedState<Address, string, long> Balances { get; set; }
    public MappedState<Address, Address, string, long> Allowances { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-478)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```
