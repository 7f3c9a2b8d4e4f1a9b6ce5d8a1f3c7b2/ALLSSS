# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTerm Allows Mining Reward Manipulation

## Summary
The AEDPoS consensus mechanism fails to validate the `ExtraBlockProducerOfPreviousRound` field during NextTerm block processing. A malicious miner can manipulate this field to grant unauthorized mining privileges and disproportionate rewards to arbitrary miners, directly impacting the fairness of reward distribution.

## Finding Description

The vulnerability stems from a critical validation gap in the NextTerm consensus data verification flow. The `ExtraBlockProducerOfPreviousRound` field grants special mining privileges during the inter-round period, but this field is never validated during block processing.

**Validation Gap Chain:**

The NextTermInput.Create() method blindly copies the field without any verification: [1](#0-0) 

The RoundTerminateValidationProvider, which validates NextTerm blocks, only checks round number, term number, and InValues, completely omitting `ExtraBlockProducerOfPreviousRound`: [2](#0-1) 

The ValidateBeforeExecution method for NextTerm only adds RoundTerminateValidationProvider: [3](#0-2) 

Post-execution validation uses GetCheckableRound() for hash comparison, which explicitly excludes ExtraBlockProducerOfPreviousRound: [4](#0-3) 

**Exploitation Mechanism:**

The manipulated field grants privileged mining access through IsCurrentMiner(): [5](#0-4) 

Each tiny block produced during this privileged window increments the miner's ProducedBlocks counter: [6](#0-5) 

**Attack Flow:**
1. Attacker is legitimately selected to produce a NextTerm block
2. Attacker calls GetConsensusExtraData which generates Round with correct ExtraBlockProducerOfPreviousRound
3. Before finalizing the block, attacker modifies this field to a colluding miner's pubkey (or their own if in the new term)
4. Block passes all validation because no validator checks this field
5. Modified Round is stored in state via ProcessNextTerm
6. Beneficiary miner gains extra mining privileges before round start
7. Extra tiny blocks increment their ProducedBlocks counter
8. At term end, rewards are calculated giving the beneficiary disproportionately high rewards

## Impact Explanation

**Direct Financial Impact:**

Mining rewards in AElf are distributed based on each miner's ProducedBlocks count through the Treasury contract's Basic Miner Reward scheme. The Treasury's UpdateBasicMinerRewardWeights method calculates each miner's share using the CalculateShares function, which directly depends on ProducedBlocks: [7](#0-6) 

The reward calculation mechanism: [8](#0-7) 

By manipulating ExtraBlockProducerOfPreviousRound, an attacker can:
- Grant extra mining time slots to a beneficiary miner (before round officially starts)
- Inflate the beneficiary's ProducedBlocks counter through additional tiny blocks
- Increase the beneficiary's share of Basic Miner Rewards proportionally
- Reduce all other miners' reward shares correspondingly

**Affected Parties:**
- Legitimate extra block producer loses rightful mining privileges and associated rewards
- All honest miners receive proportionally reduced rewards when ProducedBlocks counts are artificially inflated
- Protocol integrity compromised as rewards no longer reflect actual consensus participation

## Likelihood Explanation

**Attack Feasibility: HIGH**

The attack requires only standard miner privileges and is straightforward to execute:

**Attacker Requirements:**
- Must be selected to produce a NextTerm block during their designated time slot (regular consensus operation)

**Execution Steps:**
1. Attacker produces NextTerm block during legitimate time slot
2. Attacker calls GetConsensusExtraData to generate consensus data: [9](#0-8) 

3. Attacker modifies ExtraBlockProducerOfPreviousRound field before finalizing block
4. Block passes all validation (validation gap confirmed)
5. Transaction executes via ProcessNextTerm, storing manipulated Round: [10](#0-9) 

**Detection Impossibility:**
- No pre-execution validator checks this field
- Post-execution hash comparison excludes this field
- No cryptographic signature binds the consensus data structure
- Block appears completely valid to all validation layers

**Economic Rationality:**
- Attack cost: Near zero (single field modification)
- Attack benefit: Direct increase in mining rewards through inflated ProducedBlocks
- Risk: Minimal (no detection mechanism exists)
- Frequency: Executable at every term transition (every 7 days by default)

## Recommendation

Add explicit validation of ExtraBlockProducerOfPreviousRound in the RoundTerminateValidationProvider:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Is next term number correct?
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // Validate ExtraBlockProducerOfPreviousRound matches the block producer
    var expectedProducer = extraData.SenderPubkey.ToHex();
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != expectedProducer)
        return new ValidationResult { Message = "Invalid ExtraBlockProducerOfPreviousRound." };

    return new ValidationResult { Success = true };
}
```

Additionally, include ExtraBlockProducerOfPreviousRound in GetCheckableRound() to enable post-execution hash validation:

```csharp
var checkableRound = new Round
{
    RoundNumber = RoundNumber,
    TermNumber = TermNumber,
    RealTimeMinersInformation = { minersInformation },
    BlockchainAge = BlockchainAge,
    ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound
};
```

## Proof of Concept

A complete test demonstrating this vulnerability would:
1. Set up a test environment with multiple miners
2. Select an attacker miner to produce a NextTerm block
3. Have the attacker call GetConsensusExtraData to get legitimate consensus data
4. Modify the ExtraBlockProducerOfPreviousRound field to a different miner's pubkey
5. Submit the block and verify it passes validation
6. In subsequent rounds, demonstrate the beneficiary miner can produce blocks during inter-round period
7. Show the beneficiary's ProducedBlocks count is artificially increased
8. At term end, verify the beneficiary receives disproportionate rewards from the Treasury contract

The test would confirm that no validation catches the manipulation and that reward distribution is directly affected by the inflated ProducedBlocks counter.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L305-305)
```csharp
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
