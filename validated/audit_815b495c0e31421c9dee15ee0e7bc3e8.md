# Audit Report

## Title
Evil Nodes Bypass Punishment During Term Transitions Due to Missing Banned Pubkey Check in GetVictories Fallback Logic

## Summary
The Election contract's `GetVictories` method contains a critical vulnerability in its fallback logic that allows banned miners (marked as evil nodes) to continue participating in consensus during term transitions. When insufficient valid candidates are available, the method selects backup miners from current miners and initial miners without checking `State.BannedPubkeyMap`, completely bypassing the punishment mechanism.

## Finding Description

The vulnerability exists in the `GetVictories` method's fallback selection logic. When valid candidates are insufficient to fill all miner slots during a term transition, the method falls back to selecting backup miners from current miners and initial miners without verifying whether these nodes have been banned. [1](#0-0) 

The fallback logic at lines 66 and 68-69 directly adds miners from `currentMiners` and `State.InitialMiners` without checking `State.BannedPubkeyMap`. When a node is marked as evil, the `UpdateCandidateInformation` method sets the banned flag and removes the node from candidates, but crucially does NOT remove it from `State.InitialMiners`: [2](#0-1) 

The correct implementation exists in the same file. The `GetMinerReplacementInformation` method properly filters banned pubkeys when selecting from initial miners: [3](#0-2) 

During term transitions, the consensus contract calls `TryToGetVictories` to obtain the new miner list: [4](#0-3) 

This calls the vulnerable `GetVictories` method in the Election contract: [5](#0-4) 

The returned miner list is then directly used to set the new term's miners without additional validation: [6](#0-5) 

The miner replacement mechanism that could potentially catch banned miners only activates during same-term round transitions, NOT during term changes: [7](#0-6) 

## Impact Explanation

This vulnerability has CRITICAL impact on network security and integrity:

1. **Consensus Integrity Violation**: Banned miners (evil nodes) that should be excluded from consensus continue participating in block production across multiple terms, completely defeating the punishment mechanism designed to maintain network security.

2. **Reward Misallocation**: Banned miners continue earning mining rewards despite being marked as malicious actors. The term transition process includes reward distribution: [8](#0-7) 

3. **Long-term Attack Persistence**: Malicious nodes can continue attacking the network across multiple terms without consequences, as long as candidate participation remains low.

4. **Undermined Governance**: The evil node detection and punishment mechanism becomes ineffective, as banned nodes automatically return during term transitions.

The impact affects network security, legitimate miners facing unfair competition, token holders whose rewards fund banned nodes, and overall network trustworthiness.

## Likelihood Explanation

The likelihood of this vulnerability being triggered is HIGH:

**Reachable Entry Point**: Term transitions occur automatically based on blockchain time through the public consensus mechanism. No special privileges are required beyond the normal mining process.

**Feasible Preconditions**:
1. At least one miner marked as evil (realistic - happens through `UpdateCandidateInformation` called by consensus contract when detecting evil behavior or via emergency response organization)
2. Valid candidates < required miners count (realistic during low participation periods, especially in early network stages or periods of low voter engagement)
3. Term transition occurs (happens regularly in normal operation - every term period)

**Automatic Trigger**: The vulnerability triggers deterministically during normal term transitions when insufficient candidates exist. No attacker action is required beyond the initial evil behavior that caused the ban.

**Silent Execution**: The issue occurs without errors or events that would alert operators, making it difficult to detect without explicit monitoring of the banned pubkey map versus active miner lists.

## Recommendation

Add banned pubkey checks to the `GetVictories` fallback logic, similar to the implementation in `GetMinerReplacementInformation`:

```csharp
private List<ByteString> GetVictories(List<string> currentMiners)
{
    var validCandidates = GetValidCandidates();
    List<ByteString> victories;
    var diff = State.MinersCount.Value - validCandidates.Count;
    
    if (diff > 0)
    {
        victories = new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
        
        // Filter banned pubkeys from current miners
        var backups = currentMiners
            .Where(k => !validCandidates.Contains(k))
            .Where(k => !State.BannedPubkeyMap[k])  // ADD THIS CHECK
            .ToList();
            
        if (State.InitialMiners.Value != null)
            backups.AddRange(
                State.InitialMiners.Value.Value.Select(k => k.ToHex())
                    .Where(k => !backups.Contains(k))
                    .Where(k => !State.BannedPubkeyMap[k]));  // ADD THIS CHECK
        
        victories.AddRange(backups.OrderBy(p => p)
            .Take(Math.Min(diff, currentMiners.Count))
            .Select(v => ByteStringHelper.FromHexString(v)));
        return victories;
    }
    
    victories = validCandidates.Select(k => State.CandidateVotes[k])
        .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
        .Take(State.MinersCount.Value).ToList();
    return victories;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BannedMinerBypassesPunishmentDuringTermTransition()
{
    // Setup: Initialize chain with 5 initial miners
    var initialMiners = GenerateMinersPubkey(5);
    await InitializeConsensusWithMiners(initialMiners);
    
    // Step 1: Mark first miner as evil node
    var evilMinerPubkey = initialMiners[0].ToHex();
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = evilMinerPubkey,
            IsEvilNode = true
        });
    
    // Verify miner is banned
    var isBanned = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = evilMinerPubkey });
    isBanned.Value.ShouldBeTrue();
    
    // Step 2: Create scenario with insufficient valid candidates
    // Remove all candidates except 2 (less than MinersCount of 5)
    for (int i = 1; i < 4; i++)
    {
        await ElectionContractStub.QuitElection.SendAsync(
            new StringValue { Value = initialMiners[i].ToHex() });
    }
    
    // Step 3: Trigger term transition
    await NextTerm(ConsensusContractStub);
    
    // Step 4: Verify banned miner is still in active miner list
    var currentMiners = await ConsensusContractStub.GetCurrentMinerList.CallAsync(new Empty());
    var activeMinerPubkeys = currentMiners.Pubkeys.Select(p => p.ToHex()).ToList();
    
    // VULNERABILITY: Banned miner should NOT be in active list but is included
    activeMinerPubkeys.ShouldContain(evilMinerPubkey);
    
    // Step 5: Verify banned miner continues earning rewards
    await ProduceBlocksWithMiner(evilMinerPubkey, 1);
    await NextTerm(ConsensusContractStub);
    
    // Check mining reward was distributed (proving banned miner participated)
    var minerBalance = await GetNativeTokenBalance(evilMinerPubkey);
    minerBalance.ShouldBeGreaterThan(0); // Banned miner received rewards!
}
```

## Notes

The vulnerability is deterministic and will occur whenever a term transition happens with insufficient valid candidates and at least one banned node remaining in the backup pools (`State.InitialMiners` or current miner list). The miner replacement mechanism (`GetMinerReplacementInformation`) only operates during same-term round transitions and cannot prevent this issue during term changes. This represents a fundamental bypass of the punishment system that protects network security.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-76)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
