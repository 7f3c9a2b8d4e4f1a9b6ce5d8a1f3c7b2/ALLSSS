# Audit Report

## Title
Pre-Authorization Resource Exhaustion in SetMethodFee Across All ACS1 Implementations

## Summary
The `SetMethodFee` method in 15 out of 16 ACS1-implementing system contracts performs unbounded input validation with expensive state reads before checking caller authorization, allowing any user to force network validators to perform thousands of state operations before transaction rejection. This creates a pre-authorization resource exhaustion vector affecting critical contracts including MultiToken, Parliament, Association, Election, and others.

## Finding Description

The vulnerability exists in the standard ACS1 implementation pattern where expensive validation operations occur before authorization checks. In MultiToken, the execution flow performs validation before authorization: [1](#0-0) 

The `foreach` loop iterates through all entries in `input.Fees` and invokes `AssertValidFeeToken` for each entry. This validation method performs token verification: [2](#0-1) 

Each call to `GetTokenInfo` performs 1-3 state reads from the contract state: [3](#0-2) 

Only AFTER all validation completes does the authorization check execute, which rejects unauthorized callers. This ordering allows attackers to force expensive operations before being denied access.

**Why Existing Protections Fail:**

The `fees` field is defined as an unbounded repeated field in the protobuf specification: [4](#0-3) 

The ArrayValidator only validates compile-time constant arrays in contract code, not runtime input parameters. The transaction size limit allows up to 5MB transactions: [5](#0-4) 

With approximately 23-50 bytes per MethodFee entry, an attacker can include 100,000+ entries in a single transaction, forcing corresponding state reads before authorization rejection.

**Systemic Scope:**

This pattern affects 15 system contracts identically. For example, Parliament: [6](#0-5) 

Association: [7](#0-6) 

Election: [8](#0-7) 

Only ProfitContract includes a protective count limit: [9](#0-8) [10](#0-9) 

However, even ProfitContract validates BEFORE checking the count limit (line 13 validates, line 14 checks count, line 16 checks authorization). The only exception is NFTContract which implements SetMethodFee as a no-op: [11](#0-10) 

All other contracts (TokenConverter, Treasury, Vote, Configuration, Consensus, CrossChain, Economic, Genesis, TokenHolder, Referendum) follow the same vulnerable pattern.

## Impact Explanation

This vulnerability enables **operational denial-of-service** against the AElf network:

1. **Unauthorized Resource Consumption**: Any user can force validators to perform 100,000+ state reads and validation operations per transaction without authorization
2. **Block Space Exhaustion**: Each malicious transaction consumes up to 5MB of block space
3. **Validator Resource Depletion**: Multiple such transactions can exhaust CPU, memory, and I/O resources across the validator network
4. **Legitimate Transaction Delays**: Resource exhaustion delays processing of legitimate governance, token, and consensus operations

**Affected Critical Components**: MultiToken (token operations), Parliament/Association/Referendum (governance), Election (validator selection), Consensus (AEDPoS), CrossChain (interoperability), Treasury/Profit (fund management), TokenConverter (DEX pricing), and others.

**Severity Rationale**: Medium severity because while exploitation is trivial and affects multiple critical contracts, the attacker must pay transaction fees proportional to size, and cannot permanently disable the network. However, the computational cost of validation (state reads, regex matching, cross-contract calls) likely exceeds the fee charged, creating a cost/damage disparity that enables economically viable attacks.

## Likelihood Explanation

This vulnerability is **highly exploitable**:

1. **Public Entry Point**: `SetMethodFee` is a standard RPC method accessible to all users as defined in the ACS1 specification: [12](#0-11) 

2. **No Preconditions**: Exploitation requires only:
   - Constructing a MethodFees message with a large Fees array
   - Submitting the transaction to any network node
   - No special permissions, tokens, or complex setup needed

3. **Economic Feasibility**: While attackers pay size-based transaction fees, validators perform disproportionately expensive operations (state reads cost more than transaction size suggests). The validation work happens after fee charging but before authorization check, and computational costs are not fully compensated by the size-based fee model.

4. **Detection Difficulty**: Malicious transactions appear as normal failed authorization attempts in logs, making sustained attacks harder to distinguish from legitimate misconfigurations.

## Recommendation

Move authorization checks to occur BEFORE expensive validation operations. The corrected implementation should follow this pattern:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    // 1. Check authorization FIRST
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
    
    // 2. Add input size limit
    Assert(input.Fees.Count <= 10, "Too many fee entries.");
    
    // 3. THEN perform expensive validation
    foreach (var methodFee in input.Fees) 
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    
    // 4. Store validated fees
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

This fix should be applied consistently across all affected contracts: Association, Configuration, Consensus, CrossChain, Economic, Election, Genesis, MultiToken, Parliament, Profit, Referendum, TokenConverter, TokenHolder, Treasury, and Vote.

## Proof of Concept

```csharp
[Fact]
public async Task SetMethodFee_PreAuthResourceExhaustion_Test()
{
    // Attacker creates a MethodFees message with 1000 entries
    var maliciousInput = new MethodFees
    {
        MethodName = "Transfer",
        Fees = { }
    };
    
    // Add 1000 fee entries (within size limit but forces many state reads)
    for (int i = 0; i < 1000; i++)
    {
        maliciousInput.Fees.Add(new MethodFee
        {
            Symbol = "ELF",  // Valid token, will pass validation
            BasicFee = 1000000
        });
    }
    
    // Execute as unauthorized user
    var result = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(maliciousInput);
    
    // Transaction fails with "Unauthorized" as expected
    result.TransactionResult.Error.ShouldContain("Unauthorized");
    
    // BUT: 1000 calls to IsTokenAvailableForMethodFee (and GetTokenInfo) were executed
    // BEFORE the authorization check, forcing 1000-3000 state reads
    // This proves the resource exhaustion occurs before authorization rejection
}
```

**Notes**

This vulnerability represents a fundamental **security design flaw** rather than just a performance issue. The "fail fast" principle dictates that authorization checks should occur before expensive operations to prevent resource exhaustion attacks. The fact that ProfitContract added a count limit (though still after validation) suggests developers recognized this pattern as problematic but didn't systematically address it across all contracts.

The economic viability of this attack stems from the mismatch between transaction fee models (size-based) and actual computational costs (state read-intensive). While AElf's resource token system charges for execution costs, the pre-authorization validation work still represents wasted validator resources that can accumulate under sustained attack.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L15-18)
```csharp
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L123-132)
```csharp
    private void AssertValidFeeToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Token is not found");
        }
        Assert(tokenInfo.IsBurnable, $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** protobuf/acs1.proto (L22-23)
```text
    rpc SetMethodFee (MethodFees) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/acs1.proto (L44-44)
```text
    repeated MethodFee fees = 2;
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L12-15)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L12-15)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L13-16)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L13-16)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-10)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
```
