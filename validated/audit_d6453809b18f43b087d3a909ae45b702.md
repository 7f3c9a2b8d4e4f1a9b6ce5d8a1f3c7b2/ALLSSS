# Audit Report

## Title
NFT Type Inconsistency via Unchecked CrossChainCreate Symbol Format

## Summary
The `NFTContract.CrossChainCreate` method extracts NFT type from the first 2 characters of any symbol without validating symbol format or checking consistency with the token's metadata. Attackers can create tokens via `MultiToken.Create` with arbitrary symbols and NFT metadata, then call `CrossChainCreate` to register NFT protocols with mismatched type information, creating data integrity violations.

## Finding Description

The vulnerability arises from three interconnected design flaws that allow bypassing the intended NFT protocol creation flow:

**Flaw 1: CrossChainCreate blindly extracts NFT type from symbol prefix**

The method extracts the first 2 characters of any symbol and maps them directly to an NFT type without validating that the symbol was generated through the proper NFT creation flow: [1](#0-0) 

The extracted type becomes the authoritative `NftType` field in the protocol, while the token's metadata (copied from ExternalInfo) may contain a different type value: [2](#0-1) 

**Flaw 2: MultiToken.Create accepts arbitrary NFT metadata keys**

The MultiToken contract's reserved keys list explicitly excludes NFT-specific metadata keys: [3](#0-2) 

The NFT-specific metadata keys are defined separately in the NFT contract: [4](#0-3) 

When creating tokens, the MultiToken contract directly accepts input ExternalInfo without validating against NFT-specific keys: [5](#0-4) 

**Flaw 3: No access control on CrossChainCreate**

Unlike the `Create` method (which checks for main chain) and `AddNFTType` (which requires Parliament authority), CrossChainCreate has no sender validation: [6](#0-5) 

**Attack Execution:**

1. Attacker obtains a SEED NFT for symbol "BA999999999" (standard requirement)
2. Attacker calls `MultiToken.Create` with symbol "BA999999999" and ExternalInfo containing `{"aelf_nft_type": "Art", "aelf_nft_base_uri": "...", "aelf_nft_token_id_reuse": "false"}`
3. Token is created successfully - SEED NFT validation passes, and no validation prevents NFT metadata keys in ExternalInfo
4. Attacker calls `NFTContract.CrossChainCreate` with symbol "BA999999999"
5. CrossChainCreate extracts "BA" from the symbol prefix
6. The type mapping converts "BA" to "Badges": [7](#0-6) 

7. NFTProtocolInfo is created with `NftType = "Badges"` while `Metadata["aelf_nft_type"] = "Art"`, creating an inconsistency

This bypasses the intended creation flow where NFTContract.Create ensures consistency by deriving both the symbol prefix and metadata from the same NFT type input: [8](#0-7) 

## Impact Explanation

This vulnerability violates the design invariant that NFT type information must be consistent across all data sources within an NFT protocol. The impact manifests as:

**Data Integrity Violation:**
- NFT protocols contain contradictory type information where `NFTProtocolInfo.NftType` (derived from symbol prefix) differs from `NFTProtocolInfo.Metadata["aelf_nft_type"]` (from token ExternalInfo)
- Applications querying NFT protocol information receive incorrect type classification based on which field they trust

**Ecosystem-Wide Effects:**
- **NFT Marketplaces:** Incorrect filtering and categorization when using the `NftType` field for collection organization
- **DApps and Explorers:** Display wrong NFT categories, creating user confusion
- **Type-Based Logic:** Any future contract or application logic that depends on NFT type classification will behave incorrectly
- **User Trust:** Undermines confidence in the NFT classification system when metadata sources disagree

**Severity Justification: Medium** - This does not directly cause fund loss or privilege escalation, but creates significant data integrity issues that mislead users, break ecosystem applications, and could enable bypasses of any future type-specific policies or restrictions.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker needs a SEED NFT to create tokens with arbitrary symbols (standard, publicly obtainable requirement per the protocol's token creation rules)
- No special privileges, compromised keys, or whitelisting required

**Execution Complexity:**
- Simple two-step attack: call `MultiToken.Create` followed by `NFTContract.CrossChainCreate`
- No timing constraints, race conditions, or complex state manipulation required
- Both methods are public with minimal restrictions (only SEED NFT requirement for token creation)

**Economic Feasibility:**
- Cost: Transaction gas fees + SEED NFT acquisition cost (economically reasonable)
- Detection: Creates valid tokens and protocols through standard contract methods - appears as normal usage
- No anomalous behavior to trigger monitoring alerts

**Probability Justification: High** - The attack path is straightforward, requires only standard resources available to any user, and has no technical barriers preventing execution.

## Recommendation

Implement the following protections to ensure NFT type consistency:

1. **Add sender authorization to CrossChainCreate** - Restrict the method to trusted cross-chain token creation flows or require Parliament approval
2. **Validate symbol format in CrossChainCreate** - Check that the symbol follows the expected NFT protocol symbol format (type prefix + number generated by GetSymbol)
3. **Add NFT metadata keys to MultiToken's reserved list** - Prevent direct token creation with NFT-specific metadata keys unless called through NFTContract
4. **Verify metadata consistency** - In CrossChainCreate, validate that `tokenInfo.ExternalInfo["aelf_nft_type"]` matches the type derived from the symbol prefix

Example fix for CrossChainCreate:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    // Add authorization check
    AssertSenderIsAuthorizedForCrossChainCreate();
    
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput { Symbol = input.Symbol });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    var nftTypeShortName = input.Symbol.Substring(0, 2);
    var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
    if (nftTypeFullName == null)
        throw new AssertionException($"Full name of {nftTypeShortName} not found.");
    
    // Validate metadata consistency
    if (tokenInfo.ExternalInfo.Value.TryGetValue(NftTypeMetadataKey, out var metadataType))
    {
        Assert(metadataType == nftTypeFullName, 
            $"NFT type mismatch: symbol indicates {nftTypeFullName} but metadata contains {metadataType}");
    }
    
    // ... rest of method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NFTTypeInconsistency_Attack()
{
    // Step 1: Attacker obtains SEED NFT for symbol "BA999999999"
    var seedSymbol = await CreateSeedNFT("BA999999999");
    
    // Step 2: Create token via MultiToken.Create with inconsistent metadata
    await TokenContract.Create.SendAsync(new CreateInput
    {
        Symbol = "BA999999999",
        TokenName = "Malicious NFT",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = AttackerAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {"aelf_nft_type", "Art"},  // Claiming to be Art type
                {"aelf_nft_base_uri", "https://example.com/"},
                {"aelf_nft_token_id_reuse", "false"}
            }
        }
    });
    
    // Step 3: Call CrossChainCreate to register NFT protocol
    var result = await NFTContract.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = "BA999999999"
    });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Verify inconsistency
    var protocolInfo = await NFTContract.GetNFTProtocolInfo.CallAsync(new StringValue { Value = "BA999999999" });
    
    // NftType field says "Badges" (from "BA" prefix)
    protocolInfo.NftType.ShouldBe("Badges");
    
    // But metadata says "Art"
    protocolInfo.Metadata.Value["aelf_nft_type"].ShouldBe("Art");
    
    // INCONSISTENCY CONFIRMED: Two different NFT types for the same protocol
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L104-106)
```csharp
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-199)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-9)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L44-53)
```csharp
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
```
