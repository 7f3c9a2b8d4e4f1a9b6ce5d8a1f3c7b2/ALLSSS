# Audit Report

## Title
Missing Contract Address Validation in Governance Proposal Creation Allows Governance DoS

## Summary
The Referendum, Parliament, and Association governance contracts fail to validate whether proposal target addresses correspond to deployed smart contracts. This allows whitelisted proposers to create proposals targeting non-existent contracts or EOA addresses, causing approved proposals to fail during release and temporarily locking voter resources until proposal expiration.

## Finding Description

All three governance contracts validate proposals using a `Validate(ProposalInfo)` method that only checks if `ToAddress != null` without verifying contract existence.

In Referendum, the validation only checks for non-null address without verifying the address corresponds to a deployed contract: [1](#0-0) 

The same insufficient validation exists in Parliament: [2](#0-1) 

And in Association: [3](#0-2) 

When a proposal with an invalid address is approved and released, the system attempts to execute an inline transaction. The `Release` methods call `Context.SendVirtualInlineBySystemContract()` targeting the unvalidated address, followed by the proposal removal: [4](#0-3) 

Similar patterns exist in Parliament: [5](#0-4) 

And Association: [6](#0-5) 

During execution, when the system attempts to get an executive for a non-existent contract address, a `SmartContractFindRegistrationException` is caught and the inline transaction fails with status `ContractError`: [7](#0-6) 

When an inline transaction fails, execution stops and the parent transaction is marked as unsuccessful: [8](#0-7) 

Critically, when a transaction fails due to inline transaction failure, only pre/post plugin state changes are committed to the state cache, NOT the main transaction's state changes: [9](#0-8) 

This behavior is confirmed by test cases showing that when an inline transaction fails, the parent transaction status is `Failed` and no state changes are committed (block state set has 0 changes): [10](#0-9) 

Since the proposal removal operation (`State.Proposals.Remove(input)`) in the Release methods is not committed when the transaction fails, the proposal remains in storage in an approved but perpetually unreleasable state. The proposer can attempt release repeatedly, but it will fail each time until the proposal expires.

For Referendum contracts, voter tokens are locked via `TransferFrom` to the proposal virtual address during voting: [11](#0-10) 

These tokens can only be reclaimed after proposal expiration: [12](#0-11) 

## Impact Explanation

**Governance Disruption (High):** Approved proposals cannot execute their intended governance actions (parameter changes, contract updates, resource allocations), breaking the governance process. This is particularly severe for time-sensitive or critical protocol updates.

**Resource Waste (Medium):** In Referendum contracts, voter tokens remain locked in the proposal virtual address until expiration. While tokens can eventually be reclaimed via `ReclaimVoteToken`, this represents a temporary denial of liquidity for voters and wastes governance participation effort.

**Availability Impact (High):** The proposal enters a deadlock state - it remains approved and cannot be executed, but also cannot be easily cleared until expiration. Repeated release attempts will consistently fail, consuming transaction fees without resolution.

**Scope:** This affects all three core governance contracts (Referendum, Parliament, Association), potentially impacting the entire protocol governance system.

## Likelihood Explanation

**Access Requirements (Medium Constraint):** The attacker must be a whitelisted proposer for the organization, verified by `AssertIsAuthorizedProposer`. While this limits the attack surface, proposers are a larger group than genesis/admin keys and may include:
- Multiple organization members in Association
- Parliament members in Parliament (when `ParliamentMemberProposingAllowed = true`)
- Whitelisted addresses in Referendum

**Execution Complexity (Low):** The attack requires only creating a proposal with a non-existent contract address. This can occur through:
- **Accidental**: Copy-paste errors, typos in addresses, or targeting not-yet-deployed contracts
- **Intentional**: Malicious proposer deliberately wasting governance resources

**Detection Difficulty (Medium):** While voters can inspect `ToAddress` before voting, they may not verify contract existence. The validation gap means the error is only discovered during release, after voting effort is expended.

**Overall Likelihood: MEDIUM** - Feasible for authorized proposers with low complexity, but requires proposer role.

## Recommendation

Add contract existence validation to the `Validate(ProposalInfo)` methods in all three governance contracts. The validation should verify that `ToAddress` corresponds to a deployed smart contract by checking the contract registration.

Example fix for Referendum (similar changes needed for Parliament and Association):

```csharp
private bool Validate(ProposalInfo proposal)
{
    var validDestinationAddress = proposal.ToAddress != null;
    var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
    var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    var hasOrganizationAddress = proposal.OrganizationAddress != null;
    var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
    
    // Add contract existence check
    var isContractDeployed = validDestinationAddress && 
        Context.GetContractAddressByName(SmartContractConstants.GenesisSmartContractSystemName) != null &&
        IsValidContractAddress(proposal.ToAddress);
    
    return validDestinationAddress && isContractDeployed && validDestinationMethodName && 
           validExpiredTime && hasOrganizationAddress && validDescriptionUrl;
}

private bool IsValidContractAddress(Address address)
{
    // Use the Genesis contract to verify if the address is a registered contract
    return State.GenesisContract.GetContractInfo.Call(address) != null;
}
```

## Proof of Concept

The vulnerability is demonstrated by the existing test case `Increase_Value_With_Failed_Inline` which shows that:
1. A transaction that calls a method which sends an inline transaction to a failing target
2. Results in `TransactionResultStatus.Failed`
3. Commits zero state changes (`blockStateSet.Changes.Count.ShouldBe(0)`)

This same pattern applies to governance proposals targeting non-existent contracts - the Release transaction succeeds initially but its inline call to the non-existent contract fails, causing the entire transaction (including `State.Proposals.Remove(input)`) to roll back, leaving the proposal in storage indefinitely.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L39-72)
```csharp
    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,
        Address organizationAddress)
    {
        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null, "Already locked.");

        var lockId = Context.GenerateId(Context.Self,
            HashHelper.ConcatAndCompute(proposalId, HashHelper.ComputeFrom(lockedAddress)));
        RequireTokenContractStateSet();
        Context.SendVirtualInline(proposalId, State.TokenContract.Value,
            nameof(TokenContractContainer.TokenContractReferenceState.TransferFrom), new TransferFromInput
            {
                From = Context.Sender,
                To = GetProposalVirtualAddress(proposalId),
                Symbol = symbol,
                Amount = amount,
                Memo = "Referendum."
            });
        State.LockedTokenAmount[Context.Sender][proposalId] = new Receipt
        {
            Amount = amount,
            LockId = lockId,
            TokenSymbol = symbol
        };

        return new ReferendumReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = proposalId,
            Amount = amount,
            Symbol = symbol,
            Time = Context.CurrentBlockTime,
            OrganizationAddress = organizationAddress
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L115-122)
```csharp
    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L150-161)
```csharp
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L216-246)
```csharp
    private async Task ExecuteInlineTransactions(int depth, Timestamp currentBlockTime,
        ITransactionContext txContext, TieredStateCache internalStateCache,
        IChainContext internalChainContext,
        Hash originTransactionId,
        CancellationToken cancellationToken)
    {
        var trace = txContext.Trace;
        internalStateCache.Update(txContext.Trace.GetStateSets());
        foreach (var inlineTx in txContext.Trace.InlineTransactions)
        {
            var singleTxExecutingDto = new SingleTransactionExecutingDto
            {
                Depth = depth + 1,
                ChainContext = internalChainContext,
                Transaction = inlineTx,
                CurrentBlockTime = currentBlockTime,
                Origin = txContext.Origin,
                OriginTransactionId = originTransactionId
            };

            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;

            internalStateCache.Update(inlineTrace.GetStateSets());
        }
```

**File:** test/AElf.Parallel.Tests/DeleteDataFromStateDbTest.cs (L2101-2140)
```csharp
    public async Task Increase_Value_With_Failed_Inline()
    {
        var accountAddress = await _accountService.GetAccountAsync();
        var chain = await _blockchainService.GetChainAsync();
        await SetIrreversibleBlockAsync(chain);

        const string key = "TestKey";

        var value = await GetValueAsync(accountAddress, key, chain.BestChainHash, chain.BestChainHeight);
        CheckValueNotExisted(value);

        var transaction = await GenerateTransactionAsync(accountAddress,
            ParallelTestHelper.BasicFunctionWithParallelContractAddress,
            nameof(BasicFunctionWithParallelContractContainer.BasicFunctionWithParallelContractStub
                .IncreaseValueWithFailedInline), new IncreaseValueInput
            {
                Key = key,
                Memo = Guid.NewGuid().ToString()
            });
        var transactions = new List<Transaction> { transaction };
        var block = _parallelTestHelper.GenerateBlock(chain.BestChainHash, chain.BestChainHeight, transactions);
        block = (await _blockExecutingService.ExecuteBlockAsync(block.Header, transactions)).Block;
        await _blockchainService.AddTransactionsAsync(transactions);
        await _blockchainService.AddBlockAsync(block);
        await _blockAttachService.AttachBlockAsync(block);

        var transactionResult = await GetTransactionResultAsync(transaction.GetHash(), block.Header);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);

        value = await GetValueAsync(accountAddress, key, block.GetHash(), block.Height);
        CheckValueNotExisted(value);

        var blockStateSet = await _blockStateSetManger.GetBlockStateSetAsync(block.GetHash());
        blockStateSet.Changes.Count.ShouldBe(0);
        blockStateSet.Deletes.Count.ShouldBe(0);

        chain = await _blockchainService.GetChainAsync();
        await SetIrreversibleBlockAsync(chain);
        await CheckValueNotExistedInVersionStateAsync(key);
    }
```
