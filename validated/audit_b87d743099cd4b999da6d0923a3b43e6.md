# Audit Report

## Title
Non-Deterministic FirstActualMiner() Can Cause Consensus Failure During Blockchain Initialization

## Summary
The `FirstActualMiner()` method uses `FirstOrDefault` on an unordered protobuf map without explicit sorting, causing different nodes to potentially select different miners when multiple miners have set their `OutValue` during the round 1 to round 2 transition. This results in divergent blockchain start timestamps being stored on-chain, breaking consensus determinism.

## Finding Description

The vulnerability exists in the `FirstActualMiner()` method which iterates over `RealTimeMinersInformation.Values` without ordering. [1](#0-0) 

The `RealTimeMinersInformation` field is defined as a protobuf map. [2](#0-1) 

Protobuf maps in C# are implemented using `MapField<K,V>` backed by `Dictionary<K,V>`. Dictionary enumeration order in C# is implementation-dependent and not guaranteed to be consistent across different processes, even when deserializing from identical protobuf bytes.

This method is called during the critical transition from round 1 to round 2 to determine the blockchain start timestamp. [3](#0-2) 

During round 1, multiple miners produce blocks and call `UpdateValue`, which sets their `OutValue`. [4](#0-3) 

Without explicit ordering, `FirstOrDefault(m => m.OutValue != null)` returns whichever miner appears first in the dictionary's iteration order. Since multiple miners can have `OutValue != null`, and dictionary iteration order is non-deterministic across processes, different nodes may select different "first actual miners" and calculate different blockchain start timestamps.

The blockchain start timestamp is stored in on-chain state. [5](#0-4)  This state is defined as a readonly timestamp field. [6](#0-5) 

The codebase demonstrates clear awareness of this ordering issue - the same contract uses `OrderBy` in similar situations to ensure deterministic iteration:

- In `GetLatestSignature()`: [7](#0-6) 
- In `CalculateNextExtraBlockProducerOrder()`: [8](#0-7) 
- In `GenerateNextRoundInformation()`: [9](#0-8) 
- In `CheckRoundTimeSlots()`: [10](#0-9) 

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability breaks the fundamental blockchain invariant that all nodes must reach identical state from identical inputs. The blockchain start timestamp is consensus-critical state that affects:

1. **Term change calculations** - determining when to transition to new terms
2. **Blockchain age computation** - used throughout the consensus system  
3. **Miner count growth timing** - when to add more miners to the network
4. **Dividend release schedules** - when side chain dividends are released

When different nodes calculate different blockchain start timestamps, they will:
- Produce different state roots for the same block
- Fail to validate each other's blocks
- Potentially fork the chain into multiple incompatible branches

The failure mode is particularly dangerous because it's silent - nodes won't immediately detect the divergence. The consensus failure will only manifest when blocks start being rejected due to state root mismatches, at which point recovery requires a coordinated chain restart with fixed code.

## Likelihood Explanation

**HIGH Likelihood - Occurs During Normal Operation**

This is not an exploit requiring attacker action - it's a determinism bug that naturally occurs during blockchain initialization:

1. During round 1, miners produce blocks sequentially (normal operation)
2. Each miner that produces a block calls `UpdateValue`, setting their `OutValue`
3. When transitioning to round 2, multiple miners will have `OutValue != null`
4. Each node deserializes the Round state from storage (identical protobuf bytes)
5. Each node calls `FirstActualMiner()` which iterates the dictionary
6. Dictionary iteration order can vary between nodes due to hash randomization
7. Different nodes select different miners as the "first actual miner"

The likelihood is HIGH because:
- No special conditions needed - just normal multi-miner operation
- Dictionary enumeration order IS non-deterministic in C# (confirmed by the codebase's own defensive use of `OrderBy` in similar code paths)
- Single-node test environments won't expose this bug
- Production multi-node networks will hit it during chain initialization

## Recommendation

Add explicit ordering to `FirstActualMiner()` to ensure deterministic iteration across all nodes. The method should sort by a deterministic field (such as `Order`) before selecting the first miner with a non-null `OutValue`:

```csharp
public MinerInRound FirstActualMiner()
{
    return RealTimeMinersInformation.Count > 0
        ? RealTimeMinersInformation.Values.OrderBy(m => m.Order).FirstOrDefault(m => m.OutValue != null)
        : null;
}
```

This change aligns with the defensive coding pattern already used extensively throughout the codebase in similar contexts.

## Proof of Concept

A proof of concept would require a multi-node test environment to expose the non-deterministic behavior. The existing single-node test `AEDPoSContract_FirstRound_Terminate_Test` [11](#0-10)  demonstrates the round 1 to round 2 transition but runs in a single process where Dictionary ordering is consistent.

To reproduce:
1. Set up a multi-node AElf network
2. Initialize the chain with multiple miners
3. Have multiple miners produce blocks during round 1 (setting their `OutValue`)
4. Trigger the round 1 to round 2 transition
5. Compare the `BlockchainStartTimestamp` values stored on different nodes
6. Observe that nodes may have different timestamp values due to non-deterministic dictionary iteration

The bug is deterministic in its non-determinism - it will reliably produce inconsistent results across nodes when multiple miners have produced blocks in round 1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L35-35)
```csharp
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L150-155)
```csharp
    public MinerInRound FirstActualMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.OutValue != null)
            : null;
    }
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L97-98)
```csharp
        var latestSignature = currentRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .LastOrDefault(m => m.Signature != null)?.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-123)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-253)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L85-89)
```csharp
    private void SetBlockchainStartTimestamp(Timestamp timestamp)
    {
        Context.LogDebug(() => $"Set start timestamp to {timestamp}");
        State.BlockchainStartTimestamp.Value = timestamp;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L24-24)
```csharp
    public ReadonlyState<Timestamp> BlockchainStartTimestamp { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-26)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L112-113)
```csharp
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/ACS4ImplTest.cs (L298-317)
```csharp
    public async Task AEDPoSContract_FirstRound_Terminate_Test()
    {
        var transaction =
            (await AEDPoSContract_GenerateConsensusTransactions_FirstRound_ExtraBlockMiner_Test()).Transactions
            .First();

        BlockTimeProvider.SetBlockTime(BlockchainStartTimestamp + new Duration
        {
            Seconds = AEDPoSContractTestConstants.MiningInterval.Mul(AEDPoSContractTestConstants.InitialMinersCount)
                .Div(1000)
        });

        var nextRound = new NextRoundInput();
        nextRound.MergeFrom(transaction.Params);

        await AEDPoSContractStub.NextRound.SendAsync(nextRound);

        var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
        currentRound.RoundNumber.ShouldBe(2);
    }
```
