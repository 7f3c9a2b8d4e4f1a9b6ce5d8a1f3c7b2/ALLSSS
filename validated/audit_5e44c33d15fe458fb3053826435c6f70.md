# Audit Report

## Title
Scheme Manager Can DOS Profit Claiming Through Unlimited Empty Period Creation

## Summary
A malicious scheme manager can repeatedly call `DistributeProfits` with an empty `AmountsMap`, causing period counters to increment indefinitely without distributing any actual profits. This forces beneficiaries to iterate through potentially millions of empty periods when claiming their legitimate profits, making the claiming process economically infeasible due to excessive gas costs, effectively creating a permanent denial-of-service condition.

## Finding Description

The vulnerability exists in the TokenHolder contract's `DistributeProfits` function, which unconditionally increments the period counter regardless of whether any profits were actually distributed. [1](#0-0) 

The critical flaw is that the function conditionally adds `AmountsMap` to the distribution input (line 141), but then unconditionally increments `scheme.Period` (line 144) regardless of whether the map was empty or not. The authorization check confirms that the scheme manager is explicitly authorized to call this function. [2](#0-1) 

In the underlying Profit contract, the `DistributeProfits` function exhibits the same issue: [3](#0-2) 

The only protection is the check on line 485: if the period is negative OR totalShares is zero or less, profits are burned instead. However, in the normal case where a scheme has beneficiaries (totalShares > 0), this check passes and the `CurrentPeriod` is unconditionally incremented on line 494, even when no actual profits were distributed. [4](#0-3) [5](#0-4) 

When beneficiaries attempt to claim profits, they must iterate through all periods from their `LastProfitPeriod` to the scheme's `CurrentPeriod - 1`: [6](#0-5) 

While empty periods are skipped (lines 868-871), they still consume gas during iteration. The maximum number of periods that can be processed per claim transaction is limited by constants: [7](#0-6) [8](#0-7) 

This means approximately 100 periods maximum can be processed per claim (divided by the number of profitable details, which is capped at 10). If a malicious manager creates 1,000,000 empty periods, beneficiaries would need to make approximately 10,000 separate `ClaimProfits` transactions to traverse all empty periods and reach their actual profits.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables a complete economic denial-of-service attack on the profit claiming mechanism:

1. **All scheme beneficiaries are affected**: Every participant who has registered for profits in the scheme becomes a victim
2. **Profits become economically inaccessible**: The cumulative gas cost of making 10,000+ transactions would far exceed the value of small profit amounts, making them permanently inaccessible for most users
3. **No recovery mechanism**: There is no way to skip empty periods in batch or reset the period counter - the damage is permanent once periods are created
4. **Minimal attack cost**: The attacker only pays normal transaction fees for calling `DistributeProfits`, while victims must pay orders of magnitude more to claim
5. **Protocol reputation damage**: Users losing access to legitimate profits severely damages trust in the entire profit distribution system

## Likelihood Explanation

**Likelihood: HIGH**

The attack has extremely high feasibility:

1. **Attacker capability**: The scheme manager role is obtained legitimately during scheme creation. Anyone can create a scheme and become its manager: [9](#0-8) 

2. **Attack complexity**: Trivially low - the attacker simply calls `DistributeProfits` repeatedly with an empty `AmountsMap`. No complex conditions or timing requirements exist.

3. **Preconditions**: The only requirement is that the scheme has at least one beneficiary (totalShares > 0), which is the normal operational state for any active profit scheme.

4. **Detection**: While the attack is visible on-chain (period increments without corresponding profit distribution events), detection doesn't prevent the damage - once empty periods are created, they cannot be removed.

5. **No protections**: There are no rate limits, cooldown periods, or validation checks to prevent empty period creation.

## Recommendation

Add validation to prevent period increment when no profits are actually being distributed:

**In TokenHolderContract.DistributeProfits:**
```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // ADD VALIDATION: Require non-empty AmountsMap
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), 
           "Cannot increment period without distributing profits.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

**In ProfitContract.DistributeProfits:**
Add a check to ensure profitsMap is non-empty before incrementing the period:
```csharp
// Before line 494
Assert(profitsMap.Any() && profitsMap.Values.Any(v => v > 0), 
       "Cannot increment period without distributing profits.");
scheme.CurrentPeriod = input.Period.Add(1);
```

## Proof of Concept

```csharp
[Fact]
public async Task SchemeManager_Can_Create_Empty_Periods_DOS()
{
    // 1. Create a scheme (attacker becomes manager)
    var attacker = Accounts[0].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // 2. Beneficiary registers for profits (creates totalShares > 0)
    var beneficiary = Accounts[1].Address;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = attacker,
        Amount = 1000
    });
    
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(attacker);
    var initialPeriod = scheme.Period;
    
    // 3. Attacker calls DistributeProfits with empty AmountsMap 1000 times
    for (int i = 0; i < 1000; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = attacker,
            AmountsMap = { } // Empty map
        });
    }
    
    // 4. Verify period incremented without distributing profits
    scheme = await TokenHolderContractStub.GetScheme.CallAsync(attacker);
    scheme.Period.ShouldBe(initialPeriod + 1000);
    
    // 5. Beneficiary must now iterate through 1000 empty periods to claim
    // Each ClaimProfits call processes ~100 periods, requiring 10 transactions
    // With 1,000,000 empty periods, this would require 10,000 transactions - a clear DOS
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-499)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");

        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }

        var totalShares = scheme.TotalShares;

        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }

        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");

        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);

        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L822-833)
```csharp
    private int GetMaximumPeriodCountForProfitableDetail(int profitableDetailCount)
    {
        // Get the maximum profit receiving period count
        var maxPeriodCount = GetMaximumProfitReceivingPeriodCount();
        // Check if the maximum period count is greater than the profitable detail count
        // and if the profitable detail count is greater than 0
        return maxPeriodCount > profitableDetailCount && profitableDetailCount > 0
            // Divide the maximum period count by the profitable detail count
            ? maxPeriodCount.Div(profitableDetailCount)
            // If the conditions are not met, return 1 as the maximum period count
            : 1;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L1-10)
```csharp
namespace AElf.Contracts.Profit;

public class ProfitContractConstants
{
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
}
```
