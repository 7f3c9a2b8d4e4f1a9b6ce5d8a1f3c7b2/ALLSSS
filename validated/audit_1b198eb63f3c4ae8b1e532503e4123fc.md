# Audit Report

## Title
Hex Encoding Case Sensitivity Causes Miner DoS Through Candidate Replacement

## Summary
The consensus contract's `RecordCandidateReplacement` method accepts pubkey strings without case normalization, while all block production and validation operations use lowercase hex strings from `.ToHex()`. A candidate admin can replace a miner's pubkey with an uppercase variant, causing the miner to be permanently unable to produce blocks due to dictionary key mismatches, resulting in consensus disruption.

## Finding Description

The vulnerability stems from inconsistent handling of pubkey string case across the Election and Consensus contracts. The AElf codebase consistently generates lowercase hex strings through the `ToHex()` method implementation, which uses arithmetic (`b + 0x37 + 0x20`) that produces lowercase 'a'-'f' characters. [1](#0-0) 

However, the consensus contract's `RecordCandidateReplacement` method directly uses input pubkey strings as dictionary keys without any case normalization. When this method receives an uppercase pubkey string from the Election contract, it removes the old (lowercase) key and adds the new (uppercase) key to `RealTimeMinersInformation`. [2](#0-1) 

During block production, the miner's pubkey is converted to lowercase via `ToHex()` [3](#0-2) , then checked against the miner list [4](#0-3) . The `IsInMinerList` method performs a simple dictionary key check [5](#0-4) , which fails when the dictionary contains the uppercase key but the lookup uses lowercase.

The validation system exhibits the same issue. The `SenderPubkey` property always returns lowercase hex [6](#0-5) , and the mining permission validator checks if this lowercase key exists in the dictionary [7](#0-6) .

The attack entry point is the Election contract's `ReplaceCandidatePubkey` method, which accepts arbitrary string pubkeys without any format validation or case normalization [8](#0-7) . The protobuf definition confirms pubkeys are simple strings with no constraints [9](#0-8) . The Election contract passes these strings directly to the consensus contract [10](#0-9) .

Initial candidate registration always uses lowercase pubkeys from `ToHex()` [11](#0-10) , establishing the baseline that all miner pubkeys in `RealTimeMinersInformation` are lowercase before replacement.

**Attack Sequence:**
1. Attacker (candidate admin) calls `ReplaceCandidatePubkey(oldPubkey="abc123...", newPubkey="ABC123...")`
2. Election contract calls consensus contract's `RecordCandidateReplacement`
3. Consensus contract removes "abc123..." and adds "ABC123..." to `RealTimeMinersInformation`
4. When miner attempts block production, `ToHex()` produces "abc123..." (lowercase)
5. `IsInMinerList` check fails, returns `InvalidConsensusCommand`
6. Mining permission validation fails, preventing block validation
7. Miner is effectively DoS'd from consensus participation

## Impact Explanation

This vulnerability directly disrupts consensus operations with **HIGH** severity:

**Immediate Operational Impact:**
- Affected miner becomes permanently unable to produce blocks until the issue is manually corrected via another replacement transaction
- `GetConsensusCommand` returns `InvalidConsensusCommand`, preventing block production entirely
- Mining permission validation fails, preventing consensus participation even if blocks were somehow produced

**Consensus-Level Impact:**
- Miner misses all assigned time slots, causing block production delays
- Reduces effective miner count, concentrating consensus power among remaining miners
- If multiple miners are targeted, could significantly degrade network performance
- Creates consensus instability and reduces network liveness guarantees

**Affected Parties:**
- Any candidate/miner whose admin performs pubkey replacement with non-lowercase hex
- Can be triggered maliciously by a compromised or malicious admin
- Can occur accidentally if developers use uppercase hex strings from external tools

The severity is HIGH because it directly breaks the core protocol operation (block production) and cannot be recovered without manual intervention or another replacement transaction.

## Likelihood Explanation

This vulnerability has **MEDIUM-HIGH** likelihood of exploitation:

**Attacker Profile:**
- Requires candidate admin role, which is a legitimate, non-privileged position that any candidate can set for themselves
- No special permissions or trusted role required beyond being a candidate's designated admin

**Attack Complexity:**
- Extremely simple: single transaction to `ReplaceCandidatePubkey`
- Only requirement: provide uppercase hex string as new pubkey
- No timing constraints, race conditions, or complex state manipulation needed
- No economic barriers (only transaction fees)

**Feasibility:**
- Candidate being a current miner is a common operational scenario
- Admin permissions are granted by design for legitimate key rotation
- No special blockchain state or conditions required
- Attack can be executed at any time

**Accidental Trigger Risk:**
- Developers using external tools might copy uppercase hex strings (common in Ethereum tooling)
- No input validation prevents accidental misuse
- Error is not immediately apparent until next block production attempt

The combination of simple execution, legitimate attacker role, and potential for accidental triggering makes this a realistic threat to network stability.

## Recommendation

Add case normalization to ensure all pubkey strings are stored in lowercase format:

**In `AEDPoSContract.RecordCandidateReplacement`:**
```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    // Normalize to lowercase
    var oldPubkey = input.OldPubkey.ToLower();
    var newPubkey = input.NewPubkey.ToLower();

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(oldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[oldPubkey];
    realTimeMinerInformation.Pubkey = newPubkey;
    currentRound.RealTimeMinersInformation.Remove(oldPubkey);
    currentRound.RealTimeMinersInformation.Add(newPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == oldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = newPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = newPubkey,  // Already normalized
        NewPubkey = newPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

**Additionally, add validation in `ElectionContract.ReplaceCandidatePubkey`:**
```csharp
// After line 173, add validation
Assert(input.OldPubkey == input.OldPubkey.ToLower() && 
       input.NewPubkey == input.NewPubkey.ToLower(),
       "Pubkeys must be lowercase hex strings.");
```

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseHex_CausesDoS()
{
    // Setup: Announce candidate and make them a miner
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    await AnnounceElectionAsync(candidateKeyPair, candidateAdminAddress);
    
    // Make the candidate a current miner by progressing to next term
    await BootMinerChangeRoundAsync();
    
    // Verify miner can get consensus command before replacement
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = candidateKeyPair.PublicKey });
    consensusCommand.ShouldNotBe(ConsensusCommandProvider.InvalidConsensusCommand);
    
    // Replace with UPPERCASE pubkey
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var uppercasePubkey = newKeyPair.PublicKey.ToHex().ToUpper();
    
    var candidateAdminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = candidateKeyPair.PublicKey.ToHex(),
        NewPubkey = uppercasePubkey  // UPPERCASE - triggers the bug
    });
    
    // Verify: GetConsensusCommand now returns InvalidConsensusCommand
    var newConsensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = newKeyPair.PublicKey });
    newConsensusCommand.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
    
    // Miner is now DoS'd - cannot produce blocks
}
```

### Citations

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L142-143)
```csharp
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L19-19)
```csharp
        _processingBlockMinerPubkey = input.Value.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-17)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** protobuf/election_contract.proto (L504-507)
```text
message ReplaceCandidatePubkeyInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L98-98)
```csharp
        var pubkey = recoveredPublicKey.ToHex();
```
