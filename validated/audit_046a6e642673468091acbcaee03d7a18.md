# Audit Report

## Title
Unbounded Loop DoS in MinersCount Reduction via Branch Count Threshold Exceeded

## Summary
When `MinersCount` is drastically reduced through governance, the `SyncSubsidyInfoAfterReduceMiner` method attempts to remove all excess candidates in a single transaction without batching or upper bound checks. With hundreds of removals, each involving cross-contract calls, the transaction exceeds AElf's 15,000 branch count limit and throws `RuntimeBranchThresholdExceededException`, causing a DoS that prevents legitimate miner count adjustments. [1](#0-0) 

## Finding Description

The vulnerability exists in the `SyncSubsidyInfoAfterReduceMiner` method which performs an unbounded loop over excess candidates when miner count is reduced: [2](#0-1) 

**Execution Flow:**
1. Consensus contract calls `UpdateMinersCount` when miner count changes
2. This triggers `SyncSubsidyInfoAfterReduceMiner` at line 158
3. Method calculates `validDataCenterCount` as `MinersCount * 5` using `GetValidationDataCenterCount()` [3](#0-2) 

4. If `DataCentersRankingList` exceeds this limit, it loops through `diffCount` excess candidates
5. Each iteration calls `RemoveBeneficiary`, which makes a cross-contract call to ProfitContract [4](#0-3) 

6. The ProfitContract's `RemoveBeneficiary` performs additional operations including nested loops [5](#0-4) 

**Why This Causes DoS:**

AElf enforces a **15,000 branch count limit** per transaction to prevent infinite loops. The contract patcher tracks control flow transfers during execution and throws `RuntimeBranchThresholdExceededException` when exceeded: [6](#0-5) 

**Realistic Scenario:**
- Governance sets `MaximumMinersCount` to 100 (no upper limit exists except > 0)
- Over time, 500 candidates join `DataCentersRankingList` (100 * 5)
- Network decides to reduce `MaximumMinersCount` to 1 for operational reasons
- `UpdateMinersCount` attempts to remove 495 candidates (500 - 5)
- With ~30-40 branches per iteration minimum, total branches: 495 * 35 = **17,325** (exceeds 15,000 limit)
- Transaction fails with `RuntimeBranchThresholdExceededException`

**No Protections:**
- No maximum iteration cap on the removal loop
- No batching mechanism for large reductions
- No check against branch count threshold
- Cross-contract calls compound branch count

## Impact Explanation

**Operational Denial of Service:**
- The `UpdateMinersCount` function becomes permanently unusable when large reductions are needed
- Network governance cannot reduce miner count during:
  - Security incidents requiring immediate miner count reduction
  - Network optimization requiring scaling down
  - Economic adjustments necessitating fewer miners
  
**System Availability Impact:**
- Critical governance function is DoS'd
- Network cannot adapt to changing conditions
- Emergency response capabilities are compromised
- Long-term network evolution is blocked

This breaks the **availability guarantee** of governance functions - the system cannot perform legitimate administrative operations when scaling down is required.

## Likelihood Explanation

**High Likelihood in Production:**

The vulnerable state emerges from **legitimate operations**, not malicious actions:

1. **Initial Growth Phase**: Network starts with high `MaximumMinersCount` (e.g., 50-100) to encourage early participation
2. **Natural Accumulation**: Hundreds of candidates announce and receive votes, filling `DataCentersRankingList` up to capacity
3. **Network Maturity**: After establishing security, governance decides to reduce miner count for efficiency
4. **DoS Triggered**: Reduction attempt exceeds branch limit

**Evidence:**
- `MaximumMinersCount` has no hardcoded upper bound (only validated > 0)
- Testing only validates small reductions (10 candidates removed in existing test): [7](#0-6) 

- The branch count limit is enforced and tested at 15,000 iterations: [8](#0-7) 

**Probability: Medium-High** - Any long-running network that needs to scale down miner participation faces this issue.

## Recommendation

Implement batched removal with a configurable iteration limit:

```csharp
private void SyncSubsidyInfoAfterReduceMiner()
{
    var rankingList = State.DataCentersRankingList.Value;
    if (rankingList == null)
        return;
    var validDataCenterCount = GetValidationDataCenterCount();
    if (rankingList.DataCenters.Count <= validDataCenterCount) return;
    
    const int maxRemovalsPerCall = 50; // Safe limit well below branch threshold
    var diffCount = rankingList.DataCenters.Count.Sub(validDataCenterCount);
    var actualRemovalCount = Math.Min(diffCount, maxRemovalsPerCall);
    
    var toRemoveList = rankingList.DataCenters.OrderBy(x => x.Value)
        .Take(actualRemovalCount).ToList();
    
    foreach (var kv in toRemoveList)
    {
        rankingList.DataCenters.Remove(kv.Key);
        RemoveBeneficiary(kv.Key);
    }

    State.DataCentersRankingList.Value = rankingList;
    
    // If more removals needed, require subsequent calls
    if (rankingList.DataCenters.Count > validDataCenterCount)
    {
        Context.Fire(new DataCenterRemovalIncomplete 
        { 
            Remaining = rankingList.DataCenters.Count.Sub(validDataCenterCount) 
        });
    }
}
```

Alternatively, use the existing `RemoveBeneficiaries` batch method if it can be optimized, or allow the consensus contract to call `UpdateMinersCount` incrementally across multiple transactions.

## Proof of Concept

The existing test demonstrates the pattern but only validates small scale (10 removals). To prove the vulnerability, extend the test to realistic scale:

```csharp
[Fact]
public async Task ElectionContract_UpdateMinerCount_LargeReduction_ExceedsBranchLimit_Test()
{
    // Setup: Add 500 candidates to DataCentersRankingList
    var fullCount = 100 * 5; // 500 candidates
    // ... (announce and vote for 500 candidates)
    
    // Trigger: Reduce miner count from 100 to 1
    await ResetMinerCount(1); // validDataCenterCount becomes 5
    
    // Expected: Transaction fails with RuntimeBranchThresholdExceededException
    // when trying to remove 495 candidates in one call
    var result = await NextTerm(InitialCoreDataCenterKeyPairs[0]);
    result.TransactionResult.Error.ShouldContain("RuntimeBranchThresholdExceededException");
}
```

The vulnerability is confirmed by AElf's documented 15,000 branch count limit and the unbounded loop structure that will exceed this limit with hundreds of removals.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L359-377)
```csharp
    private void SyncSubsidyInfoAfterReduceMiner()
    {
        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList == null)
            return;
        var validDataCenterCount = GetValidationDataCenterCount();
        if (rankingList.DataCenters.Count <= validDataCenterCount) return;
        Context.LogDebug(() => "sync DataCenter after reduce bp");
        var diffCount = rankingList.DataCenters.Count.Sub(validDataCenterCount);
        var toRemoveList = rankingList.DataCenters.OrderBy(x => x.Value)
            .Take(diffCount).ToList();
        foreach (var kv in toRemoveList)
        {
            rankingList.DataCenters.Remove(kv.Key);
            RemoveBeneficiary(kv.Key);
        }

        State.DataCentersRankingList.Value = rankingList;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L797-807)
```csharp
    private void RemoveBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var previousSubsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            Beneficiary = beneficiaryAddress,
            ProfitDetailId = previousSubsidyId
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L11-16)
```text
------------------

- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
  The control transfer opcodes in C# contract are shown as below.
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1844-1876)
```csharp
        var fullCount = 5.Mul(5);
        foreach (var keyPair in ValidationDataCenterKeyPairs.Take(fullCount))
        {
            await AnnounceElectionAsync(keyPair);
            await VoteToCandidateAsync(voter, keyPair.PublicKey.ToHex(), lockTime, voteAmount);
            voteAmount = voteAmount.Add(span);
        }

        var minerCount = 3;
        await NextRound(InitialCoreDataCenterKeyPairs[0]);
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.Count.ShouldBe(fullCount);
        var diffCount = fullCount.Sub(minerCount.Mul(5));
        var subsidy = ProfitItemsIds[ProfitType.BackupSubsidy];
        foreach (var keyPair in ValidationDataCenterKeyPairs.Take(diffCount))
        {
            var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
            {
                SchemeId = subsidy,
                Beneficiary = Address.FromPublicKey(keyPair.PublicKey)
            });
            profitDetail.Details[0].EndPeriod.ShouldNotBe(0);
            profitDetail.Details.Count.ShouldBe(1);
        }

        await ResetMinerCount(minerCount);
        await NextTerm(InitialCoreDataCenterKeyPairs[0]);
        var newMinerCount = await ElectionContractStub.GetMinersCount.CallAsync(new Empty());
        newMinerCount.Value.ShouldBe(minerCount);
        var dataCenterListAfterReduceBp =
            await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());

        dataCenterList.DataCenters.Count.Sub(dataCenterListAfterReduceBp.DataCenters.Count).ShouldBe(diffCount);
```

**File:** test/AElf.Contracts.TestContract.Tests/PatchedContractSecurityTests.cs (L388-435)
```csharp
    [Fact]
    public async Task TestBranchCount()
    {
        {
            await TestBasicSecurityContractStub.TestWhileInfiniteLoop.SendAsync(new Int32Input
                { Int32Value = 14999 });
            var txResult = await TestBasicSecurityContractStub.TestWhileInfiniteLoop.SendWithExceptionAsync(
                new Int32Input
                    { Int32Value = 15000 });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }

        {
            await TestBasicSecurityContractStub.TestForInfiniteLoop.SendAsync(new Int32Input { Int32Value = 14999 });
            var txResult = await TestBasicSecurityContractStub.TestForInfiniteLoop.SendWithExceptionAsync(
                new Int32Input
                    { Int32Value = 15000 });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }

        {
            await TestBasicSecurityContractStub.TestForInfiniteLoopInSeparateClass.SendAsync(new Int32Input
                { Int32Value = 14999 });
            var txResult = await TestBasicSecurityContractStub.TestForInfiniteLoop.SendWithExceptionAsync(
                new Int32Input
                    { Int32Value = 15000 });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }

        {
            await TestBasicSecurityContractStub.TestWhileInfiniteLoopWithState.SendAsync(new Int32Input
                { Int32Value = 14999 });
            var txResult =
                await TestBasicSecurityContractStub.TestWhileInfiniteLoopWithState.SendWithExceptionAsync(
                    new Int32Input
                        { Int32Value = 15000 });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }

        {
            await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendAsync(new ListInput
                { List = { new int[14999] } });
            var txResult =
                await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendWithExceptionAsync(
                    new ListInput { List = { new int[15000] } });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }
    }
```
