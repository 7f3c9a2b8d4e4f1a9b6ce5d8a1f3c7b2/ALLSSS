# Audit Report

## Title
Double Removal of Beneficiary Shares Via profitDetailId Bypass of IsWeightRemoved Flag

## Summary
The `RemoveProfitDetails` method in the Profit contract allows a `ProfitDetail` to be removed twice by exploiting special-case logic that bypasses the `IsWeightRemoved` flag protection when a `profitDetailId` is specified. This causes `TotalShares` to be incorrectly reduced twice for the same beneficiary, corrupting profit distribution accounting and enabling remaining beneficiaries to receive inflated shares.

## Finding Description

The vulnerability exists in the `RemoveProfitDetails` private method's handling of profit detail removal. The method implements a two-stage filtering process that contains a critical bypass. [1](#0-0) 

The initial filtering correctly excludes details where `IsWeightRemoved = true`, establishing the intended protection mechanism.

However, subsequent special-case logic explicitly adds a detail by `profitDetailId` without verifying the `IsWeightRemoved` status: [2](#0-1) 

This code only checks: (1) if `profitDetailId` is provided, (2) if a detail with that ID exists in the collection, and (3) if it's not already in `detailsCanBeRemoved` **within the current call**. It does **not** verify whether `IsWeightRemoved` is true from a previous removal.

When a detail has `LastProfitPeriod < CurrentPeriod`, it remains in the collection after removal: [3](#0-2) 

The detail is kept with `IsWeightRemoved = true` and shortened `EndPeriod`, allowing it to be targeted again. The removed shares are accumulated: [4](#0-3) 

The `TryAdd` method correctly accumulates shares within a single call: [5](#0-4) 

However, each call to `RemoveBeneficiary` creates a fresh `removedDetails` dictionary, so the double reduction occurs across two separate calls.

In `RemoveBeneficiary`, the returned dictionary reduces `TotalShares`: [6](#0-5) 

**Attack Sequence:**
1. **First call**: `RemoveBeneficiary(beneficiary, schemeId, null)` - detail marked `IsWeightRemoved = true`, kept in collection if `LastProfitPeriod < CurrentPeriod`, `TotalShares` reduced by X
2. **Second call**: `RemoveBeneficiary(beneficiary, schemeId, detailId)` - lines 333-338 bypass the `IsWeightRemoved` check, detail processed again, `TotalShares` reduced by X again

The authorization check allows both the scheme manager and TokenHolder contract to execute this: [7](#0-6) 

## Impact Explanation

The double reduction of `TotalShares` directly corrupts the profit distribution mathematics. When `DistributeProfits` is called, the artificially reduced `TotalShares` is captured as the denominator for all future claims in that period: [8](#0-7) 

This corrupted value is stored in the distribution record: [9](#0-8) 

When beneficiaries claim profits, they use the formula `(distributedAmount Ã— beneficiaryShares) / TotalShares`: [10](#0-9) [11](#0-10) 

With an artificially low `TotalShares` denominator, each remaining beneficiary receives inflated shares, causing the total claimed amount to exceed the distributed amount. This results in:
- Insufficient balance for late claimers (transaction failures)
- Theft of profits intended for other beneficiaries or sub-schemes
- Permanent corruption of the scheme's accounting

**Concrete Impact**: If scheme has beneficiaries with total 250 shares, double-removing 50 shares reduces `TotalShares` to 150 instead of 200. Distributing 150 tokens with corrupted `TotalShares = 150` allows remaining beneficiaries to claim more than distributed, causing fund exhaustion.

## Likelihood Explanation

**Attacker Prerequisites:**
- Control of scheme manager account OR exploitation of TokenHolder contract
- Beneficiary with `LastProfitPeriod < CurrentPeriod` (common when profits aren't claimed immediately)

**Attack Complexity**: LOW
- No complex timing or state manipulation required
- No multi-contract coordination needed
- Simple two-step process: call `RemoveBeneficiary` twice with same beneficiary, once without `profitDetailId`, once with it

**Feasibility**: HIGH
- Condition `LastProfitPeriod < CurrentPeriod` is standard when beneficiaries haven't claimed recent distributions
- No on-chain validation prevents multiple removals of the same detail
- Scheme manager actions are not externally audited
- `TotalShares` corruption may go undetected until distribution/claiming phase

The vulnerability requires privileged access (scheme manager or TokenHolder), but these are legitimate operational roles in the protocol. A malicious or compromised manager can trivially execute this attack.

## Recommendation

Add an explicit check for `IsWeightRemoved` status before adding a detail by `profitDetailId` in lines 333-338:

```csharp
// Remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    var targetDetail = profitDetails.Details.Single(d => d.Id == profitDetailId);
    // ADD THIS CHECK:
    if (!targetDetail.IsWeightRemoved)
    {
        detailsCanBeRemoved.Add(targetDetail);
    }
}
```

This ensures that already-removed details cannot be re-added to the removal list regardless of how they are specified.

## Proof of Concept

```csharp
[Fact]
public async Task DoubleBeneficiaryRemoval_CorruptsTotalShares_Test()
{
    const long shares = 100;
    var creator = Creators[0];
    var beneficiary = Normal[0];
    var beneficiaryAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);
    
    // Create scheme and add beneficiary with profitDetailId
    var schemeId = await CreateSchemeAsync();
    var detailId = HashHelper.ComputeFrom("test_detail_id");
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiaryAddress, Shares = shares },
        EndPeriod = long.MaxValue,
        ProfitDetailId = detailId
    });
    
    // Verify initial TotalShares
    var schemeBeforeRemoval = await creator.GetScheme.CallAsync(schemeId);
    schemeBeforeRemoval.TotalShares.ShouldBe(shares);
    
    // First removal WITHOUT profitDetailId - marks IsWeightRemoved = true
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress
    });
    
    var schemeAfterFirstRemoval = await creator.GetScheme.CallAsync(schemeId);
    schemeAfterFirstRemoval.TotalShares.ShouldBe(0); // Correctly reduced by 100
    
    // Second removal WITH profitDetailId - bypasses IsWeightRemoved check
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress,
        ProfitDetailId = detailId
    });
    
    // TotalShares incorrectly reduced twice
    var schemeAfterSecondRemoval = await creator.GetScheme.CallAsync(schemeId);
    schemeAfterSecondRemoval.TotalShares.ShouldBe(-shares); // VULNERABILITY: -100 instead of 0
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L333-338)
```csharp
        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-356)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L358-358)
```csharp
                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L462-462)
```csharp
        var totalShares = scheme.TotalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L567-567)
```csharp
        distributedProfitsInformation.TotalShares = totalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-12)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
```
