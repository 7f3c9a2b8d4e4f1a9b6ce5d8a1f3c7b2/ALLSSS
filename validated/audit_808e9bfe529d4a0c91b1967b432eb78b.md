# Audit Report

## Title
Consensus Behavior Spoofing Enables Bypass of UpdateValue Validation Requirements

## Summary
A malicious miner can falsely claim `TinyBlock` behavior in their block header when consensus rules require `UpdateValue` behavior. The validation logic blindly trusts the claimed behavior without verifying it matches the expected behavior calculated from consensus state, allowing miners to bypass OutValue and Signature validation requirements while still receiving block production rewards.

## Finding Description

The AEDPoS consensus mechanism calculates the expected behavior for each miner based on their state in the current round. When a miner has `OutValue == null` and their time slot has not passed, the expected behavior is `UpdateValue`. [1](#0-0) [2](#0-1) 

However, the validation code in `ValidateBeforeExecution` never verifies that the behavior claimed in `extraData.Behaviour` matches this expected behavior. Instead, it blindly trusts the claimed behavior to determine which recovery method to use and which validation providers to apply. [3](#0-2) [4](#0-3) 

The two recovery methods handle data differently: `RecoverFromUpdateValue` restores OutValue, Signature, PreviousInValue, ImpliedIrreversibleBlockHeight, ActualMiningTimes, and order information, [5](#0-4)  while `RecoverFromTinyBlock` only restores ImpliedIrreversibleBlockHeight and ActualMiningTimes. [6](#0-5) 

Critically, the `UpdateValueValidationProvider` that validates OutValue and Signature presence is only added when `extraData.Behaviour == UpdateValue`. [7](#0-6) [8](#0-7) 

When the malicious miner claims `TinyBlock` behavior, transaction generation creates an `UpdateTinyBlockInformation` transaction instead of `UpdateValue`, [9](#0-8)  which calls `ProcessTinyBlock` that increments `ProducedBlocks` but does NOT set OutValue or Signature. [10](#0-9) 

The miner still receives rewards because reward calculation is based on `GetMinedBlocks()` which simply sums all `ProducedBlocks` values without checking OutValue presence. [11](#0-10) [12](#0-11) 

## Impact Explanation

**Consensus Integrity Compromise:**
This vulnerability breaks critical consensus security properties. The random number generation chain relies on miners providing OutValue commitments, which hash to form an unpredictable randomness source. When miners can bypass OutValue requirements, the randomness chain is broken, potentially enabling manipulation of outcomes dependent on random numbers.

Additionally, Signature-based accountability allows the network to cryptographically prove which miner produced each consensus commitment. Bypassing Signature requirements eliminates this verifiable audit trail, reducing miner accountability.

**Economic Unfairness:**
Miners who exploit this vulnerability receive full block production rewards while avoiding cryptographic commitments that honest miners must provide. This creates an unfair advantage where malicious miners reduce their computational/cryptographic overhead while honest miners bear full costs.

**Protocol Invariant Violation:**
The fundamental assumption is that all blocks with `ProducedBlocks > 0` have corresponding OutValue and Signature commitments. This vulnerability breaks that invariant, creating inconsistent state where miners have produced blocks but lack required consensus data.

The severity is **Medium** because while it doesn't directly steal funds, it undermines core consensus integrity, enables selective protocol violation, and degrades the security guarantees that applications depend on.

## Likelihood Explanation

**Attacker Prerequisites:**
The attacker must be an elected miner in the current round, which is achievable through normal election mechanisms. No special privileges beyond standard miner role are required.

**Attack Execution:**
The attack is trivially simple - when generating a block that should use `UpdateValue` behavior, the miner simply sets `Behaviour = TinyBlock` in the consensus extra data. The data generation uses the claimed behavior, [13](#0-12)  so `GetTinyBlockRound` creates simplified data without OutValue/Signature. [14](#0-13) 

**Detection Constraints:**
While other nodes can observe that a miner's OutValue remains null despite producing blocks, there is no automatic rejection or penalty mechanism. The `CountMissedTimeSlots` logic checks for null OutValue, [15](#0-14)  but this runs at term transitions, not during block validation, and the miner has already received rewards for those blocks. Detection requires manual monitoring and governance intervention.

The likelihood is **Medium** - technically simple for any miner to execute, but observable through state monitoring. The lack of automated validation makes exploitation practical, though reputational risk and eventual detection may deter some rational actors.

## Recommendation

Add explicit validation that the claimed behavior matches the expected behavior calculated from consensus state:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // **NEW: Verify claimed behavior matches expected behavior**
    var expectedBehaviour = IsMainChain
        ? new MainChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
                GetMaximumBlocksCount(), Context.CurrentBlockTime, 
                GetBlockchainStartTimestamp(), State.PeriodSeconds.Value)
            .GetConsensusBehaviour()
        : new SideChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
                GetMaximumBlocksCount(), Context.CurrentBlockTime)
            .GetConsensusBehaviour();
    
    if (extraData.Behaviour != expectedBehaviour)
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"Claimed behaviour {extraData.Behaviour} does not match expected behaviour {expectedBehaviour}"
        };

    // Continue with existing validation logic...
    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
    // ... rest of method
}
```

This ensures that miners cannot arbitrarily choose their behavior and must follow the behavior determined by consensus rules.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task MinerCanBypassUpdateValueValidation_ByClaiming_TinyBlock()
{
    // Setup: Initialize consensus with a miner who hasn't produced blocks yet (OutValue == null)
    var minerKeyPair = CryptoHelper.GenerateKeyPair();
    var minerAddress = Address.FromPublicKey(minerKeyPair.PublicKey);
    
    // Miner is in current round but OutValue is null
    var currentRound = await GetCurrentRound();
    var minerInRound = currentRound.RealTimeMinersInformation[minerKeyPair.PublicKey.ToHex()];
    Assert.Null(minerInRound.OutValue); // Miner should provide UpdateValue
    
    // Attack: Miner creates block claiming TinyBlock behavior instead of UpdateValue
    var maliciousExtraData = new AElfConsensusHeaderInformation
    {
        Behaviour = AElfConsensusBehaviour.TinyBlock, // FALSE claim
        SenderPubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        Round = currentRound.GetTinyBlockRound(minerKeyPair.PublicKey.ToHex())
    };
    
    // Validation should reject this, but doesn't
    var validationResult = await ConsensusContract.ValidateConsensusBeforeExecution.CallAsync(
        maliciousExtraData.ToByteString());
    Assert.True(validationResult.Success); // BUG: Validation passes when it should fail
    
    // Execute the malicious block
    await ConsensusContract.UpdateTinyBlockInformation.SendAsync(new TinyBlockInput
    {
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        ProducedBlocks = 1,
        RoundId = currentRound.RoundId
    });
    
    // Verify exploit: Miner's ProducedBlocks incremented but OutValue still null
    var updatedRound = await GetCurrentRound();
    var updatedMiner = updatedRound.RealTimeMinersInformation[minerKeyPair.PublicKey.ToHex()];
    Assert.Equal(1, updatedMiner.ProducedBlocks); // Miner got credit
    Assert.Null(updatedMiner.OutValue); // But didn't provide OutValue commitment
    Assert.Null(updatedMiner.Signature); // Or Signature commitment
    
    // Miner will receive rewards despite bypassing consensus obligations
}
```

This test proves that a miner can claim TinyBlock behavior when they should use UpdateValue, bypass OutValue/Signature validation, and still increment their ProducedBlocks counter that determines rewards.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-56)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L148-163)
```csharp
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L87-96)
```csharp
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```
