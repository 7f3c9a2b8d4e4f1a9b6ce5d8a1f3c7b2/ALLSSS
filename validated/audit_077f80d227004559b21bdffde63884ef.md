# Audit Report

## Title
Replacement Miners Unfairly Penalized in Reward Distribution Due to Missing IsReplacedEvilMiner Flag

## Summary
When evil miners are detected and replaced during consensus round generation, the Treasury contract's `RecordMinerReplacement` method is never called, causing the `IsReplacedEvilMiner` flag to remain unset. This results in replacement miners being penalized by the standard `CalculateShares()` formula that reduces or zeros their reward shares despite joining mid-term to maintain network consensus.

## Finding Description
The vulnerability exists in the evil miner replacement flow spanning the Consensus and Treasury contracts:

**Missing Treasury Notification:**
When the Consensus contract's `GenerateNextRoundInformation` method detects evil miners via `GetMinerReplacementInformation`, it updates the round information and fires events but never notifies the Treasury contract. [1](#0-0)  The replacement happens at the consensus layer (evil miner removed, replacement added), but no call to `TreasuryContract.RecordMinerReplacement` is made.

**Only Call Site is Wrong Context:**
The ONLY call to `RecordMinerReplacement` in the entire codebase is within the `RecordCandidateReplacement` method, which handles voluntary pubkey changes initiated by the Election contract, NOT evil miner detection. [2](#0-1)  This call does not set the `IsOldPubkeyEvil` parameter, meaning it defaults to `false` in the protobuf message. [3](#0-2) 

**Flag Never Set:**
The `IsReplacedEvilMiner` flag is set in the Treasury contract's `RecordMinerReplacement` method for the new pubkey. [4](#0-3)  Since this method is never called during evil miner replacement, the flag remains unset for replacement miners.

**Unfair Reward Penalty:**
During reward distribution in `UpdateBasicMinerRewardWeights`, the absence of the `IsReplacedEvilMiner` flag causes replacement miners to be treated as regular miners. [5](#0-4)  With the flag set, miners receive shares equal to their actual `ProducedBlocks`. Without the flag, they go through `CalculateShares()`, which applies a penalty formula.

**The Penalty Formula:**
The `CalculateShares()` function penalizes miners with below-average block production: [6](#0-5) 
- Returns 0 shares if blocks < average/2
- Returns blocks²/average if blocks < 4*average/5
- Returns blocks only if blocks >= 4*average/5

Since replacement miners join mid-term by definition, they have inherently fewer produced blocks and are severely penalized by this formula despite not being at fault.

## Impact Explanation
**Direct Financial Harm:**
Replacement miners who step in to replace evil miners receive unfair reward distribution:
- **Zero rewards** if joining late enough that their blocks < average/2
- **Quadratically reduced rewards** if blocks < 4*average/5 (e.g., 400 blocks with 1000 average = 160 shares instead of 400)
- **Example**: Joining halfway through a term means producing ~50% of average blocks, resulting in (0.5×average)²/average = 0.25×average shares, losing 75% of fair rewards

**Affected Parties:**
1. Replacement miners providing critical consensus service
2. Their voters/supporters expecting reasonable returns
3. Protocol security - disincentivizes candidates from serving as replacement miners

**Severity:** Medium - Direct financial impact, automatic trigger, undermines evil miner replacement mechanism's effectiveness.

## Likelihood Explanation
**Automatic Trigger:**
This vulnerability triggers automatically whenever the consensus contract detects evil miners during normal operation. Evil miners are identified via the Election contract's `GetMinerReplacementInformation`, which checks the `BannedPubkeyMap`. [7](#0-6) 

**No Attacker Required:**
This is a bug in the legitimate evil miner replacement flow. The issue manifests during:
- Normal consensus operation where miners miss time slots
- Malicious miners being banned
- Any scenario triggering `GenerateNextRoundInformation` with banned miners

**Feasibility:**
- Occurs automatically during consensus round generation
- No special permissions or state manipulation needed
- Happens every time an evil miner is replaced mid-term
- Affects ALL replacement miners in such scenarios

## Recommendation
Add the missing call to `TreasuryContract.RecordMinerReplacement` in the evil miner replacement flow within `GenerateNextRoundInformation`:

After the evil miner replacement loop (after line 339 in AEDPoSContract_ViewMethods.cs), add:

```csharp
// Notify Treasury Contract about the replacement
State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
{
    OldPubkey = evilMinerPubkey,
    NewPubkey = alternativeCandidatePubkey,
    CurrentTermNumber = State.CurrentTermNumber.Value,
    IsOldPubkeyEvil = true
});
```

This ensures the `IsReplacedEvilMiner` flag is properly set, allowing replacement miners to receive fair rewards based on their actual produced blocks without penalty.

## Proof of Concept
A proof of concept would demonstrate:
1. Deploy contracts with initial miners
2. Trigger evil miner detection (e.g., via missed time slots)
3. Observe miner replacement in `GenerateNextRoundInformation`
4. Verify `RecordMinerReplacement` is NOT called
5. At term end, call `UpdateBasicMinerRewardWeights`
6. Observe replacement miner receives penalized shares via `CalculateShares()` instead of full `ProducedBlocks` shares
7. Confirm financial loss for replacement miner despite providing consensus service

The test would validate that replacement miners joining mid-term receive reduced rewards compared to their actual contribution, demonstrating the unfair penalty caused by the missing `IsReplacedEvilMiner` flag.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-342)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** protobuf/treasury_contract.proto (L154-159)
```text
message RecordMinerReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
    int64 current_term_number = 3;
    bool is_old_pubkey_evil = 4;
}
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L583-598)
```csharp
        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L802-812)
```csharp
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```
