# Audit Report

## Title
Retroactive Miner Count Calculation Causes Sudden Jumps When MinerIncreaseInterval is Modified

## Summary
The `SetMinerIncreaseInterval()` function allows governance to decrease the miner increase interval, but the miner count calculation in `GetAutoIncreasedMinersCount()` retroactively applies the new interval to the entire blockchain history. This causes an immediate jump in the miner count instead of a gradual increase, disrupting consensus and diluting mining rewards.

## Finding Description

The vulnerability exists in how the auto-increased miner count is calculated when the miner increase interval is modified by governance.

The `SetMinerIncreaseInterval()` function updates the interval value after validating that it can only be decreased (not increased). [1](#0-0) 

However, `GetAutoIncreasedMinersCount()` uses the CURRENT interval value to divide the ENTIRE elapsed time since blockchain start. [2](#0-1) 

The formula applies `State.MinerIncreaseInterval.Value` to the total blockchain age `(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value)`, meaning when the interval decreases, all historical time gets recalculated with the new interval.

When the interval decreases from 31,536,000 seconds (1 year) to 15,768,000 seconds (6 months) after 2 years have elapsed:
- **Before:** 17 + (63,072,000 / 31,536,000) × 2 = 21 miners
- **After:** 17 + (63,072,000 / 15,768,000) × 2 = 25 miners
- **Result:** Sudden jump of 4 miners

The same retroactive calculation exists in `GetMinersCount()`. [3](#0-2) 

This value propagates to the Election Contract via `UpdateMinersCountToElectionContract()` during term transitions [4](#0-3)  or when `SetMaximumMinersCount()` is called. [5](#0-4) 

The Election Contract stores this value [6](#0-5)  and uses it in `GetVictories()` to determine how many candidates should be selected as miners. [7](#0-6) 

## Impact Explanation

**Consensus Disruption:** The sudden addition of multiple miners (e.g., 4 in the example) changes the consensus participant set abruptly, violating the intended gradual decentralization mechanism that adds only 2 miners per interval. [8](#0-7) 

**Reward Dilution:** Existing miners suddenly experience a significant decrease in mining rewards when the count jumps from 21 to 25 miners, as rewards are distributed among all participants through the Treasury contract's donation mechanism.

**Security Model Violation:** AEDPoS Byzantine fault tolerance calculations depend on the miner count, so sudden jumps affect security assumptions without the network gradually adapting.

**Candidate Selection Error:** Less-qualified candidates who shouldn't yet be eligible become miners immediately, as `GetVictories()` selects based on the jumped count value rather than the intended gradual progression.

**Severity:** MEDIUM - While this doesn't directly steal funds, it violates critical consensus invariants, causes reward misallocation, and disrupts the intended gradual decentralization mechanism.

## Likelihood Explanation

**Trigger Path:** Requires governance approval through `MaximumMinersCountController` (default: Parliament). [9](#0-8) 

**Feasibility:** The governance body may legitimately want to adjust the interval to accelerate decentralization or adapt to network conditions. The validation only allows decreasing the interval, [10](#0-9)  making this a plausible governance action.

**Deterministic:** Once `SetMinerIncreaseInterval()` is called, the bug triggers automatically on the next term transition or `SetMaximumMinersCount()` call.

**Detection:** The jump would be visible in query results, but governance may not realize the retroactive effect until after approval.

**Probability:** MEDIUM to HIGH - If governance ever adjusts the interval for legitimate policy reasons, the bug will trigger with certainty.

## Recommendation

Implement a snapshot mechanism that tracks when the interval was changed and applies different intervals to their respective time periods:

```csharp
// Store interval changes with timestamps
private int GetAutoIncreasedMinersCount()
{
    if (State.BlockchainStartTimestamp.Value == null) 
        return AEDPoSContractConstants.SupposedMinersCount;

    var currentTime = Context.CurrentBlockTime;
    var startTime = State.BlockchainStartTimestamp.Value;
    
    // Calculate additional miners based on interval changes over time
    // Apply old intervals to their respective time periods
    // Only apply new interval to time after the change
    
    var additionalMiners = 0;
    var lastChangeTime = State.LastIntervalChangeTime.Value ?? startTime;
    var previousInterval = State.PreviousMinerIncreaseInterval.Value;
    
    if (lastChangeTime > startTime && previousInterval > 0)
    {
        // Calculate miners added during old interval period
        var oldPeriodSeconds = (lastChangeTime - startTime).Seconds;
        additionalMiners += (int)(oldPeriodSeconds.Div(previousInterval).Mul(2));
        
        // Calculate miners added during new interval period
        var newPeriodSeconds = (currentTime - lastChangeTime).Seconds;
        additionalMiners += (int)(newPeriodSeconds.Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
    else
    {
        // No interval change yet, use current interval
        var totalSeconds = (currentTime - startTime).Seconds;
        additionalMiners = (int)(totalSeconds.Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
    
    return AEDPoSContractConstants.SupposedMinersCount.Add(additionalMiners);
}
```

Also update `SetMinerIncreaseInterval()` to record the change timestamp and previous interval value.

## Proof of Concept

This vulnerability can be demonstrated by:

1. Deploy a test blockchain with initial `MinerIncreaseInterval` of 31,536,000 seconds (1 year)
2. Fast-forward blockchain time by 2 years (63,072,000 seconds)
3. Verify current miner count is 21 (17 + (63,072,000 / 31,536,000) × 2)
4. Submit governance proposal to decrease interval to 15,768,000 seconds (6 months)
5. Execute `SetMinerIncreaseInterval()` after proposal approval
6. Query `GetMinersCount()` or `GetMaximumMinersCount()`
7. Observe immediate jump to 25 miners (17 + (63,072,000 / 15,768,000) × 2)
8. Verify the 4-miner jump occurs instantly rather than gradually over future intervals

## Notes

This is a design flaw in the miner count auto-increase mechanism. The code assumes the interval remains constant throughout blockchain history, which creates unintended consequences when governance exercises its legitimate authority to adjust decentralization speed. The validation that only allows decreasing the interval suggests this functionality is intended for accelerating decentralization, but the retroactive calculation defeats the purpose of gradual, controlled growth of the validator set.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L23-26)
```csharp
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-390)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```
