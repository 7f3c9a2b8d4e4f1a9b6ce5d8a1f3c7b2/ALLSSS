# Audit Report

## Title
Insufficient Validation Allows Duplicate Mining Orders in Consensus Round Transitions

## Summary
The `NextRoundMiningOrderValidationProvider` incorrectly validates uniqueness of mining orders by calling `Distinct()` on entire `MinerInRound` objects instead of on their `FinalOrderOfNextRound` values. Since protobuf-generated classes compare all 17 fields (including `pubkey`), miners with duplicate `FinalOrderOfNextRound` but different public keys pass validation, breaking the fundamental AEDPoS consensus invariant that each miner must have a unique, deterministic time slot.

## Finding Description

The vulnerability exists in the validation logic that checks for duplicate `FinalOrderOfNextRound` values during NextRound transitions. [1](#0-0) 

The validator calls `Distinct()` on `MinerInRound` objects, where `MinerInRound` is a protobuf-generated message type with 17 fields: [2](#0-1) 

Since protobuf equality compares ALL fields, two miners with duplicate `FinalOrderOfNextRound` values but different `pubkey` values (field 9) will be considered distinct objects by the `Distinct()` operation. The validation passes even though there are duplicate mining orders.

**How the Attack Works:**

1. A malicious miner crafts a `NextRoundInput` where multiple miners have the same `FinalOrderOfNextRound` value (e.g., MinerA and MinerB both have order 1)

2. The `ProvidedRound` comes from miner-submitted consensus header data: [3](#0-2) 

3. When validation runs, `Distinct()` checks if entire `MinerInRound` objects are equal. Since each miner has a unique `pubkey`, they are considered distinct even with duplicate orders, and the validation passes.

4. The malicious round is stored to state: [4](#0-3) 

5. When generating the next round, the system orders miners by `FinalOrderOfNextRound`: [5](#0-4) 

With duplicates, multiple miners get assigned the same `Order` value in the generated round.

6. The system treats `FinalOrderOfNextRound` values as "occupied orders" when assigning miners who didn't mine: [6](#0-5) 

With duplicates, this calculation fails - it treats duplicate orders as if only one slot is occupied, causing miners who didn't mine to be assigned to already-occupied orders.

The system's conflict resolution logic in normal operations confirms that `FinalOrderOfNextRound` values are expected to be unique: [7](#0-6) 

## Impact Explanation

This vulnerability directly undermines consensus schedule integrity, a core invariant of the AEDPoS mechanism:

- **Consensus Ambiguity**: Multiple miners assigned the same mining order creates ambiguity about who should mine in each time slot
- **Block Production Conflicts**: Miners with duplicate orders attempt to produce blocks simultaneously, causing scheduling conflicts
- **Network Instability**: The deterministic mining schedule that ensures orderly block production is compromised
- **Protocol Invariant Break**: Violates the fundamental guarantee that each miner has a unique, deterministic time slot

The impact is **Critical** because it breaks a fundamental protocol invariant that the entire consensus mechanism relies upon. Unlike issues affecting individual miners, this creates network-wide consensus instability affecting all participants. The validation is specifically designed to prevent this condition but fails due to incorrect equality semantics.

## Likelihood Explanation

The likelihood is **Medium-High**:

**Attacker Requirements:**
- Must be a miner in the current round (realistic - multiple miners participate in consensus)
- Must be selected to propose NextRound (typically the extra block producer at round transitions)
- This opportunity occurs regularly at every round transition

**Attack Complexity:**
- **Low** - Simply requires constructing a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values
- No complex cryptographic operations needed
- No precise timing requirements beyond being selected for NextRound proposal
- The flawed validation logic accepts the malicious input

**Detection:**
- The validator is specifically designed to check for this condition but fails due to incorrect use of `Distinct()`
- No subsequent validation catches duplicate orders
- The malicious round is accepted into chain state and persisted

The combination of regular opportunity (every round transition), low attack complexity (simple data structure manipulation), and failed validation makes this readily exploitable once a miner is in position to propose NextRound.

## Recommendation

Fix the validation to check uniqueness of `FinalOrderOfNextRound` values specifically, not entire `MinerInRound` objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select the order value only
    .Distinct()
    .Count();
```

This ensures that duplicate `FinalOrderOfNextRound` values are properly detected regardless of differences in other fields like `pubkey`.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a test environment with multiple miners in a round
2. Have some miners produce blocks (set `OutValue`)
3. Craft a `NextRoundInput` where two or more miners have identical `FinalOrderOfNextRound` values (e.g., both set to 1) but different `pubkey` values
4. Submit this as a NextRound transaction
5. Verify that the `NextRoundMiningOrderValidationProvider` validation passes (returns `Success = true`)
6. Verify that the malicious round is stored in state
7. Call `GenerateNextRoundInformation` on this malicious round
8. Verify that the generated next round has multiple miners with the same `Order` value, breaking the uniqueness invariant

The test would demonstrate that the validation fails to catch duplicate mining orders when miners have different public keys, allowing consensus schedule corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```
