# Audit Report

## Title
Next Round Order Manipulation via Unvalidated FinalOrderOfNextRound Values in UpdateValue

## Summary
A malicious miner can manipulate `FinalOrderOfNextRound` values for all miners during `UpdateValue` block production, granting themselves favorable positions (such as first miner or extra block producer) in subsequent rounds. The consensus validation logic fails to verify that order values are correctly calculated from signatures, allowing manipulated values to propagate through the system and determine the next round's mining schedule.

## Finding Description

The vulnerability exists in the AEDPoS consensus update flow where order values for the next round are not cryptographically validated against their expected calculation.

**Block Creation Flow:** When a miner produces an UpdateValue block, `GetUpdateValueRound()` creates a simplified round containing `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` for all miners by copying them directly from the current round state. [1](#0-0) 

**Validation Flow:** During validation in `ValidateBeforeExecution`, the system calls `RecoverFromUpdateValue()` which blindly copies order values from the provided round into consensus state for all miners without any cryptographic validation. [2](#0-1)  The validation provider only checks that `OutValue` and `Signature` are filled, and that `PreviousInValue` is correct - there is no validation that order values match their expected calculation. [3](#0-2) 

**Correct Calculation Not Enforced:** The protocol specifies that `supposedOrderOfNextRound` should be calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, followed by deterministic conflict resolution. [4](#0-3)  However, this calculation is only performed locally during block creation and is never re-validated by other nodes.

**State Persistence:** In `ProcessUpdateValue`, the system directly applies the provided order values and `TuneOrderInformation` without verification. [5](#0-4)  These manipulated values then persist in state and determine the mining schedule for subsequent rounds.

**Ineffective Hash Validation:** The hash check in `ValidateConsensusAfterExecution` compares the header's round with the current round after `RecoverFromUpdateValue` has already copied the manipulated values into the current round, making this check ineffective. [6](#0-5) 

**Direct Impact on Mining Schedule:** The manipulated `FinalOrderOfNextRound` values directly determine the mining order in the next round, as miners are sorted by this field when generating the next round. [7](#0-6) 

**Attack Execution:** A malicious miner modifies their local node to set arbitrary order values in the Round object after `ApplyNormalConsensusData` completes but before block generation. Both the block header (via `GetUpdateValueRound`) and transaction (via `ExtractInformationToUpdateConsensus`) are generated from the same manipulated Round object. [8](#0-7)  They remain internally consistent while violating the protocol's signature-based ordering rules.

## Impact Explanation

**Consensus Integrity Violation:** This vulnerability fundamentally breaks the consensus mechanism's fairness and randomness guarantees. The attacker can arbitrarily determine the mining order for the next round, subverting the cryptographic randomness that should govern block producer selection.

**Direct Economic Impact:**
- The attacker can assign themselves `FinalOrderOfNextRound = 1` to consistently mine first in subsequent rounds
- Mining first provides advantages in capturing block production rewards and transaction fees  
- The attacker can manipulate which miner becomes the extra block producer (who produces an additional block per round)
- Other honest miners suffer reduced mining opportunities and economic rewards

**Severity Justification - CRITICAL:**
1. Any active miner can exploit this without requiring special privileges beyond normal mining rights
2. The attack directly subverts consensus fairness, a core security property
3. It enables sustained reward manipulation across multiple rounds
4. The consensus system's security model fundamentally assumes order values reflect cryptographic randomness from signatures - this assumption is violated

## Likelihood Explanation

**Attacker Capabilities:** Any miner in the active consensus set can execute this attack. The attacker only needs to run a modified node that manipulates the Round object before calling block generation functions.

**Attack Complexity:** Low. The attacker modifies their local consensus client to set desired order values after the correct calculation completes. Both the block header and transaction are generated locally with the same manipulated values, so internal consistency checks pass.

**Feasibility:** The attack is immediately executable. The validation logic has no checks for order value correctness. The hash-based validation only confirms consistency between header and transaction data, not correctness against protocol rules.

**Detection Constraints:** The attack is difficult to detect because manipulated order values pass all existing validation checks. Only manual auditing comparing order assignments against the signature-based calculation formula would reveal the manipulation.

**Economic Rationality:** Attack cost is zero (no additional resources beyond normal block production), while benefits include increased mining rewards and strategic control over consensus timing.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that all order values are correctly calculated from signatures:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation
// After existing checks, add:

// Validate order values are correctly calculated from signatures
foreach (var minerInfo in validationContext.ProvidedRound.RealTimeMinersInformation)
{
    if (minerInfo.Value.Signature != null && minerInfo.Value.SupposedOrderOfNextRound > 0)
    {
        var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
        var sigNum = minerInfo.Value.Signature.ToInt64();
        var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
        
        if (minerInfo.Value.SupposedOrderOfNextRound != expectedOrder)
            return new ValidationResult { 
                Message = $"Invalid SupposedOrderOfNextRound for {minerInfo.Key}" 
            };
    }
}

// Also validate FinalOrderOfNextRound consistency with conflict resolution rules
```

Additionally, validate the `TuneOrderInformation` dictionary in `ProcessUpdateValue` to ensure it only contains legitimate conflict resolutions based on the deterministic algorithm.

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up a test environment with multiple miners in the consensus set
2. Modifying one miner's node to intercept the Round object after `ApplyNormalConsensusData` 
3. Setting arbitrary `FinalOrderOfNextRound` values (e.g., attacker = 1, others = 2,3,4...)
4. Producing an UpdateValue block with the manipulated values
5. Observing that the block passes validation on other nodes
6. Verifying that the next round's mining schedule reflects the manipulated order values

The test would verify that blocks with incorrect order values are currently accepted when they should be rejected, demonstrating the absence of validation that allows this consensus manipulation.

## Notes

The vulnerability is valid because:
- All affected files are in-scope production consensus contract code
- The attack requires only being an active miner (a legitimate role)
- The execution path is fully confirmed with concrete code evidence
- The impact directly breaks consensus fairness and enables reward manipulation
- The likelihood is high with immediate executability by any miner

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-44)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
```
