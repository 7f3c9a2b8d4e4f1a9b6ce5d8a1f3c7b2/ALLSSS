# Audit Report

## Title
Missing Validation of TuneOrderInformation Allows Miners to Corrupt Next Round Mining Schedule

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract directly applies `TuneOrderInformation` values from miner-submitted `UpdateValueInput` to `FinalOrderOfNextRound` without validating that order values are within the valid range [1, minersCount] or checking for duplicates. This allows a malicious miner to inject arbitrary order values that corrupt the mining schedule, causing non-deterministic round generation across nodes and consensus failure.

## Finding Description

The vulnerability exists in the consensus update flow where mining order information for the next round is processed without validation.

When a miner produces a block, they submit an `UpdateValue` transaction containing an `UpdateValueInput` message. This message includes a `tune_order_information` map (defined in the protobuf) that allows setting order values for multiple miners: [1](#0-0) 

In `ProcessUpdateValue`, these values are directly applied to the current round state without any validation: [2](#0-1) 

The validation system for `UpdateValue` behavior only checks cryptographic values (OutValue, Signature, PreviousInValue), not the order information: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` has a critical bug - it calls `.Distinct()` on `MinerInRound` objects instead of on the order values themselves, so it cannot detect duplicate order values: [4](#0-3) 

Since `MinerInRound` is a protobuf-generated class with multiple properties (pubkey, in_value, out_value, etc.), each miner's object is always distinct even when they have identical `FinalOrderOfNextRound` values. [5](#0-4) 

When generating the next round, the corrupted `FinalOrderOfNextRound` values are used directly to determine mining order and timing: [6](#0-5) 

The `OrderBy` operation on line 26 becomes non-deterministic when duplicate order values exist, because the source sequence (dictionary values) has non-deterministic iteration order across different nodes.

## Impact Explanation

This vulnerability breaks consensus integrity with severe network-wide consequences:

**1. Non-Deterministic Round Generation**: When a malicious miner sets duplicate order values (e.g., two miners with `FinalOrderOfNextRound` = 3), different nodes will generate different `nextRound` objects because `OrderBy` preserves the relative order from the source dictionary, which has non-deterministic iteration order. This causes block hash mismatches and consensus failure.

**2. Mining Schedule Corruption**: Out-of-range order values (e.g., Order=999 when there are 7 miners) push affected miners' `ExpectedMiningTime` far into the future, effectively excluding them from consensus and disrupting the intended round-robin mining schedule.

**3. Protocol-Level DoS**: Once the round state is corrupted, all nodes fail to reach consensus on the next round, halting block production. The attack affects the entire network, not just individual participants.

**4. No Recovery Mechanism**: There is no validation or recovery mechanism to detect and correct corrupted order values once they enter the round state.

The attack breaks the fundamental consensus guarantee that all honest nodes agree on the mining schedule and block production order.

## Likelihood Explanation

The vulnerability is highly exploitable:

**Attacker Requirements**: The attacker must be an elected miner in the current miner list. This is verified by `PreCheck()`: [7](#0-6) 

**Attack Complexity**: Low. The attacker only needs to:
1. Modify their consensus client to craft a custom `UpdateValueInput` with malicious `TuneOrderInformation` values
2. Submit the transaction during their legitimate mining time slot

**Method Accessibility**: The `UpdateValue` method is publicly accessible: [8](#0-7) 

**No Prevention**: The validation providers check miner permissions, time slots, and continuous block limits, but none validate the order values: [9](#0-8) 

**Probability**: High. Any malicious miner can execute this attack during their time slot in every round they participate in, with only transaction fee costs.

## Recommendation

Implement comprehensive validation for `TuneOrderInformation` in `ProcessUpdateValue`:

1. **Range Validation**: Verify all order values are within [1, minersCount]
2. **Duplicate Detection**: Ensure no duplicate order values exist
3. **Miner Existence**: Verify keys in `TuneOrderInformation` correspond to actual miners in the round

Add validation code before line 259 in `AEDPoSContract_ProcessConsensusInformation.cs`:

```csharp
// Validate TuneOrderInformation before applying
if (updateValueInput.TuneOrderInformation.Any())
{
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    var proposedOrders = updateValueInput.TuneOrderInformation.Values.ToList();
    
    // Check range
    Assert(proposedOrders.All(order => order >= 1 && order <= minersCount),
        "Order values must be within [1, minersCount]");
    
    // Check duplicates
    Assert(proposedOrders.Count == proposedOrders.Distinct().Count(),
        "Duplicate order values detected");
    
    // Check miner existence
    foreach (var key in updateValueInput.TuneOrderInformation.Keys)
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(key),
            "Unknown miner in TuneOrderInformation");
}
```

Fix `NextRoundMiningOrderValidationProvider` to check order value distinctness:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select order values, not objects
    .Distinct()
    .Count();
```

## Proof of Concept

A complete PoC would require setting up the full AEDPoS consensus test environment. The test would:

1. Initialize a round with N miners (e.g., 7)
2. Have miner A produce a block with a legitimate `UpdateValue` transaction
3. Have miner B produce a block with a malicious `UpdateValueInput` containing `TuneOrderInformation` with duplicate values (e.g., setting both miner C and miner D to order=3)
4. Attempt to generate the next round using `GenerateNextRoundInformation`
5. Demonstrate that different nodes (with different dictionary iteration orders) generate different `nextRound` objects with different hashes

The vulnerability is confirmed through code analysis showing:
- Direct application of unvalidated input at lines 259-260 of `AEDPoSContract_ProcessConsensusInformation.cs`
- Missing validation in all validation providers
- Broken duplicate detection in `NextRoundMiningOrderValidationProvider` at lines 15-16
- Non-deterministic ordering in `Round_Generation.cs` at line 26 when duplicates exist

## Notes

This is a critical consensus vulnerability that can be exploited by any elected miner to halt the blockchain. The root cause is the missing input validation combined with the flawed duplicate detection logic. The attack requires no special privileges beyond being an elected miner, and the impact affects the entire network's ability to reach consensus and produce blocks.

### Citations

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-83)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
