# Audit Report

## Title
Incorrect LIB Index Calculation Violates 2/3 Consensus Threshold in AEDPoS

## Summary
The Last Irreversible Block (LIB) height calculation uses an incorrect index formula that fails to ensure 2/3 consensus when exactly `MinersCountOfConsent` miners have mined. This allows blocks to be finalized with as low as 57% miner agreement instead of the required 67%, violating Byzantine Fault Tolerance guarantees.

## Finding Description

The vulnerability exists in the LIB calculation logic. [1](#0-0)  The algorithm collects implied irreversible heights from miners who mined in the current round, checks if the count meets the minimum threshold, then selects a height using the index formula `(Count - 1) / 3`.

The `MinersCountOfConsent` property is defined as: [2](#0-1) 

**Root Cause:**

For a sorted list of heights [H₀, H₁, ..., Hₙ₋₁], selecting index `i` means that `(n - i)` miners have reported heights ≥ Hᵢ. When using index `(n-1)/3`:

- **For 7 total miners**: MinersCountOfConsent = 5
  - When Count = 5: index = 1, agreeing miners = 4 (57% of 7)
  - Required: 5 miners (67% of 7)
  - **Violation**: 4 < 5

- **For 10 total miners**: MinersCountOfConsent = 7  
  - When Count = 7: index = 2, agreeing miners = 5 (50% of 10)
  - Required: 7 miners (67% of 10)
  - **Violation**: 5 < 7

The check at line 26 only ensures sufficient miners have mined, but doesn't validate that the selected index provides 2/3 consensus. The index formula doesn't align with the MinersCountOfConsent threshold.

## Impact Explanation

This vulnerability compromises the fundamental security guarantees of the consensus system:

1. **Byzantine Fault Tolerance Breakdown**: Blocks can be finalized with only ~57% agreement, breaking the BFT assumption that up to 1/3 malicious nodes can be tolerated.

2. **Irreversible Block Compromise**: The incorrectly calculated LIB triggers the `IrreversibleBlockFound` event, which updates the chain state system-wide. [3](#0-2) 

3. **Cross-Chain Impact**: The LIB is processed and propagated throughout the system, affecting cross-chain verification and state finalization. [4](#0-3) 

4. **No Additional Validation**: The blockchain service accepts the LIB without validating consensus requirements. [5](#0-4) 

The entire security model of Byzantine Fault Tolerance is violated, allowing consensus with insufficient agreement.

## Likelihood Explanation

This vulnerability occurs naturally during normal protocol operation:

1. **Reachable Entry Point**: Triggered when miners call `UpdateValue` during consensus. [6](#0-5) 

2. **Natural Occurrence**: The vulnerable condition manifests when exactly `MinersCountOfConsent` miners have mined in the current round—a common scenario during normal operations.

3. **No Attack Required**: This is a logic bug in the consensus algorithm itself, not requiring any malicious actor.

4. **Frequency**: With 7 miners, the probability that exactly 5 have mined when a miner processes `UpdateValue` is substantial during each consensus round.

5. **Detection Difficulty**: The miscalculation produces a valid block height, making it undetectable without analyzing the consensus mathematics.

## Recommendation

The index formula should ensure that at least `MinersCountOfConsent` miners agree on the selected LIB height. The correct approach is:

**Option 1**: When `Count = MinersCountOfConsent`, use index 0 to ensure all reporting miners agree:
```csharp
libHeight = impliedIrreversibleHeights[0];
```

**Option 2**: Require more miners to report before calculating LIB:
```csharp
if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent + someBuffer)
{
    libHeight = 0;
    return;
}
// Then use a formula that ensures MinersCountOfConsent agreement
```

**Option 3**: Fix the index calculation to ensure proper consensus:
```csharp
// Calculate index to ensure at least MinersCountOfConsent miners agree
var requiredAgreement = _currentRound.MinersCountOfConsent;
var index = impliedIrreversibleHeights.Count - requiredAgreement;
if (index < 0) index = 0;
libHeight = impliedIrreversibleHeights[index];
```

## Proof of Concept

A test demonstrating the vulnerability with 7 miners:

```csharp
[Fact]
public void LIB_Calculation_Violates_Consensus_Threshold()
{
    // Setup: 7 total miners
    var totalMiners = 7;
    var minersCountOfConsent = (totalMiners * 2) / 3 + 1; // = 5
    
    // Exactly MinersCountOfConsent (5) miners have mined
    var impliedHeights = new List<long> { 100, 110, 120, 130, 140 };
    var count = impliedHeights.Count; // = 5
    
    // Current algorithm calculates index
    var index = (count - 1) / 3; // = 1
    var selectedHeight = impliedHeights[index]; // = 110
    
    // Number of miners agreeing (height >= 110)
    var agreeingMiners = count - index; // = 4
    
    // Assert: Only 4 out of 7 miners agree (57%), but need 5 (67%)
    Assert.Equal(4, agreeingMiners);
    Assert.Equal(5, minersCountOfConsent);
    Assert.True(agreeingMiners < minersCountOfConsent); // VIOLATION!
    
    // 4/7 = 57% < 67% required for 2/3 consensus
    var percentageAgreeing = (agreeingMiners * 100) / totalMiners;
    Assert.Equal(57, percentageAgreeing);
    Assert.True(percentageAgreeing < 67); // CONSENSUS VIOLATED!
}
```

## Notes

The vulnerability is mathematically demonstrable and occurs during legitimate consensus operations. The index formula `(Count-1)/3` appears designed for a different consensus model (perhaps where Count represents a larger set). With the current implementation where Count can equal MinersCountOfConsent exactly, insufficient miners agree on the finalized LIB height, violating the 2/3 Byzantine Fault Tolerance requirement that is fundamental to blockchain security.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L54-87)
```csharp
    private async Task ProcessLogEventAsync(Block block, IrreversibleBlockFound irreversibleBlockFound)
    {
        try
        {
            var chain = await _blockchainService.GetChainAsync();

            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;

            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;

            if (chain.LastIrreversibleBlockHeight == irreversibleBlockFound.IrreversibleBlockHeight) return;

            var blockIndex = new BlockIndex(libBlockHash, irreversibleBlockFound.IrreversibleBlockHeight);
            Logger.LogDebug($"About to set new lib height: {blockIndex.BlockHeight} " +
                            $"Event: {irreversibleBlockFound} " +
                            $"BlockIndex: {blockIndex.BlockHash} - {blockIndex.BlockHeight}");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var currentChain = await _blockchainService.GetChainAsync();
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
                }, KernelConstants.UpdateChainQueueName);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to resolve IrreversibleBlockFound event.");
            throw;
        }
    }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockchainService.cs (L281-298)
```csharp
    public async Task SetIrreversibleBlockAsync(Chain chain, long irreversibleBlockHeight,
        Hash irreversibleBlockHash)
    {
        // Create before IChainManager.SetIrreversibleBlockAsync so that we can correctly get the previous LIB info
        var eventDataToPublish = new NewIrreversibleBlockFoundEvent
        {
            PreviousIrreversibleBlockHash = chain.LastIrreversibleBlockHash,
            PreviousIrreversibleBlockHeight = chain.LastIrreversibleBlockHeight,
            BlockHash = irreversibleBlockHash,
            BlockHeight = irreversibleBlockHeight
        };

        var success = await _chainManager.SetIrreversibleBlockAsync(chain, irreversibleBlockHash);
        if (!success)
            return;

        await LocalEventBus.PublishAsync(eventDataToPublish);
    }
```
