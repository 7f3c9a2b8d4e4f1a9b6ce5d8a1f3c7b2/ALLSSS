# Audit Report

## Title
Incorrect Distinct() Usage Allows Duplicate Mining Orders to Pass Validation in NextRound Transition

## Summary
The `NextRoundMiningOrderValidationProvider` incorrectly validates duplicate `FinalOrderOfNextRound` values by applying `Distinct()` to entire `MinerInRound` objects instead of their order values. Since protobuf-generated classes compare all fields for equality, two miners with identical `FinalOrderOfNextRound` but different pubkeys/signatures will not be detected as duplicates, allowing multiple miners to be assigned the same mining time slot and breaking consensus schedule integrity.

## Finding Description

The vulnerability exists in the validation logic that prevents duplicate mining orders during NextRound transitions. [1](#0-0) 

The validation applies `.Distinct()` directly to `MinerInRound` objects from the provided round data. The `MinerInRound` type is a protobuf message with 17 fields including pubkey, order, produced_blocks, in_value, out_value, final_order_of_next_round, and others. [2](#0-1) 

**Root Cause**: Protobuf-generated C# classes implement `Equals()` and `GetHashCode()` by comparing ALL fields. When `.Distinct()` is called on `MinerInRound` objects, two miners (MinerA with pubkey="A" and MinerB with pubkey="B") can both have `FinalOrderOfNextRound = 5`, but `MinerA.Equals(MinerB)` returns false because their pubkeys differ. Thus `.Distinct()` counts them as separate entries even though they have duplicate order values.

**Attack Vector**: During NextRound block production, the validation receives round data from the block producer's consensus extra data. [3](#0-2) [4](#0-3) 

A malicious miner producing the NextRound block can craft a `NextRoundInput` where multiple different `MinerInRound` entries share the same `FinalOrderOfNextRound` value. The flawed validation incorrectly passes this malicious data.

**Consensus Schedule Corruption**: After bypassing validation, the malicious round data is processed. [5](#0-4) [6](#0-5) 

The next round generation directly uses `FinalOrderOfNextRound` to assign each miner's `Order` and `ExpectedMiningTime`. [7](#0-6) 

If two miners have `FinalOrderOfNextRound = 5`, both will be assigned `Order = 5` with identical `ExpectedMiningTime`, causing them to attempt mining at the same time slot.

## Impact Explanation

**Critical Consensus Integrity Violation**: The fundamental invariant of AEDPoS consensus is that each miner has a unique, non-overlapping time slot for block production. This vulnerability directly breaks that invariant by allowing multiple miners to be assigned identical mining orders and expected mining times.

**Cascading Consensus Failure**: When multiple miners attempt to produce blocks at the same time slot, the network experiences consensus confusion. The `occupiedOrders` calculation will incorrectly identify available slots since duplicate orders are not properly tracked: [8](#0-7) 

This potentially causes miners who missed their slot to be assigned to already-occupied positions.

**Persistent State Corruption**: The malicious round data is permanently stored in contract state, and subsequent rounds build upon this corrupted data, perpetuating the consensus schedule breakdown.

## Likelihood Explanation

**Attacker Profile**: Any valid miner in the current round can exploit this vulnerability. No special privileges or capabilities are required beyond being an authorized block producer.

**Attack Opportunity**: Miners rotate through producing blocks, and each miner will eventually get the opportunity to produce the block that triggers NextRound behavior. This is a normal, regular occurrence in the consensus protocol.

**Attack Complexity**: LOW - The attacker simply needs to craft a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values across different miner entries when producing their NextRound block. The validation logic itself is fundamentally flawed, requiring no sophisticated bypass techniques, timing manipulation, or cryptographic attacks.

**Detection Difficulty**: The malicious round data appears structurally valid (all required fields are present, signatures may be valid), and the flaw in the validation logic prevents detection at the protocol level.

## Recommendation

Fix the validation to check for duplicate `FinalOrderOfNextRound` values specifically, not duplicate `MinerInRound` objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select just the order value
    .Distinct()
    .Count();
```

This ensures that two miners cannot have the same `FinalOrderOfNextRound` value, regardless of their other field differences.

## Proof of Concept

```csharp
[Fact]
public void NextRoundValidation_Should_Detect_Duplicate_FinalOrderOfNextRound()
{
    // Setup: Create a round with two miners having duplicate FinalOrderOfNextRound
    var round = new Round
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            ["MinerA"] = new MinerInRound 
            { 
                Pubkey = "MinerA",
                FinalOrderOfNextRound = 5,
                OutValue = Hash.FromString("outA")
            },
            ["MinerB"] = new MinerInRound 
            { 
                Pubkey = "MinerB", 
                FinalOrderOfNextRound = 5,  // Duplicate order!
                OutValue = Hash.FromString("outB")
            }
        }
    };
    
    var context = new ConsensusValidationContext
    {
        ProvidedRound = round
    };
    
    var validator = new NextRoundMiningOrderValidationProvider();
    var result = validator.ValidateHeaderInformation(context);
    
    // Current implementation incorrectly returns Success = true
    // because Distinct() doesn't detect duplicates on full objects
    Assert.False(result.Success); // Should fail but doesn't!
    Assert.Contains("Invalid FinalOrderOfNextRound", result.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```
