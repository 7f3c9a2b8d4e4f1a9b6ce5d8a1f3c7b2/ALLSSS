# Audit Report

## Title
Integer Rounding in Fee Calculation Allows Fee Avoidance Through Transaction Splitting

## Summary
The TokenConverter contract's `Buy()` and `Sell()` functions use `Convert.ToInt64()` for fee calculation, which applies banker's rounding. When the calculated fee is less than 0.5 tokens, it rounds to zero, allowing users to avoid all fees by splitting large transactions into smaller chunks. This causes direct financial loss to the Treasury and prevents the token burn mechanism from functioning as designed.

## Finding Description
The vulnerability exists in the fee calculation logic of both trading functions. The `Buy()` function calculates fees by multiplying the amount to pay by the fee rate and converting to a 64-bit integer [1](#0-0) , while the `Sell()` function uses identical logic for the amount to receive [2](#0-1) .

**Root Cause:** C#'s `Convert.ToInt64()` performs banker's rounding (round to nearest integer, ties to even). When `amountToPay * GetFeeRate()` produces a value less than 0.5, the result rounds to 0. The fee rate is stored as a decimal string validated to be between 0 and 1 [3](#0-2)  and parsed back as decimal [4](#0-3) .

**Why Protections Fail:** The contract enforces no minimum transaction amount. The `PayLimit` parameter in BuyInput is documented as "Limit of cost. If the token required for buy exceeds this value, the buy will be abandoned. And 0 is no limit." [5](#0-4)  This serves only as maximum cost protection, not a minimum transaction size requirement. Similarly, `ReceiveLimit` in SellInput only provides maximum protection [6](#0-5) .

**Fee Handling:** When fees are collected, they are split equally between Treasury donation and token burning [7](#0-6) . However, fee handling only executes when `fee > 0` in both Buy() [8](#0-7)  and Sell() [9](#0-8) .

**Exploitation:** With the standard fee rate of 0.005 (0.5%) defined in the Economic contract constants [10](#0-9) , any transaction where `amountToPay * 0.005 < 0.5` (i.e., `amountToPay < 100`) results in zero fees. A malicious user can split any large transaction into chunks of 100 tokens or less to completely avoid all fees.

## Impact Explanation
**Direct Financial Loss:**
- For a 10,000 token transaction: normal fee = 50 tokens (10,000 × 0.005 = 50)
- Same transaction split into 100 × 100 token trades = 0 total fees (each: Convert.ToInt64(100 × 0.005) = Convert.ToInt64(0.5) = 0)
- 100% fee avoidance achieved through simple transaction splitting

**Protocol Damage:**
- Treasury loses donation revenue that funds protocol operations and dividends
- Token burn mechanism fails to reduce circulating supply, affecting tokenomics
- Systematic exploitation by arbitrage bots and sophisticated traders creates unfair advantages
- Economic model depends on fee collection for sustainability

**Severity Justification (Medium):**
- Direct, quantifiable financial loss to protocol
- Does not compromise token security or consensus mechanisms
- Requires deliberate action but is trivially automatable
- Impact scales linearly with trading volume
- Undermines economic incentives without breaking core functionality

## Likelihood Explanation
**Attacker Profile:** Any user with tokens can exploit this - no special permissions or elevated privileges required.

**Attack Complexity:** Extremely simple:
1. Identify fee rate (publicly readable via `GetFeeRate()` [11](#0-10) )
2. Calculate zero-fee threshold: `amountToPay < 0.5 / feeRate` (100 for 0.5% fee)
3. Split desired transaction amount into sub-threshold chunks
4. Execute multiple `Buy()` or `Sell()` calls

**Economic Feasibility:**
- Transaction costs (gas fees) are typically minimal compared to fee savings on large amounts
- Break-even point is low - profitable for transactions above ~1,000 tokens
- Arbitrage bots can automatically exploit this pattern
- No detection or prevention mechanism exists on-chain

**Probability: High** - The exploit is trivial to execute, economically rational for any significant transaction size, and has no effective countermeasures.

## Recommendation
Implement one or more of the following mitigations:

1. **Use proper rounding:** Replace `Convert.ToInt64()` with explicit ceiling function to ensure fees are always rounded up:
   ```csharp
   var fee = (long)Math.Ceiling(amountToPay * GetFeeRate());
   ```

2. **Enforce minimum transaction amounts:** Add a configurable minimum transaction size to prevent micro-trades:
   ```csharp
   Assert(input.Amount >= State.MinimumTradeAmount.Value, "Transaction amount below minimum.");
   ```

3. **Implement minimum fee:** Ensure a minimum fee is always charged regardless of transaction size:
   ```csharp
   var calculatedFee = Convert.ToInt64(amountToPay * GetFeeRate());
   var fee = Math.Max(calculatedFee, State.MinimumFee.Value);
   ```

The first option (ceiling rounding) is the most straightforward fix that preserves the fee rate semantics while preventing zero-fee transactions.

## Proof of Concept
```csharp
[Fact]
public async Task Buy_Fee_Rounding_Exploit_Test()
{
    // Setup: Initialize contract with 0.5% fee rate
    await CreateWriteToken();
    await InitializeTreasuryContractAsync();
    await InitializeTokenConverterContract();
    await PrepareToBuyAndSell();
    
    // Scenario 1: Normal large transaction pays expected fee
    var normalAmount = 10000L;
    var normalAmountToPay = BancorHelper.GetAmountToPayFromReturn(
        ELFConnector.VirtualBalance, 
        decimal.Parse(ELFConnector.Weight),
        await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress), 
        decimal.Parse(WriteConnector.Weight), 
        normalAmount);
    var expectedNormalFee = Convert.ToInt64(normalAmountToPay * 0.005m);
    
    // Scenario 2: Split transaction avoids all fees
    var splitAmount = 100L; // Just enough to make fee round to 0
    var splitCount = 100; // Same total as normalAmount
    
    // Calculate fee for one split transaction
    var splitAmountToPay = BancorHelper.GetAmountToPayFromReturn(
        ELFConnector.VirtualBalance, 
        decimal.Parse(ELFConnector.Weight),
        await GetBalanceAsync(WriteSymbol, TokenConverterContractAddress), 
        decimal.Parse(WriteConnector.Weight), 
        splitAmount);
    var splitFee = Convert.ToInt64(splitAmountToPay * 0.005m);
    
    // Verify: Split transaction results in ZERO fee due to rounding
    splitFee.ShouldBe(0L);
    
    // Verify: Total fees avoided equals expected normal fee
    var totalFeesAvoided = expectedNormalFee - (splitFee * splitCount);
    totalFeesAvoided.ShouldBe(expectedNormalFee);
    
    // Demonstrate: User can execute split trades with zero total fees
    var treasuryBalanceBefore = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
    
    for (int i = 0; i < splitCount; i++)
    {
        await DefaultStub.Buy.SendAsync(new BuyInput
        {
            Symbol = WriteConnector.Symbol,
            Amount = splitAmount,
            PayLimit = 0
        });
    }
    
    var treasuryBalanceAfter = await TreasuryContractStub.GetUndistributedDividends.CallAsync(new Empty());
    var treasuryIncrease = treasuryBalanceAfter.Value[NativeSymbol] - treasuryBalanceBefore.Value[NativeSymbol];
    
    // Assert: Treasury received ZERO fees despite 10,000 tokens traded
    treasuryIncrease.ShouldBe(0L);
}
```

## Notes
This vulnerability affects both `Buy()` and `Sell()` functions identically. The exploit is particularly concerning because:

1. It's completely permissionless - any user can execute it
2. It's economically rational for any significant trade volume
3. It can be fully automated by trading bots
4. There's no on-chain detection or rate limiting
5. The standard 0.5% fee rate makes the threshold predictably 100 tokens

The issue fundamentally breaks the economic model's assumption that all trades contribute to Treasury funding and token burning. Without this fee collection, the protocol loses a critical revenue stream and the deflationary token mechanism fails to function.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L36-38)
```csharp
        var feeRate = AssertedDecimal(input.FeeRate);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L124-124)
```csharp
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L130-130)
```csharp
        if (fee > 0) HandleFee(fee);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L174-174)
```csharp
        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L183-183)
```csharp
        if (fee > 0) HandleFee(fee);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L214-258)
```csharp
    private void HandleFee(long fee)
    {
        var donateFee = fee.Div(2);
        var burnFee = fee.Sub(donateFee);

        // Donate 0.5% fees to Treasury
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = donateFee
            });
        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Spender = State.DividendPoolContract.Value,
            Amount = donateFee
        });
        State.DividendPoolContract.Donate.Send(new DonateInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Amount = donateFee
        });

        // Transfer to self contract then burn
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = burnFee
            });
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L369-372)
```csharp
    private decimal GetFeeRate()
    {
        return decimal.Parse(State.FeeRate.Value);
    }
```

**File:** protobuf/token_converter_contract.proto (L130-132)
```text
    // Limit of cost. If the token required for buy exceeds this value, the buy will be abandoned.
    // And 0 is no limit.
    int64 pay_limit = 3; 
```

**File:** protobuf/token_converter_contract.proto (L140-142)
```text
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L8-8)
```csharp
    public const string TokenConverterFeeRate = "0.005";
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L9-15)
```csharp
    public override StringValue GetFeeRate(Empty input)
    {
        return new StringValue
        {
            Value = State.FeeRate.Value
        };
    }
```
