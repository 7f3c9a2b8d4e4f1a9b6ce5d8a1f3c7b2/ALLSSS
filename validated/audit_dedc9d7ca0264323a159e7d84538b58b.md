# Audit Report

## Title
Inconsistent Vote Counting Allows MinimalVoteThreshold Bypass Through Stale Votes from Removed Members

## Summary
The Association contract contains a critical vote counting inconsistency in `CheckEnoughVoteAndApprovals()` where approval/rejection/abstention counts filter by current membership, but the total vote count used for MinimalVoteThreshold validation does not. This allows proposals to pass using stale votes from members removed after voting, effectively bypassing governance participation requirements.

## Finding Description

When members vote on a proposal, their address is added to the proposal's vote lists (approvals, rejections, or abstentions). [1](#0-0) 

Members can later be removed from the organization through `RemoveMember()`, which removes them from `organization.OrganizationMemberList` but does NOT modify any existing proposal vote lists. [2](#0-1) 

The vulnerability exists in `CheckEnoughVoteAndApprovals()` which validates proposal thresholds:

**Approval counting (filtered by current membership):** [3](#0-2) 

**Total vote counting (NOT filtered):** [4](#0-3) 

The same filtering pattern applies to rejections [5](#0-4)  and abstentions [6](#0-5) , which both filter by current membership.

This inconsistency means votes from removed members DO NOT count toward approval/rejection/abstention thresholds but DO count toward the MinimalVoteThreshold requirement, breaking the governance guarantee that MinimalVoteThreshold ensures adequate participation from current members.

## Impact Explanation

**Governance Security Control Bypass:** MinimalVoteThreshold is a critical parameter ensuring adequate participation before proposal execution. This vulnerability undermines that control by allowing stale votes to satisfy the threshold.

**Concrete Attack Scenario:**
- Organization: 10 members, MinimalVoteThreshold = 6, MinimalApprovalThreshold = 4
- Proposal receives 4 approvals from current members (meeting approval threshold)
- 2 additional members vote (any type)
- Organization removes those 2 members via governance
- When `Release()` is called:
  - Current member approvals: 4 ≥ 4 ✓ (filtered count)
  - Total votes: 6 ≥ 6 ✓ (unfiltered count includes removed members)
  - Proposal executes successfully
- **Expected behavior:** With only 4 current member votes, should fail MinimalVoteThreshold of 6

**Severity:** High - Directly violates governance invariant that thresholds reflect current member participation, allowing unauthorized proposal execution.

## Likelihood Explanation

**Preconditions:**
- Proposal must receive votes
- Members must then be removed

**Execution Path:**
`RemoveMember()` requires `Context.Sender` to equal the organization address (governance action). [7](#0-6) 

**Attack Vectors:**
1. **Malicious Collusion:** Members coordinate to vote, then use governance to remove voters and manipulate threshold calculations
2. **Unintentional Trigger:** Legitimate member removal during normal operations (removing inactive members, restructuring) after votes are cast

**Probability:** Medium-High - While requiring governance action, this can occur through both malicious coordination and routine member management, making it a realistic threat.

## Recommendation

Modify `CheckEnoughVoteAndApprovals()` to filter the total vote count by current membership, maintaining consistency with approval/rejection/abstention counting:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership
    var totalCurrentMemberVotes = 
        proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalCurrentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinimalVoteThreshold_Bypass_Via_RemovedMember_Votes()
{
    // Setup: Organization with 10 members, MinimalVoteThreshold=6, MinimalApprovalThreshold=4
    var organizationAddress = await CreateOrganizationAsync(4, 6, 1, 1, Reviewer1);
    
    // Create proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // 4 current members approve (meets MinimalApprovalThreshold)
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Reviewer3KeyPair, proposalId);
    await ApproveAsync(DefaultSenderKeyPair, proposalId);
    
    // 2 additional members vote (to reach MinimalVoteThreshold=6)
    var member5 = Accounts[4].Address;
    var member6 = Accounts[5].Address;
    await ApproveAsync(Accounts[4].KeyPair, proposalId);
    await ApproveAsync(Accounts[5].KeyPair, proposalId);
    
    // Remove those 2 members through governance
    var organizationStub = GetAssociationContractTester(organizationAddress);
    await organizationStub.RemoveMember.SendAsync(member5);
    await organizationStub.RemoveMember.SendAsync(member6);
    
    // Attempt to release - should FAIL (only 4 current member votes < 6 threshold)
    // But actually SUCCEEDS due to bug (counts removed member votes)
    var reviewer1Stub = GetAssociationContractTester(Reviewer1KeyPair);
    var releaseResult = await reviewer1Stub.Release.SendAsync(proposalId);
    
    // BUG: This should fail but passes
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Only 4 current members voted but proposal passed with MinimalVoteThreshold=6
}
```

## Notes

The vulnerability specifically affects the `MinimalVoteThreshold` governance parameter in Association organizations. While `RemoveMember()` requires governance authorization, this makes the issue exploitable through both malicious coordination and unintentional operational changes. Organizations with strict participation requirements are particularly vulnerable, as they may unknowingly execute proposals with insufficient current member participation.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```
