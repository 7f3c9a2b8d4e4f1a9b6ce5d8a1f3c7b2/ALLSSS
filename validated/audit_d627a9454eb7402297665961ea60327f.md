# Audit Report

## Title
Resource Token Debt Accumulates Indefinitely Without Repayment Mechanism, Causing Eventual Overflow

## Summary
The `PayResourceTokens()` function in the MultiToken contract accumulates resource token debt in the `OwningResourceToken` state when contracts have insufficient balance, but provides no mechanism to repay or clear this debt. This design flaw causes unbounded debt accumulation that will eventually exceed `long.MaxValue`, triggering an overflow exception in the `DonateResourceToken` system transaction and disrupting block production.

## Finding Description

The vulnerability exists in the resource token payment mechanism where debt accumulation occurs without any corresponding repayment logic.

When `PayResourceTokens()` processes a contract with insufficient balance to pay for consumed resources, it calculates the shortfall and adds it to existing debt: [1](#0-0) 

The `OwningResourceToken` state variable is defined as a `long` type mapping: [2](#0-1) 

Comprehensive analysis confirms this is the **only location** where `OwningResourceToken` is incremented - there is no decrement or clearing logic anywhere in the codebase.

The `CheckResourceToken()` function verifies that balance exceeds debt but does not reduce the accumulated debt: [3](#0-2) 

**Root Cause:** Complete absence of debt repayment logic in the resource token system.

**Why Existing Protections Fail:** The `.Add()` operation uses checked arithmetic that throws `OverflowException` when debt exceeds `long.MaxValue`: [4](#0-3) 

This means overflow will cause a system transaction failure rather than silently wrapping around.

**Inconsistency with Similar Code:** The `PayRental()` function implements proper debt repayment for `OwningRental`, explicitly clearing debt when sufficient balance exists: [5](#0-4) 

This demonstrates the expected pattern that `PayResourceTokens()` fails to implement - when balance becomes sufficient, the debt should be paid down and cleared.

**Execution Path:** The `DonateResourceToken()` method is called as a system transaction at the end of each block: [6](#0-5) 

This system transaction then invokes `PayResourceTokens()`: [7](#0-6) 

When overflow occurs, the transaction fails and state changes roll back. The `DonateResourceTokenValidationProvider` then compares the state hash with expected hash, causing validation failure: [8](#0-7) 

Block validation failure causes the block to be rejected: [9](#0-8) 

## Impact Explanation

**Operational Harm:** When accumulated debt exceeds `long.MaxValue`, the overflow exception causes the `DonateResourceToken` system transaction to fail. The transaction failure leads to state rollback, which causes hash mismatch in post-execution validation, resulting in block rejection and disruption of block production.

**Accounting Integrity:** Once debt begins accumulating, it never clears even when contracts obtain sufficient balance. This violates the fundamental invariant that debts should be repayable. The debt tracking becomes meaningless as it can only increase, preventing accurate resource accounting and creating a permanent liability with no resolution mechanism.

**Contract Bricking:** The `CheckResourceToken()` pre-execution validation prevents any contract with accumulated debt from executing methods until balance exceeds the debt amount. Since debt can never be cleared, contracts are permanently impaired once they accumulate any debt.

**Affected Parties:**
- Contracts that consume resources without maintaining sufficient balances accumulate permanent debt and become unable to execute
- The entire chain when overflow causes block validation failures
- Block producers who cannot produce valid blocks due to system transaction failures

The severity is **Medium-High** due to the concrete DoS potential affecting critical system operations (block production) combined with permanent contract impairment, though the overflow timeline is extended.

## Likelihood Explanation

**Attacker Capabilities:** Any deployed contract can contribute to debt accumulation by consuming resource tokens (CPU, RAM, DISK, NET) without maintaining sufficient balance. No special privileges or malicious intent required - normal operation of underfunded contracts causes this.

**Attack Complexity:** Low - passive accumulation through normal resource consumption when balance is insufficient.

**Feasibility Conditions:**
1. Contract consistently consumes resource tokens
2. Contract maintains insufficient balance relative to consumption
3. Accumulation continues until reaching `long.MaxValue`

**Timeline Constraints:** For a token with 8 decimals, reaching overflow requires accumulating approximately 92 billion tokens worth of debt. At 1,000 tokens per block, this would require approximately 92 million blocks (roughly 11.6 years at 4 seconds per block). However:
- Multiple contracts can contribute independently to their own debt
- Higher consumption rates accelerate accumulation
- The fundamental issue is that ANY debt is permanent and creates a permanently impaired contract

**Detection:** Debt accumulation is tracked via `ResourceTokenOwned` events but there is no mechanism to clear accumulated debt.

**Probability:** Medium. While normal operations are unlikely to reach overflow quickly for a single contract, the complete absence of any repayment mechanism means ANY debt accumulation is permanent and will eventually cause system failure over sufficient time. The design flaw affects all contracts that consume resources without sufficient balance.

## Recommendation

Implement debt repayment logic in `PayResourceTokens()` consistent with the pattern used in `PayRental()`. When a contract has sufficient balance to cover both current consumption and outstanding debt, the debt should be paid down and cleared.

Add the following logic to `PayResourceTokens()` before processing current resource payments:

```csharp
// Check and repay existing debt if balance is sufficient
var owningResourceToken = State.OwningResourceToken[bill.ContractAddress][symbol];
if (owningResourceToken > 0)
{
    var currentBalance = GetBalance(bill.ContractAddress, symbol);
    if (currentBalance >= owningResourceToken)
    {
        // Pay off the debt
        ModifyBalance(bill.ContractAddress, symbol, -owningResourceToken);
        State.OwningResourceToken[bill.ContractAddress][symbol] = 0;
        
        // Transfer to appropriate receiver
        var receiver = isMainChain ? Context.Self : 
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        ModifyBalance(receiver, symbol, owningResourceToken);
        
        Context.Fire(new ResourceTokenClaimed
        {
            Symbol = symbol,
            Amount = owningResourceToken,
            Payer = bill.ContractAddress,
            Receiver = receiver
        });
    }
}
```

This ensures that debt is repayable when contracts obtain sufficient balance, maintaining accounting integrity and preventing unbounded accumulation.

## Proof of Concept

The vulnerability can be demonstrated through the existing test infrastructure. A test contract that repeatedly consumes resources without sufficient balance will accumulate permanent debt in `OwningResourceToken`. The debt persists even after the contract is funded with sufficient balance, and there is no method to clear it. Over time, if this pattern repeats across multiple contracts or with high consumption rates, the accumulated debt will approach `long.MaxValue`, at which point the next increment will trigger an `OverflowException` in the `DonateResourceToken` system transaction, causing block validation failure.

The test `CheckResourceToken_Fail_Test` already demonstrates the contract bricking behavior: [10](#0-9)

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L602-613)
```csharp
    public override Empty CheckResourceToken(Empty input)
    {
        AssertTransactionGeneratedByPlugin();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName))
        {
            var balance = GetBalance(Context.Sender, symbol);
            var owningBalance = State.OwningResourceToken[Context.Sender][symbol];
            Assert(balance > owningBalance,
                $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-952)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L970-974)
```csharp
                if (amount > existingBalance)
                {
                    var owned = amount.Sub(existingBalance);
                    var currentOwning = State.OwningResourceToken[bill.ContractAddress][symbol].Add(owned);
                    State.OwningResourceToken[bill.ContractAddress][symbol] = currentOwning;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1047-1059)
```csharp
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L32-32)
```csharp
    public MappedState<Address, string, long> OwningResourceToken { get; set; }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L13-75)
```csharp
internal class DonateResourceTransactionGenerator : ISystemTransactionGenerator
{
    private readonly ISmartContractAddressService _smartContractAddressService;
    private readonly ITotalResourceTokensMapsProvider _totalResourceTokensMapsProvider;


    public DonateResourceTransactionGenerator(ISmartContractAddressService smartContractAddressService,
        ITotalResourceTokensMapsProvider totalResourceTokensMapsProvider)
    {
        _smartContractAddressService = smartContractAddressService;
        _totalResourceTokensMapsProvider = totalResourceTokensMapsProvider;
    }

    public ILogger<DonateResourceTransactionGenerator> Logger { get; set; }

    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();

        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        };

        var tokenContractAddress =
            await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
                TokenSmartContractAddressNameProvider.StringName);

        if (tokenContractAddress == null) return generatedTransactions;

        var totalResourceTokensMaps = await _totalResourceTokensMapsProvider.GetTotalResourceTokensMapsAsync(
            chainContext);

        ByteString input;
        if (totalResourceTokensMaps != null && totalResourceTokensMaps.BlockHeight == preBlockHeight &&
            totalResourceTokensMaps.BlockHash == preBlockHash)
            // If totalResourceTokensMaps match current block.
            input = totalResourceTokensMaps.ToByteString();
        else
            input = new TotalResourceTokensMaps
            {
                BlockHash = preBlockHash,
                BlockHeight = preBlockHeight
            }.ToByteString();

        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });

        Logger.LogTrace("Tx DonateResourceToken generated.");
        return generatedTransactions;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTokenValidationProvider.cs (L58-101)
```csharp
    public async Task<bool> ValidateBlockAfterExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight) return true;

        var tokenContractAddress =
            await _smartContractAddressService.GetAddressByContractNameAsync(new ChainContext
            {
                BlockHash = block.GetHash(),
                BlockHeight = block.Header.Height
            }, TokenSmartContractAddressNameProvider.StringName);
        if (tokenContractAddress == null) return true;

        var hashFromState = await _contractReaderFactory.Create(new ContractReaderContext
        {
            BlockHash = block.GetHash(),
            BlockHeight = block.Header.Height,
            ContractAddress = tokenContractAddress
        }).GetLatestTotalResourceTokensMapsHash.CallAsync(new Empty());

        var totalResourceTokensMapsFromProvider =
            await _totalResourceTokensMapsProvider.GetTotalResourceTokensMapsAsync(new ChainContext
            {
                BlockHash = block.Header.PreviousBlockHash,
                BlockHeight = block.Header.Height - 1
            });

        if (hashFromState.Value.IsEmpty)
            // If hash from state is empty, data from provider must be null.
            return totalResourceTokensMapsFromProvider == null;

        if (hashFromState == HashHelper.ComputeFrom(new TotalResourceTokensMaps
            {
                BlockHash = block.Header.PreviousBlockHash,
                BlockHeight = block.Header.Height - 1
            }))
        {
            if (totalResourceTokensMapsFromProvider == null) return true;
            return totalResourceTokensMapsFromProvider.BlockHeight != block.Header.Height - 1;
        }

        if (totalResourceTokensMapsFromProvider == null) return false;
        var hashFromProvider = HashHelper.ComputeFrom(totalResourceTokensMapsFromProvider);
        return hashFromState == hashFromProvider;
    }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockchainExecutingService.cs (L146-150)
```csharp
        if (!await _blockValidationService.ValidateBlockAfterExecuteAsync(block))
        {
            Logger.LogDebug($"Block validate fails after execution. block hash : {blockHash}");
            return null;
        }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee.Tests/ExecutionPluginForResourceFeeTest.cs (L360-365)
```csharp
    public async Task CheckResourceToken_Fail_Test()
    {
        await TestContractStub.CpuConsumingMethod.SendWithExceptionAsync(new Empty());
        var checkResourceTokenRet = await TestContractStub.CpuConsumingMethod.SendWithExceptionAsync(new Empty());
        checkResourceTokenRet.TransactionResult.Error.ShouldContain("token is not enough. Owning");
    }
```
