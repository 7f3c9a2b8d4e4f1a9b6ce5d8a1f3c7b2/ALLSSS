# Audit Report

## Title
Consensus Breakdown via Duplicate Mining Orders Through Broken Validation and Lagrange Interpolation Failure

## Summary
A malicious miner can manipulate `TuneOrderInformation` in `UpdateValue` to assign duplicate `FinalOrderOfNextRound` values to multiple miners. The validation system fails to detect these duplicates due to multiple bugs, leading to duplicate `Order` values in subsequent rounds. This causes consensus protocol breakdown through `GetMiningInterval()` returning 0 milliseconds and Lagrange interpolation failures in secret sharing, ultimately halting the entire blockchain network.

## Finding Description

This vulnerability exploits a complete absence of validation for `TuneOrderInformation` combined with a broken duplicate detection mechanism.

**Attack Vector 1: Unvalidated TuneOrderInformation**

When a miner calls `UpdateValue`, the `ProcessUpdateValue` method directly applies arbitrary `TuneOrderInformation` without any validation: [1](#0-0) 

A malicious miner can craft `UpdateValueInput` with `TuneOrderInformation` that sets multiple miners' `FinalOrderOfNextRound` to the same value (e.g., setting both MinerA and MinerB to `FinalOrderOfNextRound = 1`).

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, completely ignoring `TuneOrderInformation`: [2](#0-1) 

**Attack Vector 2: Broken Duplicate Detection**

The `NextRoundMiningOrderValidationProvider` contains a critical bug where it calls `.Distinct()` on `MinerInRound` objects rather than on their `FinalOrderOfNextRound` values: [3](#0-2) 

Since `MinerInRound` is a protobuf-generated class that doesn't override `Equals()` or `GetHashCode()`, this uses reference equality. Each `MinerInRound` object is already distinct by reference, so this never detects duplicate `FinalOrderOfNextRound` values. Additionally, this validation checks `providedRound` (the next round) where `FinalOrderOfNextRound` is not even set, making it effectively a no-op.

**Attack Vector 3: Duplicate Orders Propagate to Next Round**

When `GenerateNextRoundInformation` creates the next round, it directly uses each miner's `FinalOrderOfNextRound` to assign their `Order`: [4](#0-3) 

If multiple miners have the same `FinalOrderOfNextRound`, they receive identical `Order` values in the next round, with identical `ExpectedMiningTime` values calculated based on that order.

**Impact 1: GetMiningInterval() Returns 0**

The `GetMiningInterval()` method retrieves miners with `Order == 1` or `Order == 2`: [5](#0-4) 

When two miners have `Order == 1`, the list contains both miners with identical `ExpectedMiningTime`. The interval calculation `(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)` returns 0 milliseconds, breaking all time-slot calculations throughout the consensus protocol.

**Impact 2: Lagrange Interpolation Failure**

During secret sharing reconstruction, `RevealSharedInValues` extracts the `Order` values from miners: [6](#0-5) 

When duplicate orders exist in this list, `DecodeSecret` fails because the Lagrange interpolation formula requires distinct x-coordinates: [7](#0-6) 

When `orders[j] == orders[i]` with `i != j`, the denominator `orders[j] - orders[i]` becomes 0. This propagates through the rational arithmetic, eventually calling `Inverse(0)`: [8](#0-7) 

`Inverse(0)` returns 0, making the entire Lagrange basis polynomial term evaluate to 0, producing incorrect secret reconstruction that breaks the commit-reveal randomness scheme.

## Impact Explanation

**Severity: HIGH** - Complete consensus breakdown and network halt.

1. **Mining Interval Collapse**: A 0-millisecond mining interval makes it impossible for miners to determine their time slots. Multiple miners believe they should mine simultaneously, causing:
   - Time slot validation failures across the network
   - Block production conflicts
   - Inability to progress to subsequent rounds
   - Complete consensus halt

2. **Secret Sharing Compromise**: Incorrect Lagrange interpolation produces wrong `InValue` reconstructions, undermining:
   - The verifiable randomness generation scheme
   - Detection of dishonest miners
   - Validation of previous in-values
   - Security properties of the consensus algorithm

3. **Network-Wide Impact**: The entire blockchain network experiences consensus failure, affecting all miners, validators, and users. Manual intervention would be required to restore chain operation.

4. **No Recovery Mechanism**: Once duplicate orders are written to state, the broken round persists until manual intervention.

## Likelihood Explanation

**Likelihood: HIGH** - Any active miner can execute this attack with minimal effort.

**Attacker Prerequisites**:
- Must be an active miner in the current or previous round (verified by `PreCheck()`): [9](#0-8) 

**Attack Complexity**: LOW
- No collusion required - single miner can execute
- Simple transaction construction with custom `TuneOrderInformation`
- No complex cryptographic operations needed
- No timing requirements or race conditions

**Feasibility**: While `ExtractInformationToUpdateConsensus` generates legitimate `TuneOrderInformation`: [10](#0-9) 

Miners can construct custom `UpdateValue` transactions with arbitrary malicious values since no validation exists.

**Detection**: The attack passes all validation silently and only manifests when the next round begins, making preemptive detection difficult.

## Recommendation

1. **Validate TuneOrderInformation in UpdateValueValidationProvider**:
   - Check that all `FinalOrderOfNextRound` values are distinct
   - Verify values are within valid range (1 to miner count)
   - Ensure only valid miner public keys are included

2. **Fix NextRoundMiningOrderValidationProvider**:
   - Change to: `.Select(m => m.FinalOrderOfNextRound).Distinct().Count()`
   - Check `baseRound` instead of `providedRound` for NextRound behavior
   - Add explicit duplicate detection with detailed error messages

3. **Add Defensive Checks in GenerateNextRoundInformation**:
   - Validate no duplicate `FinalOrderOfNextRound` values before processing
   - Fail fast if duplicates detected rather than propagating invalid state

4. **Add Runtime Assertions**:
   - In `GetMiningInterval()`, assert that interval > 0
   - In `DecodeSecret()`, validate all orders are distinct before processing

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task DuplicateOrderAttack_CausesConsensusFail

ure()
{
    // Setup: Initialize consensus with 3 miners
    var initialMiners = new[] { MinerA, MinerB, MinerC };
    await InitializeConsensus(initialMiners);
    
    // Attack: MinerA crafts malicious UpdateValue
    var maliciousUpdateValue = new UpdateValueInput
    {
        // ... normal fields (OutValue, Signature, etc.) ...
        TuneOrderInformation = 
        {
            // Set duplicate FinalOrderOfNextRound values
            { MinerA.PublicKey, 1 },  // MinerA gets order 1
            { MinerB.PublicKey, 1 },  // MinerB ALSO gets order 1 (duplicate!)
            { MinerC.PublicKey, 2 }
        }
    };
    
    // Execute attack - this should fail validation but doesn't
    await MinerA.UpdateValue(maliciousUpdateValue);
    
    // Trigger round transition
    await MinerA.NextRound();
    
    // Verify: Next round has duplicate orders
    var nextRound = await GetCurrentRound();
    var minerAOrder = nextRound.RealTimeMinersInformation[MinerA.PublicKey].Order;
    var minerBOrder = nextRound.RealTimeMinersInformation[MinerB.PublicKey].Order;
    
    Assert.Equal(1, minerAOrder);
    Assert.Equal(1, minerBOrder);  // DUPLICATE!
    
    // Verify: GetMiningInterval returns 0 (consensus broken)
    var miningInterval = nextRound.GetMiningInterval();
    Assert.Equal(0, miningInterval);  // ZERO INTERVAL = BROKEN CONSENSUS
    
    // Verify: Lagrange interpolation fails with duplicate orders
    var orders = new List<int> { 1, 1, 2 };  // Duplicate 1s
    var sharedParts = GenerateSharedParts();
    
    // This will produce incorrect secret due to division by zero
    var recoveredSecret = SecretSharingHelper.DecodeSecret(sharedParts, orders, 2);
    var expectedSecret = GetOriginalSecret();
    
    Assert.NotEqual(expectedSecret, recoveredSecret);  // SECRET RECONSTRUCTION BROKEN
}
```

## Notes

This vulnerability represents a complete failure of input validation in a critical consensus mechanism. The combination of unvalidated `TuneOrderInformation`, broken duplicate detection using `.Distinct()` on objects instead of values, and the validation checking the wrong round creates a trivial attack path for any active miner to halt the entire blockchain network. The impact extends beyond immediate consensus failure to compromise the cryptographic secret sharing scheme that underpins the randomness generation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L52-58)
```csharp
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L83-96)
```csharp
        private static (BigInteger gcd, BigInteger invA, BigInteger invB) GetGreatestCommonDivisor2(BigInteger integer1,
            BigInteger integer2)
        {
            if (integer2 == 0) return (integer1, 1, 0);

            var div = BigInteger.DivRem(integer1, integer2, out var rem);
            var (g, iA, iB) = GetGreatestCommonDivisor2(integer2, rem);
            return (g, iB, iA - iB * div);
        }

        private static BigInteger Inverse(BigInteger integer)
        {
            return GetGreatestCommonDivisor2(SecretSharingConsts.FieldPrime, integer).invB.Abs();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
