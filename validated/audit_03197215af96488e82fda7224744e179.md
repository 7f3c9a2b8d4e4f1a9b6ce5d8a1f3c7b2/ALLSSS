# Audit Report

## Title
Association Contract MinimalVoteThreshold Incorrectly Counts Votes from Removed Members

## Summary
The Association contract's `CheckEnoughVoteAndApprovals` method fails to filter votes by current organization membership when checking `MinimalVoteThreshold`, allowing proposals to pass with votes from removed members counting toward the participation threshold. This violates the governance guarantee that MinimalVoteThreshold represents minimum current member participation.

## Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals` method where the MinimalVoteThreshold check counts ALL votes without filtering by current organization membership. [1](#0-0) 

This contrasts with the same function's approval count check that correctly filters by current membership: [2](#0-1) 

The rejection and abstention checks also properly filter by membership: [3](#0-2) [4](#0-3) 

**Root Cause:** When members vote via `Approve`, `Reject`, or `Abstain`, their addresses are added to proposal vote lists after membership verification: [5](#0-4) 

However, when members are removed via `RemoveMember`, only the organization membership list is updated - their previous votes remain in active proposals: [6](#0-5) 

This is proven to be a bug by comparing with Parliament contract's correct implementation: [7](#0-6) 

Note how Parliament correctly uses `.Count(parliamentMembers.Contains)` to filter votes by current members when checking vote thresholds.

## Impact Explanation

**Governance Integrity Violation:** Proposals can be released with fewer participating current members than MinimalVoteThreshold requires, undermining the fundamental governance guarantee that a minimum number of current organization members must participate in proposal decisions.

**Concrete Attack Scenario:**
- Organization has 5 members with MinimalVoteThreshold=5, MinimalApprovalThreshold=3
- Attacker-controlled majority adds 2 temporary members via proposal
- Temporary members cast votes (any type) on a malicious proposal
- Organization removes temporary members via separate proposal
- Only 3 current members approve the malicious proposal
- Proposal passes: 3 current member approvals meet MinimalApprovalThreshold, and 5 total votes (including 2 from removed members) meet MinimalVoteThreshold
- Result: Proposal executes with 60% current member approval instead of requiring 100% participation

This enables minority control through coordinated membership manipulation, violating the security model where MinimalVoteThreshold enforces minimum participation from current organization membership.

## Likelihood Explanation

**Reachable Entry Points:** All required methods (`AddMember`, `RemoveMember`, `Approve`, `Reject`, `Abstain`, `Release`) are public and accessible through standard proposal execution. [8](#0-7) [9](#0-8) 

**Feasible Preconditions:** Requires ability to pass proposals for adding/removing members, achievable if:
1. Organization has legitimate membership changes over time (non-malicious scenario triggering bug)
2. Attacker controls MinimalApprovalThreshold votes to manipulate membership (malicious scenario)

**Execution Practicality:** All steps use standard contract operations without requiring elevated privileges beyond normal proposal approval thresholds. The timing requirement (overlapping proposals) is easily achievable in practice.

**Likelihood Assessment:** MEDIUM - Requires coordination of multiple proposals but uses only standard contract functionality. More likely in organizations with frequent membership changes or where a faction seeks to game governance thresholds.

## Recommendation

Modify `CheckEnoughVoteAndApprovals` to filter all votes by current organization membership, matching the pattern used in Parliament contract and other threshold checks. The fix should change line 56 from:

```csharp
proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count()
```

to:

```csharp
proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count(organization.OrganizationMemberList.Contains)
```

This ensures MinimalVoteThreshold truly represents participation from current organization members only.

## Proof of Concept

```csharp
[Fact]
public async Task MinimalVoteThreshold_CountsRemovedMembers_Vulnerability()
{
    // Setup: Create organization with 5 members, MinimalVoteThreshold=5, MinimalApprovalThreshold=3
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, 
                         Address.FromPublicKey(Accounts[4].KeyPair.PublicKey),
                         Address.FromPublicKey(Accounts[5].KeyPair.PublicKey) };
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 3,
            MinimalVoteThreshold = 5,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { Reviewer1 } }
    };
    
    var orgAddress = (await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput)).Output;
    
    // Step 1: Create malicious proposal
    var proposalId = (await GetAssociationContractTester(Accounts[1].KeyPair).CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = orgAddress,
            ToAddress = orgAddress,
            ContractMethodName = nameof(AssociationContractStub.ChangeOrganizationThreshold),
            Params = new ProposalReleaseThreshold { MinimalApprovalThreshold = 1, MinimalVoteThreshold = 1 }.ToByteString(),
            ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1)
        })).Output;
    
    // Step 2: Two members (accounts[4], accounts[5]) vote
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[5].KeyPair).Approve.SendAsync(proposalId);
    
    // Step 3: Remove those two members via separate proposal
    var removeMember1Proposal = await CreateAndExecuteRemoveMemberProposal(orgAddress, members[3]);
    var removeMember2Proposal = await CreateAndExecuteRemoveMemberProposal(orgAddress, members[4]);
    
    // Step 4: Only 3 current members approve
    await GetAssociationContractTester(Accounts[1].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[2].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[3].KeyPair).Approve.SendAsync(proposalId);
    
    // Vulnerability: Proposal should FAIL (only 3 current members participated, need 5)
    // But it PASSES because removed members' votes still count toward MinimalVoteThreshold
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // This proves the vulnerability
    
    // Release succeeds even though only 3/5 current members participated
    var releaseResult = await GetAssociationContractTester(Accounts[1].KeyPair).Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L42-44)
```csharp
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L94-102)
```csharp
    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```
