# Audit Report

## Title
Deterministic Hash Causes Infinite Loop DOS in NFT Protocol Creation

## Summary
The `GenerateSymbolNumber()` function in the NFT contract contains a critical infinite loop vulnerability. The function generates a random hash once before a collision-avoidance loop but never regenerates it within the loop. Since `Context.ConvertHashToInt64()` is deterministic, the same number is produced on every iteration. When that number already exists in `State.IsCreatedMap`, the transaction enters an infinite loop until gas exhaustion, causing a denial-of-service of NFT protocol creation for affected users.

## Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` helper function where collision avoidance is attempted through a do-while loop. [1](#0-0) 

The critical flaw occurs in the following sequence:

1. A `randomHash` is computed once outside and before the loop using random bytes from the consensus contract combined with the sender's address. [2](#0-1) 

2. Inside the do-while loop, this fixed `randomHash` is passed to `Context.ConvertHashToInt64()` along with constant range parameters `from` and `from.Mul(10)`. [3](#0-2) 

3. The `ConvertHashToInt64()` method is deterministic - it uses pure mathematical operations (BigInteger modulo arithmetic) with no randomness or state changes. [4](#0-3) 

Given identical inputs (`randomHash`, `from`, `from.Mul(10)`), this function will always return the exact same `randomNumber` value on every loop iteration. If `State.IsCreatedMap[randomNumber]` returns `true`, the while condition is satisfied and the loop continues infinitely with no mechanism to escape.

This vulnerability is triggered through the public `Create()` method which calls `GetSymbol()`, which in turn calls `GenerateSymbolNumber()`. [5](#0-4) 

The number length starts at `NumberMinLength = 9`, providing an initial space of 9×10^8 possible values. [6](#0-5) 

## Impact Explanation

**Severity: Critical**

**Direct Operational Impact:**
- Complete DOS of the `Create()` function for specific (sender address, block height) combinations that generate already-used numbers
- Users experience transaction failures after gas exhaustion with no clear error message indicating the root cause
- The NFT protocol creation mechanism becomes progressively unreliable as the `State.IsCreatedMap` accumulates more entries

**Scope of Affected Users:**
- Any user whose deterministic hash mapping collides with an existing entry
- Since the mapping is deterministic per (sender, blockHeight) pair, certain addresses will be permanently unable to create protocols at specific block heights
- As protocol creation continues over time, the collision probability increases geometrically
- With sufficient protocol creation, some address ranges may become completely blocked from ever creating new protocols

**Protocol Integrity Impact:**
- Core functionality of the NFT contract is compromised
- User trust erodes as creation attempts mysteriously fail
- Wasted transaction fees for users encountering the infinite loop
- Potential forced migration to alternative NFT solutions

This represents a critical availability vulnerability affecting the primary purpose of the NFT contract.

## Likelihood Explanation

**Likelihood: Medium to High (increasing over time)**

**Attacker Capabilities Required:** 
None - this occurs naturally without malicious intent when legitimate users attempt to create NFT protocols.

**Attack Complexity:** 
Trivial - users simply call the public `Create()` method with valid inputs. No special setup, permissions, or manipulation required.

**Feasibility Conditions:**
- The vulnerability triggers automatically when the deterministic number generation produces a value already present in `State.IsCreatedMap`
- Initial collision probability is low with 9×10^8 possible 9-digit values
- However, the hash-to-number mapping is deterministic for each (sender address, block height) combination
- As more NFT protocols are created, `State.IsCreatedMap` grows and collision probability increases monotonically
- Eventually, certain sender addresses will consistently fail at specific block heights

**Probability Assessment:**
- **Initial phase:** Low probability when few protocols exist
- **Growth phase:** Probability increases as O(n) where n = number of created protocols
- **Saturation phase:** Certain address/block height combinations reach 100% failure rate
- **Persistence:** Once an address encounters a collision at one block height, retrying at that same height will always fail due to deterministic behavior

**Detection:** 
Transaction failures manifest as gas exhaustion without descriptive error messages, making the root cause difficult to diagnose for end users.

## Recommendation

**Fix: Regenerate the random hash inside the collision-avoidance loop**

The core issue is that `randomHash` is computed once and never updated. The fix requires regenerating a new hash on each loop iteration to ensure different numbers are tried:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    do
    {
        // Generate fresh random bytes on each iteration
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        
        // Regenerate hash using a different salt (e.g., iteration counter or previous randomNumber)
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(Context.TransactionId) // Additional entropy
        );
        
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Alternative Fix: Use iteration counter as additional salt**

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
    {
        Value = Context.CurrentHeight.Sub(1)
    }.ToBytesValue());

    long randomNumber;
    var iteration = 0;
    do
    {
        // Include iteration counter to ensure different hash each time
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(iteration++)
        );
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Additional Safety Measure: Add maximum iteration limit**

To prevent potential infinite loops in edge cases:

```csharp
const int MaxCollisionRetries = 100;
var iteration = 0;
do
{
    Assert(iteration < MaxCollisionRetries, "Failed to generate unique symbol number after maximum retries.");
    // ... regenerate hash with iteration counter ...
    iteration++;
} while (State.IsCreatedMap[randomNumber]);
```

## Proof of Concept

```csharp
[Fact]
public async Task NFTProtocolCreation_InfiniteLoop_WhenCollisionOccurs()
{
    // Setup: Create initial NFT protocol to occupy a symbol number
    var initialInput = new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "Test Protocol 1",
        TotalSupply = 10000,
        BaseUri = "https://example.com/",
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    };
    
    var result1 = await NftContractStub.Create.SendAsync(initialInput);
    var symbol1 = result1.Output.Value;
    
    // The first creation succeeds and stores a number in State.IsCreatedMap
    
    // Attack: Call Create() with a sender address and at a block height that deterministically 
    // generates the SAME number that was already stored
    // Due to ConvertHashToInt64 being deterministic, if the (sender, blockHeight, randomBytes) 
    // combination produces a collision, the transaction will loop infinitely
    
    // In practice, this would require either:
    // 1. Creating many protocols until collision probability is high
    // 2. Using the same sender at a specific block height known to collide
    // 3. Waiting for natural collision as protocol count grows
    
    var collidingInput = new CreateInput
    {
        NftType = NFTType.Music.ToString(),
        ProtocolName = "Test Protocol 2",
        TotalSupply = 5000,
        BaseUri = "https://example2.com/",
        IsBurnable = false,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    };
    
    // This transaction will fail with gas exhaustion if it generates the same number
    // The assertion verifies the transaction fails rather than succeeds
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NftContractStub.Create.SendAsync(collidingInput);
    });
    
    // Expected: Transaction fails with gas exhaustion or timeout
    Assert.Contains("gas", exception.Message.ToLower());
}
```

**Note:** A complete PoC would require either (1) creating sufficient protocols to increase collision probability, or (2) manipulating test environment to force specific (sender, blockHeight) combinations that produce known collisions. The core issue is the deterministic nature of the hash-to-number conversion combined with the non-regenerating hash in the loop.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-36)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
