# Audit Report

## Title
Unbounded State Growth via Unvalidated EncryptedPieces in Consensus Secret Sharing

## Summary
The AEDPoS consensus contract accepts an arbitrary number of encrypted secret sharing pieces from miners without validating that the count matches the expected miner count. A malicious elected miner can exploit this to cause unbounded blockchain state growth by repeatedly submitting oversized `EncryptedPieces` maps, leading to state bloat and operational DoS that threatens network decentralization.

## Finding Description

The vulnerability exists in the consensus secret sharing mechanism where encrypted pieces are added to persistent state without size validation.

**Vulnerable Location 1**: The `UpdateLatestSecretPieces` method iterates through all entries in `triggerInformation.EncryptedPieces` and adds them to the round state without any count validation. [1](#0-0) 

**Vulnerable Location 2**: The `PerformSecretSharing` method similarly adds all entries from `input.EncryptedPieces` without validation. [2](#0-1) 

**Root Cause**: The protobuf definition allows arbitrary map sizes for `encrypted_pieces` with no constraints. [3](#0-2) [4](#0-3) 

**Expected Behavior**: According to the legitimate secret sharing implementation, each miner should provide exactly `minersCount` encrypted pieces (one per miner, typically 17 based on `SupposedMinersCount`). [5](#0-4) 

**Validation Provider Confirmation**: The `UpdateValueValidationProvider` used during block validation does not check the count or size of encrypted pieces, only validating that consensus values (OutValue, Signature) are properly filled. [6](#0-5) 

**Execution Path**:

1. Malicious miner modifies their node software to inject oversized `EncryptedPieces` map
2. During block production, `UpdateLatestSecretPieces` is invoked, copying all malicious pieces to `updatedRound`
3. The round data is extracted via `ExtractInformationToUpdateConsensus`, which includes all encrypted pieces [7](#0-6) 
4. A transaction calling `UpdateValue` is generated with the oversized input
5. When executed, `ProcessUpdateValue` calls `PerformSecretSharing` [8](#0-7) 
6. The bloated round is persisted to blockchain state [9](#0-8) 
7. State is retained for 40,960 rounds [10](#0-9) [11](#0-10) 

**Security Guarantee Broken**: The consensus protocol assumes miners will only submit data proportional to the miner count. This assumption is violated because there is no enforcement mechanism in the contract.

## Impact Explanation

**Operational Impact - State Bloat DoS**:
- A malicious miner can inject up to 5MB of encrypted pieces per UpdateValue transaction (AElf's transaction size limit enforced at the transaction pool level)
- With 40,960 rounds kept in state, persistent bloat accumulates
- For a single malicious miner producing approximately 1/17th of blocks (assuming 17 miners), this results in roughly 12 GB of unnecessary state data
- Multiple malicious miners multiply this impact proportionally
- All full nodes must store and sync this bloated state
- New nodes face significantly increased sync times
- Storage costs increase proportionally for all node operators
- Eventually makes running a node economically impractical, threatening network decentralization
- Unlike temporary DoS attacks, this causes permanent state growth that persists for 40,960 rounds

**Severity**: Medium - While this does not directly steal funds, it causes significant operational degradation that can make the blockchain impractical to operate over time and threatens the fundamental property of decentralization.

## Likelihood Explanation

**Attacker Capabilities**:
- Requires being in the active miner list (elected through the Election contract)
- Miners are semi-trusted but can become malicious or have their infrastructure compromised
- Once elected, miner has full control over their node's off-chain consensus data generation

**Attack Complexity**:
- Low - Simply modify node software to inject oversized maps
- No complex cryptographic operations or precise timing requirements
- Can be automated to execute on every block the miner produces

**Feasibility Conditions**:
- Secret sharing must be enabled (configuration-based) [12](#0-11) 
- Attacker must maintain miner status to exploit repeatedly
- Transaction size limit (5MB) caps per-attack impact but allows sustained exploitation

**Economic Rationality**:
- Standard transaction fees apply but are negligible compared to damage inflicted
- No tokens are burned or locked beyond normal transaction fees
- Attacker's election stake remains intact (no slashing for this behavior)
- Potential motivations: griefing, competitive advantage, extortion

**Detection**: While abnormal state growth would be visible in metrics, attributing it specifically to malicious encrypted pieces versus legitimate consensus data may be challenging initially, allowing sustained exploitation before detection.

**Probability**: Medium - Requires achieving miner status (moderate barrier) but is trivial to execute once achieved (low technical barrier).

## Recommendation

Add validation to enforce that the count of encrypted pieces matches the expected miner count before storing them:

1. In `UpdateLatestSecretPieces`, validate the count:
```csharp
Assert(triggerInformation.EncryptedPieces.Count <= currentRound.RealTimeMinersInformation.Count, 
    "Encrypted pieces count exceeds miner count");
```

2. In `PerformSecretSharing`, add similar validation:
```csharp
Assert(input.EncryptedPieces.Count <= round.RealTimeMinersInformation.Count,
    "Encrypted pieces count exceeds miner count");
```

3. Consider adding size limits to the protobuf schema or enforcing maximum byte size per encrypted piece

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a consensus round with 17 miners
2. Have one malicious miner submit an UpdateValueInput with 1000+ encrypted pieces instead of 17
3. Verify that ProcessUpdateValue accepts and stores all 1000+ pieces without rejection
4. Verify the bloated data persists in state

The key assertion would be that `minerInRound.EncryptedPieces.Count > expectedMinersCount` after processing, proving no validation exists.

## Notes

The vulnerability is valid despite the original claim's impact calculation being slightly overstated. The claim assumes 204.8 GB (5MB Ã— 40,960 rounds), but this would only occur if the attacker could inject data every single round. In reality, a single malicious miner produces approximately 1/17th of blocks (assuming 17 miners), resulting in approximately 12 GB of malicious state data. However, this is still a significant operational DoS, and multiple colluding malicious miners would multiply the impact proportionally, making the threat real and exploitable.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L139-141)
```csharp
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L290-290)
```csharp
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
```

**File:** protobuf/aedpos_contract.proto (L210-210)
```text
    map<string, bytes> encrypted_pieces = 8;
```

**File:** protobuf/aedpos_contract.proto (L294-294)
```text
    map<string, bytes> encrypted_pieces = 14;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L45-45)
```csharp
            EncryptedPieces = { minerInRound.EncryptedPieces },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L118-118)
```csharp
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
