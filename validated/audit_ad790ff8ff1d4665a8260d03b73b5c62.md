# Audit Report

## Title
Unchecked Empty Details List in TokenHolder RemoveBeneficiary Causes Permanent DoS

## Summary
The `RemoveBeneficiary` function in TokenHolderContract unconditionally calls `.Single()` on the beneficiary's profit details list without verifying that the list is non-empty. When a beneficiary has claimed all profit periods, the Profit contract's `ClaimProfits` removes expired details, leaving an empty `Details` list in state. Subsequent calls to `RemoveBeneficiary` throw an `InvalidOperationException`, permanently preventing scheme managers from removing that beneficiary and causing state pollution. [1](#0-0) 

## Finding Description

The vulnerability exists in `RemoveBeneficiary` where it retrieves beneficiary profit details and unconditionally calls `.Single()` without defensive validation: [2](#0-1) 

The LINQ method `.Single()` throws `InvalidOperationException` when called on an empty sequence or a sequence with multiple elements.

The root cause is in the Profit contract's `ClaimProfits` implementation, which removes expired profit details from state: [3](#0-2) 

When a beneficiary has claimed all available profit periods, `LastProfitPeriod > EndPeriod` becomes true for all details. The next `ClaimProfits` call removes these expired entries and updates state with an empty `Details` list.

The `GetProfitDetails` view method simply returns the stored state without any null checks or defensive handling: [4](#0-3) 

**Execution Path:**

1. Beneficiary is registered in a TokenHolder scheme with profit details
2. Over time, beneficiary claims all profit periods via `ClaimProfits`
3. After claiming, `LastProfitPeriod > EndPeriod` for all details
4. Next `ClaimProfits` call removes these expired details
5. State is updated: `new ProfitDetails { Details = { availableDetails } }` where `availableDetails` is empty
6. Manager attempts to call `RemoveBeneficiary`
7. Code retrieves `ProfitDetails` with empty `Details` list
8. `.Single()` throws `InvalidOperationException: "Sequence contains no elements"`
9. Transaction reverts, manager cannot remove beneficiary

Importantly, the beneficiary's shares were already subtracted from the scheme's `TotalShares` during the cleanup in `ClaimProfits`: [5](#0-4) 

This means the beneficiary has zero effective shares but remains in the state map.

TokenHolder schemes are created with `CanRemoveBeneficiaryDirectly = true`: [6](#0-5) 

This flag should enable immediate beneficiary removal, but the vulnerability prevents this capability.

**Evidence of Known Defensive Pattern:**

Within the same contract, `AddBeneficiary` demonstrates proper defensive checking before calling `.Single()`: [7](#0-6) 

This proves the development team was aware of the need for `.Any()` checks before `.Single()`, but this pattern was not applied to `RemoveBeneficiary`.

## Impact Explanation

**Operational Denial of Service:**
- Scheme managers permanently lose the ability to remove affected beneficiaries through the TokenHolder contract's administrative interface
- The `RemoveBeneficiary` function becomes unusable for beneficiaries who have completed all profit claims
- Beneficiaries remain in the `ProfitDetailsMap` state as stale entries that cannot be cleaned up
- Scheme state becomes polluted with inactive beneficiaries who have zero effective shares
- Repeated `RemoveBeneficiary` attempts waste transaction gas

**Affected Parties:**
- Scheme managers who need beneficiary lifecycle management for administrative reasons
- TokenHolder schemes that require clean beneficiary lists for operational purposes
- Protocol's operational integrity and state hygiene

**No Financial Loss:**
- This vulnerability does NOT result in fund theft, loss, or unauthorized transfers
- Beneficiaries have already received all their entitled profits before the issue manifests
- The beneficiary's shares were already removed from `TotalShares` during profit claiming
- No tokens are locked or inaccessible

**Severity Justification - Medium:**
This is a Medium severity issue because it creates a reliable DoS vector for an important administrative function and breaks operational integrity by preventing proper scheme management. However, it does not threaten fund security or enable financial exploitation. The impact is operational rather than financial.

## Likelihood Explanation

**Natural Occurrence (No Attack Required):**
The vulnerability triggers naturally without any malicious action:
- Beneficiaries legitimately claim their profits over time using `ClaimProfits`
- When all periods are claimed, `LastProfitPeriod > EndPeriod` occurs naturally
- The next `ClaimProfits` call automatically cleans up expired details
- Any subsequent `RemoveBeneficiary` attempt by the manager will fail

**No Front-Running Necessary:**
While the original claim mentions front-running, the vulnerability occurs without it:
- If a beneficiary has already claimed all profits, the state is already vulnerable
- The manager's `RemoveBeneficiary` will fail regardless of transaction ordering
- Front-running is only relevant if trying to prevent removal before all profits are claimed, but this is the beneficiary's legitimate right

**Feasibility Conditions:**
- **Common Scenario:** Expected in any long-running TokenHolder scheme where beneficiaries actively claim profits
- **Zero Cost:** No economic penalty for beneficiaries; claiming profits is their normal right
- **No Special Permissions:** Only requires being a registered beneficiary with expired profit details
- **Indistinguishable:** The trigger action (`ClaimProfits`) is legitimate user behavior

**Probability Assessment - High:**
This vulnerability will manifest in any TokenHolder scheme where:
1. Beneficiaries actively claim their distributed profits
2. The scheme runs long enough for all profit periods to be claimed
3. Managers attempt to remove beneficiaries for administrative reasons

Given these are normal operational conditions, the likelihood is HIGH.

## Recommendation

Add defensive validation before calling `.Single()` in `RemoveBeneficiary`:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);

    var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    });
    
    // Add defensive check
    if (profitDetails == null || !profitDetails.Details.Any())
    {
        // Beneficiary already removed or has no active details
        return new Empty();
    }
    
    var detail = profitDetails.Details.Single();
    var lockedAmount = detail.Shares;
    
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    
    if (lockedAmount > input.Amount && input.Amount != 0)
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = lockedAmount.Sub(input.Amount)
            }
        });

    return new Empty();
}
```

This matches the defensive pattern already used in `AddBeneficiary` within the same contract.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_After_ClaimingAllProfits_ShouldNotThrow()
{
    // Setup: Create scheme and add beneficiary
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 10000
    });
    
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Shares = 100
    });
    
    var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    
    // Distribute profits
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = Starter,
        AmountsMap = { { "ELF", 0L } }
    });
    
    // Beneficiary claims all profits (this will eventually trigger cleanup)
    var userProfitStub = GetTester<ProfitContractImplContainer.ProfitContractImplStub>(
        ProfitContractAddress, UserKeyPairs.First());
    await userProfitStub.ClaimProfits.SendAsync(new Profit.ClaimProfitsInput
    {
        SchemeId = tokenHolderProfitScheme.SchemeId
    });
    
    // Additional ClaimProfits to trigger expired details cleanup
    await userProfitStub.ClaimProfits.SendAsync(new Profit.ClaimProfitsInput
    {
        SchemeId = tokenHolderProfitScheme.SchemeId
    });
    
    // Verify Details is now empty
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            SchemeId = tokenHolderProfitScheme.SchemeId,
            Beneficiary = UserAddresses.First()
        });
    profitDetails.Details.Count.ShouldBe(0);
    
    // BUG: This will throw "Sequence contains no elements" exception
    var result = await TokenHolderContractStub.RemoveBeneficiary.SendWithExceptionAsync(
        new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First()
        });
    
    // Verify the exception
    result.TransactionResult.Error.ShouldContain("Sequence contains no elements");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L46-56)
```csharp
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-806)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```
