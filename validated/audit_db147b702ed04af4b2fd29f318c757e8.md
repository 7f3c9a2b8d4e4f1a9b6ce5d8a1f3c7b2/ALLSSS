# Audit Report

## Title
Invalid Profit Detail Creation When EndPeriod Equals CurrentPeriod with Delayed Distribution

## Summary
The `AddBeneficiary` function in the Profit contract contains insufficient validation that allows creation of invalid profit details when `DelayDistributePeriodCount > 0`. When `EndPeriod = CurrentPeriod`, the calculated `StartPeriod` exceeds `EndPeriod`, creating an unclaimable detail whose shares permanently dilute all legitimate beneficiaries' profit distributions.

## Finding Description

The vulnerability exists in the validation logic of `AddBeneficiary`. The method validates that `EndPeriod >= CurrentPeriod` but fails to account for the scheme's `DelayDistributePeriodCount`: [1](#0-0) 

However, `StartPeriod` is calculated by adding the delay to the current period: [2](#0-1) 

When `EndPeriod = CurrentPeriod` and `DelayDistributePeriodCount > 0`, this creates `StartPeriod > EndPeriod`. Despite this invalid state, shares are immediately added to `TotalShares`: [3](#0-2) 

During profit claiming, the filter correctly rejects invalid details where `StartPeriod > EndPeriod`: [4](#0-3) 

The cleanup mechanism cannot remove these invalid details because it only removes details where `LastProfitPeriod >= EndPeriod`, which never occurs for unclaimed details with `LastProfitPeriod = 0`: [5](#0-4) 

This vulnerability affects production systems. The Treasury Welfare scheme is initialized with `DelayDistributePeriodCount = 1`: [6](#0-5) 

## Impact Explanation

**Permanent Profit Dilution**: Invalid beneficiary shares remain in `TotalShares` forever. During distribution, the denominator includes these invalid shares, causing all legitimate beneficiaries to receive proportionally less. If invalid shares represent X% of total shares, every beneficiary loses X% of all future distributions permanently.

**Fund Locking**: The portion allocated to invalid beneficiaries in each distribution is transferred to period virtual addresses where it remains locked indefinitely with no recovery mechanism.

**Production Exposure**: While Treasury Welfare scheme (with `DelayDistributePeriodCount = 1`) is technically vulnerable, the Election contract's implementation doesn't currently provide an exploit path. However, any user-created profit scheme with `DelayDistributePeriodCount > 0` is immediately exploitable by its manager.

**Scalability**: Each invalid beneficiary added compounds the dilution. Multiple invalid details could severely degrade profit distribution fairness across hundreds of distribution periods.

## Likelihood Explanation

**Entry Point**: `AddBeneficiary` is callable by scheme managers and the TokenHolder contract: [7](#0-6) 

**Realistic Scenarios**:
1. **User-Created Schemes**: Any user can create a profit scheme with `DelayDistributePeriodCount > 0` and, as manager, mistakenly call `AddBeneficiary` with `EndPeriod = CurrentPeriod` during beneficiary management operations
2. **Period-Limited Rewards**: Managers attempting to add beneficiaries for the current period only, not understanding the delay semantics
3. **Migration Operations**: Managers moving beneficiaries between schemes without accounting for delay periods

**Execution Simplicity**: Single transaction with standard parametersâ€”no complex state manipulation required.

**Probability**: Medium for user-created schemes (requires manager mistake or malicious intent); Very Low for Treasury Welfare specifically (no current code path through Election contract to trigger this).

## Recommendation

Add validation to ensure `EndPeriod` is at least `CurrentPeriod + DelayDistributePeriodCount`:

```csharp
Assert(input.EndPeriod >= scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
    $"Invalid end period. End Period must be at least {scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount)} when DelayDistributePeriodCount is {scheme.DelayDistributePeriodCount}");
```

Additionally, consider adding a cleanup mechanism in `AddBeneficiary` that removes any existing invalid details (where `StartPeriod > EndPeriod`) for the beneficiary before adding new ones.

## Proof of Concept

```csharp
// Test scenario: User creates a scheme with delay, then adds beneficiary with EndPeriod = CurrentPeriod
[Fact]
public void AddBeneficiary_WithDelayAndEndPeriodEqualsCurrentPeriod_CreatesInvalidDetail()
{
    // Create scheme with DelayDistributePeriodCount = 1
    var schemeId = ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        DelayDistributePeriodCount = 1
    }).Result.Output;
    
    var scheme = ProfitContractStub.GetScheme.CallAsync(schemeId).Result;
    var currentPeriod = scheme.CurrentPeriod; // Period 1
    
    // Add beneficiary with EndPeriod = CurrentPeriod
    ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = DefaultSender,
            Shares = 100
        },
        EndPeriod = currentPeriod // EndPeriod = 1
    }).Wait();
    
    // Verify: TotalShares increased (shares added)
    scheme = ProfitContractStub.GetScheme.CallAsync(schemeId).Result;
    Assert.Equal(100, scheme.TotalShares);
    
    // Verify: Detail created with StartPeriod = 2, EndPeriod = 1 (INVALID)
    var details = ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = DefaultSender
    }).Result;
    Assert.Equal(1, details.Details.Count);
    Assert.Equal(2, details.Details[0].StartPeriod); // StartPeriod = CurrentPeriod + Delay = 2
    Assert.Equal(1, details.Details[0].EndPeriod);   // EndPeriod = 1
    Assert.True(details.Details[0].StartPeriod > details.Details[0].EndPeriod); // INVALID
    
    // Distribute profits
    ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = currentPeriod,
        AmountsMap = { { "ELF", 1000 } }
    }).Wait();
    
    // Attempt to claim - should fail to receive anything due to invalid detail
    var profitAmount = ProfitContractStub.GetProfitAmount.CallAsync(new GetProfitAmountInput
    {
        SchemeId = schemeId,
        Beneficiary = DefaultSender,
        Symbol = "ELF"
    }).Result;
    Assert.Equal(0, profitAmount.Value); // Cannot claim due to invalid detail
    
    // Verify: Shares still in TotalShares (permanent dilution)
    scheme = ProfitContractStub.GetScheme.CallAsync(schemeId).Result;
    Assert.Equal(100, scheme.TotalShares); // Still there, causing dilution
}
```

## Notes

The validation flaw exists as a protocol-level design issue affecting any profit scheme with `DelayDistributePeriodCount > 0`. While the Treasury Welfare scheme is technically vulnerable due to its `DelayDistributePeriodCount = 1` configuration, the current Election contract implementation does not provide a practical exploit path for this specific scheme. The primary risk applies to user-created schemes where managers have direct control over `AddBeneficiary` parameters and may not understand the delay semantics, leading to accidental creation of invalid profit details that permanently dilute distributions.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```
