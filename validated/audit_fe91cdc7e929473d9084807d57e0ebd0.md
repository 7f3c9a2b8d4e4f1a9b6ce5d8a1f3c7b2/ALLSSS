# Audit Report

## Title
Unbounded Profit Detail Accumulation Causes Gas Griefing and Operational DoS

## Summary
The Profit contract's `ClaimProfits` function processes a maximum of 10 profit details per transaction, but there is no upper bound on how many details can accumulate for a single beneficiary. This design flaw forces users with numerous profit details—particularly active voters in the Election system—to make multiple transactions to claim all their profits, resulting in excessive gas costs and poor user experience.

## Finding Description

The vulnerability stems from a fundamental mismatch between the profit detail accumulation mechanism and the claiming mechanism.

**Unbounded Accumulation**: The `AddBeneficiary` method unconditionally appends new profit details to a beneficiary's list without checking for a maximum count. [1](#0-0)  The method creates a new `ProfitDetail` object and adds it to the existing list, with only minimal cleanup of already-expired details. [2](#0-1) 

**Processing Bottleneck**: The `ClaimProfits` function explicitly limits processing to 10 profit details per transaction. [3](#0-2)  This limit is defined as a constant `ProfitReceivingLimitForEachTime = 10`. [4](#0-3) 

**Election System Trigger**: The Election contract's `Vote` method creates one profit detail per vote by calling `AddBeneficiaryToVoter`. [5](#0-4)  This method directly invokes the Profit contract's `AddBeneficiary`, with a code comment explicitly stating "one vote, one profit detail". [6](#0-5) 

**Insufficient Cleanup Mechanisms**: The cleanup logic only removes details that are fully claimed (LastProfitPeriod >= EndPeriod) AND past their due period. [2](#0-1)  Similarly, `ClaimProfits` only removes details after complete processing (LastProfitPeriod > EndPeriod). [7](#0-6)  Neither mechanism prevents the accumulation of new active details.

**Authorization Context**: Only the scheme manager or TokenHolder contract can add beneficiaries. [8](#0-7)  While this prevents arbitrary external additions, it doesn't prevent accumulation through legitimate protocol use.

**Missed Consolidation Pattern**: The TokenHolder contract demonstrates a consolidation mechanism that removes existing details before adding new ones. [9](#0-8)  However, the Election contract bypasses this consolidation by calling the Profit contract directly, allowing unbounded detail accumulation.

## Impact Explanation

**Economic Harm via Gas Griefing**: An active voter with 1,000 profit details must invoke `ClaimProfits` 100 separate times (1,000 ÷ 10) to claim all accumulated profits. Each transaction incurs gas fees, creating significant economic burden. The cost compounds over time as more votes are cast.

**Operational Denial of Service**: Requiring 100 separate transactions creates severe friction:
- Time-consuming process requiring multiple block confirmations
- Increased complexity and higher probability of user errors
- Risk that profits may expire before all can be claimed if the `ProfitReceivingDuePeriodCount` limit is reached
- Poor user experience that discourages protocol participation

**Affected User Base**: 
- Active voters in the Election system (legitimate and encouraged behavior)
- Long-term participants who accumulate details over extended periods
- Any beneficiaries in profit schemes with high activity rates

**Severity Justification**: This is a **Medium severity** issue. While funds are not directly stolen or permanently lost, the operational disruption and financial waste through gas costs are substantial. The issue specifically penalizes good actors who actively participate in governance, degrading core protocol usability.

## Likelihood Explanation

**Normal Usage Path (HIGH Likelihood)**: Active participation in the Election system naturally creates this scenario through no fault of the user. Each vote adds a profit detail, and there's no consolidation mechanism. A voter participating in 1,000 votes over time will inevitably accumulate 1,000 details. This requires no malicious actor and occurs through protocol-encouraged behavior (voting).

**Preconditions**: 
- User participates in voting (no special conditions required)
- Time passes, allowing multiple votes to be cast
- No preventive mechanism exists in the contract logic

**Detection**: The accumulation is observable on-chain through profit detail queries, but users may not realize the impact until attempting to claim profits.

**Assessment**: The likelihood is **HIGH** because the normal usage path alone (active voting) guarantees this issue will manifest for engaged users. Any voter who casts more than 10 votes and attempts to claim all profits will experience the issue.

## Recommendation

Implement one or more of the following mitigations:

1. **Add Consolidation Logic**: Modify the Election contract's voting mechanism to consolidate existing profit details before adding new ones, similar to the TokenHolder pattern:
   - Check for existing details when voting
   - Remove and sum existing shares
   - Add a single consolidated detail with total shares

2. **Implement Maximum Detail Cap**: Add a check in `AddBeneficiary` to enforce a maximum number of active details per beneficiary (e.g., 100), reverting if exceeded.

3. **Increase Processing Limit**: Raise `ProfitReceivingLimitForEachTime` from 10 to a higher value (e.g., 100) to reduce the number of required transactions, though this doesn't fully solve the unbounded accumulation.

4. **Automatic Consolidation on Claim**: When `ClaimProfits` is called, automatically consolidate remaining unprocessed details into a single detail to prevent future accumulation.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. User casts 100 votes through the Election contract's `Vote` method
2. Each vote creates one profit detail via `AddBeneficiaryToVoter`
3. User attempts to claim all profits via `ClaimProfits`
4. Only 10 details are processed in the first transaction
5. User must call `ClaimProfits` 10 times total to claim all accumulated profits
6. Each additional call incurs gas fees, resulting in economic harm

To verify, inspect the state after multiple votes:
- Query `GetProfitDetails` for a voter's address
- Observe that the `Details` list grows with each vote
- Attempt `ClaimProfits` and observe only 10 details processed per call

## Notes

This vulnerability demonstrates a critical design pattern issue where the accumulation rate (one detail per vote) significantly exceeds the processing rate (10 details per claim). While the TokenHolder contract shows awareness of this pattern through its consolidation mechanism, the Election contract—one of the most active users of the Profit system—does not implement similar protections. The issue is exacerbated by the fact that voting is not only permitted but actively encouraged as a core governance mechanism, meaning the most engaged and valuable users suffer the greatest impact.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-201)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-774)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-806)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L443-443)
```csharp
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L46-56)
```csharp
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }
```
