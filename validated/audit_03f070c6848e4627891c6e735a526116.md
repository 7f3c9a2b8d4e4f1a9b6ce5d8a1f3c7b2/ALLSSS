Based on my thorough analysis of the codebase, I can confirm this is a **valid vulnerability**. Let me provide the complete audit report:

# Audit Report

## Title
Incorrect Use of TotalSupply Instead of Supply in GetNeededDeposit Causes Inflated Deposit Requirements

## Summary
The `GetNeededDeposit` function incorrectly uses `tokenInfo.TotalSupply` instead of `tokenInfo.Supply` to calculate tokens in external circulation. Since `TotalSupply` remains constant while `Supply` decreases when tokens are burned, this causes deposit requirements to be inflated by the amount of burned or unissued tokens, forcing users to deposit excessive base tokens when enabling connectors.

## Finding Description
The vulnerability exists in the `GetNeededDeposit` function where `amountOutOfTokenConvert` is incorrectly calculated using `tokenInfo.TotalSupply`: [1](#0-0) 

The core issue is that `TotalSupply` and `Supply` represent fundamentally different values in the token system:

**TotalSupply** is set at token creation and never changes: [2](#0-1) 

**Supply** represents actual circulating tokens. It starts at 0 and increases when tokens are issued: [3](#0-2) 

When tokens are burned, only `Supply` decreases while `TotalSupply` remains constant: [4](#0-3) 

The TokenConverter itself burns tokens through the `HandleFee` function on every Buy/Sell operation: [5](#0-4) 

The inflated `amountOutOfTokenConvert` value is then used in the Bancor formula to calculate the required deposit: [6](#0-5) 

This deposit amount is enforced when users call `EnableConnector`: [7](#0-6) 

The function should calculate tokens in external circulation as `Supply - balance - AmountToTokenConvert` because only `Supply` tokens actually exist. Using `TotalSupply` incorrectly counts burned and never-issued tokens as being "in external circulation" when they don't exist anywhere.

## Impact Explanation
**Economic Harm**: Users enabling connectors must deposit `(TotalSupply - Supply)` more base tokens than economically necessary. This overcount grows as tokens are burned through fee mechanisms or remain unissued.

**Quantified Example**: For a token with `TotalSupply = 1,000`, `Supply = 600` (400 burned/unissued), contract `balance = 300`, and `AmountToTokenConvert = 200`:
- Current (wrong): `1000 - 300 - 200 = 500` tokens external → high deposit required
- Correct: `600 - 300 - 200 = 100` tokens external → 5x lower deposit required

**Affected Users**: Any user enabling a connector for tokens where `Supply < TotalSupply`, including:
- Tokens with burn mechanisms (especially ELF, which burns fees via `HandleFee`)
- Tokens with gradual issuance schedules
- Any token where the issuer hasn't issued up to `TotalSupply`

**Severity**: If the `(TotalSupply - Supply)` gap is large enough, deposit requirements become prohibitively expensive, effectively preventing token listings and locking excess capital unnecessarily.

## Likelihood Explanation
**Trigger Conditions**: The issue manifests automatically whenever `Supply < TotalSupply`, which occurs in two common scenarios:
1. Tokens are burned via `HandleFee` during every Buy/Sell transaction
2. Tokens remain unissued (issuer hasn't issued up to `TotalSupply`)

**No Privileges Required**: `EnableConnector` is publicly callable with no authorization checks. Any user enabling a connector is affected.

**High Probability**: The gap widens naturally through normal protocol operations:
- Every Buy/Sell transaction burns tokens via the fee mechanism (half of the fee is burned)
- Many tokens intentionally use gradual issuance models with high initial `TotalSupply`
- ELF itself (the base token) has burns, making this issue systemic

**Detection Difficulty**: Users may notice high deposit requirements but likely attribute them to Bancor pricing rather than a calculation error.

## Recommendation
Replace `tokenInfo.TotalSupply` with `tokenInfo.Supply` in the `GetNeededDeposit` function:

```csharp
// Change line 73 in TokenConvert_Views.cs from:
var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;

// To:
var amountOutOfTokenConvert = tokenInfo.Supply - balance - input.AmountToTokenConvert;
```

This ensures that only tokens that actually exist in circulation are considered when calculating the required deposit.

## Proof of Concept
```csharp
[Fact]
public async Task GetNeededDeposit_InflatedByBurnedTokens_Test()
{
    // Setup: Initialize TokenConverter
    await DefaultStub.Initialize.SendAsync(new InitializeInput
    {
        FeeRate = "0.005"
    });
    
    var tokenSymbol = "BURN";
    long totalSupply = 100_0000_0000;
    
    // Create token with TotalSupply = 100_0000_0000
    await CreateTokenAsync(tokenSymbol, totalSupply);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue only 60_0000_0000 tokens (40% never issued)
    long issuedAmount = 60_0000_0000;
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = issuedAmount,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // Burn 10_0000_0000 tokens (now Supply = 50_0000_0000, TotalSupply still 100_0000_0000)
    await TokenContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = tokenSymbol,
        Amount = 10_0000_0000
    });
    
    // User wants to transfer all remaining tokens to converter
    var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 50_0000_0000 // All existing tokens
    };
    
    var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
    
    // VULNERABILITY: amountOutOfTokenConvert calculated as:
    // TotalSupply - balance - AmountToTokenConvert = 100_0000_0000 - 0 - 50_0000_0000 = 50_0000_0000
    // But SHOULD be: Supply - balance - AmountToTokenConvert = 50_0000_0000 - 0 - 50_0000_0000 = 0
    
    // This means user must deposit for 50_0000_0000 "external" tokens that don't exist
    deposit.AmountOutOfTokenConvert.ShouldBe(50_0000_0000); // Wrong! Should be 0
    deposit.NeedAmount.ShouldBeGreaterThan(0); // Wrong! Should be 0 since no tokens are external
    
    // The correct calculation would show 0 external tokens and require 0 deposit
    // But current implementation inflates the deposit by counting burned/unissued tokens
}
```

**Notes:**
- This vulnerability causes measurable economic harm by requiring users to lock excess capital that doesn't correspond to actual circulating tokens.
- The issue is particularly severe for tokens with burn mechanisms (like ELF itself via `HandleFee`) where the `(TotalSupply - Supply)` gap continuously grows.
- The fix is straightforward: use `Supply` instead of `TotalSupply` to reflect actual circulating tokens.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L81-83)
```csharp
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-164)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-336)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L214-257)
```csharp
    private void HandleFee(long fee)
    {
        var donateFee = fee.Div(2);
        var burnFee = fee.Sub(donateFee);

        // Donate 0.5% fees to Treasury
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = donateFee
            });
        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Spender = State.DividendPoolContract.Value,
            Amount = donateFee
        });
        State.DividendPoolContract.Donate.Send(new DonateInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Amount = donateFee
        });

        // Transfer to self contract then burn
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = burnFee
            });
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-285)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });
```
