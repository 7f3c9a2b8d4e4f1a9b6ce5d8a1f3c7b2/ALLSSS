# Audit Report

## Title
State Corruption in TokenHolder Scheme Updates via Cross-Scheme Operations

## Summary
The `UpdateTokenHolderProfitScheme` function contains a critical bug where it writes scheme data to `Context.Sender`'s address instead of the intended `manager` address. This causes state corruption when users interact with schemes managed by others, leading to permanent fund lockup for scheme participants.

## Finding Description
The root cause exists in the `UpdateTokenHolderProfitScheme` function where scheme data is persisted to the wrong address mapping key. [1](#0-0) 

The function receives the `manager` parameter to indicate whose scheme should be updated, but at line 298 it writes to `State.TokenHolderProfitSchemes[Context.Sender]` instead of `State.TokenHolderProfitSchemes[manager]`. The state mapping is defined as keyed by manager addresses. [2](#0-1) 

This vulnerable function is invoked through `GetValidScheme`, which is called from multiple public entry points including `ClaimProfits` [3](#0-2) , `RegisterForProfits` [4](#0-3) , `ContributeProfits` [5](#0-4) , and `Withdraw` [6](#0-5) .

**Attack Execution Path:**
1. Alice creates SchemeA with Symbol="USDT", MinimumLockMinutes=60 via CreateScheme
2. Bob creates SchemeB with Symbol="ELF", MinimumLockMinutes=120
3. Users register to Bob's scheme, locking "ELF" tokens
4. Bob calls `ClaimProfits` with `SchemeManager = Alice` (Context.Sender is Bob)
5. `GetValidScheme(Alice)` loads Alice's scheme which has `SchemeId == null` (uninitialized)
6. Since `SchemeId == null`, the conditional at line 289 evaluates to false and execution continues [7](#0-6) 
7. Line 298 writes Alice's scheme data to `State.TokenHolderProfitSchemes[Bob]`, corrupting Bob's scheme
8. Users registered to Bob's scheme now reference corrupted data with wrong token symbol

Test evidence confirms schemes have `SchemeId == null` immediately after creation. [8](#0-7) 

The TokenHolderProfitScheme structure includes critical fields that control withdrawal validation. [9](#0-8) 

## Impact Explanation
When Bob's scheme is corrupted, the `Symbol` and `MinimumLockMinutes` fields are replaced with Alice's values, breaking withdrawals for all users registered to Bob's scheme. [10](#0-9) 

The `Withdraw` function retrieves the locked token amount using the corrupted scheme's symbol. Since users locked "ELF" but the corrupted scheme now specifies "USDT", the `GetLockedAmount` call will return zero or fail. [11](#0-10) 

The subsequent unlock operation fails, and the lock time validation uses the corrupted `MinimumLockMinutes`, causing incorrect timing checks. [12](#0-11) 

**Affected Parties:**
- Users who locked tokens in Bob's scheme lose access to their funds (permanent DoS)
- Bob's scheme becomes permanently unusable
- Any scheme manager who interacts with uninitialized schemes risks corruption

**Severity:** High - causes operational DoS and effective permanent fund lockup for scheme participants.

## Likelihood Explanation
**Attacker Capabilities:** No special privileges required. Any user can:
1. Create their own scheme (become a manager) via the public `CreateScheme` method [13](#0-12) 
2. Interact with another scheme via public methods that accept `SchemeManager` parameter

**Attack Complexity:** Low
- Normal transaction sequence using public methods
- No timing requirements beyond the target scheme being uninitialized
- No economic cost beyond standard transaction fees
- Multiple entry points available

**Feasibility Conditions:**
- Target scheme must have `SchemeId == null` (window exists after `CreateScheme` call)
- Attacker must be a scheme manager (trivially achievable by calling `CreateScheme`)

**Probability:** Medium-High - The vulnerability window definitively exists (confirmed by tests), and the operation sequence is natural for managers legitimately participating in multiple schemes.

## Recommendation
Change line 298 in `UpdateTokenHolderProfitScheme` to write to the correct address key:

```csharp
State.TokenHolderProfitSchemes[manager] = scheme;
```

This ensures scheme data is written to the intended manager's storage location instead of the caller's location.

## Proof of Concept
```csharp
[Fact]
public async Task StateCorruption_CrossScheme_Test()
{
    // Alice creates scheme with USDT
    var aliceStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs[0]);
    await aliceStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 60
    });
    
    // Bob creates scheme with ELF
    var bobStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs[1]);
    await bobStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 120
    });
    
    // Verify Bob's scheme before corruption
    var bobSchemeBefore = await TokenHolderContractStub.GetScheme.CallAsync(UserAddresses[1]);
    bobSchemeBefore.Symbol.ShouldBe("ELF");
    bobSchemeBefore.MinimumLockMinutes.ShouldBe(120);
    
    // Bob calls ClaimProfits referencing Alice's scheme - triggers corruption
    await bobStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = UserAddresses[0] // Alice
    });
    
    // Verify Bob's scheme is now corrupted with Alice's data
    var bobSchemeAfter = await TokenHolderContractStub.GetScheme.CallAsync(UserAddresses[1]);
    bobSchemeAfter.Symbol.ShouldBe("USDT"); // Corrupted!
    bobSchemeAfter.MinimumLockMinutes.ShouldBe(60); // Corrupted!
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-102)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-152)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L247-256)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        var beneficiary = input.Beneficiary ?? Context.Sender;
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L42-46)
```csharp
            var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
            tokenHolderProfitScheme.Period.ShouldBe(0);
            tokenHolderProfitScheme.Symbol.ShouldBe("APP");
            tokenHolderProfitScheme.SchemeId.ShouldBeNull();
        }
```

**File:** protobuf/token_holder_contract.proto (L116-127)
```text
message TokenHolderProfitScheme {
    // The token symbol.
    string symbol = 1;
    // The scheme id.
    aelf.Hash scheme_id = 2;
    // The current dividend period.
    int64 period = 3;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 4;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 5;
}
```
