# Audit Report

## Title
Unvalidated Miner Order Assignment Enables Consensus DoS via Invalid Orders

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract accepts user-provided mining order values without validating they are within the valid range [1, minersCount]. This allows malicious miners to assign invalid orders that propagate to subsequent rounds and cause critical consensus functions to throw exceptions, permanently halting block production.

## Finding Description

The vulnerability exists in the order assignment flow where user-provided values are directly assigned to state without bounds validation.

**Missing Validation in ProcessUpdateValue:** [1](#0-0) [2](#0-1) 

These lines directly assign `SupposedOrderOfNextRound` and values from `TuneOrderInformation` to `FinalOrderOfNextRound` without any validation that they are within the valid range [1, minersCount].

**Insufficient Validation Provider:** [3](#0-2) 

The validation only checks `OutValue`, `Signature`, and `PreviousInValue` fields - order values are never validated. The `NextRoundMiningOrderValidationProvider` only validates COUNT: [4](#0-3) 

This checks that the count of miners with `FinalOrderOfNextRound > 0` equals miners who mined, but does NOT validate the values are within [1, minersCount].

**Input Definition Without Constraints:** [5](#0-4) 

The proto definition shows these are unconstrained int32 fields that accept any value.

**Propagation to Next Round:** [6](#0-5) 

When generating the next round, miners who successfully mined use their `FinalOrderOfNextRound` values directly as their `Order` in the next round. Invalid orders don't consume valid order slots from the range [1, minersCount].

**Critical Failure Point 1 - GetMiningInterval:** [7](#0-6) 

This function filters for miners with `Order == 1` or `Order == 2`, then accesses `firstTwoMiners[1]`. If the filtered list has fewer than 2 elements (because no miners have Order 1 or 2), this throws an `IndexOutOfRangeException`.

**Critical Failure Point 2 - BreakContinuousMining:** [8](#0-7) [9](#0-8) [10](#0-9) 

These lines use `First()` to find miners with specific orders (1, 2, minersCount-1). If these orders don't exist due to invalid assignments, `First()` throws an `InvalidOperationException`.

**GetMiningInterval Called in Critical Paths:** [11](#0-10) [12](#0-11) [13](#0-12) 

GetMiningInterval is called during next round generation and time slot validation, making these exceptions block all consensus progression.

**Attack Flow:**
1. Malicious miner crafts `UpdateValueInput` with `SupposedOrderOfNextRound` set to an invalid value (e.g., 999, exceeding minersCount)
2. Includes `TuneOrderInformation` dictionary to corrupt other miners' orders to invalid values
3. Calls public `UpdateValue` method: [14](#0-13) 

4. Passes `PreCheck` authorization which only validates miner membership: [15](#0-14) 

5. Invalid orders are assigned to round state without validation
6. Next round is generated with miners having invalid orders
7. When `GetMiningInterval()` or `BreakContinuousMining()` is called during consensus operations, exceptions are thrown
8. Consensus halts permanently

## Impact Explanation

**Critical Severity - Consensus DoS:**

The impact is a complete and permanent halt of consensus progression:

1. **Block Production Halts:** `GetMiningInterval()` is called during block validation and time slot checking. If it throws an exception, no blocks can be validated or produced.

2. **Round Generation Fails:** `GenerateNextRoundInformation()` calls both `GetMiningInterval()` and `BreakContinuousMining()`. If either throws an exception, new rounds cannot be generated.

3. **Protocol-Wide Freeze:** All nodes are affected simultaneously since they all execute the same corrupted round state. The chain becomes completely unresponsive.

4. **Cascading Effects:**
   - Mining rewards cannot be distributed
   - Cross-chain operations depending on round progression are blocked
   - Governance actions requiring new blocks cannot be executed
   - All transaction processing stops

5. **Recovery Difficulty:** Recovery requires either a hard fork or emergency governance intervention with manual state correction, both requiring significant coordination.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attacker Requirements:**
   - Only requires being an elected miner (achievable through normal staking/election process)
   - No special privileges or compromised keys needed
   - Any of the active miners can execute the attack

2. **Trivial Attack Complexity:**
   - Single transaction with crafted input parameters
   - No timing dependencies or race conditions
   - No need for multiple coordinated transactions
   - Immediate effect in the next round

3. **No Technical Barriers:**
   - Public method accessible to any miner
   - Only validation is miner list membership (which attacker satisfies)
   - No economic cost beyond normal transaction fees

4. **High Success Rate:**
   - Attack is deterministic - always succeeds if executed
   - No randomness or probabilistic elements
   - Effect is immediate and observable

## Recommendation

Add bounds validation for mining orders in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound is within valid range
    Assert(updateValueInput.SupposedOrderOfNextRound >= 1 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid SupposedOrderOfNextRound value.");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    minerInRound.Signature = updateValueInput.Signature;
    minerInRound.OutValue = updateValueInput.OutValue;
    minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
    
    // Validate TuneOrderInformation values
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
               $"Invalid order value in TuneOrderInformation for {tuneOrder.Key}.");
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }
    
    // ... rest of the function
}
```

## Proof of Concept

```csharp
[Fact]
public async Task TestInvalidOrderConsensusDoS()
{
    // Setup: Initialize consensus with 5 miners
    var minersCount = 5;
    var minerKeyPairs = GenerateMinerKeyPairs(minersCount);
    await InitializeConsensus(minerKeyPairs);
    
    // Attack: Malicious miner submits invalid orders
    var attackerKeyPair = minerKeyPairs[0];
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("sig"),
        SupposedOrderOfNextRound = 999, // Invalid: exceeds minersCount
        TuneOrderInformation = 
        {
            // Corrupt all other miners' orders
            { minerKeyPairs[1].PublicKey.ToHex(), 998 },
            { minerKeyPairs[2].PublicKey.ToHex(), 997 },
            { minerKeyPairs[3].PublicKey.ToHex(), 996 },
            { minerKeyPairs[4].PublicKey.ToHex(), 995 }
        },
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        RandomNumber = HashHelper.ComputeFrom("random").ToByteString()
    };
    
    // Submit the malicious update
    await ConsensusStub.UpdateValue.SendAsync(maliciousInput);
    
    // Trigger next round generation - should throw exception
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        var nextRoundInput = await ConsensusStub.GetNextRoundInformation.CallAsync(new Empty());
        await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    });
    
    // Verify consensus is halted
    Assert.Contains("IndexOutOfRangeException", exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L206-208)
```text
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L83-84)
```csharp
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L100-101)
```csharp
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L45-45)
```csharp
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-157)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
