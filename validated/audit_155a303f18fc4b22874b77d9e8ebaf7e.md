# Audit Report

## Title
Missing Validation of Term Transition State Allows Arbitrary Miner List Manipulation

## Summary
The `ProcessNextTerm` method converts `NextTermInput` to a `Round` object and directly commits the miner list to state without validating that it matches the legitimate output from `GenerateFirstRoundOfNextTerm`. A malicious block producer can modify the consensus extra data to inject arbitrary miners, completely bypassing the election system on mainchain or perpetuating control on sidechains.

## Finding Description

The vulnerability exists in the term transition logic where miner lists for the next term are established. The legitimate flow requires calling `GenerateFirstRoundOfNextTerm` which derives miners from election victories (mainchain) or current miners (sidechain). [1](#0-0) 

However, when processing the term transition, `ProcessNextTerm` simply converts the submitted `NextTermInput` to a `Round` via `ToRound()` without any validation. [2](#0-1) 

The `ToRound()` method is a simple data structure conversion with no validation logic. [3](#0-2) 

The pre-execution validation only checks that round and term numbers increment correctly and that InValues are null - it does NOT validate the actual miner list content. [4](#0-3) 

The unvalidated `nextRound.RealTimeMinersInformation` is then directly used to create and commit the miner list for the new term. [5](#0-4) 

While the `AEDPoSExtraDataExtractor` validates that `SenderPubkey` matches the block signer, this only ensures the submitter is the actual block producer - it doesn't prevent them from modifying the Round data. [6](#0-5) 

**Attack Flow:**
1. Malicious miner calls `GetConsensusExtraDataForNextTerm` to generate legitimate consensus data [7](#0-6) 
2. Parse the returned `AElfConsensusHeaderInformation` and modify `Round.RealTimeMinersInformation` to add/remove/reorder miners
3. Create `NextTermInput` from modified Round [8](#0-7) 
4. Sign block with their valid key and include the modified consensus data
5. Validation passes because only numbers and null checks are performed [9](#0-8) 
6. Modified miner list is committed to state [10](#0-9) 

## Impact Explanation

**Consensus Integrity Compromise (CRITICAL)**: This vulnerability completely breaks the fundamental security property that miners are selected through the election system on mainchain or maintained consistently on sidechains.

On **mainchain**, this bypasses the entire election mechanism where token holders vote for block producers. The attacker can ignore `TryToGetVictories` results and inject arbitrary miners. [11](#0-10) 

On **sidechains**, miners can self-perpetuate or exclude competitors arbitrarily, as the code falls back to using current miners when no election exists. [12](#0-11) 

**Concrete Harm:**
- **Election Bypass**: Democratically elected miners are excluded while colluding nodes are included
- **Consensus Capture**: Attacker gains control over block production for an entire term
- **Schedule Manipulation**: Favorable mining time slots assigned to attacker's nodes
- **Chain Disruption**: Invalid miner configurations can cause consensus failures

This affects all network participants as consensus security is foundational to the entire blockchain system.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current block producer (member of active miner list)
- Must produce the term transition block (occurs once per term, typically every few days/weeks)

**Attack Complexity:** LOW - The attack is straightforward:
1. Generate legitimate consensus data via contract call
2. Parse and modify the protobuf structure
3. Sign block with own key (which is valid)
4. Submit modified data

**Feasibility:** HIGH
- No special privileges required beyond being a current miner
- The miner is authorized to produce blocks and sign consensus data
- Validation only checks incremental numbers, not miner list correctness
- The block signature remains valid because the attacker is the legitimate signer

**Detection Difficulty:** HIGH - The modified miner list appears legitimate in committed state. There's no on-chain record of what the "correct" list should have been, making it difficult for nodes to detect the manipulation after the fact.

**Probability:** MEDIUM-HIGH - Any compromised or colluding miner can execute this attack when they have the opportunity to produce the term transition block.

## Recommendation

Add validation in `ProcessNextTerm` to verify the submitted miner list matches what `GenerateFirstRoundOfNextTerm` would produce:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // NEW: Validate miner list matches expected output
    var senderPubkey = Context.RecoverPublicKey().ToHex();
    var expectedRound = GenerateFirstRoundOfNextTerm(senderPubkey, State.MiningInterval.Value);
    
    // Verify miner lists match
    var submittedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var expectedMiners = expectedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    Assert(submittedMiners.SequenceEqual(expectedMiners), 
        "Submitted miner list does not match expected election/current miners");
    
    // Continue with existing logic...
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

Alternatively, modify the validation provider to check miner list correctness:

```csharp
// In RoundTerminateValidationProvider.ValidationForNextTerm
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate miner list matches expected
    // This would require accessing contract state or passing expected miner list in context
    // Implementation depends on architectural constraints
    
    return new ValidationResult { Success = true };
}
```

The most secure approach would validate at both the pre-execution stage (validation provider) and execution stage (ProcessNextTerm).

## Proof of Concept

Due to the complexity of the AEDPoS consensus system and the need to simulate a complete blockchain environment with election contracts, miner lists, and term transitions, a full working test would require extensive test infrastructure setup. However, the vulnerability can be demonstrated through code inspection:

1. The `NextTerm` method accepts `NextTermInput` which contains `RealTimeMinersInformation`
2. This is converted to `Round` via `ToRound()` - a simple property copy with no validation
3. The `RoundTerminateValidationProvider` only checks numeric increments, not miner content
4. The miner list from input is directly committed to state via `SetMinerList`
5. There is no comparison with `GenerateFirstRoundOfNextTerm` output at any point

The logical flow proves the vulnerability exists without requiring a running test, as the missing validation is evident from the code structure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-92)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```
