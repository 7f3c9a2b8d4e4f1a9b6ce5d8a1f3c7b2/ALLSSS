# Audit Report

## Title
Association Contract Vote Threshold Counts Non-Member Votes Leading to Governance Bypass

## Summary
The Association contract contains a critical inconsistency in vote threshold validation where the total vote count for `MinimalVoteThreshold` checks is not filtered by current membership, while approval, rejection, and abstention counts are correctly filtered. This allows organizations to manipulate governance outcomes by removing members after they vote, as their votes continue counting toward participation requirements while their actual voting positions are excluded.

## Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals()` function within the Association contract's threshold validation logic.

The function correctly filters approval counts by current membership [1](#0-0) , but fails to filter the total vote count used for `MinimalVoteThreshold` validation [2](#0-1) .

Similarly, rejection and abstention counts are correctly filtered by current membership [3](#0-2) [4](#0-3) .

While only current members can vote (enforced by authorization checks [5](#0-4) ), members can be removed after voting through the `RemoveMember` function [6](#0-5) .

When members are removed, their addresses remain in the proposal's vote lists but are no longer in `OrganizationMemberList`. The unfiltered total vote count continues to include these removed members, while the filtered approval/rejection/abstention counts correctly exclude them.

This creates a critical inconsistency with the Parliament contract, which correctly filters ALL vote counts by current membership [7](#0-6) .

The flawed threshold check is invoked during proposal release [8](#0-7)  through [9](#0-8) .

## Impact Explanation

This vulnerability enables governance manipulation with severe consequences:

1. **Participation Requirement Bypass**: The `MinimalVoteThreshold` ensures minimum participation relative to current organization size. The validation at organization creation enforces this relationship [10](#0-9) . By counting removed members' votes, actual current member participation can be significantly lower than intended.

2. **Concrete Attack Scenario**:
   - Organization with 10 members, `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=5`, `MaximalRejectionThreshold=2`
   - Proposal created, 7 members vote: 5 approve, 2 reject
   - Organization passes another proposal to remove the 2 rejecting members
   - Now 8 members remain, but original proposal validation shows:
     - `approvedMemberCount = 5` (filtered, valid current members)
     - `rejectionMemberCount = 0` (filtered, rejectors removed)
     - `totalVotes = 7` (NOT filtered, includes removed members)
   - Proposal passes with only 5/8 (62.5%) current member participation instead of requiring 7/8 (87.5%)

3. **Governance Integrity Breach**: Organizations can strategically remove dissenting members after they vote, neutralizing their rejections/abstentions while benefiting from their vote count toward the participation threshold. This fundamentally breaks the democratic safeguards that thresholds provide.

4. **Widespread Impact**: All Association-based governance systems, including multi-signature wallets and DAOs using Association contracts for decision-making, are vulnerable to this manipulation.

## Likelihood Explanation

The vulnerability is highly exploitable under realistic conditions:

1. **Reachable Entry Points**: All required functions (`Approve`, `Reject`, `Abstain`, `RemoveMember`, `Release`) are part of the public ACS3 interface [11](#0-10) .

2. **Feasible Preconditions**: Only requires normal organization operations (voting and member management). Member removal requires the organization itself to call it via its virtual address [12](#0-11) , which is standard for organization management through proposal execution.

3. **Execution Practicality**: The attack sequence is straightforward:
   - Create proposal and gather votes
   - Create and pass a second proposal to remove dissenting members
   - Release the original proposal with manipulated vote counts
   - All steps use standard contract methods with no unusual parameters

4. **Economic Rationality**: The cost is minimal (only transaction fees for normal proposal operations), while the benefit is bypassing intended governance safeguards, which could be extremely valuable for contentious proposals.

5. **Detection Difficulty**: The manipulation is subtle and would appear as legitimate organization management with no on-chain signal distinguishing malicious member removal from legitimate restructuring.

## Recommendation

Modify the `CheckEnoughVoteAndApprovals()` function to filter the total vote count by current membership, consistent with how approvals, rejections, and abstentions are handled. The fix should change the total vote count calculation to filter by `organization.OrganizationMemberList.Contains`, matching the Parliament contract's implementation.

The corrected logic should be:
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures all vote counts are consistently filtered by current membership, preventing the governance manipulation vector.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create an Association organization with 10 members and thresholds: `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=5`, `MaximalRejectionThreshold=2`
2. Create a proposal and have 7 members vote (5 approve, 2 reject)
3. Create and pass a second proposal to call `RemoveMember` for the 2 rejecting members
4. Verify that the original proposal now passes `IsReleaseThresholdReached()` even though only 5 out of 8 current members approved (62.5% vs required 87.5%)
5. Successfully call `Release()` on the proposal

The test would demonstrate that the total vote count remains at 7 (unfiltered) while the rejection count drops to 0 (filtered), allowing the proposal to bypass the intended participation requirements.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-73)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-201)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L97-100)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
```
