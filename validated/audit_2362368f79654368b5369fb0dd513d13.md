# Audit Report

## Title
NextRound Validation Checks Wrong Round Allowing Consensus Manipulation

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method incorrectly validates the provided next round instead of the current round from blockchain state. Since newly generated rounds have `FinalOrderOfNextRound = 0` and `OutValue = null` by default, the validation always passes (0 == 0). This allows any miner acting as extra block producer to submit arbitrary next round data with manipulated mining order that gets stored directly to state, breaking the cryptographic fairness guarantee of AEDPoS consensus.

## Finding Description

The vulnerability occurs in the mining order validation logic for round transitions. The validator is designed to ensure that miners who determined their next round order match those who actually mined blocks during the current round, but it checks the wrong data structure.

**Root Cause:**

The validator examines `providedRound` (the proposed next round from the block header) instead of `baseRound` (the actual current round from blockchain state): [1](#0-0) 

The comment explicitly states the intended behavior: "Miners that have determined the order of the next round should be equal to miners that mined blocks during current round" [2](#0-1) 

**Why baseRound Remains Unmodified:**

During validation setup, `RecoverFromUpdateValue` is only invoked for UpdateValue and TinyBlock behaviors, NOT for NextRound behavior: [3](#0-2) 

This means `baseRound` contains the unmodified current round from state with miners' `FinalOrderOfNextRound` and `OutValue` fields populated during their UpdateValue operations.

**Next Round Generation Omits Critical Fields:**

When `GenerateNextRoundInformation` creates a new round, it only sets specific fields: [4](#0-3) 

The `FinalOrderOfNextRound` and `OutValue` fields are never initialized, remaining at their protobuf default values (0 and null respectively).

**Validation Always Passes:**

Since providedRound has all `FinalOrderOfNextRound = 0` and `OutValue = null`, the validation check `0 != 0` evaluates to false, allowing the block to pass.

**Malicious Round Stored Without Validation:**

The provided round is converted and stored directly to blockchain state: [5](#0-4) 

The storage persists the manipulated Order values: [6](#0-5) 

**Violation of Cryptographic Order Determination:**

In the legitimate flow, `FinalOrderOfNextRound` is calculated cryptographically from miner signatures during UpdateValue operations: [7](#0-6) 

This signature-based randomness ensures fair mining order. The vulnerability allows attackers to bypass this mechanism entirely.

## Impact Explanation

**Severity: Critical - Consensus Integrity Compromise**

The attacker can manipulate mining order in the next round by:

1. **Claiming First Miner Position**: Set their `Order = 1` to maximize block production opportunities and rewards
2. **Disadvantaging Competitors**: Assign unfavorable Order values to competing miners, reducing their mining opportunities  
3. **Timing Manipulation**: Control `ExpectedMiningTime` values since they are calculated from Order [8](#0-7) 
4. **Breaking Cryptographic Fairness**: Completely bypass the signature-based randomness mechanism that should determine mining order

**Quantified Damage:**
- Attacker gains repeated first-miner advantage across multiple rounds (every time they become extra block producer)
- Unfair reward distribution heavily favoring the attacker
- Honest miners lose expected mining opportunities and associated block rewards
- Complete breakdown of the cryptographic mining order guarantee
- Undermines fairness and decentralization of the AEDPoS consensus

The mining time slot validation enforces these manipulated Order values: [9](#0-8) 

This directly violates the fundamental AEDPoS invariant that round transitions and miner schedules must maintain cryptographic integrity.

## Likelihood Explanation

**Probability: High**

**Attacker Requirements:**
- Must be in the current miner set (standard requirement for any block producer)
- Must be selected as extra block producer (occurs routinely through the consensus round-robin mechanism)
- No special permissions or trusted roles required beyond normal miner status

**Attack Complexity: Low**

The attacker simply crafts a `NextRoundInput` with manipulated Order values. The input structure definition: [10](#0-9) 

The public NextRound method is accessible to any miner: [11](#0-10) 

**Feasibility:** Every miner eventually becomes the extra block producer in normal consensus operation, providing repeated attack opportunities. The malicious round appears valid to all validators since the broken validation passes. Only detailed forensic analysis comparing expected versus actual mining orders would reveal the manipulation.

## Recommendation

Fix the validator to check `baseRound` instead of `providedRound`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    // FIX: Check baseRound (current round from state) instead of providedRound
    var baseRound = validationContext.BaseRound;
    var distinctCount = baseRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

Additionally, verify that the Order values in the provided next round match the FinalOrderOfNextRound values from baseRound to ensure the cryptographic calculation was performed correctly.

## Proof of Concept

A malicious miner can exploit this vulnerability by:

1. Waiting until they are selected as the extra block producer
2. Instead of calling the legitimate round generation logic at [12](#0-11) , they construct a malicious `NextRoundInput` with arbitrary Order values
3. Calling the public `NextRound` method with their malicious input
4. The broken validator checks the provided next round (where all FinalOrderOfNextRound = 0 and OutValue = null by default) and passes validation
5. The malicious round is stored to state with manipulated Order values
6. In the next round, the attacker mines at their chosen position (typically Order = 1 for maximum advantage)

This can be repeated every time the attacker is selected as extra block producer, allowing sustained consensus manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L11-12)
```csharp
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-17)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L40-45)
```csharp
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
