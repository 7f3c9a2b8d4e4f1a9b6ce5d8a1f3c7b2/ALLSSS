# Audit Report

## Title
Missing LIB Upper Bound Validation in NextRound Allows Consensus Safety Mechanism Bypass

## Summary
The AEDPoS consensus contract's `NextRound` method lacks validation to prevent future LIB (Last Irreversible Block) values from being injected into consensus state. An elected miner can set arbitrary `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values that persist indefinitely, disabling the blockchain mining status detection mechanism designed to throttle block production when finality lags.

## Finding Description

**Root Cause - Unvalidated LIB Copying**

The `NextRoundInput.Create()` method directly copies LIB values without validation. [1](#0-0) 

**Missing Validation Provider**

The consensus validation architecture applies `LibInformationValidationProvider` only for `UpdateValue` behavior to check that LIB doesn't decrease. [2](#0-1) 

For `NextRound` behavior, this provider is explicitly excluded from the validation chain. [3](#0-2) 

**Insufficient Existing Validation**

The `LibInformationValidationProvider` only validates that LIB values don't decrease, not that they don't exceed current blockchain height or round. [4](#0-3) 

**Direct Storage Without Validation**

The `ProcessNextRound` method converts input to Round and stores it directly without recalculating or validating LIB values. [5](#0-4) [6](#0-5) 

The `AddRoundInformation` method performs simple storage without validation. [7](#0-6) 

**Persistence Mechanism**

Fake LIB values persist because `ProcessUpdateValue` only updates LIB when the newly calculated value exceeds the stored value. [8](#0-7) 

## Impact Explanation

**Consensus Safety Mechanism Disabled**

The `GetMaximumBlocksCount` method uses `ConfirmedIrreversibleBlockRoundNumber` to evaluate blockchain mining status via `BlockchainMiningStatusEvaluator`. [9](#0-8) 

The evaluator determines Normal/Abnormal/Severe status based on the gap between `libRoundNumber` and `currentRoundNumber`. [10](#0-9) 

If an attacker sets `ConfirmedIrreversibleBlockRoundNumber` to a very high future value (e.g., current_round + 1000), the evaluator will always return Normal status because `currentRoundNumber` will never exceed `libRoundNumber + threshold`. This disables the consensus safety mechanism designed to:
- Detect when finality is lagging behind block production
- Throttle block production limits when LIB falls behind
- Emit `IrreversibleBlockHeightUnacceptable` events to alert the network

This represents a consensus integrity compromise where the protocol's self-protection mechanism against finality lag is permanently disabled until the blockchain reaches the fake round number.

## Likelihood Explanation

**Attacker Profile**: Any elected miner in the current consensus round.

**Attack Complexity: LOW**
1. Obtain legitimate next round data via public view methods
2. Modify `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` to high future values
3. Submit during assigned NextRound time slot

**Technical Feasibility: HIGH**

The `NextRound` method is public with authorization limited to miner list membership. [11](#0-10) 

Validation is executed via ACS4 interface but explicitly excludes LIB upper bound checks for NextRound behavior. [12](#0-11) 

## Recommendation

Add `LibInformationValidationProvider` to the NextRound validation chain and enhance it to validate upper bounds:

1. Include `LibInformationValidationProvider` in NextRound validation (line 84-88 in AEDPoSContract_Validation.cs)
2. Enhance `LibInformationValidationProvider` to validate that:
   - `ConfirmedIrreversibleBlockHeight <= Context.CurrentHeight`
   - `ConfirmedIrreversibleBlockRoundNumber <= currentRoundNumber`
3. Consider adding a maximum allowed increment threshold for LIB values between rounds

## Proof of Concept

A malicious elected miner can craft a NextRoundInput:
1. Call legitimate view methods to get current round information
2. Generate proper NextRoundInput via standard flow
3. Modify the input to set `ConfirmedIrreversibleBlockRoundNumber = currentRound + 1000`
4. Call `NextRound` during their assigned time slot
5. The fake LIB persists in state, causing `GetMaximumBlocksCount` to always return Normal status even when real finality is severely lagging

## Notes

The vulnerability affects the consensus safety mechanism rather than directly causing fund loss. The blockchain would continue operating but without proper throttling when finality lags behind block production, potentially leading to increased fork risk or finality failures under adversarial conditions. The attacker must be an elected miner, which provides some trust assumption, but the protocol should not rely on miner honesty for consensus safety properties.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-280)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-37)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```
