# Audit Report

## Title
Mining Order Manipulation via Unvalidated FinalOrderOfNextRound in UpdateValue Blocks

## Summary

The AEDPoS consensus validation system fails to validate `FinalOrderOfNextRound` values in UpdateValue block headers, allowing malicious miners to manipulate the mining order for the next round. The `NextRoundMiningOrderValidationProvider` that checks order value distinctness is only applied to NextRound behavior, not UpdateValue behavior, creating a validation gap that enables consensus manipulation.

## Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus blocks. When a miner produces an UpdateValue block, the block header contains a `Round` object with `FinalOrderOfNextRound` values for all miners. While honest miners generate these values through proper conflict resolution in `ApplyNormalConsensusData`, malicious miners can manipulate these values before submitting their block.

The attack succeeds because:

**1. Missing Validation Provider**: In `ValidateBeforeExecution`, the validation providers for UpdateValue behavior do not include order validation: [1](#0-0) 

Compare this to NextRound behavior which includes `NextRoundMiningOrderValidationProvider`: [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` validates that FinalOrderOfNextRound values are distinct and correct: [3](#0-2) 

**2. Blind Value Recovery**: The `RecoverFromUpdateValue` function copies order values from the header without any validation: [4](#0-3) 

**3. State Propagation**: The manipulated header values are extracted into `TuneOrderInformation`: [5](#0-4) 

These manipulated tunings are then applied directly to state during execution: [6](#0-5) 

**4. Consensus Impact**: The next round generation uses these manipulated `FinalOrderOfNextRound` values to determine the actual mining order: [7](#0-6) 

The intended conflict resolution mechanism in `ApplyNormalConsensusData` becomes irrelevant when miners can bypass it: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Breach**: This vulnerability fundamentally breaks the AEDPoS randomized consensus mechanism. The security of AEDPoS relies on unpredictable mining order derived from cryptographic signatures. By manipulating FinalOrderOfNextRound values, attackers can:

- **Control Mining Order**: Position themselves as the first miner (order 1) for favorable block production timing
- **Manipulate Time Slots**: Push competing miners to less favorable positions
- **Affect Extra Block Producer Selection**: Influence which miner becomes the extra block producer
- **Avoid Penalties**: Adjust orders to avoid detection for missed time slots

**Economic Impact**: Mining order affects block production advantages, potential MEV extraction opportunities, and reward distribution. First miners in a round have timing advantages for transaction ordering.

**Protocol Degradation**: Once one miner exploits this, competitive pressure forces others to follow, creating a race-to-exploit scenario that undermines trust in consensus randomness.

## Likelihood Explanation

**High Likelihood** - The attack is practically executable:

**Attacker Requirements**:
- Active miner in consensus set (achievable through staking/election)
- Modified node software to manipulate block headers (straightforward software modification)

**Attack Complexity**: Low
- Single-step manipulation of Round object in block header
- No timing constraints or race conditions
- No coordination with other miners needed
- Works on every UpdateValue block the attacker produces

**Detection Difficulty**: Extremely high
- Manipulated blocks pass all validations
- No cryptographic evidence of tampering
- After-execution validation compares manipulated state against manipulated header (both match)
- Indistinguishable from honest blocks

## Recommendation

Apply `NextRoundMiningOrderValidationProvider` to UpdateValue behavior in addition to NextRound behavior:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        validationProviders.Add(new NextRoundMiningOrderValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
    // ...
}
```

This ensures that FinalOrderOfNextRound values in UpdateValue block headers are validated for distinctness and correctness, preventing manipulation.

## Proof of Concept

The vulnerability can be demonstrated by creating a test where:

1. A miner obtains proper consensus data via `GetConsensusExtraData`
2. Modifies the `FinalOrderOfNextRound` values in the returned Round object
3. Submits the modified Round in their block header
4. The block passes validation despite the manipulated values
5. The manipulated values are applied to state
6. Next round generation uses the manipulated order values

The test would verify that:
- The modified block passes `ValidateConsensusBeforeExecution`
- The modified values persist in state after execution
- The next round reflects the manipulated mining order

This demonstrates that miners can bypass the intended randomized consensus mechanism by directly controlling mining order through header manipulation.

## Notes

The vulnerability exists because the validation system assumes that only NextRound blocks need order validation, while UpdateValue blocks were considered safe since they only update a single miner's information. However, the `GetUpdateValueRound` simplification includes order information for ALL miners, creating an attack surface that was not properly secured. The fix requires extending the existing `NextRoundMiningOrderValidationProvider` to also validate UpdateValue blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```
