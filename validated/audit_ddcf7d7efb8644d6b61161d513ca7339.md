# Audit Report

## Title
Time Slot Validation Allows Overlapping and Unequal Mining Windows via Lenient Interval Checks

## Summary
The `CheckRoundTimeSlots()` validation function uses a lenient interval check permitting mining time intervals from 0ms to 2× the base interval. This allows malicious miners to craft `NextRoundInput` with overlapping or gapped time slots that pass validation, breaking the consensus invariant of sequential, non-overlapping mining windows and enabling unfair mining advantages.

## Finding Description

The vulnerability exists in the AEDPoS consensus contract's time slot validation logic. When a miner submits `NextRoundInput` to transition to a new round, the validation uses an overly permissive check that mathematically permits intervals ranging from 0 to 2× the base interval. [1](#0-0) 

The validation calculates `baseMiningInterval` from the first two miners, then checks subsequent intervals with the condition on line 53. This condition fails only when `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval`, meaning it passes when the absolute deviation is ≤ baseMiningInterval, permitting any interval in the range [0, 2×baseMiningInterval].

In contrast, legitimate round generation creates equal time slots: [2](#0-1) [3](#0-2) 

Each miner's effective time slot duration is determined by `GetMiningInterval()`, which extracts the interval from the first two miners: [4](#0-3) 

When combined with arbitrary `ExpectedMiningTime` values that pass lenient validation, this creates overlapping windows. The attack flow is:

1. Malicious miner crafts `NextRoundInput` (e.g., A:t+0, B:t+4000, C:t+12000, D:t+14000)
2. Calls `NextRound()` - permission check only validates miner list membership: [5](#0-4) 

3. Validation invokes `CheckRoundTimeSlots()` which passes the manipulated intervals
4. The provided Round is stored directly without regeneration: [6](#0-5) [7](#0-6) 

5. During block production, `IsTimeSlotPassed()` only checks if the slot END has passed: [8](#0-7) 

At time t+15000 in the example, both Miner C (slot ends t+16000) and Miner D (slot ends t+18000) have `!IsTimeSlotPassed` = true, allowing both to receive `UpdateValue` behavior: [9](#0-8) 

The validation during new round proposals calls `CheckRoundTimeSlots` but doesn't enforce equality: [10](#0-9) 

## Impact Explanation

**Consensus Integrity Breach:**
- Breaks the fundamental invariant that only one miner should have an active time slot at any moment
- Multiple miners can produce blocks simultaneously during overlapping periods (t+14000 to t+16000 in example)
- Creates gaps where no miner has an active slot, causing block production delays
- Enables strategic time slot allocation favoring colluding miners

**Unfair Mining Advantages:**
- Colluding miners can allocate themselves longer windows (up to 2× normal) while compressing honest miners' slots (down to near-0)
- Honest miners in compressed slots may miss opportunities despite being online
- Long-term accumulation of unfair block production opportunities

**Reward Misallocation:**
- Unequal time slot distribution directly translates to unequal block rewards
- Systematic advantage for attackers in accumulating consensus rewards over time

**Network Stability:**
- Increased fork rates during overlapping periods when multiple miners compete
- Chain quality degradation from non-uniform block timing
- Breaks assumptions in LIB (Last Irreversible Block) calculations relying on predictable time slots

## Likelihood Explanation

**Attacker Capabilities:**
- Requires being elected as a miner (realistic in DPoS through vote staking)
- Must craft malicious `NextRoundInput` with manipulated `ExpectedMiningTime` values
- Can submit via public `NextRound` transaction

**Attack Complexity:**
- LOW - Simple arithmetic manipulation within the 2× allowed range
- No cryptographic breaks required
- Easily automated once mining infrastructure is controlled

**Feasibility:**
- Permission check only validates miner list membership, not round correctness
- Attack repeatable every round for sustained advantage
- 2-3 colluding miners sufficient for systematic exploitation

**Detection Constraints:**
- Manipulated rounds pass all validation checks
- Appears as legitimate consensus data on-chain
- Requires off-chain statistical analysis to detect anomalies

**Economic Rationality:**
- Minimal cost beyond standard mining operations
- Clear benefit through increased block reward share
- Low detection and punishment risk

## Recommendation

Strengthen `CheckRoundTimeSlots()` to enforce strict equality of time intervals, not just approximate equality:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval = 
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    // Enforce strict equality (or very tight tolerance like ±1ms)
    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval = 
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (miningInterval != baseMiningInterval) // Changed from lenient check
            return new ValidationResult { Message = "Time slots must be equal." };
    }

    return new ValidationResult { Success = true };
}
```

Additionally, consider regenerating the round information server-side rather than trusting user-provided `NextRoundInput`, or add validation that `ExpectedMiningTime` values increment by exactly `GetMiningInterval()` for each sequential miner.

## Proof of Concept

```csharp
[Fact]
public async Task TimeSlotValidation_AllowsOverlappingWindows()
{
    // Setup: Initialize consensus with 4 miners
    var miners = new[] { MinerA, MinerB, MinerC, MinerD };
    await InitializeConsensusWithMiners(miners);
    
    // Create malicious NextRoundInput with unequal intervals
    var maliciousRound = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation =
        {
            { MinerA, new MinerInRound { Order = 1, ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow) } },
            { MinerB, new MinerInRound { Order = 2, ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMilliseconds(4000)) } },
            { MinerC, new MinerInRound { Order = 3, ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMilliseconds(12000)) } }, // 8000ms interval
            { MinerD, new MinerInRound { Order = 4, ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMilliseconds(14000)) } }  // 2000ms interval
        }
    };
    
    // Act: Submit malicious round - should pass validation despite overlapping slots
    var result = await ConsensusStub.NextRound.SendAsync(maliciousRound);
    
    // Assert: Transaction succeeds
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify overlapping windows exist
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var miningInterval = currentRound.GetMiningInterval(); // Should be 4000ms
    
    var minerCSlotEnd = currentRound.RealTimeMinersInformation[MinerC].ExpectedMiningTime.AddMilliseconds(miningInterval); // t+16000
    var minerDSlotEnd = currentRound.RealTimeMinersInformation[MinerD].ExpectedMiningTime.AddMilliseconds(miningInterval); // t+18000
    
    // At time t+15000, both miners can mine (overlapping window from t+14000 to t+16000)
    var testTime = Timestamp.FromDateTime(DateTime.UtcNow.AddMilliseconds(15000));
    currentRound.IsTimeSlotPassed(MinerC, testTime).ShouldBeFalse(); // Can still mine
    currentRound.IsTimeSlotPassed(MinerD, testTime).ShouldBeFalse(); // Can still mine
    // This proves overlapping mining windows exist
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-54)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L88-90)
```csharp
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L50-51)
```csharp
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```
