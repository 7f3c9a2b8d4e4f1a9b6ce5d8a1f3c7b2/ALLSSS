# Audit Report

## Title
Cross-Chain Token Metadata Confusion via Unchecked IssueChainId Parameter

## Summary
The `CreateToken()` function allows creating tokens with arbitrary `IssueChainId` values without validating that it matches the current chain ID. This enables attackers to front-run legitimate cross-chain token synchronization by creating tokens with matching symbols and IssueChainIds but malicious metadata (Issuer, Owner, TotalSupply), causing permanent metadata confusion since `CrossChainCreateToken()` does not overwrite existing tokens.

## Finding Description

The vulnerability stems from insufficient validation during token creation and inadequate metadata synchronization in cross-chain operations.

**Root Cause:**

The `CreateToken()` function accepts any non-zero `IssueChainId` value without asserting it equals the current chain ID. When creating a token, if `input.IssueChainId` is non-zero, the code directly assigns it without validation. [1](#0-0) 

The validation function `AssertValidCreateInput()` performs checks for token name length, symbol format, decimals range, and existence, but does not validate that `IssueChainId` matches `Context.ChainId`. [2](#0-1) 

**Why Existing Protections Fail:**

1. **Issue() protection is insufficient**: The `Issue()` function prevents issuing tokens with mismatched IssueChainId through validation [3](#0-2) , but this only prevents local issuance and doesn't prevent the token from being created and receiving cross-chain transfers.

2. **CrossChainCreateToken doesn't overwrite**: When legitimate cross-chain sync occurs, if the token already exists, the function only updates alias information in the ExternalInfo field and does NOT overwrite the token's Issuer, Owner, or TotalSupply. [4](#0-3) 

3. **CrossChainReceiveToken accepts squatted tokens**: When cross-chain transfers arrive, the function retrieves the local token info and only validates that the IssueChainId matches, without checking that Issuer, Owner, or TotalSupply match the source chain's values. [5](#0-4) 

**Exploitation Path:**

1. Attacker on Main Chain obtains Seed NFT for target symbol. The Seed NFT check is enforced in the CreateToken flow. [6](#0-5) 

2. Attacker calls `Create()` with Symbol="LEGIT", IssueChainId=SideChainAId (not MainChainId), and attacker's addresses for Issuer/Owner.

3. Token is created on Main Chain with IssueChainId=SideChainAId but cannot be issued locally due to the check at line 159.

4. Legitimate issuer creates "LEGIT" on Side Chain A with IssueChainId=SideChainAId and correct metadata.

5. When legitimate `CrossChainCreateToken` is called on Main Chain, it finds the token exists and only updates alias information, preserving the attacker's metadata.

6. Cross-chain transfers via `CrossChainReceiveToken` succeed because IssueChainId matches, but use the squatted token's metadata showing attacker as Issuer/Owner.

## Impact Explanation

**High Severity** due to:

1. **Permanent Metadata Corruption**: Once a token is squatted, there is no mechanism to overwrite or correct its metadata. The CrossChainCreateToken function explicitly preserves existing tokens and only updates alias information, making the corruption permanent.

2. **Trust and Identification Break**: Users querying token information on the destination chain see incorrect Issuer and Owner addresses, fundamentally breaking token identification and trust mechanisms.

3. **Supply Tracking Inconsistencies**: The squatted token can have arbitrary TotalSupply values (e.g., 1,000 vs legitimate 100,000,000), causing severe supply tracking discrepancies across chains.

4. **Cross-Chain Integrity Violation**: The fundamental guarantee that tokens with the same symbol and IssueChainId represent the same asset across all chains is violated, breaking cross-chain token semantics.

5. **Governance Impact**: For governance tokens, incorrect Owner information misdirects control and authority, potentially affecting voting and proposal mechanisms.

**Affected Parties**:
- Users receiving cross-chain transfers see incorrect token metadata
- DApps and explorers querying token info receive fraudulent Issuer/Owner/TotalSupply data
- Legitimate token issuers cannot properly register their tokens cross-chain after squatting occurs

## Likelihood Explanation

**Medium-to-High Likelihood** due to:

1. **Low Attack Complexity**: The attack requires only a straightforward call to `Create()` with specific parameters. No specialized technical knowledge beyond understanding the IssueChainId parameter is needed.

2. **Realistic Preconditions**: 
   - Attacker must obtain a Seed NFT for the target symbol, which is achievable through marketplace purchase or the Seed creation mechanism
   - Cross-chain operations have inherent latency, providing a timing window for front-running
   - The attack is specifically viable for Main Chain ‚Üê Side Chain scenarios since side chains block direct `Create()` calls through the SideChainCreator mechanism

3. **Economic Feasibility**: The primary cost is Seed NFT acquisition, which is market-dependent but often economically viable for valuable token symbols or governance tokens.

4. **No Automated Prevention**: The system has no validation mechanism to prevent creating tokens with IssueChainId values different from Context.ChainId, and no detection system to identify squatted tokens.

5. **Permanent Impact**: Once executed, the attack leaves permanent state that is observable via GetTokenInfo queries but cannot be automatically remediated.

## Recommendation

Add validation in the `CreateToken()` function to ensure that `IssueChainId` matches `Context.ChainId` when creating tokens:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    AssertValidCreateInput(input, symbolType);
    
    // Add validation to prevent IssueChainId mismatch
    if (input.IssueChainId != 0 && input.IssueChainId != Context.ChainId)
    {
        Assert(false, "IssueChainId must match the current chain ID for token creation.");
    }
    
    // ... rest of the function
}
```

Alternatively, modify the IssueChainId assignment to always use the current chain ID:

```csharp
var tokenInfo = new TokenInfo
{
    Symbol = input.Symbol,
    TokenName = input.TokenName,
    TotalSupply = input.TotalSupply,
    Decimals = input.Decimals,
    Issuer = input.Issuer,
    IsBurnable = input.IsBurnable,
    IssueChainId = Context.ChainId, // Always use current chain ID
    ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
    Owner = input.Owner
};
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a token on Chain A with `Symbol="TEST"` and `IssueChainId=ChainB`
2. Verify the token is created successfully with `IssueChainId=ChainB`
3. Attempt to call `Issue()` and confirm it fails with "Unable to issue token with wrong chainId"
4. Simulate `CrossChainCreateToken` from Chain B with legitimate metadata
5. Verify that the token metadata on Chain A still shows the attacker's Issuer/Owner
6. Demonstrate that `CrossChainReceiveToken` succeeds despite metadata mismatch

**Notes**

This vulnerability specifically affects the Main Chain in cross-chain scenarios where tokens originate on side chains. Side chains are protected from this attack because the `SideChainCreator` mechanism blocks direct `Create()` calls after initialization. [7](#0-6)  The attack exploits the fact that `CrossChainCreateToken` preserves existing token state rather than enforcing metadata consistency across chains.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L54-55)
```csharp
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L76-76)
```csharp
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L159-159)
```csharp
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-531)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L607-609)
```csharp
        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```
