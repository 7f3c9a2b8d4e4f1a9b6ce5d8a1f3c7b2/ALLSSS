# Audit Report

## Title
Missing Miner List Validation in NextRound Transitions Allows Consensus Disruption via Inflated Miner Count

## Summary
The AEDPoS consensus contract fails to validate that the miner list in a provided NextRound matches the authorized miners from the current round. A malicious miner can inject fake entries into `RealTimeMinersInformation` during round transitions, causing consensus order calculations to use an inflated miner count that disrupts the deterministic ordering mechanism.

## Finding Description

The vulnerability exists in the NextRound validation flow where only internal consistency is checked, but the miner list itself is never validated against the trusted BaseRound state.

**Validation Gap:**

The `NextRoundMiningOrderValidationProvider` performs only internal consistency checking without comparing the provided miner list to the authorized miners: [1](#0-0) 

For a freshly generated next round where miners have default values (`OutValue = null`, `FinalOrderOfNextRound = 0`), fake miners with these same default values pass validation because both sides of the equality check exclude them.

**Missing Validation:**

The validation context provides both `BaseRound` (trusted state) and `ProvidedRound` (untrusted input): [2](#0-1) 

However, the NextRound behavior only uses two validators that never compare the miner lists: [3](#0-2) 

The `MiningPermissionValidationProvider` only checks if the **sender** is in BaseRound, not whether the ProvidedRound's miner list matches: [4](#0-3) 

**State Corruption:**

After passing validation, the corrupted round is written directly to state: [5](#0-4) 

**Consensus Disruption:**

Subsequent consensus operations use the inflated miner count for order calculations: [6](#0-5) 

When `minersCount` is inflated (e.g., 10 instead of 5), the modulus operation `GetAbsModulus(sigNum, minersCount) + 1` produces different order assignments, breaking the deterministic ordering mechanism that is fundamental to AEDPoS consensus.

**Persistence:**

Fake miners persist across rounds because `GenerateNextRoundInformation` copies all miners from the current round, including fake entries: [7](#0-6) [8](#0-7) 

Fake miners with `SupposedOrderOfNextRound = 0` are returned by `GetNotMinedMiners()` and copied to subsequent rounds, accumulating missed time slots until detected as evil miners after exceeding the tolerance threshold: [9](#0-8) 

## Impact Explanation

**High Severity - Consensus Integrity Violation:**

1. **Incorrect Order Assignments**: The inflated `minersCount` causes `ApplyNormalConsensusData` to calculate wrong mining orders. For example, with 5 real miners and 5 fake miners, `signature % 10` produces different results than `signature % 5`, assigning miners to incorrect time slots and breaking the deterministic consensus ordering.

2. **Time Slot Disruption**: Fake miners are assigned time slots but never produce blocks, causing gaps in the block production schedule and delays across the entire network.

3. **Persistent Disruption**: Fake miners persist for up to 4,320 rounds (approximately 3 days at 1-minute intervals) before being detected as evil miners, or until the next term transition resets the miner list.

4. **Protocol-Wide Impact**: All validators and miners are affected because consensus order and timing calculations impact every block production cycle. The deterministic ordering mechanism that ensures fair and predictable block production is compromised.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Complexity**: The attacker only needs to be an authorized miner in the current round and wait for their turn to produce a NextRound block. They then modify the generated next round data before including it in the block header.

2. **No Special Privileges Required**: Any current miner can execute this attack by running modified block production software that injects fake miners into the round data.

3. **Silent Execution**: The attack succeeds without triggering validation failures, as fake miners with default values pass all internal consistency checks. Detection is difficult until observable symptoms appear (missed time slots, disrupted block timing).

4. **Single Point of Failure**: Only one malicious miner is needed to corrupt consensus state for the entire network.

## Recommendation

Add validation to verify that the miner list in ProvidedRound matches the authorized miners from BaseRound. Implement a new validator or extend an existing one:

```csharp
public class MinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        // Only validate for NextRound and NextTerm behaviors
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextRound &&
            validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys;
        var providedMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys;
        
        // For NextRound, miner list should match exactly (unless NextTerm with miner list change)
        if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound)
        {
            if (baseMiners.Count != providedMiners.Count || 
                !baseMiners.All(k => providedMiners.Contains(k)))
            {
                validationResult.Message = "Provided round contains unauthorized miners.";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this validator to the NextRound validation providers in `AEDPoSContract_Validation.cs`.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithFakeMiners_ShouldFail()
{
    // Setup: Initialize consensus with 3 authorized miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Current miner produces blocks to reach NextRound transition
    await ProduceBlocksToNextRound("miner1");
    
    // Attack: Generate valid NextRound but inject 2 fake miners
    var nextRoundInput = await GenerateNextRoundInput("miner1");
    
    // Add fake miners with default values
    nextRoundInput.RealTimeMinersInformation.Add("fake_miner1", new MinerInRound
    {
        Pubkey = "fake_miner1",
        OutValue = null,
        FinalOrderOfNextRound = 0,
        SupposedOrderOfNextRound = 0
    });
    nextRoundInput.RealTimeMinersInformation.Add("fake_miner2", new MinerInRound
    {
        Pubkey = "fake_miner2",
        OutValue = null,
        FinalOrderOfNextRound = 0,
        SupposedOrderOfNextRound = 0
    });
    
    // Submit the corrupted NextRound
    var result = await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    
    // Verify: The corrupted round is written to state (vulnerability)
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(5, currentRound.RealTimeMinersInformation.Count); // 3 real + 2 fake
    
    // Verify: Subsequent order calculations use inflated miner count
    var testSignature = HashHelper.ComputeFrom("test");
    var sigNum = testSignature.ToInt64();
    var correctOrder = Math.Abs(sigNum % 3) + 1; // Should use 3 miners
    var actualOrder = Math.Abs(sigNum % 5) + 1;  // Actually uses 5 miners
    Assert.NotEqual(correctOrder, actualOrder); // Orders are different - consensus disrupted
}
```

## Notes

This vulnerability exploits the trust assumption that miners will provide correctly generated round data. The validation only checks internal consistency but does not verify that the provided miner list matches the authorized miners from the trusted state. This allows a single malicious miner to corrupt consensus state and disrupt the deterministic ordering mechanism that is fundamental to AEDPoS consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-17)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L16-18)
```csharp
        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L131-135)
```csharp
    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
