# Audit Report

## Title
Unvalidated RevealedInValues Allow PreviousInValue Poisoning Leading to Miner DoS

## Summary
The `UpdateLatestSecretPieces()` function in the AEDPoS consensus contract accepts `RevealedInValues` from trigger information without cryptographic validation and uses them to set other miners' `PreviousInValue` state. A malicious consensus miner can inject fake revealed values to poison victim miners' `PreviousInValue`, causing their subsequent blocks to fail validation. The `Hash.Empty` check in `ApplyNormalConsensusData` prevents victims from correcting the poisoned state, enabling targeted denial-of-service attacks against specific miners.

## Finding Description

The vulnerability exists in the secret sharing mechanism of the AEDPoS consensus protocol. When a miner produces a block, they provide `AElfConsensusTriggerInformation` containing `RevealedInValues` for other miners who may have failed to mine in previous rounds. These revealed values are intended to help recover miners' previous in-values using secret sharing reconstruction.

**Root Cause:** The `UpdateLatestSecretPieces()` function blindly trusts the `RevealedInValues` from trigger information without any cryptographic verification: [1](#0-0) 

The trigger information originates from the miner's off-chain node, which can be modified by a malicious miner: [2](#0-1) 

**Missing Validation:** Block validation only checks the block producer's own `PreviousInValue`, NOT the revealed values for other miners: [3](#0-2) 

**Why Protection Fails:** Once a `PreviousInValue` is set (even to a fake value), the conditional check in `ApplyNormalConsensusData` prevents legitimate updates: [4](#0-3) 

**Attack Execution:**
1. Victim miner V fails to mine in Round N (due to network issues, maintenance, etc.), leaving V's `PreviousInValue` as `Hash.Empty` in Round N+1
2. Malicious miner M modifies their off-chain node to inject `RevealedInValues[V] = FakeHash` instead of legitimate secret sharing reconstruction
3. M produces a block in Round N+1 before V mines
4. `UpdateLatestSecretPieces` sets V's `PreviousInValue` to `FakeHash` without validation
5. Block validation passes because only M's own `PreviousInValue` is verified
6. When V attempts to mine, `ApplyNormalConsensusData` does not overwrite the fake value due to the `Hash.Empty` check
7. V's block fails validation: `Hash(FakeHash) â‰  V's OutValue` from the previous round where V successfully mined
8. V's block is rejected, causing missed mining slot

**Propagation:** The fake value continues propagating via `SupplyCurrentRoundInformation`: [5](#0-4) 

## Impact Explanation

**HIGH Severity**

**Consensus Integrity Impact:**
- Breaks consensus fairness by allowing arbitrary exclusion of miners from block production
- Enables targeted denial-of-service attacks against specific miners
- Disrupts the predictable miner schedule and consensus reliability
- Violates the fundamental guarantee that honest miners should be able to produce blocks during their assigned time slots

**Economic Impact:**
- Victim miners lose block production rewards for rejected blocks
- Mining reputation metrics are negatively affected (ProducedBlocks not incremented, MissedTimeSlots increased)
- Affects future mining slot assignments and profitability calculations
- Provides economic advantage to the attacker by eliminating competition

**Operational Impact:**
- Network may experience reduced block production rate if multiple miners are targeted
- Creates uncertainty in transaction finality and throughput
- The poisoned state can persist across multiple rounds via `SupplyCurrentRoundInformation`

**Affected Parties:**
- Individual miners who experience temporary mining failures (a common operational scenario)
- The broader network through reduced consensus reliability
- Token holders through potential delays in transaction finality

## Likelihood Explanation

**MEDIUM Likelihood**

**Attacker Requirements:**
- Must be an authorized consensus miner (high privilege but realistic in adversarial Byzantine fault tolerance models)
- Must have ability to modify their node software to inject fake `RevealedInValues` (feasible - off-chain code is under miner's control)
- No additional cryptographic capabilities needed beyond being in the miner set

**Attack Complexity:**
- LOW - Simple modification to off-chain trigger information generation
- No timing precision required beyond producing a block before the victim in the same round
- No multi-step coordination or complex setup needed

**Preconditions:**
- Victim must have missed mining in a previous round (COMMON due to network latency, maintenance windows, node restarts, or attacks)
- Attacker must produce a block before victim in the subsequent round (probability 1/N where N is miner count, high for early time slots)
- Secret sharing must be enabled (checked via configuration): [6](#0-5) 

**Economic Incentives:**
- Strong incentive in competitive scenarios to exclude rival miners
- Zero cost to attacker (just software modification)
- Potential benefit: elimination of competition for block rewards

## Recommendation

**Immediate Fix:** Implement cryptographic verification of revealed in-values by reconstructing them on-chain from the secret shares and comparing against the provided revealed values.

**Implementation Approach:**
1. Store decrypted pieces on-chain during `PerformSecretSharing`
2. In `UpdateLatestSecretPieces`, verify each `RevealedInValues` entry by:
   - Collecting the target miner's decrypted pieces from previous round
   - Reconstructing the in-value using `SecretSharingHelper.DecodeSecret`
   - Computing the hash and comparing against the provided revealed value
   - Only apply if verification passes

**Alternative:** Add validation in `UpdateValueValidationProvider` to verify revealed values:
- Check that `Hash(revealedInValue) == previousRound.RealTimeMinersInformation[targetMiner].OutValue` for each revealed value
- This ensures revealed values are cryptographically bound to previous round state

**Defense-in-Depth:** Allow miners to submit correction transactions when their `PreviousInValue` is detected to be incorrect, with proof that the current value doesn't match their previous `OutValue`.

## Proof of Concept

Due to the complexity of setting up a full AEDPoS consensus environment with secret sharing enabled, a complete executable PoC would require:

1. Deploy AEDPoS contract with secret sharing enabled
2. Initialize multiple miners in the consensus set
3. Simulate victim miner V failing to mine in Round N
4. Implement malicious node behavior in attacker miner M to inject fake `RevealedInValues[V] = FakeHash`
5. M produces block in Round N+1, poisoning V's `PreviousInValue`
6. V attempts to mine, block validation fails due to incorrect `PreviousInValue`

**Key Observable Outcomes:**
- V's `PreviousInValue` set to attacker-controlled value without validation
- V's subsequent block rejected with validation error: "Incorrect previous in value"
- V loses mining rewards for that time slot
- V's `MissedTimeSlots` counter incremented

The vulnerability is confirmed through code analysis showing the complete absence of validation for `RevealedInValues` in `UpdateLatestSecretPieces`, combined with the immutability enforced by `ApplyNormalConsensusData`'s conditional check.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L189-193)
```csharp
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
