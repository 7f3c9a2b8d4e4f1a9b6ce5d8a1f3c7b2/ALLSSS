# Audit Report

## Title
LIB Monotonicity Violation via Unvalidated NextRound and TinyBlock Consensus Behaviors

## Summary
The `LibInformationValidationProvider` is only applied to `UpdateValue` behavior, while `NextRound` and `TinyBlock` behaviors also modify LIB-related values in consensus state without validation. A malicious miner can exploit this selective validation gap to submit consensus data with regressed Last Irreversible Block (LIB) heights, violating the critical monotonicity invariant and poisoning consensus state.

## Finding Description

**Root Cause:** Inconsistent validation provider registration creates an exploitable gap in LIB monotonicity enforcement across different consensus behaviors.

The `LibInformationValidationProvider` validates that LIB values do not regress by checking that `ConfirmedIrreversibleBlockHeight`, `ConfirmedIrreversibleBlockRoundNumber`, and per-miner `ImpliedIrreversibleBlockHeight` do not decrease. [1](#0-0) 

However, this validator is **only** registered for `UpdateValue` behavior in the validation provider list, not for `NextRound` or `TinyBlock` behaviors. [2](#0-1) 

**Vulnerability Path 1 - NextRound:**

When a miner produces a NextRound block, the `NextRoundInput` contains `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields that are directly copied into the `Round` object without validation. [3](#0-2) 

The ProcessNextRound method directly stores the provided round to state via `AddRoundInformation(nextRound)` without any LIB monotonicity check. [4](#0-3) 

The AddRoundInformation method performs no validation on LIB fields before persisting to state. [5](#0-4) 

**Vulnerability Path 2 - TinyBlock:**

TinyBlock behavior includes `ImpliedIrreversibleBlockHeight` in its simplified round data. [6](#0-5) 

During validation, the `RecoverFromTinyBlock` method applies the provided `ImpliedIrreversibleBlockHeight` to the miner's state without validation. [7](#0-6) 

The updated round with potentially regressed LIB value is then stored to state. [8](#0-7) 

**Attack Vector:**

A malicious miner controls the consensus extra data placed in the block header they produce. The consensus extra data is parsed from the block header during validation. [9](#0-8) 

The validation service iterates through registered providers but only executes those that were added to the list for each specific behavior. [10](#0-9) 

Since `LibInformationValidationProvider` is not registered for NextRound or TinyBlock behaviors, a miner can:
1. Modify `ConfirmedIrreversibleBlockHeight`/`ConfirmedIrreversibleBlockRoundNumber` in NextRoundInput to lower values
2. Or modify `ImpliedIrreversibleBlockHeight` in TinyBlock round data to a lower value
3. Submit the block with malicious consensus extra data
4. Pass validation (since the LIB check is not executed)
5. Have the regressed LIB values permanently stored to consensus state

## Impact Explanation

**Critical Consensus Invariant Violation:**
Last Irreversible Block height is a fundamental consensus safety property that must be monotonically increasing. Regressing LIB values violates this invariant and breaks the finality guarantees that the entire system depends on.

**State Poisoning and Cascade Effect:**
Once a malicious round with lowered LIB is stored to state, all subsequent consensus operations build upon this corrupted baseline. Future UpdateValue operations that do include LIB validation will compare against the already-poisoned state values, enabling cascading LIB regressions across multiple rounds.

**Cross-Chain Integrity Impact:**
LIB determines which blocks are considered finalized for cross-chain operations. While the system-level LIB tracking has protections, the consensus contract's Round state would diverge from the actual chain LIB, creating inconsistency that could affect cross-chain indexing operations querying consensus state.

**No Recovery Mechanism:**
The codebase contains no automatic detection or recovery mechanism for regressed LIB values in consensus state. Once poisoned, the state remains corrupted until manual intervention.

## Likelihood Explanation

**High Likelihood - Directly Exploitable:**

**Public Entry Points:** Both `NextRound` and `UpdateTinyBlockInformation` are public methods callable by authorized miners. [11](#0-10) [12](#0-11) 

**Minimal Prerequisites:**
- Attacker must be in the active miner set (realistic for a compromised validator node)
- No additional privileges beyond normal miner consensus participation required
- Executable during attacker's assigned time slot

**Attack Execution:**
The consensus extra data is generated by the block producer and included in the block header. A malicious miner can modify this data before block creation, and the validation will execute without the LIB monotonicity check.

**No Economic Deterrent:**
- Attack cost is equivalent to normal block production (negligible)
- No slashing mechanism specifically targeting this validation bypass
- Attack is detectable in logs but not preventable by existing validation logic

## Recommendation

Add `LibInformationValidationProvider` to the validation provider list for both `NextRound` and `TinyBlock` behaviors in the validation switch statement:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

For TinyBlock, add a case to the switch statement:

```csharp
case AElfConsensusBehaviour.TinyBlock:
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

This ensures LIB monotonicity is enforced consistently across all consensus behaviors that modify LIB-related state.

## Proof of Concept

A malicious miner with an assigned consensus time slot can:

1. Generate legitimate NextRound consensus data via `GetConsensusExtraData`
2. Parse the returned `AElfConsensusHeaderInformation` 
3. Modify the `ConfirmedIrreversibleBlockHeight` field to a value lower than current state
4. Re-serialize and include in block header
5. Submit the block during their time slot
6. The block passes validation because `LibInformationValidationProvider` is not registered for NextRound behavior
7. The `ProcessNextRound` method stores the malicious round with regressed LIB to state via `AddRoundInformation`
8. Consensus state is now poisoned with regressed LIB values

The same attack vector applies to TinyBlock behavior by modifying `ImpliedIrreversibleBlockHeight` in the simplified round data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-30)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
