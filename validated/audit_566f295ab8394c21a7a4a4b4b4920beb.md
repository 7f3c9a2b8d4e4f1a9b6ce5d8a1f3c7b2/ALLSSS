# Audit Report

## Title
TokenHolder Scheme Configuration Overwrite Allows Lock Term Manipulation

## Summary
The `CreateScheme` function in the TokenHolder contract lacks duplicate prevention checks, allowing a scheme manager to call it multiple times and overwrite the stored scheme configuration (`Symbol` and `MinimumLockMinutes`). This enables retroactive changes to lock terms after users have locked tokens, breaking withdrawal functionality and arbitrarily extending lock periods beyond the original agreement.

## Finding Description

The `CreateScheme` function contains no validation to prevent multiple invocations by the same sender. [1](#0-0) 

The function directly overwrites `State.TokenHolderProfitSchemes[Context.Sender]` without checking if a scheme already exists (line 27). Each invocation also creates a new Profit scheme (line 20), and the Profit contract allows multiple schemes per manager by storing them in a list. [2](#0-1) 

When users register for profits and lock tokens, they use the current scheme configuration retrieved from state. [3](#0-2) 

During withdrawal, the scheme configuration is retrieved fresh from state, which may now contain different `Symbol` and `MinimumLockMinutes` values if the manager called `CreateScheme` again. [4](#0-3) 

The withdrawal process queries `GetLockedAmount` with the retrieved scheme's `Symbol` (line 220-224), then validates time using `MinimumLockMinutes` (line 227-228), and finally attempts to unlock using the same `Symbol` (line 230-236). If the `Symbol` changes from "ELF" to "APP", the query returns 0 (since the lock contains ELF, not APP), preventing withdrawal. If `MinimumLockMinutes` changes from 100 to 1,000,000, the time assertion fails, blocking withdrawal for nearly 2 years instead of 1.6 hours.

**Root Cause**: Missing existence check before scheme creation and no immutability guarantee for lock terms.

**Why Protections Fail**: While `RegisterForProfits` has duplicate protection [5](#0-4) , and the Profit contract prevents duplicate scheme IDs [6](#0-5) , the TokenHolder contract has no equivalent check. The state mapping design allows arbitrary overwrites, and the `UpdateTokenHolderProfitScheme` helper only updates the SchemeId (using FirstOrDefault), not the Symbol or MinimumLockMinutes. [7](#0-6) 

## Impact Explanation

**Direct Fund Impact**: Users' locked tokens become permanently inaccessible or locked for periods far exceeding their original agreement. If `MinimumLockMinutes` changes from 100 to 1,000,000, users expecting a ~1.6 hour lock face a nearly 2-year lock period. This is a direct fund lockup with no recovery mechanism.

**Symbol Mismatch Impact**: If `Symbol` changes from "ELF" to "APP", the withdrawal's `GetLockedAmount` queries for the wrong token type. Since the MultiToken contract's `GetLockedAmount` retrieves the balance of the specified symbol for the lock's virtual address [8](#0-7) , querying for "APP" when "ELF" was locked returns 0. The subsequent `Unlock` call then attempts to unlock 0 tokens, leaving the user's actual ELF tokens permanently locked.

**Affected Parties**: All users who registered for profits under the scheme before the configuration change. TokenHolder schemes are designed for DApp profit-sharing where multiple users stake tokens for dividends.

**Severity Justification**: HIGH - This breaks the fundamental lock/unlock invariant. Users lose access to funds based on a unilateral change by the scheme manager, with no recovery mechanism. The exploit requires no special privileges beyond the manager's normal role.

## Likelihood Explanation

**Attacker Capabilities**: The scheme manager (who legitimately created the scheme) is the attacker. No additional privileges or vulnerability chaining is required.

**Attack Complexity**: Trivial - simply call `CreateScheme` again with different parameters. The function is public with no access control beyond standard transaction authentication.

**Feasibility Conditions**: 
- Manager must have created an initial scheme (normal operation)
- Users must have locked tokens via `RegisterForProfits` (normal operation)
- No additional preconditions required

**Detection/Operational Constraints**: No on-chain events distinguish a malicious re-creation from legitimate operations. Users cannot detect the change until they attempt withdrawal. No governance or time-lock mechanisms protect configuration changes.

**Probability**: HIGH - The attack is economically rational for malicious managers in rug-pull scenarios. Zero marginal cost to execute beyond transaction fees.

## Recommendation

Add an existence check at the beginning of the `CreateScheme` function, similar to the protection in `RegisterForProfits`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add duplicate prevention check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, consider implementing a separate `UpdateScheme` function with proper migration logic for existing beneficiaries, or making schemes completely immutable after the first user registration.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_Overwrite_Breaks_Withdrawal()
{
    var lockAmount = 1000L;
    var originalSymbol = "ELF";
    var newSymbol = "APP";
    var originalLockMinutes = 100L;
    var newLockMinutes = 1000000L;

    // Step 1: Manager creates initial scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = originalSymbol,
        MinimumLockMinutes = originalLockMinutes
    });

    // Step 2: User registers and locks tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });

    var balanceAfterLock = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = originalSymbol,
        Owner = Starter
    })).Balance;

    // Step 3: Manager maliciously overwrites scheme configuration
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = newSymbol,
        MinimumLockMinutes = newLockMinutes
    });

    // Step 4: User attempts to withdraw - should fail
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    
    // Verify withdrawal fails due to time check or symbol mismatch
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    withdrawResult.TransactionResult.Error.ShouldContain("Cannot withdraw");

    // Verify tokens remain locked
    var balanceAfterFailedWithdraw = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = originalSymbol,
        Owner = Starter
    })).Balance;
    balanceAfterFailedWithdraw.ShouldBe(balanceAfterLock); // Tokens still locked
}
```

## Notes

This vulnerability affects the core lock/unlock mechanism of the TokenHolder contract. The issue stems from the design assumption that managers would only call `CreateScheme` once, which is not enforced at the contract level. The protection pattern used in `RegisterForProfits` demonstrates that the developers were aware of the need for duplicate prevention, but this was not applied to `CreateScheme`.

The impact is severe because it allows managers to unilaterally breach the lock agreement with users, either by extending the lock period indefinitely or by changing the token symbol, which renders the original locked tokens inaccessible through normal withdrawal flows.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-165)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-236)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L59-59)
```csharp
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
