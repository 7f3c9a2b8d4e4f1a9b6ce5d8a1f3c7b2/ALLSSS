# Audit Report

## Title
DepositBalance Underflow Causes DoS in TokenConverter Sell Operations Due to VirtualBalance Accounting Mismatch

## Summary
The `Sell()` function in the TokenConverter contract calculates the base token return amount using the Bancor formula with a combined `VirtualBalance + DepositBalance`, but only subtracts from `DepositBalance` during accounting updates. When the calculated return exceeds available `DepositBalance`, the checked arithmetic throws an `OverflowException`, causing transaction revert and denying legitimate sell operations.

## Finding Description

The vulnerability stems from an accounting mismatch between pricing calculation and state updates in the TokenConverter's sell operation.

**Pricing Phase:**
The `Sell()` function calculates the return amount using `GetSelfBalance(toConnector)` in the Bancor formula. [1](#0-0) 

For deposit account connectors with virtual balance enabled, `GetSelfBalance()` returns the sum of `VirtualBalance` and `DepositBalance`. [2](#0-1) 

**Accounting Phase:**
After calculating the return amount, the contract only subtracts from `DepositBalance`, completely ignoring the `VirtualBalance` component used in pricing. [3](#0-2) 

**Overflow Protection:**
The `SafeMath.Sub()` method uses checked arithmetic that throws `OverflowException` on underflow attempts. [4](#0-3) 

**Default Configuration:**
During economic system initialization, deposit account connectors are configured with `VirtualBalance = 10_000_000_00000000` (10 million ELF with 8 decimals). [5](#0-4) 

These connectors are created with `IsVirtualBalanceEnabled = true` and `IsDepositAccount = true`. [6](#0-5) 

**Bancor Formula:**
When both connectors have equal weights (0.005), the Bancor formula simplifies to a direct ratio calculation. [7](#0-6) 

This results in: `amountToReceive = (VirtualBalance + DepositBalance) * paidAmount / (fromConnectorBalance + paidAmount)`

**Exploitation Scenario:**
When `DepositBalance` is relatively small (e.g., 100 ELF) but `VirtualBalance` is 10 million ELF:
- The pricing calculation uses 10,000,100 ELF as the available balance
- User sells resource tokens, formula calculates return amount based on this inflated balance
- If calculated return > 100 ELF, the `DepositBalance.Sub()` operation underflows
- Transaction reverts with `OverflowException`

## Impact Explanation

**Severity: HIGH - Denial of Service**

This vulnerability breaks core protocol functionality:

1. **Fund Lockup**: Users holding resource tokens cannot convert them back to base tokens, effectively locking their value until other users perform enough buy operations to increase `DepositBalance` sufficiently.

2. **Market Dysfunction**: The Bancor automated market maker provides price quotes that cannot be executed. Users receive misleading pricing information that fails during execution based on opaque internal accounting state.

3. **Protocol Availability**: Token conversion functionality is denied even when:
   - The contract holds sufficient total base token balance
   - The Bancor pricing formula indicates valid market conditions  
   - Users have proper token balances and approvals

4. **Protected Failure**: The checked arithmetic prevents state corruption by reverting the transaction rather than allowing negative balances, limiting the issue to availability denial rather than fund theft.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability is highly practical under standard operating conditions:

**Default Configuration:**
- All deposit account connectors are initialized with `VirtualBalance = 10_000_000_00000000` by default during economic system setup
- This is the standard production configuration, not an edge case

**Triggering Conditions:**
1. **Early Protocol Lifecycle**: When `DepositBalance` is still accumulating and remains small relative to the 10M `VirtualBalance`
2. **Low Volume Trading Pairs**: Connector pairs with minimal trading activity accumulate insufficient `DepositBalance`
3. **Post-Buy Scenarios**: After users buy resource tokens, reducing the resource token balance in the contract, the Bancor formula becomes more sensitive to price movements

**No Privilege Requirements:**
- Any user can trigger by calling the public `Sell()` method
- Only requires owning resource tokens and having standard token approval
- No special permissions or sophisticated attack vectors needed

**Realistic Example:**
- Resource token balance in contract: 1,000 tokens
- `DepositBalance[ntWRITE]`: 100 ELF
- `VirtualBalance[ntWRITE]`: 10,000,000 ELF (default)
- User attempts to sell 500 tokens
- Bancor calculates: (10,000,100 * 500) / (1,000 + 500) ≈ 3,333,400 ELF return
- Accounting attempts: 100 - 3,333,400 → Immediate underflow exception

## Recommendation

**Fix Option 1 - Add Validation Check:**
Before executing the subtraction, validate that the calculated return does not exceed available `DepositBalance`:

```csharp
Assert(amountToReceive <= State.DepositBalance[toConnector.Symbol], 
    "Insufficient deposit balance for this sell operation.");
```

**Fix Option 2 - Exclude VirtualBalance from Sell Pricing:**
Modify `GetSelfBalance()` to exclude `VirtualBalance` when calculating sell returns for deposit connectors, using only the actual `DepositBalance` for the "to" connector side of the trade.

**Fix Option 3 - Symmetric VirtualBalance Handling:**
Ensure `VirtualBalance` is treated symmetrically in both pricing and accounting, though this would require fundamental redesign of the virtual balance mechanism.

The recommended approach is **Option 1** as it provides immediate protection with minimal changes, giving users clear error messages about insufficient liquidity while maintaining the current pricing model.

## Proof of Concept

```csharp
[Fact]
public async Task Sell_DepositBalance_Underflow_DoS()
{
    // Setup: Initialize TokenConverter with default VirtualBalance = 10M
    await InitializeTokenConverterWithDefaultConfig();
    
    // Setup: Perform small buy to establish minimal DepositBalance
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = "WRITE",
        Amount = 100_00000000, // Buy 100 WRITE tokens
        PayLimit = 200_00000000
    });
    
    // Verify: DepositBalance is small (e.g., ~100 ELF)
    var depositBalance = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "WRITE" });
    // depositBalance.Value includes VirtualBalance (10M) + actual deposit (~100)
    
    // Attack: User attempts to sell significant portion
    var sellResult = await DefaultStub.Sell.SendAsync(new SellInput
    {
        Symbol = "WRITE",
        Amount = 50_00000000, // Sell 50 WRITE tokens
        ReceiveLimit = 0
    });
    
    // Expected: Transaction fails with OverflowException
    // Bancor calculates return based on 10M+ balance
    // But DepositBalance.Sub() attempts subtraction from ~100 ELF only
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    sellResult.TransactionResult.Error.ShouldContain("Overflow");
}
```

## Notes

The vulnerability is confirmed through direct code analysis showing:
- Pricing uses `VirtualBalance + DepositBalance` via `GetSelfBalance()` 
- Accounting only modifies `DepositBalance` via `.Sub()` operation
- No validation bridges this accounting mismatch
- SafeMath's checked arithmetic causes DoS rather than silent corruption

This represents a design flaw where virtual balance stabilization creates misleading liquidity signals that cannot be honored during execution, resulting in unpredictable denial of service for legitimate users attempting to sell resource tokens.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L240-249)
```csharp
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-49)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);
```
