# Audit Report

## Title
Byzantine Miner Can Disrupt Consensus by Providing NextRound with Malformed ExpectedMiningTime Values

## Summary
A Byzantine miner producing a NextRound block can inject a Round object with ExpectedMiningTime values set to timestamps in the distant past. The `CheckRoundTimeSlots` validation only verifies interval consistency but does not validate that ExpectedMiningTime values are reasonable relative to current block time. This allows corrupted round data to be written to state, causing all subsequent miners to have their time slots marked as "passed," disrupting normal block production.

## Finding Description

The vulnerability exists in the consensus validation logic for NextRound transitions. When a miner produces a NextRound block, the consensus extra data contains a new Round object with scheduled mining times for all miners.

**Root Cause:**

The `CheckRoundTimeSlots` method validates new round information but has a critical gap. [1](#0-0) 

This method only checks:
- ExpectedMiningTime fields are not null
- Mining intervals between consecutive miners are positive
- Intervals are relatively equal (within tolerance)

It does NOT validate that ExpectedMiningTime values are in the future or within a reasonable range of the current blockchain time.

**Attack Execution:**

1. A Byzantine miner waits until selected to produce the NextRound extra block

2. Instead of using the legitimate Round data generated by `GetConsensusExtraDataForNextRound` [2](#0-1) , the attacker crafts malicious Round data with ExpectedMiningTime values set to very early timestamps (e.g., seconds=0, 1, 2, 3... for each miner with proper intervals like 1000ms)

3. The validation occurs via `TimeSlotValidationProvider` which calls `CheckRoundTimeSlots` for new rounds [3](#0-2) 

4. Since the attacker used proper intervals (e.g., 1 second apart), the validation passes even though timestamps are in the distant past

5. The malicious Round is written to state via `ProcessNextRound` [4](#0-3) 

6. When subsequent miners try to produce blocks, `IsTimeSlotPassed` checks whether their time slot has passed [5](#0-4) 

7. Since ExpectedMiningTime values are in the distant past, the check `minerInRound.ExpectedMiningTime + miningInterval < currentBlockTime` returns TRUE for all miners

8. The `ConsensusBehaviourProviderBase` uses this result to determine mining behavior [6](#0-5) 

9. With `_isTimeSlotPassed = true`, the logic cannot return `UpdateValue` behavior, forcing all miners to attempt round termination instead of normal block production

10. Additionally, `ArrangeNormalBlockMiningTime` uses `Max(ExpectedMiningTime, currentBlockTime)` [7](#0-6) , which will consistently return currentBlockTime instead of the scheduled time, further disrupting the time slot system

## Impact Explanation

**Severity: MEDIUM**

The attack breaks the consensus time slot scheduling system, which is a core security guarantee of AEDPoS:

- **Consensus Disruption**: Normal block production (UpdateValue behavior) becomes impossible for all miners once the corrupted round is in state
- **Time Slot Chaos**: The carefully orchestrated schedule ensuring orderly block production is completely bypassed
- **Multi-Round Effect**: Until corrected with a new NextRound block, all miners are stuck in round termination mode
- **Observable Disruption**: The blockchain's ability to maintain predictable block times is compromised

However, this is not HIGH severity because:
- No funds are stolen or lost
- No permanent chain halt occurs
- Recovery is possible (miners can produce corrected NextRound blocks)
- No token supply manipulation
- No governance bypass

The impact is limited to temporary consensus disruption affecting block production regularity and potentially causing confusion among miners attempting to synchronize recovery.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack is feasible but has meaningful constraints:

**Required Conditions:**
- Attacker must be an active miner in the current consensus round
- Attacker must wait until selected to produce the NextRound extra block
- Block production rights are rotated based on consensus algorithm

**Attack Complexity:**
- LOW - The attack requires only modifying ExpectedMiningTime values in the Round object before including it in the block's consensus extra data
- No complex cryptographic operations needed
- No multi-step coordination required
- The validation gap is straightforward to exploit

**Detection:**
- The malformed timestamps would be visible in block explorer consensus data
- Monitoring tools could detect ExpectedMiningTime values far in the past
- The resulting disruption (all miners attempting NextRound simultaneously) would be immediately observable

The likelihood is MEDIUM rather than HIGH because the attacker needs miner status and must wait for their NextRound turn, but the execution is trivial once conditions are met.

## Recommendation

Add timestamp reasonableness validation to `CheckRoundTimeSlots`:

```csharp
public ValidationResult CheckRoundTimeSlots(Timestamp currentBlockTime = null)
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // NEW: Validate that ExpectedMiningTime values are reasonable
    if (currentBlockTime != null)
    {
        var firstMinerTime = miners[0].ExpectedMiningTime;
        // ExpectedMiningTime should be in the future or very recent past (allow small tolerance for block time drift)
        if (firstMinerTime.AddSeconds(60) < currentBlockTime)
            return new ValidationResult { Message = "ExpectedMiningTime values are too far in the past." };
            
        // ExpectedMiningTime should not be too far in the future
        var miningInterval = GetMiningInterval();
        var maxFutureTime = currentBlockTime.AddMilliseconds(miningInterval * miners.Count * 2);
        if (miners.Last().ExpectedMiningTime > maxFutureTime)
            return new ValidationResult { Message = "ExpectedMiningTime values are too far in the future." };
    }

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Update `TimeSlotValidationProvider` to pass currentBlockTime:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        // Pass current block time for timestamp validation
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots(
            validationContext.ExtraData.Round.RealTimeMinersInformation.Values
                .SelectMany(m => m.ActualMiningTimes)
                .OrderByDescending(t => t)
                .FirstOrDefault() ?? Context.CurrentBlockTime);
        if (!validationResult.Success) return validationResult;
    }
    // ... rest of validation
}
```

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Sets up a multi-miner consensus environment
2. Has one miner produce a NextRound block with ExpectedMiningTime values set to epoch zero + proper intervals
3. Verifies that validation passes
4. Verifies that the malicious data is written to state
5. Verifies that subsequent miners have `IsTimeSlotPassed` return true
6. Verifies that normal UpdateValue behavior is impossible

The test would confirm that `CheckRoundTimeSlots` accepts timestamps in the distant past as long as intervals are consistent, and that this corrupts the consensus state to prevent normal block production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L26-115)
```csharp
        protected ConsensusBehaviourProviderBase(Round currentRound, string pubkey, int maximumBlocksCount,
            Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;

            _pubkey = pubkey;
            _maximumBlocksCount = maximumBlocksCount;
            _currentBlockTime = currentBlockTime;

            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
            _minerInRound = CurrentRound.RealTimeMinersInformation[_pubkey];
        }

        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }

        /// <summary>
        ///     If this miner come to a new round, normally, there are three possible behaviour:
        ///     UPDATE_VALUE (most common)
        ///     TINY_BLOCK (happens if this miner is mining blocks for extra block time slot of previous round)
        ///     NEXT_ROUND (only happens in first round)
        /// </summary>
        /// <returns></returns>
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L17-20)
```csharp
        public static Timestamp ArrangeNormalBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return TimestampExtensions.Max(round.GetExpectedMiningTime(pubkey), currentBlockTime);
        }
```
