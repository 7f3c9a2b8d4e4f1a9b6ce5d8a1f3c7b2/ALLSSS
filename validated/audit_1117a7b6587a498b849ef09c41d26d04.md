# Audit Report

## Title
Reserved External Info Key Collision Enables Arbitrary Contract Execution During Token Operations

## Summary
The MultiToken contract accepts user-provided ExternalInfo during token creation without validating against reserved callback keys. Attackers can create tokens with malicious callbacks that execute automatically during transfer, lock, and unlock operations, enabling denial-of-service attacks, gas exhaustion, and reentrancy exploitation.

## Finding Description

The vulnerability exists in the token creation flow where user-provided ExternalInfo is accepted without validation. The `CreateToken` method directly assigns user input to the token's ExternalInfo without checking for reserved keys [1](#0-0) 

The system defines four reserved callback keys intended for system use [2](#0-1) 

A view function `GetReservedExternalInfoKeyList` exposes these keys [3](#0-2) , but grep search confirms it is never called for validation during token creation - it exists only as a view method.

When tokens are transferred, the contract unconditionally executes any callback specified in ExternalInfo [4](#0-3) 

Similar callback execution occurs during lock operations [5](#0-4) 

And unlock operations [6](#0-5) 

The CallbackInfo structure allows specifying arbitrary contract addresses and method names [7](#0-6) 

These callbacks are automatically invoked during Transfer [8](#0-7) , Lock [9](#0-8) , and Unlock [10](#0-9)  operations.

## Impact Explanation

**Guaranteed Denial of Service (HIGH)**: An attacker can create a token with a callback that always reverts. Any user attempting to transfer, lock, or unlock this malicious token will have their transaction fail. This is a straightforward, easily exploitable DoS that affects all holders of the malicious token permanently.

**Gas Exhaustion (HIGH)**: Callbacks can contain expensive operations, forcing victims to pay excessive gas fees for attacker-controlled code execution during routine token operations. Victims have no way to avoid this cost when interacting with the malicious token.

**Reentrancy Risk (MEDIUM-HIGH)**: Callbacks execute via `Context.SendInline()` during the middle of token operations, creating a reentrancy vector. While direct fund theft requires additional conditions (such as victims having approved the attacker's contract), the reentrancy itself violates the non-reentrant execution model expected during token transfers and enables complex attack chains.

**Event Log Pollution (MEDIUM)**: The `aelf_log_event` key allows injecting arbitrary events that appear to originate from the MultiToken contract, potentially misleading indexers and applications that rely on event data.

**Trust Model Breakdown**: The existence of `GetReservedExternalInfoKeyList` indicates these keys were intended to be system-controlled. Allowing user-set values breaks this security boundary and the design intent of the system.

## Likelihood Explanation

**Attack Prerequisites (LOW BARRIER)**:
- Attacker needs a SEED NFT to create the malicious token, obtainable through normal token creation mechanisms
- No special permissions or whitelist membership required beyond SEED ownership
- Token creation follows standard public methods with no elevated privileges

**Attack Steps**:
1. Acquire SEED NFT for desired token symbol through normal mechanisms
2. Create malicious token with ExternalInfo containing reserved callback key (e.g., `"aelf_transfer_callback": "{\"contract_address\":\"<attacker_contract>\",\"method_name\":\"MaliciousCallback\"}"`)
3. Issue and distribute tokens to victims via airdrops, sales, or legitimate-looking distributions
4. When victims transfer/lock/unlock the token, malicious callbacks execute automatically without their knowledge or consent

**No Detection or Prevention**:
- Malicious tokens are indistinguishable from legitimate ones at creation time
- No on-chain validation prevents setting reserved keys in ExternalInfo
- No mechanism exists to blacklist or disable malicious callbacks after discovery
- Victims cannot identify malicious tokens before interacting with them

**High Probability**: The attack is straightforward, economically viable (low cost to create SEED and token), requires no special privileges beyond publicly available SEED NFTs, and is difficult to detect until exploited.

## Recommendation

Add validation during token creation to prevent users from setting reserved ExternalInfo keys. The fix should:

1. Call `GetReservedExternalInfoKeyList()` or use the constants directly to check user-provided ExternalInfo
2. Reject token creation if any reserved keys are present in the input
3. Add the validation in the `CreateToken` method before assigning ExternalInfo to tokenInfo

Suggested fix location: In `TokenContract_Actions.cs`, after line 79 and before `RegisterTokenInfo`, add:

```
// Validate that ExternalInfo does not contain reserved keys
if (input.ExternalInfo != null && input.ExternalInfo.Value.Count > 0)
{
    var reservedKeys = new[] {
        TokenContractConstants.TransferCallbackExternalInfoKey,
        TokenContractConstants.LockCallbackExternalInfoKey,
        TokenContractConstants.UnlockCallbackExternalInfoKey,
        TokenContractConstants.LogEventExternalInfoKey
    };
    
    foreach (var reservedKey in reservedKeys)
    {
        Assert(!input.ExternalInfo.Value.ContainsKey(reservedKey), 
            $"ExternalInfo cannot contain reserved key: {reservedKey}");
    }
}
```

This ensures reserved callback keys remain system-controlled and cannot be set by users during token creation.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousCallback_CausesTransferDoS_Test()
{
    // Setup: Create malicious token with callback that reverts
    var maliciousTokenSymbol = "EVIL";
    var createInput = new CreateInput
    {
        Symbol = maliciousTokenSymbol,
        TokenName = "Evil Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true,
        Owner = DefaultAddress,
        ExternalInfo = new ExternalInfo()
    };
    
    // Set malicious callback that points to a reverting contract method
    createInput.ExternalInfo.Value["aelf_transfer_callback"] = 
        "{\"contract_address\":\"" + BasicFunctionContractAddress.ToBase58() + "\"," +
        "\"method_name\":\"RevertMethod\"}";
    
    // Create SEED and malicious token
    await CreateMutiTokenAsync(TokenContractStub, createInput);
    
    // Issue tokens to victim
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = maliciousTokenSymbol,
        Amount = 1000,
        To = User1Address
    });
    
    // Attempt transfer - should fail due to malicious callback
    var transferResult = await TokenContractStubUser.Transfer.SendWithExceptionAsync(new TransferInput
    {
        To = User2Address,
        Symbol = maliciousTokenSymbol,
        Amount = 100
    });
    
    // Verify DoS: transfer fails due to callback revert
    transferResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    transferResult.TransactionResult.Error.ShouldContain("RevertMethod");
}
```

This test demonstrates that a malicious token with a reverting callback makes all transfer operations fail, causing a permanent DoS for token holders.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-16)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```
