# Audit Report

## Title
NextRound Validation Fails to Detect Duplicate Mining Orders Due to Incorrect Distinct() Usage on Protobuf Objects

## Summary
The `NextRoundMiningOrderValidationProvider` incorrectly applies `Distinct()` to `MinerInRound` protobuf objects instead of their `FinalOrderOfNextRound` values. Since protobuf equality compares all fields, miners with duplicate `FinalOrderOfNextRound` but different `pubkey` values pass validation as distinct objects, allowing injection of duplicate mining orders that corrupt the consensus schedule.

## Finding Description

The validation provider checks for duplicate mining orders by applying `Distinct()` directly to `MinerInRound` objects: [1](#0-0) 

However, `MinerInRound` is a protobuf message with multiple fields including `pubkey`, `order`, `out_value`, `signature`, `in_value`, `expected_mining_time`, and `final_order_of_next_round`: [2](#0-1) 

Protobuf-generated C# classes implement equality by comparing ALL fields. Two `MinerInRound` objects with identical `final_order_of_next_round` values but different `pubkey` or other fields will be considered distinct by `.Distinct()`.

**Attack Path:**

1. A malicious miner crafts a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values (e.g., Miner A gets order 1, Miner B gets order 2, Miner C gets order 2)

2. The validation is registered for NextRound behavior: [3](#0-2) 

3. Validation counts 3 distinct objects (due to different pubkeys) matching 3 miners who mined, so it passes despite duplicate orders: [4](#0-3) 

4. The malicious round is saved to state: [5](#0-4) 

5. When generating the next round, `FinalOrderOfNextRound` values are directly assigned as `Order`: [6](#0-5) 

Both Miner B and C receive `Order = 2` in the next round.

## Impact Explanation

**CRITICAL - Consensus Integrity Breach**

This vulnerability breaks the fundamental invariant that each miner must have a unique mining order. The consequences include:

1. **Mining Time Conflicts**: Multiple miners have identical `ExpectedMiningTime` calculated from their order: [7](#0-6) 

2. **Available Order Miscalculation**: The `occupiedOrders` list contains duplicates, causing incorrect calculation of available orders for non-mining miners: [8](#0-7) 

   With duplicate orders in `occupiedOrders`, fewer available orders exist than needed, potentially causing index out-of-bounds exceptions when assigning orders to miners who didn't mine.

3. **Simultaneous Block Production**: Multiple miners attempt to produce blocks at the same time slot, creating fork risks and consensus failures.

4. **Persistent Corruption**: The corrupted round data propagates to subsequent rounds, causing sustained network instability.

This directly undermines AEDPoS consensus mechanism's deterministic mining schedule.

## Likelihood Explanation

**HIGH**

The attack is highly feasible:

- **Attacker Requirements**: Must be a valid miner in the current round (rotates among all participants)
- **Entry Point**: `NextRound` is a public contract method: [9](#0-8) 
- **Attack Complexity**: Straightforward - craft `NextRoundInput` with duplicate `FinalOrderOfNextRound` values during the attacker's NextRound turn
- **Detection**: Malicious data passes all validation checks and appears structurally valid
- **Cost**: No additional economic cost beyond normal block production

Any malicious miner can exploit this during their scheduled NextRound turn.

## Recommendation

Change the validation to check distinctness of the `FinalOrderOfNextRound` VALUES rather than the objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract value first
    .Distinct()
    .Count();
```

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_DuplicateOrdersBypass_ShouldFail()
{
    // Setup: 3 miners in current round
    var currentRound = GenerateRoundWith3Miners();
    
    // Attack: Craft NextRoundInput with duplicate FinalOrderOfNextRound
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = 
        {
            { "MinerA", new MinerInRound { Pubkey = "MinerA", FinalOrderOfNextRound = 1, OutValue = Hash.FromString("a") } },
            { "MinerB", new MinerInRound { Pubkey = "MinerB", FinalOrderOfNextRound = 2, OutValue = Hash.FromString("b") } },
            { "MinerC", new MinerInRound { Pubkey = "MinerC", FinalOrderOfNextRound = 2, OutValue = Hash.FromString("c") } } // DUPLICATE!
        }
    };
    
    // Validation should fail but doesn't due to object comparison
    var validator = new NextRoundMiningOrderValidationProvider();
    var context = new ConsensusValidationContext { ProvidedRound = maliciousInput.ToRound() };
    var result = validator.ValidateHeaderInformation(context);
    
    // BUG: Validation passes despite duplicate orders
    Assert.True(result.Success); // This SHOULD be False but isn't
    
    // Impact: Generate next round and verify duplicate Order assignments
    currentRound.GenerateNextRoundInformation(Timestamp.FromDateTime(DateTime.UtcNow), 
        Timestamp.FromDateTime(DateTime.UtcNow), out var nextRound);
    
    var minerBOrder = nextRound.RealTimeMinersInformation["MinerB"].Order;
    var minerCOrder = nextRound.RealTimeMinersInformation["MinerC"].Order;
    
    // Proof: Both miners have Order = 2
    Assert.Equal(2, minerBOrder);
    Assert.Equal(2, minerCOrder); // Consensus invariant violated!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L17-21)
```csharp
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L266-290)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-44)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```
