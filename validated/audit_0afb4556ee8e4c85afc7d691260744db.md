# Audit Report

## Title
Inadequate Validation Allows Time Slot Collisions via Duplicate FinalOrderOfNextRound Values

## Summary
The `NextRoundMiningOrderValidationProvider` incorrectly validates uniqueness of `FinalOrderOfNextRound` values by calling `.Distinct()` on `MinerInRound` objects instead of on the order values themselves. This allows malicious miners to set duplicate mining orders through `TuneOrderInformation`, causing multiple miners to receive identical time slots in the next round and compromising consensus integrity.

## Finding Description

The vulnerability exists in the validation logic that checks uniqueness of mining orders for the next round. The validation calls `.Distinct()` on a collection of `MinerInRound` objects rather than on the order values: [1](#0-0) 

Since `MinerInRound` is a protobuf-generated message type with 17 fields including the unique `pubkey` field, its auto-generated `Equals()` method compares all fields. Two `MinerInRound` objects with different pubkeys are never considered equal even if they have identical `FinalOrderOfNextRound` values, causing the validation to always pass regardless of duplicate order values. [2](#0-1) 

**Attack Vector - Via TuneOrderInformation:**

The `UpdateValueInput` message contains a `tune_order_information` field that maps miner public keys to mining order values: [3](#0-2) 

When processing an `UpdateValue` transaction, the contract directly applies these values to miners' `FinalOrderOfNextRound` without any validation of uniqueness or validity: [4](#0-3) 

The `UpdateValue` method is a public RPC that accepts arbitrary `UpdateValueInput` parameters: [5](#0-4) [6](#0-5) 

The only authorization check is that the sender must be an active miner in the current or previous round: [7](#0-6) 

**Consequence - Time Slot Collision:**

When generating the next round, duplicate `FinalOrderOfNextRound` values directly cause mining time slot collisions. The `GenerateNextRoundInformation` method calculates `ExpectedMiningTime` directly from the order value: [8](#0-7) 

If multiple miners have the same order value, they receive identical `ExpectedMiningTime` values since the calculation is `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`.

The `NextRoundMiningOrderValidationProvider` is only invoked during `NextRound` behavior, not during `UpdateValue` transactions when the malicious values are set: [9](#0-8) 

By the time validation runs, the duplicate orders are already committed to state.

## Impact Explanation

**Severity: HIGH**

This vulnerability directly compromises the core consensus mechanism. The AEDPoS protocol relies on each miner having a unique, non-overlapping time slot to produce blocks. When multiple miners receive identical `ExpectedMiningTime` values:

- Multiple miners attempt to produce blocks simultaneously, creating ambiguity about which block is legitimate
- This can lead to competing forks, consensus deadlock, or complete block production stalls  
- The network becomes unable to reliably advance the blockchain
- Recovery requires manual intervention or chain restart

The impact affects the entire network's operation, not just individual miners or users.

## Likelihood Explanation

**Probability: HIGH**

The attack is straightforward to execute:
- Any active miner (elected through normal processes) can exploit this vulnerability
- Requires only a single `UpdateValue` transaction with malicious `TuneOrderInformation`
- No complex timing, state manipulation, or collusion required
- The broken validation provides a false sense of security while allowing duplicates through

The preconditions are realistic: the attacker must be an active miner in the current round, which is achievable through the election process. The attack complexity is low with no special privileges needed beyond standard miner capabilities.

## Recommendation

The validation logic should check uniqueness of the `FinalOrderOfNextRound` values themselves, not the `MinerInRound` objects. Change the validation to:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract the order values
    .Distinct()
    .Count();
```

Additionally, add validation in `ProcessUpdateValue` to ensure `TuneOrderInformation` does not create duplicate orders:

```csharp
// Validate no duplicate orders before applying
var proposedOrders = updateValueInput.TuneOrderInformation.Values.ToList();
if (proposedOrders.Count != proposedOrders.Distinct().Count())
{
    Assert(false, "Duplicate orders in TuneOrderInformation");
}

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

## Proof of Concept

A malicious miner can craft an `UpdateValue` transaction with duplicate `FinalOrderOfNextRound` values in the `TuneOrderInformation` dictionary. For example:

```csharp
var maliciousInput = new UpdateValueInput
{
    // ... normal fields ...
    TuneOrderInformation = 
    {
        { "MinerB_Pubkey", 5 },  // Set MinerB to order 5
        { "MinerC_Pubkey", 5 }   // Set MinerC to same order 5
    }
};
```

When this transaction is processed:
1. `ProcessUpdateValue` applies both assignments without checking for duplicates
2. Both MinerB and MinerC now have `FinalOrderOfNextRound = 5`
3. Later, when `NextRound` is called, the validation checks `Distinct()` on the `MinerInRound` objects
4. Since MinerB and MinerC have different `pubkey` fields, they are considered distinct objects
5. Validation passes incorrectly
6. `GenerateNextRoundInformation` assigns both miners: `ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval * 5)`
7. Both miners receive identical time slots, causing consensus collision

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L29-31)
```text
    // Update consensus information.
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```
