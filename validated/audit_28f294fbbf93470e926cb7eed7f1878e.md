# Audit Report

## Title
Stale Period Cache Causes RegisterForProfits Auto-Distribution Failure After Direct ProfitContract Calls

## Summary
The TokenHolderContract maintains a cached period that becomes desynchronized from the ProfitContract's authoritative CurrentPeriod due to an early return in `UpdateTokenHolderProfitScheme()`. When a scheme manager legitimately calls ProfitContract.DistributeProfits directly, the period mismatch causes all subsequent RegisterForProfits operations with auto-distribution to fail with a period validation error, resulting in a denial of service for new token holder registrations.

## Finding Description

The vulnerability stems from a period synchronization failure between TokenHolderContract and ProfitContract. The TokenHolderContract caches a `Period` field that should mirror ProfitContract's `CurrentPeriod`, but an early return condition prevents synchronization: [1](#0-0) 

When `scheme.SchemeId` exists and `updateSchemePeriod` is false, this early return skips the period synchronization logic that queries ProfitContract's current state. [2](#0-1) 

The issue manifests through the following sequence:

1. **Manager calls ProfitContract.DistributeProfits directly** - The ProfitContract explicitly allows scheme managers to distribute profits: [3](#0-2) 

This increments the ProfitContract's CurrentPeriod: [4](#0-3) 

2. **TokenHolder's cached period becomes stale** - When RegisterForProfits is called, it invokes GetValidScheme with the default `updateSchemePeriod = false`: [5](#0-4) 

3. **Auto-distribute uses stale period** - The auto-distribute logic creates a DistributeProfitsInput using the stale cached period: [6](#0-5) 

4. **ProfitContract validation fails** - The strict period validation in ProfitContract rejects the mismatched period: [7](#0-6) 

The assertion fails because the input period (N) doesn't match the current period (N+1), causing transaction reversion.

## Impact Explanation

**Denial of Service Impact:**
- **Complete DoS of RegisterForProfits**: All users attempting to register for profits when auto-distribute is configured will have their transactions fail with a period validation error
- **Affects all new registrations**: Until the periods are manually re-synchronized by calling TokenHolder.DistributeProfits, no new users can join the scheme  
- **Operational disruption**: The TokenHolder scheme becomes non-functional for new participant onboarding, breaking a core protocol feature

**Severity Justification (Medium):**
- Causes operational DoS but does not result in fund loss or theft
- Breaks core dividend registration functionality that is essential for TokenHolder schemes
- Recovery requires manual intervention to re-sync periods
- Affects all users during the desynchronized state
- Does not compromise existing funds or allow unauthorized access

## Likelihood Explanation

**High Likelihood:**

This vulnerability will occur naturally in normal operations:

1. **Legitimate manager behavior**: Scheme managers calling ProfitContract.DistributeProfits directly is an explicitly authorized operation in the protocol design, not an attack vector

2. **Common configuration**: Auto-distribute thresholds are a standard feature that schemes commonly configure to automate profit distribution

3. **No special privileges required**: Only requires being a scheme manager (a normal protocol role) and users registering for profits (core protocol functionality)

4. **Low operational complexity**: The issue triggers with just two sequential normal operations:
   - Manager calls ProfitContract.DistributeProfits (standard management action)
   - User calls RegisterForProfits with auto-distribute threshold met (normal user action)

**Operational Rationale:**
Managers may legitimately prefer calling ProfitContract.DistributeProfits directly for integration with other contracts, custom distribution logic, or batch operations across multiple schemes.

## Recommendation

Fix the synchronization issue by always updating the cached period when the scheme exists, regardless of the `updateSchemePeriod` parameter. Modify `UpdateTokenHolderProfitScheme`:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId == null)
    {
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        scheme.SchemeId = originSchemeId;
    }
    
    // Always sync period if updateSchemePeriod is true, or if SchemeId was just set
    if (updateSchemePeriod || scheme.Period == 0)
    {
        var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[manager] = scheme;
    }
}
```

Alternatively, always call `GetValidScheme` with `updateSchemePeriod = true` in RegisterForProfits when auto-distribute is configured.

## Proof of Concept

```csharp
[Fact]
public async Task RegisterForProfits_Fails_After_Direct_ProfitContract_Distribution()
{
    // Setup: Create scheme with auto-distribute threshold
    var amount = 1000L;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = { { "ELF", amount } }
    });
    
    // Contribute profits to meet auto-distribute threshold
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = "ELF"
    });
    
    // Get scheme IDs
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds.First();
    
    // Manager calls ProfitContract.DistributeProfits directly (legitimate operation)
    // This increments ProfitContract's CurrentPeriod but TokenHolder's cache remains stale
    await ProfitContractStub.DistributeProfits.SendAsync(new Profit.DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    // Verify period mismatch: ProfitContract is now at period 2, but TokenHolder cache is at 1
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    profitScheme.CurrentPeriod.ShouldBe(2);
    
    var tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    tokenHolderScheme.Period.ShouldBe(1); // Stale!
    
    // Attempt RegisterForProfits - this will fail due to period mismatch in auto-distribute
    var result = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
    
    // Transaction fails with period validation error
    result.TransactionResult.Error.ShouldContain("Invalid period");
    result.TransactionResult.Error.ShouldContain("Current period is 2");
}
```

## Notes

This vulnerability demonstrates a classic cache synchronization issue where a local cache (TokenHolder's Period) can become stale when the source of truth (ProfitContract's CurrentPeriod) is updated through an alternative pathway. The issue is exacerbated by the design decision to allow both direct calls to ProfitContract and calls through TokenHolderContract, creating multiple update paths without consistent synchronization.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-152)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L193-197)
```csharp
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L289-289)
```csharp
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L295-297)
```csharp
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
