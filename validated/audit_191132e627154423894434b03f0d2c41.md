# Audit Report

## Title
Threshold Mismatch in Term Change Logic Enables Governance Denial-of-Service Attack

## Summary
The `NeedToChangeTerm` method contains a critical mismatch: the consensus threshold (`MinersCountOfConsent`) is calculated from the total miner count, but the actual vote count only includes miners who produced blocks. When the network has a miner count divisible by 3, attackers controlling exactly 1/3 of miners can block term transitions indefinitely by stopping block production, preventing new miner elections and delaying treasury distributions.

## Finding Description

The vulnerability stems from an architectural inconsistency in how term change consensus is determined.

The `MinersCountOfConsent` property calculates the required threshold as `RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1)`, computing ⌊2n/3⌋ + 1 based on the **total** miner count [1](#0-0) .

However, the `NeedToChangeTerm` method only counts miners who have `ActualMiningTimes.Any()` - meaning only **active** miners who produced blocks [2](#0-1) . The method's comment states "Change term if two thirds of miners latest ActualMiningTime meets threshold" [3](#0-2) , indicating intent for a standard 2/3 majority.

When n is divisible by 3, the formula produces inflated thresholds:
- n=3: requires 3 votes (100%) vs. 2/3 standard (66.7%)
- n=6: requires 5 votes (83.3%) vs. 2/3 standard (66.7%)  
- n=9: requires 7 votes (77.8%) vs. 2/3 standard (66.7%)

**Attack Scenario:**
1. Network configured with 6 miners via Parliament-controlled `SetMaximumMinersCount` [4](#0-3) 
2. Attacker controls 2 miners (exactly 1/3)
3. When term period expires, `GetConsensusBehaviourToTerminateCurrentRound` checks `NeedToChangeTerm` [5](#0-4) 
4. Attacker's 2 miners stop producing blocks (no `ActualMiningTimes` entries)
5. Only 4 honest miners have `ActualMiningTimes.Any()` = true
6. Count of 4 < `MinersCountOfConsent` of 5, so `NeedToChangeTerm` returns false
7. System returns `NextRound` instead of `NextTerm`, blocking term transition

The mismatch is critical: inactive miners don't count toward the threshold but DO inflate the required threshold.

## Impact Explanation

**Governance Layer Denial-of-Service:**
- New miners elected through the election contract cannot join because miner list updates only occur in `ProcessNextTerm` [6](#0-5) 
- Election snapshots are not taken [7](#0-6) , breaking the democratic election cycle
- Old miner set remains in power indefinitely until evil miner detection triggers after ~3 days

**Economic Disruption:**
- Treasury profit releases are delayed, as they only trigger during `ProcessNextTerm` [8](#0-7) 
- Current miners (including attackers) continue earning block rewards [9](#0-8)  that should go to newly elected miners
- Attackers who lost elections extend their tenure and reward earnings for multiple days

**Severity Assessment:** Medium - This constitutes a time-bounded DoS attack on governance and economic distribution systems. While block production continues and no funds are directly stolen, it disrupts democratic governance, delays legitimate distributions, and allows attackers to extract unearned rewards.

## Likelihood Explanation

**Preconditions:**
- Network must be configured with miner count divisible by 3 (3, 6, 9, 12, 15, 18, or 21)
- Default miner count is 17 [10](#0-9)  (not vulnerable)
- However, `SetMaximumMinersCount` is Parliament-controlled and only validates `input.Value > 0` [11](#0-10) 
- No validation prevents setting counts divisible by 3

**Attacker Capabilities:**
- Must control exactly n/3 miners when n is divisible by 3
- Attack execution is trivial: cease block production
- No transaction fees or technical complexity required

**Economic Rationality:**
- Attackers who are current miners but lost recent elections have strong incentive to delay replacement
- They continue earning substantial block rewards for 3+ days until evil miner detection triggers [12](#0-11) 
- Detection occurs via `TryToDetectEvilMiners` checking `MissedTimeSlots >= TolerableMissedTimeSlotsCount` [13](#0-12) 

**Likelihood Assessment:** Medium - While not exploitable in default configuration, the attack becomes feasible if governance sets a vulnerable miner count. The attack is then trivially executable by any actor controlling 1/3 of miners with rational economic incentives.

## Recommendation

**Option 1: Fix the threshold calculation**
Change `MinersCountOfConsent` to use ceiling division for true 2/3 majority:
```csharp
public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Add(2).Div(3);
```
This ensures ⌈2n/3⌉ which correctly represents "at least 2/3" for all values of n.

**Option 2: Count based on total miners, not active miners**
Modify `NeedToChangeTerm` to count all miners in `RealTimeMinersInformation`, treating miners without `ActualMiningTimes` as voting "no":
```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var agreeCount = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .Count(m => IsTimeToChangeTerm(blockchainStartTimestamp, 
            m.ActualMiningTimes.Last(), currentTermNumber, periodSeconds));
    return agreeCount >= MinersCountOfConsent;
}
```
This maintains the BFT threshold semantics while preventing inactive miners from blocking progress.

**Option 3: Add validation to SetMaximumMinersCount**
Prevent configuration of vulnerable miner counts:
```csharp
Assert(input.Value % 3 != 0, "Miner count cannot be divisible by 3 to ensure proper consensus thresholds.");
```

**Recommended approach:** Implement Option 2 (count all miners consistently) combined with Option 3 (validation) for defense in depth.

## Proof of Concept

```csharp
[Fact]
public void TermChangeDoS_WithSixMiners_WhenOneThirdStopMining()
{
    // Setup: Configure network with 6 miners (divisible by 3)
    var round = new Round
    {
        RoundNumber = 100,
        TermNumber = 5,
        RealTimeMinersInformation = new Dictionary<string, MinerInRound>()
    };
    
    // Add 6 miners
    for (int i = 1; i <= 6; i++)
    {
        round.RealTimeMinersInformation[$"miner{i}"] = new MinerInRound
        {
            Pubkey = $"miner{i}",
            Order = i,
            ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(i * 10)
        };
    }
    
    // Simulate: 4 honest miners produce blocks and agree term should change
    var blockchainStart = TimestampHelper.GetUtcNow().AddDays(-8); // 8 days ago
    var currentTerm = 5L;
    var periodSeconds = 604800L; // 7 days
    
    for (int i = 1; i <= 4; i++)
    {
        // These miners produced blocks AFTER term period expired
        round.RealTimeMinersInformation[$"miner{i}"].ActualMiningTimes.Add(
            TimestampHelper.GetUtcNow().AddDays(-1)); // 1 day ago, within new term period
    }
    
    // Attackers (miner5, miner6) stop mining - no ActualMiningTimes
    // They represent exactly 1/3 of miners
    
    // Verify: MinersCountOfConsent calculation
    var threshold = round.MinersCountOfConsent;
    threshold.ShouldBe(5); // ⌊12/3⌋ + 1 = 5, requires 83.3%
    
    // Verify: NeedToChangeTerm returns false
    var shouldChange = round.NeedToChangeTerm(blockchainStart, currentTerm, periodSeconds);
    shouldChange.ShouldBeFalse(); // Only 4 active miners < 5 threshold
    
    // Expected: With true 2/3 majority, threshold should be 4
    // 4 out of 6 miners (66.7%) should be sufficient for term change
    var expectedThreshold = (int)Math.Ceiling(6 * 2.0 / 3.0);
    expectedThreshold.ShouldBe(4);
    
    // Impact: Term transition blocked, governance DoS achieved
}
```

**Notes:**
- This vulnerability exploits the mismatch between threshold basis (total miners) and count basis (active miners)
- The formula ⌊2n/3⌋ + 1 may be intentional for Byzantine fault tolerance, but its application here creates an exploitable inconsistency
- The attack is time-limited by evil miner detection (~3 days), but causes significant governance and economic disruption during that period
- The default configuration (17 miners) is not vulnerable, but the system can be governance-configured into a vulnerable state

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L210-210)
```csharp
    ///     Change term if two thirds of miners latest ActualMiningTime meets threshold of changing term.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L7-7)
```csharp
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
