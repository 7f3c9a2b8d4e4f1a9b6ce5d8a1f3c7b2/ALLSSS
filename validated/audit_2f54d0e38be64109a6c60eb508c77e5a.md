# Audit Report

## Title
Miner Replacement Accepts Historical Candidates Without Current Stake Validation

## Summary
The miner replacement mechanism allows former candidates who have quit election and recovered their 100,000 ELF deposits to become miners by selecting replacements from historical term snapshots without validating current candidate status or locked stake, enabling mining without capital at risk.

## Finding Description

The vulnerability exists in the interaction between snapshot creation, candidate quit logic, and miner replacement selection across the AEDPoS Consensus and Election contracts.

**Snapshot Creation at Term End:**
When a term ends, `TakeSnapshot` creates a permanent historical record by iterating through all current candidates and storing their vote amounts. [1](#0-0)  This snapshot is stored in a state mapping and never modified after creation. [2](#0-1) 

**Candidate Quit After Snapshot:**
During the subsequent term, a candidate can call `QuitElection` which returns their 100,000 ELF deposit [3](#0-2)  and sets `IsCurrentCandidate` to false. [4](#0-3)  The deposit constant is 100,000 ELF (100_000_00000000). [5](#0-4) 

**Missing Validation in Replacement Selection:**
When evil miners are detected during round generation within the same term, the consensus contract calls `GetMinerReplacementInformation`. [6](#0-5) 

This method retrieves the previous term's snapshot via `GetPreviousTermSnapshotWithNewestPubkey()`. [7](#0-6)  The snapshot retrieval only filters candidates with invalid votes or replaces banned pubkeys - **it does not check `IsCurrentCandidate` status**. [8](#0-7) 

Alternative candidates are selected from this historical snapshot based on vote amounts recorded at the previous term's end. [9](#0-8) 

**Unvalidated Addition to Miner List:**
The returned alternative candidates are directly added to `RealTimeMinersInformation` by transferring the evil miner's consensus information, with no validation of current candidacy status or locked stake. [10](#0-9) 

**Insufficient Mining Permission Check:**
The mining permission validation only checks if a pubkey exists in `RealTimeMinersInformation.Keys`, with no validation of stake or candidate status. [11](#0-10) 

## Impact Explanation

This vulnerability fundamentally breaks the Proof-of-Stake security model by allowing miners to participate in consensus without locked capital:

**Consensus Security Breach:** Unauthorized entities without any stake can become miners and produce blocks, violating the core security assumption that miners must have "skin in the game." This eliminates the economic disincentive against malicious behavior.

**Economic Exploitation:** Attackers earn mining rewards without any capital at risk. If they misbehave (censorship, downtime, double-signing), there is no stake to slash. Legitimate miners have their rewards diluted by unauthorized participants who extracted their deposits.

**Systemic Risk:** The attack is undetectable on-chain as the unauthorized miner appears identical to legitimate miners in the miner list, compromising network security without visible anomalies.

## Likelihood Explanation

**Attack Complexity: LOW**
The attack requires only standard contract interactions:
1. Register as candidate in Term N (100,000 ELF deposit)
2. Obtain sufficient votes to rank high
3. Wait for Term N to end (predictable timing)
4. Call `QuitElection()` to recover deposit
5. Wait for natural evil miner detection (occurs when miners miss time slots)

**Preconditions: REALISTIC**
- Term transitions are deterministic at regular intervals
- Evil miner detection occurs naturally when miners fail to produce blocks
- No special permissions required
- All steps use public contract methods

**Detection: DIFFICULT**
The unauthorized miner appears identical to legitimate miners with no on-chain signals to differentiate them.

## Recommendation

Add validation in `GetMinerReplacementInformation` to verify that alternative candidates are currently registered with locked deposits:

```csharp
private List<string> GetValidAlternativeCandidates(TermSnapshot snapshot, List<string> currentMinerList)
{
    return snapshot.ElectionResult
        .Where(cs => {
            // Check current candidate status
            var candidateInfo = State.CandidateInformationMap[cs.Key];
            if (candidateInfo == null || !candidateInfo.IsCurrentCandidate) 
                return false;
            
            // Verify deposit is locked
            var lockId = candidateInfo.AnnouncementTransactionId;
            if (lockId == null || lockId == Hash.Empty) 
                return false;
                
            return !State.InitialMiners.Value.Value.Contains(
                ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key)))
                && !currentMinerList.Contains(cs.Key);
        })
        .OrderByDescending(s => s.Value)
        .Select(c => c.Key)
        .ToList();
}
```

Additionally, validate candidate status in `GenerateNextRoundInformation` before adding alternative candidates to the miner list.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. **Setup:** Candidate registers in Term N with 100,000 ELF deposit and obtains votes
2. **Term Transition:** Term N ends, snapshot is created with candidate's vote data
3. **Exploit:** Candidate calls `QuitElection()` and recovers 100,000 ELF in Term N+1
4. **Trigger:** Evil miner is detected (missed time slots)
5. **Result:** Quit candidate is selected from historical snapshot and added to miner list
6. **Verification:** Former candidate can now mine blocks without any locked deposit

The test would verify that:
- Candidate's deposit balance increases by 100,000 ELF after quit
- Candidate's `IsCurrentCandidate` flag is false
- Candidate's pubkey is added to `RealTimeMinersInformation` after replacement
- Candidate can successfully produce blocks and earn rewards

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L459-479)
```csharp
    private void SavePreviousTermInformation(TakeElectionSnapshotInput input)
    {
        var snapshot = new TermSnapshot
        {
            MinedBlocks = input.MinedBlocks,
            EndRoundNumber = input.RoundNumber
        };

        if (State.Candidates.Value == null) return;

        foreach (var pubkey in State.Candidates.Value.Value)
        {
            var votes = State.CandidateVotes[pubkey.ToHex()];
            var validObtainedVotesAmount = 0L;
            if (votes != null) validObtainedVotesAmount = votes.ObtainedActiveVotedVotesAmount;

            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
        }

        State.Snapshots[input.TermNumber] = snapshot;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L40-40)
```csharp
    public MappedState<long, TermSnapshot> Snapshots { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L240-249)
```csharp
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-252)
```csharp
        candidateInformation.IsCurrentCandidate = false;
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L130-161)
```csharp
    private TermSnapshot GetPreviousTermSnapshotWithNewestPubkey()
    {
        var termNumber = State.CurrentTermNumber.Value.Sub(1);
        var snapshot = State.Snapshots[termNumber];
        if (snapshot == null) return null;
        var invalidCandidates = snapshot.ElectionResult.Where(r => r.Value <= 0).Select(r => r.Key).ToList();
        Context.LogDebug(() => $"Invalid candidates count: {invalidCandidates.Count}");
        foreach (var invalidCandidate in invalidCandidates)
        {
            Context.LogDebug(() => $"Invalid candidate detected: {invalidCandidate}");
            if (snapshot.ElectionResult.ContainsKey(invalidCandidate)) snapshot.ElectionResult.Remove(invalidCandidate);
        }

        if (!snapshot.ElectionResult.Any()) return snapshot;

        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }

        return snapshot;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-363)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```
