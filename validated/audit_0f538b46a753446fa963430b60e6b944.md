# Audit Report

## Title
Unbounded Nested Loop Complexity in Consensus Round Update Causes Block Production Denial of Service

## Summary
The `ApplyNormalConsensusData` function in the AEDPoS consensus contract contains nested loops with O(c×n²) computational complexity that can exceed AElf's execution branch threshold of 15,000, causing block production to fail with `RuntimeBranchThresholdExceededException`. When governance legitimately scales `MaximumMinersCount` to 100+ miners and order conflicts occur, the conflict resolution algorithm triggers excessive branch counting, halting consensus operations.

## Finding Description

The vulnerability exists in the consensus round update logic where miners calculate their next-round order assignments. The nested loop structure in `ApplyNormalConsensusData` creates O(c×n²) complexity: [1](#0-0) 

The outer `foreach` iterates over conflicts (miners with duplicate `FinalOrderOfNextRound`), the inner `for` loop searches up to `2×minersCount` positions, and the `All()` method checks all `minersCount` miners for each candidate position.

This function is invoked during normal block production. The execution path is:

1. Block production calls `GetConsensusExtraData`: [2](#0-1) 

2. Which routes to `GetConsensusExtraDataToPublishOutValue` for UpdateValue behavior: [3](#0-2) 

3. Which calls `ApplyNormalConsensusData`: [4](#0-3) 

The critical failure point is that `SetMaximumMinersCount` has no upper bound validation: [5](#0-4) 

AElf enforces execution limits through branch counting: [6](#0-5) 

The branch counter increments at every loop iteration and throws an exception when the threshold is reached: [7](#0-6) 

Order assignment is hash-based, creating natural collision probability: [8](#0-7) [9](#0-8) 

With minersCount=100 and conflicts=3, the total branch count reaches approximately 60,000 (3 × 200 × 100), which is 4× over the 15,000 threshold, causing block production to fail.

## Impact Explanation

**Operational DoS of Consensus:**
- When `ApplyNormalConsensusData` exceeds the branch threshold, it throws `RuntimeBranchThresholdExceededException` [10](#0-9) 
- The miner cannot generate valid consensus extra data, preventing block production
- If multiple miners encounter this condition simultaneously, the blockchain experiences block production delays or complete halts
- Recovery requires emergency governance action to reduce `MaximumMinersCount`, which itself requires functional block production

**Quantified Threshold Breach:**
- minersCount=50, conflicts=6: ~30,000 branches (2× over threshold)
- minersCount=100, conflicts=3: ~60,000 branches (4× over threshold)
- minersCount=200, conflicts=2: ~160,000 branches (10.7× over threshold)

**Severity Justification:**
High severity because it causes operational DoS of the core consensus mechanism. While it requires governance to set enabling parameters, this is a legitimate network scaling action, not a malicious configuration.

## Likelihood Explanation

**Preconditions:**
1. Governance sets `MaximumMinersCount` to 100+ through Parliament proposal (legitimate scaling action requiring only governance approval, not special privileges)
2. Order conflicts occur among miners through hash collisions (natural birthday paradox behavior)

**Attack Complexity:**
- Medium: Does not require compromising governance or any cryptographic primitives
- Natural network scaling toward 100+ miners is a predictable evolution path
- Hash-based order assignment creates natural collision probability that increases with miner count
- With 100 miners, birthday paradox mathematics ensures conflicts occur regularly
- Malicious miners could intentionally manipulate signatures to create conflicts, though natural collisions are sufficient

**Feasibility:**
- Execution limits are enforced at runtime during normal block production
- No complexity checks or upper bounds exist on miner count beyond the minimal positive value check
- Reachable through standard consensus flow without special permissions

**Probability Reasoning:**
Medium-to-High likelihood as the chain matures. The current 17-miner configuration is safe, but scaling toward 50-100 miners creates a critical risk zone. Natural network evolution makes this increasingly probable without requiring any malicious actor.

## Recommendation

Add an upper bound check in `SetMaximumMinersCount` to prevent DoS scenarios:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    // Add upper bound to prevent branch threshold DoS
    Assert(input.Value <= 50, "Maximum miners count exceeds safety threshold.");
    
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");
    // ... rest of implementation
}
```

Alternatively, optimize the conflict resolution algorithm in `ApplyNormalConsensusData`:
1. Use a HashSet to track used orders instead of `.All()` for O(1) lookups
2. Break early when a valid order is found
3. Add a maximum retry limit to prevent unbounded loops

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting `MaximumMinersCount` to 100 via governance proposal
2. Simulating 3 miners with hash collisions in their order assignments
3. Observing `RuntimeBranchThresholdExceededException` during `ApplyNormalConsensusData` execution
4. Verifying branch count exceeds 15,000 threshold (approximately 60,000 branches executed)

The mathematical calculation: 3 conflicts × 200 maximum search iterations × 100 `.All()` checks per iteration = 60,000 total branch instructions, which is 4× the 15,000 threshold limit enforced by the execution observer.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-30)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-35)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** src/AElf.Sdk.CSharp/Exceptions.cs (L77-86)
```csharp
public class RuntimeBranchThresholdExceededException : BaseAElfException
{
    public RuntimeBranchThresholdExceededException()
    {
    }

    public RuntimeBranchThresholdExceededException(string message) : base(message)
    {
    }
}
```
