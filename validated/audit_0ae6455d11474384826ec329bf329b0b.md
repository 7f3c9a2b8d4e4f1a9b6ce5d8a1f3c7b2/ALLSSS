# Audit Report

## Title
Incorrect Balance Validation in Recharge Allows Side Chain to Run Out of Indexing Funds Immediately

## Summary
The `Recharge` function in the CrossChain contract contains a mathematically flawed balance validation formula that double-counts the recharge amount and arrears. This allows side chains to successfully recharge with insufficient funds, causing them to immediately re-enter debt status after the next block indexing operation, disrupting cross-chain data flow and leaving indexing proposers unpaid.

## Finding Description

The vulnerability exists in the balance validation logic when a side chain recharges while in `IndexingFeeDebt` status. [1](#0-0) 

The execution flow has a critical ordering flaw:

1. **Recharge transfer** - The function first transfers `input.Amount` tokens to the side chain's virtual address [2](#0-1) 

2. **Arrears payment** - If the chain is in debt, it pays all accumulated arrears from the side chain's virtual address to creditors [3](#0-2) 

3. **Balance retrieval** - It retrieves the current balance AFTER both operations above [4](#0-3) 

4. **Flawed validation** - It validates using the formula: `input.Amount + originBalance >= arrearsAmount + IndexingPrice` [5](#0-4) 

**Root Cause**: The `GetSideChainIndexingFeeDeposit` helper method [6](#0-5)  returns the balance AFTER the recharge and arrears payment have already executed. Therefore:
- `originBalance = initial_balance + input.Amount - arrearsAmount`

Substituting into the validation formula:
- `input.Amount + (initial_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice`
- Simplifies to: `2*input.Amount + initial_balance >= 2*arrearsAmount + IndexingPrice`

The correct check should ensure the final balance covers at least one indexing operation:
- `final_balance >= IndexingPrice`
- `initial_balance + input.Amount - arrearsAmount >= IndexingPrice`
- Rearranged: `initial_balance + input.Amount >= arrearsAmount + IndexingPrice`

The actual formula double-counts both `input.Amount` and `arrearsAmount`, allowing recharges that leave insufficient funds.

**Concrete Example**:
- Initial balance: 5 tokens
- Arrears: 90 tokens  
- IndexingPrice: 20 tokens
- Recharge amount: 100 tokens

Current validation: `100 + 15 >= 90 + 20` → `115 >= 110` ✓ PASSES
But final balance: `5 + 100 - 90 = 15 < 20` ✗ INSUFFICIENT

Correct validation: `5 + 100 >= 90 + 20` → `105 >= 110` ✗ WOULD CORRECTLY FAIL

**Secondary Issue**: When the side chain is NOT in debt status, the validation is completely skipped [7](#0-6) , allowing arbitrarily small recharges regardless of `IndexingPrice`.

## Impact Explanation

**Operational Disruption**: When a side chain successfully recharges with insufficient funds due to this flawed validation, it immediately returns to `IndexingFeeDebt` status after the next indexing operation executes. The indexing mechanism deducts `IndexingPrice` for each indexed block [8](#0-7) , and when the balance becomes negative, the chain enters debt status and arrears accumulate [9](#0-8) .

**Severity Justification (Medium)**:
- Side chain operators experience "successful" recharges that fail operationally
- Proposers who index the next block are not paid, accumulating arrears instead
- Cross-chain data flow is disrupted as chains cycle between Active and Debt states
- No direct fund theft occurs, but protocol operational reliability is severely compromised
- Affects all stakeholders: side chain operators, indexing proposers, and cross-chain applications relying on consistent data availability

The vulnerability breaks the fundamental guarantee that a successful recharge should restore the chain to operational Active status for at least one indexing cycle.

## Likelihood Explanation

**Reachable Entry Point**: The `Recharge` function is a public method callable by any address [10](#0-9) .

**Feasible Preconditions**:
1. A side chain exists with non-zero `IndexingPrice`
2. The chain is in `IndexingFeeDebt` status with accumulated arrears (common scenario)
3. User attempts to recharge with an amount in the vulnerable range: where `2*input.Amount >= arrearsAmount + IndexingPrice` but `input.Amount < arrearsAmount + IndexingPrice`

**Execution Practicality**: This vulnerability triggers during normal operational workflows without requiring any attack intent. Side chain operators routinely recharge their chains, and the flaw manifests whenever the recharge amount falls within the vulnerable mathematical range. This is particularly likely when operators calculate "just enough" to cover arrears without accounting for the next indexing operation.

**Probability Assessment**: High - The flaw will manifest during routine operations whenever recharge amounts are calculated based on arrears alone, which is a natural operational pattern. No special privileges, attack sophistication, or economic irrationality required.

## Recommendation

Fix the validation logic by checking the balance BEFORE the recharge and arrears payment operations, or adjust the formula to account for the correct sequence of operations.

**Option 1: Check balance before operations**
```csharp
public override Empty Recharge(RechargeInput input)
{
    var chainId = input.ChainId;
    var sideChainInfo = State.SideChainInfo[chainId];
    Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
        "Side chain not found or incorrect side chain status.");

    long arrearsAmount = 0;
    if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
    {
        foreach (var arrears in sideChainInfo.ArrearsInfo)
            arrearsAmount += arrears.Value;
    }
    
    // Get balance BEFORE transfer
    var initialBalance = GetSideChainIndexingFeeDeposit(chainId);
    
    // Validate BEFORE any transfers
    Assert(initialBalance + input.Amount >= arrearsAmount + sideChainInfo.IndexingPrice,
        "Indexing fee recharging not enough.");

    TransferFrom(new TransferFromInput
    {
        From = Context.Sender,
        To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
        Symbol = Context.Variables.NativeSymbol,
        Amount = input.Amount,
        Memo = "Indexing fee recharging."
    });

    if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
    {
        foreach (var arrears in sideChainInfo.ArrearsInfo)
        {
            TransferDepositToken(new TransferInput
            {
                To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                Symbol = Context.Variables.NativeSymbol,
                Amount = arrears.Value,
                Memo = "Indexing fee recharging."
            }, chainId);
        }
    }

    sideChainInfo.ArrearsInfo.Clear();
    sideChainInfo.SideChainStatus = SideChainStatus.Active;
    State.SideChainInfo[chainId] = sideChainInfo;
    return new Empty();
}
```

**Option 2: Always validate regardless of debt status**
```csharp
// Always check that the final balance will be sufficient
var initialBalance = GetSideChainIndexingFeeDeposit(chainId);
long arrearsAmount = 0;
if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
{
    foreach (var arrears in sideChainInfo.ArrearsInfo)
        arrearsAmount += arrears.Value;
}

Assert(initialBalance + input.Amount >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

## Proof of Concept

```csharp
[Fact]
public async Task RechargeForSideChain_InsufficientFunds_DoubleCountingBug()
{
    var parentChainId = 123;
    long lockedToken = 5;  // Initial balance: 5 tokens
    long indexingPrice = 20;  // Price per block: 20 tokens
    long parentChainHeightOfCreation = 10;

    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, 
        parentChainId, 
        lockedToken,
        indexingPrice);

    // Index blocks to create debt
    // First block: 5 - 20 = -15 (enters debt, 20 tokens arrears)
    var fakeSideChainBlockHash = HashHelper.ComputeFrom("sideChainBlockHash");
    var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("txMerkleTreeRoot");
    
    var sideChainBlockData = CreateSideChainBlockData(
        fakeSideChainBlockHash, 1, sideChainId, fakeTxMerkleTreeRoot);
    
    await DoIndexAsync(new CrossChainBlockData
    {
        SideChainBlockDataList = { sideChainBlockData }
    }, new[] { sideChainId });

    // Verify chain is in debt with 20 tokens arrears
    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(
        new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(20);  // 20 tokens in arrears

    // Now recharge with amount that satisfies flawed validation but is insufficient
    // Current balance: 0 (all used)
    // Arrears: 20
    // IndexingPrice: 20
    // Recharge: 25 tokens
    
    // Flawed validation: 25 + (0 + 25 - 20) >= 20 + 20 → 30 >= 40 ✗ Actually FAILS
    // Let's use 30 tokens: 30 + (0 + 30 - 20) >= 20 + 20 → 40 >= 40 ✓ PASSES
    // But final balance: 0 + 30 - 20 = 10 < 20 ✗ INSUFFICIENT
    
    await ApproveBalanceAsync(30);
    var rechargeInput = new RechargeInput
    {
        ChainId = sideChainId,
        Amount = 30
    };
    
    // This should fail but passes due to double-counting bug
    var rechargeTx = await CrossChainContractStub.Recharge.SendAsync(rechargeInput);
    rechargeTx.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify chain is marked Active
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.Active);
    
    // Verify final balance is only 10 tokens (insufficient for one indexing)
    var balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(10);  // 0 + 30 - 20 = 10 < 20 (IndexingPrice)
    
    // Index one more block - chain immediately goes back to debt
    var sideChainBlockData2 = CreateSideChainBlockData(
        fakeSideChainBlockHash, 2, sideChainId, fakeTxMerkleTreeRoot);
    
    await DoIndexAsync(new CrossChainBlockData
    {
        SideChainBlockDataList = { sideChainBlockData2 }
    }, new[] { sideChainId });
    
    // Chain is back in debt immediately after "successful" recharge
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    // New arrears accumulated (10 tokens paid, 10 more owed)
    debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(
        new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(10);  // 20 - 10 = 10 tokens still owed
}
```

## Notes

This vulnerability demonstrates a critical operational flaw where the mathematical formula for balance validation contains an ordering error that leads to double-counting. The issue is particularly insidious because:

1. The recharge transaction succeeds (doesn't revert)
2. The side chain is marked as Active
3. Users believe they have successfully restored operational status
4. The very next indexing operation immediately returns the chain to debt status

This creates a poor user experience and operational unreliability for the cross-chain system, even though no funds are directly stolen. The secondary issue of skipped validation for Active chains compounds the problem by allowing arbitrarily small recharges that cannot sustain even a single indexing operation.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L842-844)
```csharp
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L846-876)
```csharp
                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }
```
