# Audit Report

## Title
Parliament Governance Deadlock via Approval-Rejection Threshold Gap

## Summary
The Parliament contract's default voting thresholds contain a mathematical deadlock zone caused by asymmetric inequality operators (strict `>` for rejection, inclusive `>=` for approval) combined with threshold values that sum to less than 100%. This allows proposals to remain permanently stuck in pending state when 13.33%-20% of miners reject while others split between approval and abstention, preventing both formal rejection and approval.

## Finding Description

The Parliament contract defines default threshold constants that create an exploitable gap between approval and rejection requirements [1](#0-0) .

The proposal rejection logic uses **strict inequality** (`>`) requiring MORE than 20% to formally reject a proposal [2](#0-1) .

Meanwhile, the approval logic uses **inclusive inequality** (`>=`) requiring AT LEAST 66.67% to approve [3](#0-2) .

**Root Cause:** The validation function explicitly allows threshold configurations where `MaximalRejectionThreshold + MinimalApprovalThreshold <= AbstractVoteTotal`, permitting the deadlock gap [4](#0-3) .

With default values of 2000 + 6667 = 8667 ≤ 10000, there exists a **13.33% gap** where proposals cannot be approved or rejected.

**Mathematical Proof with 100 miners:**
- To REJECT: rejectionCount * 10000 > 200000 requires 21+ rejections (strict >)
- To APPROVE: approvalCount * 10000 >= 666700 requires 67+ approvals (inclusive >=)
- With exactly 20 rejections and 66 approvals: Neither threshold is met → **Deadlock**

The release mechanism confirms proposals can only be released when thresholds are satisfied, blocking execution in deadlock state [5](#0-4) .

**Why Existing Protections Fail:**

1. The validation explicitly permits this configuration as shown above
2. `ClearProposal` only removes expired proposals after timeout - it doesn't resolve deadlock, just cleans up afterwards [6](#0-5) 
3. `ChangeOrganizationThreshold` creates a circular dependency: it requires the organization address itself as sender, which only acts as sender when proposals are released via `SendVirtualInlineBySystemContract` - but deadlocked proposals cannot be released [7](#0-6) 

## Impact Explanation

**Critical Governance Denial-of-Service:**

The default Parliament organization serves as the authority controller for system-wide governance functions. The MultiToken contract uses it as the MethodFeeController [8](#0-7) , the Configuration contract uses it as the ConfigurationController [9](#0-8) , and the Consensus contract uses it to control maximum miners count [10](#0-9) .

A deadlocked Parliament proposal prevents execution of:
- **Security fixes:** Emergency patches for vulnerabilities cannot be deployed
- **Parameter updates:** Method fees, economic parameters, consensus settings
- **Contract upgrades:** Critical system contract improvements blocked
- **Configuration changes:** System-wide settings frozen

**No Escape Path:** The Emergency Response Organization cannot resolve this as it requires the default organization to create it and has separate authority scope [11](#0-10) .

**Severity: HIGH** - While not directly stealing funds, this enables minority censorship of critical governance actions, potentially preventing security fixes or necessary protocol adaptations that could lead to greater harm. The circular dependency makes recovery impossible without contract redeployment.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Control or coordination of 13-20 miners out of ~100 (13.33%-20% minority)
- Standard voting permissions via Parliament member status (elected miners)
- No special privileges needed beyond normal governance participation

**Attack Complexity: LOW**
- Execute through normal `Reject()` method calls [12](#0-11) 
- No technical sophistication required
- Can occur organically during contentious governance debates without coordination
- Natural vote splits in divisive scenarios may trigger deadlock unintentionally

**Feasibility Conditions:**
- Parliament members are elected miners from the current miner list (realistic precondition)
- Coordination among 13-20 miners is achievable for organized minority groups
- Controversial proposals naturally create vote fragmentation
- Detection is difficult - appears as legitimate disagreement until expiration

**Likelihood: MEDIUM-HIGH** - The attack is technically trivial to execute, requires no special access beyond elected miner status, and can occur either through deliberate minority coordination or organically in divisive governance scenarios.

## Recommendation

Modify the validation function to ensure approval and rejection thresholds have no gap. The validation should enforce:

```
MaximalRejectionThreshold + MinimalApprovalThreshold >= AbstractVoteTotal
```

Additionally, consider:
1. Using consistent inequality operators (both strict or both inclusive)
2. Setting emergency override mechanisms with separate authority that doesn't depend on the deadlocked organization
3. Implementing time-weighted automatic threshold relaxation for aged proposals
4. Adding explicit "deadlock" state detection with alternative resolution paths

## Proof of Concept

```csharp
// Test demonstrating deadlock scenario
[Fact]
public async Task ParliamentDeadlock_20Rejections_66Approvals_ProposalStuck()
{
    // Setup: 100 miners total, default organization with 6667/2000 thresholds
    var minerCount = 100;
    var defaultOrganization = await GetDefaultParliamentOrganization();
    
    // Create proposal
    var proposalId = await CreateTestProposal(defaultOrganization);
    
    // 20 miners reject (exactly 20% - not enough to formally reject with strict >)
    for (int i = 0; i < 20; i++)
        await MinersReject(proposalId, i);
    
    // 66 miners approve (exactly 66% - not enough to approve with inclusive >=)
    for (int i = 20; i < 86; i++)
        await MinersApprove(proposalId, i);
    
    // 14 miners abstain or don't vote
    for (int i = 86; i < 100; i++)
        await MinersAbstain(proposalId, i);
    
    // Verify: Cannot release (IsReleaseThresholdReached returns false)
    var releaseResult = await ParliamentContract.Release(proposalId);
    Assert.False(releaseResult.Success); // "Not approved" assertion fails
    
    // Verify: Not formally rejected (IsProposalRejected returns false)
    var proposal = await ParliamentContract.GetProposal(proposalId);
    Assert.False(proposal.ToBeReleased); // Stuck in pending
    
    // Verify: Cannot fix thresholds due to circular dependency
    var changeThresholdProposal = await CreateChangeThresholdProposal();
    // This proposal would face the same deadlock - cannot pass to fix itself
}
```

## Notes

The vulnerability is architecturally unsound due to the circular dependency: the only method to fix the thresholds (`ChangeOrganizationThreshold`) requires the organization itself to execute it via a released proposal, but deadlocked proposals cannot be released. This creates an unrecoverable governance failure state that can only be resolved through contract redeployment or hard fork, making it a critical availability vulnerability despite not directly impacting funds.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-9)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L96-112)
```csharp
    public override Empty Reject(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Rejections.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L203-210)
```csharp
    public override Empty CreateEmergencyResponseOrganization(Empty input)
    {
        Assert(State.EmergencyResponseOrganizationAddress.Value == null,
            "Emergency Response Organization already exists.");
        AssertSenderAddressWith(State.DefaultOrganizationAddress.Value);
        CreateEmergencyResponseOrganization();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L95-109)
```csharp
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_Helper.cs (L8-19)
```csharp
    private AuthorityInfo GetDefaultConfigurationController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```
