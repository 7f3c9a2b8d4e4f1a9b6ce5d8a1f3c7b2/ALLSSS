# Audit Report

## Title
LibInformationValidationProvider Bypass Through Pre-Validation State Modification

## Summary
The `LibInformationValidationProvider` monotonicity check is completely bypassed because `RecoverFromUpdateValue` modifies the `baseRound` object in-place before validation occurs. This allows malicious miners to report artificially low `ImpliedIrreversibleBlockHeight` values, potentially delaying Last Irreversible Block (LIB) advancement and affecting consensus finality guarantees.

## Finding Description

The AEDPoS consensus validation system contains a critical ordering flaw in the validation pipeline.

**Root Cause:**

When `ValidateBeforeExecution` processes `UpdateValue` consensus behavior, it fetches `baseRound` from state and immediately calls `RecoverFromUpdateValue` to restore full round information: [1](#0-0) [2](#0-1) 

The `RecoverFromUpdateValue` method modifies `baseRound` in-place, overwriting critical fields including `ImpliedIrreversibleBlockHeight`: [3](#0-2) 

After this modification, the validation context is created using the already-modified `baseRound`: [4](#0-3) 

**Why the Protection Fails:**

The `LibInformationValidationProvider` is added to validate `UpdateValue` behavior: [5](#0-4) 

This validator attempts to check that the provided `ImpliedIrreversibleBlockHeight` is not lower than the value in `baseRound`: [6](#0-5) 

However, the validation context's `BaseRound` property references the already-modified round object, while `ProvidedRound` accesses the original round from block header: [7](#0-6) 

Since `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was already set equal to `providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` by the earlier `RecoverFromUpdateValue` call, the comparison becomes `X > X`, which is always false, so the validation never rejects decreasing values.

## Impact Explanation

**Consensus Finality Degradation:**

The `ImpliedIrreversibleBlockHeight` values are directly used in the Last Irreversible Block (LIB) height calculation. When processing update values, the malicious low value gets persisted to state: [8](#0-7) 

The LIB calculator retrieves implied heights from miners and uses them to determine consensus finality: [9](#0-8) 

The algorithm selects the value at position `(count-1)/3` from sorted implied heights: [10](#0-9) 

**Specific Harms:**

1. **Delayed Finality**: Malicious miners reporting artificially low values drag down the median calculation, preventing proper LIB advancement
2. **Cross-Chain Impact**: LIB height is used for cross-chain transaction verification and finality guarantees
3. **Time-Sensitive Operations**: Any operations depending on block finalization are delayed
4. **Consensus Integrity**: Violates the monotonicity invariant that each miner's `ImpliedIrreversibleBlockHeight` should only increase

While no direct fund theft occurs, consensus finality is a critical security property. The bypass completely disables an important monotonicity check.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a consensus miner (privileged but within scope for consensus security analysis)
- No additional permissions required beyond normal mining operations

**Attack Complexity:**
- Trivial: Simply provide a lower `ImpliedIrreversibleBlockHeight` value when producing blocks
- Expected value should be `Context.CurrentHeight`: [11](#0-10) 
- Attacker provides value less than their previously reported height
- Validation bypass is automatic and deterministic

**Feasibility:**
- Reachable through normal `UpdateValue` consensus transaction flow
- No race conditions or timing requirements
- Low economic cost (normal mining operations)

**Detection:**
- Requires monitoring historical `ImpliedIrreversibleBlockHeight` values per miner across rounds
- Not immediately detectable without cross-round comparison
- Could appear as "slow" or "buggy" miner rather than malicious

**Probability:** High likelihood of exploitation if a miner becomes malicious, as the attack is trivial to execute and provides strategic advantages in controlling finality.

## Recommendation

Fix the ordering issue by performing validation **before** modifying the base round. Create a copy of the base round for recovery operations, or restructure the validation to use the unmodified state:

**Option 1**: Validate first, then recover:
```csharp
// In ValidateBeforeExecution, perform validation before calling RecoverFromUpdateValue
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound.Clone(), // Use original unmodified round
    // ... other fields
};

// Run validation with unmodified baseRound
var validationResult = service.ValidateInformation(validationContext);
if (validationResult.Success == false)
    return validationResult;

// Only after validation passes, recover the round
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**Option 2**: Store original value before modification:
```csharp
// In RecoverFromUpdateValue, preserve original for validation
var originalImpliedHeight = minerInRound.ImpliedIrreversibleBlockHeight;
// Store this in the round or return it for validation checks
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. A miner produces a block with `UpdateValue` behavior
2. In block N, miner's `ImpliedIrreversibleBlockHeight` is set to 100
3. In block N+K, same miner provides `ImpliedIrreversibleBlockHeight` = 50 (lower than previous)
4. `ValidateBeforeExecution` fetches round with value 100
5. `RecoverFromUpdateValue` overwrites it to 50
6. `LibInformationValidationProvider` checks if `50 > 50` â†’ false, validation passes
7. Value 50 gets persisted to state, violating monotonicity
8. LIB calculation now uses the artificially low value of 50, delaying finality

This can be tested by modifying a consensus node to provide decreasing `ImpliedIrreversibleBlockHeight` values and observing that validation does not reject the blocks, and LIB advancement is delayed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-19)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-27)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```
