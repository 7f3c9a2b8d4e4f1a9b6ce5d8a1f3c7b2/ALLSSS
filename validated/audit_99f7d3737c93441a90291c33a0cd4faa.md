# Audit Report

## Title
Duplicate Initial Miners Can Cause Consensus DoS During Term Transition

## Summary
The AEDPoS consensus contract's `GenerateFirstRoundOfNewTerm` method lacks duplicate public key filtering before calling `ToDictionary`, causing an `ArgumentException` when duplicate initial miners exist. This results in complete consensus failure during term transitions when the Election contract falls back to using unvalidated initial miners.

## Finding Description

The vulnerability exists across three critical locations:

**1. Missing Deduplication in Round Generation:**
The contract's `GenerateFirstRoundOfNewTerm` method directly converts miner public keys to a dictionary without duplicate removal [1](#0-0) , whereas the kernel extension version includes `.Distinct()` for safety [2](#0-1) .

**2. No Validation During Initialization:**
The Election contract's `InitialElectionContract` method accepts the initial miner list without any duplicate validation [3](#0-2) , allowing duplicates to persist in `State.InitialMiners.Value`.

**3. Duplicate Preservation in Fallback Path:**
When valid candidates are insufficient, the `GetVictories` method's fallback logic adds initial miners to the backups list [4](#0-3) . The filter `Where(k => !backups.Contains(k))` only prevents duplicates **between** the backups list and initial miners, but does NOT deduplicate **within** the initial miners list itself. If `State.InitialMiners.Value` contains `[A, A, B]`, both A entries pass the filter when backups doesn't already contain A.

**Execution Flow:**
During term transitions, `GetConsensusExtraDataForNextTerm` [5](#0-4)  calls `GenerateFirstRoundOfNextTerm` [6](#0-5) , which retrieves victories via `TryToGetVictories` [7](#0-6) . The Election contract returns the potentially duplicated miner list [8](#0-7) , which is then passed to `victories.GenerateFirstRoundOfNewTerm()`, triggering the `ArgumentException` on the unprotected `ToDictionary` call.

## Impact Explanation

**Critical Consensus DoS:**
- When duplicate public keys exist in the miner list, the `ToDictionary` operation throws `ArgumentException` with message "An item with the same key has already been added"
- Term generation fails completely, preventing consensus from advancing to the next term
- The blockchain enters a halted state as no new blocks can be produced after the current term expires
- All network participants are affected simultaneously - validators cannot mine, transactions cannot be processed
- No automatic recovery mechanism exists in the protocol
- Requires emergency governance intervention or chain fork to resolve

**Severity: High** - This is a complete availability attack on the entire blockchain network, breaking the fundamental consensus liveness guarantee.

## Likelihood Explanation

**Feasible Attack Scenario:**

**Precondition Setup:**
1. During chain initialization (genesis), a malicious or incompetent operator provides a miner list containing duplicates to `InitialElectionContract`
2. No validation prevents this, so `State.InitialMiners.Value` permanently stores duplicates
3. This persists silently in contract state

**Natural Trigger:**
1. Term transition time arrives (every ~7 days by default)
2. Valid election candidates are fewer than required miners count (common in early chain stages or low participation)
3. `GetVictories` executes fallback path that adds initial miners
4. Duplicates from initial miners propagate to victories list
5. `GenerateFirstRoundOfNewTerm` calls `ToDictionary` with duplicates
6. **Consensus halts**

**Likelihood: Medium to High**
- **Low attack complexity**: Only requires incorrect initialization data (no special runtime privileges needed)
- **Realistic precondition**: Configuration errors are common during genesis setup; accidental duplicates possible
- **Natural trigger**: Low candidate participation is plausible, especially on new chains or during low activity periods
- **Difficult detection**: Issue remains dormant until the specific trigger conditions align
- **No economic cost**: If duplicates injected at genesis, attacker needs no ongoing access

## Recommendation

**Fix 1: Add deduplication in `GenerateFirstRoundOfNewTerm`**
```csharp
var sortedMiners =
    (from obj in Pubkeys.Distinct()  // Add .Distinct() here
            .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
        orderby obj.Value descending
        select obj.Key).ToList();
```

**Fix 2: Validate duplicates during initialization**
```csharp
public override Empty InitialElectionContract(InitialElectionContractInput input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    
    // Add duplicate validation
    var distinctMiners = input.MinerList.Distinct().ToList();
    Assert(distinctMiners.Count == input.MinerList.Count, "Duplicate miners detected in initialization.");
    
    State.MinersCount.Value = distinctMiners.Count;
    State.InitialMiners.Value = new PubkeyList
    {
        Value = { distinctMiners.Select(m => ByteStringHelper.FromHexString(m)) }
    };
    // ... rest of initialization
}
```

**Fix 3: Deduplicate in GetVictories fallback**
```csharp
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value
            .Select(k => k.ToHex())
            .Distinct()  // Add .Distinct() here
            .Where(k => !backups.Contains(k)));
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateInitialMiners_CausesConsensusDoS_Test()
{
    // Setup: Initialize Election contract with duplicate miners
    var duplicateMinerList = new List<string>
    {
        InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex(),
        InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex(), // DUPLICATE
        InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex()
    };
    
    await ElectionContractStub.InitialElectionContract.SendAsync(new InitialElectionContractInput
    {
        MinerList = { duplicateMinerList },
        MinimumLockTime = 7 * 86400,
        MaximumLockTime = 1096 * 86400,
        TimeEachTerm = 604800
    });
    
    // Advance to term transition time with insufficient candidates
    var changeTermTime = BlockchainStartTimestamp.ToDateTime()
        .AddSeconds(604800 + 1); // Past term duration
    BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());
    
    // Attempt to generate next term - should throw ArgumentException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Behaviour = AElfConsensusBehaviour.NextTerm,
                Pubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey)
            }.ToBytesValue());
    });
    
    Assert.Contains("already been added", exception.Message);
    // Consensus is now stuck - cannot transition to next term
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L33-38)
```csharp
        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-84)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```
