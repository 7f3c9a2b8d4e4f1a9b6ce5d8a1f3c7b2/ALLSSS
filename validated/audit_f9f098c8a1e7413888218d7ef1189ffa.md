# Audit Report

## Title
Missing Validation in Secret Sharing Allows Consensus State Corruption via Arbitrary PreviousInValue Injection

## Summary
The AEDPoS consensus contract's `PerformSecretSharing` method accepts arbitrary `PreviousInValue` entries for any miner without cryptographic validation. A malicious miner can inject fake values that become used in signature calculations during round transitions, compromising consensus integrity by affecting extra block producer selection and contaminating the signature randomness pool.

## Finding Description

**Root Cause - Unvalidated State Injection:**

The `PerformSecretSharing` method unconditionally stores `PreviousInValue` for any miner specified in the caller's `MinersPreviousInValues` dictionary without any validation. [1](#0-0) 

**Validation Gap:**

The `UpdateValueValidationProvider` only validates the sender's own `PreviousInValue` by checking that `HashHelper.ComputeFrom(previousInValue) == previousOutValue` using `validationContext.SenderPubkey`. [2](#0-1) 

This leaves entries in `MinersPreviousInValues` for other miners completely unvalidated.

**Exploitation Mechanism:**

When `NextRound` is called, `SupplyCurrentRoundInformation` fills missing data for miners who didn't produce blocks. It reads the potentially corrupted `PreviousInValue` from state and uses it to calculate a signature. [3](#0-2) 

The signature calculation at line 199 uses `previousRound.CalculateSignature(previousInValue)`, which XORs the (potentially fake) previousInValue with all existing signatures in the round. [4](#0-3) 

**Impact Paths:**

1. **Extra Block Producer Manipulation**: The corrupted signature affects `CalculateNextExtraBlockProducerOrder`, which selects the extra block producer based on the first miner's signature using `GetAbsModulus(sigNum, blockProducerCount) + 1`. [5](#0-4) 

2. **Signature Pool Contamination**: The fake signature contaminates all future signature calculations that use `CalculateSignature`, as it XORs with all signatures in the round, affecting consensus randomness.

**Attack Sequence:**
1. Round N: Victim miner produces block with legitimate OutValue
2. Round N+1: Attacker (active miner) calls UpdateValue with malicious `MinersPreviousInValues[victim] = fake_hash`
3. `PerformSecretSharing` stores the fake value without validation
4. Round N+2 transition: Victim doesn't mine (due to downtime/network issues)
5. `NextRound` triggers `SupplyCurrentRoundInformation` which calculates victim's signature using the fake PreviousInValue
6. If victim has early mining order, their corrupted signature determines the extra block producer
7. The corrupted signature contaminates the signature pool via XOR operations in `CalculateSignature`

## Impact Explanation

**Consensus Integrity Compromise:**
- Attacker can manipulate extra block producer selection by controlling the signature calculation for offline miners
- The XOR-based signature aggregation means a single corrupted signature contaminates the entire round's randomness
- Affects the fairness of consensus by allowing attackers to bias which miners get extra block production opportunities
- Cannot be detected or corrected once injected into state

**Severity: Medium**
- Requires attacker to be an active miner (moderate barrier to entry)
- Requires victim to miss blocks (realistic during maintenance/network issues)
- No direct fund loss, but undermines consensus fairness guarantees
- Persistent corruption across rounds until victim produces another block
- Limited scope compared to full consensus takeover

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an elected consensus miner
- Needs victim miner to miss their time slot in a subsequent round
- Secret sharing must be enabled via configuration

**Feasibility: Medium-High**
- **Technical Complexity: Low** - Simple transaction construction with modified MinersPreviousInValues field
- **Detection Difficulty: High** - No on-chain validation signals the manipulation; appears as legitimate secret sharing data
- **Occurrence Probability: Medium** - Missed blocks occur regularly during network congestion, maintenance windows, or infrastructure issues

The attack becomes more likely when:
- Network conditions cause intermittent miner connectivity
- Targeting miners with known reliability issues
- During periods of high transaction volume causing block production delays

## Recommendation

Add cryptographic validation of `MinersPreviousInValues` entries in `PerformSecretSharing`:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    // Validate each PreviousInValue entry before storing
    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        var targetMiner = previousInValue.Key;
        var claimedPreviousInValue = previousInValue.Value;
        
        // Verify against the miner's OutValue from previous round
        if (round.RealTimeMinersInformation.ContainsKey(targetMiner))
        {
            var previousRound = TryToGetPreviousRoundInformation(out var prevRound) ? prevRound : null;
            if (previousRound != null && 
                previousRound.RealTimeMinersInformation.ContainsKey(targetMiner))
            {
                var expectedOutValue = previousRound.RealTimeMinersInformation[targetMiner].OutValue;
                if (expectedOutValue != null && 
                    HashHelper.ComputeFrom(claimedPreviousInValue) != expectedOutValue)
                {
                    // Invalid PreviousInValue - skip it
                    continue;
                }
            }
        }
        
        round.RealTimeMinersInformation[targetMiner].PreviousInValue = claimedPreviousInValue;
    }
}
```

Alternatively, extend `UpdateValueValidationProvider` to validate all entries in `MinersPreviousInValues` dictionary, not just the sender's own value.

## Proof of Concept

```csharp
// Test: Malicious miner injects fake PreviousInValue for victim
[Fact]
public async Task MaliciousMiner_CanCorruptVictimSignature_ViaFakePreviousInValue()
{
    // Setup: Initialize consensus with 3 miners
    var miners = new[] { "attacker", "victim", "honest" };
    await InitializeConsensusWithMiners(miners);
    
    // Round N: Victim produces block normally
    var victimOutValue = HashHelper.ComputeFrom("victim_secret");
    await VictimProducesBlock(victimOutValue);
    
    // Round N+1: Attacker injects fake PreviousInValue for victim
    var fakeVictimPreviousInValue = HashHelper.ComputeFrom("fake_secret");
    var attackerInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("attacker_secret"),
        // Attacker's own PreviousInValue is valid
        PreviousInValue = GetValidPreviousInValue("attacker"),
        // But attacker injects fake value for victim
        MinersPreviousInValues = 
        {
            ["victim"] = fakeVictimPreviousInValue
        }
    };
    await AttackerCallsUpdateValue(attackerInput);
    
    // Verify: Fake value was stored without validation
    var currentRound = await GetCurrentRound();
    Assert.Equal(fakeVictimPreviousInValue, 
        currentRound.RealTimeMinersInformation["victim"].PreviousInValue);
    
    // Round N+2: Victim goes offline, NextRound is called
    await HonestMinerCallsNextRound();
    
    // Verify: Victim's signature was calculated using the fake PreviousInValue
    var previousRound = await GetPreviousRound();
    var victimSignature = previousRound.RealTimeMinersInformation["victim"].Signature;
    
    // The signature should be based on fake value, not the real one
    var expectedFakeSignature = previousRound.CalculateSignature(fakeVictimPreviousInValue);
    Assert.Equal(expectedFakeSignature, victimSignature);
    
    // Impact: Extra block producer selection is now corrupted
    var extraBlockProducerOrder = CalculateExtraBlockProducerOrder(previousRound);
    // This order is now based on corrupted signature, not legitimate consensus randomness
}
```

## Notes

The vulnerability exists in the trust model for secret sharing: the contract assumes miners only share their own legitimate previous in values or cryptographically revealed values for others. However, the `MinersPreviousInValues` dictionary allows arbitrary injection without any cryptographic proof that these values are correct.

The impact is more nuanced than "direct mining order manipulation" - it specifically affects:
1. Extra block producer selection when victim has early mining order
2. Signature randomness pool contamination via XOR operations
3. Consensus fairness over multiple rounds

The vulnerability requires secret sharing to be enabled (checked at line 254 via `IsSecretSharingEnabled()`), making it configuration-dependent but still a serious consensus integrity issue when active.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
