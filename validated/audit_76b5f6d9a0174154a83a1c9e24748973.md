# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Allows Arbitrary Public Key Hijacking

## Summary
The `AnnounceElectionFor` function lacks authorization checks, allowing any caller to announce election for arbitrary public keys and assign themselves as admin. This enables attackers to gain permanent administrative control over candidates they don't own, manipulate elections, and prevent legitimate owners from ever registering their public keys as candidates.

## Finding Description

The vulnerability exists in the `AnnounceElectionFor` function which accepts an arbitrary `pubkey` string and `admin` address parameter without verifying that the caller has permission to announce election for that public key. [1](#0-0) 

The function directly assigns the provided `admin` parameter (defaulting to `Context.Sender` when null) as the candidate admin without any consent mechanism from the public key owner. [2](#0-1) 

The internal validation in the private `AnnounceElection(byte[] pubkeyBytes)` method only checks pubkey eligibility status - not an initial miner, not already announced, and not banned - but never validates that the caller has authorization to announce for this public key. [3](#0-2) 

**Contrast with Secure Implementation:**

The alternative `AnnounceElection(Address input)` method uses cryptographic signature verification via `Context.RecoverPublicKey()` to ensure only the private key owner can announce their candidacy. [4](#0-3) 

This secure pattern of signature-based ownership verification is completely absent from `AnnounceElectionFor`, creating the authorization bypass.

## Impact Explanation

**1. Unauthorized Administrative Control**

An attacker gains full admin privileges over candidates they don't own. The admin role controls critical operations:

- **Quit Election**: Only the admin can quit election for a candidate. [5](#0-4) 

- **Replace Public Key**: Only the admin can replace a candidate's public key. [6](#0-5) 

- **Set Profit Receivers**: The Treasury contract verifies that only the candidate's admin can set profit receivers. [7](#0-6) 

**2. Permanent Registration DoS**

Once a pubkey is announced as a candidate, the legitimate owner cannot register it because the check prevents re-announcement while `IsCurrentCandidate` is true. [8](#0-7) 

Even after the attacker quits (setting `IsCurrentCandidate` to false), they can immediately re-announce before the legitimate owner, creating a persistent griefing attack.

**3. Election Manipulation**

Attackers can strategically quit elections to manipulate the miner selection process during term changes. Voters may vote for hijacked candidates believing they're legitimate, locking tokens for candidates controlled by attackers. The data center ranking system can be manipulated by controlling when candidates participate.

**4. Reputation and Trust Damage**

Attackers can register well-known public keys (from other blockchains, public figures, etc.) as candidates under their control, creating confusion and damaging the election system's integrity.

## Likelihood Explanation

**Attacker Capabilities Required:**
- 100,000 ELF for the candidate lock [9](#0-8) 
- Ability to call a public contract method
- Knowledge of target public key hex strings

**Attack Complexity:** TRIVIAL
- Single transaction call with two parameters: arbitrary pubkey and attacker's address as admin
- No special timing, race conditions, or complex state setup required

**Economic Cost:** MINIMAL

The attacker locks 100,000 ELF but retrieves it when quitting. The sponsor (attacker) is recorded in `CandidateSponsorMap` and receives the refund when the admin quits. [10](#0-9) [11](#0-10) 

The attacker's net cost is zero plus transaction fees.

**Detection Difficulty:** HIGH

The hijacked registration appears legitimate on-chain. Users cannot easily distinguish between legitimate candidate registrations and malicious hijackings without off-chain verification of ownership.

**Probability:** HIGH - The vulnerability is easily discoverable, trivial to exploit, and economically rational for attackers seeking to manipulate elections or grief legitimate candidates.

## Recommendation

Implement authorization verification in `AnnounceElectionFor` to ensure only the public key owner can set themselves as admin. The recommended fix is to require cryptographic proof of ownership, similar to the `AnnounceElection` method:

1. Add signature verification to ensure the admin address corresponds to the public key owner
2. Alternatively, remove the ability to specify an arbitrary admin in `AnnounceElectionFor` and always set it to the address derived from the public key
3. If third-party sponsorship is needed, implement a two-step process where the public key owner must approve the admin assignment

Example fix:
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    var candidateAddress = Address.FromPublicKey(pubkeyBytes);
    
    // FIX: Always set admin to the public key owner, not arbitrary caller
    var admin = candidateAddress;
    
    AnnounceElection(pubkeyBytes);
    State.CandidateAdmins[pubkey] = admin;
    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Unauthorized_Admin_Takeover()
{
    // Victim's keypair (attacker doesn't have private key)
    var victimKeyPair = ValidationDataCenterKeyPairs.First();
    var victimPubkey = victimKeyPair.PublicKey.ToHex();
    
    // Attacker's keypair
    var attackerKeyPair = ValidationDataCenterKeyPairs.Last();
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    
    // Attacker announces election for victim's pubkey with attacker as admin
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Admin = attackerAddress, // Attacker sets themselves as admin
        Pubkey = victimPubkey    // For victim's public key
    });
    
    // Verify attacker is now the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimPubkey });
    admin.ShouldBe(attackerAddress);
    
    // Verify victim cannot quit (only admin can)
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.QuitElection.SendWithExceptionAsync(
        new StringValue { Value = victimPubkey });
    result.TransactionResult.Error.ShouldContain("Only admin can quit election");
    
    // Attacker can quit and get refund
    await attackerStub.QuitElection.SendAsync(new StringValue { Value = victimPubkey });
    
    // Attacker can immediately re-announce before victim
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Admin = attackerAddress,
        Pubkey = victimPubkey
    });
    
    // Verify permanent admin control
    admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimPubkey });
    admin.ShouldBe(attackerAddress);
}
```

## Notes

This vulnerability breaks the fundamental security invariant that only a public key's owner should control operations associated with that key. The existing test in `SponsorTests.cs` demonstrates the intended use case where a sponsor pays the deposit but the admin is correctly set to the candidate's own address. However, the implementation fails to enforce this constraint, allowing arbitrary admin assignment.

The contrast with `AnnounceElection(Address input)` which uses `Context.RecoverPublicKey()` for cryptographic verification clearly indicates this is an unintended authorization bypass rather than a designed feature.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-96)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```
