# Audit Report

## Title
Insufficient Validation of OutValue in NextRound Allows Denial of Service Against Miners

## Summary
The `ValidationForNextRound()` method only validates that `InValue` is null for all miners in the next round, but fails to validate that `OutValue` is also null. This allows a malicious miner to inject arbitrary non-null `OutValue` data when creating NextRound transactions, causing victim miners to be incorrectly treated as having already mined, preventing them from producing UPDATE_VALUE blocks and incrementing their missed time slot counters until they are removed from consensus.

## Finding Description

The AEDPoS consensus contract validates round transitions through the `RoundTerminateValidationProvider`. However, the `ValidationForNextRound()` method contains an incomplete validation check that only verifies `InValue` is null but does NOT validate `OutValue`: [1](#0-0) 

When a legitimate next round is generated, both `InValue` and `OutValue` should be null. The `GenerateNextRoundInformation` method creates new `MinerInRound` objects with only basic fields set (Pubkey, Order, ExpectedMiningTime, ProducedBlocks, MissedTimeSlots), leaving InValue and OutValue as null: [2](#0-1) [3](#0-2) 

When a miner creates NextRound data, they provide a `NextRoundInput` which is directly converted to a `Round` object via the `ToRound()` method, giving the attacker full control over all miner fields including `OutValue`: [4](#0-3) 

The malicious round data is stored directly in ProcessNextRound without additional OutValue validation: [5](#0-4) 

The attack succeeds because consensus behavior determination relies on `OutValue` being null to identify miners who haven't mined yet. If `OutValue` is null, the miner enters `HandleMinerInNewRound()` which can return UPDATE_VALUE behavior: [6](#0-5) 

However, if `OutValue` is non-null due to malicious injection, the miner skips UPDATE_VALUE logic and receives TinyBlock or termination behavior instead: [7](#0-6) 

Miners producing TinyBlock do not set their `SupposedOrderOfNextRound` field: [8](#0-7) 

In contrast, UPDATE_VALUE blocks do set this field: [9](#0-8) 

When generating the next round, `GetNotMinedMiners()` returns miners with `SupposedOrderOfNextRound == 0`: [10](#0-9) 

These "not mined" miners have their `MissedTimeSlots` counter incremented: [11](#0-10) 

## Impact Explanation

**Consensus Integrity Impact:**
- Victim miners are prevented from producing UPDATE_VALUE blocks, which are essential for consensus participation
- Each victim's `MissedTimeSlots` counter increments every round they are affected
- After reaching the threshold, victims are detected as evil miners: [12](#0-11) 

The threshold is set to 4,320 missed time slots (approximately 3 days at one slot per minute): [13](#0-12) 

Detected evil miners are marked and banned from consensus: [14](#0-13) 

**Operational Impact:**
- Reduces effective number of active miners, weakening consensus security
- Victims lose mining rewards for missed blocks  
- Chain liveness may be affected if multiple miners are targeted
- Honest miners suffer reputational damage through false evil node marking

The severity is **MEDIUM-HIGH** because while it doesn't directly steal funds, it severely disrupts consensus operations and can result in honest miners being removed from the validator set.

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a current consensus miner, verified in PreCheck: [15](#0-14) 

- Attacker must be selected to produce the extra block that triggers round transition (occurs naturally in rotation based on pseudo-random selection)
- Attacker modifies their node software to inject malicious `OutValue` data

**Attack Complexity:**
- **LOW**: Simply set non-null `OutValue` values for target miners when creating NextRound data
- No complex timing requirements or race conditions  
- Single transaction executes the attack

**Feasibility:**
- Entry point is the public `NextRound` method accessible to all miners: [16](#0-15) 

- Miners rotate through extra block producer role regularly
- No economic cost beyond normal mining operations
- Attack can be repeated whenever attacker is selected for extra block production

**Detection:**
- Malicious `OutValue` data visible in block data but might not trigger alarms initially
- Effects could be attributed to network issues
- Requires blockchain analysis to identify root cause

**Probability:** **MEDIUM-HIGH** - While requiring a malicious miner, the attack is simple to execute, has no additional cost, and would be difficult to detect initially. An attacker can repeat this attack across multiple rounds to accumulate enough missed time slots for victim removal.

## Recommendation

Add validation for `OutValue` in the `ValidationForNextRound()` method to ensure it is null for all miners in a legitimate next round, matching the validation already performed for `InValue`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Validate both InValue and OutValue are null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information - InValue should be null." };
    
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.OutValue != null))
        return new ValidationResult { Message = "Incorrect next round information - OutValue should be null." };

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

A malicious miner would execute the following:

1. Wait to be selected as the extra block producer for a round
2. Generate legitimate NextRoundInput data via standard round generation
3. Before submitting, modify the `NextRoundInput.RealTimeMinersInformation` dictionary to set non-null `OutValue` (e.g., Hash.FromString("malicious")) for target victim miners
4. Submit the modified NextRound transaction
5. Transaction passes validation (only InValue checked)
6. Victim miners in subsequent rounds receive TinyBlock behavior instead of UPDATE_VALUE
7. Victims don't set SupposedOrderOfNextRound, causing MissedTimeSlots to increment
8. Repeat attack when selected as extra block producer again
9. After 4,320 accumulated missed time slots, victims are marked as evil and removed from consensus

The vulnerability can be demonstrated by examining the validation logic flow and confirming that OutValue is never validated during NextRound processing, while legitimate round generation always produces null OutValue fields.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L131-135)
```csharp
    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-83)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
