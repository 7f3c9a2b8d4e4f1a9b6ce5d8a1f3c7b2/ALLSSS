# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Malicious Miner to Monopolize Block Production

## Summary
The AEDPoS consensus contract's `NextTerm` function accepts arbitrary miner lists without validating them against the Election Contract's elected miners. A malicious current miner can submit a term transition containing only their own public key, establishing themselves as the sole block producer for the entire term, bypassing continuous block production limits and enabling complete transaction censorship.

## Finding Description

The vulnerability exists in the term transition validation and processing flow where miner list legitimacy is never verified.

**Entry Point**: The `NextTerm` method is a public RPC endpoint that accepts `NextTermInput` from any caller. [1](#0-0) 

**Insufficient Authorization**: The `PreCheck` method only verifies the sender is in the current or previous miner list, not whether the proposed miner list is legitimate. [2](#0-1) 

**Validation Gap**: The `ValidationForNextTerm` method only validates that round and term numbers increment by 1 and that InValues are null. It performs NO validation that the provided miner list matches elected miners from the Election Contract. [3](#0-2) 

**Unvalidated Processing**: The `ProcessNextTerm` method extracts the miner list directly from the input's `nextRound.RealTimeMinersInformation.Keys` without any cross-contract validation against `GetVictories()` from the Election contract. [4](#0-3) 

**SetMinerList Accepts Without Validation**: The `SetMinerList` method only checks if a miner list was already set for the term number but performs zero validation of the miner list's legitimacy or content. [5](#0-4) 

**Continuous Blocks Bypass**: The continuous blocks validation is completely bypassed when `RealTimeMinersInformation.Count == 1`. Once the attacker becomes the sole miner, they can produce unlimited consecutive blocks without restriction. [6](#0-5) 

**Intended vs Actual Flow**: The honest implementation in `GetConsensusExtraDataForNextTerm` calls `GenerateFirstRoundOfNextTerm` which retrieves elected miners via `TryToGetVictories()` from the Election contract. [7](#0-6) [8](#0-7) 

However, the contract does not enforce this - test code demonstrates the intended usage where `GetVictories()` is explicitly called before constructing `NextTermInput`, but this is not validated on-chain. [9](#0-8) 

**Attack Execution**: A malicious current miner crafts a `NextTermInput` with:
1. Correct term number (current + 1) and round number (current + 1) to pass structural validation
2. `RealTimeMinersInformation` containing ONLY their own public key
3. Null `InValues` to satisfy validation requirements

The attacker calls `NextTerm` with this malicious input. Since they are a current miner, `PreCheck` passes. The structural validation in `ValidationForNextTerm` passes. The fraudulent miner list is extracted and stored without legitimacy verification, establishing the attacker as the sole block producer.

## Impact Explanation

**Consensus Integrity Violation**: The attacker achieves complete monopoly over block production for an entire term (typically 7 days), fundamentally breaking the distributed consensus security model which requires multiple independent validators.

**Transaction Censorship**: As the sole miner, the attacker can permanently censor any transactions including:
- Governance proposals to fix the issue
- Election votes to change the miner set  
- Any user transactions
This enables complete network-level censorship capability.

**Economic Theft**: The attacker captures 100% of mining rewards for the entire term. The `DonateMiningReward` function calculates rewards based on blocks mined in the previous round, which are entirely produced by the attacker. [10](#0-9) 

All legitimately elected miners receive nothing, constituting direct theft of protocol rewards from honest validators.

**Exclusion of Legitimate Miners**: All miners who were honestly elected through the voting process are completely removed from consensus participation despite having legitimate election mandate.

**Self-Perpetuating Attack**: The attacker controls the next term transition and can repeatedly submit fraudulent `NextTerm` transactions to maintain their monopoly indefinitely across multiple terms.

## Likelihood Explanation

**Realistic Preconditions**: The attacker must be one of the current miners, which is a realistic assumption for any compromised validator or initially honest validator who becomes malicious. No special privileges beyond normal miner status are required.

**Direct Entry Point**: The `NextTerm` method is publicly callable with no authorization checks beyond being a current or previous miner, verified via `PreCheck`.

**Zero Detection**: The validation pipeline contains no checks to detect this attack. The `MiningPermissionValidationProvider` only validates the sender is in the CURRENT round's miner list, not that the NEXT round's miner list is legitimate. [11](#0-10) 

Honest nodes will accept the malicious block as valid since it passes all implemented validation checks.

**Low Complexity**: The attack requires only:
1. Waiting for term transition timing
2. Crafting `NextTermInput` with correct term/round numbers and only attacker's pubkey  
3. Submitting the transaction during the attacker's time slot

**Economic Rationality**: Attack cost is minimal (one transaction fee) while the benefit is capturing 100% of mining rewards and complete network control for a full term, making this economically rational for any profit-motivated attacker.

## Recommendation

Add cross-contract validation in `ProcessNextTerm` to verify the miner list matches elected miners from the Election Contract:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL FIX: Validate miner list against Election Contract
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = victoriesPublicKeys.Value.Select(pk => pk.ToHex()).OrderBy(x => x).ToList();
        var providedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(x => x).ToList();
        
        Assert(
            expectedMiners.Count == providedMiners.Count && 
            expectedMiners.SequenceEqual(providedMiners),
            "Provided miner list does not match elected miners from Election Contract.");
    }
    
    // ... rest of existing logic
}
```

Additionally, strengthen `ValidationForNextTerm` to include this check before state modification occurs.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanMonopolizeNextTerm()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = new[] { InitialCoreDataCenterKeyPairs[0], InitialCoreDataCenterKeyPairs[1], InitialCoreDataCenterKeyPairs[2] };
    await InitializeConsensus(initialMiners);
    
    // Get current round information
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var attacker = InitialCoreDataCenterKeyPairs[0];
    var attackerPubkey = attacker.PublicKey.ToHex();
    
    // Attacker crafts malicious NextTermInput with ONLY their pubkey
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        RealTimeMinersInformation = 
        {
            [attackerPubkey] = new MinerInRound 
            { 
                Pubkey = attackerPubkey,
                Order = 1,
                ExpectedMiningTime = TimestampHelper.GetUtcNow()
            }
        },
        RandomNumber = ByteString.CopyFrom(HashHelper.ComputeFrom("random").ToByteArray())
    };
    
    // Attacker submits malicious NextTerm
    var attackerStub = GetConsensusContractTester(attacker);
    var result = await attackerStub.NextTerm.SendAsync(maliciousNextTermInput);
    
    // Verify attack succeeded
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.TermNumber.ShouldBe(currentRound.TermNumber + 1);
    newRound.RealTimeMinersInformation.Count.ShouldBe(1); // Only attacker
    newRound.RealTimeMinersInformation.Keys.ShouldContain(attackerPubkey);
    
    // Verify legitimate miners were excluded
    var legitimateMiner = InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex();
    newRound.RealTimeMinersInformation.Keys.ShouldNotContain(legitimateMiner);
    
    // Attacker now has monopoly over block production
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-191)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** test/AElf.Contracts.Economic.TestBase/OtherContractsOperation.cs (L17-36)
```csharp
    protected async Task NextTerm(ECKeyPair keyPair)
    {
        var miner = GetConsensusContractTester(keyPair);
        var round = await miner.GetCurrentRoundInformation.CallAsync(new Empty());
        var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
        var miners = new MinerList
        {
            Pubkeys =
            {
                victories.Value
            }
        };
        var randomNumber = await GenerateRandomProofAsync(keyPair);
        var firstRoundOfNextTerm =
            miners.GenerateFirstRoundOfNewTerm(EconomicContractsTestConstants.MiningInterval,
                randomNumber, BlockTimeProvider.GetBlockTime(), round.RoundNumber, round.TermNumber);
        var executionResult = (await miner.NextTerm.SendAsync(firstRoundOfNextTerm)).TransactionResult;
        executionResult.Error.ShouldBeNullOrEmpty();
        executionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
