# Audit Report

## Title
Signature Non-Repudiation Vulnerability: Unvalidated Signature Mismatch Between Block Header and Transaction State

## Summary
The AEDPoS consensus system fails to validate that the signature in the block header matches the signature stored in the transaction state during `UpdateValue` operations. A malicious miner can provide a valid signature for block validation but store a different signature (including `Hash.Empty`) in the consensus state, breaking signature non-repudiation and corrupting the signature chain used for randomness generation and mining order calculations.

## Finding Description

The vulnerability exists in the dual-path signature handling during the `UpdateValue` consensus operation:

**Path 1: Block Header Signature**

The `GetUpdateValueRound()` function creates a simplified Round object for the block header, copying the signature from the current round's miner information. [1](#0-0)  This signature is validated before execution through `ValidateBeforeExecution()` which uses the `UpdateValueValidationProvider`. [2](#0-1) 

**Path 2: Transaction Signature**

The `ExtractInformationToUpdateConsensus()` function creates an `UpdateValueInput` containing a signature field extracted from the miner's round information. [3](#0-2)  During transaction execution, this signature from the transaction input is stored directly to state without cross-validation against the header signature. [4](#0-3) 

**Missing Validation**

The `UpdateValueValidationProvider` only checks that the header signature exists and is non-empty, but does not compare it with the transaction signature. [5](#0-4) 

The `ValidateConsensusAfterExecution()` method attempts validation through hash comparison, but is ineffective because `RecoverFromUpdateValue()` modifies the current round in-place by overwriting the state signature with the header signature before the comparison occurs. [6](#0-5)  The recovery operation [7](#0-6)  makes the subsequent hash comparison meaningless as both sides reference data with the overwritten signature, while the persisted state retains the transaction signature.

## Impact Explanation

**Consensus Integrity Corruption:**

The signature is critical for consensus operations. The `CalculateSignature()` method aggregates all miner signatures through XOR operations to compute future signatures. [8](#0-7)  A corrupted signature in the state breaks this cryptographic chain, affecting all subsequent rounds.

Mining order for the next round is calculated directly from the signature value through modulo operations. [9](#0-8)  A manipulated signature affects the fairness of miner selection and round ordering.

**Specific Harms:**
1. **Non-Repudiation Failure**: A miner can provide a valid signature for validation but store `Hash.Empty` in state, denying participation while appearing compliant to the validation system
2. **Randomness Corruption**: Future random number generation depends on signature chain integrity through `GetLatestSignature` which reads from the persisted state [10](#0-9) 
3. **Fairness Violation**: Mining order calculations use corrupted signatures, affecting the deterministic miner selection process
4. **Consensus Instability**: Signature chain breaks propagate through all subsequent rounds when `CalculateSignature()` is called during block generation [11](#0-10) 

**Severity: MEDIUM** - Requires a malicious miner (privileged but not trusted role per the threat model) but breaks critical consensus invariants with network-wide impact.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner (privileged but distributed role, not in the trusted role list per threat model)
- Must modify node implementation to generate mismatched signatures between header and transaction
- Node modification is technically feasible for sophisticated actors with access to their own mining infrastructure

**Attack Complexity:**
- LOW - Once node is modified, exploitation is straightforward
- Both block header and transaction are generated through the consensus contract's methods, allowing a malicious implementation to inject different signatures [12](#0-11) 
- Attacker can modify their node to use different signatures for header versus transaction generation

**Feasibility Conditions:**
- Attacker controls a miner node and its software
- No contract-level validation prevents the attack - validation only examines the header signature
- Block validation passes with the header signature
- State stores the transaction signature without cross-checking against the header

**Detection Difficulty:**
- Difficult to detect without explicit comparison of historical block header data versus stored consensus state signatures
- Attack may only become apparent when signature chain is used for critical operations like mining order calculation or randomness generation in future rounds

**Probability: MEDIUM-HIGH** - Technical barrier exists (node modification and maintaining miner status) but no protocol-level prevention mechanism exists once these barriers are overcome.

## Recommendation

Add explicit validation to compare the block header signature with the transaction input signature before state modification. The validation should occur in either:

1. **ValidateBeforeExecution**: After recovering the base round with header data, validate that the signature in the header matches what would be extracted from the transaction.

2. **ProcessUpdateValue**: Before storing the signature to state, validate it matches the header signature by comparing against the validated header data.

Recommended fix in `ProcessUpdateValue()`:
```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // NEW: Validate signature matches header
    var headerRound = State.RoundBeforeLatestExecution.Value;
    if (headerRound?.RealTimeMinersInformation.ContainsKey(_processingBlockMinerPubkey) == true)
    {
        var headerSignature = headerRound.RealTimeMinersInformation[_processingBlockMinerPubkey].Signature;
        Assert(updateValueInput.Signature == headerSignature, 
            "Transaction signature must match validated header signature.");
    }
    
    // Continue with existing logic...
    minerInRound.Signature = updateValueInput.Signature;
    // ... rest of method
}
```

## Proof of Concept

A complete proof of concept would require:
1. Setting up a test miner node
2. Modifying the consensus contract call to inject different signatures
3. Observing that validation passes while state contains the wrong signature
4. Verifying the signature chain corruption in subsequent rounds

The vulnerability can be confirmed by examining the code paths:
- Header validation only checks signature is non-empty
- After-execution validation overwrites state signature before comparison
- No direct comparison between header and transaction signatures exists in the codebase [13](#0-12)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-24)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-80)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-50)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L95-106)
```csharp
    private Hash GetLatestSignature(Round currentRound)
    {
        var latestSignature = currentRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .LastOrDefault(m => m.Signature != null)?.Signature;
        if (latestSignature != null) return latestSignature;
        if (TryToGetPreviousRoundInformation(out var previousRound))
            latestSignature = previousRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
                .LastOrDefault(m => m.Signature != null)
                ?.Signature;

        return latestSignature;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-244)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-74)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }

    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-101)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L88-108)
```csharp
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```
