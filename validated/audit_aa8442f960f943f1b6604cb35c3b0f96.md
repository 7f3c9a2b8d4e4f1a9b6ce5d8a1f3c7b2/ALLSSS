# Audit Report

## Title
Missing Validation of Zero/Negative Vote Amount in Delegated Voting Allows Vote Manipulation

## Summary
The `Vote()` function in the VoteContract fails to validate the `amount` field for delegated voting items (when `IsLockToken == false`). This allows sponsors to submit votes with zero or negative amounts, corrupting vote totals and inflating voter counts, which violates protocol invariants and undermines voting integrity.

## Finding Description
In delegated voting mode, the `Vote()` method accepts and processes votes without validating that the amount is positive:

1. The `Vote()` method directly assigns `input.Amount` to the local `amount` variable for non-quadratic voting [1](#0-0) 

2. The validation function `AssertValidVoteInput()` only checks that the sender is the sponsor, the voter is not null, and the voteId is not null for delegated voting—it performs no validation on the amount field [2](#0-1) 

3. The unvalidated amount is used to update voting results, adding the amount to the option's vote total, incrementing the voter count, and adding the amount to the total votes [3](#0-2) 

4. For delegated voting, the `Lock()` method is never called (the token lock only occurs when `IsLockToken` is true) [4](#0-3) 

5. In contrast, for token-locked voting, the `Lock()` method provides validation through `AssertValidToken()` [5](#0-4)  which calls `AssertValidSymbolAndAmount()` requiring `amount > 0` [6](#0-5) 

The protobuf definition specifies the amount as `int64`, which is a signed integer that can be negative [7](#0-6) 

This vulnerability allows sponsors to manipulate vote data: zero-amount votes inflate voter counts without adding votes, while negative-amount votes can subtract from vote totals, violating the fundamental protocol invariant that vote amounts should be positive.

## Impact Explanation
The missing validation enables two distinct attack vectors:

**Zero-amount votes:** A sponsor can submit votes with `amount = 0`, causing the voter count to increase without changing the vote total. This artificially inflates participation metrics, potentially affecting quorum calculations or decision-making based on voter turnout.

**Negative-amount votes:** A sponsor can submit votes with `amount < 0`, which decreases the total votes for a given option while still incrementing the voter count. This allows direct manipulation of voting results by subtracting votes from options.

Both scenarios break protocol invariants—vote totals should never be negative, and voter counts should accurately reflect voting participation. Systems that consume voting data (such as the Election contract which uses delegated voting [8](#0-7) ) may malfunction or make incorrect decisions based on corrupted vote data.

While the sponsor already controls the voting item they created, the protocol should enforce basic data integrity to prevent invalid state and ensure systems consuming this data can rely on fundamental invariants.

## Likelihood Explanation
This vulnerability has **high likelihood** of occurrence:

1. **Easy to trigger:** Any address can create a voting item with `IsLockToken = false` and become its sponsor, then call `Vote()` with an invalid amount. No special privileges or complex setup is required.

2. **Supported feature:** Delegated voting is actively used in production, as evidenced by the Election contract's use of this mode.

3. **Deterministic behavior:** The issue is guaranteed to occur when a sponsor submits a vote with zero or negative amount—there is no randomness or race condition involved.

4. **No existing protections:** The validation gap is complete—no check exists in the delegated voting path to prevent this issue.

## Recommendation
Add amount validation for delegated voting in the `AssertValidVoteInput()` method or at the beginning of the `Vote()` method:

```csharp
// In Vote() method after AssertValidVoteInput or in AssertValidVoteInput for delegated voting:
if (!votingItem.IsLockToken)
{
    Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
    Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
    Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
    Assert(input.Amount > 0, "Amount must be positive for delegated voting."); // ADD THIS LINE
}
```

This ensures consistent validation across both token-locked and delegated voting modes, maintaining protocol invariants regardless of voting type.

## Proof of Concept
```csharp
[Fact]
public async Task Vote_With_Negative_Amount_In_Delegated_Voting_Should_Corrupt_Results()
{
    // Setup: Create a delegated voting item (IsLockToken = false)
    var sponsor = Accounts[0].Address;
    var votingItem = await CreateDelegatedVotingItem(sponsor);
    
    // Attack: Sponsor submits vote with negative amount
    var voteInput = new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Voter = Accounts[1].Address,
        VoteId = HashHelper.ComputeFrom("vote1"),
        Amount = -1000,  // Negative amount
        Option = "Option1"
    };
    
    // Execute vote as sponsor
    await VoteContractStub.Vote.SendAsync(voteInput);
    
    // Verify corruption: Voter count increased but votes decreased
    var result = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    
    result.VotersCount.ShouldBe(1);  // Voter count increased
    result.Results["Option1"].ShouldBe(-1000);  // Vote total is negative - INVALID STATE
    result.VotesAmount.ShouldBe(-1000);  // Total votes is negative - INVARIANT VIOLATED
}
```

## Notes
- This vulnerability only affects delegated voting mode (`IsLockToken == false`); token-locked voting is protected by the Lock() validation
- The sponsor role is obtainable by any address that creates a voting item
- While sponsors control their own voting items, the protocol should still enforce data integrity to maintain invariants for consuming systems
- The Election contract's use of delegated voting demonstrates this is not a theoretical concern but affects real protocol functionality

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-96)
```csharp
    public override Empty Vote(VoteInput input)
    {
        var votingItem = AssertValidVoteInput(input);
        var amount = 0L;
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-207)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** protobuf/vote_contract.proto (L135-148)
```text
message VoteInput {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The address of voter.
    aelf.Address voter = 2;
    // The amount of vote.
    int64 amount = 3;
    // The option to vote.
    string option = 4;
    // The vote id.
    aelf.Hash vote_id = 5;
    // Whether vote others.
    bool is_change_target = 6;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L55-68)
```csharp
    {
        Assert(!State.VotingEventRegistered.Value, "Already registered.");

        State.VoteContract.Value = Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);
```
