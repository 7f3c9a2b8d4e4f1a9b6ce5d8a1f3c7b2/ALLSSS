# Audit Report

## Title
Consensus Round Number Reset Vulnerability via Validation Bypass During Bootstrap Phase

## Summary
A malicious miner can exploit a bootstrap-phase validation bypass during the first 24 blocks to reset the consensus round number back to 1, causing critical consensus state corruption. The attack combines an early-return validation bypass with an unsafe round number update check that allows round number regression without proper validation.

## Finding Description

The vulnerability stems from two interconnected flaws in the AEDPoS consensus contract:

**Flaw 1: Bootstrap Validation Bypass**

The `ValidateBeforeExecution` method contains a bootstrap-phase bypass that returns early when only a single miner has been producing blocks across all rounds during the first 24 blocks (height < `MaximumTinyBlocksCount * 3` = 8 * 3 = 24). [1](#0-0) 

This early return occurs BEFORE the validation providers are added to the pipeline. Specifically, `RoundTerminateValidationProvider` is added at lines 84-87, but the bootstrap bypass returns at line 43, completely skipping this critical validation. [2](#0-1) 

**Flaw 2: Unsafe Round Number Update Logic**

The `TryToUpdateRoundNumber` method has a special case that allows setting round number to 1 without validating progression. [3](#0-2) 

When `roundNumber == 1`, the condition `roundNumber != 1` evaluates to false, causing the if-statement to short-circuit and skip the progression validation check `oldRoundNumber + 1 != roundNumber`. This allows unconditional updates to round 1 regardless of the current round number.

**Normal Protection That Gets Bypassed**

Under normal circumstances, `RoundTerminateValidationProvider` validates that round numbers increment by exactly 1. [4](#0-3) 

However, this provider is never invoked when the bootstrap bypass activates.

**Attack Execution Path:**

1. Network starts with multiple miners configured but only one miner actively producing blocks during blocks 1-23
2. System naturally progresses to round 2
3. Malicious miner sends `NextRound` transaction with `NextRoundInput{RoundNumber: 1}`
4. `ValidateBeforeExecution` enters bootstrap bypass and returns success without adding validators
5. `ProcessNextRound` executes and calls `TryToUpdateRoundNumber(1)` [5](#0-4) 
6. Update succeeds due to special case for round 1
7. `State.CurrentRoundNumber.Value` is reset to 1
8. `AddRoundInformation` overwrites the original round 1 data [6](#0-5) 

**Consequence: Wrong Strategy Selection**

After the attack, `GetConsensusCommand` incorrectly uses `FirstRoundCommandStrategy` instead of `NormalBlockCommandStrategy` because the condition `currentRound.RoundNumber == 1` evaluates to true. [7](#0-6) 

`FirstRoundCommandStrategy` uses simplified time calculations and critically omits `RoundId` and `PreviousRoundId` fields from the consensus hint. [8](#0-7) 

In contrast, `NormalBlockCommandStrategy` includes these essential round continuity fields. [9](#0-8) 

## Impact Explanation

**Critical Consensus State Corruption**

The vulnerability causes irreversible consensus state damage through multiple mechanisms:

1. **Round Number Regression**: The consensus round number resets from round 2+ back to 1, violating the monotonic progression invariant that the consensus protocol depends on for ordering and coordination.

2. **Historical Data Loss**: The original round 1 data in `State.Rounds[1]` is permanently overwritten, destroying immutable consensus history that nodes rely on for validation and synchronization.

3. **Mining Strategy Corruption**: Future blocks use `FirstRoundCommandStrategy` which calculates mining times using simplified formulas instead of the actual expected mining times stored in the round state, causing miners to produce blocks at incorrect times.

4. **Broken Round Continuity**: The consensus hints omit `RoundId` and `PreviousRoundId` fields required for proper round continuity validation, breaking the chain of round proofs that ensures consensus integrity.

5. **Irrecoverable Network Fork**: When additional miners come online after the bootstrap phase, they observe `CurrentRoundNumber == 1` while the blockchain height has advanced significantly. This conflicting state view causes permanent consensus disagreement that cannot be resolved without manual intervention and chain rollback.

The severity is **Critical** because it directly undermines the fundamental consensus mechanism, affects all network participants, has no automated recovery path, and requires network-wide coordination to resolve.

## Likelihood Explanation

**High Exploitability During Bootstrap Phase**

The vulnerability is highly exploitable during network initialization:

**Required Conditions:**
1. **Temporal Window**: Attack must occur within the first 24 blocks (8 * 3 as defined in constants) [10](#0-9) 
2. **Sole Active Miner**: Attacker must be the only miner producing blocks while multiple miners are configured
3. **Valid Miner Status**: Attacker must be in the legitimate miner list

**Realistic Attack Scenario:**

This is highly realistic during blockchain launch because:
- **Staged Deployment**: Not all miners start simultaneously due to coordination challenges and staged rollout procedures
- **Network Issues**: Temporary connectivity problems commonly prevent initial participation
- **Intentional Design**: The system explicitly accommodates single-miner bootstrap operation but fails to protect against malicious exploitation
- **No Economic Barrier**: The attacker is a legitimate miner earning normal block rewards with no cost to execute the attack

**Low Attack Complexity:**
- Requires crafting a single `NextRound` transaction with `RoundNumber: 1`
- No complex sequencing or precise timing requirements
- Attack succeeds on first attempt if conditions are met

**Difficult Detection:**
- The malicious transaction appears as a valid consensus operation during bootstrap
- No immediate errors or anomalies occur
- Corruption only becomes apparent when other miners join and experience consensus disagreement

The combination of high exploitability, realistic preconditions, and low detection probability during the critical bootstrap phase results in a **High** likelihood assessment.

## Recommendation

Implement strict round number progression validation even during the bootstrap phase. Add a check in `TryToUpdateRoundNumber` to prevent round number regression:

```csharp
private bool TryToUpdateRoundNumber(long roundNumber)
{
    var oldRoundNumber = State.CurrentRoundNumber.Value;
    // Prevent round number regression - must be first round or increment by 1
    if (oldRoundNumber > 0 && roundNumber <= oldRoundNumber) return false;
    if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
    State.CurrentRoundNumber.Value = roundNumber;
    return true;
}
```

Additionally, consider either:
1. Removing the bootstrap validation bypass entirely, OR
2. Ensuring critical validators like `RoundTerminateValidationProvider` are always added before the early return

## Proof of Concept

```csharp
[Fact]
public async Task RoundNumberResetAttack_BootstrapBypass_Test()
{
    // Initialize with multiple miners configured
    await InitializeCandidates(3);
    
    // Get initial round 1
    var round1 = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    round1.RoundNumber.ShouldBe(1);
    
    // Single miner (attacker) produces blocks and advances to round 2
    BlockTimeProvider.SetBlockTime(BlockchainStartTimestamp.AddSeconds(AEDPoSContractTestConstants.MiningInterval * 10));
    
    var round2Info = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
        new AElfConsensusTriggerInformation
        {
            Behaviour = AElfConsensusBehaviour.NextRound,
            Pubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey)
        }.ToBytesValue());
    
    var round2Input = NextRoundInput.Parser.ParseFrom(round2Info.ToConsensusHeaderInformation().Round.ToByteArray());
    round2Input.RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(BootMinerKeyPair));
    await AEDPoSContractStub.NextRound.SendAsync(round2Input);
    
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RoundNumber.ShouldBe(2);
    
    // ATTACK: Reset round number to 1 while still in bootstrap window (height < 24)
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 1, // Malicious round number
        RealTimeMinersInformation = { currentRound.RealTimeMinersInformation },
        RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(BootMinerKeyPair))
    };
    
    // Attack succeeds due to bootstrap bypass
    var attackResult = await AEDPoSContractStub.NextRound.SendAsync(maliciousInput);
    attackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify round number was reset to 1
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.RoundNumber.ShouldBe(1); // Critical: Round number regressed!
    
    // Verify original round 1 data was overwritten
    var round1Data = await AEDPoSContractStub.GetRoundInformation.CallAsync(new Int64Value { Value = 1 });
    round1Data.ShouldNotBe(round1); // Historical data lost
}
```

## Notes

The bootstrap constant value is 24 blocks (not 23 as initially stated), calculated as `MaximumTinyBlocksCount.Mul(3)` where `MaximumTinyBlocksCount = 8`. The vulnerability is particularly dangerous because it exploits a legitimate design feature (bootstrap accommodation) in an unintended malicious way. The fix must balance security with the practical need to support single-miner bootstrap scenarios.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L23-43)
```csharp
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L28-30)
```csharp
        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/FirstRoundCommandStrategy.cs (L31-47)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var miningInterval = MiningInterval;
            var offset =
                _consensusBehaviour == AElfConsensusBehaviour.UpdateValue && Order == 1
                    ? miningInterval
                    : Order.Add(MinersCount).Sub(1).Mul(miningInterval);
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeMiningTimeWithOffset(CurrentBlockTime, offset);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint { Behaviour = _consensusBehaviour }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(miningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L23-41)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeNormalBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);

            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
