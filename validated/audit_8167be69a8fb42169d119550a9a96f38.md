# Audit Report

## Title
State Corruption in TokenHolder Scheme Initialization - Writes to Wrong Address

## Summary
The `UpdateTokenHolderProfitScheme` helper method contains a critical bug where it writes scheme initialization data to `Context.Sender` (the transaction caller) instead of the `manager` parameter (the scheme owner's address). This causes permanent state corruption when users interact with newly created TokenHolder profit schemes, leaving the manager's scheme uninitialized and scattering scheme data across multiple addresses.

## Finding Description

The vulnerability exists in the private `UpdateTokenHolderProfitScheme` method at line 298. [1](#0-0) 

When a scheme is created via `CreateScheme`, it stores basic configuration (Symbol, MinimumLockMinutes, AutoDistributeThreshold) at the manager's address but leaves the `SchemeId` field as null. [2](#0-1) 

When any user subsequently calls operations like `ClaimProfits`, the contract invokes `GetValidScheme` which reads the scheme from the manager's address and calls `UpdateTokenHolderProfitScheme` to initialize the missing fields. [3](#0-2) 

The bug occurs at line 298 where the updated scheme (now containing the initialized `SchemeId` and `Period` fields fetched from the Profit contract) is written to `State.TokenHolderProfitSchemes[Context.Sender]` instead of `State.TokenHolderProfitSchemes[manager]`. This means the initialized data goes to the caller's address, not the scheme owner's address.

**Why Protections Fail**: Other methods in the same contract correctly write to the manager's address. For example, `DistributeProfits` writes to `input.SchemeManager` at line 145. [4](#0-3)  Similarly, `RegisterForProfits` correctly writes to `input.SchemeManager` at line 205. [5](#0-4) 

## Impact Explanation

**Severity: Medium** - The vulnerability causes operational denial of service and permanent state corruption but does not directly enable fund theft.

1. **View Function Failure**: The `GetProfitsMap` view function reads the scheme directly from the manager's address without validation. [6](#0-5)  When `SchemeId` remains null at the manager's address, it passes null to the Profit contract, causing failures or incorrect results as the Profit contract expects a valid SchemeId. [7](#0-6) 

2. **Permanent State Corruption**: The manager's scheme at `TokenHolderProfitSchemes[manager]` remains uninitialized indefinitely. Every subsequent call to methods like `ClaimProfits`, `ContributeProfits`, `RegisterForProfits`, or `Withdraw` repeats the bug, writing initialized data to different callers' addresses but never fixing the manager's state.

3. **Cross-Contamination**: If a caller who triggers the bug is also a scheme manager for a different scheme, their own scheme configuration at their address gets overwritten with the corrupted data from the manager's scheme they're interacting with.

4. **Inconsistent State**: Scheme data becomes fragmented - basic configuration fields (Symbol, MinimumLockMinutes, AutoDistributeThreshold) exist at the manager's address while critical operational fields (SchemeId, Period) are scattered at various user addresses. [8](#0-7) 

The actual profit distribution mechanism remains secure because it's handled by the underlying Profit contract based on properly registered beneficiary shares, preventing direct fund loss.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is highly likely to occur in production environments:

1. **Multiple Entry Points**: The bug can be triggered through any of these public methods: `ClaimProfits` [9](#0-8) , `ContributeProfits` [10](#0-9) , `RegisterForProfits` [5](#0-4) , or `Withdraw` [11](#0-10) .

2. **Realistic Preconditions**: The exploit only requires that a TokenHolder scheme is newly created and external users interact with it. This is a completely natural usage pattern - schemes are created to be used by beneficiaries.

3. **No Special Permissions Required**: Any user can trigger the bug through normal contract interaction without any privileged access.

4. **Attack Complexity: Low**: No sophisticated techniques are needed. The bug triggers automatically during routine operations.

## Recommendation

Fix the `UpdateTokenHolderProfitScheme` method to write to the `manager` parameter instead of `Context.Sender`:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId != null && !updateSchemePeriod) return;
    var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
    {
        Manager = manager
    }).SchemeIds.FirstOrDefault();
    Assert(originSchemeId != null, "Origin scheme not found.");
    var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
    scheme.SchemeId = originScheme.SchemeId;
    scheme.Period = originScheme.CurrentPeriod;
    State.TokenHolderProfitSchemes[manager] = scheme;  // FIX: Write to manager, not Context.Sender
}
```

## Proof of Concept

```csharp
[Fact]
public async Task StateCorruption_WritesToWrongAddress_Test()
{
    // Setup: Manager creates a scheme
    var managerStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, DefaultKeyPair);
    
    await managerStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Verify scheme exists at manager's address with null SchemeId
    var managerScheme = await managerStub.GetScheme.CallAsync(Starter);
    managerScheme.Symbol.ShouldBe("ELF");
    managerScheme.SchemeId.ShouldBeNull(); // Initially null
    
    // Attack: Different user calls ContributeProfits
    var userStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    
    await userStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,  // Manager's address
        Symbol = "ELF",
        Amount = 1
    });
    
    // BUG VERIFICATION: Manager's scheme still has null SchemeId
    managerScheme = await managerStub.GetScheme.CallAsync(Starter);
    managerScheme.SchemeId.ShouldBeNull(); // STILL NULL - Bug confirmed!
    
    // The initialized data went to the user's address instead
    var userScheme = await userStub.GetScheme.CallAsync(UserAddresses.First());
    userScheme.SchemeId.ShouldNotBeNull(); // User got the initialized data
    
    // View function will fail because manager's SchemeId is null
    var getProfitsResult = await managerStub.GetProfitsMap.SendWithExceptionAsync(
        new ClaimProfitsInput { SchemeManager = Starter });
    getProfitsResult.TransactionResult.Error.ShouldContain("Scheme not found");
}
```

## Notes

The existing test suite doesn't catch this bug because most tests have the scheme manager (Starter) calling operations on their own scheme, making `Context.Sender == manager`, which masks the bug. The vulnerability only manifests when a different user interacts with another user's scheme - a common real-world scenario.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-209)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L247-257)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        var beneficiary = input.Beneficiary ?? Context.Sender;
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L264-276)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var scheme = State.TokenHolderProfitSchemes[input.SchemeManager];
        var profitsMap = State.ProfitContract.GetProfitsMap.Call(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary ?? Context.Sender
        });
        return new ReceivedProfitsMap
        {
            Value = { profitsMap.Value }
        };
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L88-96)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary);

        return new ReceivedProfitsMap
        {
            Value = { allProfitsMapResult.AllProfitsMap }
        };
    }
```

**File:** protobuf/token_holder_contract.proto (L116-127)
```text
message TokenHolderProfitScheme {
    // The token symbol.
    string symbol = 1;
    // The scheme id.
    aelf.Hash scheme_id = 2;
    // The current dividend period.
    int64 period = 3;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 4;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 5;
}
```
