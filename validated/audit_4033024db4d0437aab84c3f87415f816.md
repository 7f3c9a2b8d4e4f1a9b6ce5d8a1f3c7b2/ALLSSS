# Audit Report

## Title
NFT Collection Creation Bypass Allows Non-Zero Decimals Through Direct TokenContract Call

## Summary
The AElf protocol enforces that NFT collections must have `Decimals = 0` to maintain indivisibility, but this invariant can be bypassed by calling `TokenContract.Create` directly with NFT collection symbols (ending with "-0") and non-zero decimals. The TokenContract only validates that decimals are within [0, 18], not that they equal zero for NFT collections, allowing creation of divisible "NFTs" that violate the fundamental NFT indivisibility invariant.

## Finding Description

The NFT contract properly enforces NFT indivisibility by hardcoding `Decimals = 0` when creating NFT protocols [1](#0-0) .

However, the `TokenContract.Create` method is publicly callable and routes token creation based on symbol patterns through `GetSymbolType` [2](#0-1) . The symbol type classification is purely pattern-based - symbols ending with "-0" are automatically classified as `NftCollection` [3](#0-2) .

When an NFT collection symbol is detected, `CreateNFTCollection` delegates directly to `CreateToken` [4](#0-3) , which validates decimals only through `AssertValidCreateInput`. This validation permits any value between 0 and `MaxDecimals` (18) [5](#0-4) . The `MaxDecimals` constant is set to 18 [6](#0-5) .

Only SEED NFTs have explicit `Decimals == 0` validation in the NFT creation flow [7](#0-6) . Regular NFT collections created via direct `TokenContract.Create` calls bypass the NFT contract entirely and inherit no decimals enforcement beyond the [0, 18] range check.

Once created, the TokenInfo is stored with the specified decimals value [8](#0-7) , and subsequent Issue and Transfer operations treat the token according to its stored decimals without additional NFT-specific validation [9](#0-8) .

The only requirement for calling `TokenContract.Create` (for non-whitelisted users) is ownership of a valid SEED NFT for the symbol, which is validated and then burned during token creation [10](#0-9) .

## Impact Explanation

**Protocol Invariant Violation**: NFTs are fundamentally defined as non-fungible, indivisible tokens with `Decimals = 0`. Creating NFT collections (symbols ending with "-0") with non-zero decimals breaks this core protocol invariant, allowing fractional NFT amounts. For example, an NFT collection with `Decimals = 8` could be issued/transferred in amounts like 50000000 (representing 0.5 of an "NFT").

**Ecosystem Confusion**: The AElf ecosystem (dApps, wallets, NFT marketplaces) relies on symbol patterns to identify token types. Symbols ending in "-0" are recognized as NFT collections, and individual items like "ABC-1" are recognized as NFTs within that collection. When these symbols represent divisible tokens, it creates:
- Incorrect display and accounting in NFT galleries and marketplaces
- Failed assumptions in smart contracts that interact with NFTs expecting indivisible units
- User deception when purchasing what appears to be an NFT based on symbol pattern but is actually divisible

**Operational Impact**: The malformed NFT collections can be fully operated as divisible tokens through standard MultiToken operations (Issue, Transfer, Approve, etc.), completely undermining the NFT semantic guarantees the protocol intends to provide.

## Likelihood Explanation

**Reachable Entry Point**: `TokenContract.Create` is a public method callable by any user on the network. It is the standard entry point for token creation and does not require special privileges.

**Feasible Preconditions**: 
- The attacker must obtain a SEED NFT for their desired symbol (e.g., "ABC"), which can be acquired through the normal SEED NFT creation and issuance mechanisms available in the protocol
- No governance approvals, whitelisting, or special contract permissions are required beyond standard SEED NFT ownership

**Execution Steps**:
1. Acquire SEED NFT for symbol "ABC" (through normal SEED NFT mechanisms)
2. Call `TokenContract.Create` with:
   - `Symbol = "ABC-0"` (NFT collection format)
   - `Decimals = 8` (or any value 1-18)
   - Valid `TotalSupply`, `Issuer`, and other required parameters
3. The system validates the SEED NFT ownership and burns it
4. Token is created with non-zero decimals as an NFT collection
5. The attacker can now issue and transfer fractional amounts of this "NFT collection"

**Economic Rationality**: SEED NFT acquisition costs are reasonable within the protocol's token economics, and the ability to create confusing NFT-like tokens could enable deceptive schemes in secondary markets or cause integration issues with NFT-dependent protocols.

## Recommendation

Add explicit `Decimals = 0` validation for NFT collections in the `AssertValidCreateInput` or `CreateToken` methods. The fix should be applied in `TokenContract_Helper.cs`:

```csharp
private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
{
    Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
           && input.Symbol.Length > 0
           && input.Decimals >= 0
           && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
    
    // Add explicit decimals validation for NFT collections
    if (symbolType == SymbolType.NftCollection)
    {
        Assert(input.Decimals == 0, "NFT collections must have Decimals = 0.");
    }

    CheckSymbolLength(input.Symbol, symbolType);
    if (symbolType == SymbolType.Nft) return;
    CheckTokenAndCollectionExists(input.Symbol);
    if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
}
```

This ensures that NFT collections created through both `NFTContract.Create` and direct `TokenContract.Create` calls maintain the indivisibility invariant.

## Proof of Concept

```csharp
[Fact]
public async Task NFTCollection_NonZeroDecimals_BypassTest()
{
    // Setup: Create and issue SEED NFT for symbol "TEST"
    var seedSymbol = "SEED-1";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "SEED-0",
        TokenName = "SEED Collection",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        Owner = DefaultSender
    });
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = seedSymbol,
        TokenName = "SEED for TEST",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        Owner = DefaultSender,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {TokenContractConstants.SeedOwnedSymbolExternalInfoKey, "TEST"},
                {TokenContractConstants.SeedExpireTimeExternalInfoKey, 
                    (Context.CurrentBlockTime.Seconds + 100000).ToString()}
            }
        }
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = seedSymbol,
        Amount = 1,
        To = DefaultSender
    });
    
    // Exploit: Create NFT collection with non-zero decimals directly
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST-0",  // NFT collection format
        TokenName = "Test NFT Collection",
        TotalSupply = 100000000,  // 1.0 with decimals=8
        Decimals = 8,  // Non-zero decimals for "NFT"!
        Issuer = DefaultSender,
        IsBurnable = true,
        Owner = DefaultSender
    });
    
    // Verify: Token created with non-zero decimals
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "TEST-0"
    });
    
    Assert.Equal(8, tokenInfo.Decimals);  // Should be 0 for NFT collections, but is 8!
    
    // Demonstrate: Can issue and transfer fractional amounts
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "TEST-0",
        Amount = 50000000,  // 0.5 of an "NFT"
        To = DefaultSender
    });
    
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "TEST-0",
        Owner = DefaultSender
    });
    
    Assert.Equal(50000000, balance.Balance);  // Fractional NFT balance exists!
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L26-26)
```csharp
            Decimals = 0, // Fixed
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-193)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }

    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-40)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L6-6)
```csharp
    public const int MaxDecimals = 18;
```
