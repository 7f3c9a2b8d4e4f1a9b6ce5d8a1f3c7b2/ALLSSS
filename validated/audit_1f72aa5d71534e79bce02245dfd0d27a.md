# Audit Report

## Title
Taylor Series Truncation in Exp Function Causes Convergence Failure for Large Exponents in Token Conversion

## Summary
The `Exp` function in BancorHelper uses only 20 iterations of the Taylor series expansion [1](#0-0) , which is insufficient for large exponents that can occur during token conversion operations. When connector weights are set to extreme ratios by governance and users attempt large trades, the exponent can exceed the convergence range, causing arithmetic overflow or wildly incorrect values that lead to transaction failures (DoS).

## Finding Description

The vulnerability exists in the mathematical approximation used for exponential calculations. The `Exp` function implements exponential calculation using a truncated Taylor series with only 20 terms [2](#0-1) . 

The critical issue occurs in the `GetReturnFromPaid` function used during Sell operations [3](#0-2) , which is invoked by the `Sell` method [4](#0-3) .

The exponent passed to `Exp` is calculated as `y * Ln(x)` where:
- `y = fromConnectorWeight / toConnectorWeight` (weight ratio calculated at line 52)
- `x = fromConnectorBalance / (fromConnectorBalance + paidAmount)` (calculated at line 51)

**Root Cause**: Connector weights are only constrained to be between 0 and 1 (exclusive) [5](#0-4) , validated by `AssertValidConnectorWeight` [6](#0-5) . However, there is **no constraint on the ratio between weights**.

**Example Scenario**: If ResourceWeight = 0.5 and NativeWeight = 0.01, then y = 50. When a user sells a large amount relative to the connector balance:
- If `fromConnectorBalance = 10,000,000` and `paidAmount = 90,000,000`, then `x = 0.1`
- `Ln(0.1) ≈ -2.303`
- Exponent: `50 * (-2.303) = -115.15`

For `exp(-115.15)`, the 20-term Taylor series does not converge. The true value is approximately `3.6e-51` (essentially zero), but computing the 20th term requires calculating `(-115.15)^20 / 20!`, where the numerator (approximately 4.6e40) exceeds C# decimal.MaxValue (7.9e28), causing arithmetic overflow.

The `Ln` function constraint only prevents |1-a| >= 1 [7](#0-6) , which ensures the input to Ln is valid, but does not prevent extreme exponents after weight multiplication.

## Impact Explanation

**Primary Impact - Denial of Service**: When the `Exp` function encounters arithmetic overflow or returns an incorrect value, the formula `Return = bt * (1 - Exp(...))` produces:
- Arithmetic overflow exceptions during calculation of large power terms
- Negative return values (causing transaction revert)  
- Values exceeding connector balance (causing underflow when subtracted from deposit balance at line 193-194 of TokenConverterContract.cs)

This renders Sell operations unusable for large trades when weight ratios are extreme, creating a DoS condition for critical protocol functionality.

**Secondary Impact - Potential Mispricing**: In edge cases where the incorrect `Exp` value happens to fall in a valid range (0, 1) but is significantly wrong, users could receive incorrect amounts during token swaps.

**Affected Users**: 
- Token sellers unable to execute large trades
- All users if governance misconfigures weights
- TokenConverter contract functionality degraded

**Severity Justification**: While direct fund theft is unlikely (most errors cause transaction failure), this creates operational DoS of a critical protocol component. The vulnerability affects protocol availability and functionality.

## Likelihood Explanation

**Preconditions**:
1. Governance sets connector pairs with extreme weight ratios (e.g., 0.5 and 0.01) via `AddPairConnector` [8](#0-7)  or `UpdateConnector` [9](#0-8) 
2. Sufficient token supply distributed to users
3. Users attempt large sell transactions relative to connector balance

**Realistic Assessment**: 
- Test configurations use equal weights (0.05/0.05) [10](#0-9) , suggesting this is standard practice
- However, governance has legitimate authority to set different weights for specialized token pairs
- No warning or documentation about this mathematical limitation exists
- The vulnerability is latent in the code and will manifest if governance configures extreme ratios

**Probability**: Medium-Low in default configuration (weights are equal), but Medium-High if governance creates connectors with extreme weight ratios for specialized token pairs. The issue is not about malicious governance but rather a mathematical bug that manifests when governance uses their legitimate powers in certain valid configurations.

## Recommendation

Implement one or more of the following mitigations:

1. **Add Weight Ratio Constraint**: Enforce maximum ratio between connector weights (e.g., weights must not differ by more than 10x)

2. **Increase Taylor Series Terms**: Increase `_LOOPS` to handle larger exponents, though this increases gas costs

3. **Add Exponent Range Check**: Before calling `Exp`, validate that the exponent is within convergence range (e.g., |exponent| < 20)

4. **Use Alternative Implementation**: Replace Taylor series with a more robust exponential approximation that handles extreme values

Example fix (Option 3):
```csharp
private static decimal Exp(decimal y)
{
    // Add safety check for exponent range
    if (Math.Abs(y) > 20)
        throw new InvalidValueException("Exponent exceeds safe range for Taylor series convergence");
    
    var iteration = _LOOPS;
    decimal result = 1;
    while (iteration > 0)
    {
        var fatorial = Fact[iteration - 1];
        result += Pow(y, (uint)iteration) / fatorial;
        iteration--;
    }
    return result;
}
```

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public void ExtremeWeightRatio_CausesArithmeticOverflow()
{
    // Setup: Governance sets extreme weight ratio
    var resourceWeight = 0.5m;
    var nativeWeight = 0.01m;  // Ratio of 50:1
    
    var fromConnectorBalance = 10_000_000L;
    var paidAmount = 90_000_000L;  // User selling 9x the connector balance
    var toConnectorBalance = 100_000_000L;
    
    // This will cause arithmetic overflow in Exp function
    // x = 10M / 100M = 0.1
    // y = 0.5 / 0.01 = 50
    // exponent = 50 * Ln(0.1) ≈ 50 * (-2.303) = -115.15
    // (-115.15)^20 ≈ 4.6e40 which exceeds decimal.MaxValue (7.9e28)
    
    Assert.Throws<OverflowException>(() =>
        BancorHelper.GetReturnFromPaid(
            fromConnectorBalance, resourceWeight,
            toConnectorBalance, nativeWeight,
            paidAmount)
    );
}
```

**Notes**

This is a valid mathematical vulnerability in the contract's pricing implementation. While governance is trusted, the contract should handle the full range of valid governance configurations without arithmetic failure. The issue is comparable to an integer overflow bug that only manifests with certain valid parameter combinations - still a contract vulnerability even if parameters are set by trusted parties. The lack of bounds checking on weight ratios combined with the limited convergence range of the 20-term Taylor series creates a latent DoS condition.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L131-132)
```csharp
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-109)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** test/AElf.Contracts.Economic.TestBase/ContractsPreparation.cs (L595-601)
```csharp
            await SetConnector(new PairConnectorParam
            {
                ResourceConnectorSymbol = EconomicContractsTestConstants.TransactionFeeChargingContractTokenSymbol,
                ResourceWeight = "0.05",
                NativeWeight = "0.05",
                NativeVirtualBalance = 1_000_000_00000000
            });
```
