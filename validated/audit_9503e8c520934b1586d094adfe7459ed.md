# Audit Report

## Title
Continuous Blocks Limit Bypass via RoundNumber Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
A malicious miner can bypass the continuous blocks production limit by manipulating the `RoundNumber` field in consensus extra data for UpdateValue and TinyBlock behaviors. By setting `RoundNumber` to ≤2, the miner skips the `ContinuousBlocksValidationProvider` check, allowing unlimited consecutive block production beyond the intended 8-block limit.

## Finding Description

The AEDPoS consensus mechanism implements a continuous blocks limit to prevent any single miner from monopolizing block production. This protection is enforced through `ContinuousBlocksValidationProvider`, which validates that a miner hasn't exceeded their quota tracked in `LatestPubkeyToTinyBlocksCount`. [1](#0-0) 

However, this protection has a critical bypass: validation is skipped when `RoundNumber ≤ 2`. The vulnerability arises because:

1. The `ProvidedRound` used in validation comes directly from the untrusted consensus extra data in the block header: [2](#0-1) 

2. During validation, recovery methods only merge miner information without validating or correcting the RoundNumber field: [3](#0-2) [4](#0-3) 

3. UpdateValue and TinyBlock behaviors do NOT receive `RoundTerminateValidationProvider`, which would validate RoundNumber correctness: [5](#0-4) 

In contrast, NextRound and NextTerm behaviors DO have this validation: [6](#0-5) 

**Exploitation Mechanism:**

When a miner's continuous blocks count becomes negative, `GetConsensusCommand` returns an advisory to use NextRound behavior: [7](#0-6) 

A malicious miner can:
1. Ignore this advisory
2. Manually construct UpdateValue or TinyBlock consensus extra data
3. Set `RoundNumber = 1` (or 2) in the consensus extra data
4. Include it in the block header

Since the validation check `ProvidedRound.RoundNumber > 2` evaluates to false, the continuous blocks validation is entirely skipped.

After execution, the recovery process corrects the RoundNumber before hash validation, making the manipulation difficult to detect: [8](#0-7) 

## Impact Explanation

This vulnerability breaks the fundamental fairness guarantee of the AEDPoS consensus mechanism. The continuous blocks limit is defined as 8 blocks: [9](#0-8) 

The tracking mechanism that enforces this limit: [10](#0-9) 

**Concrete Harm:**
- **Consensus Monopolization**: A single miner can produce unlimited consecutive blocks, completely bypassing the intended 8-block limit
- **Block Production Starvation**: Other honest miners are denied their fair share of block production opportunities
- **Reward Misallocation**: The exploiting miner receives disproportionate mining rewards
- **Consensus Integrity**: Breaks the round-robin mechanism designed to ensure distributed consensus participation

## Likelihood Explanation

**Attacker Profile:** Any active miner in the consensus set

**Required Capabilities:**
1. Being an active miner (standard prerequisite)
2. Modifying node software to ignore `GetConsensusCommand` advisory
3. Manually constructing consensus extra data with manipulated `RoundNumber`

**Attack Complexity:** Low - only requires setting a single field (`RoundNumber`) to a value ≤2 in the consensus extra data before block production. No cryptographic operations, race conditions, or complex state manipulation required.

**Feasibility:** High - miners have full control over the consensus extra data they include in their block headers. The manipulation occurs entirely locally during block generation.

**Detection Difficulty:** High - the manipulated `RoundNumber` is corrected during the recovery phase before hash validation, making post-execution detection challenging without inspecting raw block headers before validation.

## Recommendation

Add `RoundTerminateValidationProvider` to UpdateValue and TinyBlock behaviors, or create a dedicated RoundNumber validation provider that ensures the provided `RoundNumber` matches the current state's `RoundNumber` for these behaviors.

**Option 1: Add existing validator**
```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.TinyBlock:
    validationProviders.Add(new RoundTerminateValidationProvider()); // Add this
    break;
```

However, `RoundTerminateValidationProvider` currently only validates NextRound/NextTerm, so it would need modification to handle UpdateValue/TinyBlock.

**Option 2: Create dedicated validator**
Create a `RoundNumberValidationProvider` that validates the provided `RoundNumber` matches the current state's `RoundNumber` for UpdateValue and TinyBlock behaviors.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a scenario where a miner has exhausted their continuous blocks limit (`BlocksCount < 0`)
2. Have the miner produce an UpdateValue or TinyBlock with `RoundNumber = 1` in the consensus extra data
3. Verify that the block passes validation despite the negative `BlocksCount`
4. Demonstrate that the miner can continue producing blocks indefinitely

The core vulnerability is that `ValidateBeforeExecution` in `AEDPoSContract_Validation.cs` fails to validate `RoundNumber` for UpdateValue/TinyBlock behaviors, allowing the bypass of `ContinuousBlocksValidationProvider`'s check at line 13.

## Notes

This vulnerability specifically affects the consensus fairness mechanism rather than causing fund loss. However, it represents a critical break in the consensus integrity guarantees that AEDPoS is designed to provide. The round-robin block production schedule is a core security property that prevents consensus centralization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
