# Audit Report

## Title
State Update Pattern Violation in SetTransactionFeeDelegations Causes Empty Delegatee Entries to Persist

## Summary
The `SetTransactionFeeDelegations` function fails to properly remove empty delegatee entries from storage due to a state management antipattern. When all delegations for a delegatee are removed, the function attempts deletion via direct state access that returns a deserialized copy rather than a reference, causing the removal operation to be lost. This allows empty delegatee entries to accumulate until the 24-entry limit blocks users from adding legitimate delegatees.

## Finding Description

AElf's contract state system uses protobuf serialization where `MappedState` getters return deserialized copies, not references. Modifications to these copies must be explicitly written back to persist.

The bug occurs in the update branch when removing a delegatee with zero delegations: [1](#0-0) 

**Execution Flow:**
1. Lines 68-80 modify the local `delegationsMap` object, removing entries where value â‰¤ 0
2. Line 83 writes the entire `allDelegatees` structure back to state (containing the now-empty delegatee)
3. Line 86 checks if delegation count is non-zero; if zero, execution continues
4. **Line 91 (BUG):** Attempts removal via `State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress)`

At line 91, the state getter returns a fresh deserialized copy. The `.Remove()` operation modifies this copy but never writes it back, so the delegatee entry persists in storage.

**Proof of Correct Pattern:**

The correct read-modify-write pattern is demonstrated in both removal methods: [2](#0-1) [3](#0-2) 

Additionally, the similar function `SetTransactionFeeDelegateInfos` correctly removes empty delegatees by modifying a local variable and writing it back: [4](#0-3) 

## Impact Explanation

**1. Delegatee Limit Denial of Service**

The contract enforces a hard limit of 24 delegatees: [5](#0-4) 

This limit is checked when adding new delegatees: [6](#0-5) 

Users who accumulate 24 empty delegatee entries cannot add new legitimate delegatees, despite having zero active delegations. This creates a permanent DoS condition for the delegation feature.

**2. Gas Inefficiency**

During transaction fee charging, the system iterates through all stored delegatees: [7](#0-6) 

Empty delegatees waste gas on every transaction by forcing iteration over entries that can never satisfy fee requirements.

**3. Storage Pollution**

Empty delegatee entries consume permanent state storage without any cleanup mechanism, increasing chain state bloat.

**4. Test Gap Masking the Bug**

The existing test only verifies that the delegation count reaches zero but doesn't confirm delegatee entry removal: [8](#0-7) 

The query function returns an empty object for both non-existent and empty delegatees, masking the distinction: [9](#0-8) 

## Likelihood Explanation

**High Likelihood - Triggered by Normal User Operations:**

- **Reachability:** The method is public and callable by any user
- **Trigger Condition:** Users naturally clean up delegations by setting all amounts to 0 or negative values when removing a delegatee
- **Frequency:** Over the protocol's lifetime, users will repeatedly add and remove delegations, incrementally accumulating ghost entries
- **No Attack Required:** This is a pure logic bug in normal delegation management, requiring no adversarial behavior or special privileges

Each user can accumulate up to 24 empty delegatee entries through legitimate usage patterns, permanently blocking their ability to delegate transaction fees to new addresses.

## Recommendation

Replace the direct state modification at line 91 with the correct read-modify-write pattern:

```csharp
// Instead of:
State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);

// Use:
var delegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
delegatees.Delegatees.Remove(delegateeAddress);
State.TransactionFeeDelegateesMap[input.DelegatorAddress] = delegatees;
```

This follows the same pattern used successfully in `RemoveTransactionFeeDelegator` and `RemoveTransactionFeeDelegatee`.

## Proof of Concept

```csharp
[Fact]
public async Task SetTransactionFeeDelegations_EmptyDelegatee_ShouldBeRemoved()
{
    // Setup: Create token and add initial delegatee with delegations
    await Initialize();
    var delegations = new Dictionary<string, long>
    {
        [NativeToken] = 100,
        [BasicFeeSymbol] = 200
    };
    
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = User1Address,
            Delegations = { delegations }
        });

    // Verify delegatee was added
    var delegateesBefore = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
    delegateesBefore.DelegateeAddresses.Count.ShouldBe(1);
    delegateesBefore.DelegateeAddresses[0].ShouldBe(DefaultAddress);

    // Remove all delegations by setting to 0
    var emptyDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 0,
        [BasicFeeSymbol] = 0
    };
    
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = User1Address,
            Delegations = { emptyDelegations }
        });

    // BUG: Delegatee entry should be removed but persists
    var delegateesAfter = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
    
    // This assertion will FAIL due to the bug
    delegateesAfter.DelegateeAddresses.Count.ShouldBe(0); // Expected: 0, Actual: 1
    
    // The delegatee entry remains despite having no active delegations
    var remainingDelegation = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput
        {
            DelegatorAddress = User1Address,
            DelegateeAddress = DefaultAddress
        });
    remainingDelegation.Delegations.Count.ShouldBe(0); // Delegations are empty but entry exists
}
```

This test demonstrates that after removing all delegations, the delegatee entry persists in storage (count remains 1) even though the delegations map is empty, confirming the state management bug.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L31-37)
```csharp
            if (allDelegateesMap.Count() >= TokenContractConstants.DELEGATEE_MAX_COUNT)
            {
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = false
                };
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L66-98)
```csharp
        else // This delegatee exists, so update
        {
            var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }

            // Set and Fire logEvent
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

            // If a delegatee has no delegations, remove it!
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
            Context.Fire(new TransactionFeeDelegationCancelled()
            {
                Caller = Context.Sender,
                Delegatee = Context.Sender,
                Delegator = input.DelegatorAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L122-124)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
        delegatees.Delegatees.Remove(Context.Sender.ToBase58());
        State.TransactionFeeDelegateesMap[input.DelegatorAddress] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L151-153)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[Context.Sender];
        delegatees.Delegatees.Remove(input.DelegateeAddress.ToBase58());
        State.TransactionFeeDelegateesMap[Context.Sender] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L164-179)
```csharp
    public override TransactionFeeDelegations GetTransactionFeeDelegationsOfADelegatee(
        GetTransactionFeeDelegationsOfADelegateeInput input)
    {
        var allDelegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
        var delegateeAddress = input.DelegateeAddress.ToBase58();
        // According to protoBuf, return an empty object, but null.
        if (allDelegatees == null)
        {
            return new TransactionFeeDelegations();
        }

        var allDelegateesMap = allDelegatees.Delegatees;
        return allDelegateesMap.ContainsKey(delegateeAddress)
            ? allDelegateesMap[delegateeAddress]
            : new TransactionFeeDelegations();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-245)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L100-116)
```csharp
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenDelegationTest.cs (L51-76)
```csharp
    public async Task SetTokenDelegation_removeDelegatee_Test()
    {
        await SetTokenDelegation_Test();
        var delegations = new Dictionary<string, long>
        {
            [NativeToken] = 0,
            [BasicFeeSymbol] = 0,
            [SizeFeeSymbol] = 0
        };
        await TokenContractStub.SetTransactionFeeDelegations.SendAsync(new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations =
            {
                delegations
            }
        });

        var delegateAllowance = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
            new GetTransactionFeeDelegationsOfADelegateeInput()
            {
                DelegateeAddress = DefaultAddress,
                DelegatorAddress = User1Address
            });
        delegateAllowance.Delegations.Count().ShouldBe(0);
    }
```
