# Audit Report

## Title
Unvalidated Secret Sharing Revelations Allow Consensus State Poisoning via First-Write-Wins Policy

## Summary
The AEDPoS consensus contract accepts `RevealedInValues` from miner-controlled trigger information without cryptographic validation, implementing a first-write-wins policy that allows malicious miners to inject incorrect `PreviousInValue` data for other miners. These poisoned values persist to state and are used to calculate consensus signatures, corrupting randomness generation and round transitions.

## Finding Description

The vulnerability exists in the secret sharing revelation mechanism where a malicious miner can inject arbitrary `PreviousInValue` data for other miners without on-chain validation.

**Attack Flow:**

When a miner produces a block with `UpdateValue` behavior, their node provides trigger information containing `RevealedInValues`. The `UpdateLatestSecretPieces()` method processes these revealed values and writes them directly to the Round object if the target miner's `PreviousInValue` is null or empty, implementing a first-write-wins policy. [1](#0-0) 

The modified Round flows into transaction input via `ExtractInformationToUpdateConsensus()`, which extracts all non-null `PreviousInValue` fields into `MinersPreviousInValues`. [2](#0-1) 

During transaction execution, `PerformSecretSharing()` writes these unvalidated values directly to state. [3](#0-2) 

When `NextRound` is triggered, `SupplyCurrentRoundInformation()` reads the poisoned `PreviousInValue` from state for miners who didn't mine, and uses it to calculate their signatures. [4](#0-3) 

**Root Cause:**

The validation provider only checks the sender's own `PreviousInValue` against their previous `OutValue`. [5](#0-4) 

No validation occurs for the `RevealedInValues` that the sender provides for OTHER miners. A malicious miner can inject arbitrary hash values for victim miners who failed to mine in previous rounds.

## Impact Explanation

**Consensus State Corruption:** The attack corrupts the cryptographic integrity of consensus state. Signatures are calculated using XOR operations that combine the malicious `PreviousInValue` with all miners' existing signatures. [6](#0-5) 

**Specific Impacts:**
- **Randomness Manipulation**: Incorrect signatures affect consensus randomness generation, potentially influencing block producer selection and other randomness-dependent operations
- **Mining Order Disruption**: Corrupted signature values influence the calculated mining order for subsequent rounds through the XOR-based signature mechanism
- **Persistent State Corruption**: Incorrect values remain in on-chain state until affected miners successfully mine again, potentially spanning multiple rounds
- **Consensus Integrity Violation**: The fundamental security guarantee that consensus state reflects legitimate cryptographic operations is broken

While this doesn't directly result in fund theft, it undermines the security properties of the consensus mechanism itself, which is critical for blockchain operation.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a scheduled miner in the current miner list
- Must control their node software to inject arbitrary `RevealedInValues` in trigger information
- Must produce a block during a round where target miners have failed to mine

**Feasibility:** MEDIUM
- Miners naturally control their own node software and can modify consensus command generation
- The trigger information is generated by the attacker's node and directly accepted by the contract [7](#0-6) 
- The first-write-wins policy ensures malicious values persist once written
- Detection is difficult as revealed values appear legitimate without independent secret sharing verification

**Exploitation Window:** The attack targets miners who missed their time slots in previous rounds, which naturally occurs during network issues or node maintenance. A malicious miner producing blocks after such events can inject incorrect recovery values.

## Recommendation

Implement cryptographic validation of `RevealedInValues` by verifying that they match the secret sharing reconstruction from available decrypted pieces on-chain. The contract should:

1. Verify that sufficient decrypted pieces exist for the revealed miner (2/3 threshold)
2. Reconstruct the in value from on-chain decrypted pieces using `SecretSharingHelper.DecodeSecret`
3. Compare the reconstructed value with the provided `RevealedInValue`
4. Only accept revealed values that match the cryptographic reconstruction

Alternatively, remove the `RevealedInValues` from trigger information entirely and rely solely on the on-chain `RevealSharedInValues()` method [8](#0-7)  which already performs proper cryptographic validation during `NextRound` behavior.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a testnet with multiple miners
2. Having one miner (victim) miss their time slot due to simulated network issue
3. Having another miner (attacker) modify their node to inject arbitrary `RevealedInValues` in trigger information for the victim
4. Observing that the malicious value is written to state without validation
5. Triggering `NextRound` and verifying the victim's signature is calculated using the poisoned `PreviousInValue`
6. Confirming the corrupted signature persists in on-chain state and affects subsequent consensus rounds

**Notes**

The legitimate secret sharing process requires cryptographic reconstruction from decrypted pieces with proper threshold validation, as shown in the off-chain `SecretSharingService` implementation. [9](#0-8)  The on-chain contract bypasses this validation when accepting `RevealedInValues` from trigger information, creating a trust assumption that miner nodes will provide honest values. This violates the principle that on-chain logic should not trust off-chain inputs without verification.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L124-125)
```csharp
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-184)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        var revealedInValues = new Dictionary<string, Hash>();

        foreach (var pair in round.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == selfPubkey) continue;

            var pubkey = pair.Key;
            var minerInRound = pair.Value;

            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
        }

        _revealedInValues[secretSharingInformation.CurrentRoundId] = revealedInValues;
    }
```
