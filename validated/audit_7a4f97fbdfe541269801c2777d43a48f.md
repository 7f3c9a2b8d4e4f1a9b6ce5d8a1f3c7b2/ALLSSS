# Audit Report

## Title
Secret Sharing Information Persists in Contract State Despite Deletion Attempt

## Summary
The AEDPoS consensus contract's `DeleteSecretSharingInformation()` function only clears secret sharing data from an in-memory Round object copy used for block headers, but fails to remove it from persistent contract state storage. This architectural flaw allows anyone to recover sensitive EncryptedPieces and DecryptedPieces through public view methods, completely defeating the intended security mechanism of ephemeral secret sharing data used for consensus randomness generation.

## Finding Description

The vulnerability stems from a critical disconnect between the deletion mechanism and persistent state management in the secret sharing protocol.

The `DeleteSecretSharingInformation()` method clears EncryptedPieces and DecryptedPieces from a Round object: [1](#0-0) 

However, this method is only invoked when generating consensus block extra data, specifically on a local variable prepared for the block header: [2](#0-1) 

The root cause is that secret sharing data was already written to permanent storage earlier in the execution flow. When miners execute UpdateValue transactions, the `ProcessUpdateValue` method calls `PerformSecretSharing` when secret sharing is enabled: [3](#0-2) 

The `PerformSecretSharing` method adds encrypted and decrypted pieces directly to the Round object: [4](#0-3) 

This Round object containing all secret sharing data is then persisted to state: [5](#0-4) 

The `TryToUpdateRoundInformation` implementation writes directly to persistent state: [6](#0-5) 

Critically, the persistent state in `State.Rounds[round.RoundNumber]` is never updated to remove the secrets after they are added. Public view methods directly return this unredacted state: [7](#0-6) 

The helper methods used by these view methods retrieve data directly from persistent state: [8](#0-7) [9](#0-8) 

The protobuf structure confirms that MinerInRound contains these sensitive cryptographic fields: [10](#0-9) 

## Impact Explanation

This vulnerability represents a **HIGH severity** breach of consensus integrity by exposing cryptographic materials that are fundamental to the security of the AEDPoS consensus protocol.

The encrypted_pieces contain encrypted shares of miners' InValues, and decrypted_pieces contain decrypted shares recovered from other miners. These are part of the secret sharing protocol used for verifiable random number generation in consensus. The protocol design assumes these pieces remain ephemeral - used only during the consensus round and then discarded.

By making these pieces permanently queryable through public view methods, an attacker can:

1. **Reconstruct miners' InValues prematurely**: With access to sufficient decrypted pieces (2/3 threshold as shown in the recovery mechanism), an attacker can potentially reconstruct a miner's InValue before it's meant to be revealed, breaking the commit-reveal scheme. [11](#0-10) 

2. **Predict future random values**: The consensus protocol uses these InValues to generate signatures and ultimately random hashes. Knowledge of InValues allows prediction of future randomness used in consensus decisions.

3. **Manipulate consensus outcomes**: With foreknowledge of consensus randomness, an attacker could potentially time transactions or actions to take advantage of predictable random outcomes, undermining the fairness guarantees of the consensus mechanism.

The severity is HIGH because:
- Consensus randomness is a **critical security property** of the AEDPoS protocol
- The vulnerability completely defeats the intended protection mechanism (DeleteSecretSharingInformation exists specifically to prevent this exposure)
- All consensus participants are affected - their secret sharing information becomes publicly queryable indefinitely
- The design intent is clear (ephemeral secrets), but the implementation fails to achieve it

## Likelihood Explanation

The likelihood is **100% - CERTAIN**. This is not a race condition or timing-dependent vulnerability, but a fundamental architectural flaw in state management.

**Attacker capabilities required:** None beyond calling a public view method available to any user or observer.

**Attack complexity:** Trivial - requires only calling `GetCurrentRoundInformation()` or `GetRoundInformation(roundNumber)` which returns Round with all secret sharing data intact.

**Feasibility conditions:** 
- Secret sharing is enabled (checked via `IsSecretSharingEnabled()`) [12](#0-11) 
- Miners have executed UpdateValue transactions (normal consensus operation)
- Both conditions are met during standard protocol operation on mainnet

**Detection constraints:** The attack requires no transactions and leaves no traces, as it only involves reading public state through view methods. The data exposure is persistent - once written, it remains queryable indefinitely (until old rounds are pruned per the retention policy).

The vulnerability contradicts the entire purpose of `DeleteSecretSharingInformation()`, which exists specifically to prevent persistent storage of these sensitive cryptographic materials. The fact that this function exists but only operates on ephemeral copies demonstrates clear design intent that is not properly implemented.

## Recommendation

The fix should ensure that secret sharing information is removed from persistent state after it's no longer needed. Implement one of these approaches:

**Option 1 - Remove after use**: Call a state-modifying version of DeleteSecretSharingInformation on the persistent Round object after the secret sharing protocol completes (e.g., when transitioning to the next round).

**Option 2 - Redact in view methods**: Modify GetCurrentRoundInformation and GetRoundInformation to clone the Round object and remove secret sharing data before returning it.

**Option 3 - Store separately**: Store secret sharing pieces in a separate state structure that is explicitly cleared after each round, rather than embedding them in the persistent Round object.

**Recommended Implementation (Option 1)**:
After successfully using secret sharing data in `ProcessNextRound` or `ProcessNextTerm`, explicitly update the previous round's state to remove the secret pieces by calling a modified version of TryToUpdateRoundInformation with a sanitized Round object.

## Proof of Concept

The vulnerability can be demonstrated with a simple test that:
1. Progresses through a consensus round with secret sharing enabled
2. Calls `GetCurrentRoundInformation()` or `GetRoundInformation(roundNumber)` 
3. Verifies that the returned Round object contains non-empty EncryptedPieces and/or DecryptedPieces maps
4. Uses the exposed DecryptedPieces to reconstruct InValues using the same logic as `RevealSharedInValues`

This would demonstrate that sensitive cryptographic material remains accessible through public view methods, violating the design intent evidenced by the existence of `DeleteSecretSharingInformation()`.

## Notes

The existence of `DeleteSecretSharingInformation()` is critical evidence of design intent - this method serves no purpose other than to prevent exposure of secret sharing data. The implementation flaw is that it's only applied to ephemeral block header data, not to the persistent state that remains queryable through view methods. This creates a disconnect between the intended security model (ephemeral secrets) and the actual implementation (permanently stored secrets).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L66-70)
```csharp
    private bool TryToGetRoundInformation(long roundNumber, out Round round)
    {
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L21-29)
```csharp
    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }

    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** protobuf/aedpos_contract.proto (L293-296)
```text
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
