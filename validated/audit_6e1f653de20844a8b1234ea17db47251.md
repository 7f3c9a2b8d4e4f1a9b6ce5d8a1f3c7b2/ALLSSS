# Audit Report

## Title
Missing Order Value Validation in Round Structure Enables Consensus DoS Attack

## Summary
The AEDPoS consensus contract fails to validate that miner Order values in `NextRoundInput` are sequential starting from 1. When a malicious miner submits a round with invalid Order values (e.g., starting from 10), the `GetMiningInterval()` method throws an unhandled `ArgumentOutOfRangeException`, causing all nodes to crash when attempting to retrieve consensus commands and halting the entire blockchain.

## Finding Description

The vulnerability stems from a critical assumption that miner Order values are sequential starting from 1, without any validation to enforce this invariant on external input.

The `CommandStrategyBase` class stores a Round parameter and exposes a `MiningInterval` property that delegates to `CurrentRound.GetMiningInterval()` [1](#0-0) . All strategy implementations (`NormalBlockCommandStrategy`, `TinyBlockCommandStrategy`, `TerminateRoundCommandStrategy`) access this property [2](#0-1) [3](#0-2) .

The critical flaw exists in `GetMiningInterval()` which filters for miners with `Order == 1` or `Order == 2`, then directly accesses `firstTwoMiners[1]` without bounds checking [4](#0-3) . If no miners have these Order values, the list is empty and accessing index 1 throws an `ArgumentOutOfRangeException`.

The validation pipeline includes `CheckRoundTimeSlots()` which only verifies time intervals between consecutive miners ordered by their Order property, but does NOT validate that Order values start from 1 [5](#0-4) . This is invoked by `TimeSlotValidationProvider` [6](#0-5) .

The `NextRoundMiningOrderValidationProvider` only validates that the count of miners with `FinalOrderOfNextRound > 0` matches the count with `OutValue != null`, but does not check Order sequentiality [7](#0-6) .

The `NextRoundInput.ToRound()` conversion performs no validation on Order values [8](#0-7) . When `ProcessNextRound()` processes the input, it converts and stores the unvalidated Round [9](#0-8)  via `AddRoundInformation()` [10](#0-9) .

**Attack Path:**
1. Malicious miner crafts `NextRoundInput` with Order values starting from 10 (e.g., 10, 11, 12...)
2. Sets `ExpectedMiningTime` with consistent intervals to pass `CheckRoundTimeSlots()`
3. Ensures `FinalOrderOfNextRound` counts match `OutValue` counts
4. Calls public `NextRound()` method [11](#0-10) 
5. `PreCheck()` validates miner is in miner list and passes [12](#0-11) 
6. Malicious Round is stored in state
7. When any miner calls `GetConsensusCommand()` [13](#0-12) , strategy classes are instantiated with the malicious Round
8. Strategy property access triggers `GetMiningInterval()` which crashes with empty `firstTwoMiners` list

The code in `Round_Generation.cs` demonstrates the system expects sequential Order values starting from 1, using `Enumerable.Range(1, minersCount)` to generate orders [14](#0-13)  and explicitly checking for miners with `Order == 1` [15](#0-14) , but validation never enforces this invariant on external input.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial of service of the consensus mechanism. Once a malicious Round is stored in state, ALL nodes crash with an unhandled `ArgumentOutOfRangeException` when attempting to retrieve consensus commands, permanently halting block production.

The impact is catastrophic:
- **Operational Impact**: Complete blockchain halt - no new blocks can be produced
- **Network-Wide Scope**: Affects all network participants regardless of their behavior
- **Persistence**: The malicious Round remains in state, causing repeated crashes
- **Recovery Cost**: Requires coordinated manual intervention across all nodes to reset state

All miners become unable to produce blocks, users cannot submit transactions, and the entire chain freezes. The attack persists in storage, so the crash repeats on every consensus command retrieval attempt until the malicious Round data is manually removed from the contract state.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Capabilities**: The attacker must be an active miner, which is obtainable through the standard election process. Importantly, miners are NOT trusted roles in the AElf threat model - they are expected to be potentially malicious actors.

**Attack Complexity**: LOW - The attacker needs only to:
1. Craft a `NextRoundInput` message with Order values starting from an arbitrary number (e.g., 10) instead of 1
2. Set `ExpectedMiningTime` values with consistent intervals to satisfy time slot validation
3. Ensure `FinalOrderOfNextRound` values match `OutValue` counts to satisfy the mining order validation
4. Submit a single `NextRound` transaction

**Validation Bypass**: The validation pipeline includes `MiningPermissionValidationProvider`, `TimeSlotValidationProvider`, `NextRoundMiningOrderValidationProvider`, and `RoundTerminateValidationProvider` [16](#0-15) , but NONE of these validate that Order values are sequential starting from 1. The malicious input passes all validation checks.

**Economic Cost**: Minimal - the attack requires only being an elected miner and submitting a single malicious transaction.

**Detection**: Pre-execution detection is difficult because the malformed Round satisfies all validation rules. Post-execution detection is immediate (all nodes crash), but damage is already done as the malicious data is persisted in state.

## Recommendation

Add explicit validation in the consensus validation pipeline to ensure Order values are sequential starting from 1. Create a new validation provider:

```csharp
public class OrderSequentialityValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var providedRound = validationContext.ProvidedRound;
        var minersCount = providedRound.RealTimeMinersInformation.Count;
        
        // Check that all Order values from 1 to minersCount exist
        var orders = providedRound.RealTimeMinersInformation.Values
            .Select(m => m.Order)
            .OrderBy(o => o)
            .ToList();
        
        var expectedOrders = Enumerable.Range(1, minersCount).ToList();
        
        if (!orders.SequenceEqual(expectedOrders))
        {
            return new ValidationResult 
            { 
                Message = "Order values must be sequential starting from 1." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Register this provider in the validation pipeline for `NextRound` and `NextTerm` behaviors in `ValidateBeforeExecution()`.

Additionally, add defensive bounds checking in `GetMiningInterval()`:

```csharp
public int GetMiningInterval()
{
    if (RealTimeMinersInformation.Count == 1)
        return 4000;

    var firstTwoMiners = RealTimeMinersInformation.Values
        .Where(m => m.Order == 1 || m.Order == 2)
        .OrderBy(m => m.Order)
        .ToList();

    Assert(firstTwoMiners.Count >= 2, 
        "Round must contain miners with Order 1 and 2.");

    return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - 
        firstTwoMiners[0].ExpectedMiningTime).Milliseconds());
}
```

## Proof of Concept

```csharp
[Fact]
public async Task OrderValidation_MissingSequentialOrders_ShouldCauseConsensusCrash()
{
    // Arrange: Initialize consensus with valid first round
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Act: Craft malicious NextRoundInput with Order values starting from 10
    var maliciousRound = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            { initialMiners[0], new MinerInRound 
                { 
                    Pubkey = initialMiners[0], 
                    Order = 10, 
                    ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
                    OutValue = Hash.FromString("out1"),
                    FinalOrderOfNextRound = 1
                } 
            },
            { initialMiners[1], new MinerInRound 
                { 
                    Pubkey = initialMiners[1], 
                    Order = 11, 
                    ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(4)),
                    OutValue = Hash.FromString("out2"),
                    FinalOrderOfNextRound = 2
                } 
            },
            { initialMiners[2], new MinerInRound 
                { 
                    Pubkey = initialMiners[2], 
                    Order = 12, 
                    ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(8)),
                    OutValue = Hash.FromString("out3"),
                    FinalOrderOfNextRound = 3
                } 
            }
        },
        RandomNumber = ByteString.CopyFrom(GenerateRandomBytes())
    };
    
    // Submit malicious round - should pass validation
    var txResult = await ConsensusContractStub.NextRound.SendAsync(maliciousRound);
    txResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Assert: GetConsensusCommand should crash with ArgumentOutOfRangeException
    var exception = await Assert.ThrowsAsync<ArgumentOutOfRangeException>(
        async () => await ConsensusContractStub.GetConsensusCommand.CallAsync(
            new BytesValue { Value = ByteString.CopyFromUtf8(initialMiners[0]) }
        )
    );
    
    exception.Message.ShouldContain("Index was out of range");
}
```

This test demonstrates that a malicious miner can craft a `NextRoundInput` with non-sequential Order values (10, 11, 12 instead of 1, 2, 3), successfully submit it through all validation checks, and cause all subsequent `GetConsensusCommand` calls to crash with an `ArgumentOutOfRangeException`, effectively halting the blockchain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L28-37)
```csharp
        protected CommandStrategyBase(Round currentRound, string pubkey, Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;
            Pubkey = pubkey;
            CurrentBlockTime = currentBlockTime;
        }

        protected MinerInRound MinerInRound => CurrentRound.RealTimeMinersInformation[Pubkey];
        protected int Order => CurrentRound.GetMiningOrder(Pubkey);
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L38-38)
```csharp
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L34-38)
```csharp
                ? roundStartTime.AddMilliseconds(-MiningInterval)
                : CurrentRound.RoundNumber == 1
                    ? MinerInRound.ActualMiningTimes.First()
                    : MinerInRound.ExpectedMiningTime;
            var currentTimeSlotEndTime = currentTimeSlotStartTime.AddMilliseconds(MiningInterval);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L41-41)
```csharp
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-86)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```
