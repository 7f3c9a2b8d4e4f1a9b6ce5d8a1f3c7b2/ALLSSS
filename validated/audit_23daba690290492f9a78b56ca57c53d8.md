# Audit Report

## Title
Retroactive Vote Weight Inequality - Early Voters Maintain Inflated Weights After Interest Rate Changes

## Summary
The `SetVoteWeightInterest()` function modifies interest rates affecting vote weight calculations for new votes, but existing votes permanently retain their original weights stored in the profit contract. This creates unfair reward distribution where voters with identical parameters (amount, duration) receive different shares based solely on when they voted relative to interest rate changes.

## Finding Description

When governance calls `SetVoteWeightInterest()` to adjust interest rates, the function only updates the state variable without any mechanism to recalculate existing vote weights: [1](#0-0) 

Vote weights are calculated exactly once at vote creation using `GetVotesWeight()` with the current interest rates: [2](#0-1) 

This calculated weight is then permanently stored as "shares" in the CitizenWelfare profit scheme: [3](#0-2) 

Even when votes are extended via `ExtendVoterWelfareProfits()`, the shares remain unchanged. The `FixProfitDetail()` method in the Profit contract only clones the existing detail and updates period information: [4](#0-3) 

The cloned profit detail preserves the original shares value - there is no code path to update shares based on recalculated weights. The critical line shows the clone operation maintains all fields including the shares that should reflect updated interest rates: [5](#0-4) 

Profit distribution directly uses these frozen shares to calculate each voter's reward portion: [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability breaks the fundamental fairness invariant that equal voting parameters should yield equal voting power and rewards. The concrete impact includes:

**Direct Economic Harm:**
- User A votes 100 tokens for 365 days at high interest rates → receives weight of 200 shares
- Governance lowers interest rates via `SetVoteWeightInterest`
- User B votes 100 tokens for 365 days at new rates → receives weight of 150 shares
- User A permanently receives 200/(200+150) = 57.1% of rewards
- User B receives only 150/(200+150) = 42.9% of rewards
- **User A gets 33% more rewards despite identical voting parameters**

This disparity persists for the entire lock period (up to `MaximumLockTime`, potentially years). The only way to update weights is to withdraw after expiry and re-vote, or use `ChangeVotingOption` with `IsResetVotingTime=true`, which requires changing the vote target - an unrelated action that users may not want to perform.

The vulnerability systematically disadvantages new participants and violates protocol fairness guarantees.

## Likelihood Explanation

This vulnerability has high likelihood because:

**Triggering Conditions:**
- Requires only a legitimate governance action (`SetVoteWeightInterest`) which is expected for normal economic adjustments
- No special attacker capabilities needed beyond standard voting rights
- Works with any interest rate change (increase or decrease creates asymmetry)

**Exploit Scenarios:**

1. **Malicious Governance:** Insiders vote early to lock high rates, then lower rates to disadvantage competitors
2. **Front-Running:** Sophisticated voters monitor governance proposals and vote before rate decreases execute
3. **Natural Occurrence:** Legitimate rate adjustments automatically create unfair advantages for existing voters without any malicious intent

The weight disparity is not easily visible on-chain, making detection by affected users unlikely. The existing test suite does not validate behavior after interest rate changes, suggesting this scenario was not considered during development: [8](#0-7) 

## Recommendation

Implement a mechanism to allow voters to voluntarily update their vote weights after interest rate changes:

1. **Add `UpdateVoteWeight()` method** that recalculates weight using current interest rates and updates the corresponding profit detail shares
2. **Emit events on interest rate changes** to notify voters they can update
3. **Alternative:** Automatically recalculate all active vote weights when `SetVoteWeightInterest()` is called (may be gas-intensive)
4. **Minimum fix:** Document this behavior clearly and provide UI tools to help users detect when their weights are outdated

The fix should update the profit contract shares to match recalculated weights based on the voter's original amount and remaining lock time.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task VoteWeightInequalityAfterInterestRateChange()
{
    const long amount = 1000;
    const int lockTime = 365 * 60 * 60 * 24; // 365 days
    
    // User A votes with initial high interest rates
    var userAKeyPair = VoterKeyPairs[0];
    await VoteToCandidateAsync(userAKeyPair, 
        ValidationDataCenterKeyPairs[0].PublicKey.ToHex(), 
        lockTime, amount);
    
    var userAProfitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            Beneficiary = Address.FromPublicKey(userAKeyPair.PublicKey),
            SchemeId = ProfitItemsIds[ProfitType.CitizenWelfare]
        });
    var userAInitialShares = userAProfitDetail.Details[0].Shares;
    
    // Governance lowers interest rates
    var newSetting = new VoteWeightInterestList
    {
        VoteWeightInterestInfos =
        {
            new VoteWeightInterest { Day = 365, Interest = 1, Capital = 2000 }, // Lower rate
            new VoteWeightInterest { Day = 730, Interest = 15, Capital = 20000 },
            new VoteWeightInterest { Day = 1095, Interest = 2, Capital = 2000 }
        }
    };
    await ExecuteProposalForParliamentTransaction(ElectionContractAddress,
        nameof(ElectionContractStub.SetVoteWeightInterest), newSetting);
    
    // User B votes with same parameters but after rate change
    var userBKeyPair = VoterKeyPairs[1];
    await VoteToCandidateAsync(userBKeyPair,
        ValidationDataCenterKeyPairs[1].PublicKey.ToHex(),
        lockTime, amount);
    
    var userBProfitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            Beneficiary = Address.FromPublicKey(userBKeyPair.PublicKey),
            SchemeId = ProfitItemsIds[ProfitType.CitizenWelfare]
        });
    var userBShares = userBProfitDetail.Details[0].Shares;
    
    // Verify inequality: User A has higher shares despite identical voting parameters
    userAInitialShares.ShouldBeGreaterThan(userBShares);
    
    // Distribute profits and verify unfair distribution
    await NextTerm(InitialCoreDataCenterKeyPairs[0]);
    await NextTerm(InitialCoreDataCenterKeyPairs[0]);
    
    var userAProfits = await ProfitContractStub.GetProfitAmount.CallAsync(
        new GetProfitAmountInput
        {
            Beneficiary = Address.FromPublicKey(userAKeyPair.PublicKey),
            SchemeId = ProfitItemsIds[ProfitType.CitizenWelfare],
            Symbol = EconomicContractsTestConstants.NativeTokenSymbol
        });
    
    var userBProfits = await ProfitContractStub.GetProfitAmount.CallAsync(
        new GetProfitAmountInput
        {
            Beneficiary = Address.FromPublicKey(userBKeyPair.PublicKey),
            SchemeId = ProfitItemsIds[ProfitType.CitizenWelfare],
            Symbol = EconomicContractsTestConstants.NativeTokenSymbol
        });
    
    // User A receives disproportionately more rewards
    userAProfits.Value.ShouldBeGreaterThan(userBProfits.Value);
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1366-1381)
```csharp
    public async Task Election_VoteWeightInterestSetting_Test()
    {
        var defaultSetting = await ElectionContractStub.GetVoteWeightSetting.CallAsync(
            new Empty());
        defaultSetting.VoteWeightInterestInfos.Count.ShouldBe(3);
        defaultSetting.VoteWeightInterestInfos[0].Capital = 13200;
        defaultSetting.VoteWeightInterestInfos[0].Day = 50;

        await ExecuteProposalForParliamentTransaction(ElectionContractAddress,
            nameof(ElectionContractStub.SetVoteWeightInterest), defaultSetting);

        defaultSetting = await ElectionContractStub.GetVoteWeightSetting.CallAsync(
            new Empty());
        defaultSetting.VoteWeightInterestInfos[0].Capital.ShouldBe(13200);
        defaultSetting.VoteWeightInterestInfos[0].Day.ShouldBe(50);
    }
```
