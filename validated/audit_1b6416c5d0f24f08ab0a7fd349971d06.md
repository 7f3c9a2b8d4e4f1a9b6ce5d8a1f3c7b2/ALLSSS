# Audit Report

## Title
Two-Miner Consensus Deadlock: Malicious Miner Can Permanently Block Term Transitions

## Summary
In a two-miner network, a single malicious miner can permanently block term transitions by refusing to mine, creating an unrecoverable deadlock. The consensus mechanism requires both miners to have mined blocks before allowing term transition, but the attacker prevents this threshold from being met. This permanently freezes the miner list, blocks treasury distributions, and renders the blockchain governance ineffective.

## Finding Description

The vulnerability stems from the consensus term transition logic that requires a two-thirds majority of miners to have mined in the new period before transitioning terms.

**Root Cause:**

The `GetConsensusBehaviourToTerminateCurrentRound` method determines whether to use `NextRound` or `NextTerm` behavior based on `NeedToChangeTerm`: [1](#0-0) 

The `NeedToChangeTerm` method implements the consensus requirement by counting only miners who have `ActualMiningTimes`: [2](#0-1) 

The critical flaw is in `MinersCountOfConsent` calculation for a two-miner network: [3](#0-2) 

For 2 miners: `2 * 2 / 3 + 1 = 1 + 1 = 2` (integer division), requiring BOTH miners.

**Attack Mechanism:**

When a malicious miner refuses to mine:
- Line 219 filters: `.Where(m => m.ActualMiningTimes.Any())` excludes the non-mining attacker
- Only 1 miner passes the filter
- Count (1) < MinersCountOfConsent (2)
- `NeedToChangeTerm` returns false
- System uses `NextRound` instead of `NextTerm`

**Why Protections Fail:**

After 4320 missed slots, evil miners are detected during `ProcessNextRound`: [4](#0-3) [5](#0-4) [6](#0-5) 

However, marking as evil only updates the Election contract - it does NOT remove the miner from the active consensus list.

The active miner list is ONLY updated during term transitions in `ProcessNextTerm`: [7](#0-6) 

**Miner Replacement Cannot Break Deadlock:**

The system attempts mid-term miner replacement through `GetMinerReplacementInformation`: [8](#0-7) [9](#0-8) 

In a two-miner network where both miners are initial miners:
- Alternative candidates from election: None (filters exclude current miners at line 374)
- Alternative candidates from initial miners: None (filters exclude current miners at line 390)
- Result: `AlternativeCandidatePubkeys.Count = 0`
- Line 309 check fails, replacement never occurs

**Governance Cannot Recover:**

The `RemoveEvilNode` governance method also cannot break the deadlock: [10](#0-9) 

This only calls `UpdateCandidateInformation` which updates Election contract state, not the active consensus miner list.

**Unbreakable Circular Dependency:**
1. To remove evil miner from active list → need term transition (`ProcessNextTerm`)
2. To trigger term transition → need `NextTerm` behavior
3. To get `NextTerm` → need `NeedToChangeTerm = true`
4. To satisfy `NeedToChangeTerm` → need both miners to have mined
5. But attacker refuses to mine → **deadlock**

## Impact Explanation

This vulnerability creates **permanent, unrecoverable protocol failure** with the following critical impacts:

**Consensus Availability Failure:**
- Term transitions are permanently blocked
- The system freezes at the current term indefinitely
- No mechanism exists to recover without hard fork intervention

**Economic Impact:**
- Treasury distributions halt (only occur during term transitions per lines 203-211 of ProcessNextTerm)
- Mining rewards cannot be donated to Treasury
- Token holders receive no profit distributions

**Governance Paralysis:**
- Election results cannot be applied (miner list updates only happen in ProcessNextTerm)
- New miners cannot join despite winning elections
- Evil miners cannot be removed from active consensus
- Protocol cannot adapt to changing conditions

**Network Control:**
- The malicious miner maintains their position indefinitely
- Effectively achieves permanent 50% control over block production
- Prevents legitimate miners from joining

This is CRITICAL severity because it permanently breaks the consensus mechanism's availability and governance with no in-protocol recovery path.

## Likelihood Explanation

**High likelihood** in two-miner network scenarios due to:

**Low Attack Barrier:**
- Requires control of only 1 of 2 miners (50% threshold)
- No special technical capabilities needed
- Trivial execution: simply stop mining at period boundary
- Zero transaction costs
- Passive attack - just refuse to participate

**Realistic Deployment Scenarios:**
- Early-stage sidechains during bootstrap
- Test networks with minimal miners  
- Small private chains
- Development/staging environments
- Period boundaries occur every 7 days (604800 seconds default)

**Economic Incentive:**
- Attacker maintains their miner position indefinitely
- Prevents competitors from joining via elections
- Zero cost to maintain attack
- High benefit: permanent control over 50% of block production and rewards

**Detection Difficulty:**
- Initially appears as normal network issues or miner downtime
- By the time deadlock is recognized (3+ days after marking as evil), recovery requires hard fork
- No in-protocol detection mechanism for this specific deadlock scenario

**Attack Rationality:**
- Economically rational: maintain privileged position at zero cost
- Strategically beneficial: block competition from new miners
- Risk-free: no penalty for refusing to mine beyond detection (which doesn't resolve the issue)

## Recommendation

Implement one or more of the following fixes:

**Option 1: Modify Term Transition Logic for Small Networks**
Add special handling when miner count is critically low (e.g., ≤ 3):
- Reduce `MinersCountOfConsent` threshold for 2-miner networks to 1 (allowing term transition with single honest miner)
- Or use simple majority instead of two-thirds for small networks

**Option 2: Enable Forceful Miner Replacement**
Allow `RemoveEvilNode` to directly update the consensus miner list:
- Modify `RemoveEvilNode` to call both Election contract update AND consensus miner list update
- Add governance method to force term transition when evil miners are detected

**Option 3: Implement Automatic Recovery Mechanism**
Add timeout-based term transition:
- If `NeedToChangeTerm` fails for N consecutive rounds, force term transition
- Automatically exclude miners with excessive `MissedTimeSlots` from `MinersCountOfConsent` calculation

**Option 4: Miner List Update Without Term Transition**
Allow miner replacement to update `State.MainChainCurrentMinerList.Value` during `NextRound`:
- Modify `SetMinerList` to accept replacement flag
- Update active miner list when evil miner replacement occurs in `GenerateNextRoundInformation`

**Recommended Approach:**
Combine Options 1 and 2 for defense in depth:
- Adjust consensus threshold for small networks
- Enable governance-driven recovery via forceful miner list update

## Proof of Concept

```csharp
// Test demonstrating the deadlock scenario
public async Task TwoMinerDeadlock_CannotTransitionTerm()
{
    // Setup: 2-miner network at term boundary
    var miners = new[] { "MinerA", "MinerB" };
    
    // MinerA mines honestly, MinerB refuses to mine
    // Simulate period boundary reached (7 days passed)
    
    // Step 1: Check NeedToChangeTerm
    // Only MinerA has ActualMiningTimes in new period
    // MinersCountOfConsent = 2
    // Count of miners who mined = 1
    // Result: NeedToChangeTerm returns false
    
    // Step 2: Verify NextRound behavior used instead of NextTerm
    var behaviour = GetConsensusBehaviourToTerminateCurrentRound();
    Assert.Equal(AElfConsensusBehaviour.NextRound, behaviour);
    
    // Step 3: After 4320 rounds (3 days), MinerB detected as evil
    // But miner list is NOT updated
    
    // Step 4: Verify no alternative candidates exist
    var replacementInfo = GetMinerReplacementInformation(miners);
    Assert.Equal(1, replacementInfo.EvilMinerPubkeys.Count);
    Assert.Equal(0, replacementInfo.AlternativeCandidatePubkeys.Count);
    
    // Step 5: Confirm deadlock - term transition never occurs
    // System stuck in NextRound loop indefinitely
    // MinerB remains in active miner list forever
}
```

## Notes

This vulnerability is specific to networks with very small miner counts where the two-thirds consensus threshold creates problematic edge cases. The core issue is the disconnect between evil miner detection (which updates Election contract) and active miner list management (which only occurs during term transitions). The `NeedToChangeTerm` filter on `ActualMiningTimes.Any()` combined with the integer division in `MinersCountOfConsent` creates the mathematical condition where a single non-participating miner can block consensus indefinitely in a two-miner network.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-342)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-350)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
```
