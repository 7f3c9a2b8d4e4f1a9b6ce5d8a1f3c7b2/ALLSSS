# Audit Report

## Title
Dictionary Access Vulnerability in Consensus Block Production Causes Consensus Disruption via Miner Pubkey Replacement Race Condition

## Summary
The AEDPoS consensus contract contains unprotected dictionary accesses to `RealTimeMinersInformation` during block production. When a candidate admin replaces an active miner's pubkey via `ReplaceCandidatePubkey`, the consensus contract removes the old pubkey from the current round information. When that miner attempts to produce their next block, the code directly accesses the dictionary without checking key existence, causing a `KeyNotFoundException` that prevents block production and disrupts consensus availability.

## Finding Description

The vulnerability exists in multiple block production code paths that lack defensive key existence checks before accessing the `RealTimeMinersInformation` dictionary.

**Primary vulnerable location in `GetConsensusExtraDataToPublishOutValue`:** [1](#0-0) 

These lines directly access `currentRound.RealTimeMinersInformation[pubkey]` three times without verifying the key exists. The only validation is an empty pubkey check, which doesn't protect against missing keys.

**Attack mechanism via pubkey replacement:**

The Election Contract allows candidate admins to replace miner pubkeys: [2](#0-1) 

This triggers `RecordCandidateReplacement` in the consensus contract, which removes the old pubkey from the current round: [3](#0-2) 

Critically, line 142 removes the old pubkey from `RealTimeMinersInformation`, making it unavailable for subsequent dictionary accesses.

**Additional vulnerable locations:**

The same unprotected dictionary access pattern exists in `GetConsensusExtraDataForTinyBlock`: [4](#0-3) 

`GetUpdateValueRound`: [5](#0-4) 

`GetTinyBlockRound`: [6](#0-5) 

**Evidence of coding oversight - inconsistent defensive checks:**

The `NextRound` behavior HAS proper key existence validation: [7](#0-6) 

The `NextTerm` behavior also has defensive checks: [8](#0-7) 

This inconsistency between code paths proves the missing checks in UpdateValue and TinyBlock behaviors are unintentional oversights.

**Race condition window:**

Block production involves two separate phases. First, `GetConsensusCommand` validates the miner is in the current round: [9](#0-8) 

Later, `GetConsensusExtraData` is called to generate block header data: [10](#0-9) 

Between these calls, a `ReplaceCandidatePubkey` transaction can execute in another miner's block, removing the target pubkey from the round information. When the affected miner subsequently calls `GetConsensusExtraData`, the unprotected dictionary access causes a `KeyNotFoundException`.

## Impact Explanation

**Consensus Disruption**: When a miner's block production fails with `KeyNotFoundException`, that time slot is lost. The miner cannot produce their scheduled block, breaking the expected block production cadence and forcing the consensus mechanism to reschedule mining for that node.

**Availability Attack**: While the chain continues with other miners (AEDPoS has mechanisms to handle missed time slots), repeated exploitation can systematically disrupt consensus availability. An attacker controlling multiple candidate admin roles could coordinate replacements to affect multiple miners, significantly degrading network performance and transaction confirmation times.

**Affected Parties**:
- All blockchain users experience transaction confirmation delays
- Miners lose their block rewards for missed slots  
- DApps depending on predictable block times experience failures
- Network availability is compromised

**Severity Justification**: This violates the consensus invariant of "miner schedule integrity" and enables operational DoS of the consensus mechanism. The ability to prevent block production on-demand qualifies this as High severity, as it directly threatens consensus availability.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must control a candidate admin role. Candidate admins are set when candidates announce election and are NOT part of the core trusted set: [11](#0-10) 

Any candidate can set their own admin during election announcement, making this a non-privileged role.

**Attack Complexity**: The attack is straightforward:
1. Monitor when target miner receives their mining command (observable on-chain via consensus state)
2. Submit `ReplaceCandidatePubkey` transaction timed to execute before the miner produces their block
3. The miner's block production fails when accessing the removed pubkey

**Feasibility Conditions**:
- No rate limiting on `ReplaceCandidatePubkey` calls
- Transaction can be included in any block before the target miner's time slot
- The race window is predictable from public consensus information
- Multiple candidate admins could coordinate to affect multiple miners

**Probability Assessment**: MEDIUM-HIGH. Candidate admins have legitimate access to this functionality, the timing window is predictable from public consensus state, and the attack is repeatable with no built-in protections.

## Recommendation

Add defensive key existence checks before accessing `RealTimeMinersInformation` dictionary in the vulnerable code paths, consistent with the protection already implemented in `NextRound` and `NextTerm` behaviors:

**For `GetConsensusExtraDataToPublishOutValue`:**
```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
    string pubkey, AElfConsensusTriggerInformation triggerInformation)
{
    // Add defensive check
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // Return early or handle gracefully - miner was replaced
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = currentRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
    
    // Existing logic continues...
    currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = ...
```

**For `GetUpdateValueRound` and `GetTinyBlockRound`:**
```csharp
public Round GetUpdateValueRound(string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey))
        return new Round { RoundNumber = RoundNumber, RoundIdForValidation = RoundId };
        
    var minerInRound = RealTimeMinersInformation[pubkey];
    // Rest of existing logic...
}
```

Apply similar checks to `GetConsensusExtraDataForTinyBlock` to maintain consistency across all block production code paths.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_CausesBlockProductionFailure()
{
    // Setup: Initialize consensus with active miner
    var minerKeyPair = SampleECKeyPairs.KeyPairs[0];
    var minerPubkey = minerKeyPair.PublicKey.ToHex();
    var candidateAdmin = Accounts[5].Address;
    
    // Miner announces election and sets admin
    await ElectionContractStub.AnnounceElection.SendAsync(candidateAdmin);
    
    // Miner becomes active in current round
    await BootMinerAndInitialize();
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.True(currentRound.RealTimeMinersInformation.ContainsKey(minerPubkey));
    
    // Miner receives consensus command successfully
    var command = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        ByteStringHelper.FromHexString(minerPubkey).ToBytesValue());
    Assert.True(command.CountingMilliseconds > 0);
    
    // Attacker (as candidate admin) replaces pubkey
    var newKeyPair = CryptoHelper.GenerateKeyPair();
    var newPubkey = newKeyPair.PublicKey.ToHex();
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerPubkey,
        NewPubkey = newPubkey
    });
    
    // Verify old pubkey removed from current round
    currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.False(currentRound.RealTimeMinersInformation.ContainsKey(minerPubkey));
    
    // Miner attempts to produce block - THIS WILL THROW KeyNotFoundException
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        InValue = HashHelper.ComputeFrom("test")
    };
    
    // This call will fail with KeyNotFoundException due to unprotected dictionary access
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggerInfo.ToBytesValue());
    });
    
    Assert.Contains("KeyNotFoundException", exception.Message);
}
```

## Notes

The vulnerability is confirmed through code inspection showing unprotected dictionary accesses in critical consensus paths. The inconsistency with defensive checks in `NextRound` and `NextTerm` behaviors provides strong evidence this is an unintentional oversight rather than a design decision. While the impact characterization of "chain halt" might be slightly overstated (the chain continues with other miners via AEDPoS missed slot handling), the core vulnerability enables a repeatable DoS attack on individual miners that degrades consensus availability, justifying High severity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-63)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L155-163)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForTinyBlock(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L211-212)
```csharp
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-13)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-60)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-103)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
```
