# Audit Report

## Title
Missing Order Uniqueness Validation Allows Consensus Timing Disruption via Duplicate Miner Orders

## Summary
The AEDPoS consensus contract fails to validate Order field uniqueness when storing Round information via `NextRound` transactions. A malicious miner can submit a `NextRoundInput` with duplicate Order values (e.g., all miners with Order = 1), bypassing time slot validation and causing incorrect extra block timing calculations that disrupt consensus progression.

## Finding Description

The vulnerability exists in the Round validation logic. The `GetExtraBlockMiningTime()` method relies on `OrderBy(m => m.Value.Order).Last()` to identify when the extra block should be produced [1](#0-0) . When multiple miners share the same Order value, `.Last()` returns an arbitrary miner based on dictionary enumeration order rather than the intended last miner in the mining sequence.

Similarly, `GetMiningInterval()` expects miners with Order = 1 and Order = 2 [2](#0-1) , but with duplicate orders (all Order = 1), it would select two arbitrary miners from the dictionary, calculating an incorrect mining interval.

**Root Cause:**

When a miner calls `NextRound`, the input is processed via `ProcessNextRound` [3](#0-2) , which converts `NextRoundInput` to `Round` via `ToRound()` [4](#0-3) . The Round is then stored without Order uniqueness validation [5](#0-4) .

The validation performed by `ValidateConsensusBeforeExecution` [6](#0-5)  uses `TimeSlotValidationProvider` for NextRound behavior [7](#0-6) , which calls `CheckRoundTimeSlots()` [8](#0-7) .

However, `CheckRoundTimeSlots()` only validates time slot intervals, NOT Order uniqueness [9](#0-8) . A malicious round with all miners having Order = 1 would pass validation if `ExpectedMiningTime` values are properly distributed.

Additionally, `NextRoundMiningOrderValidationProvider` only validates `FinalOrderOfNextRound` field distinctness [10](#0-9) , not the actual `Order` field in the stored Round.

## Impact Explanation

**Consensus Timing Disruption:**
- Extra block time calculated incorrectly via `GetExtraBlockMiningTime()`, potentially scheduling it at an arbitrary wrong time
- Mining interval calculated from two arbitrary miners instead of intended Order=1 and Order=2 miners
- `BreakContinuousMining()` logic fails when trying to find miner with `Order == minersCount` [11](#0-10) , returning null and skipping critical continuous mining prevention
- `ArrangeAbnormalMiningTime()` uses both `GetExtraBlockMiningTime()` and `GetMiningInterval()` [12](#0-11) , causing incorrect abnormal mining time calculations
- `IsCurrentMiner()` checks against wrong extra block time [13](#0-12) 

**Protocol Impact:**
- Consensus round progression disrupted
- Extra block producer unable to produce at correct time
- Potential chain stalls or validation failures
- Future rounds generated with incorrect timing via `GenerateNextRoundInformation()` [14](#0-13) 

**Severity:** Medium - Requires miner authority but causes operational consensus disruption without direct fund theft. Consensus timing integrity is a critical protocol invariant.

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner, verified in `PreCheck()` [15](#0-14) 

**Attack Complexity:**
- Low complexity - Miner crafts `NextRoundInput` with duplicate Order values (e.g., all Order = 1)
- Ensures `ExpectedMiningTime` values are properly spaced to pass `CheckRoundTimeSlots()` time interval validation
- Submits via `NextRound` transaction [16](#0-15)  during their designated turn

**Feasibility:**
- Miners rotate as extra block producers, giving each authorized miner opportunities to submit malicious rounds
- No economic cost or detection mechanism prevents this attack
- Round structure not validated against expected generation patterns

**Probability:** Medium - Limited to miners but straightforward execution with operational impact.

## Recommendation

Add Order uniqueness validation in `CheckRoundTimeSlots()` or create a dedicated validation provider:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // NEW: Validate Order uniqueness
    var distinctOrders = miners.Select(m => m.Order).Distinct().Count();
    if (distinctOrders != miners.Count)
        return new ValidationResult { Message = "Duplicate Order values detected in round information." };

    var baseMiningInterval = (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
    
    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval = (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Additionally, validate that Order values form a contiguous sequence from 1 to `minersCount`:

```csharp
// Validate Order sequence
var expectedOrders = Enumerable.Range(1, miners.Count).ToList();
var actualOrders = miners.Select(m => m.Order).OrderBy(o => o).ToList();
if (!expectedOrders.SequenceEqual(actualOrders))
    return new ValidationResult { Message = "Order values must form contiguous sequence from 1 to miners count." };
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateOrdersPassValidation_CausesIncorrectExtraBlockTime()
{
    // Setup: Initialize consensus with 5 miners
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Attack: Craft malicious NextRoundInput with duplicate Orders
    var maliciousRound = new Round
    {
        RoundNumber = 2,
        RealTimeMinersInformation = {}
    };
    
    var baseTime = TimestampHelper.GetUtcNow();
    var miningInterval = 4000;
    
    // All miners have Order = 1, but different ExpectedMiningTime
    for (int i = 0; i < miners.Count; i++)
    {
        maliciousRound.RealTimeMinersInformation[miners[i]] = new MinerInRound
        {
            Pubkey = miners[i],
            Order = 1, // DUPLICATE ORDER!
            ExpectedMiningTime = baseTime.AddMilliseconds(miningInterval * i)
        };
    }
    
    // Verify: CheckRoundTimeSlots passes (only validates time intervals)
    var validationResult = maliciousRound.CheckRoundTimeSlots();
    Assert.True(validationResult.Success); // Passes despite duplicate Orders
    
    // Impact: GetExtraBlockMiningTime returns arbitrary result
    var extraBlockTime = maliciousRound.GetExtraBlockMiningTime();
    // Should be baseTime + (5 * 4000) + 4000 for Order=5 miner
    // But returns arbitrary time based on dictionary enumeration
    
    // Impact: GetMiningInterval gets wrong interval
    var interval = maliciousRound.GetMiningInterval();
    // Returns interval between two arbitrary Order=1 miners instead of Order 1->2
    
    // Submit malicious round via NextRound
    var nextRoundInput = NextRoundInput.Create(maliciousRound, GenerateRandomNumber());
    await ConsensusContract.NextRound.SendAsync(nextRoundInput);
    
    // Consensus timing is now disrupted
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-77)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L71-71)
```csharp
            new TimeSlotValidationProvider(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L93-95)
```csharp
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L22-30)
```csharp
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L173-174)
```csharp
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
