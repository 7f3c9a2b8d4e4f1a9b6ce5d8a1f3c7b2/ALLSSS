# Audit Report

## Title
Time-of-Check-Time-of-Use Vulnerability in Proposal Rejection Count Allows Governance Bypass Through Member Manipulation

## Summary
The Association contract's rejection validation mechanism contains a critical TOCTOU vulnerability that allows attackers to retroactively invalidate legitimate proposal rejections by removing rejecting members between voting and release, enabling execution of proposals that were explicitly rejected by the organization.

## Finding Description

The vulnerability exists in the rejection validation logic during proposal release. When organization members cast rejection votes, their addresses are stored in the proposal's rejection list. [1](#0-0)  However, when the proposal is later released, the rejection count is recalculated by filtering this list against the **current** organization membership rather than the membership at voting time.

The critical flaw occurs in the `IsProposalRejected` function, which calculates rejection counts using `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)`. [2](#0-1)  This queries the current state of the organization's member list [3](#0-2)  rather than capturing a snapshot at voting time.

Organization membership can be modified through the `RemoveMember` function, which is callable only by the organization itself via proposal execution. [4](#0-3)  The validation function permits member removal as long as threshold constraints are satisfied. [5](#0-4) 

This creates a TOCTOU race condition:
1. Proposal P1 receives sufficient rejections to be rejected (e.g., 4 rejections when MaximalRejectionThreshold=3)
2. A separate proposal P2 is approved to remove one or more rejecting members
3. When P1 is later released, its rejection validation recalculates using the modified membership
4. With fewer valid rejecting members, P1 may no longer exceed the rejection threshold and executes

The vulnerability is enforced during the `Release` function, which calls `IsReleaseThresholdReached` [6](#0-5) , which in turn calls `IsProposalRejected`. [7](#0-6) 

There are no protections against membership changes after voting has occurred, no snapshot mechanism to preserve voting-time membership, and no locks preventing member removal for proposals with active votes.

## Impact Explanation

This vulnerability has **CRITICAL** severity as it violates the fundamental governance invariant that rejection decisions must be final and immutable.

**Concrete Attack Scenario:**
- Organization with 7 members [A,B,C,D,E,F,G]
- Thresholds: MinimalApprovalThreshold=3, MaximalRejectionThreshold=3
- Attacker controls members A, B, C (sufficient to approve proposals)
- Malicious Proposal P1 is created and receives 4 rejections (D,E,F,G) and 3 approvals (A,B,C)
- P1 is correctly rejected since 4 > 3
- Attacker creates Proposal P2 to remove member D, which receives 3 approvals and executes
- Organization validation passes: 3 + 3 <= 6 members remaining
- When P1 is released, rejection count recalculates to 3 (only E,F,G remain as members)
- Since 3 is NOT > 3, P1 is no longer rejected and executes

**Impact Consequences:**
- **Governance Bypass**: Proposals explicitly rejected by the organization can be executed
- **Fund Theft**: Rejected proposals draining treasury funds can be retroactively approved
- **Unauthorized Actions**: Malicious contract calls, parameter changes, or system modifications that were rejected can be executed
- **Multi-signature Violation**: Defeats the purpose of multi-signature governance requiring consensus

## Likelihood Explanation

The attack has **HIGH** likelihood:

**Attacker Requirements:**
- Control of MinimalApprovalThreshold members to pass removal proposals
- No special privileges beyond normal voting rights
- No exploitation of implementation bugs

**Attack Feasibility:**
- Uses only standard governance operations (Reject, Approve, RemoveMember, Release)
- Member removals appear legitimate and may have valid governance justifications
- Organizations with dynamic membership naturally exhibit this vulnerability
- Long proposal expiration windows provide extended attack opportunities

**Detection Difficulty:**
- All operations use legitimate governance mechanisms
- Member removals may occur for valid organizational reasons unrelated to vote manipulation
- No anomalous transaction patterns to detect
- Attack can be executed over extended time periods to avoid suspicion

## Recommendation

Implement one of the following fixes:

**Option 1: Snapshot-based Validation (Recommended)**
Store the organization's member count and rejection threshold at proposal creation time. During release, validate against these snapshot values rather than recalculating from current membership:

```csharp
// In ProposalInfo, add:
public int MemberCountAtCreation { get; set; }

// In CreateNewProposal:
proposal.MemberCountAtCreation = organization.OrganizationMemberList.Count();

// In IsProposalRejected, replace with:
var actualRejectionCount = proposal.Rejections.Count;
return actualRejectionCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**Option 2: Vote Lock Mechanism**
Prevent member removal if they have cast votes on any active (non-expired) proposals.

**Option 3: Rejection Count Storage**
Store the rejection count as an integer rather than an address list, incrementing it immutably when members vote.

## Proof of Concept

```csharp
[Fact]
public async Task TOCTOU_Vulnerability_Proof()
{
    // Setup: Create organization with 7 members, thresholds: MinimalApproval=3, MaximalRejection=3
    var members = new[] { MemberA, MemberB, MemberC, MemberD, MemberE, MemberF, MemberG };
    var org = await CreateOrganizationAsync(members, minApproval: 3, maxRejection: 3);
    
    // Step 1: Create malicious proposal P1
    var p1 = await CreateProposalAsync(org, maliciousAction);
    
    // Step 2: Get rejections from D, E, F, G (4 rejections > 3 threshold)
    await RejectAsync(p1, MemberD);
    await RejectAsync(p1, MemberE);
    await RejectAsync(p1, MemberF);
    await RejectAsync(p1, MemberG);
    
    // Step 3: Get approvals from A, B, C
    await ApproveAsync(p1, MemberA);
    await ApproveAsync(p1, MemberB);
    await ApproveAsync(p1, MemberC);
    
    // Verify P1 is correctly rejected at this point
    var status1 = await GetProposalAsync(p1);
    Assert.False(status1.ToBeReleased); // 4 rejections > 3 threshold
    
    // Step 4: Create and execute proposal P2 to remove member D
    var p2 = await CreateProposalAsync(org, RemoveMemberAction(MemberD));
    await ApproveAsync(p2, MemberA);
    await ApproveAsync(p2, MemberB);
    await ApproveAsync(p2, MemberC);
    await ReleaseAsync(p2); // Removes MemberD from organization
    
    // Step 5: Attempt to release P1 - VULNERABILITY: This should fail but succeeds
    var status2 = await GetProposalAsync(p1);
    Assert.True(status2.ToBeReleased); // BUG: Only 3 rejections count now (E,F,G)
    
    // P1 executes despite being legitimately rejected
    var result = await ReleaseAsync(p1);
    Assert.True(result.Success); // CRITICAL: Rejected proposal executed!
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L150-150)
```csharp
        proposal.Rejections.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L26-26)
```csharp
        var isRejected = IsProposalRejected(proposal, organization);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L79-80)
```csharp
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
