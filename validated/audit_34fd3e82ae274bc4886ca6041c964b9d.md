# Audit Report

## Title
Parliament Organization Governance Lock via Impossible Threshold Configuration

## Summary
The `ChangeOrganizationThreshold()` function validates new voting thresholds only against the constant `AbstractVoteTotal` (10,000) without verifying they are achievable given the actual parliament member count. This allows setting mathematically valid but practically impossible thresholds that permanently lock the organization's governance, as no future proposal can reach consensusâ€”including proposals to restore reasonable thresholds.

## Finding Description

The vulnerability exists in the Parliament contract's threshold change mechanism. When an organization updates its governance thresholds via `ChangeOrganizationThreshold()`, the validation only ensures mathematical consistency with `AbstractVoteTotal` but never checks if thresholds are achievable given the actual member count. [1](#0-0) 

The `Validate()` helper function only verifies that threshold values satisfy arithmetic constraints relative to the constant 10,000, without any comparison to the actual parliament member count retrieved from the consensus contract: [2](#0-1) 

An attacker can set extreme but validation-passing thresholds:
- `MinimalApprovalThreshold = 10000` (requires 100% approval)
- `MinimalVoteThreshold = 10000` (requires 100% participation)  
- `MaximalRejectionThreshold = 0` (any single rejection blocks)
- `MaximalAbstentionThreshold = 0` (any single abstention blocks)

These values pass all validation checks but create impossible governance conditions in the proposal approval logic. The rejection check formula makes ANY single rejection block the proposal: [3](#0-2) 

The abstention check formula makes ANY single abstention block the proposal: [4](#0-3) 

The approval check requires ALL members to approve: [5](#0-4) 

With these formulas and extreme thresholds, achieving unanimous approval while tolerating zero dissent is practically impossible. Since changing thresholds requires passing a proposal under the current thresholds, the organization becomes permanently locked. [6](#0-5) 

The constant `AbstractVoteTotal` is defined as 10,000 (representing 100%): [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

The impact is a complete and permanent governance denial-of-service:

1. **Immediate paralysis**: After the malicious threshold change, no proposals can pass, blocking critical system upgrades, parameter adjustments, or emergency responses.

2. **No recovery path**: Restoring reasonable thresholds requires passing a proposal, but that proposal itself needs unanimous approval under the impossible thresholds. If any single member is unavailable, compromised, or disagrees, recovery is impossible.

3. **Cascading failure**: If this affects the default Parliament organization (initialized during contract deployment and used to govern core AElf system contracts), the entire blockchain's governance becomes paralyzed: [8](#0-7) 

4. **Widespread impact**: All organization members lose governance capabilities, and any systems depending on that organization's decisions are affected.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

The attack is feasible because:

1. **Low technical barrier**: Requires only creating and passing a single malicious proposal with carefully crafted threshold values. No complex transaction sequences or reentrancy exploitation needed.

2. **Social engineering vector**: The malicious proposal can be framed as "security hardening" (e.g., "requiring unanimous approval for critical decisions"), making it appear legitimate to voters.

3. **Realistic preconditions**: 
   - Attacker needs proposal creation rights (available to parliament members or whitelisted proposers per the authorization logic)
   - Must achieve approval under CURRENT thresholds (e.g., 66.67% in default configuration)
   - More likely in smaller organizations or during governance transitions

4. **Accidental trigger**: Beyond malicious intent, honest misconfigurations when setting thresholds could accidentally create impossible conditions, especially if operators don't understand the approval formula mechanics.

5. **No detection**: There is no automatic detection of impossible threshold configurations, and the impact only becomes evident when the next proposal fails.

## Recommendation

Add validation in the `Validate()` function to check that thresholds are achievable given the actual parliament member count. Query the current member list and ensure:

1. `MinimalApprovalThreshold` allows at least one member to be absent/reject
2. `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` allow realistic dissent levels
3. The combination of all thresholds permits at least one feasible voting outcome

Example fix:
```csharp
private bool Validate(Organization organization)
{
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Existing mathematical checks
    var mathValid = proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    
    if (!mathValid) return false;
    
    // NEW: Check against actual member count
    var memberCount = GetCurrentMinerList().Count;
    if (memberCount == 0) return false;
    
    // Ensure at least one feasible voting outcome exists
    // MinimalApproval should not require more than (memberCount - 1) votes
    // to allow for at least one absent member
    var maxFeasibleApproval = (memberCount - 1) * AbstractVoteTotal;
    if (proposalReleaseThreshold.MinimalApprovalThreshold * memberCount > maxFeasibleApproval)
        return false;
    
    // Ensure MaximalRejection allows at least some dissent
    var minAllowedRejection = AbstractVoteTotal; // Allow at least 1 rejection (1/N * 10000)
    if (proposalReleaseThreshold.MaximalRejectionThreshold * memberCount < minAllowedRejection)
        return false;
        
    // Similar check for abstentions
    if (proposalReleaseThreshold.MaximalAbstentionThreshold * memberCount < minAllowedRejection)
        return false;
    
    return true;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task GovernanceLock_Via_Impossible_Thresholds_Test()
{
    // Step 1: Create organization with normal thresholds (66.67% approval, allows dissent)
    var normalOrganization = await CreateOrganizationAsync(
        minimalApprovalThreshold: 6667,
        maximalAbstentionThreshold: 2000, 
        maximalRejectionThreshold: 2000,
        minimalVoteThreshold: 7500);
    
    // Step 2: Create proposal to change to impossible thresholds
    var impossibleThresholds = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 10000,  // Requires 100% approval
        MinimalVoteThreshold = 10000,      // Requires 100% participation
        MaximalRejectionThreshold = 0,     // ANY rejection blocks
        MaximalAbstentionThreshold = 0     // ANY abstention blocks
    };
    
    var changeThresholdProposal = await ParliamentContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            ContractMethodName = nameof(ParliamentContractStub.ChangeOrganizationThreshold),
            ToAddress = ParliamentContractAddress,
            Params = impossibleThresholds.ToByteString(),
            ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
            OrganizationAddress = normalOrganization
        });
    
    var proposalId = changeThresholdProposal.Output;
    
    // Step 3: Pass the threshold change under CURRENT thresholds (2 of 3 miners = 66.67%)
    await ApproveAsync(InitialMinersKeyPairs[0], proposalId);
    await ApproveAsync(InitialMinersKeyPairs[1], proposalId);
    
    // Release the malicious threshold change
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Verify thresholds were changed to impossible values
    var org = await ParliamentContractStub.GetOrganization.CallAsync(normalOrganization);
    org.ProposalReleaseThreshold.MinimalApprovalThreshold.ShouldBe(10000);
    org.ProposalReleaseThreshold.MaximalRejectionThreshold.ShouldBe(0);
    org.ProposalReleaseThreshold.MaximalAbstentionThreshold.ShouldBe(0);
    
    // Step 5: Attempt ANY new proposal - it will be impossible to pass
    var recoveryProposal = await CreateProposalAsync(DefaultSenderKeyPair, normalOrganization);
    
    // Even with 2 approvals and 1 rejection, proposal is blocked (ANY rejection blocks)
    await ApproveAsync(InitialMinersKeyPairs[0], recoveryProposal);
    await ApproveAsync(InitialMinersKeyPairs[1], recoveryProposal);
    await RejectionAsync(InitialMinersKeyPairs[2], recoveryProposal);
    
    var proposalInfo = await ParliamentContractStub.GetProposal.CallAsync(recoveryProposal);
    proposalInfo.ToBeReleased.ShouldBeFalse(); // Cannot pass due to 1 rejection
    
    // Step 6: Even with all approvals, if one member abstains, it's blocked
    var anotherProposal = await CreateProposalAsync(DefaultSenderKeyPair, normalOrganization);
    await ApproveAsync(InitialMinersKeyPairs[0], anotherProposal);
    await ApproveAsync(InitialMinersKeyPairs[1], anotherProposal);
    await AbstainAsync(InitialMinersKeyPairs[2], anotherProposal);
    
    var proposalInfo2 = await ParliamentContractStub.GetProposal.CallAsync(anotherProposal);
    proposalInfo2.ToBeReleased.ShouldBeFalse(); // Cannot pass due to 1 abstention
    
    // GOVERNANCE IS PERMANENTLY LOCKED - no proposal can pass
}
```

## Notes

This vulnerability affects all three governance contract types (Parliament, Association, Referendum) as they share similar validation logic. The same validation gap exists in Association and Referendum contracts, allowing the same attack vector across the entire AElf governance ecosystem.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L22-36)
```csharp
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```
