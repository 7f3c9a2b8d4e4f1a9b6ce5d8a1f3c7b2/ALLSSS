# Audit Report

## Title
Unauthorized Manager Assignment in CreateScheme Enables Unbounded List Growth DoS Attack

## Summary
The `CreateScheme` function in the Profit contract lacks authorization validation when accepting a manager parameter, allowing any attacker to create unlimited profit schemes with an arbitrary victim address as the manager. This causes unbounded growth of the victim's `ManagingSchemeIds` list, resulting in gas exhaustion DoS on critical operations like `ResetManager` and view function failures on `GetManagingSchemeIds`.

## Finding Description

The root cause is the absence of authorization validation in the `CreateScheme` function. The function accepts any address as the scheme manager without verifying that the caller has permission from the specified manager address. [1](#0-0) 

The manager parameter is either taken from the input or defaults to `Context.Sender`, but there is no check to ensure `Context.Sender` has authorization to assign schemes to `input.Manager` when it differs from the caller's address.

Each created scheme ID is unconditionally added to the manager's scheme list without any size limit validation. [2](#0-1) 

The only validation performed is a duplicate scheme ID check [3](#0-2) , which an attacker can trivially bypass by providing unique `Token` values in the input. When a token is provided, the scheme ID generation becomes deterministic based on that token. [4](#0-3) 

The protobuf definition confirms the `Token` parameter exists specifically for scheme ID generation. [5](#0-4) 

**Attack Execution Path:**
1. Attacker calls `CreateScheme` with `Manager = VictimAddress` and unique `Token` values
2. Each call generates a unique scheme ID via `GenerateSchemeId`
3. Each scheme ID is appended to `State.ManagingSchemeIds[VictimAddress]`
4. No maximum limit exists on list size (verified in ProfitContractConstants [6](#0-5) )
5. List grows unbounded until victim operations fail with gas exhaustion

## Impact Explanation

**Primary DoS - ResetManager Failure:**

The `ResetManager` function performs an O(n) `Remove` operation on the scheme ID list. [7](#0-6) 

With a protobuf repeated field [8](#0-7)  containing millions of entries, the `Remove` operation must scan the entire list to find and remove the target element. The subsequent state write operation will exceed gas limits, permanently preventing the victim from transferring management of their legitimate schemes.

**Secondary DoS - View Function Failure:**

The `GetManagingSchemeIds` view function returns the entire list without pagination. [9](#0-8) 

Large lists will exceed response size limits or timeout, preventing the victim from querying their schemes and breaking off-chain systems that rely on this data for profit distribution management.

**Tertiary DoS - Scheme Creation Degradation:**

Legitimate scheme creation by the victim becomes increasingly expensive due to read-modify-write operations on the inflated list, as seen in the scheme ID generation logic that reads the count. [10](#0-9) 

**Affected Parties:**
- System contracts (Treasury, TokenHolder) that manage profit schemes
- DApp developers who rely on profit distribution mechanisms
- Economic actors who need to manage profit scheme configurations

## Likelihood Explanation

**Attacker Capabilities:** Any user with a standard account can execute this attack. The CreateScheme function is publicly accessible [11](#0-10)  with no special permissions, staked tokens, or trusted role compromise required.

**Attack Complexity:** Trivial. The attacker simply calls `CreateScheme` in a loop with incrementing `Token` values, each generating a unique scheme ID for the victim address.

**Economic Feasibility:** The attack cost is `CreateScheme` gas cost Ã— number of schemes. To cause permanent DoS, approximately 10,000-100,000 schemes would suffice depending on gas limits, making this economically viable for targeted attacks against high-value system contracts.

**Detection:** While the attack leaves clear on-chain evidence (many schemes with the same manager from the same attacker address), by the time it's detected, the victim's list is already corrupted. No rate limiting or preventive mechanism exists in the codebase.

**Probability:** HIGH - The entry point is public, the vulnerability is straightforward to exploit, and there are no technical barriers to execution.

## Recommendation

Add authorization validation in the `CreateScheme` function to ensure only the manager address itself can be set as manager, unless explicitly authorized:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    // Add authorization check
    var manager = input.Manager ?? Context.Sender;
    if (input.Manager != null && input.Manager != Context.Sender)
    {
        Assert(false, "Cannot assign manager role to another address without authorization.");
    }
    
    // Rest of the function...
}
```

Additionally, consider implementing:
1. Maximum size limit on `ManagingSchemeIds` per manager
2. Rate limiting on scheme creation per address
3. Pagination support in `GetManagingSchemeIds` view function

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_UnauthorizedManagerAssignment_DoS_Test()
{
    var attacker = Creators[0];
    var victimAddress = Address.FromPublicKey(CreatorKeyPair[1].PublicKey);
    
    // Attacker creates 1000 schemes with victim as manager
    for (int i = 0; i < 1000; i++)
    {
        await attacker.CreateScheme.SendAsync(new CreateSchemeInput
        {
            Manager = victimAddress,
            Token = HashHelper.ComputeFrom(i),
            ProfitReceivingDuePeriodCount = 10
        });
    }
    
    // Verify victim's ManagingSchemeIds list is polluted
    var victimSchemes = await attacker.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = victimAddress });
    
    victimSchemes.SchemeIds.Count.ShouldBe(1000);
    
    // Demonstrate ResetManager will fail with gas exhaustion
    // (In production, this would exceed gas limits with sufficient entries)
    var victim = Creators[1];
    var firstSchemeId = victimSchemes.SchemeIds.First();
    
    // This operation becomes increasingly expensive as list grows
    var result = await victim.ResetManager.SendAsync(new ResetManagerInput
    {
        SchemeId = firstSchemeId,
        NewManager = Address.FromPublicKey(CreatorKeyPair[2].PublicKey)
    });
    
    // With millions of entries, this would fail with out-of-gas
}
```

## Notes

The vulnerability exists because the protocol assumes that only legitimate managers would create schemes for themselves. However, the lack of authorization check allows anyone to pollute another address's manager list, violating the invariant that a manager should only manage schemes they explicitly created or authorized. This is particularly critical for system contracts like Treasury and TokenHolder that rely on the Profit contract for reward distribution.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L57-57)
```csharp
        var manager = input.Manager ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L59-59)
```csharp
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L733-735)
```csharp
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L967-968)
```csharp
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L969-970)
```csharp
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
```

**File:** protobuf/profit_contract.proto (L18-20)
```text
    // Create a scheme for profit distribution, and return the created scheme id.
    rpc CreateScheme (CreateSchemeInput) returns (aelf.Hash) {
    }
```

**File:** protobuf/profit_contract.proto (L132-132)
```text
    aelf.Hash token = 6;
```

**File:** protobuf/profit_contract.proto (L288-291)
```text
message CreatedSchemeIds {
    // The scheme ids.
    repeated aelf.Hash scheme_ids = 1;
}
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L1-10)
```csharp
namespace AElf.Contracts.Profit;

public class ProfitContractConstants
{
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
}
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
