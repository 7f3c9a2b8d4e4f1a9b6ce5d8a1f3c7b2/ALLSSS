# Audit Report

## Title
LIB Height Deflation Attack via Malicious ImpliedIrreversibleBlockHeight Reporting

## Summary
The AEDPoS consensus contract fails to validate that miners report reasonable `ImpliedIrreversibleBlockHeight` values close to the current block height. Malicious miners can report artificially low values (e.g., 1) which pass validation, and with approximately one-third of miners colluding, they can prevent the Last Irreversible Block (LIB) from advancing, eliminating finality guarantees and disrupting cross-chain operations.

## Finding Description

The vulnerability exists in the LIB calculation and validation mechanism of the AEDPoS consensus system.

**Attack Flow:**

1. When honest miners produce blocks, they set `ImpliedIrreversibleBlockHeight = Context.CurrentHeight` during block production [1](#0-0) 

2. This value is packaged into `UpdateValueInput` [2](#0-1) 

3. During validation, `LibInformationValidationProvider` only checks that the new value does not decrease from the miner's previous report [3](#0-2) 

4. The value is directly assigned without any bounds checking [4](#0-3) 

5. The LIB is calculated by sorting all `ImpliedIrreversibleBlockHeight` values and selecting the value at index `(count - 1) / 3` [5](#0-4) 

**Exploitation:**

A malicious miner can modify their consensus node to report `ImpliedIrreversibleBlockHeight = 1` (or any low positive value) instead of `Context.CurrentHeight`. This passes validation because:
- It's not zero (filtered out by `GetSortedImpliedIrreversibleBlockHeights`) [6](#0-5) 
- It doesn't decrease from previous reports (satisfies the only validation check)
- There is no upper or lower bound validation

With approximately N/3 malicious miners (where N is the total miner count) reporting artificially low heights, the LIB calculation's selection at index `(N-1)/3` will pick one of these low values instead of a legitimate height.

**No Detection Mechanism:**

The evil miner detection logic only identifies miners who miss time slots, not those reporting incorrect LIB heights [7](#0-6) 

## Impact Explanation

This vulnerability has **HIGH** impact because it breaks fundamental consensus integrity guarantees:

1. **Finality Loss**: The LIB (Last Irreversible Block) is the foundation of transaction finality in AElf. An artificially low LIB means blocks above that height remain reversible indefinitely, eliminating finality guarantees that users and applications depend on.

2. **Cross-Chain Disruption**: Cross-chain operations rely on LIB heights for verification and indexing. An artificially low LIB renders cross-chain bridges and parent-child chain communications inoperable.

3. **Reorganization Risk**: A low LIB allows potential reorganization of recent blocks that should be irreversible, creating uncertainty about transaction permanence and potentially enabling double-spend attacks if reorganizations can be coordinated.

4. **Economic Impact**: The loss of finality guarantees undermines the blockchain's utility for any application requiring transaction certainty (financial settlements, asset transfers, governance decisions).

**Concrete Example**: With 7 miners, if 3 malicious miners report height 1, the LIB becomes 1 (selection index: (7-1)/3 = 2, the 3rd lowest value). All blocks at height 2+ cannot be finalized.

## Likelihood Explanation

The likelihood is **MEDIUM-HIGH** because:

**Attacker Requirements:**
- Must control approximately 1/3 of the elected miner set (standard Byzantine fault tolerance assumption)
- Must be actively participating miners (not requiring privilege escalation)

**Attack Complexity:**
- **Low**: Attackers simply modify their consensus node software to report a constant low value instead of `Context.CurrentHeight`
- No timing coordination needed beyond normal mining participation
- No need to exploit complex race conditions or edge cases

**No Countermeasures:**
- Zero detection mechanisms for incorrect LIB reporting
- No slashing or economic penalties for malicious values
- No reputation system tracking LIB reporting accuracy
- Validation only enforces monotonicity, not reasonableness

**Realistic Preconditions:**
- The 1/3 Byzantine actor threshold is the standard threat model for BFT consensus systems
- Miners have full control over their node software and can modify reported values
- The attack can be sustained indefinitely once initiated

## Recommendation

Implement bounds validation for `ImpliedIrreversibleBlockHeight` in the `LibInformationValidationProvider`:

1. Add a check that the reported `ImpliedIrreversibleBlockHeight` is within a reasonable range of `Context.CurrentHeight` (e.g., not more than a few rounds behind)
2. Add a minimum threshold check ensuring the value is not unreasonably low compared to the current confirmed LIB
3. Consider implementing reputation tracking or slashing mechanisms for miners who consistently report outlier values
4. Add detection logic for abnormal LIB reporting patterns alongside the existing missed time slot detection

Example fix for `LibInformationValidationProvider.cs`:
```csharp
// Add validation that implied height is reasonable relative to current state
var maxAllowedLag = /* reasonable threshold based on round count */;
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var impliedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var currentConfirmedLib = baseRound.ConfirmedIrreversibleBlockHeight;
    
    // Check monotonicity
    if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > impliedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
    
    // Check reasonableness: implied height should not be too far behind confirmed LIB
    if (currentConfirmedLib > 0 && impliedHeight < currentConfirmedLib - maxAllowedLag)
    {
        validationResult.Message = "Implied lib height unreasonably low.";
        return validationResult;
    }
}
```

## Proof of Concept

**Note**: A complete proof of concept would require modifying consensus node software to report malicious values, which is beyond the scope of a smart contract test. However, the vulnerability can be demonstrated through code analysis:

1. Deploy AElf network with 7 miners
2. Modify 3 miner nodes to set `ImpliedIrreversibleBlockHeight = 1` in `GetConsensusExtraDataToPublishOutValue`
3. Allow miners to produce blocks normally
4. Observe that when LIB is calculated in `LastIrreversibleBlockHeightCalculator`, the sorted list contains [1, 1, 1, current_height, current_height, current_height, current_height]
5. Index (7-1)/3 = 2 selects the value 1
6. LIB remains stuck at 1 despite chain progressing to higher blocks

The vulnerability is evident from the code structure where no validation exists to prevent low `ImpliedIrreversibleBlockHeight` values from affecting the consensus LIB calculation.

## Notes

This vulnerability represents a fundamental weakness in the Byzantine fault tolerance assumptions of the LIB calculation mechanism. While the system correctly assumes that up to 1/3 of miners could be Byzantine actors, it fails to implement the necessary validation to prevent those actors from manipulating the LIB through false reporting. The fix requires adding reasonableness checks to complement the existing monotonicity validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L48-48)
```csharp
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
