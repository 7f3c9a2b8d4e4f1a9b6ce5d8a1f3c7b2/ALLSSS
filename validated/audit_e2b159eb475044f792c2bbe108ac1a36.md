# Audit Report

## Title
NFT Item ID Leading Zero Bypass Allows Duplicate NFT Creation for Same Logical Item

## Summary
The MultiToken contract accepts NFT item IDs with arbitrary leading zeros (e.g., "1", "01", "001") due to permissive regex validation. Because the case-insensitive uniqueness check uses `ToUpper()` which does not normalize numeric digits, symbols like "COLLECTION-1" and "COLLECTION-01" are stored as separate NFTs with independent supplies and ownership. This violates the NFT uniqueness invariant and enables collection owners to create unlimited duplicate NFTs for any item number.

## Finding Description

The vulnerability arises from the interaction between three contract components:

**1. Permissive Item ID Validation:**
The `IsValidItemId()` method validates NFT item IDs using the regex pattern `^[0-9]+$`, which accepts any sequence of one or more digits including those with leading zeros like "01", "001", "0001". [1](#0-0) 

This validation is invoked during symbol type determination where the item ID portion is extracted and checked. [2](#0-1) 

**2. Failed Normalization in Uniqueness Check:**
The contract checks token existence using the case-insensitive mapping `State.InsensitiveTokenExisting[symbol.ToUpper()]`. [3](#0-2) 

The critical flaw is that C#'s `ToUpper()` method only uppercases alphabetic characters and does NOT normalize numeric digits. Therefore:
- "COLLECTION-1".ToUpper() returns "COLLECTION-1"
- "COLLECTION-01".ToUpper() returns "COLLECTION-01"

These produce different storage keys in the state mapping, allowing both to pass the uniqueness check independently.

**3. Storage Without Normalization:**
When a token is registered, the symbol is stored directly using its uppercased form as the key, and the TokenInfo is stored using the exact symbol string. [4](#0-3) 

The state mapping that tracks token existence is defined as a simple string-to-boolean mapping. [5](#0-4) 

**Execution Flow:**
1. Collection owner creates NFT collection "TEST-0"
2. Owner calls `Create` with symbol "TEST-1" (TotalSupply=1) - passes validation and uniqueness check [6](#0-5) 
3. Owner calls `Create` with symbol "TEST-01" (TotalSupply=1) - also passes because "TEST-01" is a different key than "TEST-1"
4. Both variants are registered as completely separate tokens with independent TokenInfo, supply tracking, and balance accounting [7](#0-6) 

The NFT creation flow validates collection ownership but does not prevent this bypass. [8](#0-7) 

## Impact Explanation

**NFT Uniqueness Invariant Violation:**
This fundamentally breaks the core NFT principle that each item ID within a collection represents a unique digital asset. The protocol allows multiple on-chain NFTs to exist for what should be a single logical item.

**Direct Supply Inflation:**
Each leading zero variant creates an independent NFT with its own TotalSupply counter. For ERC-721 style NFTs (TotalSupply=1 per item), a malicious collection owner can create unlimited "copies" by varying leading zeros ("COLLECTION-001", "COLLECTION-0001", etc.), each with TotalSupply=1.

**Ownership and Authenticity Confusion:**
Different users can own different variants ("COLLECTION-1" vs "COLLECTION-00001") representing the same logical item. Marketplaces and wallets that normalize display formatting would show these as "Item #1", making them appear identical while having completely separate on-chain ownership, balances, and metadata state.

**Fraud Potential:**
A malicious collection owner can exploit this to:
- Sell "COLLECTION-1" to one buyer as "the authentic NFT #1"
- Later mint and sell "COLLECTION-01" and "COLLECTION-001" to other buyers
- Claim each is legitimate since all pass contract validation
- Exploit different normalization behaviors across dApps, wallets, and indexers

**Protocol-Wide Impact:**
This vulnerability affects ALL NFT collections created through the MultiToken contract system-wide, as the flawed validation and storage logic applies universally.

## Likelihood Explanation

**Publicly Accessible Entry Point:**
The `Create` method is a public contract function that routes to NFT creation for symbols matching the NFT pattern format. No special permissions beyond standard NFT creation requirements are needed.

**Minimal Attacker Requirements:**
The attacker must be the collection owner, which is the standard authorization requirement for creating NFTs within a collection. This is not a privilege escalationâ€”it's a protocol logic flaw that allows legitimate collection owners to bypass fundamental uniqueness guarantees.

**Trivial Execution:**
The attack requires only standard NFT creation transactions:
1. Create collection "TEST-0" (standard operation)
2. Call `Create` with "TEST-1" - succeeds
3. Call `Create` with "TEST-01" - also succeeds (vulnerability)
4. Repeat with "TEST-001", "TEST-0001", etc.

No complex state manipulation, transaction ordering dependencies, or timing constraints exist.

**Detection Difficulty:**
The vulnerability is difficult to detect in practice:
- Test suites lack coverage for leading zero scenarios
- Visual displays typically normalize to "Item #1" for all variants
- All variants pass validation checks without warnings
- No exceptional events are emitted to signal duplication

**Economic Rationality:**
The attack cost equals the standard NFT creation cost with no additional gas overhead or economic barriers, making exploitation economically viable whenever the value of perceived scarcity exceeds creation costs.

## Recommendation

Implement numeric normalization for NFT item IDs to ensure uniqueness. The fix should:

1. **Normalize item IDs on input** - Strip leading zeros from the item ID portion before any validation or storage:
```csharp
private string NormalizeItemId(string itemId)
{
    // Remove leading zeros but preserve "0" if that's the only digit
    return long.Parse(itemId).ToString();
}
```

2. **Update validation flow** - In `GetSymbolType()`, normalize the item ID before validation:
```csharp
private SymbolType GetSymbolType(string symbol)
{
    var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
    Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
    if (words.Length == 1) return SymbolType.Token;
    
    var itemId = words[1];
    Assert(itemId.Length > 0 && IsValidItemId(itemId), "Invalid NFT Symbol input");
    
    // Normalize to prevent leading zero duplicates
    var normalizedItemId = NormalizeItemId(itemId);
    var normalizedSymbol = $"{words[0]}-{normalizedItemId}";
    
    return normalizedItemId == TokenContractConstants.CollectionSymbolSuffix 
        ? SymbolType.NftCollection 
        : SymbolType.Nft;
}
```

3. **Reject or auto-normalize** - Either reject symbols with leading zeros during validation, or automatically normalize them to the canonical form before storage.

This ensures that "COLLECTION-1", "COLLECTION-01", and "COLLECTION-001" all resolve to the same canonical symbol "COLLECTION-1", preventing duplicate creation.

## Proof of Concept

```csharp
[Fact(DisplayName = "[MultiToken_Nft] Leading Zero Bypass - Duplicate NFT Creation")]
public async Task NFT_LeadingZero_Bypass_Test()
{
    // Step 1: Create NFT collection
    var collectionResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST-0",
        TokenName = "Test Collection",
        TotalSupply = 0,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId
    });
    collectionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 2: Create NFT with item ID "1"
    var nft1Result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST-1",
        TokenName = "Test NFT #1",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId
    });
    nft1Result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 3: VULNERABILITY - Create NFT with leading zero "01"
    var nft01Result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST-01",
        TokenName = "Test NFT #01",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId
    });
    // This SHOULD fail but SUCCEEDS - proving the vulnerability
    nft01Result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 4: Verify both NFTs exist independently
    var tokenInfo1 = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "TEST-1" });
    var tokenInfo01 = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "TEST-01" });

    // Both tokens exist with independent supplies - breaks uniqueness
    tokenInfo1.Symbol.ShouldBe("TEST-1");
    tokenInfo1.TotalSupply.ShouldBe(1);
    
    tokenInfo01.Symbol.ShouldBe("TEST-01");
    tokenInfo01.TotalSupply.ShouldBe(1);
    
    // Demonstrates: Two separate NFTs exist for the same logical item ID
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L23-26)
```csharp
    private bool IsValidItemId(string symbolItemId)
    {
        return Regex.IsMatch(symbolItemId, "^[0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L35-36)
```csharp
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```
