# Audit Report

## Title
Missing FinalOrderOfNextRound Validation Enables Consensus DoS via UpdateValue Manipulation

## Summary
A critical vulnerability exists in the AEDPoS consensus validation flow where `FinalOrderOfNextRound` values are not validated during UpdateValue block processing. A malicious miner can inject invalid order values (e.g., 0) for other miners in their block's consensus header, corrupting the consensus state and causing a permanent deadlock when the blockchain attempts to transition to the next round.

## Finding Description

The vulnerability stems from missing validation of `FinalOrderOfNextRound` values at two critical points in the UpdateValue execution path:

**1. During Validation - Unvalidated Recovery:**

The `RecoverFromUpdateValue` method blindly copies `FinalOrderOfNextRound` values from the attacker-controlled consensus header without any validation. The method iterates through all miners in the provided Round and overwrites their `FinalOrderOfNextRound` values in the base round: [1](#0-0) 

This recovery happens during the validation phase before the block is executed: [2](#0-1) 

**2. During Execution - Unvalidated Application:**

The `ProcessUpdateValue` method applies `TuneOrderInformation` values directly to the round state without validation, then persists the corrupted state: [3](#0-2) 

The corrupted round is saved to state: [4](#0-3) 

**Why Existing Protections Fail:**

The UpdateValue validation flow uses multiple validators, but critically, NONE check `FinalOrderOfNextRound` values. The validation providers are registered based on the consensus behavior: [5](#0-4) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` - it does NOT validate `FinalOrderOfNextRound`: [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` that DOES check order validity is only applied for NextRound behavior, NOT for UpdateValue: [7](#0-6) 

**Attack Execution Path:**

1. Malicious miner modifies node software to inject `FinalOrderOfNextRound=0` for other miners in the simplified Round that gets included in their block's consensus header
2. During validation, `RecoverFromUpdateValue` copies these invalid values to baseRound
3. No validator detects that 0 is invalid (valid range is 1 to minersCount)
4. During execution, `ProcessUpdateValue` applies the corrupted values
5. Corrupted state is persisted with miners having `FinalOrderOfNextRound=0`
6. When `GenerateNextRoundInformation` is called for the next round, miners are ordered by their corrupted `FinalOrderOfNextRound` values and directly assigned those values as their `Order` in the next round: [8](#0-7) 
7. All miners with `FinalOrderOfNextRound=0` are assigned `Order=0` in the next round
8. The `BreakContinuousMining` method then calls `.First(i => i.Order == 1)` which throws an `InvalidOperationException` because no miner has Order=1: [9](#0-8) 
9. NextRound block generation fails, blockchain cannot progress

**Why the Attack Works:**

Miners control the construction of their consensus headers. The honest path uses `ApplyNormalConsensusData` to calculate valid `FinalOrderOfNextRound` values: [10](#0-9) 

However, a malicious miner can bypass this calculation by modifying their node software to inject arbitrary values directly into the consensus header's Round object. The simplified Round created for the consensus header includes `FinalOrderOfNextRound` for all miners: [11](#0-10) 

Since the sender's block signature is validated but the content of their Round data is not fully validated, the malicious values are accepted and persist to state.

## Impact Explanation

**Critical Severity - Complete Consensus Failure:**

- **Consensus Deadlock:** The blockchain becomes permanently unable to transition to the next round, halting all block production. The `BreakContinuousMining` method throws `InvalidOperationException` when attempting to find a miner with `Order=1`, causing the NextRound transaction to fail.
- **Network-Wide DoS:** All consensus operations are blocked; no new transactions can be confirmed across the entire network.
- **Permanent State Corruption:** The round state is corrupted with invalid order assignments (`Order=0`) that persist across the network. This corruption is stored in the blockchain state and cannot be automatically corrected.
- **No Automatic Recovery:** There is no built-in mechanism to recover from this state; manual intervention or a hard fork would be required to restore network functionality.
- **Total Network Impact:** All users, dApps, smart contracts, and miners are affected; the entire blockchain becomes non-operational.

This breaks the fundamental consensus guarantee that the network can continuously produce blocks and process transactions.

## Likelihood Explanation

**High Likelihood:**

- **Attacker Requirements:** Must be a legitimate elected miner, which is achievable through the election/staking mechanism available to any participant with sufficient tokens.
- **Technical Complexity:** Medium - requires modifying node software to inject malicious consensus data into the block header's Round object, but the modification itself is straightforward (directly setting values in the data structure).
- **Cost:** Moderate - requires obtaining miner status through election/staking, but the impact (complete network DoS) far exceeds the cost.
- **Detection:** The attack is detectable on-chain (corrupted `FinalOrderOfNextRound` values are visible in the state), but the damage occurs before detection is actionable since the corrupted state persists.
- **Execution:** A single malicious UpdateValue block is sufficient to corrupt the state and trigger the consensus deadlock.
- **Barriers:** No cryptographic or protocol-level barriers prevent the attack once miner status is obtained. The block signature validates the sender's identity but not the correctness of the Round data contents.

For a motivated attacker seeking to DoS the entire network, this vulnerability provides a guaranteed, high-impact attack vector with moderate entry cost.

## Recommendation

Implement validation of `FinalOrderOfNextRound` values for UpdateValue behavior by:

1. **Add validation in UpdateValueValidationProvider**: Check that all `FinalOrderOfNextRound` values are within the valid range [1, minersCount] and that each value in this range is used at most once by miners who mined in the current round.

2. **Alternatively, modify RecoverFromUpdateValue**: Add bounds checking before copying `FinalOrderOfNextRound` values. Reject values outside [1, minersCount] or duplicate values.

3. **Apply NextRoundMiningOrderValidationProvider to UpdateValue**: Extend the validation logic to also apply to UpdateValue behavior, not just NextRound.

Example fix in `RecoverFromUpdateValue`:
```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    // Validate FinalOrderOfNextRound is within valid range
    if (information.Value.FinalOrderOfNextRound != 0)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (information.Value.FinalOrderOfNextRound < 1 || 
            information.Value.FinalOrderOfNextRound > minersCount)
        {
            continue; // Skip invalid values
        }
    }
    
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

## Proof of Concept

A proof of concept would require:

1. Setting up an AElf test network with multiple miners
2. Modifying one miner's node to inject `FinalOrderOfNextRound=0` for all other miners in the consensus header when producing an UpdateValue block
3. Observing that the block passes validation
4. Verifying the corrupted state is persisted
5. Attempting to generate the next round and observing the `InvalidOperationException` when `BreakContinuousMining` calls `.First(i => i.Order == 1)`

The core vulnerable code path is:
- ValidateBeforeExecution → RecoverFromUpdateValue (copies malicious values)
- ProcessUpdateValue → TryToUpdateRoundInformation (persists corrupted state)
- GetConsensusExtraDataForNextRound → GenerateNextRoundInformation → BreakContinuousMining (throws exception)

This would demonstrate complete consensus failure preventing the blockchain from progressing to the next round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```
