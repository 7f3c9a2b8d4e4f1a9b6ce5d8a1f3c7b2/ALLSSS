# Audit Report

## Title
Conflict Resolution Failure in ApplyNormalConsensusData Causes Duplicate Mining Orders and Consensus Breakdown

## Summary
The conflict resolution mechanism in `ApplyNormalConsensusData()` fails to guarantee unique `FinalOrderOfNextRound` values when all mining orders are occupied. This allows duplicate order assignments to persist through normal block production, breaking the fundamental consensus invariant and causing chain halt or permanent fork when the next round is generated.

## Finding Description

The vulnerability exists in the conflict resolution logic that handles `FinalOrderOfNextRound` collisions during consensus data updates. [1](#0-0) 

When a miner produces a block, their new `supposedOrderOfNextRound` is calculated from their signature hash. If this conflicts with another miner's existing `FinalOrderOfNextRound`, the conflict resolution loop (lines 31-40) attempts to find an available order for the conflicted miner. However, the loop checks if ANY miner currently holds each candidate order (line 34), including:
- The conflicted miner's own current order
- The current block producer's old order (which will be overwritten at line 44)
- All other miners' orders

When all orders 1 through N are occupied, the loop exhausts all candidates without finding a free slot. The conflicted miner retains their original order, then the current miner is unconditionally assigned the same conflicting order at line 44, creating duplicates.

This vulnerability is compounded by multiple protection failures:

**1. TuneOrderInformation Propagation Failure:** [2](#0-1) 

The mechanism only broadcasts miners where `FinalOrderOfNextRound != SupposedOrderOfNextRound`. Since unresolved conflicts leave miners with matching values, other nodes never learn about the duplicate.

**2. Validation Bypass:** [3](#0-2) 

`NextRoundMiningOrderValidationProvider` only runs for `NextRound` behavior (line 86), not for `UpdateValue` behavior where duplicates are created (lines 79-83).

**3. Ineffective Duplicate Detection:** [4](#0-3) 

Even when the validator runs, `.Distinct()` operates on `MinerInRound` objects (protobuf-generated with full field comparison), not on `FinalOrderOfNextRound` values, failing to detect duplicate orders.

**4. State Persistence:** [5](#0-4) 

The duplicate values are persisted to on-chain state, where they remain until next round generation.

**5. Signature Variance by Height:** [6](#0-5) 

When miners produce multiple blocks without a `PreviousInValue`, a fake value is generated using `pubkey + CurrentHeight`, ensuring each block produces different signatures and different supposed orders, making conflicts probabilistic but regular.

## Impact Explanation

When `GenerateNextRoundInformation` processes the current round with duplicate `FinalOrderOfNextRound` values: [7](#0-6) 

**Critical Failures:**

1. **Duplicate Mining Schedules:** Both miners receive `Order = FinalOrderOfNextRound` (line 32) and identical `ExpectedMiningTime` (line 33), scheduling simultaneous block production that violates time-slot consensus rules.

2. **Order Slot Corruption:** [8](#0-7) 

The `occupiedOrders` list contains duplicate values, reducing `ableOrders` count. If miners who didn't mine need orders from the reduced pool, `ableOrders[i]` throws `IndexOutOfRangeException`, halting consensus.

3. **Non-deterministic Round Generation:** The `OrderBy(m => m.FinalOrderOfNextRound)` with duplicates relies on dictionary iteration order, which can vary across nodes after serialization/deserialization, causing different nodes to generate different next rounds and permanently forking the chain.

**Severity: HIGH** - Breaks the fundamental consensus invariant that each miner has a unique mining order and time slot. Results in chain halt or permanent fork, affecting all network participants.

## Likelihood Explanation

**Trigger Conditions:**
1. All N miners have produced at least one block (orders 1-N occupied)
2. A miner produces an additional block in the same round (common via tiny blocks)
3. Their new signature-derived order conflicts with existing miner
4. All other orders occupied, so conflict resolution fails

**Attack Complexity: LOW**
- Happens during normal block production (UpdateValue/TinyBlock behavior)
- No special permissions required beyond being a miner
- Signature calculation naturally varies per block height
- Tiny block production is standard protocol behavior

**Probability: MEDIUM-HIGH** - In active rounds where all miners participate, preconditions are frequently met. The hash-based order calculation makes conflicts probabilistic but regular as miners produce multiple blocks per round.

## Recommendation

Modify the conflict resolution loop to exclude the current block producer's order from the occupied set before searching for available slots:

```csharp
public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

    RealTimeMinersInformation[pubkey].OutValue = outValue;
    RealTimeMinersInformation[pubkey].Signature = signature;
    if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
        RealTimeMinersInformation[pubkey].PreviousInValue == null)
        RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

    var minersCount = RealTimeMinersInformation.Count;
    var sigNum = signature.ToInt64();
    var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

    var conflicts = RealTimeMinersInformation.Values
        .Where(i => i.Pubkey != pubkey && i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

    foreach (var orderConflictedMiner in conflicts)
    {
        bool reassignmentSuccessful = false;
        for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
        {
            var maybeNewOrder = i > minersCount ? i % minersCount : i;
            // Exclude current miner's order from occupied check
            if (RealTimeMinersInformation.Values.All(m => 
                m.Pubkey == pubkey || m.FinalOrderOfNextRound != maybeNewOrder))
            {
                RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
                reassignmentSuccessful = true;
                break;
            }
        }
        // Assert or handle failed reassignment
        Assert(reassignmentSuccessful, "Failed to resolve order conflict - all orders occupied");
    }

    RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
    RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

    return this;
}
```

Additionally:
1. Add validation in `NextRoundMiningOrderValidationProvider` to check for duplicate `FinalOrderOfNextRound` values explicitly
2. Consider enabling the validator for `UpdateValue` behavior
3. Add assertion in `GenerateNextRoundInformation` to detect duplicate orders before processing

## Proof of Concept

```csharp
[Fact]
public void Test_DuplicateOrderCreation_WhenAllOrdersOccupied()
{
    // Setup: 5 miners, all have mined and occupy orders 1-5
    var round = new Round { RoundNumber = 1 };
    var miners = new[] { "MinerA", "MinerB", "MinerC", "MinerD", "MinerE" };
    
    for (int i = 0; i < 5; i++)
    {
        round.RealTimeMinersInformation[miners[i]] = new MinerInRound
        {
            Pubkey = miners[i],
            Order = i + 1,
            FinalOrderOfNextRound = i + 1,
            SupposedOrderOfNextRound = i + 1,
            OutValue = Hash.FromString($"out{i}"),
            Signature = Hash.FromString($"sig{i}")
        };
    }
    
    // MinerA produces another block with signature that hashes to order 3 (conflicts with MinerC)
    var conflictingSignature = Hash.FromString("conflict");
    var sigNum = conflictingSignature.ToInt64();
    var supposedOrder = Math.Abs(sigNum % 5) + 1; // Assume this equals 3
    
    // Apply consensus data - should create duplicate
    var updatedRound = round.ApplyNormalConsensusData(
        "MinerA",
        Hash.FromString("prevIn"),
        Hash.FromString("newOut"),
        conflictingSignature
    );
    
    // Verify: Both MinerA and MinerC now have FinalOrderOfNextRound = 3
    var minerAOrder = updatedRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound;
    var minerCOrder = updatedRound.RealTimeMinersInformation["MinerC"].FinalOrderOfNextRound;
    
    Assert.Equal(minerAOrder, minerCOrder); // DUPLICATE DETECTED
    Assert.Equal(3, minerAOrder);
    
    // Verify impact: GenerateNextRoundInformation will fail or produce invalid schedule
    updatedRound.GenerateNextRoundInformation(
        Timestamp.FromDateTime(DateTime.UtcNow),
        Timestamp.FromDateTime(DateTime.UtcNow.AddDays(-1)),
        out var nextRound
    );
    
    // Both miners will have same Order in next round
    var nextRoundOrders = nextRound.RealTimeMinersInformation.Values
        .Select(m => m.Order).ToList();
    
    Assert.True(nextRoundOrders.Count != nextRoundOrders.Distinct().Count()); // NON-UNIQUE ORDERS
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-44)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-44)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
```
