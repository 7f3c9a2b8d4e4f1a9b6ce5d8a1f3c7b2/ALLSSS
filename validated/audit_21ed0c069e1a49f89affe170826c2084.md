# Audit Report

## Title
Hash Collision Vulnerability in NFT Contract Allows Cross-Protocol Data Corruption and Asset Theft

## Summary
The NFT contract's `CalculateTokenHash` function uses naive string concatenation to generate token hashes, enabling attackers to create malicious NFT protocols with symbols that collide with legitimate NFTs. This leads to state corruption across critical storage maps, allowing asset theft through the Disassemble function and denial-of-service attacks preventing legitimate NFT minting.

## Finding Description

The vulnerability stems from the `CalculateTokenHash` implementation which concatenates symbol and tokenId as strings before hashing: [1](#0-0) 

This creates ambiguous hash inputs where different (symbol, tokenId) pairs produce identical strings:
- Protocol "XX12345678" with TokenId 91 → "XX1234567891"
- Protocol "XX123456789" with TokenId 1 → "XX1234567891"

The NFT contract expects symbols to follow the format `{2-char-prefix}{9-digit-number}` with minimum 11 characters: [2](#0-1) [3](#0-2) 

However, the TokenContract allows regular tokens with symbols up to 10 characters: [4](#0-3) 

The `CrossChainCreate` method accepts any symbol existing in TokenContract without length validation and is publicly callable: [5](#0-4) 

During minting, the contract checks if tokenId exists but this check can be bypassed when `IsTokenIdReuse=true`: [6](#0-5) 

When a collision occurs with `IsTokenIdReuse=true`, the existing NFT's data is modified rather than rejected: [7](#0-6) 

The collision affects multiple critical state maps indexed by the same tokenHash: [8](#0-7) [9](#0-8) [10](#0-9) [11](#0-10) 

## Impact Explanation

**Critical Impact - Asset Theft via Disassemble:**

The most severe impact occurs through the Disassemble function. When a hash collision exists, an attacker can call Disassemble with their colliding (symbol, tokenId) pair to steal the victim's assembled NFT/FT components: [12](#0-11) 

The function calculates the same tokenHash, retrieves the victim's assembled assets, and transfers them to the attacker.

**Secondary Impacts:**

1. **NFT Metadata Corruption**: When the attacker mints with `IsTokenIdReuse=true`, the victim's NFTInfo quantity and minters list are modified, corrupting protocol integrity.

2. **Balance Map Sharing**: Multiple protocols share the same balance entry, allowing unauthorized balance manipulation through transfers.

3. **Allowance Map Exploitation**: Allowances set for one protocol affect another protocol sharing the hash.

4. **Denial of Service**: If the attacker mints first, legitimate protocols with `IsTokenIdReuse=false` (the default for NFTs) cannot mint their intended tokenIds, as the check will fail.

## Likelihood Explanation

**High Likelihood:**

1. **Public Attack Surface**: The `CrossChainCreate` method has no authorization checks, making it callable by anyone: [13](#0-12) 

2. **Low Attack Cost**: Attackers only need to acquire a SEED NFT (available through market purchase) to create tokens: [14](#0-13) 

3. **Attacker Control**: The attacker controls the token's ExternalInfo during creation, allowing them to set `IsTokenIdReuse=true` to bypass collision detection.

4. **Deterministic Exploitation**: Hash calculation is deterministic, enabling precise targeting of victim NFT protocols by calculating which (symbol, tokenId) pairs produce desired collisions.

5. **No On-Chain Detection**: Hash collisions appear as normal NFT operations with no obvious indicators, making detection difficult.

## Recommendation

Replace string concatenation with an unambiguous encoding scheme that eliminates collision possibilities:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    // Use structured encoding instead of string concatenation
    var symbolBytes = Encoding.UTF8.GetBytes(symbol);
    var tokenIdBytes = BitConverter.GetBytes(tokenId);
    
    // Combine with length prefixes to ensure uniqueness
    var combined = new byte[4 + symbolBytes.Length + 8];
    BitConverter.GetBytes(symbolBytes.Length).CopyTo(combined, 0);
    symbolBytes.CopyTo(combined, 4);
    tokenIdBytes.CopyTo(combined, 4 + symbolBytes.Length);
    
    return HashHelper.ComputeFrom(combined);
}
```

Additionally, add symbol length validation in `CrossChainCreate` to enforce the expected 11+ character format:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    
    // Add validation
    Assert(input.Symbol.Length >= 11, "NFT protocol symbol must be at least 11 characters");
    
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    // ... rest of method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task HashCollision_AllowsAssetTheft_Test()
{
    // Setup: Create legitimate NFT protocol "XX123456789" with tokenId 1
    var legitimateSymbol = "XX123456789"; // 11 characters
    var legitimateTokenId = 1L;
    
    // Victim creates protocol and mints NFT with assembled components
    await CreateLegitimateProtocolAsync(legitimateSymbol);
    var victimNft = await MintWithAssembledComponentsAsync(legitimateSymbol, legitimateTokenId);
    
    // Calculate the hash for verification
    var expectedHash = await NFTContractStub.CalculateTokenHash.CallAsync(new CalculateTokenHashInput
    {
        Symbol = legitimateSymbol,
        TokenId = legitimateTokenId
    });
    
    // Attack: Create malicious token "XX12345678" (10 characters) with IsTokenIdReuse=true
    var maliciousSymbol = "XX12345678"; // 10 characters
    var maliciousTokenId = 91L; // Chosen to create collision: "XX12345678" + "91" = "XX1234567891"
    
    // Create token in MultiToken contract with ExternalInfo
    await CreateMaliciousTokenAsync(maliciousSymbol, isTokenIdReuse: true);
    
    // Call public CrossChainCreate to register malicious protocol
    await AttackerNFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = maliciousSymbol
    });
    
    // Verify hash collision
    var attackerHash = await NFTContractStub.CalculateTokenHash.CallAsync(new CalculateTokenHashInput
    {
        Symbol = maliciousSymbol,
        TokenId = maliciousTokenId
    });
    
    attackerHash.ShouldBe(expectedHash); // COLLISION CONFIRMED
    
    // Attacker mints NFT with colliding hash
    await AttackerNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = maliciousSymbol,
        TokenId = maliciousTokenId,
        Owner = AttackerAddress
    });
    
    // EXPLOIT: Attacker calls Disassemble with their (symbol, tokenId) to steal victim's assets
    var result = await AttackerNFTContractStub.Disassemble.SendAsync(new DisassembleInput
    {
        Symbol = maliciousSymbol,
        TokenId = maliciousTokenId,
        Owner = AttackerAddress
    });
    
    // Verify: Attacker received victim's assembled components
    var attackerBalance = await GetAssembledComponentBalance(AttackerAddress);
    attackerBalance.ShouldBeGreaterThan(0); // ASSET THEFT SUCCESSFUL
    
    // Verify: Victim's assembled components are gone
    var victimComponents = await GetAssembledComponents(expectedHash);
    victimComponents.ShouldBeNull(); // VICTIM'S ASSETS STOLEN
}
```

## Notes

This vulnerability represents a fundamental flaw in the NFT protocol's hash generation mechanism. The attack is feasible because:

1. The collision space is large but computationally tractable - attackers can find collisions by iterating through short symbols (1-10 chars) and calculating which tokenIds produce target hashes
2. The protocol's assumption that NFT symbols will be 11+ characters is not enforced in `CrossChainCreate`
3. The `IsTokenIdReuse` flag, intended for legitimate re-minting scenarios, becomes an attack vector when combined with hash collisions
4. The impact extends beyond data corruption to direct asset theft through the Disassemble mechanism

The fix must address both the hash collision root cause and add validation to enforce symbol format expectations.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-24)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-178)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-225)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L295-298)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-396)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-441)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-89)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-64)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
```
