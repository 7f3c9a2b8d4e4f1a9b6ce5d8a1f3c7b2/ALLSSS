# Audit Report

## Title
Invalid FinalOrderOfNextRound Values Enable Consensus Disruption Through Malicious Order Assignment

## Summary
A malicious miner can inject arbitrary `FinalOrderOfNextRound` values through the `UpdateValue` method's `TuneOrderInformation` parameter without validation. These invalid values (including 0, duplicates, or values exceeding `minersCount`) directly disrupt next round generation, causing consensus crashes or schedule corruption.

## Finding Description

**Root Cause - Unvalidated Order Assignment:**

The `ProcessUpdateValue` method directly applies `TuneOrderInformation` from user input to `FinalOrderOfNextRound` without any validation: [1](#0-0) 

The protobuf definition allows arbitrary `int32` values in the `tune_order_information` map: [2](#0-1) 

**Vulnerable Execution Path:**

When `GenerateNextRoundInformation` processes the next round, it uses unvalidated `FinalOrderOfNextRound` values to assign mining orders: [3](#0-2) 

The `occupiedOrders` calculation collects whatever values exist, including invalid ones: [4](#0-3) 

**Why Existing Protections Fail:**

The `NextRoundMiningOrderValidationProvider` only validates during NextRound behavior (not UpdateValue), and only checks that the count of distinct miners with positive orders matches miners who minedâ€”it doesn't validate uniqueness of order values: [5](#0-4) [6](#0-5) 

The `UpdateValueValidationProvider` only validates OutValue and Signature fields, ignoring TuneOrderInformation: [7](#0-6) 

**Downstream Crash Points:**

The `BreakContinuousMining` function expects specific orders (1, 2, minersCount-1) to exist and uses `First()` which throws `InvalidOperationException` if these orders are missing: [8](#0-7) [9](#0-8) [10](#0-9) 

This function is called during next round generation: [11](#0-10) 

Which occurs when miners generate consensus extra data for block production: [12](#0-11) 

## Impact Explanation

**Consensus Integrity Violation (HIGH SEVERITY):**

1. **Execution Crashes**: When all miners have `FinalOrderOfNextRound = 0`, the next round assigns them `Order = 0`. When `BreakContinuousMining` searches for miners with `Order == 1`, `First()` throws `InvalidOperationException`, crashing block production and halting consensus.

2. **Duplicate Orders**: Multiple miners assigned the same `FinalOrderOfNextRound` compete for identical time slots, creating block production conflicts and consensus ambiguity.

3. **Schedule Corruption**: Orders outside the valid range [1, minersCount] or duplicate values corrupt the mining schedule, breaking the deterministic block production sequence.

4. **Miner Exclusion**: Invalid order assignments cause legitimate miners to be excluded from the next round or assigned incorrect time slots.

**Affected Components:**
- Block production scheduling
- Round transition logic  
- LIB height calculation
- Cross-chain verification relying on consensus state

## Likelihood Explanation

**Attacker Capabilities:**

Any active miner can call the public `UpdateValue` method: [13](#0-12) 

The only permission check validates the sender is in the miner list: [14](#0-13) 

**Attack Complexity: LOW**
1. Malicious miner crafts `UpdateValue` transaction with arbitrary `TuneOrderInformation` (e.g., all values set to 0)
2. Values are stored immediately without validation
3. When the next round transition occurs, miners attempt to generate consensus data
4. `GenerateNextRoundInformation` uses invalid values, causing crash or schedule corruption

**Feasibility Conditions:**
- Attacker must be an elected miner (realistic in any competitive network)
- Single transaction execution required
- No special timing or coordination needed
- Economically rational for malicious actors to disrupt competitors or cause consensus DoS

**Probability: HIGH** - Any malicious miner can execute this attack with a single transaction during their mining slot.

## Recommendation

Add validation in `ProcessUpdateValue` before applying `TuneOrderInformation`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate TuneOrderInformation
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        // Check order is in valid range
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
            $"Invalid order value: {tuneOrder.Value}");
        
        // Check miner exists in current round
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
            $"Miner not found: {tuneOrder.Key}");
    }
    
    // Check for duplicate order values
    var orderValues = updateValueInput.TuneOrderInformation.Values.ToList();
    Assert(orderValues.Distinct().Count() == orderValues.Count,
        "Duplicate order values detected");
    
    // Existing logic continues...
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousOrderAssignment_CausesConsensusCrash()
{
    // Setup: Initialize consensus with 3 miners
    var miners = await InitializeConsensusWithMiners(3);
    var maliciousMiner = miners[0];
    
    // Attack: Malicious miner sets all FinalOrderOfNextRound to 0
    var maliciousInput = new UpdateValueInput
    {
        OutValue = Hash.FromString("test"),
        Signature = Hash.FromString("sig"),
        RoundId = 1,
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            { miners[0].ToHex(), 0 },
            { miners[1].ToHex(), 0 },
            { miners[2].ToHex(), 0 }
        }
    };
    
    // Execute malicious UpdateValue
    await ConsensusStub.UpdateValue.SendAsync(maliciousInput);
    
    // Verify: Attempting to generate next round crashes
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(
        async () => await ConsensusStub.GetConsensusExtraDataForNextRound());
    
    Assert.Contains("Sequence contains no matching element", exception.Message);
}
```

## Notes

The vulnerability stems from a missing validation layer in the consensus order assignment mechanism. While the `NextRoundMiningOrderValidationProvider` exists, it only runs during `NextRound` behavior validation, not during `UpdateValue` processing where the malicious data is injected. The `Distinct()` check on `MinerInRound` objects doesn't validate uniqueness of order values themselves, only that miners are distinct entities. This allows invalid orders to persist in state until the next round generation attempts to use them, at which point the system crashes or produces corrupted schedules.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L30-31)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L67-67)
```csharp
        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L83-84)
```csharp
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L100-101)
```csharp
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
