# Audit Report

## Title
NextRound Mining Order Validation Checks Wrong Round, Allowing Mining Order Manipulation

## Summary
The `NextRoundMiningOrderValidationProvider` validates the wrong round during NextRound consensus behavior. It checks the newly-generated next round (with default values) instead of the current round, causing validation to always pass. This allows miners to manipulate `FinalOrderOfNextRound` values via `TuneOrderInformation` without detection, potentially causing invalid miner order assignments and consensus disruption.

## Finding Description

The `NextRoundMiningOrderValidationProvider` is designed to validate that miners who determined their next round order are exactly the miners who mined blocks in the current round. However, it uses the wrong data source for validation.

The validator checks `validationContext.ProvidedRound` [1](#0-0) , which is defined as `ExtraData.Round` [2](#0-1) .

For NextRound behavior, `ExtraData.Round` contains the freshly-generated next round from `GenerateNextRoundInformation` [3](#0-2) [4](#0-3) .

This newly-generated round contains fresh `MinerInRound` objects with only basic fields initialized [5](#0-4) . Critically, `FinalOrderOfNextRound` and `OutValue` are not initialized, leaving them with default values of 0 and null respectively. The validation check therefore becomes `distinctCount(0) == Count(OutValue != null)(0)`, which always evaluates to `0 == 0 = true` [6](#0-5) .

Unlike UpdateValue and TinyBlock behaviors which recover the base round before validation [7](#0-6) , NextRound has no recovery step, yet the validator still checks `ProvidedRound` instead of `BaseRound`.

During UpdateValue execution, miners can manipulate `TuneOrderInformation` to set arbitrary `FinalOrderOfNextRound` values [8](#0-7) . The `UpdateValueValidationProvider` does not validate these tuning values [9](#0-8) .

When the next round is generated, these manipulated `FinalOrderOfNextRound` values are used to assign miner orders [10](#0-9) . A miner with `FinalOrderOfNextRound = 0` would receive `Order = 0`, which is invalid since valid orders range from 1 to N [11](#0-10) .

The correct implementation should check `BaseRound` (the current round from StateDb), as demonstrated by other validation providers [12](#0-11) [13](#0-12) .

## Impact Explanation

This vulnerability breaks consensus integrity. Malicious miners can:

1. Set invalid `FinalOrderOfNextRound` values (including 0) for any miner via `TuneOrderInformation`
2. Bypass the intended validation since it always passes
3. Cause invalid miner order assignments in the next round
4. Disrupt the mining schedule and potentially cause consensus failures

The impact is **High** because:
- Consensus mechanisms are critical security invariants
- Invalid miner orders (Order=0) violate the expected range (1 to N) and can cause unpredictable behavior
- Honest miners may be assigned invalid orders through no fault of their own
- The entire network's block production schedule becomes vulnerable to manipulation
- Could lead to chain halts or degraded consensus operation

## Likelihood Explanation

The likelihood is **Medium to High** because:

**Attacker Capabilities:** Any miner can exploit this by modifying their node to include manipulated `TuneOrderInformation` in `UpdateValueInput`. Since miners regularly produce UpdateValue blocks as part of normal consensus operation, the attack vector is readily accessible.

**Attack Complexity:** Requires modifying node software to inject malicious consensus data, but no additional privileges beyond being a miner are needed.

**Existing Protections Fail:** 
- `UpdateValueValidationProvider` does not validate tuning values
- `NextRoundMiningOrderValidationProvider` is completely ineffective due to checking the wrong data structure
- No authorization checks prevent manipulation of these values

**Detection Difficulty:** The manipulation would persist in state and only manifest as invalid orders when NextRound is generated, making attribution difficult.

## Recommendation

Change `NextRoundMiningOrderValidationProvider` to check `BaseRound` instead of `ProvidedRound`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound; // Use BaseRound instead of ProvidedRound
    var distinctCount = baseRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

Additionally, consider adding validation in `UpdateValueValidationProvider` to ensure `TuneOrderInformation` values are within valid ranges (1 to minersCount).

## Proof of Concept

A test would demonstrate:
1. Setting up a round with N miners who have mined blocks
2. Having a miner produce UpdateValue with malicious `TuneOrderInformation` (e.g., setting another miner's `FinalOrderOfNextRound` to 0)
3. Verifying the UpdateValue block passes validation
4. Producing a NextRound block using the manipulated state
5. Verifying the NextRound validation passes (when it should fail)
6. Observing that the next round contains a miner with `Order = 0`

The test would confirm that the validation logic checks the wrong round and always passes, allowing invalid miner orders to be committed to state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-14)
```csharp
        var providedRound = validationContext.ProvidedRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L201-201)
```csharp
            Round = nextRound,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-17)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-29)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
```
