# Audit Report

## Title
Evil Nodes Bypass Punishment During Term Transitions Due to Missing Banned Pubkey Check in GetVictories Fallback Logic

## Summary
The Election contract's `GetVictories` method contains a critical vulnerability in its fallback logic that allows banned miners (marked as evil nodes) to continue participating in consensus during term transitions. When insufficient valid candidates are available, the method selects backup miners from initial miners without checking `State.BannedPubkeyMap`, completely bypassing the punishment mechanism.

## Finding Description

The vulnerability exists in the `GetVictories` method's fallback selection logic. When valid candidates are insufficient to fill all miner slots during a term transition, the fallback logic at lines 66-69 directly adds miners from `currentMiners` and `State.InitialMiners` without checking `State.BannedPubkeyMap`. [1](#0-0) 

When a node is marked as evil, the `UpdateCandidateInformation` method sets `State.BannedPubkeyMap[input.Pubkey] = true` and removes the node from `State.CandidateInformationMap` and `State.Candidates`, but critically does NOT remove it from `State.InitialMiners`. [2](#0-1) 

The correct implementation exists in the same file. The `GetMinerReplacementInformation` method properly filters banned pubkeys when selecting from initial miners using `.Where(k => !State.BannedPubkeyMap[k])`. [3](#0-2) 

During term transitions, the consensus contract calls `TryToGetVictories` to obtain the new miner list. [4](#0-3) 

This calls the vulnerable `GetVictories` method in the Election contract. [5](#0-4) 

The returned miner list is then directly used to set the new term's miners in `ProcessNextTerm` without additional banned pubkey validation. [6](#0-5) 

The miner replacement mechanism that could catch banned miners only activates during same-term round transitions (when `previousRound.TermNumber == currentRound.TermNumber`), NOT during term changes. [7](#0-6) 

## Impact Explanation

This vulnerability has CRITICAL impact on network security and integrity:

1. **Consensus Integrity Violation**: Banned miners (evil nodes) that should be permanently excluded from consensus continue participating in block production across multiple terms, completely defeating the punishment mechanism designed to maintain network security.

2. **Reward Misallocation**: Banned miners continue earning mining rewards despite being marked as malicious actors. The term transition process includes reward donation and distribution through the Treasury contract. [8](#0-7) 

3. **Long-term Attack Persistence**: Malicious nodes can continue attacking the network across multiple terms without consequences, as long as candidate participation remains below the required miner count threshold.

4. **Undermined Governance**: The evil node detection and punishment mechanism becomes ineffective, as banned nodes automatically return during term transitions, undermining trust in the governance system.

## Likelihood Explanation

The likelihood of this vulnerability being triggered is HIGH:

**Reachable Entry Point**: Term transitions occur automatically based on blockchain time through the public consensus mechanism via `NextTerm`. [9](#0-8) 

**Feasible Preconditions**:
1. At least one miner marked as evil (realistic - happens through `UpdateCandidateInformation` when consensus contract detects evil behavior, or via emergency response organization through `RemoveEvilNode`) [10](#0-9) 
2. Valid candidates < required miners count (realistic during low participation periods, especially in early network stages or periods of low voter engagement)
3. Term transition occurs (happens regularly in normal operation - every term period)

**Automatic Trigger**: The vulnerability triggers deterministically during normal term transitions when insufficient candidates exist. No attacker action is required beyond the initial evil behavior that caused the ban.

**Silent Execution**: The issue occurs without errors or events that would alert operators, making it difficult to detect without explicit monitoring of the banned pubkey map versus active miner lists.

## Recommendation

Add a banned pubkey check in the `GetVictories` fallback logic when selecting from initial miners:

```csharp
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k) && !State.BannedPubkeyMap[k])); // Add banned check
```

This mirrors the correct implementation already present in `GetMinerReplacementInformation`.

## Proof of Concept

```csharp
[Fact]
public async Task GetVictories_Returns_BannedInitialMiner_During_TermTransition()
{
    // Setup: Initialize with initial miners
    var initialMiners = ValidationDataCenterKeyPairs.Take(5).ToList();
    
    // Ban one of the initial miners
    var bannedMinerPubkey = initialMiners[0].PublicKey.ToHex();
    await ConsensusStub.UpdateCandidateInformation.SendAsync(new UpdateCandidateInformationInput
    {
        Pubkey = bannedMinerPubkey,
        IsEvilNode = true
    });
    
    // Verify miner is banned
    var isBanned = await ElectionStub.GetReplacedPubkey.CallAsync(new StringValue { Value = bannedMinerPubkey });
    isBanned.ShouldNotBeNull();
    
    // Ensure insufficient valid candidates (< MinersCount)
    // Only 2 candidates with votes, but need 5 miners
    await AnnounceElectionAsync(ValidationDataCenterKeyPairs[5]);
    await AnnounceElectionAsync(ValidationDataCenterKeyPairs[6]);
    await VoteToCandidateAsync(VoterKeyPairs[0], ValidationDataCenterKeyPairs[5].PublicKey.ToHex(), 90 * 86400, 100);
    await VoteToCandidateAsync(VoterKeyPairs[1], ValidationDataCenterKeyPairs[6].PublicKey.ToHex(), 90 * 86400, 100);
    
    // Trigger term transition
    await BlockMiningService.MineBlockToNextTermAsync();
    
    // Get the new miner list - THIS IS THE BUG
    var victories = await ElectionStub.GetVictories.CallAsync(new Empty());
    
    // VULNERABILITY: Banned initial miner is included in the victories
    victories.Value.Select(v => v.ToHex()).ShouldContain(bannedMinerPubkey);
    
    // Confirm banned miner can now participate in consensus
    var currentMiners = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    currentMiners.Pubkeys.Select(p => p.ToHex()).ShouldContain(bannedMinerPubkey);
}
```

## Notes

This vulnerability specifically affects the term transition flow where the miner list is completely refreshed. The same-term miner replacement mechanism (`GetMinerReplacementInformation`) correctly filters banned pubkeys, but this protection does not apply during term changes. The issue is exacerbated during periods of low candidate participation, which makes the fallback logic more likely to execute. The vulnerability can persist across multiple terms as long as the preconditions remain met.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-76)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-392)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-350)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
