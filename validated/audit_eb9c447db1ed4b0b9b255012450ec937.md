# Audit Report

## Title
Symbol Mismatch Causes Permanent Token Lock When Scheme is Recreated

## Summary
The TokenHolder contract allows scheme managers to recreate profit schemes with different token symbols, causing users' previously locked tokens to become permanently inaccessible. When the scheme symbol is changed after users have registered and locked tokens, withdrawal operations fail because the contract queries the new symbol's balance while the actual locked tokens remain under the original symbol.

## Finding Description

The vulnerability exists in the interaction between the TokenHolder and MultiToken contracts through a critical design flaw in scheme management.

**1. CreateScheme() - No Overwrite Protection**

The `CreateScheme()` function unconditionally overwrites the existing scheme without any validation [1](#0-0) . When a manager calls `CreateScheme()` multiple times, it directly overwrites the scheme including the `Symbol` field, with no check for existing schemes or registered users.

**2. RegisterForProfits() - Locks Tokens with Current Symbol**

When users register for profits, tokens are locked using the scheme's symbol at registration time [2](#0-1) . The function retrieves the current scheme and locks tokens with that specific symbol. The lockId is stored to track the registration, and users cannot re-register due to the "Already registered" check.

**3. Withdraw() - Queries with New Symbol**

During withdrawal, the contract retrieves the **current** scheme and queries for locked tokens using the **current** symbol [3](#0-2) . The critical issue is that `GetLockedAmount` is called with `scheme.Symbol`, which now reflects the new symbol from the recreated scheme, not the original symbol used during locking.

**4. GetLockedAmount() - Returns Zero for Wrong Symbol**

The MultiToken contract's `GetLockedAmount` function computes the virtual address correctly but queries the balance for the specified symbol [4](#0-3) . Since the virtual address contains tokens locked with the original symbol, querying for the new symbol returns zero balance.

**5. Unlock() - Fails on Zero Amount**

When attempting to unlock zero tokens, the MultiToken contract's validation fails [5](#0-4) . The `AssertValidToken` call invokes `AssertValidSymbolAndAmount` [6](#0-5) , which requires `amount > 0`, causing the transaction to fail with "Invalid amount."

**6. No Recovery Path**

Users cannot re-register because the lockId still exists [7](#0-6) . The lockId is only removed on successful withdrawal [8](#0-7) . The `RemoveBeneficiary` function only removes profit distribution rights but does not unlock tokens [9](#0-8) .

## Impact Explanation

**Direct Fund Loss:**
- Users' locked tokens become permanently inaccessible, representing complete loss of funds
- All users who registered before scheme recreation are affected simultaneously
- The tokens remain locked in virtual addresses with no mechanism to retrieve them through normal contract functions

**Affected Parties:**
- All users who locked tokens under the original scheme symbol before it was changed
- The locked funds cannot be recovered through any standard contract function
- Even the scheme manager cannot help affected users recover their funds through contract methods

**Severity: HIGH** because:
1. Complete and permanent loss of user funds
2. Affects all registered users of a scheme simultaneously
3. No reasonable recovery mechanism exists in the contract
4. Simple execution requiring minimal effort

## Likelihood Explanation

**Attacker Capabilities:**
- Any scheme manager can trigger this vulnerability
- Requires only calling `CreateScheme()` twice with different symbols
- No special permissions beyond being a scheme creator (standard functionality available to any address)

**Attack Complexity:**
- Trivial: Single transaction to recreate the scheme with a different symbol
- Can be intentional (malicious manager) or accidental (manager attempting to update scheme parameters without understanding the consequences)
- Immediate effect on all registered users upon scheme recreation

**Feasibility:**
- Users registering for profits is normal and expected usage
- Manager calling `CreateScheme()` again is a standard contract operation with no restrictions
- No special setup or preconditions required beyond normal operations

**Probability: HIGH** - The vulnerability can be triggered by any scheme manager with minimal effort, and the contract provides no safeguards against scheme recreation with different symbols.

## Recommendation

Add validation to prevent scheme recreation when users are registered:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Check if scheme already exists with registered users
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    if (existingScheme != null && existingScheme.SchemeId != null)
    {
        // Verify no users are currently registered by checking the profit scheme
        var schemeDetails = State.ProfitContract.GetScheme.Call(existingScheme.SchemeId);
        Assert(schemeDetails.TotalShares == 0, "Cannot recreate scheme with registered users.");
    }
    
    // ... rest of existing CreateScheme logic
}
```

Alternatively, prevent symbol changes entirely:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    if (existingScheme != null)
    {
        Assert(existingScheme.Symbol == input.Symbol, 
            "Cannot change scheme symbol. Symbol must remain: " + existingScheme.Symbol);
    }
    
    // ... rest of existing CreateScheme logic
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SymbolMismatch_CausesPermanentLock()
{
    // Setup: Manager creates scheme with TOKEN_A
    var manager = Accounts[1].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "TOKEN_A",
        MinimumLockMinutes = 1
    });
    
    // User registers and locks 100 TOKEN_A
    var user = Accounts[2].Address;
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "TOKEN_A",
        Amount = 100
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 100
    });
    
    // Manager recreates scheme with TOKEN_B (vulnerability trigger)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "TOKEN_B",  // Different symbol!
        MinimumLockMinutes = 1
    });
    
    // Wait for minimum lock period
    await AdvanceTime(TimeSpan.FromMinutes(2));
    
    // User tries to withdraw - THIS WILL FAIL
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(manager);
    
    // Assert: Transaction fails with "Invalid amount" because GetLockedAmount returns 0 for TOKEN_B
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    withdrawResult.TransactionResult.Error.ShouldContain("Invalid amount");
    
    // User's 100 TOKEN_A are permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-166)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-225)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L238-238)
```csharp
        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-236)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
