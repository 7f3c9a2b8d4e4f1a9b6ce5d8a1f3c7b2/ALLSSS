# Audit Report

## Title
Insufficient Taylor Series Iterations in Ln Function Causes Material Pricing Error at Domain Boundary

## Summary
The `Ln` function in BancorHelper uses only 20 iterations of a Taylor series approximation, causing approximately 3.5% error when calculating ln(2) at the domain boundary. This error propagates through the Bancor pricing formula in `GetAmountToPayFromReturn`, resulting in approximately 4-5% underpayment when users purchase amounts approaching half of the connector balance, leading to material protocol fund loss. [1](#0-0) 

## Finding Description
The `Ln` function implements natural logarithm using the Taylor series: ln(1-x) = -x - x²/2 - x³/3 - ... where x = 1 - a, convergent for |x| < 1. [2](#0-1) 

The boundary validation permits values where |1 - a| < 1, allowing a to approach 2.0. With only 20 iterations, the alternating harmonic series converges insufficiently at this boundary. When a ≈ 1.999999, the series x = 1 - a ≈ -0.999999 produces approximately 0.6687 after 20 terms, compared to the true value ln(2) ≈ 0.6931, representing a ~3.5% error.

This occurs when users call the `Buy` function to purchase amounts approaching half the `toConnectorBalance`. The calculation `x = bt / (bt - a)` approaches 2.0: [3](#0-2) 

The error propagates through `Exp(y * Ln(x))` in the Bancor pricing formula. When y = 1 (equal weights):
- Correct: Exp(ln(2)) = 2
- With error: Exp(0.6687) ≈ 1.952
- Payment calculation: bf * (Exp(y*Ln(x)) - 1)
- Correct payment: bf * (2 - 1) = bf  
- Incorrect payment: bf * (1.952 - 1) = 0.952 * bf
- Underpayment: ~4.8%

The `Buy` function is publicly accessible with no restrictions on purchase size relative to pool balance: [4](#0-3) 

The only protection is the user-controlled `PayLimit` parameter, which does not protect the protocol from receiving insufficient payment.

## Impact Explanation
**Quantified Financial Impact:**

For a pool with 2,000,000 resource tokens where a user buys 999,999 tokens:
- x = 2,000,000 / (2,000,000 - 999,999) = 2,000,000 / 1 ≈ 2,000,000 (approaches infinity, but practically x ≈ 2 for 999,998 tokens)
- For 999,998 tokens: x = 2,000,000 / 2 = 1,000,000 (wait, this calculation is wrong in my reasoning)

Let me recalculate: If bt = 2,000,000 and a = 999,999:
- bt - a = 1
- x = 2,000,000 / 1 = 2,000,000

Actually, when buying close to half: a ≈ bt/2 = 1,000,000
- x = 2,000,000 / (2,000,000 - 1,000,000) = 2,000,000 / 1,000,000 = 2

With weight ratio y = 1 and payment underestimated by ~4.8%:
- If correct cost should be 1,000,000 base tokens
- Actual payment charged: ~952,000 base tokens  
- Loss to protocol: ~48,000 base tokens
- After 0.5% fee: Additional ~2,400 tokens in fees also lost

**Who is Affected:**
- Token converter protocol loses base tokens on large boundary trades
- Liquidity providers receive less deposit than economically justified
- Protocol treasury receives reduced fees on underpriced trades

**Severity Justification:** Medium severity - requires specific boundary conditions (buying ~50% of pool) but causes material financial loss (4-5% on large trades) with no privileged access required.

## Likelihood Explanation
**Attacker Capabilities:**
- Must have sufficient capital to purchase approximately 50% of pool balance
- Must calculate precise amount where x approaches 2.0
- No special permissions required - Buy function is public

**Attack Complexity:**
Medium - requires mathematical knowledge to identify the boundary condition and calculate optimal purchase amount, but execution is straightforward via standard contract call.

**Feasibility Conditions:**
- Pool must have sufficient liquidity (hundreds of thousands to millions of tokens) for absolute profit to justify gas costs
- Attacker needs capital to purchase close to half the pool balance
- Can be executed repeatedly as pool balances change

**Detection Constraints:**
Difficult to detect as transaction appears as legitimate large buy order. The `PayLimit` parameter is user-specified and won't raise red flags.

**Probability Assessment:**
Moderate - requires sophisticated actor with substantial capital, but pools with millions of tokens make the absolute profit (tens of thousands of tokens) economically attractive. The exploit is deterministic and reproducible once boundary conditions are identified.

## Recommendation
Increase the number of Taylor series iterations in the `Ln` function from 20 to at least 50-100 to ensure sufficient convergence near domain boundaries. Alternatively, implement a more robust logarithm calculation method or add explicit bounds checking to prevent trades that approach the domain boundary (e.g., restrict purchases to maximum 40-45% of pool balance).

**Suggested Fix:**

Change `_LOOPS` constant to a higher value for better precision:
```csharp
private const int _LOOPS = 50; // Increased from 20 for boundary precision
```

Or add explicit boundary protection in `GetAmountToPayFromReturn`:
```csharp
// Add check to prevent buying more than 45% of pool
Assert(amountToReceive < toConnectorBalance * 0.45m, 
    "Purchase amount too large relative to pool balance");
```

## Proof of Concept

The following conceptual test demonstrates the vulnerability:

```csharp
[Fact]
public void Ln_Boundary_Precision_Error_Test()
{
    // Setup: Calculate for x approaching 2 (buying ~50% of pool)
    long fromConnectorBalance = 1_000_000; // 1M base tokens
    long toConnectorBalance = 2_000_000;   // 2M resource tokens
    decimal fromWeight = 0.5m;
    decimal toWeight = 0.5m;
    long amountToReceive = 999_999;  // Just under half the pool
    
    // This will trigger Ln(x) where x ≈ 2.0
    var amountToPay = BancorHelper.GetAmountToPayFromReturn(
        fromConnectorBalance, fromWeight,
        toConnectorBalance, toWeight,
        amountToReceive);
    
    // Expected (mathematically correct with perfect ln(2)):
    // x = 2_000_000 / (2_000_000 - 999_999) ≈ 2000
    // With y=1: payment should be bf * (Exp(1*ln(2000)) - 1) 
    // But due to Ln error, payment is underestimated by ~4-5%
    
    // The actual payment will be less than the mathematically correct amount
    // Protocol loses ~4-5% on this trade
    
    amountToPay.ShouldBeLessThan(/* mathematically correct amount */);
}
```

The mathematical proof is evident in the Taylor series convergence: for x = -0.999999 (when a = 1.999999), the alternating harmonic series 1 - 1/2 + 1/3 - ... + 1/20 yields approximately 0.6687, while ln(2) ≈ 0.6931, demonstrating the ~3.5% error in the logarithm that propagates to ~4.8% in the final payment calculation.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-127)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```
