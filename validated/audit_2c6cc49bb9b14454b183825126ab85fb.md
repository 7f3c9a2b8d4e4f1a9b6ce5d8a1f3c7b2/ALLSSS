# Audit Report

## Title
Consensus Hijacking via Unvalidated Miner List Manipulation in NextRound Transition

## Summary
The AEDPoS consensus validation logic fails to verify that the miner list in a NextRound transition matches the expected miner list from the current round. This allows any legitimate miner to inject arbitrary public keys during their NextRound block, permanently replacing all consensus participants and achieving complete blockchain takeover.

## Finding Description

The vulnerability exists in the consensus validation pipeline that processes NextRound transitions. The core issue is that **no validator checks whether the miner public keys (dictionary keys of `RealTimeMinersInformation`) in the provided next round match those in the current round**.

**Validation Gap:**

The `ValidationForNextRound()` method only validates two conditions: [1](#0-0) 

This validation checks round number incrementation and that `InValue` fields are null, but **never validates the miner list**.

**Complete Validation Pipeline for NextRound:**

The validation providers for NextRound behavior are: [2](#0-1) 

1. **MiningPermissionValidationProvider** - checks if sender is in the **base round** (current round from state), not the provided round: [3](#0-2) 

2. **NextRoundMiningOrderValidationProvider** - validates internal consistency within the provided round only: [4](#0-3) 

**None of these validators compare the miner list in the provided next round against the current round.**

**Attack Execution:**

After passing validation, `ProcessNextRound()` directly stores the attacker-provided round: [5](#0-4) 

The malicious round is stored without any validation: [6](#0-5) 

And the current round number is updated: [7](#0-6) 

**Permanent Enforcement:**

All future mining permission checks use the stored malicious miner list: [8](#0-7) 

**Legitimate Behavior Comparison:**

The legitimate `GenerateNextRoundInformation()` method preserves the current round's miner list by iterating over existing miners: [9](#0-8) 

However, validation does not enforce this invariant.

**Post-Execution Validation Cannot Detect:**

Post-execution validation compares header with state **after** the malicious round has already been stored: [10](#0-9) 

Since both the header and state contain the same malicious round after execution, the hash comparison passes.

## Impact Explanation

**Critical Consensus Integrity Violation:**

- An attacker can permanently replace the entire miner list with arbitrary public keys of their choosing
- The malicious miner list is stored in `State.Rounds[roundNumber]` and becomes the authoritative source for all future mining permission checks
- All legitimate miners are immediately and permanently locked out of consensus participation
- The attacker's chosen addresses gain exclusive control over block production
- The chain continues operating but under complete attacker control with no decentralization
- No automatic recovery mechanism exists in the protocol

**Blockchain-Wide Impact:**

- Complete loss of consensus security and decentralization
- Attacker can censor any transactions indefinitely
- Attacker controls all governance actions that require block production
- The blockchain becomes a centralized system controlled by the attacker
- Recovery would require hard fork or manual intervention
- All users, applications, and dependent systems are affected

This represents a **CRITICAL** severity issue as it allows complete and irreversible takeover of the blockchain's consensus mechanism.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a legitimate miner in the current round (achievable through normal election/staking process)
- Must produce a block during their designated NextRound time slot
- No additional permissions, stake requirements, or resources needed

**Attack Complexity:**
- **Very Low** - Attacker simply constructs a `NextRoundInput` with arbitrary miner public keys in `RealTimeMinersInformation`: [11](#0-10) 

- Single transaction through the public `NextRound` method: [12](#0-11) 

- No timing constraints or race conditions
- No need for coordination with other actors
- 100% success rate once validation is bypassed

**Feasibility:**
- **HIGH** - Miners rotate through NextRound responsibilities in every term
- Each miner gets multiple opportunities to execute the attack
- No detection mechanisms exist before commitment
- No economic barriers beyond being a current miner

## Recommendation

Add a miner list validation check in `ValidationForNextRound()` or create a dedicated validation provider:

```csharp
// In RoundTerminateValidationProvider.ValidationForNextRound()
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing validations
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // NEW: Validate miner list consistency
    var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.ToHashSet();
    var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.ToHashSet();
    
    if (!baseMiners.SetEquals(nextMiners))
        return new ValidationResult { Message = "Miner list mismatch between current and next round." };
    
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

This ensures the miner list invariant is enforced during NextRound transitions while allowing legitimate miner list changes to occur only through NextTerm transitions where proper election contract verification exists.

## Proof of Concept

```csharp
// POC: Malicious miner replaces entire miner list during NextRound
[Fact]
public async Task ConsensusHijack_NextRound_ArbitraryMinerList()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker is miner1 (legitimate current miner)
    var attacker = legitimateMiners[0];
    
    // Attacker waits for their NextRound time slot
    await AdvanceToNextRoundTimeSlot(attacker);
    
    // Construct malicious NextRoundInput with arbitrary miner keys
    var maliciousMiners = new[] { "attacker_key1", "attacker_key2", "attacker_key3" };
    var maliciousInput = CreateMaliciousNextRoundInput(
        currentRound: await GetCurrentRound(),
        maliciousMiners: maliciousMiners
    );
    
    // Execute attack - should fail but currently succeeds
    var result = await ConsensusContract.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Malicious miner list is now stored and enforced
    var newRound = await GetCurrentRound();
    var storedMiners = newRound.RealTimeMinersInformation.Keys.ToArray();
    
    // VULNERABILITY: Stored miners are the attacker's arbitrary keys
    storedMiners.ShouldBe(maliciousMiners);
    
    // IMPACT: Legitimate miners can no longer produce blocks
    foreach (var legit in legitimateMiners)
    {
        var canMine = newRound.IsInMinerList(legit);
        canMine.ShouldBeFalse(); // Legitimate miners locked out
    }
    
    // Attacker's keys now control consensus
    foreach (var malicious in maliciousMiners)
    {
        var canMine = newRound.IsInMinerList(malicious);
        canMine.ShouldBeTrue(); // Attacker's keys have mining permission
    }
}
```

**Notes:**
- This vulnerability breaks the fundamental security guarantee that miner list changes require proper election contract validation (which only occurs during NextTerm transitions)
- The validation gap exists because validators check sender permission against the current round but never validate the provided next round's miner list against the current round
- Post-execution validation cannot detect this because it compares state after the malicious data has already been committed
- The attack is permanent and cannot be reversed without protocol intervention

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-96)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
