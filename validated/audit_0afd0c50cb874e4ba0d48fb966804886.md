# Audit Report

## Title
Missing Validation for Empty Public Keys in Miner List Causes Consensus DoS

## Summary
The `MinerList.GenerateFirstRoundOfNewTerm` method accesses the first byte of miner public keys without validating that ByteStrings are non-empty. When an empty public key is present, the code throws an `IndexOutOfRangeException`, causing complete consensus failure. This vulnerability can be exploited through the `ReplaceCandidatePubkey` function when a candidate admin replaces an active miner's public key with an empty string. [1](#0-0) 

## Finding Description

The root cause lies in the miner sorting logic that directly accesses the first byte of each public key ByteString without validation. The vulnerable code creates a dictionary that extracts `miner[0]` for sorting purposes, which throws an `IndexOutOfRangeException` when the ByteString is empty.

**Runtime Attack Vector via Candidate Replacement:**

The `ReplaceCandidatePubkey` method performs multiple validations including candidate status, ban status, permissions, and duplicate checking, but critically does NOT validate that the new public key is non-empty or has a minimum length. [2](#0-1) 

The method proceeds to call `PerformReplacement`, which notifies the consensus contract without any length validation of the new public key. [3](#0-2) 

The consensus contract's `RecordCandidateReplacement` method updates the current round's miner information with the new public key, again without validating its length or format. [4](#0-3) 

**Propagation Through Term Transitions:**

During term transitions, when `TryToGetVictories` returns false (no new election winners), the system uses existing miners from the current round and converts their string public keys to ByteStrings. [5](#0-4) 

An empty string is converted to an empty ByteString through the hex conversion utility, which creates a zero-length byte array. When this empty ByteString is passed to `GenerateFirstRoundOfNewTerm`, the code attempts to access the first byte, triggering the exception. [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability causes complete consensus failure with catastrophic network-wide impact:

1. **Runtime Consensus DoS**: When exploited through candidate replacement while the candidate is an active miner, the chain cannot transition to new terms. The `IndexOutOfRangeException` prevents round generation entirely.

2. **No Automatic Recovery**: The exception occurs during critical consensus logic, preventing the generation of new rounds. The system cannot self-recover and requires emergency manual intervention to restore operations.

3. **Network-Wide Paralysis**: All validators cannot produce blocks, all users cannot submit transactions, and the entire blockchain network halts until the issue is manually resolved.

4. **Term Transition Failure**: The vulnerability specifically manifests during term transitions when the system attempts to sort miners by their public key's first byte.

The severity is **HIGH** because it represents complete operational failure of the consensus mechanism affecting all network participants simultaneously.

## Likelihood Explanation

**Runtime Attack Path (MEDIUM likelihood):**

- **Prerequisites**: The attacker must control the candidate admin address for an active miner (a candidate who is currently in the miner list producing blocks).

- **Attack Complexity**: LOW - Simply call the public `ReplaceCandidatePubkey` method with an empty string as the `new_pubkey` parameter.

- **Attack Scenarios**:
  - Malicious insider with legitimate candidate admin privileges
  - Compromised candidate admin account
  - Accidental misconfiguration by a legitimate admin

- **Detection**: None - No validation checks prevent empty public keys from being accepted by the contract.

- **Trigger Timing**: The consensus failure occurs at the next term transition when `TryToGetVictories` returns false and the system uses existing miners.

The overall probability is **MEDIUM** because while the candidate admin role is a legitimate privilege in the protocol, the attack is trivially executable once that role is obtained, and there are no safeguards to prevent empty public keys.

## Recommendation

Add comprehensive validation for public key length in multiple locations:

1. **In `ReplaceCandidatePubkey`**: Validate that `input.NewPubkey` is not empty and has a valid minimum length (e.g., 33 bytes for compressed public keys or 65 bytes for uncompressed).

```csharp
Assert(!string.IsNullOrEmpty(input.NewPubkey), "New pubkey cannot be empty.");
var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
Assert(newPubkeyBytes.Length >= 33, "New pubkey must be at least 33 bytes.");
```

2. **In `RecordCandidateReplacement`**: Add defensive validation before updating round information.

```csharp
Assert(!string.IsNullOrEmpty(input.NewPubkey), "New pubkey cannot be empty.");
```

3. **In `GenerateFirstRoundOfNewTerm`**: Add defensive check before accessing first byte.

```csharp
var sortedMiners =
    (from obj in Pubkeys.Where(pk => pk.Length > 0)
            .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
        orderby obj.Value descending
        select obj.Key).ToList();
Assert(sortedMiners.Count > 0, "No valid miners found.");
```

4. **Genesis validation**: Ensure all elements in `InitialMinerList` are validated, not just the first element.

## Proof of Concept

```csharp
// Test: EmptyPubkeyInReplaceCandidateCausesConsensusDoS
// 1. Deploy chain with valid initial miners
// 2. Register a candidate and have them become an active miner
// 3. Call ReplaceCandidatePubkey with empty string as new_pubkey
// 4. Trigger term transition when TryToGetVictories returns false
// 5. Observe IndexOutOfRangeException in GenerateFirstRoundOfNewTerm
// 6. Verify consensus is halted and no new rounds can be generated

[Fact]
public async Task EmptyPubkeyInReplaceCandidateCausesConsensusDoS()
{
    // Setup: Initialize chain with valid miner
    var initialMinerKeyPair = SampleAccount.Accounts[0].KeyPair;
    var candidateKeyPair = SampleAccount.Accounts[1].KeyPair;
    
    // Register candidate and make them an active miner
    await ElectionContractStub.AnnounceElection.SendAsync(new Empty());
    // ... election logic to make candidate an active miner ...
    
    // Attack: Replace active miner's pubkey with empty string
    var result = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = candidateKeyPair.PublicKey.ToHex(),
            NewPubkey = "" // Empty string
        });
    
    // Trigger term transition
    await NextTerm(AEDPoSContractStub);
    
    // Assert: Consensus should fail with IndexOutOfRangeException
    // The exception will occur when GenerateFirstRoundOfNewTerm tries to access miner[0]
}
```

## Notes

The vulnerability is confirmed through direct code examination of all execution paths. The runtime attack vector through `ReplaceCandidatePubkey` is particularly concerning because it can be triggered by any malicious or compromised candidate admin without requiring extraordinary privileges. The lack of input validation at multiple layers (Election contract, Consensus contract, and MinerList processing) creates a complete failure path that results in network-wide consensus DoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-191)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-302)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L234-242)
```csharp
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** src/AElf.Types/Helper/ByteStringHelper.cs (L21-24)
```csharp
        public static ByteString FromHexString(string hexString)
        {
            return ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(hexString));
        }
```
