# Audit Report

## Title
Strict Inequality in Debt Repayment Logic Prevents Side Chain Creators from Clearing Exact Debt Balances

## Summary
The `PayRental()` function uses strict inequality (`>`) instead of (`>=`) when checking if a creator's balance can cover existing debt, preventing debt repayment when the balance exactly equals the debt amount. This forces side chain creators to maintain balances strictly greater than their debt to clear it, creating an unnecessary barrier to debt resolution. [1](#0-0) 

## Finding Description

The vulnerability exists in the debt repayment conditional at line 1051 of `PayRental()`. The function only attempts to pay off accumulated rental debt when `availableBalance > owningRental` (strict inequality), rather than `availableBalance >= owningRental`.

**Critical Code Path:**
When a side chain creator's balance exactly equals their accumulated debt, the repayment logic is completely bypassed: [2](#0-1) 

**Concrete Example:**
- Creator has balance = 100, accumulated debt = 100, new rental charge = 80
- Line 1051 evaluates: `100 > 100` = FALSE → debt repayment block skipped
- Line 1062 evaluates: `100 >= 80` = TRUE → pays current rental of 80
- **Result:** Balance = 20, Debt = 100 (unchanged)
- **Expected:** Balance = 0, Debt = 80 (old debt cleared, new rental becomes debt)

The creator had exactly enough funds to clear their entire debt but was prevented from doing so by the strict inequality. Instead, they paid only the current rental, leaving the old debt of 100 untouched while depleting their balance to 20.

**System Context:**
The `PayRental()` function is invoked automatically every minute via `DonateResourceToken()`, which is a system transaction that processes resource token donations on side chains: [3](#0-2) 

**Test Evidence:**
The existing test suite confirms this behavior when balance is insufficient to exceed debt: [4](#0-3) 

This test shows that with 1 token issued against a debt of 400, after one rental period (400 charge), the final debt becomes 799 (400 old + 399 new), confirming that when balance ≤ debt, old debt is never reduced.

## Impact Explanation

**Primary Impact - Exact Balance Scenario:**
When a creator's balance precisely matches their debt (e.g., both = 100), they cannot clear the debt despite having sufficient funds. This violates the fundamental principle that exact repayment should satisfy debt obligations.

**Secondary Impact - Debt Spiral:**
Once debt exceeds available balance, and if periodic balance additions remain below debt levels, the debt grows unboundedly:
- Period 1: Debt=60, Add 50, Pay 50 towards rental (80), Debt=90
- Period 2: Debt=90, Add 50, 50 > 90? NO → Pay 50 towards rental (80), Debt=120
- Period 3: Debt=120, Add 50, 50 > 120? NO → Pay 50 towards rental (80), Debt=150

The debt increases by 30 each period indefinitely, with no mechanism for gradual reduction through partial payments.

**Affected Parties:**
- Side chain creators paying rental fees for CPU, RAM, DISK, and NET resources
- Economic impact: creators pay rental charges but cannot reduce accumulated debt when balance = debt
- Operational impact: forces creators to always maintain balance strictly > debt, not just ≥ debt

**Severity Assessment:**
This is a **Medium** severity issue because:
1. Concrete financial harm to legitimate users (side chain creators)
2. Automatic trigger through system operations (no attacker needed)
3. Common scenario: balance fluctuations naturally create exact-match situations
4. No workaround except maintaining perpetual excess balance
5. However, does not result in fund theft, only inefficient debt management

## Likelihood Explanation

**Trigger Mechanism:**
- `DonateResourceToken()` is called automatically every block as a system transaction
- Only executable by current miners (validated via `AssertSenderIsCurrentMiner()`)
- Automatically invokes `PayRental()` for all side chains every minute (60-second intervals) [5](#0-4) 

**Occurrence Probability:**
**HIGH** - This occurs in normal operations whenever:
1. A creator's balance drops to exactly equal their debt (common during fluctuations)
2. A creator attempts to deposit precisely enough to cover debt
3. Automatic balance adjustments result in exact matches

**No Attacker Required:**
This is an inherent logic flaw in the debt repayment algorithm, not an attack vector. It affects all side chain creators during routine operations.

**Feasibility:**
100% feasible - demonstrated by existing test case and occurs automatically through system transactions every minute.

## Recommendation

**Fix: Change Strict Inequality to Inclusive Inequality**

Modify line 1051 to use `>=` instead of `>`:

```csharp
// Before (vulnerable):
if (availableBalance > owningRental)

// After (fixed):
if (availableBalance >= owningRental)
```

This allows debt repayment when balance exactly equals debt, enabling creators to clear their obligations with precise payments.

**Complete Fix Location:** [6](#0-5) 

**Alternative Enhancement:**
For a more robust solution that also handles partial debt reduction when balance < debt, consider:

```csharp
if (owningRental > 0 && availableBalance > 0)
{
    var paymentTowardDebt = Math.Min(availableBalance, owningRental);
    donates = paymentTowardDebt;
    availableBalance = availableBalance.Sub(paymentTowardDebt);
    State.OwningRental[symbol] = owningRental.Sub(paymentTowardDebt);
}
```

This would allow partial debt payments, preventing unbounded debt accumulation even when balance remains below debt levels.

## Proof of Concept

The vulnerability can be demonstrated by extending the existing test suite with a scenario where balance exactly equals debt:

```csharp
[Fact]
public async Task PayDebtTest_ExactBalance()
{
    await OwnResourceTest();  // Creates debt of 400 for each resource
    
    // Issue exactly 400 tokens to match debt
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "CPU",
        To = Creator,
        Amount = 400  // Exactly matches debt
    });
    
    await DelayOneMinuteAsync();  // Triggers PayRental with 400 charge
    
    var owningRental = await TokenContractStub.GetOwningRental.CallAsync(new Empty());
    
    // BUG: Debt should be 400 (new rental) after clearing old debt of 400
    // ACTUAL: Debt remains at 400 (old debt unchanged)
    owningRental.ResourceAmount["CPU"].ShouldBe(400);  // Old debt persists
    
    var balance = await GetCreatorBalanceOfAsync("CPU");
    balance.ShouldBe(0);  // Balance fully consumed by rental, but debt not cleared
}
```

**Expected Behavior (with fix):**
- Old debt (400) cleared with available balance (400)
- New rental (400) becomes new debt
- Final state: balance=0, debt=400 (new)

**Actual Behavior (current bug):**
- Old debt (400) skipped due to strict inequality
- Current rental (400) paid from balance
- Final state: balance=0, debt=400 (old, unchanged)

**Notes**

The core vulnerability is specifically in Scenario 1 where balance == debt. While the claim also discusses Scenario 2 (balance < debt causing a "debt spiral"), the total debt calculation in that scenario is mathematically correct (old debt + unpaid new rental). The real issue is that when balance exactly matches debt, the creator cannot clear it despite having sufficient funds. The strict inequality forces creators to always maintain balance > debt rather than ≥ debt, which is an unnecessary restriction that violates standard debt repayment expectations.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L947-950)
```csharp
        if (!isMainChain)
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1030-1038)
```csharp
        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1048-1059)
```csharp
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L173-192)
```csharp
    public async Task PayDebtTest_NotEnough()
    {
        await OwnResourceTest();

        // Charge
        foreach (var symbol in Symbols)
            await TokenContractStub.Issue.SendAsync(new IssueInput
            {
                Symbol = symbol,
                To = Creator,
                Amount = 1
            });

        await DelayOneMinuteAsync();

        var owningRental = await TokenContractStub.GetOwningRental.CallAsync(new Empty());
        owningRental.ResourceAmount["CPU"].ShouldBe(CpuAmount * Rental * 2 - 1);
        owningRental.ResourceAmount["RAM"].ShouldBe(RamAmount * Rental * 2 - 1);
        owningRental.ResourceAmount["DISK"].ShouldBe(DiskAmount * Rental * 2 - 1);
        owningRental.ResourceAmount["NET"].ShouldBe(NetAmount * Rental * 2 - 1);
```
