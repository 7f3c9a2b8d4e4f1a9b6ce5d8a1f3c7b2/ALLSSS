# Audit Report

## Title
Missing Authorization Check in Secret Sharing Allows Malicious Miners to Corrupt Consensus InValue Reconstruction

## Summary
The `PerformSecretSharing` function in the AEDPoS consensus contract does not validate whether a miner was authorized to decrypt secret pieces before accepting their `DecryptedPieces` input. A malicious miner can inject arbitrary decrypted values, corrupting the Shamir's Secret Sharing reconstruction used for consensus InValue recovery.

## Finding Description

The vulnerability exists in the `PerformSecretSharing` function which blindly accepts any entries in `input.DecryptedPieces` without verifying authorization. [1](#0-0) 

The function iterates through all provided `DecryptedPieces` and stores them in target miners' state without checking if those target miners actually encrypted pieces for the current miner in the previous round. The expected validation would verify `previousRound.RealTimeMinersInformation[targetMinerKey].EncryptedPieces.ContainsKey(publicKey)` before accepting each decrypted piece.

**Why Existing Protections Fail:**

The `PreCheck` function only validates that the sender is in the current or previous miner list, not whether specific decryption operations are authorized. [2](#0-1) 

The off-chain `SecretSharingService` correctly implements authorization checks when generating legitimate decrypted pieces: [3](#0-2) 

However, the on-chain contract does not enforce this validation, allowing malicious miners to bypass off-chain checks by crafting custom `UpdateValueInput` transactions directly.

**Execution Path:**

1. Malicious miner calls the public `UpdateValue` method: [4](#0-3) 

2. The transaction is processed and reaches `PerformSecretSharing` which stores the malicious `DecryptedPieces` without validation: [5](#0-4) 

3. Later, when `RevealSharedInValues` is invoked during NextRound preparation, it uses all accumulated `DecryptedPieces` (including malicious ones) to reconstruct InValues: [6](#0-5) 

4. The Shamir's Secret Sharing reconstruction uses the corrupted pieces: [7](#0-6) 

5. The incorrect InValue fails validation against the victim's previous OutValue during consensus validation: [8](#0-7) 

## Impact Explanation

**HIGH Severity** - This vulnerability breaks critical consensus integrity guarantees:

**Consensus Disruption:** A malicious miner can inject false decrypted pieces for any victim miner, causing the Shamir's Secret Sharing reconstruction to produce an incorrect InValue. This corrupted InValue will fail the validation check `HashHelper.ComputeFrom(previousInValue) == previousOutValue`, making honest victims appear to have provided invalid consensus data.

**Concrete Harm:**
- **Consensus Integrity Violation:** Incorrect InValue reconstruction breaks the secret sharing protocol that ensures consensus security
- **Randomness Corruption:** Since InValues feed into random number generation for consensus, this compromises the randomness source used throughout the protocol
- **False Accusations:** Honest miners appear malicious due to validation failures, potentially triggering penalties or evil node marking: [9](#0-8) 

- **Operational DoS:** Systematic attacks across multiple rounds could prevent consensus progress by causing repeated validation failures

**Who Is Affected:** All honest miners in the consensus set can become victims. The protocol's consensus integrity and randomness guarantees are fundamentally compromised.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** - The attack is straightforward to execute:

**Attacker Capabilities:** Any miner in the consensus set can execute this attack. No special privileges beyond being an active miner are required.

**Attack Complexity:** LOW
- Attacker crafts an `UpdateValueInput` message with arbitrary `DecryptedPieces` entries
- Submits via the public `UpdateValue` method that all miners use
- No complex state manipulation or precise timing requirements needed
- The attack is undetectable at submission time since the contract accepts any values

**Feasibility Conditions:**
- Attacker must be a valid miner (passes `PreCheck`)
- Secret sharing must be enabled via configuration
- Attack is repeatable every round against any target miner

**Detection Constraints:** The malicious submission appears identical to legitimate consensus updates at transaction submission time. The corruption only becomes apparent later during InValue reconstruction and validation, by which point the malicious data has been committed to state.

**Economic Rationality:** The attack costs no more than a normal `UpdateValue` transaction (standard gas fees). The attacker gains the ability to disrupt consensus and harm competitors' reputations at minimal cost.

## Recommendation

Add authorization validation in the `PerformSecretSharing` function to verify that each target miner actually encrypted a piece for the current miner in the previous round before accepting the decrypted piece.

The fix should check: `previousRound.RealTimeMinersInformation[targetMinerKey].EncryptedPieces.ContainsKey(publicKey)` for each entry in `input.DecryptedPieces` before storing it.

## Proof of Concept

A proof of concept would involve:
1. Deploy a test network with multiple miners and secret sharing enabled
2. Have a malicious miner submit an `UpdateValue` transaction with fabricated `DecryptedPieces` entries for a victim miner
3. Verify that these malicious pieces are stored in the round state without validation
4. Trigger a NextRound transition and observe that `RevealSharedInValues` uses the corrupted pieces
5. Demonstrate that the reconstructed InValue is incorrect and causes validation failures for the victim

The test would confirm that the missing authorization check allows arbitrary DecryptedPieces injection, corrupting the secret sharing protocol.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L148-152)
```csharp
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L116-123)
```csharp
            if (secretSharingInformation.PreviousRound.RealTimeMinersInformation.ContainsKey(selfPubkey) &&
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[selfPubkey].EncryptedPieces
                    .ContainsKey(pubkey))
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[selfPubkey]
                        .EncryptedPieces[pubkey]
                    = ByteString.CopyFrom(encryptedPiece);
            else
                continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```
