# Audit Report

## Title
Seed NFT Expiration Time Overflow Enables Permanent Symbol Monopolization

## Summary
The `ExtendSeedExpirationTime` method in the MultiToken contract accepts arbitrary expiration time values without bounds validation, allowing seed NFT owners to set expiration times to extreme values like `long.MaxValue`. This permanently monopolizes symbol names by blocking new seed creation and enabling indefinite seed validity, constituting a denial of service attack on the protocol's symbol namespace.

## Finding Description

The vulnerability exists in the `ExtendSeedExpirationTime` method which only validates that the caller is the seed owner but performs no validation on the expiration time value itself. [1](#0-0) 

When a seed owner sets `ExpirationTime = long.MaxValue` (9223372036854775807), this value is stored directly in the token's external information without any bounds checking. This breaks two critical validation mechanisms:

**1. CheckSymbolSeed - Permanently Blocks New Seed Creation:**

When attempting to create a new seed for a symbol that already has an existing seed, the `CheckSymbolSeed` method validates whether the old seed has expired by checking `Context.CurrentBlockTime.Seconds > symbolSeedExpireTime`. [2](#0-1) 

With expiration set to `long.MaxValue`, the condition `Context.CurrentBlockTime.Seconds > 9223372036854775807` will never be true (representing approximately year 292 billion), causing the assertion to permanently fail with "OwnedSymbol has been created". This prevents anyone from ever creating a new seed for that symbol.

**2. CheckSeedNFT - Enables Indefinite Seed Validity:**

When using a seed to create a token, the `CheckSeedNFT` method validates that the seed hasn't expired by checking `Context.CurrentBlockTime.Seconds <= expirationTimeLong`. [3](#0-2) 

With `long.MaxValue`, this condition always evaluates to true, allowing the seed to be used indefinitely without ever expiring.

The method is publicly accessible as an RPC endpoint, requiring only seed ownership. [4](#0-3) 

## Impact Explanation

This vulnerability enables **permanent denial of service on the symbol namespace**, which is a critical protocol resource:

- **Irreversible Symbol Monopolization**: Attackers can indefinitely reserve valuable symbol names (e.g., common words, brand names, ticker symbols), blocking legitimate users from creating tokens with those symbols
- **No Recovery Mechanism**: There is no administrative function to force-expire seeds, clear symbol mappings, or override expiration times. Only a contract upgrade could remediate this issue
- **Protocol Invariant Violation**: The system's security model assumes that expired seeds become available for new creation, but maximum expiration values effectively create permanent reservations
- **Namespace Fragmentation**: The attack creates a permanently polluted namespace with reserved but potentially unused symbols, degrading the ecosystem's ability to support new projects and token launches

While this does not directly steal funds or inflate supply, it permanently damages the availability of a finite, critical protocol resource and breaks fundamental assumptions about seed lifecycle management.

## Likelihood Explanation

The vulnerability has **high likelihood** of exploitation:

**Minimal Prerequisites:**
- Attacker only needs seed ownership, acquirable through normal creation or secondary market purchase
- No special privileges, governance approval, or elevated permissions required
- The method is a standard public RPC function accessible to any seed owner

**Trivial Execution:**
- Single transaction with `ExpirationTime = 9223372036854775807`
- No complex state manipulation, timing windows, or multi-step coordination required
- Attack succeeds with 100% reliability
- No rate limiting, cooldown periods, or validation constraints exist

**Economic Rationality:**
- Attack cost is minimal (transaction fee + seed acquisition cost)
- Potential value is high for desirable symbols that could be monetized or provide competitive advantage
- Rational strategy for symbol squatting in anticipation of ecosystem growth
- Attack remains undetected until someone attempts to create a new seed for the monopolized symbol

## Recommendation

Implement bounds validation in the `ExtendSeedExpirationTime` method to enforce a maximum reasonable expiration time:

```csharp
public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
{
    var tokenInfo = GetTokenInfo(input.Symbol);
    if (tokenInfo == null)
    {
        throw new AssertionException("Seed NFT does not exist.");
    }

    Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
    
    // Add validation: Maximum expiration time (e.g., 10 years from now)
    var maxAllowedExpiration = Context.CurrentBlockTime.AddYears(10).Seconds;
    Assert(input.ExpirationTime <= maxAllowedExpiration, 
        "Expiration time exceeds maximum allowed duration.");
    
    // Optional: Ensure new expiration is later than current block time
    Assert(input.ExpirationTime > Context.CurrentBlockTime.Seconds,
        "Expiration time must be in the future.");
    
    var oldExpireTimeLong = 0L;
    if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
            out var oldExpireTime))
    {
        long.TryParse(oldExpireTime, out oldExpireTimeLong);
    }

    tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
        input.ExpirationTime.ToString();
    State.TokenInfos[input.Symbol] = tokenInfo;
    
    Context.Fire(new SeedExpirationTimeUpdated
    {
        ChainId = tokenInfo.IssueChainId,
        Symbol = input.Symbol,
        OldExpirationTime = oldExpireTimeLong,
        NewExpirationTime = input.ExpirationTime
    });
    return new Empty();
}
```

Additionally, consider implementing an administrative override mechanism (controlled by Parliament) to force-expire monopolized seeds in emergency situations.

## Proof of Concept

```csharp
[Fact]
public async Task SeedExpirationOverflow_PermanentMonopolization_Test()
{
    // Step 1: Create a seed NFT for a desirable symbol "PREMIUM"
    var seedInput = BuildSeedCreateInput(new CreateInput
    {
        Symbol = "PREMIUM",
        TokenName = "Premium Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IssueChainId = _chainId,
        Owner = DefaultAddress
    });
    
    var seedSymbol = seedInput.Symbol; // e.g., "SEED-1"
    await TokenContractStub.Create.SendAsync(seedInput);
    
    // Step 2: Attacker extends expiration to long.MaxValue
    var extendResult = await TokenContractStub.ExtendSeedExpirationTime.SendAsync(
        new ExtendSeedExpirationTimeInput
        {
            Symbol = seedSymbol,
            ExpirationTime = long.MaxValue // 9223372036854775807
        });
    extendResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Verify the seed now has maximum expiration
    var seedInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput 
    { 
        Symbol = seedSymbol 
    });
    seedInfo.ExternalInfo.Value["__seed_exp_time"].ShouldBe(long.MaxValue.ToString());
    
    // Step 4: Attempt to create a new seed for "PREMIUM" by another user
    var user1Stub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, User1KeyPair);
    
    var newSeedInput = BuildSeedCreateInput(new CreateInput
    {
        Symbol = "PREMIUM",
        TokenName = "Premium Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = User1Address,
        IssueChainId = _chainId,
        Owner = User1Address
    });
    
    // Step 5: Verify new seed creation is permanently blocked
    var result = await user1Stub.Create.SendWithExceptionAsync(newSeedInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("OwnedSymbol has been created");
    
    // Step 6: Verify the monopolized seed never expires and can be used indefinitely
    // Even after advancing time significantly, the seed remains valid
    var premiumTokenInput = new CreateInput
    {
        Symbol = "PREMIUM",
        TokenName = "Premium Token", 
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IssueChainId = _chainId,
        Owner = DefaultAddress
    };
    
    var createResult = await TokenContractStub.Create.SendAsync(premiumTokenInput);
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Symbol "PREMIUM" is now permanently claimed, and no one can create a new seed for it
}
```

## Notes

This vulnerability demonstrates a critical flaw in input validation that enables resource exhaustion attacks. The symbol namespace is a finite, valuable protocol resource, and the lack of bounds checking on expiration times allows malicious actors to permanently monopolize desirable symbols. The attack is economically rational for valuable symbol names and has no recovery mechanism short of a contract upgrade, making it a high-severity issue despite not involving direct fund theft.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L57-67)
```csharp
    private void CheckSymbolSeed(string ownedSymbol)
    {
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];

        Assert(oldSymbolSeed == null || !GetTokenInfo(oldSymbolSeed).ExternalInfo.Value
                   .TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var oldSymbolSeedExpireTime) ||
               !long.TryParse(oldSymbolSeedExpireTime, out var symbolSeedExpireTime)
               || Context.CurrentBlockTime.Seconds > symbolSeedExpireTime,
            "OwnedSymbol has been created");
    }
```

**File:** protobuf/token_contract_impl.proto (L195-196)
```text
    rpc ExtendSeedExpirationTime (ExtendSeedExpirationTimeInput) returns (google.protobuf.Empty) {
    }
```
