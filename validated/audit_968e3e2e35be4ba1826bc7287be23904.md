# Audit Report

## Title
DepositBalance Accounting Underflow in Sell() Due to Virtual Balance Pricing Discrepancy

## Summary
The TokenConverter's `Sell()` function uses Bancor pricing that includes both virtual and real deposit balances, but only subtracts from the real `DepositBalance` state variable. With production-configured virtual balances of 10 million tokens and small real deposits, the calculated return can exceed available real balance, causing SafeMath to throw `OverflowException` and revert transactions. This creates a critical denial-of-service where users cannot sell resource tokens and their capital becomes locked.

## Finding Description

The vulnerability stems from an architectural mismatch between the pricing and accounting layers in the TokenConverter contract.

**Pricing Layer - Uses Combined Balance:**

When calculating sell returns, the `Sell()` function calls `GetSelfBalance()` for the deposit connector (the "toConnector" in the sell operation): [1](#0-0) 

The `GetSelfBalance()` method returns the sum of virtual and real balances for deposit accounts with `IsVirtualBalanceEnabled=true`: [2](#0-1) 

This combined balance is fed into the Bancor formula to calculate `amountToReceive`: [3](#0-2) 

**Accounting Layer - Uses Only Real Balance:**

After calculating the return amount, the contract attempts to subtract it from the real `DepositBalance` only, completely ignoring that the virtual balance was included in the pricing calculation: [4](#0-3) 

**Why SafeMath Doesn't Prevent the Issue:**

The SafeMath `Sub()` operation uses checked arithmetic that throws `OverflowException` on underflow, preventing silent corruption but converting the bug into a denial-of-service condition.

**Production Configuration:**

Deposit connectors are initialized with large virtual balances in production. The test base configuration uses `NativeVirtualBalance = 1_000_000_00000000` (10 million tokens with 8 decimals): [5](#0-4) 

The deposit connector is created with `IsVirtualBalanceEnabled=true` and `IsDepositAccount=true`: [6](#0-5) 

**Execution Scenario:**
1. Connector pair created with 10 million token virtual balance
2. `EnableConnector` called, setting small real deposit (calculated by `GetNeededDeposit`)
3. User attempts to sell moderate/large amount of resource tokens
4. Bancor calculates return based on (10M virtual + small real) balance
5. If calculated return > real deposit balance, `Sub()` throws exception
6. Transaction reverts - user cannot sell tokens

## Impact Explanation

**Critical Denial-of-Service Impact:**

This vulnerability causes complete failure of the token selling mechanism, a core protocol function. Users who purchase resource tokens through the `Buy()` function cannot sell them back when the Bancor-calculated return exceeds the real deposit balance.

**Fund Lockup:**
User capital becomes permanently locked in resource tokens with no exit path through the TokenConverter contract. While users technically still own their tokens, the intended liquidity mechanism is broken.

**Protocol Integrity:**
The Bancor-based resource token market fails to function as designed. The virtual balance mechanism, intended to bootstrap liquidity, is fundamentally incompatible with the accounting system, breaking the core economic model.

**Affected Parties:**
- All resource token holders attempting to exit positions
- The broader AElf ecosystem relying on functional resource markets
- Protocol reputation as the core conversion mechanism is non-functional

The severity is **CRITICAL** because:
- Complete DoS of core functionality (selling) under normal conditions
- Affects all users equally - not just attacker-controlled scenarios  
- Occurs with standard production configuration values (10M token virtual balance)
- No user-accessible workaround exists
- Requires contract upgrade to resolve

## Likelihood Explanation

**High Likelihood of Occurrence:**

The `Sell()` function is a public method directly callable by any user: [7](#0-6) 

**Realistic Preconditions:**
- Virtual balances enabled by default in production configurations
- Virtual balance set to extremely large values (10,000,000 tokens)
- Real deposit balances start small (calculated from `GetNeededDeposit`) and grow only incrementally through buy operations
- No special privileges required - any token holder can trigger this

**Natural Occurrence:**
This vulnerability triggers during normal protocol usage without any malicious intent:
1. After `EnableConnector`, real deposit is small while virtual balance is 10 million tokens
2. User performs legitimate sell operation with moderate to large amount
3. Bancor formula calculates return based on inflated (virtual + real) balance
4. If return exceeds real balance, transaction automatically reverts

**Economic Rationality:**
- Zero attack cost - happens during legitimate usage
- Cannot be prevented by users since pricing is protocol-determined
- Affects all participants equally
- Detection is immediate (transaction failure) but resolution requires governance intervention and contract upgrade

The likelihood is **HIGH** because the vulnerability is architectural and occurs naturally under standard operating conditions with production configuration values.

## Recommendation

**Immediate Fix:**

The accounting layer must be made consistent with the pricing layer. When subtracting from deposit balance, account for whether virtual balances were included in the pricing calculation.

**Option 1: Subtract from Combined Accounting (Recommended)**
Track virtual balance usage separately and allow it to be "depleted" during sells:
```csharp
// In Sell() function, after calculating amountToReceive:
if (toConnector.IsVirtualBalanceEnabled && toConnector.VirtualBalance > 0)
{
    // Deplete virtual balance first, then real balance
    var fromVirtual = Math.Min(amountToReceive, toConnector.VirtualBalance);
    toConnector.VirtualBalance = toConnector.VirtualBalance.Sub(fromVirtual);
    var fromReal = amountToReceive.Sub(fromVirtual);
    State.DepositBalance[toConnector.Symbol] = State.DepositBalance[toConnector.Symbol].Sub(fromReal);
}
else
{
    State.DepositBalance[toConnector.Symbol] = State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
}
```

**Option 2: Exclude Virtual Balance from Pricing**
Modify `GetSelfBalance()` to not include virtual balance in sell calculations, or use separate methods for buy vs. sell pricing.

**Option 3: Validate Before Subtraction**
Add explicit validation that calculated return doesn't exceed real balance:
```csharp
Assert(amountToReceive <= State.DepositBalance[toConnector.Symbol], 
    "Insufficient real deposit balance to fulfill sell order");
```
This would convert the issue to an explicit error message but wouldn't fix the underlying architectural problem.

**Long-term Solution:**
Re-architect the virtual balance mechanism to be consistent across pricing and accounting layers, potentially by maintaining separate virtual and real balance pools with explicit conversion rules.

## Proof of Concept

```csharp
[Fact]
public async Task Sell_With_Large_Virtual_Balance_Causes_Underflow_Test()
{
    // Setup: Create token and initialize converter with LARGE virtual balance
    await CreateWriteToken();
    await InitializeTreasuryContractAsync();
    
    // Initialize with deposit connector having 10M virtual balance (production config)
    var largeVirtualBalance = 10_000_000_00000000L; // 10 million tokens
    var ntWriteConnector = new Connector
    {
        Symbol = "NTWRITE",
        VirtualBalance = largeVirtualBalance,
        Weight = "0.5",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "WRITE",
        IsDepositAccount = true
    };
    
    var writeConnector = new Connector
    {
        Symbol = "WRITE",
        VirtualBalance = 0,
        Weight = "0.5",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = false,
        RelatedSymbol = "NTWRITE",
        IsDepositAccount = false
    };
    
    await DefaultStub.Initialize.SendAsync(new InitializeInput
    {
        BaseTokenSymbol = "ELF",
        FeeRate = "0.005",
        Connectors = { writeConnector, ntWriteConnector }
    });
    
    await PrepareToBuyAndSell();
    
    // User buys small amount - adds small real deposit
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = "WRITE",
        Amount = 1000L,
        PayLimit = 10000L
    });
    
    // Get real deposit balance after buy (will be small, e.g., ~1000-2000)
    var realDeposit = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "WRITE" });
    
    // realDeposit.Value will be around largeVirtualBalance + small_amount
    // But State.DepositBalance["NTWRITE"] is only the small_amount
    
    // Now user tries to sell - Bancor calculates return based on (10M + small) balance
    // But accounting only has the small real deposit
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = "WRITE",
        Amount = 1000L,
        ReceiveLimit = 0L
    });
    
    // VULNERABILITY: Transaction reverts with OverflowException
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    sellResult.TransactionResult.Error.ShouldContain("Overflow");
}
```

This test demonstrates that with production-configured virtual balances, the sell operation fails with an overflow exception because the Bancor-calculated return exceeds the real deposit balance available for withdrawal.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-108)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-162)
```csharp
    public override Empty Sell(SellInput input)
    {
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** test/AElf.Contracts.Economic.TestBase/ContractsPreparation.cs (L595-602)
```csharp
            await SetConnector(new PairConnectorParam
            {
                ResourceConnectorSymbol = EconomicContractsTestConstants.TransactionFeeChargingContractTokenSymbol,
                ResourceWeight = "0.05",
                NativeWeight = "0.05",
                NativeVirtualBalance = 1_000_000_00000000
            });
        }
```
