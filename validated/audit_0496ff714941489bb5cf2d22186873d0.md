# Audit Report

## Title
ProfitDetail ID Collision Causes Transaction Failure in FixProfitDetail and RemoveBeneficiary

## Summary
The Profit contract allows multiple ProfitDetail entries with identical IDs to exist for the same beneficiary. When `FixProfitDetail` or `RemoveBeneficiary` attempts to operate on these duplicate entries using `.SingleOrDefault()` or `.Single()` LINQ methods, they throw `InvalidOperationException`, causing permanent DoS. This occurs in legitimate scenarios where Election candidates quit and rejoin, making profit detail management impossible for affected beneficiaries and voters.

## Finding Description

The vulnerability exists because `AddBeneficiary` does not validate for duplicate ProfitDetail IDs before adding new entries. [1](#0-0) 

When the Election contract manages backup subsidies, it generates deterministic IDs based on candidate pubkey and beneficiary address using a hash concatenation that always produces the same result for the same inputs. [2](#0-1) 

The Subsidy profit scheme is created with `CanRemoveBeneficiaryDirectly = true`, allowing direct removal of beneficiaries. [3](#0-2) 

When a candidate quits election, the system calls `RemoveBeneficiary` which invokes `RemoveProfitDetails`. This method marks `IsWeightRemoved = true` but does NOT physically delete the ProfitDetail entry from storage if `LastProfitPeriod < CurrentPeriod`. [4](#0-3) 

When the candidate rejoins election (which is allowed per the contract logic), `AddBeneficiary` is called again with the same deterministic subsidyId. [5](#0-4) [6](#0-5) 

This creates a NEW ProfitDetail with the SAME subsidyId, since `AddBeneficiary` performs no duplicate ID validation before adding the new detail to the list. [7](#0-6) 

Subsequently, when `FixProfitDetail` is called (e.g., when a voter extends their voting period via `ExtendVoterWelfareProfits` in `ChangeVotingOption`), it uses `.SingleOrDefault()` which throws `InvalidOperationException` when multiple ProfitDetails have the same ID. [8](#0-7) [9](#0-8) 

Similarly, `RemoveBeneficiary` can fail when duplicate IDs exist and certain removal conditions are met, as `RemoveProfitDetails` uses `.Single()` which also throws when multiple matching elements exist. [10](#0-9) 

The C# LINQ `.SingleOrDefault()` and `.Single()` methods throw `InvalidOperationException` when the sequence contains more than one matching element. This breaks the security guarantee that profit detail management operations should complete successfully for valid beneficiaries.

## Impact Explanation

**Operational DoS**: Beneficiaries with duplicate ProfitDetail IDs cannot have their profit details fixed or removed. Transactions calling `FixProfitDetail` or `RemoveBeneficiary` will fail with unhandled exceptions.

**Affected Users**:
- Election candidates who quit and rejoin: their subsidy ProfitDetails become permanently unmanageable
- Voters who voted for such candidates: cannot extend voting periods via `ChangeVotingOption` with `IsResetVotingTime=true`, as this internally calls `FixProfitDetail`
- Any beneficiary in schemes where deterministic ProfitDetailIds are reused

**Severity**: HIGH - This creates permanent DoS for core profit distribution operations. Once duplicate IDs exist in the system, critical profit management operations become impossible. This affects legitimate users performing normal protocol operations (quit/rejoin election, extend voting periods). The state corruption is permanent and cannot be recovered without scheme manager intervention.

## Likelihood Explanation

**Likelihood**: HIGH - This occurs through normal, intended user operations:

1. **No Attack Required**: Any candidate who quits and rejoins election triggers this condition through normal protocol flow. Quitting is handled by `QuitElection` and rejoining by `AnnounceElection`. [11](#0-10) [12](#0-11) 

2. **Realistic Preconditions**: The Election contract is the manager of the subsidy scheme and routinely calls these methods as part of normal candidate lifecycle management. [13](#0-12) 

3. **Execution Certainty**: Once duplicate IDs exist, calling `FixProfitDetail` or `RemoveBeneficiary` with specific conditions WILL throw `InvalidOperationException` - this is guaranteed by .NET LINQ behavior.

4. **Already Occurring**: The code paths that create this state are actively used in production. The deterministic ID generation combined with the soft-delete pattern creates duplicate IDs by design whenever candidates quit and rejoin.

The vulnerability is not theoretical - it's a state that the system actively creates through normal operations.

## Recommendation

Add duplicate ID validation in `AddBeneficiary` before adding a new ProfitDetail. The fix should check if a ProfitDetail with the same ID already exists and either reject the addition or remove/update the existing entry first.

Recommended fix in `ProfitContract.cs`:

```csharp
public override Empty AddBeneficiary(AddBeneficiaryInput input)
{
    AssertValidInput(input);
    if (input.EndPeriod == 0)
        input.EndPeriod = long.MaxValue;

    var schemeId = input.SchemeId;
    var scheme = State.SchemeInfos[schemeId];
    Assert(scheme != null, "Scheme not found.");
    Assert(
        Context.Sender == scheme.Manager || Context.Sender ==
        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
        "Only manager can add beneficiary.");
    Assert(input.EndPeriod >= scheme.CurrentPeriod,
        $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

    var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
    
    // NEW: Check for duplicate ProfitDetail ID
    if (input.ProfitDetailId != null && currentProfitDetails != null)
    {
        var existingDetail = currentProfitDetails.Details.FirstOrDefault(d => d.Id == input.ProfitDetailId);
        if (existingDetail != null)
        {
            // Remove the existing detail with the same ID before adding new one
            currentProfitDetails.Details.Remove(existingDetail);
            scheme.TotalShares = scheme.TotalShares.Sub(existingDetail.Shares);
        }
    }

    scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
    State.SchemeInfos[schemeId] = scheme;

    var profitDetail = new ProfitDetail
    {
        StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
        EndPeriod = input.EndPeriod,
        Shares = input.BeneficiaryShare.Shares,
        Id = input.ProfitDetailId
    };

    if (currentProfitDetails == null)
        currentProfitDetails = new ProfitDetails { Details = { profitDetail } };
    else
        currentProfitDetails.Details.Add(profitDetail);

    // Remove details too old
    var oldProfitDetails = currentProfitDetails.Details.Where(
        d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
             d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
    foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

    State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;
    return new Empty();
}
```

Alternatively, modify `RemoveProfitDetails` to physically delete entries marked with `IsWeightRemoved = true` instead of leaving them in storage, or update `FixProfitDetail` and the problematic sections of `RemoveProfitDetails` to use `.Where()` instead of `.Single()` or `.SingleOrDefault()` and handle multiple matches appropriately.

## Proof of Concept

While a full integration test would require the complete AElf testing framework, the vulnerability can be demonstrated through the following logical sequence:

1. Candidate calls `AnnounceElection()` → Creates ProfitDetail with subsidyId X
2. Candidate calls `QuitElection()` → Marks ProfitDetail X with `IsWeightRemoved = true` (but doesn't delete if `LastProfitPeriod < CurrentPeriod`)
3. Candidate calls `AnnounceElection()` again → Creates NEW ProfitDetail with same subsidyId X
4. Voter who voted for this candidate calls `ChangeVotingOption(IsResetVotingTime=true)` → Calls `FixProfitDetail` → `.SingleOrDefault(d => d.Id == subsidyId)` throws `InvalidOperationException` because two ProfitDetails have ID X

This can be verified by examining the code paths shown in the citations above. The exception is guaranteed by C# LINQ semantics when multiple elements match the predicate passed to `.Single()` or `.SingleOrDefault()`.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-215)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;

        Context.LogDebug(() =>
            $"Added {input.BeneficiaryShare.Shares} weights to scheme {input.SchemeId.ToHex()}: {profitDetail}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L281-281)
```csharp
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L337-337)
```csharp
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L344-356)
```csharp
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L763-767)
```csharp
    private Hash GenerateSubsidyId(string pubkey, Address beneficiaryAddress)
    {
        return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(pubkey), HashHelper.ComputeFrom(beneficiaryAddress),
            HashHelper.ComputeFrom(Context.Self));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L66-66)
```csharp
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L102-106)
```csharp
            State.ProfitContract.ResetManager.Send(new ResetManagerInput
            {
                SchemeId = managingSchemeIds[2],
                NewManager = electionContractAddress
            });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```
