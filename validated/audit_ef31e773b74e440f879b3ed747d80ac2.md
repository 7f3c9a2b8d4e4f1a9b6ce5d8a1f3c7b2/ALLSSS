# Audit Report

## Title
Consensus Signature Manipulation via Unvalidated PreviousInValue Input

## Summary
The AEDPoS consensus contract contains a critical vulnerability where miners can manipulate their signature values by providing arbitrary `PreviousInValue` inputs. The signature calculation unconditionally uses miner-controlled input even when validation fails, allowing miners to bias their mining order in subsequent rounds and violate consensus fairness guarantees.

## Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue` function where signature calculation logic is inconsistent with validation logic. [1](#0-0) 

The code performs a validation check to verify if the provided `PreviousInValue` hashes to the expected previous round `OutValue`. When validation fails (lines 80-86), it sets `previousInValue = Hash.Empty`. However, the critical bug is at line 92: the signature is **always** calculated using `triggerInformation.PreviousInValue` (the unvalidated, miner-controlled input), regardless of whether validation passed or failed.

This calculated signature directly determines the miner's position in the next round through the `ApplyNormalConsensusData` method: [2](#0-1) 

The signature is converted to a long value and used to calculate `supposedOrderOfNextRound` via modulo arithmetic (line 21), which determines when the miner can produce blocks in subsequent rounds.

The `UpdateValueValidationProvider` fails to detect this manipulation because it only validates that the signature is non-null/non-empty and that the **stored** `previousInValue` hashes correctly: [3](#0-2) 

Line 46 explicitly allows `Hash.Empty` as a valid `previousInValue`, and there is no check verifying that `signature == CalculateSignature(previousInValue)`.

The signature calculation uses XOR operations with previous round signatures: [4](#0-3) 

**Attack Scenario:**
1. Miner wants to produce a block in round N
2. Offline, miner tries many arbitrary `PreviousInValue` candidates
3. For each candidate, computes `signature = previousRound.CalculateSignature(candidate)`
4. Calculates resulting mining order: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
5. Selects the candidate that gives the most favorable position
6. Submits block with this manipulated `PreviousInValue`
7. Validation fails (lines 80-86), sets stored `previousInValue = Hash.Empty`
8. But signature was already calculated using manipulated value (line 92)
9. Block passes validation because `Hash.Empty` is allowed and signature is non-null
10. Manipulated signature is stored and determines miner's next round position

## Impact Explanation

**Severity: High**

This vulnerability directly compromises a critical consensus invariant: the fairness and unpredictability of miner scheduling. The `SupposedOrderOfNextRound` determines when each miner can produce blocks in subsequent rounds. By manipulating their signature, miners can:

- Secure earlier positions in the mining schedule, giving more frequent block production opportunities
- Gain advantages in transaction ordering and inclusion decisions
- Potentially exploit timing-sensitive operations like cross-chain transactions or MEV opportunities
- Systematically bias the consensus mechanism in their favor over honest participants

While this does not lead to direct fund theft, it fundamentally undermines the consensus mechanism's integrity by breaking the randomness and fairness properties that AEDPoS is designed to guarantee. The mining schedule should be unpredictable and fair based on cryptographically-committed random values, not manipulable by individual miners.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly practical to exploit:

**Attacker Profile:** Any authorized miner in the consensus network. No special privileges beyond normal mining rights are required.

**Attack Complexity:** Low
- Miners control their node software and can modify trigger information to provide arbitrary `PreviousInValue` values
- Offline computation is inexpensive: try different values, compute signatures, calculate resulting orders
- Select the most favorable value before submitting the block
- No economic cost beyond normal block production (no penalty for `Hash.Empty` previousInValue)

**Success Rate:** 100% - The miner has full control over the input, and the validation logic allows the attack to succeed. The manipulated block will be accepted by the network as valid consensus data.

**Detection Difficulty:** Very difficult - The manipulated values appear as valid consensus data. Other validators see `previousInValue = Hash.Empty` and a signature value, but have no mechanism to detect that the signature was calculated using an invalid input rather than the legitimate value.

## Recommendation

The signature should always be calculated using the validated `previousInValue` (the value stored after validation), not the raw `triggerInformation.PreviousInValue`. 

Modify line 92 in `GetConsensusExtraDataToPublishOutValue`:

**Current (vulnerable):**
```csharp
signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**Fixed:**
```csharp
signature = previousRound.CalculateSignature(previousInValue);
```

This ensures that if validation fails and `previousInValue` is set to `Hash.Empty`, the signature will be calculated consistently with `Hash.Empty`, maintaining the integrity between stored values and calculated signatures.

Alternatively, add validation in `UpdateValueValidationProvider` to verify signature consistency:
```csharp
if (previousInValue != Hash.Empty)
{
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    if (minerInRound.Signature != expectedSignature)
        return new ValidationResult { Message = "Signature does not match previousInValue" };
}
```

## Proof of Concept

Due to the complexity of the consensus system and the need for a full node environment with multiple miners, a complete PoC would require extensive test infrastructure. However, the vulnerability can be demonstrated through code inspection:

1. A miner can provide any arbitrary `PreviousInValue` value X
2. If `HashHelper.ComputeFrom(X) != previousRound.OutValue`, validation fails
3. The stored `previousInValue` becomes `Hash.Empty`
4. But `signature = previousRound.CalculateSignature(X)` uses X, not `Hash.Empty`
5. The validator checks only that `previousInValue == Hash.Empty` (allowed) and signature is non-null
6. No check that signature was calculated from the stored `previousInValue`
7. Result: Block accepted with manipulated signature determining next round order

The attack is evident from the code structure where the signature calculation (line 92) uses the unvalidated input while storage (line 111) uses the validated value, with no reconciliation check in the validator.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-93)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
