# Audit Report

## Title
Insufficient Precision in Natural Logarithm Series Causes Transaction Failures and Pricing Errors for Large Token Purchases

## Summary
The `Ln()` function in BancorHelper uses a Taylor series with only 20 iterations, creating a mathematical constraint requiring `0 < a < 2`. This causes transaction failures when users attempt to purchase ≥50% of connector balance, and precision errors of ~1-2% for purchases in the 40-50% range. The `Buy()` function lacks pre-validation to prevent these issues.

## Finding Description

The `Ln()` function implements natural logarithm using Taylor series expansion with a hard constraint [1](#0-0)  requiring the input parameter to satisfy `0 < a < 2`. The function uses a fixed iteration count [2](#0-1)  of 20 loops for the Taylor series approximation.

In `GetAmountToPayFromReturn()`, the code calculates [3](#0-2)  `x = bt / (bt - a)` where `bt` is toConnectorBalance and `a` is amountToReceive. This value `x` is then passed to `Ln()` [4](#0-3) . When a user attempts to buy `a ≥ bt/2`, then `bt - a ≤ bt/2`, resulting in `x ≥ 2`, which violates the `Ln()` constraint and throws an `InvalidValueException`.

The `Buy()` function directly calls `GetAmountToPayFromReturn()` [5](#0-4)  without validating that the requested amount is within mathematically acceptable bounds. The `PayLimit` check [6](#0-5)  occurs after the calculation completes, so it cannot prevent the mathematical constraint violation.

For purchases approaching but not exceeding the 50% threshold (40-49% range), the Taylor series with 20 iterations produces precision errors. For example, buying 49% of balance results in `x ≈ 1.96`, giving an internal series argument of `|1-x| ≈ 0.96`. The truncation error approximates `(0.96)^21/21 ≈ 0.02` or 2%.

The balance calculation includes virtual balance [7](#0-6) , which can amplify the issue when virtual balances are enabled, making the threshold trigger unexpectedly.

## Impact Explanation

**Transaction Failure Impact (≥50% purchases):**
- Users attempting to buy ≥50% of connector balance experience immediate transaction failure with "must be 0 < a < 2" exception
- This creates a denial-of-service condition for large legitimate purchases, wasting user gas fees
- Since connector balance includes virtual balance, the actual threshold may be lower than users expect
- No funds are lost, but protocol availability is compromised for this use case

**Pricing Precision Impact (40-50% purchases):**
- Users buying 40-49% of connector balance receive incorrect pricing with ~1-2% error
- For a 1,000,000 token purchase at 45% of balance, the error could be ±10,000-20,000 tokens
- When users overpay due to precision errors, excess funds permanently enter connector balances, gradually skewing reserve ratios
- This violates the Bancor pricing invariant and affects future price calculations

**Severity: LOW** because:
- Error magnitude is bounded and predictable (~1-2% maximum)
- No direct fund theft or loss mechanism
- Practical workaround exists: users can split large transactions into smaller ones
- Natural economic incentives (slippage concerns) already discourage such large single transactions
- Failure mode is explicit exception rather than silent state corruption
- Requires whale-level capital to trigger

## Likelihood Explanation

**Required Conditions:**
- User must have sufficient funds to purchase 40-50% of connector balance in a single transaction
- No special privileges required - affects the public `Buy()` function accessible to any user
- User must be unaware of or willing to ignore the 50% limitation

**Probability Assessment:**
- **Issue 1 (≥50% failure):** Low probability - most sophisticated users naturally split large orders for better slippage management and market impact reduction
- **Issue 2 (40-50% precision):** Very low probability - requires specific circumstances where a user wants exactly 40-49% in a single transaction without concern for price impact
- Natural market dynamics and best practices already discourage such large single transactions
- However, large institutional buyers or whales could realistically encounter this, especially in smaller/newer token pairs with limited liquidity

The likelihood is assessed as low but the trigger path is technically feasible and could affect legitimate large buyers who are unaware of the mathematical constraints.

## Recommendation

Add input validation in the `Buy()` function to prevent purchases that would violate the mathematical constraints:

```csharp
public override Empty Buy(BuyInput input)
{
    var toConnector = State.Connectors[input.Symbol];
    Assert(toConnector != null, "[Buy]Can't find to connector.");
    Assert(toConnector.IsPurchaseEnabled, "can't purchase");
    Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
    var fromConnector = State.Connectors[toConnector.RelatedSymbol];
    Assert(fromConnector != null, "[Buy]Can't find from connector.");
    
    // Add validation to prevent mathematical constraint violation
    var toBalance = GetSelfBalance(toConnector);
    var maxPurchaseAmount = toBalance.Mul(45).Div(100); // 45% safety margin
    Assert(input.Amount <= maxPurchaseAmount, 
        "Purchase amount exceeds maximum allowed (45% of connector balance). Please split into smaller transactions.");
    
    var amountToPay = BancorHelper.GetAmountToPayFromReturn(
        GetSelfBalance(fromConnector), GetWeight(fromConnector),
        toBalance, GetWeight(toConnector),
        input.Amount);
    // ... rest of function
}
```

Additionally, consider increasing `_LOOPS` to 30-40 iterations to improve precision for edge cases, or document the limitation clearly in user-facing interfaces.

## Proof of Concept

```csharp
[Fact]
public async Task Buy_LargePurchase_ShouldFail()
{
    // Setup: Create token with small connector balance
    await CreateWriteToken();
    await InitializeTokenConverterContract();
    await PrepareToBuyAndSell();
    
    // Get current connector balance
    var connectorBalance = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = NtWriteConnector.Symbol });
    
    // Calculate 50% of connector balance (including virtual balance)
    var totalBalance = NtWriteConnector.VirtualBalance + connectorBalance.Value;
    var halfBalance = totalBalance / 2;
    
    // Attempt to buy exactly 50% - this should fail with "must be 0 < a < 2"
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(
        new BuyInput
        {
            Symbol = WriteConnector.Symbol,
            Amount = halfBalance,
            PayLimit = 0 // No limit
        });
    
    // Verify transaction failed with the mathematical constraint error
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    buyResult.TransactionResult.Error.ShouldContain("must be 0 < a < 2");
}
```

**Notes:**
- This vulnerability affects the TokenConverter contract's Bancor pricing formula implementation
- The issue stems from an inherent mathematical limitation of the Taylor series approximation used for logarithm calculation
- While the severity is assessed as LOW due to bounded impact and low likelihood, it represents a real limitation that could affect legitimate large buyers
- The 45% threshold recommendation provides a safety margin to avoid both the hard failure at 50% and the increasing precision errors in the 40-50% range
- Virtual balance amplification means the effective connector balance may be larger than the actual token holdings, making this threshold easier to hit than expected

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-91)
```csharp
        var x = bt / (bt - a);
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L93-93)
```csharp
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L131-132)
```csharp
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L127-127)
```csharp
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L387-387)
```csharp
        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);
```
