# Audit Report

## Title
Insufficient Address Validation in Governance Contracts Enables Griefing Attack via Unexecutable Proposals

## Summary
The Association, Parliament, and Referendum governance contracts only validate that `ToAddress` is not null, failing to check if the internal `Value` byte array is empty or valid. This allows whitelisted proposers to create proposals with non-null but invalid addresses that pass validation during both creation and release, but fail during inline transaction execution. The failure causes the Release transaction to revert, leaving approved proposals permanently stuck in state until expiry.

## Finding Description

All three governance contracts implement insufficient address validation that only checks for null object references rather than validating the internal byte array content.

**Association Contract Validation:**
The `Validate(ProposalInfo proposal)` method only checks if the ToAddress object is null: [1](#0-0) 

**Parliament Contract Validation:**
Parliament uses the same insufficient null-only check: [2](#0-1) 

**Referendum Contract Validation:**
Referendum also only validates null references: [3](#0-2) 

**Proper Validation Pattern:**
The codebase contains the correct validation pattern in TokenContract that checks both the object reference AND the internal Value: [4](#0-3) 

**Attack Flow:**

1. A whitelisted proposer creates a proposal with `new Address() { Value = ByteString.Empty }` or an address with invalid byte length
2. The Address protobuf type allows this construction: [5](#0-4) 

3. Validation passes during CreateProposal because it only checks `!= null`: [6](#0-5) 

4. Organization members vote and approve the proposal normally

5. When Release is called, validation passes again: [7](#0-6) 

6. The SendVirtualInlineBySystemContract creates an inline transaction with the invalid address: [8](#0-7) 

7. During inline transaction execution, the system attempts to get the executive for the invalid address and fails: [9](#0-8) 

8. The inline trace is marked unsuccessful, which causes the parent trace to be unsuccessful: [10](#0-9) 

9. Failed traces only have pre/post plugin state changes applied, not the main transaction's state changes: [11](#0-10) 

10. The `State.Proposals.Remove(input)` at line 198 in Association.cs never persists, leaving the proposal in an approved but permanently unexecutable state until it expires.

## Impact Explanation

**Governance Denial of Service**: Organizations lose the ability to execute approved proposals, disrupting critical governance operations. Members waste significant time and effort reviewing, voting on, and attempting to execute proposals that can never succeed.

**Resource Waste**: Approved proposals remain stuck in contract state consuming storage until their expiration time (potentially days or weeks later), preventing efficient governance operations.

**Repeated Griefing**: Any whitelisted proposer can create multiple such proposals simultaneously, overwhelming the organization with unexecutable proposals and forcing them to wait for each to expire naturally.

**Trust Erosion**: Repeated failures to execute approved proposals damage member confidence in the governance system, potentially causing members to disengage from governance activities.

The severity is **Medium** because while it does not directly steal funds or compromise token supplies, it significantly disrupts critical governance infrastructure that controls protocol upgrades, treasury management, and other essential operations.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be in the organization's proposer whitelist. While this is a barrier, it is realistic in multi-organization ecosystems where various parties participate in governance (DAOs, protocol partners, delegates, etc.).

**Attack Complexity**: The attack is trivial to executeâ€”simply instantiate an Address with `Value = ByteString.Empty` when creating a proposal. No complex state manipulation, precise timing, or special conditions are required.

**Detection Difficulty**: The issue is difficult to detect before Release execution because the validation consistently passes at both creation and release time. Organization members have no way to identify such proposals before voting.

**Economic Feasibility**: The attack costs only standard transaction fees, making sustained griefing campaigns economically viable.

**Reproducibility**: The attack works consistently under normal operational conditions with no special preconditions needed.

The likelihood is **Medium** due to the low technical barrier and the realistic attacker profile of a malicious whitelisted proposer.

## Recommendation

Implement comprehensive address validation in all three governance contracts that checks both the object reference and the internal Value byte array:

```csharp
private bool Validate(ProposalInfo proposal)
{
    // Add proper address validation
    if (proposal.ToAddress == null || proposal.ToAddress.Value.IsNullOrEmpty())
        return false;
        
    if (string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

This validation should be applied in:
- `contract/AElf.Contracts.Association/Association_Helper.cs` line 83-90
- `contract/AElf.Contracts.Parliament/Parliament_Helper.cs` line 157-166
- `contract/AElf.Contracts.Referendum/Referendum_Helper.cs` line 104-113

Alternatively, create a shared helper method following the pattern used in TokenContract:

```csharp
private void AssertValidAddress(Address input)
{
    Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid address.");
}
```

## Proof of Concept

```csharp
// Test: Create and attempt to release proposal with empty address
[Fact]
public async Task CreateProposal_WithEmptyAddressValue_FailsOnRelease()
{
    // Setup: Create organization and whitelist proposer
    var organization = await CreateTestOrganization();
    
    // Attack: Create proposal with non-null but empty address
    var invalidAddress = new Address() { Value = ByteString.Empty };
    var proposalId = await AssociationContract.CreateProposal.SendAsync(new CreateProposalInput
    {
        OrganizationAddress = organization,
        ToAddress = invalidAddress, // Passes null check but has empty Value
        ContractMethodName = "SomeMethod",
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        Params = ByteString.Empty
    });
    
    // Proposal creation succeeds despite invalid address
    proposalId.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Members approve proposal
    await ApproveProposal(proposalId.Output);
    
    // Attempt to release - this will fail and revert
    var releaseResult = await AssociationContract.Release.SendAsync(proposalId.Output);
    
    // Release fails, transaction reverts
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid contract address");
    
    // Proposal remains in state - not removed despite failure
    var proposal = await AssociationContract.GetProposal.CallAsync(proposalId.Output);
    proposal.ProposalId.ShouldBe(proposalId.Output); // Still exists
    proposal.ToBeReleased.ShouldBeTrue(); // Still marked as ready to release
    
    // Proposal is now stuck until expiry - cannot be executed or removed
}
```

## Notes

This vulnerability demonstrates a critical divergence between validation patterns used in different parts of the codebase. The TokenContract properly validates address contents, but the governance contracts only check for null references. This inconsistency creates an exploitable gap that allows malicious proposers to grief governance operations.

The issue is particularly severe because the AElf VM's inline transaction execution semantics cause parent transaction state changes to revert when inline transactions fail, creating a permanent deadlock state for affected proposals.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L150-161)
```csharp
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```
