# Audit Report

## Title
Proposer Whitelist Validation Bypass Allows Organization DoS via Empty Addresses

## Summary
The Referendum contract's `Empty()` validation method only checks if the proposer whitelist has zero entries, without validating whether individual addresses contain valid byte data. This allows an attacker to poison the whitelist with empty `Address` objects (protobuf default with `Value = ByteString.Empty`), permanently disabling all proposal creation for the affected organization.

## Finding Description

The root cause lies in insufficient address validation during whitelist updates. The `Empty()` extension method only validates the count of addresses [1](#0-0) , without checking whether the `Address.Value` field contains valid data.

When `ChangeOrganizationProposerWhiteList` is called [2](#0-1) , it updates the organization's whitelist and validates using the `Validate(organization)` method [3](#0-2) . However, this validation only ensures the list count is non-zero, not that addresses have valid content.

Unlike other contracts in the codebase that properly validate addresses using the standard pattern [4](#0-3) , the Referendum contract lacks per-address validation.

**Attack Execution Path:**
1. Malicious authorized proposer creates a proposal calling `ChangeOrganizationProposerWhiteList` with `ProposerWhiteList { Proposers = { new Address() } }`
2. The protobuf-generated `Address` object has `Value = ByteString.Empty` by default [5](#0-4) 
3. Proposal gets approved through token-weighted voting
4. During release, the whitelist update passes validation because Count() == 1 (Empty() returns false)
5. State is persisted with the invalid whitelist
6. All subsequent `CreateProposal` attempts fail at `AssertIsAuthorizedProposer` [6](#0-5)  because `Context.Sender` (a real address with 32 valid bytes) will never match the empty address in the whitelist via the `Contains()` check [7](#0-6) 

## Impact Explanation

**HIGH Severity** - This vulnerability causes permanent and irreversible denial-of-service of critical governance functionality:

- **Operational Impact**: The organization becomes completely unable to create new proposals, as all `CreateProposal` calls will fail authorization checks [8](#0-7) 
- **Governance Capture**: The organization is permanently bricked - it cannot execute any governance actions requiring new proposals, including attempts to fix the whitelist itself (which would require creating a proposal)
- **Scope**: All members of the affected Referendum organization lose governance capabilities
- **Permanence**: No recovery mechanism exists - fixing the whitelist requires proposal creation, which is now impossible

The test suite confirms that empty whitelists should be rejected (test expectations show validation should fail for invalid whitelists), and the codebase pattern shows other contracts properly validate address content, indicating this is an unintended security gap.

## Likelihood Explanation

**MEDIUM Likelihood** - The attack requires governance participation but is achievable:

**Attacker Prerequisites:**
- Must be an authorized proposer in the target organization
- Must convince token holders to approve the malicious proposal through token-weighted voting

**Attack Complexity:**
- **LOW** - Single proposal with simple payload: `new ProposerWhiteList { Proposers = { new Address() } }`
- Protobuf naturally allows empty Address objects (default Value = ByteString.Empty)
- No special cryptographic or technical knowledge required

**Feasibility:**
- **MEDIUM** - Requires insider access (authorized proposer role) but realistic in governance attack scenarios
- Attack could be disguised within a complex multi-part proposal bundle
- Could be executed by a compromised proposer account
- Social engineering could be used to gain approval ("updating whitelist for security")
- Once executed, damage is permanent and irreversible

## Recommendation

Add per-address validation in the `Validate()` method to check that each address in the whitelist contains valid byte data:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for each address in the whitelist
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

This follows the same validation pattern used throughout the codebase for address validation.

## Proof of Concept

```csharp
[Fact]
public async Task EmptyAddressInWhitelist_PermanentlyBricksOrganization_Test()
{
    // Create organization with valid proposer
    var organizationAddress = await CreateOrganizationAsync(5000, 5000, 10000, 10000, new[] { DefaultSender });
    
    // Verify we can create proposals initially
    var proposalId1 = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    proposalId1.ShouldNotBeNull();
    
    // Create malicious proposal to change whitelist to empty address
    var emptyAddressWhitelist = new ProposerWhiteList
    {
        Proposers = { new Address() } // Empty address with Value = ByteString.Empty
    };
    
    var maliciousProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        emptyAddressWhitelist,
        nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList),
        organizationAddress,
        ReferendumContractAddress);
    
    // Approve and release the malicious proposal
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, maliciousProposalId);
    await ApproveAsync(Accounts[3].KeyPair, maliciousProposalId);
    await ReferendumContractStub.Release.SendAsync(maliciousProposalId);
    
    // Verify the whitelist was updated with empty address
    var org = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress);
    org.ProposerWhiteList.Proposers.Count.ShouldBe(1); // Has one entry
    org.ProposerWhiteList.Proposers[0].Value.IsEmpty.ShouldBeTrue(); // But it's empty!
    
    // Now try to create a new proposal - this should fail permanently
    var createProposalInput = new CreateProposalInput
    {
        ToAddress = TokenContractAddress,
        Params = ByteString.CopyFromUtf8("Test"),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        OrganizationAddress = organizationAddress,
        ContractMethodName = "Test"
    };
    
    var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
    
    // Organization is permanently bricked - cannot create proposals to fix itself
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** src/AElf.Types/Types/Address.cs (L7-18)
```csharp
    public partial class Address : ICustomDiagnosticMessage, IComparable<Address>
    {
        private string _formattedAddress;

        // Make private to avoid confusion
        private Address(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            Value = ByteString.CopyFrom(bytes);
        }
```
