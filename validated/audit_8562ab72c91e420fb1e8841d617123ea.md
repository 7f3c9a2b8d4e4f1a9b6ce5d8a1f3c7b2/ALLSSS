# Audit Report

## Title
Creator Impersonation Vulnerability in NFT Protocol Creation

## Summary
The NFT Contract's `Create()` method allows arbitrary addresses to be set as the protocol creator without validating that the creator matches the transaction sender. This creates a critical privilege mismatch where the seed NFT cost is deducted from `Context.Sender` while all protocol control privileges are granted to the specified `input.Creator` address, enabling complete protocol takeover attacks.

## Finding Description

The vulnerability exists in the NFT Contract's `Create()` method where the creator address is determined without proper authorization validation: [1](#0-0) 

The code uses `input.Creator ?? Context.Sender`, which allows `input.Creator` to be any arbitrary address when explicitly provided. Critically, there is no validation ensuring that when `input.Creator` is specified, it matches `Context.Sender`.

This creator address is then used as the token issuer when creating the underlying token in the MultiToken contract: [2](#0-1) 

The MultiToken contract's `Create` method burns the seed NFT from `Context.Sender` (the transaction initiator), not from the `Issuer` field: [3](#0-2) 

This creates a critical privilege mismatch: the seed NFT is burned from `Context.Sender`'s balance, but all protocol control privileges are granted to the arbitrary `input.Creator` address. The creator is stored in the NFT protocol info with exclusive management rights: [4](#0-3) 

Only the creator can add minters to the protocol: [5](#0-4) 

Only the creator can remove minters from the protocol: [6](#0-5) 

Additionally, the creator becomes the token issuer in the MultiToken contract, granting exclusive `Issue()` rights: [7](#0-6) 

## Impact Explanation

**Direct Financial Loss:**
- The victim loses their seed NFT, a scarce and valuable resource required for token creation
- Seed NFTs have economic value and are necessary for protocol creation rights
- The victim pays the cost but receives zero control over the protocol

**Authorization Impact:**
- The attacker gains exclusive creator privileges over the NFT protocol without authorization
- The attacker has sole authority to add/remove minters, controlling who can mint NFTs for the protocol
- The attacker becomes the token issuer, with exclusive rights to issue tokens via the MultiToken contract
- The victim who paid for the protocol creation cannot manage, modify, or control the protocol in any way

**Severity Classification:**
This represents a high-severity authorization bypass vulnerability with concrete economic loss and complete privilege escalation to an unauthorized party.

## Likelihood Explanation

**Attack Feasibility:**
The attack requires the victim to call the `Create()` method with `input.Creator` set to the attacker's address. This can occur through:

1. **Malicious dApp Interfaces**: An attacker-controlled or compromised dApp could populate the `input.Creator` field with the attacker's address in the transaction parameters
2. **Compromised SDKs/Libraries**: If the SDK or library used to interact with the contract is compromised, it could inject the wrong creator address
3. **User Error**: Less sophisticated users could be convinced to set parameters incorrectly

**Probability Assessment:**
- The attack exploits a missing contract-level validation that should enforce `creator == Context.Sender`
- Users typically trust frontend interfaces to populate parameters correctly
- There is no on-chain warning or validation to alert users when creator â‰  sender
- The transaction appears valid and will succeed without any error

The likelihood is **medium** given that exploitation requires user interaction through potentially malicious or compromised interfaces, but the complete absence of contract-level validation makes this exploitable.

## Recommendation

Implement strict validation to ensure the creator address matches the transaction sender:

```csharp
public override StringValue Create(CreateInput input)
{
    Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
        "NFT Protocol can only be created at aelf mainchain.");
    
    // Fix: Validate creator matches sender when explicitly provided
    if (input.Creator != null)
    {
        Assert(input.Creator == Context.Sender, 
            "Creator must match the transaction sender.");
    }
    
    var creator = input.Creator ?? Context.Sender;
    // ... rest of the method
}
```

Alternatively, simplify by removing the optional creator parameter entirely and always using `Context.Sender`:

```csharp
var creator = Context.Sender; // Always use sender, ignore input
```

## Proof of Concept

```csharp
[Fact]
public async Task CreatorImpersonationVulnerability()
{
    // Setup: Give victim (DefaultAddress) seed NFT
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = 1_00000000_00000000,
        To = DefaultAddress
    });
    
    var victimBalanceBefore = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = DefaultAddress, Symbol = "SEED-1" });
    
    // Exploit: Victim calls Create with Attacker's address as Creator
    var executionResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://test/",
        Creator = MinterAddress, // Attacker's address!
        IsBurnable = true,
        NftType = NFTType.Art.ToString(),
        ProtocolName = "EXPLOIT",
        TotalSupply = 1000000
    });
    
    var symbol = executionResult.Output.Value;
    
    // Verify: Seed NFT was burned from victim
    var victimBalanceAfter = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = DefaultAddress, Symbol = "SEED-1" });
    victimBalanceAfter.Balance.ShouldBeLessThan(victimBalanceBefore.Balance);
    
    // Verify: Attacker controls the protocol
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = symbol });
    protocolInfo.Creator.ShouldBe(MinterAddress); // Attacker is creator!
    
    // Verify: Victim cannot add minters (will fail with "No permission")
    var addMinterResult = await NFTContractStub.AddMinters.SendWithExceptionAsync(
        new AddMintersInput
        {
            Symbol = symbol,
            MinterList = new MinterList { Value = { DefaultAddress } }
        });
    addMinterResult.TransactionResult.Error.ShouldContain("No permission");
    
    // Verify: Attacker CAN add minters
    await MinterNFTContractStub.AddMinters.SendAsync(new AddMintersInput
    {
        Symbol = symbol,
        MinterList = new MinterList { Value = { MinterAddress } }
    });
    
    // Result: Victim paid seed NFT cost, Attacker has full control
}
```

## Notes

The vulnerability stems from a missing authorization check in the contract design. The `input.Creator` field should either be validated to match `Context.Sender` or removed entirely. The official test suite explicitly sets `Creator = DefaultAddress` (the sender), suggesting the intended behavior is for creator to equal sender. The current implementation violates the security invariant that "whoever pays for protocol creation should control the created protocol."

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-53)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L62-64)
```csharp
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-161)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-352)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```
