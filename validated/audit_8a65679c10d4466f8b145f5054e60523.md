# Audit Report

## Title
ImpliedIrreversibleBlockHeight Monotonicity Violation Due to Pre-Validation Mutation

## Summary
The `RecoverFromUpdateValue()` function overwrites `ImpliedIrreversibleBlockHeight` before validation occurs, causing the `LibInformationValidationProvider` to compare the provided value against itself rather than against the original state value. This allows malicious miners to decrease the `ImpliedIrreversibleBlockHeight`, potentially causing the Last Irreversible Block (LIB) height to move backwards and violating blockchain finality guarantees.

## Finding Description

The vulnerability exists in the consensus validation flow where state mutation occurs before security validation.

**Root Cause - Pre-Validation Mutation:**

The validation flow retrieves the current round from state, then immediately mutates it by calling `RecoverFromUpdateValue` before any validation checks occur: [1](#0-0) [2](#0-1) 

The `RecoverFromUpdateValue` method directly overwrites the `ImpliedIrreversibleBlockHeight` field in the base round without any validation: [3](#0-2) 

This means that if the original state had `ImpliedIrreversibleBlockHeight = 1000` and the attacker provides `ImpliedIrreversibleBlockHeight = 500`, after this line executes, `baseRound[pubkey].ImpliedIrreversibleBlockHeight` is now `500`.

**Broken Validation Logic:**

After the mutation, the validation context is created with the already-modified `baseRound`: [4](#0-3) 

The `LibInformationValidationProvider` is then added to validate LIB information: [5](#0-4) 

However, the validator compares the modified `baseRound` against `providedRound`. Critically, `providedRound` is defined as `ExtraData.Round`: [6](#0-5) 

The validation check attempts to detect if the `ImpliedIrreversibleBlockHeight` decreased: [7](#0-6) 

Since `baseRound[pubkey].ImpliedIrreversibleBlockHeight` was already set to the provided value (500) during recovery, the check becomes: `500 > 500`, which is always `false`. The validation can never detect a decrease.

**State Persistence:**

If validation passes (which it always will), the malicious value is persisted to state during transaction execution: [8](#0-7) 

**LIB Impact:**

The corrupted `ImpliedIrreversibleBlockHeight` values are used to calculate the Last Irreversible Block: [9](#0-8) 

The LIB calculator retrieves sorted heights from all miners: [10](#0-9) 

And selects the value at position `(count-1)/3` for Byzantine fault tolerance: [11](#0-10) 

By providing lower values, malicious miners can cause the calculated LIB to decrease, violating finality.

## Impact Explanation

**Critical Consensus Integrity Violation:**

The `ImpliedIrreversibleBlockHeight` directly determines the Last Irreversible Block (LIB), which is the foundation of blockchain finality. When the LIB moves backwards:

1. **Finality Guarantee Broken**: Blocks previously considered finalized can become reversible
2. **Double-Spend Risk**: Transactions thought to be irreversible can be reorganized
3. **Cross-Chain Security Impact**: Sidechains and bridges rely on parent chain LIB heights for security decisions
4. **Consensus Trust Violation**: The fundamental assumption that finalized blocks remain finalized is broken

**Affected Parties:**
- All network participants trusting in block finality
- Cross-chain protocols depending on LIB verification
- Exchanges and payment processors using LIB for transaction finality
- DApps that consider transactions final based on LIB status

**Severity:** CRITICAL - This violates a core blockchain invariant (monotonically increasing finality) and enables potential double-spend attacks.

## Likelihood Explanation

**Access Requirements:**

The only access control is verification that the sender is in the miner list: [12](#0-11) 

Any active miner can exploit this vulnerability.

**Attack Complexity:** LOW
- Attacker must be an active miner in the consensus set
- No complex state setup or timing requirements
- Simply submit an `UpdateValue` transaction with a lower `ImpliedIrreversibleBlockHeight`
- The broken validation logic will not detect the decrease
- The malicious value will be persisted to state

**Feasibility:** HIGH
- Exploitable through normal consensus operations
- No special conditions required beyond being a miner
- Can be executed in any round during block production

**Detection:** The validation mechanism that should prevent this is completely bypassed due to the pre-validation mutation, making the attack undetectable by the current security controls.

## Recommendation

The fix requires performing validation BEFORE mutating the baseRound. The validation should compare the original state value against the provided value:

1. Store the original `ImpliedIrreversibleBlockHeight` before calling `RecoverFromUpdateValue`
2. Pass the original value to the validation context
3. Only mutate the round after validation passes

Alternatively, modify `RecoverFromUpdateValue` to NOT mutate the `ImpliedIrreversibleBlockHeight` field and instead let it be set during execution after validation passes.

The recommended approach is to modify the validation context to include both the original unmutated baseRound and the provided round, ensuring the `LibInformationValidationProvider` compares against the true original state.

## Proof of Concept

A malicious miner can exploit this by:

1. Wait until they have produced a block with `ImpliedIrreversibleBlockHeight = 1000`
2. In a subsequent round, when producing their next block, provide `UpdateValue` with `ImpliedIrreversibleBlockHeight = 500`
3. The validation will pass because after `RecoverFromUpdateValue`, baseRound contains 500, and the check `500 > 500` is false
4. The value 500 is persisted to state
5. When LIB is calculated, if enough miners provide lower values, the LIB height decreases
6. Blocks between the new lower LIB and the previous higher LIB become reversible again

This violates the fundamental blockchain property that finalized blocks remain finalized forever.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L25-25)
```csharp
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```
