# Audit Report

## Title
Division by Zero Vulnerability in Miner Count Calculation Due to Insufficient Validation in SetMinerIncreaseInterval

## Summary
The `SetMinerIncreaseInterval` method contains insufficient validation that allows governance to set `State.MinerIncreaseInterval.Value` to zero or negative values, causing a `DivideByZeroException` in critical consensus operations. This results in permanent blockchain denial-of-service with no built-in recovery mechanism.

## Finding Description

**Root Cause - Insufficient Validation:**

The `SetMinerIncreaseInterval` method only validates that the new value is less than or equal to the current value, but does not require the value to be positive: [1](#0-0) 

The validation on line 61 checks `input.Value <= State.MinerIncreaseInterval.Value`, which prevents increases but allows zero and negative values. There is no check requiring `input.Value > 0`.

**Division by Zero Locations:**

When `State.MinerIncreaseInterval.Value` is zero, division operations in two critical methods throw exceptions:

1. In `GetAutoIncreasedMinersCount()`: [2](#0-1) 

2. In `GetMinersCount()`: [3](#0-2) 

Both methods perform `.Div(State.MinerIncreaseInterval.Value)` which throws when the divisor is zero.

**Division Method Behavior:**

The `Div` extension method performs standard C# division without zero-checks: [4](#0-3) 

This throws `DivideByZeroException` as confirmed by unit tests: [5](#0-4) 

**Critical Call Paths:**

The vulnerable `GetMinersCount()` is called in three critical operations:

1. **Term transitions** via `UpdateMinersCountToElectionContract()`: [6](#0-5) 

2. **Block processing** during consensus initialization: [7](#0-6) 

3. **Governance operations** in `SetMaximumMinersCount()`: [8](#0-7) 

**Why Recovery is Impossible:**

Once `MinerIncreaseInterval` is set to zero, the validation logic prevents setting it back to a positive value because the assertion requires `input.Value <= State.MinerIncreaseInterval.Value`. If current value is 0, any positive value fails this check, creating a permanent unrecoverable state.

**Initialization Does Not Prevent Attack:**

While the contract is initialized with a valid default value: [9](#0-8) 

The vulnerability arises from the ability to modify this value to zero after initialization through governance action.

## Impact Explanation

**Severity: CRITICAL - Complete Blockchain Denial-of-Service**

Once `State.MinerIncreaseInterval.Value` is set to zero, all subsequent blockchain operations fail:

1. **Consensus Halted**: Term transitions fail when `UpdateMinersCountToElectionContract()` calls `GetMinersCount()`, preventing new consensus terms from starting
2. **Block Production Stops**: `ProcessConsensusInformation` fails during normal block processing initialization
3. **Governance Paralyzed**: `SetMaximumMinersCount()` also calls `GetMinersCount()`, so governance cannot execute any recovery actions
4. **Permanent State**: The validation logic prevents setting the value back to positive (requires `input <= current`), making recovery impossible without hard fork

This breaks the core consensus security guarantee that the blockchain can continue producing blocks and processing transactions. The entire protocol becomes non-operational with no built-in recovery mechanism.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Prerequisites:**
- Requires governance approval from `MaximumMinersCountController` (Parliament default organization by default)

**Feasibility:**
The vulnerability can be triggered through:
1. **Human error**: Governance accidentally submits proposal with value 0 instead of intended value
2. **Malicious proposal**: If governance is compromised or approves an attack proposal
3. **No safeguards**: No bounds checking, timelock, or emergency pause mechanism exists

**Attack Complexity: LOW**
- Single governance transaction required
- No complex state manipulation
- No additional economic cost beyond normal governance process

**Evidence of Oversight:**
The test coverage only validates preventing increases, not zero/negative values: [10](#0-9) 

The test on lines 121-132 attempts to increase the interval (which fails), and lines 133-146 decrease it successfully, but there is no test for zero or negative values.

While requiring governance approval is a barrier, the lack of validation combined with potential for human error makes this a realistic threat to protocol availability.

## Recommendation

Add positive value validation in `SetMinerIncreaseInterval`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");  // Add this check
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Additionally, consider:
1. Adding a minimum value constant (e.g., 86400 seconds = 1 day)
2. Adding comprehensive test coverage for edge cases including zero and negative values
3. Implementing emergency governance controls for critical consensus parameters

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_ZeroValue_CausesDivisionByZero()
{
    // Setup: Initialize contracts and governance
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    var defaultOrganizationAddress = 
        await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

    // Attack: Governance sets MinerIncreaseInterval to zero
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 0 }.ToByteString(),  // Zero value
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });

    // Verify the value was set to zero
    var interval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    interval.Value.ShouldBe(0);

    // Impact: Any operation calling GetMinersCount now fails with DivideByZeroException
    // This includes term transitions, block production, and governance operations
    var exception = await Should.ThrowAsync<Exception>(async () =>
    {
        await BlockMiningService.MineBlockToNextTermAsync();  // Triggers GetMinersCount
    });
    
    exception.Message.ShouldContain("DivideByZeroException");
    
    // Recovery is impossible: Cannot set back to positive value
    var recoveryAttempt = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 31536000 }.ToByteString(),  // Try to restore
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });
    recoveryAttempt.Error.ShouldContain("Invalid interval");  // Fails: 31536000 > 0
}
```

## Notes

This vulnerability demonstrates a critical oversight in input validation for consensus parameters. The validation logic appears intentionally designed to prevent increases (for security reasons), but fails to enforce a minimum positive bound. This creates a catastrophic failure mode where a single governance error or malicious action can permanently brick the entire blockchain with no recovery path except hard fork intervention.

The severity is amplified by the fact that:
1. The same governance mechanism that could cause the issue cannot fix it due to the validation constraint
2. Multiple critical consensus paths are affected simultaneously
3. No emergency controls or circuit breakers exist for this scenario

This is a valid CRITICAL severity vulnerability requiring immediate patching.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L125-136)
```csharp
            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-31)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L109-147)
```csharp
    public async Task SetMinerIncreaseIntervalTest()
    {
        InitialContracts();
        await BlockMiningService.MineBlockToNextTermAsync();

        InitialAcs3Stubs();
        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
        var minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        
        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
    }
```
