# Audit Report

## Title
Missing Validation for Empty Miner List Enables Permanent Blockchain Halt via NextRound/NextTerm

## Summary
The AEDPoS consensus validation pipeline fails to verify that proposed rounds contain at least one miner. Multiple validation providers check properties of miners but not their existence, allowing a malicious miner to submit an empty round that passes all validations and permanently halts the blockchain.

## Finding Description

The vulnerability exists in the consensus validation pipeline's handling of NextRound and NextTerm transactions. The critical flaw is that validators check properties **of** miners but never check **if** miners exist in the proposed round.

**Validation Context Setup:**

When `ValidateConsensusBeforeExecution` is invoked, it creates a `ConsensusValidationContext` where `BaseRound` is the current state fetched from StateDb and `ProvidedRound` is the submitted round data from the block header's consensus extra data. [1](#0-0) [2](#0-1) 

**Root Cause #1 - ContinuousBlocksValidationProvider:**

The condition checks `BaseRound.RealTimeMinersInformation.Count != 1` to skip validation for single-miner chains. When an empty round is submitted with BaseRound having multiple miners, the condition evaluates to TRUE, entering the validation block. However, the validation only checks continuous block production limits via `LatestPubkeyToTinyBlocksCount`, not whether ProvidedRound has miners. [3](#0-2) 

**Root Cause #2 - NextRoundMiningOrderValidationProvider:**

When `ProvidedRound.RealTimeMinersInformation` is empty, both `distinctCount` (count of miners with FinalOrderOfNextRound > 0) and `Count(m => m.OutValue != null)` equal zero. The equality check `0 == 0` passes validation. [4](#0-3) 

**Root Cause #3 - RoundTerminateValidationProvider:**

For NextRound behavior, the validator checks that `Any(m => m.InValue != null)` returns false to ensure InValues are null for new rounds. When the collection is empty, `Any()` returns false, which is misinterpreted as "all InValues are correctly null" rather than "no miners exist." [5](#0-4) 

**Unconditional Storage:**

After passing validation, `ProcessNextRound` unconditionally stores the empty round via `AddRoundInformation`. [6](#0-5) [7](#0-6) 

**Permanent Blockchain Halt:**

Once the empty round becomes the current round (BaseRound), all subsequent block production attempts fail at `MiningPermissionValidationProvider` because no miner's pubkey can exist in an empty `RealTimeMinersInformation.Keys` collection. [8](#0-7) 

## Impact Explanation

This vulnerability causes **CRITICAL consensus layer failure** with the following impacts:

1. **Permanent Blockchain Halt**: Once an empty round is stored, the blockchain cannot produce subsequent blocks. Every miner attempting to produce a block will fail `MiningPermissionValidationProvider` since `BaseRound.RealTimeMinersInformation.Keys` is empty.

2. **Complete Network DoS**: All consensus operations, transaction processing, cross-chain communications, and state updates cease permanently across the entire network.

3. **No Automatic Recovery**: There is no contract method to override an empty round once stored. `NextRound`/`NextTerm` would fail validation (no miner can pass `MiningPermissionValidationProvider`), and `UpdateValue`/`UpdateTinyBlockInformation` would fail `PreCheck()` (no miner exists in the round). Resolution requires emergency hard fork or manual state database intervention.

4. **Network-Wide Impact**: Unlike vulnerabilities affecting individual accounts or contracts, this impacts every node, miner, and user simultaneously.

The severity is CRITICAL because it violates the fundamental invariant "Correct round transitions and miner schedule integrity" and causes irreversible consensus failure with a single transaction.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the current round
- Can produce blocks during assigned time slots  
- Requires only standard block production privileges (no elevated permissions)

**Attack Complexity:**
The attack is trivially simple:
1. Attacker crafts `NextRoundInput` with empty `RealTimeMinersInformation` dictionary
2. Creates block with consensus extra data containing the same empty round
3. During their mining time slot, submits the block with the malicious NextRound transaction
4. Single transaction execution causes permanent halt

**Feasibility:**
The `NextRound()` method is publicly accessible as a standard RPC method. Miners can submit arbitrary transactions instead of using the auto-generated consensus transactions. [9](#0-8) 

**Detection Constraints:**
- Pre-execution validation does not detect empty miner lists
- Post-execution, the attack is immediately obvious (blockchain stops) but recovery requires out-of-band intervention
- No economic barriers prevent execution beyond potential reputation loss

**Likelihood Assessment: MEDIUM-HIGH**
While requiring miner access, the attack is straightforward to execute with no complex preconditions, requiring only one of N miners to be malicious or compromised.

## Recommendation

Add explicit validation to check that `ProvidedRound.RealTimeMinersInformation` is not empty before storing the round. This should be added to multiple validation providers and the storage logic:

**Option 1: Add to RoundTerminateValidationProvider**
```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // NEW CHECK: Ensure next round has miners
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Next round must contain at least one miner." };
    
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Option 2: Add guard in ProcessNextRound**
```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // NEW CHECK: Prevent storing empty rounds
    Assert(nextRound.RealTimeMinersInformation.Count > 0, "Round must contain at least one miner.");
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

Implement both checks for defense-in-depth: validation-level prevention and execution-level safeguard.

## Proof of Concept

The PoC would demonstrate:
1. Initialize consensus with multiple miners in round N
2. Malicious miner creates `NextRoundInput` with `RealTimeMinersInformation = {}`
3. Call `ValidateConsensusBeforeExecution` with empty round → validation passes
4. Execute `NextRound` transaction → empty round stored as round N+1
5. Attempt any subsequent block production → all fail at `MiningPermissionValidationProvider`
6. Blockchain permanently halted

The test would verify that after step 4, `GetCurrentRoundInformation().RealTimeMinersInformation.Count == 0` and no subsequent consensus transactions can succeed.

---

**Notes:**

This vulnerability is exploitable because the validation pipeline operates under the assumption that if a round passes all property checks (InValue nullness, OutValue counts, mining order), it must be valid. However, these checks implicitly assume miners exist and use operations like `Any()` and `Count()` that return vacuously true/zero values for empty collections, inadvertently allowing empty rounds to pass.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L20-27)
```csharp
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
