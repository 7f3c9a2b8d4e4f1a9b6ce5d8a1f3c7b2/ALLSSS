# Audit Report

## Title
Treasury Accepts Unfavorable Prices Due to Missing Slippage Protection on Token Conversion

## Summary
The Treasury contract's `ConvertToNativeToken` method calls `TokenConverterContract.Sell` without setting the `ReceiveLimit` parameter for slippage protection. Since `ReceiveLimit` defaults to 0, it bypasses the price validation check in the TokenConverter's `Sell` method, allowing Treasury to accept arbitrarily unfavorable exchange rates when converting donated non-native tokens to native tokens.

## Finding Description

The vulnerability exists in the token donation flow when non-native convertible tokens are donated to Treasury.

When users donate non-native tokens through the `Donate` method, Treasury checks if the token can be converted to native tokens and calls `ConvertToNativeToken` to perform the conversion. [1](#0-0) 

The `ConvertToNativeToken` method calls `TokenConverterContract.Sell` with only `Symbol` and `Amount` parameters, critically omitting the `ReceiveLimit` parameter: [2](#0-1) 

According to the protobuf definition, `ReceiveLimit` is an optional `int64` field that defaults to 0 when not specified. The protocol documentation states: "Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned. And 0 is no limit." [3](#0-2) 

In the TokenConverter's `Sell` method, the slippage protection check is implemented as: [4](#0-3) 

When `ReceiveLimit` is 0 (the default), the condition `input.ReceiveLimit == 0` evaluates to true, causing the entire assertion to pass regardless of the actual `amountToReceiveLessFee` value. This completely bypasses the "Price not good" protection.

The TokenConverter uses the Bancor pricing formula, which is deterministic and directly depends on connector balances: [5](#0-4) 

Since the `Buy` and `Sell` methods on TokenConverter are public, any actor can manipulate connector balances before Treasury's transaction executes, forcing Treasury to accept manipulated prices.

## Impact Explanation

**Direct Financial Loss to Treasury**: Each time non-native tokens are donated and converted, Treasury is vulnerable to receiving unfavorable exchange rates. The impact scenarios include:

1. **Price Manipulation Attack**: An attacker observing a pending donation transaction can front-run it by buying the resource token (depleting connector balance), causing the subsequent Treasury sell to execute at a worse price. Treasury then receives significantly fewer native tokens than the fair market value.

2. **Loss Magnitude**: The actual loss depends on:
   - Size of the donation (larger = higher absolute loss)
   - Liquidity depth in the connector (lower liquidity = easier to manipulate)
   - Attacker's capital (more capital = greater price impact)

3. **Cumulative Economic Impact**: Since donations are a core mechanism in the AElf ecosystem, repeated exploitation across multiple donations leads to significant value leakage from Treasury reserves. This directly harms the protocol's economic sustainability and reduces the rewards pool available for miners, voters, and other stakeholders.

4. **No Recovery Mechanism**: Once Treasury accepts the unfavorable conversion, the loss is permanent with no way to recover the lost value.

## Likelihood Explanation

**High Likelihood - Attack is Practical and Economically Viable**:

1. **Public Entry Point**: The `Donate` method is publicly accessible with no authorization requirements beyond basic input validation. [6](#0-5) 

2. **Public Price Manipulation**: The `Buy` and `Sell` methods on TokenConverter are public and can be called by anyone to manipulate connector balances. [7](#0-6) 

3. **Observable Transactions**: In blockchain environments, pending transactions are typically visible before execution, allowing attackers to observe donation transactions and front-run them with price-manipulating swaps.

4. **Deterministic Exploitation**: The Bancor formula is deterministic and publicly known. Attackers can precisely calculate the required trades to achieve a desired price impact.

5. **Economic Incentive**: Attackers can potentially profit through arbitrage:
   - Front-run: Buy resource tokens (worsen sell price for Treasury)
   - Treasury's sell executes at manipulated price
   - Back-run: Sell resource tokens back at better price
   - Net result: Treasury loses value, attacker potentially profits

6. **Repeatable Attack Vector**: This vulnerability affects every donation of convertible non-native tokens, making it a persistent and repeatable exploit rather than a one-time issue.

## Recommendation

Modify the `ConvertToNativeToken` method to include slippage protection by setting an appropriate `ReceiveLimit` value:

```csharp
private void ConvertToNativeToken(string symbol, long amount)
{
    State.TokenContract.Approve.Send(new ApproveInput
    {
        Spender = State.TokenConverterContract.Value,
        Symbol = symbol,
        Amount = amount
    });

    // Calculate expected receive amount with acceptable slippage
    var connector = State.TokenConverterContract.GetPairConnector.Call(new TokenSymbol { Symbol = symbol });
    var expectedAmount = CalculateExpectedReceiveAmount(connector, amount);
    var minReceiveAmount = expectedAmount.Mul(95).Div(100); // 5% slippage tolerance

    State.TokenConverterContract.Sell.Send(new SellInput
    {
        Symbol = symbol,
        Amount = amount,
        ReceiveLimit = minReceiveAmount  // Add slippage protection
    });

    Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
    {
        Symbol = Context.Variables.NativeSymbol
    });
}
```

Alternatively, implement a governance-configurable maximum acceptable slippage percentage that Treasury uses when converting donated tokens.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy TokenConverter with a token pair (e.g., RESOURCE/ELF) with low initial liquidity
2. User initiates donation of RESOURCE tokens to Treasury
3. Attacker front-runs by buying large amount of RESOURCE tokens, depleting connector balance
4. Treasury's `Donate` → `ConvertToNativeToken` → `Sell` executes with `ReceiveLimit = 0`
5. Treasury receives significantly fewer ELF tokens than expected fair value
6. The transaction succeeds despite the unfavorable price because the slippage check is bypassed

The test would verify that:
- Treasury's `ConvertToNativeToken` creates a `SellInput` with `ReceiveLimit = 0`
- The TokenConverter's `Sell` method bypasses the price check when `ReceiveLimit == 0`
- Treasury receives fewer tokens after connector balance manipulation compared to fair market conditions
- The transaction completes successfully without reverting despite the price manipulation

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-251)
```csharp
    public override Empty Donate(DonateInput input)
    {
        Assert(input.Amount > 0, "Invalid amount of donating. Amount needs to be greater than 0.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        var isNativeSymbol = input.Symbol == Context.Variables.NativeSymbol;
        var canExchangeWithNativeSymbol =
            isNativeSymbol ||
            State.TokenConverterContract.IsSymbolAbleToSell
                .Call(new StringValue { Value = input.Symbol }).Value;

        if (Context.Sender != Context.Self)
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = Context.Self,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = "Donate to treasury."
            });

        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
        else
        {
            State.TokenContract.Approve.Send(new ApproveInput
            {
                Symbol = input.Symbol,
                Amount = input.Amount,
                Spender = State.ProfitContract.Value
            });

            State.ProfitContract.ContributeProfits.Send(new ContributeProfitsInput
            {
                SchemeId = State.TreasuryHash.Value,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            var donatesOfCurrentBlock = State.DonatedDividends[Context.CurrentHeight];
            if (donatesOfCurrentBlock != null && Context.Variables.NativeSymbol == input.Symbol &&
                donatesOfCurrentBlock.Value.ContainsKey(Context.Variables.NativeSymbol))
                donatesOfCurrentBlock.Value[Context.Variables.NativeSymbol] = donatesOfCurrentBlock
                    .Value[Context.Variables.NativeSymbol].Add(input.Amount);
            else
                donatesOfCurrentBlock = new Dividends
                {
                    Value =
                    {
                        { input.Symbol, input.Amount }
                    }
                };

            State.DonatedDividends[Context.CurrentHeight] = donatesOfCurrentBlock;

            Context.Fire(new DonationReceived
            {
                From = Context.Sender,
                Symbol = input.Symbol,
                Amount = input.Amount,
                PoolContract = Context.Self
            });
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L676-680)
```csharp
        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });
```

**File:** protobuf/token_converter_contract.proto (L135-143)
```text
message SellInput {
    // The token symbol you want to sell.
    string symbol = 1;
    // The amount you want to sell.
    int64 amount = 2;
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
}
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-212)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }

    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L24-54)
```csharp
    ///     Get token return:
    ///     Return = (1 - (fromConnectorBalance / (fromConnectorBalance + paidAmount))
    ///     ^(fromConnectorWeight/toConnectorWeight))*toConnectorBalance
    /// </summary>
    /// <param name="fromConnectorBalance"></param>
    /// <param name="fromConnectorWeight"></param>
    /// <param name="toConnectorBalance"></param>
    /// <param name="toConnectorWeight"></param>
    /// <param name="paidAmount"></param>
    /// <returns></returns>
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```
