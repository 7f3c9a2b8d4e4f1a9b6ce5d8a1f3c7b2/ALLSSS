# Audit Report

## Title
Missing Miner List Validation in NextRound Transitions Allows Consensus Disruption via Inflated Miner Count

## Summary
The NextRound validation logic fails to verify that the provided round's miner list matches the authorized miners from the current round. A malicious miner can inject fake entries into `RealTimeMinersInformation` during round transitions, causing consensus order calculations to use an inflated miner count that disrupts the deterministic ordering mechanism and time slot scheduling.

## Finding Description

The vulnerability exists in the validation flow for NextRound consensus behavior. When a miner produces a block to transition to the next round, the validation only checks internal consistency of the provided round but does not validate that the miner list matches the authorized miners from the base round.

**Validation Gap:**
The `NextRoundMiningOrderValidationProvider` performs only internal consistency checking: [1](#0-0) 

For a freshly generated next round, all miners have `OutValue = null` and `FinalOrderOfNextRound = 0` (default values), so the validation passes with `0 == 0` even if fake miners are added with these same default values: [2](#0-1) 

**Missing Protection:**
The validation context provides both `BaseRound` (trusted current round from state) and `ProvidedRound` (from block header): [3](#0-2) 

However, no validator compares the miner lists between these rounds. The validation for NextRound only includes `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`: [4](#0-3) 

**State Corruption:**
After passing validation, the corrupted round is written directly to state without any miner list verification: [5](#0-4) 

**Consensus Disruption:**
Subsequent block production uses the inflated miner count for critical consensus calculations: [6](#0-5) 

The order calculation `GetAbsModulus(sigNum, minersCount) + 1` produces incorrect values when `minersCount` is inflated, disrupting the deterministic miner ordering mechanism.

**Persistence:**
Fake miners persist across subsequent rounds because `GenerateNextRoundInformation` copies all miners from the current round's `RealTimeMinersInformation`, including fake entries: [7](#0-6) 

## Impact Explanation

**High Severity - Consensus Integrity Violation:**

1. **Incorrect Order Assignments**: The inflated `minersCount` causes `ApplyNormalConsensusData` to calculate wrong mining orders, breaking the deterministic consensus ordering mechanism that is fundamental to AEDPoS.

2. **Time Slot Desynchronization**: Mining interval and time slot calculations depend on the miner count, causing schedule disruption across the entire network.

3. **Persistent Disruption**: Fake miners accumulate missed time slots and persist until the next term transition. With `TolerableMissedTimeSlotsCount` set to 4,320 slots (3 days): [8](#0-7) 

4. **Protocol-Wide Impact**: All validators and miners are affected, as consensus order and timing affects every block production cycle.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Complexity**: The attacker only needs to:
   - Be an authorized miner in the current round (passes `MiningPermissionValidationProvider`)
   - Wait for their turn to produce a NextRound block
   - Modify the generated next round data before including it in the block header

2. **No Special Privileges Required**: Any current miner can execute this attack, as they control their block production software and can modify consensus extra data before including it in the block.

3. **Silent Execution**: The attack succeeds without triggering validation failures, making detection difficult until observable symptoms appear (missed time slots, disrupted block production).

4. **Single Point of Failure**: Only one malicious miner is needed to corrupt consensus state for the entire network.

## Recommendation

Add validation in `NextRoundMiningOrderValidationProvider` to verify that the miner list in the provided next round matches the miner list in the base round:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    var baseRound = validationContext.BaseRound;
    
    // NEW: Verify miner list matches between rounds (miner list should only change during NextTerm)
    var providedMiners = providedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var baseMiners = baseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    if (!providedMiners.SequenceEqual(baseMiners))
    {
        validationResult.Message = "Next round miner list does not match current round miner list.";
        return validationResult;
    }
    
    // Existing validation
    var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

The attack can be demonstrated by:

1. Setting up a test environment with N legitimate miners in round R
2. Having one miner generate the NextRound consensus data for round R+1
3. Before submitting the block, modify `RealTimeMinersInformation` to add M fake miners with default values (`OutValue = null`, `FinalOrderOfNextRound = 0`)
4. Submit the block - validation passes because both sides of the check equal 0
5. Observe that `State.Rounds[R+1].RealTimeMinersInformation.Count` equals N+M instead of N
6. In subsequent UpdateValue blocks, verify that `ApplyNormalConsensusData` uses the inflated count (N+M) for order calculations
7. Confirm fake miners accumulate missed time slots and persist into round R+2

The test would verify that the validator accepts a next round with an inflated miner count and that this corrupted state is written and persists, violating the consensus invariant that miner lists remain constant within a term.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L16-18)
```csharp
        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-27)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
