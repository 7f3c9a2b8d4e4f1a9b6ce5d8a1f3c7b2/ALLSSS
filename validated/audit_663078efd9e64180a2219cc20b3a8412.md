# Audit Report

## Title
Taylor Series Non-Convergence in Exp() Enables DoS and Mispricing Attacks via Extreme Connector Weight Ratios

## Summary
The `Exp()` function in `BancorHelper.cs` uses a fixed 20-term Taylor series expansion that is insufficient for large magnitude inputs. When connector weights have extreme ratios (e.g., 0.001:0.999), the computed value `y * Ln(x)` can reach hundreds or thousands, causing either decimal overflow (transaction DoS) or massive convergence errors (incorrect pricing enabling arbitrage). This affects all `Buy()` and `Sell()` operations for the affected connector pairs.

## Finding Description

The root cause lies in the hardcoded 20-iteration limit in the exponential calculation. [1](#0-0) 

The `Exp()` function computes the Taylor series expansion with exactly 20 terms. [2](#0-1) 

This `Exp()` is invoked from both critical Bancor pricing functions:

1. In `GetReturnFromPaid()`, it computes `Exp(y * Ln(x))` where `y = fromWeight / toWeight`. [3](#0-2) 

2. In `GetAmountToPayFromReturn()`, it computes `Exp(y * Ln(x))` where `y = toWeight / fromWeight`. [4](#0-3) 

The value `y` represents the ratio of connector weights. Connector weights are validated only to be in the exclusive range (0, 1), with no validation of their ratio. [5](#0-4) [6](#0-5) 

**Critical Gap:** If one weight is 0.001 and another is 0.999, the ratio `y` can be 999. The `Ln()` function accepts inputs in range (0, 2). [7](#0-6) 

For `GetAmountToPayFromReturn()`:
- When `x = bt/(bt-a)` approaches 2, `Ln(2) ≈ 0.693`
- With weight ratio 999: `z = 999 × 0.693 ≈ 692`
- Computing `Exp(692)` requires calculating `692^20 / 20!`
- The value `692^20` is approximately 10^56, which vastly exceeds `decimal.MaxValue` (≈ 7.9×10^28)

The overflow occurs during binary exponentiation in the `Pow()` function when computing intermediate powers. [8](#0-7) 

These pricing functions are invoked directly from public trading operations. [9](#0-8) [10](#0-9) 

The AElf runtime enforces `CheckForOverflowUnderflow=true`, meaning arithmetic overflow throws `OverflowException` and causes transaction failure. [11](#0-10) 

## Impact Explanation

**High Severity - Dual Impact:**

1. **Denial of Service (Availability Impact):**
   - When `|y * Ln(x)| > ~60`, the `Pow()` function encounters decimal overflow during intermediate calculations
   - Throws `OverflowException` causing all `Buy()` and `Sell()` transactions to revert with status `Failed`
   - Demonstrated by existing overflow tests showing transaction failures. [12](#0-11) 
   - Complete DoS of token conversion functionality for affected connector pairs
   - Liquidity effectively locked as trading becomes impossible

2. **Price Manipulation (Fund Impact):**
   - When `10 < |y * Ln(x)| < 60`, no overflow occurs but 20-term approximation produces grossly inaccurate results
   - For `exp(30)`, true value ≈ 10^13, but 20-term Taylor series can be off by orders of magnitude
   - Incorrect prices in Bancor calculations enable arbitrage attacks
   - Users receive wrong token amounts
   - Protocol treasury receives incorrect fees based on mispriced conversions

**Affected Parties:**
- All users trading affected connector pairs
- Protocol treasury (fee miscalculation)
- Overall protocol integrity and user trust

## Likelihood Explanation

**Medium-High Likelihood:**

**Attack Requirements:**
1. Connector pairs must be created with extreme weight ratios (e.g., 0.001:0.999)
2. Connectors must be enabled for trading via `EnableConnector()`
3. Trade amounts must push `x` values toward bounds

**Precondition Feasibility:**
- Connector creation requires governance action (Parliament controller by default). [13](#0-12) 
- However, current validation only checks individual weights are in (0,1), NOT their ratios
- No documentation warns against extreme weight ratios
- Existing tests only cover moderate ratios (0.5:0.6 ≈ 1.2), not extreme cases. [14](#0-13) 
- Governance might legitimately create such pairs for specific economic models (e.g., pegged assets with asymmetric risk profiles)

**Execution Simplicity:**
- Once vulnerable connectors exist, any user can trigger DoS via public `Buy()`/`Sell()` methods
- Attack cost: Only transaction fees
- Attack benefit: DoS of critical infrastructure OR profit from mispricing arbitrage
- Highly favorable risk/reward ratio

## Recommendation

Implement multi-layered protection:

1. **Add Weight Ratio Validation:**
   - In `AssertValidConnectorWeight()`, add check that weight ratios remain within safe bounds
   - Reject connector configurations where `max(w1/w2, w2/w1) > MAX_SAFE_RATIO` (e.g., 100)

2. **Add Input Bounds on Exp():**
   - Before calling `Exp(z)`, validate that `|z| < MAX_SAFE_EXP_INPUT` (e.g., 10)
   - Throw descriptive error if bounds exceeded

3. **Increase Taylor Series Terms:**
   - For production use, increase `_LOOPS` to at least 50-100 terms
   - Or use alternative exponential approximation methods for large inputs

4. **Add Documentation:**
   - Document safe weight ratio ranges in connector configuration guides
   - Add inline comments warning about convergence limits

## Proof of Concept

```csharp
[Fact]
public void ExtremeWeightRatio_CausesOverflow_Test()
{
    // Setup: Connector pair with extreme weight ratio
    var fromWeight = 0.001m;  // Very small weight
    var toWeight = 0.999m;    // Very large weight
    var fromBalance = 1000000L;
    var toBalance = 1000000L;
    var amountToReceive = 400000L;  // Approaching toBalance/2
    
    // This should overflow because:
    // y = toWeight/fromWeight = 0.999/0.001 = 999
    // x = toBalance/(toBalance-amount) = 1000000/600000 ≈ 1.67
    // Ln(1.67) ≈ 0.51
    // z = 999 * 0.51 ≈ 510
    // Exp(510) will overflow in Pow(510, 20) computation
    
    Should.Throw<OverflowException>(() => 
        BancorHelper.GetAmountToPayFromReturn(
            fromBalance, fromWeight,
            toBalance, toWeight,
            amountToReceive));
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Configuration Risk:** Governance might unknowingly approve connector configurations with dangerous weight ratios, as no validation warns them
2. **Legitimate Use Cases:** Some economic models might genuinely require varied weights (e.g., stability mechanisms, pegged assets), making it unclear whether extreme ratios are intentional
3. **Cascading Impact:** Once vulnerable connectors exist, the DoS affects ALL users of that trading pair, not just attackers
4. **Detection Difficulty:** The issue only manifests when specific trade amounts push calculations near bounds, making it hard to detect during normal testing

The mathematical root cause is fundamental: Taylor series convergence requires the number of terms to scale with input magnitude. A fixed 20-term limit is insufficient for the unbounded weight ratios currently permitted by the system.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L51-53)
```csharp
        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L131-132)
```csharp
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/project.md (L20-30)
```markdown
- It is required to enable `CheckForOverflowUnderflow` for both Release and Debug mode so that your contract will use arithmetic operators that will throw `OverflowException` if there is any overflow. This is to ensure that execution will not continue in case of an overflow in your contract and result with unpredictable output.

```xml
<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>
```
```

**File:** test/AElf.Contracts.TestContract.Tests/ContractSecurityTests.cs (L35-36)
```csharp
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        transactionResult.Error.Contains("System.OverflowException").ShouldBeTrue();
```

**File:** test/AElf.Contracts.TokenConverter.Internal.Tests/BancorHelperTest.cs (L15-31)
```csharp
        _writeConnector = new Connector
        {
            Symbol = "WRITE",
            VirtualBalance = 50_0000,
            Weight = "0.5",
            IsVirtualBalanceEnabled = false,
            IsPurchaseEnabled = true
        };

        _elfConnector = new Connector
        {
            Symbol = "ELF",
            VirtualBalance = 100_0000,
            Weight = "0.6",
            IsPurchaseEnabled = true,
            IsVirtualBalanceEnabled = false
        };
```
