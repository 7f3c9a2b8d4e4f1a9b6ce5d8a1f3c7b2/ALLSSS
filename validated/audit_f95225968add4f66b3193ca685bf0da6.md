# Audit Report

## Title
Missing Validation of MissedTimeSlots Allows Malicious Extra Block Producer to Frame Honest Miners as Evil Nodes

## Summary
The AEDPoS consensus contract lacks validation to ensure that `MissedTimeSlots` values in `NextRoundInput` are correctly derived from the current round state. A malicious extra block producer can arbitrarily inflate `MissedTimeSlots` for victim miners, causing them to be falsely detected as evil nodes and permanently banned from the consensus set in the subsequent round transition.

## Finding Description

The vulnerability exists in a multi-contract flow involving the consensus and election contracts:

**Evil Node Detection Mechanism**

During round transitions, `ProcessNextRound` checks if any miner has `MissedTimeSlots >= TolerableMissedTimeSlotsCount` to identify evil nodes: [1](#0-0) 

The detection threshold is set to 4320 time slots (3 days): [2](#0-1) 

The actual evil detection logic filters miners based on this threshold: [3](#0-2) 

**Expected Deterministic Behavior**

When generating the next round, `MissedTimeSlots` should be deterministically computed: miners who produced blocks carry forward their current count, while miners who missed get their count incremented by 1: [4](#0-3) 

**Missing Validation**

The validation framework for `NextRound` behavior only checks that the round number increments correctly and that all InValues are null: [5](#0-4) 

Additionally, it verifies that miners with non-zero `FinalOrderOfNextRound` match those who mined: [6](#0-5) 

These validation providers are applied through the validation framework: [7](#0-6) 

However, **no validation provider checks that `MissedTimeSlots` or `ProducedBlocks` values in the proposed next round are correctly derived from the current round state**.

**Permanent Ban Without Evidence Validation**

When a miner is marked as evil, the election contract permanently bans them without validating the underlying evidence: [8](#0-7) 

**Attack Flow**

1. Attacker waits to be selected as extra block producer (deterministic rotation based on signatures)
2. Attacker calls `GetConsensusBlockExtraData` which generates legitimate `NextRoundInput` via `GenerateNextRoundInformation`
3. Attacker modifies the returned `NextRoundInput`, changing victim's `MissedTimeSlots` from current value to 4320 or higher
4. Attacker produces block with manipulated `NextRoundInput`
5. Block passes all existing validations (which don't check `MissedTimeSlots`)
6. Manipulated state becomes canonical
7. In the next round, `ProcessNextRound` detects victim as evil based on inflated `MissedTimeSlots`
8. Victim is permanently banned, removed from candidates, and stripped of beneficiary status

The `NextRoundInput.ToRound()` method simply copies all fields including the manipulated `MissedTimeSlots`: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Compromise**: The vulnerability allows arbitrary removal of honest, well-performing miners from the consensus set, undermining the fundamental security assumption that only genuinely misbehaving miners should be penalized.

**Targeted Censorship**: An attacker can selectively target specific miners (competitors, rival organizations) for permanent removal without any actual misbehavior on the victim's part.

**Permanent Economic Damage**: Once marked as evil, the miner:
- Is permanently banned via `BannedPubkeyMap`
- Is removed from the candidates list
- Loses all beneficiary rights
- Is removed from data center rankings

Recovery requires going through the replacement mechanism with a new public key, resulting in loss of reputation, voting weight, and accumulated rewards.

**Network Stability Risk**: If multiple honest miners are simultaneously removed, the network could fall below the minimum viable miner count, potentially affecting consensus liveness.

## Likelihood Explanation

**Attacker Prerequisites**: The attacker must be a miner and must be selected as the extra block producer. The extra block producer is selected deterministically based on the first miner's signature: [10](#0-9) 

In a network with N miners, each miner has approximately a 1/N chance per round to become the extra block producer. For the standard configuration of 17 miners, this occurs roughly once every 17 rounds.

**Attack Complexity**: Low. The attacker only needs to:
1. Wait for selection as extra block producer (passive)
2. Obtain legitimate next round data via `GetConsensusBlockExtraData`
3. Modify the `MissedTimeSlots` field for target victims
4. Produce the block with manipulated data

**Feasibility**: High. The attack:
- Requires no special privileges beyond being a miner
- Has zero cost beyond normal block production
- Bypasses all existing validation checks
- Results in permanent damage to victims

**Economic Rationality**: The benefit (removing competitors, increasing relative voting power, satisfying external censorship incentives) can significantly outweigh the zero marginal cost.

## Recommendation

Add a validation provider to verify the continuity of statistical fields (`MissedTimeSlots` and `ProducedBlocks`) during round transitions:

```csharp
public class StatisticalContinuityValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        
        if (extraData.Behaviour != AElfConsensusBehaviour.NextRound)
        {
            validationResult.Success = true;
            return validationResult;
        }

        var currentRound = validationContext.BaseRound;
        var proposedRound = extraData.Round;
        
        // Verify MissedTimeSlots and ProducedBlocks continuity
        foreach (var minerInProposed in proposedRound.RealTimeMinersInformation)
        {
            var pubkey = minerInProposed.Key;
            var proposedMiner = minerInProposed.Value;
            
            if (currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
            {
                var currentMiner = currentRound.RealTimeMinersInformation[pubkey];
                
                // Check if miner mined in current round
                bool minedInCurrentRound = currentMiner.OutValue != null;
                
                if (minedInCurrentRound)
                {
                    // Should preserve MissedTimeSlots
                    if (proposedMiner.MissedTimeSlots != currentMiner.MissedTimeSlots)
                    {
                        validationResult.Message = $"Invalid MissedTimeSlots for {pubkey}: miner mined but count changed";
                        return validationResult;
                    }
                    
                    // ProducedBlocks should be preserved or incremented
                    if (proposedMiner.ProducedBlocks < currentMiner.ProducedBlocks)
                    {
                        validationResult.Message = $"Invalid ProducedBlocks for {pubkey}: count decreased";
                        return validationResult;
                    }
                }
                else
                {
                    // Should increment MissedTimeSlots by 1
                    if (proposedMiner.MissedTimeSlots != currentMiner.MissedTimeSlots + 1)
                    {
                        validationResult.Message = $"Invalid MissedTimeSlots for {pubkey}: should increment by 1";
                        return validationResult;
                    }
                    
                    // ProducedBlocks should remain same
                    if (proposedMiner.ProducedBlocks != currentMiner.ProducedBlocks)
                    {
                        validationResult.Message = $"Invalid ProducedBlocks for {pubkey}: should remain unchanged";
                        return validationResult;
                    }
                }
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this provider to the validation chain in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new StatisticalContinuityValidationProvider()); // Add this
    break;
```

## Proof of Concept

Due to the complexity of setting up a full consensus test environment with multiple miners and round transitions, a complete executable POC would require substantial test infrastructure. However, the vulnerability can be demonstrated by tracing the code flow:

1. In `GetConsensusExtraDataForNextRound`, the returned `NextRoundInput` contains `RealTimeMinersInformation` with `MissedTimeSlots` values
2. These values are copied verbatim via `NextRoundInput.ToRound()` during `ProcessNextRound`
3. No validation provider checks these values against the current round state
4. The manipulated values are used directly in `TryToDetectEvilMiners`

A malicious miner can verify this by:
- Intercepting the `NextRoundInput` before block production
- Modifying `MissedTimeSlots` for any miner to 4320
- Observing that the block is accepted and the victim is banned in the next round

The lack of validation can be confirmed by inspecting all validation providers - none perform continuity checks on `MissedTimeSlots` or `ProducedBlocks` fields.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
