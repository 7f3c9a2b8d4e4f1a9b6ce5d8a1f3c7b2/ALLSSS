# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound Allows Manipulation of Block Producer Privileges

## Summary
The AEDPoS consensus contract fails to validate the `ExtraBlockProducerOfPreviousRound` field during round transitions, allowing any miner to arbitrarily set this value when calling the `NextRound` method. This manipulated field is then used to grant unauthorized mining privileges before the round start time and additional tiny block production quota, directly compromising consensus fairness and reward distribution.

## Finding Description

The vulnerability exists in the round transition validation logic. When a miner calls the public `NextRound` method to transition to the next round, they provide a `NextRoundInput` structure containing the `ExtraBlockProducerOfPreviousRound` field. [1](#0-0) 

The validation performed by `ValidationForNextRound()` only checks that the round number increments correctly and that InValues are null, but **does not validate** that the `ExtraBlockProducerOfPreviousRound` field matches the actual sender or the legitimate extra block producer from the previous round: [2](#0-1) 

The validation service applies this validator for NextRound behavior: [3](#0-2) 

When processing the NextRound input, the system simply converts it to a Round object via `ToRound()`, which **directly copies** the unvalidated field: [4](#0-3) 

This is then processed without additional validation: [5](#0-4) 

The manipulated field is subsequently used in two critical consensus functions to grant special privileges:

**1. Mining permission before round start**: The `IsCurrentMiner()` function allows the `ExtraBlockProducerOfPreviousRound` to mine before the round officially begins: [6](#0-5) 

**2. Additional tiny block quota**: The consensus behavior provider grants extra tiny blocks beyond normal limits to the `ExtraBlockProducerOfPreviousRound`: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation**: An attacker can manipulate which miner receives privileged block production rights, breaking the fundamental fairness of the AEDPoS consensus mechanism.

1. **Unauthorized Mining Windows**: By setting the field to their own or another miner's pubkey when they shouldn't be the extra block producer, they grant that miner permission to mine during the pre-round period, a time slot they should not have access to.

2. **Additional Block Production Quota**: The designated miner receives `_maximumBlocksCount + blocksBeforeCurrentRound` tiny blocks instead of the normal `_maximumBlocksCount` limit, allowing significantly more block production than intended by the protocol.

3. **Reward Misallocation**: More blocks produced means more mining rewards. Since mining rewards are distributed based on blocks produced, this directly impacts the economics and fairness of reward distribution among miners, giving unfair advantage to the manipulated beneficiary.

4. **Block Producer Selection Manipulation**: By granting unauthorized miners extra time slots and quotas, the attacker can influence which miners produce blocks and when, undermining the consensus schedule integrity that is fundamental to AEDPoS.

5. **Chain-wide Impact**: This affects all participants in the network as it compromises the deterministic and fair nature of block production scheduling that the consensus mechanism is designed to guarantee.

## Likelihood Explanation

**HIGH Likelihood**:

- **Reachable Entry Point**: The `NextRound` method is a public RPC method callable by any miner in the current round: [8](#0-7) 

- **Minimal Attacker Capabilities**: The attacker only needs to be a valid miner in the current round to execute this exploit. The `PreCheck()` only verifies the sender is in the miner list: [9](#0-8) 

- **Trivial Execution**: The attack is as simple as constructing a `NextRoundInput` with an arbitrary `ExtraBlockProducerOfPreviousRound` value and calling the public `NextRound` method.

- **No Additional Barriers**: The validation logic has a clear gap - no validator checks this field against the actual sender or previous round state.

- **Immediate Benefit**: The attacker gains extra mining privileges in the very next round, providing immediate economic incentive through increased block production and mining rewards.

- **Low Detection Risk**: Since the field is accepted without validation, the manipulation appears as valid consensus data in the blockchain state.

## Recommendation

Add validation in `RoundTerminateValidationProvider.ValidationForNextRound()` to verify that the `ExtraBlockProducerOfPreviousRound` field matches the sender's pubkey. The validator should:

1. Check that the sender is the designated extra block producer from the current round
2. Verify that `ExtraBlockProducerOfPreviousRound` in the input matches the sender's pubkey

Example fix (pseudocode):
```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing round number check
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // NEW: Validate ExtraBlockProducerOfPreviousRound matches sender
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != validationContext.SenderPubkey)
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match sender." };
    
    // Existing InValues check
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Set up a consensus round with multiple miners
2. Have a miner who is NOT the designated extra block producer call `NextRound`
3. In the `NextRoundInput`, set `ExtraBlockProducerOfPreviousRound` to their own pubkey (or another miner's)
4. Verify the transaction succeeds without validation error
5. Verify in the next round that the manipulated miner has the extra privileges (can mine before round start, gets additional tiny blocks)

The test would confirm that any miner can manipulate this field without the consensus contract rejecting the transaction, and the manipulated field grants unauthorized privileges.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L13-13)
```csharp
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L31-31)
```csharp
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L64-79)
```csharp
                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
