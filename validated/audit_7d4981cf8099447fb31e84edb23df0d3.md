# Audit Report

## Title
TOCTOU Race in Mining Order Assignment Enables Duplicate Time Slot Assignments and Consensus Schedule Violations

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition in the AEDPoS consensus mechanism allows multiple miners to receive identical `FinalOrderOfNextRound` values when their signature hashes collide. The view function `GetConsensusExtraData` performs conflict detection on stale state snapshots, and subsequent transaction execution lacks validation against concurrently committed orders. When these duplicate order values propagate to the next round, multiple miners are assigned identical time slots and mining timestamps, directly violating the fundamental consensus invariant that each miner must have a unique position in the mining schedule.

## Finding Description

The vulnerability stems from architectural separation between read-time conflict detection and write-time state updates in the mining order assignment mechanism.

**View-Time Conflict Detection on Stale State:**

When miners prepare to produce UpdateValue blocks, they call `GetConsensusExtraData`, which is marked as a view function in the ACS4 standard. [1](#0-0)  This function reads the current round state and invokes `ApplyNormalConsensusData` on an in-memory copy to calculate `FinalOrderOfNextRound`. [2](#0-1) 

The conflict detection logic checks which miners already have the calculated order value [3](#0-2)  and attempts to reassign conflicted miners to available slots. [4](#0-3)  However, this resolution occurs on an isolated in-memory copy, not the live contract state.

**Race Window:**

If Miner A and Miner B both have signatures that modulo to the same order value (calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1`), [5](#0-4)  and both call `GetConsensusExtraData` before either's UpdateValue transaction commits, they each see an empty conflicts list in their respective snapshots. Both miners calculate the same `FinalOrderOfNextRound` with no detected collision.

**Execution Without Re-Validation:**

When the UpdateValue transactions execute, `ProcessUpdateValue` directly applies the pre-calculated values from the transaction input: [6](#0-5)  The `TuneOrderInformation` map from the view call is also applied, [7](#0-6)  but this contains reassignments calculated at view-call time based on stale state, not reassignments based on the current committed state.

**Ineffective Validation:**

The `NextRoundMiningOrderValidationProvider` is invoked during NextRound block validation [8](#0-7)  and uses `.Distinct()` on `MinerInRound` objects. [9](#0-8)  Since `MinerInRound` is a protobuf-generated message [10](#0-9)  without custom equality overrides, `.Distinct()` uses reference equality rather than comparing the `FinalOrderOfNextRound` field values. This validation cannot detect when multiple distinct miner objects hold the same order value.

**Consensus Schedule Corruption:**

During next round generation, miners are ordered by their `FinalOrderOfNextRound` values from the current round, and these values become their `Order` and determine their `ExpectedMiningTime` in the new round. [11](#0-10)  Miners with duplicate `FinalOrderOfNextRound` values receive identical `Order` assignments and `ExpectedMiningTime` timestamps, creating time slot collisions where multiple miners are scheduled to produce blocks simultaneously.

## Impact Explanation

This vulnerability breaks the core consensus invariant that each miner must occupy a unique position in the block production schedule. Time slot collisions have cascading effects:

**Consensus Integrity Violation:** The deterministic mining schedule becomes ambiguous when multiple miners claim the same time slot. The protocol lacks a deterministic mechanism to choose between competing valid blocks from different authorized miners at identical timestamps.

**Potential Network Fork:** Nodes may accept different blocks at the same height depending on propagation timing, potentially causing temporary chain divergence until some resolution mechanism (outside the consensus contract's control) converges the network.

**Block Production Disruption:** Miners may experience validation failures or delays as the network attempts to process competing blocks for the same time slot, degrading transaction throughput and finality guarantees.

The severity is HIGH because consensus schedule integrity is a fundamental security property that all network participants depend on for transaction ordering and finality.

## Likelihood Explanation

**Natural Trigger Mechanism:** This vulnerability requires no malicious behavior. With N miners producing blocks, the probability that any two miners' signatures produce the same modulo value is approximately 1/N per mining pair. For a typical 17-miner configuration, signature collisions occur with non-negligible probability during normal operation.

**TOCTOU Window Characteristics:** The race window opens whenever multiple miners call the view function `GetConsensusExtraData` concurrently before any of their transactions commit. With block production intervals of ~4 seconds and multiple miners active simultaneously throughout each round, this window naturally occurs during regular network operation.

**Validation Gap:** The broken validation logic using reference equality means duplicate assignments persist undetected until they manifest as time slot collisions in the subsequent round. By then, the invalid state is already committed and the consensus schedule is corrupted.

**No Special Privileges Required:** Any authorized miner can trigger this issue simply by producing blocks according to normal consensus rules. The vulnerability manifests through natural hash collisions combined with concurrent view function calls.

Likelihood assessment: MEDIUM to HIGH frequency in active networks with multiple concurrent miners.

## Recommendation

**Implement Atomic Conflict Detection at Execution Time:**

Modify `ProcessUpdateValue` to re-check for order conflicts against the current committed state before applying the miner's `FinalOrderOfNextRound`, not just trust pre-calculated values from the view call. When a conflict is detected at execution time, either:
1. Revert the transaction and force the miner to recalculate with fresh state, or
2. Perform conflict resolution inline during transaction execution using current state

**Fix Validation Logic:**

Replace the `.Distinct()` call in `NextRoundMiningOrderValidationProvider` with explicit value-based uniqueness checking:

```csharp
var ordersAssigned = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
var uniqueOrdersCount = ordersAssigned.Distinct().Count();

if (uniqueOrdersCount != ordersAssigned.Count)
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}
```

**Add State-Level Uniqueness Constraint:**

Implement a secondary uniqueness check in `ProcessUpdateValue` or `TryToUpdateRoundInformation` that explicitly validates no two miners in the round state have identical `FinalOrderOfNextRound` values before committing.

## Proof of Concept

The vulnerability can be demonstrated by simulating concurrent `GetConsensusExtraData` calls from two miners whose signatures collide:

```csharp
[Fact]
public void TestDuplicateMiningOrderRaceCondition()
{
    // Setup: Create round with 17 miners, none have set FinalOrderOfNextRound yet
    var round = CreateRoundWithMiners(17);
    
    // Simulate Miner A calling GetConsensusExtraData
    var minerASignature = CreateSignatureWithModulo(5, 17); // Will calculate to order 6
    var roundAfterMinerA = round.Clone();
    roundAfterMinerA.ApplyNormalConsensusData("MinerA", Hash.Empty, Hash.Empty, minerASignature);
    Assert.Equal(6, roundAfterMinerA.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound);
    
    // Simulate Miner B calling GetConsensusExtraData BEFORE Miner A's transaction commits
    // Miner B sees the SAME original state (TOCTOU race window)
    var minerBSignature = CreateSignatureWithModulo(5, 17); // Same modulo = order 6
    var roundAfterMinerB = round.Clone(); // Same starting state as Miner A
    roundAfterMinerB.ApplyNormalConsensusData("MinerB", Hash.Empty, Hash.Empty, minerBSignature);
    Assert.Equal(6, roundAfterMinerB.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound);
    
    // Both miners submit transactions, both commit with order 6
    var finalRound = round.Clone();
    finalRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound = 6;
    finalRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound = 6;
    
    // Generate next round - both miners get same Order and ExpectedMiningTime
    GenerateNextRoundInformation(finalRound, Timestamp.FromDateTime(DateTime.UtcNow), 
        Timestamp.FromDateTime(DateTime.UtcNow.AddDays(-1)), out var nextRound);
    
    var minerAInNextRound = nextRound.RealTimeMinersInformation["MinerA"];
    var minerBInNextRound = nextRound.RealTimeMinersInformation["MinerB"];
    
    // VULNERABILITY CONFIRMED: Both have same Order and ExpectedMiningTime
    Assert.Equal(minerAInNextRound.Order, minerBInNextRound.Order);
    Assert.Equal(minerAInNextRound.ExpectedMiningTime, minerBInNextRound.ExpectedMiningTime);
}
```

This test demonstrates that when two miners' view calls see the same state and their signatures collide, both receive the same mining order, which propagates to duplicate time slot assignments in the next round.

## Notes

The vulnerability is exacerbated by the architectural design where consensus data calculation happens in view functions called off-chain by miners, with conflict resolution performed on isolated state snapshots. The subsequent transaction execution trusts these pre-calculated values without re-validating against the actual committed state at execution time. This creates an inherent race condition window where concurrent miners can unknowingly commit conflicting order assignments.

### Citations

**File:** protobuf/acs4.proto (L25-27)
```text
    rpc GetConsensusExtraData (google.protobuf.BytesValue) returns (google.protobuf.BytesValue) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-26)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-290)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
