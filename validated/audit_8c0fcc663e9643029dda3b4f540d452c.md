# Audit Report

## Title
Improper Stale Miner Check Bypass When Miner List Changes Leads to Transaction Failures and Unauthorized Actions

## Summary
The `IsCurrentMiner` method contains a critical flaw in its handling of the `IsMinerListJustChanged` flag. When set to true, the miner existence check is bypassed, causing unhandled exceptions for replaced miners and allowing replaced extra block producers to retain miner privileges during round transitions, even after being identified as malicious.

## Finding Description

The vulnerability exists in the `IsCurrentMiner` method's handling of replaced miners when the miner list changes. [1](#0-0) 

When `IsMinerListJustChanged` is true, this condition bypasses the critical containment check that verifies the miner exists in the current round. The flag is correctly set during miner replacement: [2](#0-1) 

And properly propagated to the next round: [3](#0-2) 

However, the `ConvertAddressToPubkey` helper searches both current and previous rounds: [4](#0-3) 

This allows replaced miners (present in previous round but removed from current round) to have their public key returned. When `IsCurrentMiner` is called with this pubkey, the containment check is bypassed, and unless they're the extra block producer during transition, execution continues to direct dictionary access without verification: [5](#0-4) 

This causes a `KeyNotFoundException` because the replaced miner doesn't exist in the current round.

Additionally, replaced miners who were the extra block producer pass the transition check: [6](#0-5) 

The extra block producer is set during round generation AFTER miner replacement occurs: [7](#0-6) 

This allows identified evil miners who happen to be producing the block during their replacement to retain privileges.

## Impact Explanation

**Primary Impact - Transaction Failures:** Replaced miners attempting to call miner-only functions will experience unhandled `KeyNotFoundException` exceptions, causing transaction failures and exposing implementation flaws. These functions include: [8](#0-7) 

And cross-chain indexing operations: [9](#0-8) 

Used by: [10](#0-9) 

**Secondary Impact - Unauthorized Actions:** Replaced miners who were the extra block producer can continue performing miner-only actions during the transition window, even after being identified as malicious. This violates the security invariant that replaced (potentially evil) miners should have all privileges immediately revoked. They can call miner-only functions including cross-chain indexing and potentially inject malicious cross-chain data before the new round officially starts.

## Likelihood Explanation

**Primary Impact Likelihood:** Medium - Miner replacement occurs regularly when miners miss time slots or are detected as malicious: [11](#0-10) 

Replaced miners could manually attempt to call miner-only functions, triggering the exception.

**Secondary Impact Likelihood:** Medium-High - Whenever a replaced miner was producing the block during their own replacement, they are automatically set as `ExtraBlockProducerOfPreviousRound` and retain privileges during the transition window. This is a deterministic vulnerability that occurs regularly during normal consensus operations when evil miners are detected and replaced while they happen to be the block producer.

## Recommendation

Add a key existence check before accessing the dictionary:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;

    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

    if (!currentRound.IsMinerListJustChanged)
        if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return false;

    // Check confirmed extra block producer of previous round.
    if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
        currentRound.ExtraBlockProducerOfPreviousRound == pubkey &&
        currentRound.RealTimeMinersInformation.ContainsKey(pubkey)) // ADD THIS CHECK
    {
        Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
        return true;
    }

    // ADD: Always verify key exists before accessing dictionary
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;

    var miningInterval = currentRound.GetMiningInterval();
    var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
    // ... rest of the method
}
```

## Proof of Concept

The vulnerability can be demonstrated with a test that:
1. Simulates miner replacement during round transition
2. Has the replaced miner call `ClaimTransactionFees` or a cross-chain method
3. Observes `KeyNotFoundException` after transition window, or unauthorized success during transition window

The test would need to:
- Set up a round with multiple miners
- Mark one miner as evil and trigger replacement during block production
- Verify `IsMinerListJustChanged = true` in next round
- Have replaced miner attempt miner-only function call
- Assert either exception (after transition) or unauthorized success (during transition)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-158)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L14-14)
```csharp
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-187)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L905-905)
```csharp
        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```
