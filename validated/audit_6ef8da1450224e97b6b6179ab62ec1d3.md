# Audit Report

## Title
NFT Collection Impersonation via Front-Running CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function fails to validate that existing NFT collection properties match those from the source chain during cross-chain synchronization. An attacker can front-run legitimate collection synchronization by creating a fake collection with the same symbol on the main chain, causing cross-chain NFT items to reference the attacker's malicious collection and granting them unauthorized control over collection-owner-gated operations.

## Finding Description

The vulnerability exists in the `CrossChainCreateToken` method's handling of NFT collections during cross-chain token creation. When an NFT collection is synchronized from a side chain to the main chain, the function calls `AssertNftCollectionExist` to verify the collection exists but critically discards the returned collection information without comparing it against the properties being synchronized from the source chain. [1](#0-0) 

The function constructs a new `TokenInfo` object using properties from the cross-chain input, but if a collection with that symbol already exists on the destination chain, it only updates alias information without validation or overwriting the existing token properties. [2](#0-1) 

This differs fundamentally from local NFT creation, where `CreateNFTInfo` properly validates that the NFT item's properties match the collection's properties, including IssueChainId and Owner validation. [3](#0-2) 

On the main chain (where `State.SideChainCreator.Value == null`), anyone possessing a valid seed NFT can create NFT collections locally, enabling the attack vector. [4](#0-3) 

**Attack Flow:**
1. Legitimate user creates NFT collection "COLLECTION-0" on side chain with Owner=Alice, IssueChainId=SideChainId
2. Attacker monitors cross-chain synchronization attempts
3. Attacker front-runs by creating "COLLECTION-0" on main chain with Owner=Attacker, IssueChainId=MainChainId using a seed NFT
4. When legitimate `CrossChainCreateToken` executes, it sees the collection already exists and only updates alias information
5. Later, NFT items "COLLECTION-1", "COLLECTION-2" are synchronized with their correct properties from the side chain
6. Operations like `SetSymbolAlias` check the collection owner/issuer for permissions, but reference the attacker's fake collection

The `SetSymbolAlias` method demonstrates the permission bypass by checking the collection owner rather than the individual NFT item owner: [5](#0-4) 

This check validates against the attacker's fake collection rather than the legitimate collection from the source chain.

## Impact Explanation

This vulnerability has **Medium** severity with the following impacts:

1. **Unauthorized Permission Control**: The attacker gains control over collection-owner-gated operations (specifically `SetSymbolAlias`) for NFT items they do not legitimately own, allowing them to set aliases for NFTs belonging to other users.

2. **Loss of Legitimate Control**: The actual NFT collection owner from the source chain loses the ability to perform collection-owner-restricted operations on their own NFTs on the destination chain.

3. **Cross-Chain Integrity Violation**: NFT items synchronized from the side chain reference a collection with fundamentally different properties (different Owner, Issuer, and IssueChainId), breaking the security invariant that NFT items must belong to collections from the same issuance context.

4. **Persistent State Corruption**: Once the fake collection is created, it cannot be overwritten by legitimate cross-chain synchronization. The corrupted state persists indefinitely.

While this vulnerability does not directly result in fund theft, it represents a serious breach of ownership and authorization controls in the NFT system, with potential economic significance for valuable NFT collections where alias control or other collection-owner operations have value.

## Likelihood Explanation

The likelihood of exploitation is **Medium-High** with the following factors:

**Attacker Requirements:**
- Must acquire a valid seed NFT (bounded cost through normal creation mechanisms)
- Must monitor mempool or cross-chain events to detect collection synchronization attempts
- Must successfully front-run the legitimate `CrossChainCreateToken` transaction

**Feasibility:**
- The attack specifically targets synchronization FROM side chains TO main chain, as side chains prevent local collection creation through the `State.SideChainCreator.Value` check
- Front-running is achievable through mempool monitoring or higher gas fees
- No automatic detection mechanism exists to alert legitimate users of the property mismatch
- The fake collection appears valid on-chain without cross-chain property comparison

**Exploitation Timing:**
- A timing window exists during any NFT collection cross-chain synchronization
- Attackers can prepare in advance once they identify valuable collections on side chains

The primary barrier is seed NFT acquisition cost, but this represents a one-time bounded investment that enables attacks on multiple collections.

## Recommendation

Add validation in `CrossChainCreateToken` to compare existing token properties against cross-chain input when the token already exists:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var collectionInfo = AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
    
    var tokenInfo = new TokenInfo { /* ... */ };
    
    var existingToken = State.TokenInfos[tokenInfo.Symbol];
    if (existingToken != null)
    {
        // Validate that existing token properties match cross-chain input
        Assert(existingToken.Owner == tokenInfo.Owner, "Token owner mismatch");
        Assert(existingToken.Issuer == tokenInfo.Issuer, "Token issuer mismatch");
        Assert(existingToken.IssueChainId == tokenInfo.IssueChainId, "Token issue chain ID mismatch");
        Assert(existingToken.TotalSupply == tokenInfo.TotalSupply, "Token total supply mismatch");
        
        // Update alias if changed
        if (isSymbolAliasSet && validateTokenInfoExistsInput.ExternalInfo.TryGetValue(
            TokenContractConstants.TokenAliasExternalInfoKey, out var tokenAliasSetting))
        {
            State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
        }
    }
    else
    {
        RegisterTokenInfo(tokenInfo);
        // ... fire event ...
    }
    
    return new Empty();
}
```

Additionally, when synchronizing NFT items, validate that their properties are consistent with the collection:

```csharp
if (collectionInfo != null)
{
    Assert(tokenInfo.IssueChainId == collectionInfo.IssueChainId,
        "NFT item issue chain ID must match collection's issue chain ID");
    Assert(tokenInfo.Owner == collectionInfo.Owner,
        "NFT item owner must match collection's owner");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NFT_Collection_Impersonation_Front_Run_Attack()
{
    // Setup: Create legitimate NFT collection on side chain
    var legitimateOwner = Accounts[1].Address;
    var attacker = Accounts[2].Address;
    var collectionSymbol = "COLL-0";
    
    // 1. Create legitimate collection on side chain
    var sideChainResult = await SideChainTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = collectionSymbol,
        TokenName = "Legitimate Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = legitimateOwner,
        Owner = legitimateOwner,
        IsBurnable = true
    });
    sideChainResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 2. Attacker front-runs by creating fake collection on main chain
    var attackerResult = await AttackerTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = collectionSymbol,
        TokenName = "Fake Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = attacker,
        Owner = attacker,  // Attacker is owner
        IsBurnable = true
    });
    attackerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 3. Legitimate cross-chain sync attempts to create collection
    var validateTransaction = CreateValidateTokenTransaction(collectionSymbol);
    var crossChainResult = await TokenContractStub.CrossChainCreateToken.SendAsync(
        CreateCrossChainInput(validateTransaction));
    crossChainResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 4. Verify fake collection still exists with attacker as owner
    var collectionInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = collectionSymbol });
    collectionInfo.Owner.ShouldBe(attacker);  // VULNERABILITY: Attacker owns collection
    
    // 5. Create NFT item via cross-chain
    var itemSymbol = "COLL-1";
    var itemValidateTransaction = CreateValidateTokenTransaction(itemSymbol);
    await TokenContractStub.CrossChainCreateToken.SendAsync(
        CreateCrossChainInput(itemValidateTransaction));
    
    // 6. Attacker can now set alias (collection-owner operation) for item they don't own
    var setAliasResult = await AttackerTokenContractStub.SetSymbolAlias.SendAsync(
        new SetSymbolAliasInput
        {
            Symbol = itemSymbol,
            Alias = "COLL"
        });
    setAliasResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);  
    // VULNERABILITY: Attacker successfully set alias using fake collection ownership
    
    // 7. Legitimate owner CANNOT set alias
    var legitimateSetAliasResult = await LegitimateOwnerTokenContractStub.SetSymbolAlias
        .SendWithExceptionAsync(new SetSymbolAliasInput
        {
            Symbol = itemSymbol,
            Alias = "COLL2"
        });
    legitimateSetAliasResult.TransactionResult.Error.ShouldContain("No permission");
    // Legitimate owner is denied permission on their own NFT
}
```

**Notes**: This vulnerability breaks the fundamental security invariant that NFT items must belong to collections with matching ownership properties across chains. The attack is feasible because seed NFT acquisition has a bounded cost, and front-running is a standard blockchain attack vector. The impact is significant as it grants unauthorized control over collection-level operations and permanently corrupts cross-chain state integrity.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L54-65)
```csharp
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L491-491)
```csharp
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-530)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L747-761)
```csharp
        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L17-36)
```csharp
        var nftCollectionInfo = AssertNftCollectionExist(input.Symbol);
        input.IssueChainId = input.IssueChainId == 0 ? nftCollectionInfo.IssueChainId : input.IssueChainId;
        Assert(
            input.IssueChainId == nftCollectionInfo.IssueChainId,
            "NFT issue ChainId must be collection's issue chainId");
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
        else
        {
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
        }
        
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```
