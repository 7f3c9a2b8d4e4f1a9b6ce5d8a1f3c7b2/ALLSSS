# Audit Report

## Title
Election Deposit Refund Mismatch After Contract Upgrade Due to Hard-Coded Constant

## Summary
The Election contract uses a compile-time constant for both locking and unlocking candidate deposits but does not persist the actual locked amount in state. When the contract is upgraded with a modified constant value, pre-upgrade candidates will receive incorrect refunds, causing either complete denial of service or permanent fund loss.

## Finding Description

The vulnerability exists in the Election contract's deposit mechanism where both lock and unlock operations rely on reading the same constant value at execution time, rather than storing the actual locked amount.

**Lock Operation**: When a candidate announces election, `LockCandidateNativeToken()` transfers exactly `ElectionContractConstants.LockTokenForElection` tokens to a virtual address. [1](#0-0) 

The constant is defined as a compile-time value of 100,000 ELF (with 8 decimals). [2](#0-1) 

**State Storage Gap**: The contract only stores `AnnouncementTransactionId` in the `CandidateInformation` state object. The protobuf definition confirms there is no field for the locked deposit amount. [3](#0-2) 

**Unlock Operation**: When a candidate quits election, `QuitElection` retrieves the lock ID from state but reads the constant value again to determine the unlock amount. [4](#0-3) 

**Balance Enforcement**: The MultiToken contract's `ModifyBalance` method enforces balance constraints. When attempting to transfer more tokens than exist in the virtual address, it asserts with an "Insufficient balance" error, causing transaction failure. [5](#0-4) 

C# constants declared with `const` are compile-time values embedded directly in IL bytecode. When the contract is recompiled and upgraded through AElf's standard governance process, these constants change to their new values, breaking the fundamental invariant that locked and unlocked amounts must match.

## Impact Explanation

**Scenario 1 - Constant Increases (Complete DoS)**:
If governance increases the constant (e.g., from 100,000 to 200,000 tokens):
- Pre-upgrade candidates' virtual addresses contain only 100,000 tokens
- `QuitElection` attempts to `TransferFrom` 200,000 tokens
- The MultiToken `ModifyBalance` check `if (addAmount < 0 && before < -addAmount)` evaluates to `if (-200k < 0 && 100k < 200k)` = TRUE
- Transaction reverts with "Insufficient balance"
- All pre-upgrade candidates are permanently unable to quit election and recover their deposits

**Scenario 2 - Constant Decreases (Direct Fund Loss)**:
If governance decreases the constant (e.g., from 100,000 to 50,000 tokens):
- Pre-upgrade candidates' virtual addresses contain 100,000 tokens
- `QuitElection` successfully transfers only 50,000 tokens back to the candidate
- Remaining 50,000 tokens per candidate are permanently locked in inaccessible virtual addresses
- With 100 active candidates, total permanent loss would be 5,000,000 tokens

The test suite confirms this behavior - the unlock amount is always expected to exactly match the constant value at execution time. [6](#0-5) 

## Likelihood Explanation

**Trigger Path**: This is not an attack scenario but a protocol design flaw that manifests during legitimate operations:
1. Parliament proposes and approves a contract upgrade through standard governance
2. Developers modify `LockTokenForElection` to adjust deposit requirements (economically reasonable if native token price changes significantly)
3. Contract is recompiled and deployed via `UpdateSmartContract`
4. Any pre-upgrade candidate calls `QuitElection`
5. Vulnerability triggers automatically

**Realistic Preconditions**: 
- Contract upgrades are routine maintenance operations in AElf and happen through the Genesis contract's `UpdateSmartContract` method
- Economic parameter adjustments are normal governance activities - if native token price increases 10x, a 100k ELF deposit becomes prohibitively expensive
- No migration logic or state field exists to track the actual locked amounts
- Developers would naturally update the constant value without realizing the impact on existing deposits
- No code comments or warnings indicate this constraint

**Probability**: HIGH - The adjustment of economic parameters like deposit requirements is a standard governance action that would reasonably occur during the protocol's lifetime as market conditions change.

## Recommendation

Add a state field to store the actual locked amount for each candidate:

1. **Modify the protobuf definition** to add a `locked_deposit_amount` field to `CandidateInformation`:
```protobuf
message CandidateInformation {
    // ... existing fields ...
    int64 locked_deposit_amount = 8;
}
```

2. **Update `LockCandidateNativeToken()`** to store the locked amount:
```csharp
private void LockCandidateNativeToken()
{
    var lockAmount = ElectionContractConstants.LockTokenForElection;
    // ... existing transfer logic ...
    
    // Store the actual locked amount in state
    var candidateInfo = State.CandidateInformationMap[pubkey];
    candidateInfo.LockedDepositAmount = lockAmount;
    State.CandidateInformationMap[pubkey] = candidateInfo;
}
```

3. **Update `QuitElection`** to use the stored amount:
```csharp
var candidateInformation = State.CandidateInformationMap[pubkey];
var refundAmount = candidateInformation.LockedDepositAmount;
State.TokenContract.TransferFrom.Send(new TransferFromInput
{
    // ... existing fields ...
    Amount = refundAmount,  // Use stored amount instead of constant
    // ...
});
```

4. **Add migration logic** in a contract upgrade to populate `locked_deposit_amount` for existing candidates using the old constant value.

## Proof of Concept

The vulnerability can be demonstrated by simulating a contract upgrade scenario:

```csharp
[Fact]
public async Task Election_Deposit_Refund_Mismatch_After_Upgrade_Test()
{
    // Setup: Candidate announces election with OLD constant (100k ELF)
    var candidate = VoterKeyPairs.First();
    var initialBalance = 1000_000_00000000L;
    
    // Candidate locks 100k ELF under old contract version
    await AnnounceElectionAsync(candidate);
    
    var balanceAfterLock = await GetBalanceAsync(candidate.PublicKey);
    balanceAfterLock.ShouldBe(initialBalance - 100_000_00000000); // 100k locked
    
    // SIMULATE CONTRACT UPGRADE: Change constant to 200k ELF
    // (In real scenario, this would be a contract recompilation with modified constant)
    // The virtual address still contains only 100k ELF from the original lock
    
    // Attempt to quit election under NEW contract version
    // QuitElection will try to unlock 200k ELF but virtual address only has 100k
    var quitResult = await QuitElectionAsync(candidate);
    
    // EXPECTED: Transaction fails with "Insufficient balance"
    quitResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    quitResult.TransactionResult.Error.ShouldContain("Insufficient balance");
    
    // Candidate is permanently unable to recover their deposit
    var finalBalance = await GetBalanceAsync(candidate.PublicKey);
    finalBalance.ShouldBe(balanceAfterLock); // Still has 100k locked, cannot recover
}
```

## Notes

This vulnerability is a critical protocol-level design flaw that affects fund custody guarantees. The issue is particularly insidious because:

1. **Silent Failure During Development**: The vulnerability is not apparent during normal testing since tests use a single constant value throughout their execution.

2. **Legitimate Governance Action**: The trigger is a reasonable economic policy change, not a malicious action or edge case input.

3. **No Warning Signs**: The code contains no comments or safeguards warning developers about this constraint.

4. **Irreversible Impact**: Once triggered, there is no recovery mechanism - funds are either permanently locked or candidates are permanently DoS'd from exiting.

5. **Affects All Pre-Upgrade Candidates**: The impact is not limited to a single user but affects every candidate who announced election before the upgrade.

The fix requires careful migration planning to ensure existing deposits are properly accounted for before any constant value changes.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L187-194)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L240-249)
```csharp
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** protobuf/election_contract.proto (L365-380)
```text
message CandidateInformation {
    // Candidateâ€™s public key.
    string pubkey = 1;
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
    // The number of blocks the candidate has produced.
    int64 produced_blocks = 3;
    // The time slot for which the candidate failed to produce blocks.
    int64 missed_time_slots = 4;
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
    // The transaction id when the candidate announced.
    aelf.Hash announcement_transaction_id = 6;
    // Indicate whether the candidate can be elected in the current term.
    bool is_current_candidate = 7;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/LockTokenTest.cs (L59-74)
```csharp
        balance.Balance.ShouldBe(1000_000_00000000 - 100_000_00000000);
    }

    [Fact]
    public async Task Token_Unlock_Test()
    {
        await Token_Lock_Test();

        await tokenTestElectionContractStub.QuitElection.SendAsync(new StringValue
            { Value = AnnounceElectionKeyPair.PublicKey.ToHex() });
        var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(AnnounceElectionKeyPair.PublicKey),
            Symbol = EconomicSystemTestConstants.NativeTokenSymbol
        });
        balance.Balance.ShouldBe(1000_000_00000000L);
```
