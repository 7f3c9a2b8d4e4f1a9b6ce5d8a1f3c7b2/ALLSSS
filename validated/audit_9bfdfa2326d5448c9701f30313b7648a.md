# Audit Report

## Title
Conflict Resolution Fails When Current Miner's Old Order is Not Considered Available, Causing Duplicate Mining Order Assignments

## Summary
The `ApplyNormalConsensusData` function's conflict resolution logic fails to recognize that the current miner is vacating their old order position. When all N mining orders are occupied and a miner's calculated order conflicts with another miner, the reassignment algorithm cannot find an available slot because it checks the current state where the initiating miner's old order still appears occupied. This results in duplicate `FinalOrderOfNextRound` assignments, causing two miners to be scheduled for the same mining time slot in the subsequent round.

## Finding Description

The vulnerability exists in the order conflict resolution mechanism within the consensus round update logic. When a miner produces a block, their signature deterministically calculates a `supposedOrderOfNextRound` value. [1](#0-0) 

If another miner already occupies this calculated order as their `FinalOrderOfNextRound`, the algorithm identifies them as conflicted and attempts reassignment. [2](#0-1) 

The critical flaw occurs in the availability check for reassignment candidates. The algorithm verifies whether a candidate order is available by checking if any miner currently has that order assigned. However, this check examines the state **before** the current miner's order update is applied. [3](#0-2) 

**Scenario:** When Miner A (FinalOrderOfNextRound=1) produces a block and calculates order 2, which is occupied by Miner B, the reassignment loop (lines 31-40) attempts to find a new order for B. It checks order 1's availability at line 34, but Miner A still has FinalOrderOfNextRound=1 at this point. Only after the loop completes does the code update A's order to 2 at lines 42-44. [4](#0-3) 

The existing validation mechanisms fail to prevent this:

**UpdateValueValidationProvider** only verifies that OutValue and Signature fields are properly populated, without checking for duplicate order assignments. [5](#0-4) 

**NextRoundMiningOrderValidationProvider** uses `.Distinct()` on `MinerInRound` objects themselves, not on their `FinalOrderOfNextRound` values. Since each miner is a distinct object, this validation passes even when their order values are duplicated. [6](#0-5) 

The duplicate assignments flow through the state update mechanism via `ExtractInformationToUpdateConsensus`: [7](#0-6) 

And are applied to state during block execution in `ProcessUpdateValue`: [8](#0-7) 

When the next round is generated, both miners with duplicate orders are processed sequentially, each receiving the same `Order` value and identical `ExpectedMiningTime`: [9](#0-8) 

## Impact Explanation

**HIGH Severity - Consensus Protocol Integrity Violation**

This vulnerability directly breaks the fundamental AEDPoS consensus invariant that each validator must have a unique mining time slot. When `GenerateNextRoundInformation` processes miners with duplicate `FinalOrderOfNextRound` values, both receive identical `Order` assignments and `ExpectedMiningTime` values.

**Consensus Disruption:**
- **Mining Slot Collision**: Two validators scheduled to produce blocks simultaneously
- **Abandoned Time Slot**: The vacated order position remains unassigned
- **Chain Liveness Risk**: Conflicting block production attempts may cause forks or chain halt
- **Schedule Chaos**: Mining order integrity compromised for the entire round

**Affected Parties:**
- All network participants experience consensus instability
- Validators face ambiguous block production responsibilities
- Chain may fail to progress if mining conflicts cannot be resolved

The severity is HIGH because this compromises the core consensus mechanism that ensures orderly, sequential block production.

## Likelihood Explanation

**HIGH Likelihood - Occurs in Normal Operation**

**Triggering Conditions:**
1. **Steady State Operation**: All N validators have produced blocks in current round (all orders 1-N occupied) - this is the expected normal state
2. **Hash Collision**: A validator's signature hash modulo N produces a value conflicting with another validator's current order
3. **No Malicious Action**: Occurs through legitimate mining operations

**Entry Point:**
The vulnerability is reachable through the consensus block production flow, which calls `GetConsensusExtraDataToPublishOutValue`: [10](#0-9) 

**Probability Analysis:**
With N validators and signature-based order calculation using modulo arithmetic, hash collisions occur with probability 1/N per block. In steady-state operation where all orders are occupied (the normal condition), any collision between a validator's new calculated order and another validator's existing assignment triggers this bug.

**Feasibility:**
- No special setup required beyond normal network operation
- No adversarial behavior needed
- Difficult to detect before impact as validation doesn't catch duplicate assignments
- Reproducible whenever preconditions align (regularly in practice)

The likelihood is HIGH because this vulnerability manifests during routine consensus operation without requiring any attack vector or unusual network conditions.

## Recommendation

Fix the conflict resolution logic by excluding the current miner from the availability check, or by updating the current miner's order before reassigning conflicted miners. The corrected logic should recognize that the current miner is vacating their old order position:

```csharp
public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

    RealTimeMinersInformation[pubkey].OutValue = outValue;
    RealTimeMinersInformation[pubkey].Signature = signature;
    if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
        RealTimeMinersInformation[pubkey].PreviousInValue == null)
        RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

    var minersCount = RealTimeMinersInformation.Count;
    var sigNum = signature.ToInt64();
    var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

    // Store current miner's old order before updating
    var currentMinerOldOrder = RealTimeMinersInformation[pubkey].FinalOrderOfNextRound;

    // Check the existence of conflicts about OrderOfNextRound.
    var conflicts = RealTimeMinersInformation.Values
        .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

    foreach (var orderConflictedMiner in conflicts)
    {
        for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
        {
            var maybeNewOrder = i > minersCount ? i % minersCount : i;
            // Exclude current miner's old order and check availability
            if (maybeNewOrder != currentMinerOldOrder && 
                RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
            {
                RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
                break;
            }
        }
    }

    RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
    RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

    return this;
}
```

Additionally, improve validation by checking for duplicate `FinalOrderOfNextRound` values in `NextRoundMiningOrderValidationProvider`:

```csharp
var distinctOrdersCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

## Proof of Concept

A proof of concept would require setting up a test environment with N=3 miners in steady state (all orders occupied), then having one miner produce a block whose signature hash modulo 3 collides with another miner's existing order. The test would verify that both miners end up with the same `FinalOrderOfNextRound` value, and subsequently receive identical `Order` and `ExpectedMiningTime` in the next round generation. Due to the complexity of the AEDPoS consensus setup and the need for specific hash collision conditions, a full working test would require access to the test framework and the ability to control signature values for reproducibility.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L31-40)
```csharp
            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
