# Audit Report

## Title
Miner Identity Manipulation in NextRound Consensus Transitions Due to Missing Miner List Validation

## Summary
The AEDPoS consensus contract fails to validate that miner public keys in `NextRoundInput.RealTimeMinersInformation` match the current round's authorized miner list during round transitions. This allows a malicious miner to arbitrarily replace, add, or remove miners during `NextRound` operations, fundamentally compromising consensus integrity.

## Finding Description

The vulnerability stems from incomplete validation during round transitions. The validation system checks structural properties but critically omits verification that the set of miner public keys remains consistent between rounds.

**Validation Gap Analysis:**

The `RoundTerminateValidationProvider` only validates round number incrementation and null InValue fields: [1](#0-0) 

The `NextRoundMiningOrderValidationProvider` only checks that count of miners with FinalOrderOfNextRound equals count with OutValue, not miner identities: [2](#0-1) 

The `MiningPermissionValidationProvider` only validates the sender is in the base round: [3](#0-2) 

The validation provider registration for NextRound confirms no miner list validation exists: [4](#0-3) 

**Exploitation Path:**

After validation passes, `ProcessNextRound` directly converts the input and stores it without miner list verification: [5](#0-4) 

The `NextRoundInput.ToRound()` method simply copies all provided miner information: [6](#0-5) 

The `AddRoundInformation` method stores the round without validation: [7](#0-6) 

**After-Execution Validation Ineffective:**

The `ValidateConsensusAfterExecution` compares header information to the current round after it has been updated by `ProcessNextRound`, meaning it compares the manipulated data to itself: [8](#0-7) 

**Design Violation:**

The honest `GenerateNextRoundInformation` method preserves the current round's miner list by iterating over existing miners: [9](#0-8) 

However, a malicious miner can bypass this by crafting a custom `NextRoundInput` directly. The design intent is that miner lists should only change during term transitions via `SetMinerList` in `ProcessNextTerm`: [10](#0-9) 

The `SetMinerList` method is only called during `ProcessNextTerm`, not `ProcessNextRound`, confirming miner list changes should be restricted to term boundaries.

## Impact Explanation

**Critical Severity - Consensus Integrity Violation**

This vulnerability fundamentally breaks the blockchain's security model:

1. **Unauthorized Block Production**: Malicious actors can add themselves or colluding parties as miners, enabling unauthorized entities to produce blocks and participate in consensus decisions.

2. **Legitimate Miner Exclusion**: Valid miners elected through the governance process can be arbitrarily removed, preventing them from fulfilling their consensus duties and earning rewards.

3. **Reward Misallocation**: Mining rewards intended for legitimate miners will be distributed to unauthorized participants, directly harming the economic incentives that secure the network.

4. **Governance Bypass**: The entire election mechanism, which determines miner composition through token holder voting, can be circumvented mid-term without any governance approval.

5. **Chain Security Degradation**: The security of the blockchain depends on the honesty threshold among authorized miners. Arbitrary miner list manipulation allows an attacker to potentially achieve majority control by adding multiple colluding identities.

## Likelihood Explanation

**High Likelihood**

The attack is highly practical with realistic preconditions:

**Entry Point**: The `NextRound` method is publicly accessible to any current miner: [11](#0-10) 

**Attacker Requirements**:
- Must be a current authorized miner (to pass `MiningPermissionValidationProvider` and `PreCheck`)
- Must wait for their designated time slot to produce a `NextRound` block
- These are realistic preconditions for any miner, including potentially malicious ones

**Execution Steps**:
1. Malicious miner waits for their turn to produce a `NextRound` transition block
2. Crafts a custom `NextRoundInput` with manipulated `RealTimeMinersInformation` dictionary keys (adding unauthorized miners or removing legitimate ones)
3. Ensures the round number increments correctly and all `InValue` fields are null (to pass existing validations)
4. Submits the `NextRound` transaction
5. All validation passes, and the manipulated miner list is stored in state
6. Subsequent rounds use the compromised miner list

**No Detection Mechanism**: All honest nodes will accept the block because it passes all consensus validations. There is no on-chain detection of miner list manipulation.

## Recommendation

Add miner list consistency validation in the `NextRound` validation path. Specifically:

1. Create a new validation provider `MinerListConsistencyValidationProvider` that:
   - Extracts miner public keys from `validationContext.BaseRound.RealTimeMinersInformation.Keys`
   - Extracts miner public keys from `validationContext.ExtraData.Round.RealTimeMinersInformation.Keys`
   - Verifies both sets contain exactly the same public keys
   - Returns validation failure if any mismatch is detected

2. Register this provider in `ValidateBeforeExecution` for `NextRound` behavior:
```
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new MinerListConsistencyValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

3. Ensure the validation compares against the base round (pre-execution state) rather than post-execution state.

## Proof of Concept

A complete test would demonstrate:

1. Initialize a round with miners [A, B, C]
2. Miner A crafts a `NextRoundInput` with miners [A, B, D] (replacing C with D)
3. Call `NextRound` with this manipulated input
4. Observe that validation passes and the new round contains [A, B, D]
5. Verify that miner C has been removed and unauthorized miner D can now produce blocks

The test would confirm that no validation prevents miner list manipulation during round transitions, violating the core security property that miner lists should only change during term transitions via the election mechanism.

## Notes

This vulnerability represents a critical break in the trust model of the AEDPoS consensus system. The design clearly intends for miner list changes to occur only during term transitions (where `SetMinerList` is called), with round transitions preserving the existing miner set. The missing validation allows this invariant to be violated by any current miner, fundamentally compromising the blockchain's security guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-102)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
