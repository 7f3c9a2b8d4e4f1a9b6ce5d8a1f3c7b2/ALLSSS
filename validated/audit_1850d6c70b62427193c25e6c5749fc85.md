# Audit Report

## Title
Duplicate FinalOrderOfNextRound Values Bypass Validation Due to Incorrect Distinctness Check and Wrong Round Validation

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` contains two critical bugs that allow colluding miners to set duplicate `FinalOrderOfNextRound` values, corrupting the next round's mining schedule. The validation incorrectly applies `.Distinct()` to `MinerInRound` objects instead of their order values, and checks the wrong round (next round instead of current round), allowing duplicate orders to pass validation and break consensus integrity.

## Finding Description

The AEDPoS consensus mechanism relies on unique mining orders to coordinate block production. However, the validation logic contains two critical bugs that allow miners to corrupt the mining schedule:

**Bug #1: Incorrect Use of .Distinct()**

The validation attempts to verify that `FinalOrderOfNextRound` values are unique, but applies `.Distinct()` to the entire `MinerInRound` objects instead of their `FinalOrderOfNextRound` field values. [1](#0-0) 

Since each `MinerInRound` object has a unique `Pubkey` field, they will always be considered distinct as objects, even if they have identical `FinalOrderOfNextRound` values. The correct implementation should select the `FinalOrderOfNextRound` values before applying `.Distinct()`.

**Bug #2: Validating Wrong Round**

The validation checks `providedRound` (the next round being proposed). However, when the next round is generated, the `FinalOrderOfNextRound` field is NOT copied from the current round to the next round: [2](#0-1) 

The generation code only uses `FinalOrderOfNextRound` to set the `Order` field in the next round. The `FinalOrderOfNextRound` field in the newly created `MinerInRound` objects defaults to 0. Therefore, the validation checking `providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)` will always find zero miners, making the check meaningless.

**Attack Vector: Unvalidated TuneOrderInformation**

During `UpdateValue` transactions, miners can set `TuneOrderInformation` to assign `FinalOrderOfNextRound` values, including duplicates: [3](#0-2) 

These values are applied directly to the current round without any uniqueness validation. The `UpdateValueValidationProvider` only validates `OutValue` and `PreviousInValue`: [4](#0-3) 

Furthermore, the `NextRoundMiningOrderValidationProvider` is only invoked for `NextRound` behavior, not for `UpdateValue` behavior: [5](#0-4) 

**Consensus Corruption**

When the next round is generated, duplicate `FinalOrderOfNextRound` values from the current round cause multiple miners to be assigned the same `Order`: [6](#0-5) 

The `occupiedOrders` calculation creates a list containing duplicate order values: [7](#0-6) 

Since `nextRound.RealTimeMinersInformation` is a dictionary keyed by `Pubkey`, both miners with duplicate `FinalOrderOfNextRound` values will exist in the next round with the same `Order` value. The `occupiedOrders` list will contain duplicates, causing the `ableOrders` calculation to incorrectly exclude orders, resulting in some miners being assigned to already-occupied slots and some valid order positions being left empty.

## Impact Explanation

**Consensus Integrity Failure (Critical)**

This vulnerability allows colluding miners to corrupt the mining schedule for the next round, leading to:

1. **Schedule Corruption**: Multiple miners assigned the same `Order` value in the next round will create conflicts in time slot assignments. The consensus mechanism cannot properly determine which miner should produce blocks at each time slot.

2. **Miner Displacement**: The `occupiedOrders` list incorrectly marks orders as occupied even when duplicates exist, reducing the number of available orders for miners who didn't mine in the current round. This causes some miners to be incorrectly assigned or left without valid time slots.

3. **Consensus Halt Risk**: With a malformed round schedule where miners have incorrect or conflicting orders, the consensus mechanism cannot properly coordinate block production. This can cause chain halts, skipped blocks, or complete consensus failure requiring manual intervention.

4. **Fairness Violation**: Colluding miners can manipulate which miners get assigned to favorable time slots or exclude specific miners from participation, breaking the fairness guarantees of the consensus algorithm.

The attack directly violates the critical consensus invariant that each time slot must have exactly one assigned miner, and all miners must have unique, valid order assignments.

## Likelihood Explanation

**High Likelihood - Practical Attack**

1. **Reachable Entry Point**: The attack uses the public `UpdateValue` method that all miners call during normal block production. No special permissions beyond normal miner status are required.

2. **Feasible Preconditions**: 
   - Requires 2+ colluding miners (realistic in PoS systems with concentrated stake)
   - Attack can be executed during any round
   - No governance approvals or special states needed

3. **Execution Practicality**:
   - Miner A calls `UpdateValue` with `TuneOrderInformation = {"MinerB": 5, "MinerC": 5}` to set duplicates
   - The values are applied directly to the current round without validation
   - When `NextRound` is triggered, the buggy validation passes
   - The generated round has corrupted order assignments

4. **Economic Rationality**:
   - Low cost: only requires coordinating `UpdateValue` transactions
   - High impact: disrupts consensus for entire network
   - Difficult to attribute: appears as normal mining behavior until round transition reveals corruption

5. **Detection Constraints**: The bugs are in the validation logic itself, so malicious transactions appear valid until the corrupted round is generated and consensus fails.

## Recommendation

**Fix Bug #1** - Correct the distinct check to operate on order values:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct()
    .Count();
```

**Fix Bug #2** - Validate the current round instead of the provided round:

```csharp
var currentRound = validationContext.BaseRound;
var distinctCount = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
if (distinctCount != currentRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound.";
    return validationResult;
}
```

**Add Validation for UpdateValue** - Include order uniqueness validation in `UpdateValueValidationProvider`:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation
var allFinalOrders = validationContext.ProvidedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (allFinalOrders.Count != allFinalOrders.Distinct().Count())
{
    return new ValidationResult { Message = "Duplicate FinalOrderOfNextRound values detected." };
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test network with at least 3 miners
2. During round N, have Miner A submit an `UpdateValue` transaction with `TuneOrderInformation` containing duplicate order values for Miner B and Miner C
3. Have Miner B and C produce their blocks normally
4. Trigger `NextRound` transition
5. Observe that the validation passes despite duplicate orders
6. Examine the generated round N+1 to confirm multiple miners have the same `Order` value and some order positions are missing
7. Verify that consensus cannot properly coordinate which miner should produce blocks at the conflicting time slot

The test should demonstrate that:
- The `UpdateValue` transaction with duplicate `TuneOrderInformation` is accepted
- The `NextRound` validation incorrectly passes
- The resulting round has corrupted order assignments
- Consensus coordination fails due to the malformed schedule

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.gs (L40-41)
```text

```
