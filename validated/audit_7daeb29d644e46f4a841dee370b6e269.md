# Audit Report

## Title
ProfitDetail ID Collision Causes Transaction Failure in FixProfitDetail and RemoveBeneficiary

## Summary
The Profit contract allows multiple ProfitDetail entries with identical IDs to exist for the same beneficiary, causing `FixProfitDetail` and `RemoveBeneficiary` to fail with `InvalidOperationException`. This occurs when Election candidates quit and rejoin, creating permanent DoS conditions for profit management operations.

## Finding Description

The vulnerability arises from a design flaw where `AddBeneficiary` never validates ProfitDetail ID uniqueness before adding new entries. [1](#0-0) 

The Election contract generates deterministic subsidy IDs based on candidate pubkey, beneficiary address, and contract address. [2](#0-1) 

The Subsidy profit scheme is explicitly created with `CanRemoveBeneficiaryDirectly = true`. [3](#0-2) 

When a candidate quits election, the system calls `UpdateDataCenterAfterMemberVoteAmountChanged`, which triggers `NotifyProfitReplaceCandidateInDataCenter` to invoke `RemoveBeneficiary`. [4](#0-3) 

However, `RemoveBeneficiary` only marks entries with `IsWeightRemoved = true` rather than deleting them when certain conditions are met. [5](#0-4) 

When the candidate rejoins, `AddBeneficiary` is called with the same deterministic subsidyId, creating a duplicate entry. This behavior is explicitly verified in the test suite, confirming that duplicate IDs are expected in the current implementation. [6](#0-5) 

Subsequently, when `FixProfitDetail` is invoked (e.g., when a voter extends their voting period), it uses `.SingleOrDefault()` which throws `InvalidOperationException` when multiple ProfitDetails share the same ID. [7](#0-6) 

Similarly, `RemoveBeneficiary` can fail when attempting to remove entries, as it uses `.Single()` which also throws when duplicates exist. [8](#0-7) 

## Impact Explanation

**Severity: HIGH**

This vulnerability creates operational DoS conditions affecting core profit distribution functionality:

1. **Beneficiaries Impacted**: Election candidates who quit and rejoin cannot have their profit details managed. Voters who voted for such candidates cannot extend voting periods.

2. **Permanent State Corruption**: Once duplicate IDs exist, the affected beneficiary's profit details become permanently unmanageable without direct state intervention.

3. **Protocol Availability**: Critical operations (`FixProfitDetail`, `RemoveBeneficiary`) fail with exceptions, breaking the profit distribution workflow.

4. **Production Evidence**: The test suite explicitly verifies this state exists, yet the contract code uses operations that assume uniqueness, creating a fundamental invariant violation.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers through normal, legitimate user operations:

1. **No Attack Required**: Any candidate performing standard quit/rejoin operations creates this condition.

2. **Deterministic Trigger**: The Election contract manages beneficiaries as part of backup subsidy tracking. When data center membership changes, the system automatically calls profit management functions.

3. **Execution Certainty**: Once duplicate IDs exist, calling `FixProfitDetail` or `RemoveBeneficiary` with those IDs WILL throw exceptions.

4. **Already Occurring**: Test code proves this state is achievable and treated as expected behavior in the current implementation.

## Recommendation

Implement duplicate ID validation in `AddBeneficiary`:

```csharp
public override Empty AddBeneficiary(AddBeneficiaryInput input)
{
    AssertValidInput(input);
    // ... existing validation ...

    var profitDetail = new ProfitDetail
    {
        StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
        EndPeriod = input.EndPeriod,
        Shares = input.BeneficiaryShare.Shares,
        Id = input.ProfitDetailId
    };

    var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
    if (currentProfitDetails == null)
        currentProfitDetails = new ProfitDetails { Details = { profitDetail } };
    else
    {
        // Add duplicate ID check
        if (input.ProfitDetailId != null && 
            currentProfitDetails.Details.Any(d => d.Id == input.ProfitDetailId && !d.IsWeightRemoved))
        {
            throw new AssertionException("ProfitDetail with this ID already exists.");
        }
        currentProfitDetails.Details.Add(profitDetail);
    }
    // ... rest of method ...
}
```

Additionally, modify `FixProfitDetail` and `RemoveBeneficiary` to handle potential duplicates gracefully or filter out `IsWeightRemoved` entries when querying by ID.

## Proof of Concept

The vulnerability is demonstrated in the existing test suite at `BackupSubsidyTests.cs`, specifically the test `SetProfitsReceiver_QuitElection_Check_BackupSubsidy`:

1. A candidate announces election (creates first ProfitDetail with subsidyId)
2. Candidate quits election (marks `IsWeightRemoved = true` but doesn't delete)
3. Candidate rejoins election (creates second ProfitDetail with SAME subsidyId)
4. Test verifies: `profitReceiverBackShare.Details.First().Id.ShouldBe(profitReceiverBackShare.Details.Last().Id)`
5. Any subsequent call to `FixProfitDetail(subsidyId)` will throw `InvalidOperationException` due to `.SingleOrDefault()` receiving multiple matching elements

The test explicitly validates that duplicate IDs exist, proving the contract's production code is incompatible with this state.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-201)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L278-281)
```csharp
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L334-337)
```csharp
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L344-356)
```csharp
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L729-751)
```csharp
        NotifyProfitReplaceCandidateInDataCenter(targetMember, maxVoterPublicKeyStringOutOfDataCenter);
    }

    private void CandidateReplaceMemberInDataCenter(DataCenterRankingList rankingList, string candidate,
        long voteAmount)
    {
        var dateCenter = rankingList.DataCenters;
        if (dateCenter.Count < GetValidationDataCenterCount())
            return;
        if (dateCenter.ContainsKey(candidate))
            return;
        var list = dateCenter.ToList();
        var minimumVoteCandidateInDataCenter = list.OrderBy(x => x.Value).First();
        if (voteAmount <= minimumVoteCandidateInDataCenter.Value) return;
        dateCenter.Remove(minimumVoteCandidateInDataCenter.Key);
        dateCenter[candidate] = voteAmount;
        NotifyProfitReplaceCandidateInDataCenter(minimumVoteCandidateInDataCenter.Key, candidate);
    }

    private void NotifyProfitReplaceCandidateInDataCenter(string oldCandidateInDataCenter,
        string newCandidateDataCenter)
    {
        RemoveBeneficiary(oldCandidateInDataCenter);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L763-766)
```csharp
    private Hash GenerateSubsidyId(string pubkey, Address beneficiaryAddress)
    {
        return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(pubkey), HashHelper.ComputeFrom(beneficiaryAddress),
            HashHelper.ComputeFrom(Context.Self));
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L66-66)
```csharp
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
```

**File:** test/AElf.Contracts.Election.Tests/Full/BackupSubsidyTests.cs (L397-402)
```csharp
            var profitReceiverBackShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(profitReceiver.PublicKey));
            profitReceiverBackShare.Details.Count.ShouldBe(2);
            profitReceiverBackShare.Details.First().IsWeightRemoved.ShouldBeTrue();
            profitReceiverBackShare.Details.Last().IsWeightRemoved.ShouldBeFalse();
            profitReceiverBackShare.Details.First().Id.ShouldBe(profitReceiverBackShare.Details.Last().Id);
```
