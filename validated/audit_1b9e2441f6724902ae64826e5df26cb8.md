# Audit Report

## Title
Unvalidated MinersPreviousInValues Allows Consensus DoS via PreviousInValue Poisoning

## Summary
The AEDPoS consensus contract's secret sharing mechanism unconditionally accepts attacker-supplied `MinersPreviousInValues` without cryptographic or logical validation, allowing malicious miners to poison other miners' `PreviousInValue` fields in on-chain state. This causes victim miners' blocks to fail validation and be rejected, resulting in targeted denial-of-service attacks on consensus participants.

## Finding Description

The vulnerability exists in the interaction between three contract components that creates an exploitable state poisoning attack:

**Root Cause 1: Unconditional Overwrite Without Validation**

The `PerformSecretSharing()` function unconditionally overwrites any miner's `PreviousInValue` with attacker-controlled values from `input.MinersPreviousInValues` without validating correctness. [1](#0-0) 

The function accepts arbitrary hash values for any miner's `PreviousInValue` and directly assigns them to the round state with no verification that these values are correctly reconstructed from secret shares or that they hash to the miners' previous `OutValue`.

**Root Cause 2: Conditional Set Prevents Victim Override**

The `ApplyNormalConsensusData()` function only sets `PreviousInValue` if it is currently empty or null, preventing victims from correcting poisoned values during block generation. [2](#0-1) 

When a victim miner generates their block, they load the poisoned round state from storage. Even though they have the correct `previousInValue` from trigger information, this conditional check prevents overwriting the already-set poisoned value.

**Root Cause 3: Validation Only Checks Sender's Own Value**

The `UpdateValueValidationProvider` validates that the sender's own `PreviousInValue` matches their previous `OutValue`, but does not validate the `MinersPreviousInValues` map being submitted for other miners. [3](#0-2) 

The validation logic only checks `validationContext.SenderPubkey` and ignores all other entries in the `MinersPreviousInValues` dictionary, allowing attackers to submit arbitrary values for victim miners without triggering validation failures.

**Attack Execution:**

1. **Poisoning Phase**: Attacker produces an `UpdateValue` block before victim with malicious `MinersPreviousInValues[VictimPubkey] = WrongHash` where `Hash(WrongHash) != Victim's previous OutValue`

2. **State Corruption**: `ProcessUpdateValue()` calls `PerformSecretSharing()` which unconditionally stores the wrong value on-chain. [4](#0-3) 

3. **Victim Block Generation Failure**: When victim loads the round state and calls `GetConsensusExtraDataToPublishOutValue()`, then applies their consensus data via `ApplyNormalConsensusData()`, the conditional check prevents overriding the poisoned value. [5](#0-4) 

4. **Validation Rejection**: The victim's block undergoes validation where `UpdateValueValidationProvider` is invoked and checks that the victim's `PreviousInValue` hashes to their previous `OutValue`. The validation fails because the poisoned value doesn't hash correctly, causing block rejection. [6](#0-5) 

**Extended Impact - Propagation to Next Round:**

If the victim fails to produce a block in the current round, `SupplyCurrentRoundInformation()` retrieves the poisoned `PreviousInValue` and uses it to calculate the victim's `InValue` and `Signature` for the next round, propagating the attack's impact beyond the current round. [7](#0-6) 

## Impact Explanation

**Severity: HIGH** - This vulnerability enables targeted denial-of-service attacks against consensus participants with direct protocol impact:

**Consensus Disruption:**
- Any active miner can prevent specific miners from producing valid blocks within the current round
- Multiple miners can be targeted simultaneously via a single malicious `UpdateValue` transaction
- If sufficient miners are targeted, the network cannot reach consensus and block production halts

**Direct Harm to Victims:**
- **Revenue Loss**: Targeted miners lose block rewards and transaction fees for missed blocks
- **Reputation Damage**: Missed time slots increment the victim's `MissedTimeSlots` counter, potentially triggering penalties
- **Extended Disruption**: Via `SupplyCurrentRoundInformation()`, the poisoned value propagates to next round calculations, extending the attack's duration

**Network-Wide Impact:**
- **Availability**: Sustained attacks reduce overall network liveness and transaction processing capacity
- **Trust**: Observable consensus manipulation undermines blockchain security guarantees
- **Economics**: Reduced block production affects token emission schedules and network economics

The impact is immediate, deterministic, and affects core consensus integrityâ€”the most critical security property of any blockchain system.

## Likelihood Explanation

**Likelihood: HIGH** - The attack is highly feasible with minimal barriers:

**Attacker Prerequisites:**
- Must be an active miner in the current round (achievable through standard staking/election process)
- Requires no special privileges beyond normal miner status
- Does not require compromising cryptographic keys or consensus contracts

**Attack Complexity:**
- **Simple Execution**: Attacker only needs to modify the `MinersPreviousInValues` field in their `UpdateValue` transaction input
- **No Timing Constraints**: Can be executed during any `UpdateValue` block when attacker's mining slot occurs before victim's
- **Deterministic Success**: No probabilistic factors; if attacker mines first, attack succeeds with 100% certainty

**Economic Feasibility:**
- **Minimal Cost**: Only requires normal transaction fees for `UpdateValue`
- **High Reward**: Can eliminate competition from other miners or extort victims for ransom
- **Low Risk**: Attack is visible on-chain but may not be immediately recognized as malicious

**Detection Difficulty:**
- No built-in monitoring for malicious `MinersPreviousInValues` values
- Requires manual inspection of transaction inputs to detect
- By the time detection occurs, victim blocks are already rejected

The attack requires only standard miner capabilities with no specialized knowledge or resources, making it highly likely to occur in adversarial environments.

## Recommendation

Implement validation of `MinersPreviousInValues` entries to ensure they are cryptographically correct:

1. **In `PerformSecretSharing()`**: Before writing `MinersPreviousInValues` entries to state, validate that each value is either:
   - Correctly reconstructed from secret shares (if secret sharing is in use)
   - Matches `Hash(value) == miner's previous OutValue` (if providing revealed values)

2. **In `UpdateValueValidationProvider`**: Add validation logic to check all entries in `input.MinersPreviousInValues`, not just the sender's own value.

3. **Consider requiring cryptographic proof**: For each entry in `MinersPreviousInValues`, require the submitter to provide proof that the value is legitimate (e.g., sufficient decrypted pieces or signature).

## Proof of Concept

A proof of concept would require:
1. Setting up a test environment with multiple miners
2. Attacker miner modifies their `UpdateValueInput.MinersPreviousInValues` to include wrong hash for victim
3. Attacker submits `UpdateValue` transaction
4. Victim attempts to mine and their block is rejected due to `PreviousInValue` validation failure
5. Verify victim's `MissedTimeSlots` counter increments

The test would demonstrate that the poisoned value persists in state and prevents the victim from producing valid blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```
