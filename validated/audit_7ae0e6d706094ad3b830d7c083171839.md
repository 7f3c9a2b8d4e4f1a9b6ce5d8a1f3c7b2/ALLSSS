# Audit Report

## Title
Off-By-One Error Allows Miner to Produce 9 Continuous Blocks Instead of Intended 8-Block Limit

## Summary
An off-by-one error in the AEDPoS consensus contract allows miners to produce 9 continuous blocks instead of the intended maximum of 8 blocks defined by `MaximumTinyBlocksCount`. The vulnerability stems from flawed initialization logic that doesn't count the first block and uses a `< 0` check instead of `<= 0`, allowing one extra block when `BlocksCount = 0`.

## Finding Description

The AEDPoS consensus mechanism enforces a limit on continuous blocks to ensure fair distribution among miners. The constant `MaximumTinyBlocksCount = 8` [1](#0-0)  explicitly defines this intended maximum.

However, the enforcement logic contains an off-by-one error across three critical points:

**1. First Block Bypass:**
When a miner produces their first block in a sequence, `State.LatestPubkeyToTinyBlocksCount.Value` is `null`. The check in `GetConsensusCommand` [2](#0-1)  requires `Value != null` to evaluate the limit, so the first block bypasses this check entirely.

**2. Flawed Initialization:**
After the first block executes, `ResetLatestProviderToTinyBlocksCount` initializes the counter to `MaximumTinyBlocksCount - 1 = 7` [3](#0-2)  instead of accounting for the already-produced first block. Subsequent blocks decrement this counter [4](#0-3) .

**3. Incorrect Boundary Check:**
Both the command generation and validation use `BlocksCount < 0` as the stopping condition [5](#0-4) . This allows blocks when `BlocksCount = 0`, permitting the 9th block before forcing `NextRound` at `BlocksCount = -1`.

**Execution sequence:**
- Block 1: `null` → passes check → initializes to `BlocksCount = 7` (1 total block)
- Blocks 2-8: `BlocksCount` goes 7→6→5→4→3→2→1→0 (8 total blocks)
- Block 9: `BlocksCount = 0`, check `0 < 0` is FALSE, **allowed** → sets to -1 (9 total blocks - THE EXTRA BLOCK)
- Block 10 attempt: `BlocksCount = -1`, check `-1 < 0` is TRUE, forced to NextRound

The validation logic reads pre-execution state [6](#0-5) , checking the value before it gets decremented, which allows block 9 when `BlocksCount = 0`.

## Impact Explanation

This vulnerability violates a critical consensus invariant with measurable consequences:

1. **Unfair Advantage:** Miners receive 12.5% more continuous block production opportunity (9 vs 8 blocks), allowing them to collect additional transaction fees and MEV for one extra block per sequence.

2. **Consensus Fairness Violation:** The explicit `MaximumTinyBlocksCount = 8` constant represents a protocol-level fairness guarantee. Breaking this constant undermines the consensus mechanism's design intent to prevent block monopolization.

3. **Recurring Impact:** This occurs every time any miner produces their maximum continuous blocks, affecting every consensus round across the network's lifetime.

4. **Systemic Issue:** All miners can exploit this equally, making it a protocol-wide fairness degradation rather than targeted exploitation.

The severity is **Medium** because while it doesn't cause fund loss or system compromise, it systematically violates a documented consensus invariant with quantifiable unfair advantage.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically without special manipulation:

1. **Zero Attacker Prerequisites:** Any miner in the consensus set can trigger this through normal block production. No special permissions, governance control, or timing manipulation required.

2. **Automatic Exploitation:** The flaw activates naturally when miners produce their maximum continuous blocks—no deliberate "attack" action needed.

3. **Universal Occurrence:** Every miner producing maximum continuous blocks experiences this, making it a systematic protocol behavior rather than an edge case.

4. **No Preventable Conditions:** The off-by-one error is deterministic and unavoidable under current code logic.

## Recommendation

Fix the off-by-one error by adjusting the boundary check and initialization logic:

**Option 1: Fix the boundary check**
Change the condition from `BlocksCount < 0` to `BlocksCount <= 0` in both locations:
- `GetConsensusCommand` (line 33)
- `ContinuousBlocksValidationProvider.ValidateHeaderInformation` (line 19)

**Option 2: Fix the initialization**
Initialize to `MaximumTinyBlocksCount` instead of `MaximumTinyBlocksCount - 1` (line 345), since the first block should count.

**Option 3: Count the first block**
Add an additional check before the first block to ensure it also counts against the limit.

**Recommended approach:** Option 1 is the simplest fix - change both checks to use `<= 0` instead of `< 0`, which will correctly enforce the 8-block limit.

## Proof of Concept

The vulnerability is proven through state transition analysis:

**Initial State:** `State.LatestPubkeyToTinyBlocksCount.Value = null`

**Block Production Sequence:**

| Block # | Pre-Check Value | Check Result | Post-Execution Value | Total Blocks |
|---------|-----------------|--------------|---------------------|--------------|
| 1       | null            | Passes (null check) | 7 | 1 |
| 2       | 7               | Passes (7 < 0 = false) | 6 | 2 |
| 3       | 6               | Passes (6 < 0 = false) | 5 | 3 |
| 4       | 5               | Passes (5 < 0 = false) | 4 | 4 |
| 5       | 4               | Passes (4 < 0 = false) | 3 | 5 |
| 6       | 3               | Passes (3 < 0 = false) | 2 | 6 |
| 7       | 2               | Passes (2 < 0 = false) | 1 | 7 |
| 8       | 1               | Passes (1 < 0 = false) | 0 | 8 |
| **9**   | **0**           | **Passes (0 < 0 = false)** | **-1** | **9 ← EXTRA** |
| 10      | -1              | Fails (-1 < 0 = true), forced to NextRound | N/A | N/A |

**Expected Behavior:** MaximumTinyBlocksCount = 8, so only 8 blocks should be allowed.

**Actual Behavior:** 9 blocks are produced due to the `< 0` check allowing block production when count equals 0.

**Mathematical Proof:**
- Starting counter after block 1: 7
- Blocks 2-8 decrement: 7 - 7 = 0
- Block 9: counter is 0, check `0 < 0` evaluates to FALSE, block allowed
- Counter becomes: 0 - 1 = -1
- Total blocks produced: 1 (initial) + 8 (counted) = 9 blocks

This violates the explicit constant `MaximumTinyBlocksCount = 8`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L340-347)
```csharp
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```
