# Audit Report

## Title
Missing Validation of Mining Order Manipulation via TuneOrderInformation in UpdateValue

## Summary
The `UpdateValue` consensus behavior lacks validation for `TuneOrderInformation` entries, allowing a malicious miner to manipulate `FinalOrderOfNextRound` values for any miner in the network. This enables mining order manipulation and consensus integrity violations through invalid order assignments.

## Finding Description

The AEDPoS consensus system maintains two order fields per miner: `SupposedOrderOfNextRound` (deterministically calculated from signature) and `FinalOrderOfNextRound` (adjusted for conflicts). When miners produce blocks locally, they execute `ApplyNormalConsensusData` to calculate orders and resolve conflicts. [1](#0-0) 

Discrepancies between supposed and final orders are communicated via `TuneOrderInformation`, which gets extracted and included in the `UpdateValueInput`: [2](#0-1) 

During block execution, `ProcessUpdateValue` directly applies this tuning information without any validation: [3](#0-2) 

**Root Cause**: The `UpdateValueValidationProvider` performs no validation of `TuneOrderInformation` content, only checking that OutValue and Signature are filled and that PreviousInValue hash is correct: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` which validates order values is only applied to `NextRound` behavior, not `UpdateValue`: [5](#0-4) 

**Attack Path**: A malicious miner modifies their local `ApplyNormalConsensusData` logic to set arbitrary `FinalOrderOfNextRound` values. When `ExtractInformationToUpdateConsensus` runs locally, these malicious values are collected into `TuneOrderInformation` and included in the consensus extra data. During validation, no check detects the manipulation. During execution, the malicious values are written directly to state.

The after-execution hash validation fails to catch this because `RecoverFromUpdateValue` copies the same malicious `FinalOrderOfNextRound` values from the header to the current round before comparing hashes: [6](#0-5) 

This is called before hash comparison in `ValidateConsensusAfterExecution`: [7](#0-6) 

When the next round is generated, these manipulated `FinalOrderOfNextRound` values are used directly to assign mining slots: [8](#0-7) 

## Impact Explanation

This vulnerability breaks consensus integrity by allowing unfair manipulation of the miner schedule:

1. **Mining Order Manipulation**: A malicious miner can set their own `FinalOrderOfNextRound` to 1 to always mine first in the next round, gaining timing advantages and MEV opportunities.

2. **Invalid Order Values**: Assigning orders of 0, negative values, or values greater than `minersCount` disrupts round generation logic, potentially causing exceptions or non-deterministic behavior when the system tries to find miners by specific order values.

3. **Duplicate Orders**: Creating multiple miners with identical `FinalOrderOfNextRound` causes non-deterministic mining time assignment when methods use `FirstOrDefault` to locate miners by order, breaking consensus determinism.

4. **Competitor Disruption**: Assigning high or invalid orders to competing miners delays their mining slots or excludes them from valid positions.

The impact is on **consensus integrity** - the deterministic, fair calculation of mining order based on signatures is violated, allowing arbitrary manipulation by any active miner.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Capabilities**: Any active miner in the consensus rotation can perform this attack by modifying their local node's consensus logic in `ApplyNormalConsensusData`.

**Attack Complexity**: Medium
- Requires local node code modification
- No special privileges beyond being an active miner  
- Single transaction (`UpdateValue`) execution
- No dependency on external conditions or timing

**Feasibility**: The attack is practical because:
1. Entry point is the standard `UpdateValue` method called during normal block production
2. No validation exists to detect malicious `TuneOrderInformation`
3. The consensus header hash validation includes order values, but both header and execution result contain the same malicious values due to `RecoverFromUpdateValue`, so hashes match
4. Malicious local computation is trusted without re-verification

**Detection**: Difficult to detect in real-time as the malicious orders appear in both the consensus header and execution result, passing all hash validation checks.

## Recommendation

Add validation of `TuneOrderInformation` in `UpdateValueValidationProvider`:

1. Verify all order values are within valid range [1, minersCount]
2. Verify no duplicate `FinalOrderOfNextRound` values exist
3. Verify tuning is only applied to miners who actually mined (SupposedOrderOfNextRound != 0)
4. Consider cryptographically verifying the conflict resolution logic or requiring multi-miner attestation for order changes

Alternative approach: Re-compute `FinalOrderOfNextRound` values during `ProcessUpdateValue` execution using the legitimate `ApplyNormalConsensusData` logic instead of trusting the provided `TuneOrderInformation`.

## Proof of Concept

```csharp
// On malicious miner's local node:
// Modify ApplyNormalConsensusData to set arbitrary FinalOrderOfNextRound
public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
{
    // ... normal logic ...
    
    // ATTACK: Instead of following conflict resolution, set arbitrary values
    RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = 1; // Always mine first
    RealTimeMinersInformation[competitorPubkey].FinalOrderOfNextRound = 999; // Delay competitor
    
    return this;
}

// The malicious values will be:
// 1. Collected in ExtractInformationToUpdateConsensus into TuneOrderInformation
// 2. Pass validation (UpdateValueValidationProvider doesn't check them)
// 3. Applied directly in ProcessUpdateValue
// 4. Pass after-execution validation (RecoverFromUpdateValue copies them before hash check)
// 5. Used in GenerateNextRoundInformation to assign mining slots
```

## Notes

This vulnerability demonstrates a critical flaw in the trust model where locally-computed consensus data (`TuneOrderInformation`) is accepted without validation or re-computation. The design assumes miners will execute `ApplyNormalConsensusData` honestly, but any miner can deviate from this assumption to manipulate the mining schedule. The after-execution hash validation mechanism, while intended to detect state manipulation, is ineffective here because it copies the manipulated values before comparison.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
