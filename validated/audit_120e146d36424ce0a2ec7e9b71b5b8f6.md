# Audit Report

## Title
Beneficiaries with EndPeriod=long.MaxValue Cannot Be Removed from Schemes with CanRemoveBeneficiaryDirectly=false

## Summary
When a profit scheme uses the default setting `CanRemoveBeneficiaryDirectly = false` and a beneficiary is added without specifying `EndPeriod` (which defaults to `long.MaxValue`), the scheme manager cannot effectively remove the beneficiary using `RemoveBeneficiary`. The removal silently fails, allowing the beneficiary to continue claiming profits indefinitely and permanently diluting the shares of legitimate beneficiaries.

## Finding Description

The vulnerability exists in the `RemoveProfitDetails` helper method that is called by `RemoveBeneficiary` to determine which profit details can be removed. [1](#0-0) 

When `CanRemoveBeneficiaryDirectly = false`, the filtering logic only includes details where `d.EndPeriod < scheme.CurrentPeriod` in the `detailsCanBeRemoved` list: [2](#0-1) 

However, when beneficiaries are added without specifying `EndPeriod`, the value defaults to 0 and is then automatically set to `long.MaxValue`: [3](#0-2) 

Since `long.MaxValue` (9,223,372,036,854,775,807) is always greater than any realistic `CurrentPeriod` value, the condition `EndPeriod < CurrentPeriod` is never satisfied, resulting in an empty `detailsCanBeRemoved` list. Consequently, the removal loop never executes, and the beneficiary's shares are never subtracted from `TotalShares`: [4](#0-3) 

The default value for `CanRemoveBeneficiaryDirectly` is `false` per the proto3 specification for boolean fields: [5](#0-4) 

After the failed removal, the beneficiary can continue claiming profits because the `ClaimProfits` logic only checks if `EndPeriod >= LastProfitPeriod`, which is always true for `long.MaxValue`: [6](#0-5) 

A workaround exists where providing a `profitDetailId` can bypass the filter: [7](#0-6)  However, this requires knowledge of the internal profit detail ID and is not documented.

## Impact Explanation

This vulnerability has direct financial impact on profit schemes:

1. **Unauthorized Continuous Profit Claims**: After a manager attempts to remove a beneficiary, that beneficiary continues receiving their proportional share of all future profit distributions because their `ProfitDetail` remains in the contract state with `EndPeriod = long.MaxValue`.

2. **Permanent Share Dilution**: The "removed" beneficiary's shares remain in the scheme's `TotalShares`, permanently diluting the profit share of all legitimate beneficiaries. For example, if a removed beneficiary had 100 shares out of 1000 total shares, they continue receiving 10% of all future distributions indefinitely.

3. **Manager Authorization Bypass**: The scheme manager's explicit intent to remove a beneficiary is silently ignored, violating the authorization model where managers have sole control over beneficiary membership.

4. **Silent Failure**: Since `RemoveBeneficiary` returns successfully without throwing an error, managers have no indication that the removal failed, making exploitation undetectable without querying contract state.

Real-world applicability: The Treasury contract creates several schemes with `CanRemoveBeneficiaryDirectly = false` including the Welfare scheme: [8](#0-7)  While the Election contract mitigates this by always specifying explicit EndPeriod values via `GetEndPeriod()`: [9](#0-8) [10](#0-9) , this protection is not enforced by the Profit contract itself, leaving third-party dApps vulnerable.

## Likelihood Explanation

This vulnerability has medium-high likelihood because:

1. **Default Configuration**: Both `CanRemoveBeneficiaryDirectly = false` and `EndPeriod = 0` (â†’ long.MaxValue) are default values, requiring no special configuration to trigger.

2. **Common Usage Pattern**: Test code demonstrates the common pattern of adding beneficiaries without specifying EndPeriod: [11](#0-10) 

3. **Realistic Preconditions**: 
   - Manager creates scheme using defaults
   - Manager adds beneficiary without EndPeriod
   - Manager later calls RemoveBeneficiary (without profitDetailId)
   - Removal silently fails

4. **No Special Privileges Required**: Any scheme manager using normal contract methods can trigger this vulnerability unknowingly.

5. **Silent Failure**: The lack of error notification makes it undetectable without querying state, increasing the probability of exploitation.

## Recommendation

Add explicit validation in the `RemoveBeneficiary` method to ensure beneficiaries are actually removed, and throw an error if the removal fails:

```csharp
public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
{
    // ... existing validation ...
    
    var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);
    
    // Validate that removal succeeded
    var totalRemovedShares = removedDetails.Values.Sum();
    Assert(totalRemovedShares > 0 || currentDetail == null, 
        "Cannot remove beneficiary. Try setting CanRemoveBeneficiaryDirectly=true or provide profitDetailId.");
    
    // ... rest of method ...
}
```

Alternatively, modify the `RemoveProfitDetails` filtering logic to handle `EndPeriod = long.MaxValue` specially when removal is requested by the manager.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_RemoveBeneficiary_WithLongMaxEndPeriod_FailsSilently_Test()
{
    const int shares = 100;
    const int amount = 1000;
    
    var creator = Creators[0];
    var beneficiary = Accounts[0].Address;
    
    // Create scheme with default CanRemoveBeneficiaryDirectly = false
    var schemeId = await CreateSchemeAsync();
    
    // Add beneficiary WITHOUT specifying EndPeriod (defaults to long.MaxValue)
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = shares }
    });
    
    await ContributeProfits(schemeId);
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, amount } }
    });
    
    // Attempt to remove beneficiary
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    
    // VULNERABILITY: TotalShares should be 0, but is still 100
    var schemeAfterRemoval = await creator.GetScheme.CallAsync(schemeId);
    schemeAfterRemoval.TotalShares.ShouldBe(0); // FAILS - actual value is 100
    
    // VULNERABILITY: Beneficiary can still claim profits
    var profitDetails = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    profitDetails.Details.Count.ShouldBe(0); // FAILS - detail still exists
}
```

## Notes

The Election contract has implemented a mitigation by always calculating explicit EndPeriod values based on lock duration, preventing this vulnerability in system-level voting schemes. However, this pattern is not enforced at the Profit contract level, leaving third-party dApp developers vulnerable if they use the default configuration. The silent failure nature of this bug makes it particularly dangerous, as managers receive no indication that their removal requests were ineffective.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L161-163)
```csharp
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L241-241)
```csharp
        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L333-338)
```csharp
        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** protobuf/profit_contract.proto (L130-130)
```text
    bool can_remove_beneficiary_directly = 5;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L379-379)
```csharp
            EndPeriod = GetEndPeriod(lockSeconds),
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L612-616)
```csharp
    private long GetEndPeriod(long lockTime)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        return lockTime.Div(State.TimeEachTerm.Value).Add(treasury.CurrentPeriod);
    }
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L513-517)
```csharp
        await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
        {
            SchemeId = schemeId,
            BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = shares },
        });
```
