# Audit Report

## Title
Zero Threshold Values Enable Permanent Governance Deadlock in Referendum Contract

## Summary
The Referendum contract's validation logic permits `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` to be set to 0, creating an unrecoverable governance state. When these thresholds are zero, any single rejection or abstention vote permanently blocks all proposals, including proposals to modify the thresholds themselves, resulting in irreversible governance deadlock.

## Finding Description

The vulnerability exists in the threshold validation logic which explicitly allows zero values for maximal thresholds. The validation checks `MaximalAbstentionThreshold >= 0` and `MaximalRejectionThreshold >= 0`, meaning zero is a valid and accepted value. [1](#0-0) 

However, the proposal release logic uses strict greater-than comparison to determine if a proposal is blocked. When `MaximalRejectionThreshold = 0`, the condition `proposal.RejectionCount > 0` evaluates to true for any rejection, blocking the proposal. Similarly, when `MaximalAbstentionThreshold = 0`, any abstention blocks the proposal. [2](#0-1) 

The critical issue is that threshold modifications can only be executed by the organization itself through a released proposal. The `ChangeOrganizationThreshold` method verifies `State.Organizations[Context.Sender]`, meaning only the organization address (acting as the transaction sender via a released proposal) can modify its thresholds. [3](#0-2) 

If thresholds are already zero, any proposal to change them requires unanimous approval (zero rejections and zero abstentions), creating a permanent deadlock if any voter dissents, is malicious, or is offline. Organizations are created via public method with no warnings about zero thresholds. [4](#0-3) 

## Impact Explanation

**Permanent Governance DoS:**
- Organizations with zero maximal thresholds become permanently dysfunctional
- All proposals require 100% approval with zero abstentions or rejections
- A single uncooperative, malicious, or offline voter blocks all governance actions permanently
- No admin override, emergency recovery, or alternative mechanism exists to restore functionality

**Attack Scenarios:**
1. **User Error**: Organization creator accidentally sets zero thresholds during creation, misunderstanding the semantics
2. **Social Engineering**: Malicious proposer frames threshold change to zero as "requiring maximum consensus for security" and convinces voters to approve, permanently locking the organization

**Protocol Impact:**
- Governance operations become unavailable permanently
- Token holders lose ability to execute critical configuration changes
- Protocols depending on these organizations for parameter updates are impacted
- The severity is High because the impact is severe (permanent governance loss), irreversible (no recovery path), and affects protocol integrity

## Likelihood Explanation

**Entry Points:**
- `CreateOrganization`: Any user can create organization with zero thresholds via public method
- `ChangeOrganizationThreshold`: Proposers in whitelist can propose threshold changes to zero

**Attack Complexity:**
For active attack:
1. Attacker gains proposer whitelist membership (or is already a member)
2. Creates proposal to change thresholds to zero
3. Socially engineers voters to approve (framing as "enhanced security requiring unanimous consent")
4. Once released, organization is permanently locked

**Likelihood Factors:**
- No validation warnings exist - zero is explicitly allowed
- Users may misunderstand threshold semantics (viewing zero rejections allowed as requiring "unanimous consent" which sounds secure)
- The permanent nature makes even low-probability events catastrophic
- No safeguards prevent this configuration

**Practical Considerations:**
Existing tests confirm zero is the minimum allowed value while negative values are rejected, demonstrating this is a reachable and intended-to-be-valid state. [5](#0-4) 

## Recommendation

Add minimum threshold validation to prevent zero values for `MaximalAbstentionThreshold` and `MaximalRejectionThreshold`. Modify the validation logic in `Referendum_Helper.cs`:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold > 0 &&  // Changed from >= 0
           proposalReleaseThreshold.MaximalRejectionThreshold > 0;      // Changed from >= 0
}
```

This ensures that at least one rejection or abstention is permitted, preventing the unanimous-only deadlock scenario while still allowing strict governance requirements.

## Proof of Concept

```csharp
[Fact]
public async Task ZeroThreshold_Creates_Permanent_Deadlock_Test()
{
    // Create organization with zero rejection threshold
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 5000,
        minimalVoteThreshold: 5000,
        maximalAbstentionThreshold: 10000,
        maximalRejectionThreshold: 0);  // Zero rejection threshold
    
    // Create proposal to change thresholds back to safe values
    var newThresholds = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 5000,
        MinimalVoteThreshold = 5000,
        MaximalAbstentionThreshold = 10000,
        MaximalRejectionThreshold = 10000
    };
    
    var proposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        newThresholds,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress);
    
    // Voter 1 approves (5000 tokens)
    await ApproveAllowanceAsync(Accounts[1].KeyPair, 5000, proposalId);
    await ApproveAsync(Accounts[1].KeyPair, proposalId);
    
    // Voter 2 rejects with just 1 token
    await ApproveAllowanceAsync(Accounts[2].KeyPair, 1, proposalId);
    await RejectAsync(Accounts[2].KeyPair, proposalId);
    
    // Proposal cannot be released - RejectionCount (1) > MaximalRejectionThreshold (0)
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeFalse();
    
    // Release fails - governance is permanently deadlocked
    var releaseResult = await ReferendumContractStub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
}
```

**Notes**

This vulnerability represents a fundamental flaw in the governance threshold validation logic. The semantic confusion between "zero allowed" (permissive) versus "zero rejections tolerated" (restrictive) creates a trap for organization creators. The permanent and irreversible nature of the deadlock, combined with the lack of any recovery mechanism, makes this a critical governance failure mode that requires immediate remediation.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L20-26)
```csharp
        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L98-101)
```csharp
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-28)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-130)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L1162-1176)
```csharp
        //MaximalAbstentionThreshold < 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = -1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MaximalRejectionThreshold < 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MaximalRejectionThreshold = -1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }
```
