# Audit Report

## Title
Missing Empty Address Validation in AddBeneficiary Allows Permanent Profit Loss

## Summary
The `AddBeneficiary` method in the Profit contract fails to validate that beneficiary addresses have non-empty Value fields. This allows scheme managers or the TokenHolder contract to add beneficiaries with empty addresses (`new Address()`), causing allocated profits to be permanently locked in an inaccessible address when distributed and claimed.

## Finding Description

The vulnerability exists in the `AssertValidInput` validation method that only checks if the beneficiary Address object reference is not null, but does not verify the Address has a non-empty Value field: [1](#0-0) 

In AElf's protobuf-based Address type, it is possible to create an Address instance with an empty ByteString Value using `new Address()`. This object passes the null check but has no valid address data.

This contrasts with proper validation patterns used elsewhere in the codebase:

**ResetManager validates with `.Value.Any()`:** [2](#0-1) 

**MultiToken contract validates with proper helper:** [3](#0-2) 

**Execution Path:**

1. Scheme manager or TokenHolder contract calls `AddBeneficiary` with empty address: [4](#0-3) 

2. Empty address passes validation and is stored in ProfitDetailsMap with allocated shares: [5](#0-4) 

3. `DistributeProfits` allocates profits proportionally including to the empty address: [6](#0-5) 

4. `ClaimProfits` transfers tokens via MultiToken contract to the empty address: [7](#0-6) 

5. MultiToken `Transfer` method does not validate recipient address: [8](#0-7) 

6. `DoTransfer` modifies balances without recipient validation: [9](#0-8) 

7. Tokens are permanently locked in `State.Balances[emptyAddress][symbol]` as no one possesses the private key for an empty address.

## Impact Explanation

**Direct Fund Impact:** Tokens allocated to empty address beneficiaries are permanently lost with no recovery mechanism.

**Quantified Damage:** Loss proportional to shares allocated to the empty address. For example, if an empty address receives 100 shares out of 1000 total shares, 10% of all distributed profits are permanently lost.

**Affected Parties:**
- All legitimate beneficiaries suffer reduced profit shares due to dilution
- The scheme itself loses assets that could have been redistributed
- Multiple distribution periods can be affected until the issue is detected

**Severity Justification: HIGH**
- Irreversible loss of funds
- Violates critical invariant of profit distribution accuracy
- No recovery mechanism exists
- Can compound over multiple periods

## Likelihood Explanation

**Attacker Capabilities Required:** Must be scheme manager (scheme creator/owner) OR the TokenHolder system contract.

**Attack Complexity: LOW** - Single transaction to `AddBeneficiary` with `new Address()` as beneficiary, no complex preconditions.

**Feasibility Conditions:**
- Most likely scenario: Programming error in calling contract or management interface
- Malicious scenario: Compromised scheme manager
- No on-chain protection exists to prevent this

**Detection Constraints:** Difficult to detect until profits are distributed and claimed. Empty address entries may not be immediately visible in standard queries.

**Probability Assessment: MEDIUM-HIGH** - While requiring privileged access, the lack of validation makes accidental occurrence through bugs highly probable. The fact that similar operations like ResetManager have proper validation (as evidenced by test at lines 1526-1531) highlights this as an inconsistent oversight: [10](#0-9) 

## Recommendation

Update the `AssertValidInput` method to validate that the Address Value field is not empty, consistent with other address validation patterns in the codebase:

```csharp
private void AssertValidInput(AddBeneficiaryInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    Assert(input.BeneficiaryShare?.Beneficiary != null && 
           !input.BeneficiaryShare.Beneficiary.Value.IsNullOrEmpty(), 
           "Invalid beneficiary address.");
    Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_EmptyAddress_CausesProfitLoss_Test()
{
    // Create a profit scheme
    var creator = Creators[0];
    var schemeId = await CreateSchemeAsync();
    
    // Add legitimate beneficiary with 50 shares
    var legitimateBeneficiary = Accounts[0].Address;
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = legitimateBeneficiary,
            Shares = 50
        },
        EndPeriod = long.MaxValue
    });
    
    // VULNERABILITY: Add empty address beneficiary with 50 shares (should fail but doesn't)
    var emptyAddress = new Address(); // Empty Value field
    var addEmptyResult = await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = emptyAddress,
            Shares = 50  // Gets 50% of profits
        },
        EndPeriod = long.MaxValue
    });
    
    // Validation incorrectly passes
    addEmptyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Contribute 1000 ELF to scheme
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = "ELF",
        Amount = 1000
    });
    
    // Distribute profits for period 1
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Legitimate beneficiary claims - should get 500 ELF but only gets portion
    var balanceBefore = (await creator.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = legitimateBeneficiary,
        Symbol = "ELF"
    })).Balance;
    
    await creator.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = legitimateBeneficiary
    });
    
    var balanceAfter = (await creator.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = legitimateBeneficiary,
        Symbol = "ELF"
    })).Balance;
    
    var received = balanceAfter - balanceBefore;
    
    // Legitimate beneficiary only receives ~500 ELF (50% of 1000)
    // The other 500 ELF allocated to empty address is PERMANENTLY LOST
    // as State.Balances[emptyAddress]["ELF"] = 500 but no one can access it
    received.ShouldBe(500); // Only gets half due to empty address dilution
    
    // Attempt to claim for empty address succeeds but tokens are locked forever
    await creator.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = emptyAddress
    });
    
    // 500 ELF now locked at empty address with no private key to access it
    // Total loss: 500 ELF (50% of distributed profits)
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-174)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-209)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L730-730)
```csharp
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L887-896)
```csharp
                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-105)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-183)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L1526-1531)
```csharp
        resetRet = await creator.ResetManager.SendWithExceptionAsync(new ResetManagerInput
        {
            NewManager = new Address(),
            SchemeId = schemeId
        });
        resetRet.TransactionResult.Error.ShouldContain("Invalid new sponsor.");
```
