# Audit Report

## Title
Missing Validation of SupposedOrderOfNextRound Allows Consensus Order Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miner-provided `SupposedOrderOfNextRound` values match their cryptographically expected values. During validation and state persistence, the system blindly accepts arbitrary order values from miners, enabling consensus schedule manipulation, order theft, and disruption through zero or collision attacks.

## Finding Description

The vulnerability exists in the consensus validation and state update flow where `SupposedOrderOfNextRound` is accepted without cryptographic verification.

When a miner produces a block with `UpdateValue` behavior, the consensus extra data contains a `SupposedOrderOfNextRound` field that should deterministically equal `GetAbsModulus(signature, minersCount) + 1`. However, the validation chain never verifies this invariant. [1](#0-0) 

The correct calculation produces values in range [1, minersCount], but during block validation, the provided value is blindly accepted: [2](#0-1) 

The `RecoverFromUpdateValue` function copies all provided `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values without any validation against the expected cryptographic calculation.

The validation provider only checks signature validity and previous in value correctness, completely omitting order field validation: [3](#0-2) 

The validation flow confirms no order validation occurs during the UpdateValue behavior: [4](#0-3) 

Finally, these unchecked values are persisted directly to state: [5](#0-4) 

## Impact Explanation

The corrupted order values directly break next round generation logic, enabling three critical attack vectors:

**1. Order Stealing Attack**: A malicious miner sets `SupposedOrderOfNextRound = 1` to always claim the first mining position in the next round. The next round generation uses this unchecked value: [6](#0-5) 

This allows repeated first-position claims, maximizing MEV extraction and block rewards.

**2. Consensus Disruption via Zero**: Setting `SupposedOrderOfNextRound = 0` exploits the miner classification logic: [7](#0-6) 

Miners with order 0 are incorrectly classified as "not mined" despite producing blocks, corrupting penalty assignment and order allocation logic which can cause index-out-of-bounds errors or state inconsistencies.

**3. Order Collision**: Multiple miners claiming the same order violate the consensus invariant requiring unique orders in [1, minersCount]. The order assignment logic assumes no duplicates: [8](#0-7) 

Collisions corrupt the available order calculation, potentially causing array access violations or incorrect penalty assignments.

**Severity: HIGH** - This breaks the fundamental "Correct round transitions and miner schedule integrity" consensus invariant. Every block from a malicious miner corrupts future round state.

## Likelihood Explanation

**Attack Requirements**: Any active miner can execute this when producing their assigned block. The miner has full control over the consensus extra data in their block header before signing.

**Attack Complexity**: Low - the attacker modifies a single integer field in the round data structure within the consensus header. The cryptographic signature field (`Signature` in `MinerInRound`) is calculated from `previousInValue`, NOT from `SupposedOrderOfNextRound`, so modifying the order doesn't invalidate the signature check.

**Feasibility**: 
- Works for any active miner (normal precondition)
- No special timing or state setup required
- Exploitable every round after initialization
- Block signature remains valid after modification

**Detection Difficulty**: The malicious value is included in the signed block header, making it appear legitimate without recalculating and comparing against the expected cryptographic value.

**Probability: HIGH** - Any rational miner seeking competitive advantage (first block rights, MEV opportunities) would exploit this. No technical barriers prevent exploitation.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that the provided `SupposedOrderOfNextRound` matches the cryptographically expected value:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    var minerInRound = extraData.Round.RealTimeMinersInformation[publicKey];
    
    if (minerInRound.Signature == null || !minerInRound.Signature.Value.Any())
        return false;
    
    var minersCount = extraData.Round.RealTimeMinersInformation.Count;
    var sigNum = minerInRound.Signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}
```

Add this check to the validation logic in `ValidateHeaderInformation`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };
    
    if (!ValidateSupposedOrderOfNextRound(validationContext))
        return new ValidationResult { Message = "Incorrect supposed order of next round." };

    return new ValidationResult { Success = true };
}
```

Also add the `GetAbsModulus` helper method or reference it from the Round class.

## Proof of Concept

Due to the complexity of the AElf consensus testing infrastructure, a complete runnable test would require extensive test harness setup. However, the vulnerability can be demonstrated by tracing the execution path:

1. A malicious miner receives consensus command to produce block with UpdateValue behavior
2. Miner calls contract to generate consensus extra data, which correctly calculates `SupposedOrderOfNextRound`
3. Before producing the block, miner modifies the `SupposedOrderOfNextRound` field in the `Round` object within `AElfConsensusHeaderInformation` to their desired value (e.g., 1 for first position)
4. Miner signs and broadcasts the block
5. During validation via `ValidateBeforeExecution`, the system calls `RecoverFromUpdateValue` which blindly copies the malicious value
6. `UpdateValueValidationProvider` checks signature and previousInValue but NOT the order field
7. Validation passes, and `ProcessUpdateValue` persists the malicious order to state
8. Next round generation uses the corrupted value, placing the attacker in their chosen position

The key insight is that the `Signature` field (used for validation) is derived from `previousInValue`, NOT from `SupposedOrderOfNextRound`, so the cryptographic check passes despite the manipulation.

**Notes**: The vulnerability is confirmed by examining the complete validation chain and noting the absence of any check that compares the provided `SupposedOrderOfNextRound` against its cryptographically expected value derived from `GetAbsModulus(signature.ToInt64(), minersCount) + 1`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-83)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-56)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-135)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }

    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```
