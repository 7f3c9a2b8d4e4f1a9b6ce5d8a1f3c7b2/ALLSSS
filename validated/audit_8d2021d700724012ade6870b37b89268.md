# Audit Report

## Title
Missing Validation for Negative Resource Amounts Enables Resource Rental Reversal Attack

## Summary
The `InitializeFromParentChain` method in the MultiToken contract lacks validation for negative `ResourceAmount` values. Non-exclusive side chains bypass CrossChain contract validation, allowing negative resource amounts to be set during initialization. This causes rental payment calculations to reverse - side chain creators receive tokens instead of paying fees, draining the consensus contract.

## Finding Description

The vulnerability arises from inconsistent validation across different initialization paths in the resource rental system.

**Root Cause - Missing Validation:**

The `ResourceAmount` state variable stores resource token amounts as signed integers. [1](#0-0) 

The `InitializeFromParentChain` method directly sets resource amounts WITHOUT validating non-negativity. [2](#0-1) 

In contrast, `UpdateRentedResources` properly validates amounts as non-negative. [3](#0-2) 

**Protection Bypass - Validation Gap:**

The CrossChain contract's `AssertValidSideChainCreationRequest` returns early for non-exclusive side chains, bypassing resource amount validation. [4](#0-3) 

The `AssertValidResourceTokenAmount` validation requires positive values but is only called for exclusive chains. [5](#0-4) 

However, `InitialResourceAmount` is passed to side chains for ALL types in the chain initialization data. [6](#0-5) 

The protobuf definition uses `int32`, which permits negative values. [7](#0-6) 

**Exploitation Mechanism:**

When `PayRental` executes, it calculates rental using the potentially negative `ResourceAmount`. [8](#0-7) 

With negative `ResourceAmount`, the rental becomes negative. The balance check `availableBalance >= rental` always passes when rental is negative, causing the method to add tokens to the creator's balance instead of deducting them, while simultaneously removing tokens from the consensus contract.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables direct token theft from the consensus contract with the following impacts:

1. **Fund Loss:** The consensus contract loses tokens proportional to `duration × |ResourceAmount| × Rental` every rental period
2. **Unauthorized Token Generation:** Side chain creators receive free tokens instead of paying rental fees
3. **Economic Invariant Violation:** Breaks the fundamental design where resource rental must flow FROM creator TO consensus
4. **Cumulative Damage:** The theft repeats automatically every rental period (typically 10 minutes) for the lifetime of the side chain

With realistic values (duration=10 minutes, ResourceAmount=-100, Rental=1000), an attacker gains 1,000,000 tokens per period.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is feasible with the following considerations:

**Reachable Entry Point:**
- `RequestSideChainCreation` is a public method callable by any address [9](#0-8) 
- `PayRental` executes automatically during normal mining operations [10](#0-9) 

**Preconditions:**
1. Attacker must create a non-exclusive side chain (permitted operation)
2. Must provide locked token amount and indexing fee allowance (economic barrier exists)
3. Requires governance approval through SideChainLifetimeController
4. No special permissions or compromised keys required

**Execution Practicality:**
- Attack executes automatically after initialization
- No complex transaction crafting needed
- Works within normal AElf runtime semantics
- Accumulates unbounded gains over time

The governance approval requirement adds friction but may not prevent the attack since non-exclusive chains receive less scrutiny and validation focuses on economic parameters rather than technical resource amounts.

## Recommendation

Add validation in `InitializeFromParentChain` to reject negative resource amounts:

```csharp
public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
{
    Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
    State.InitializedFromParentChain.Value = true;
    Assert(input.Creator != null, "creator should not be null");
    
    // ADD VALIDATION HERE
    foreach (var pair in input.ResourceAmount)
    {
        Assert(pair.Value >= 0, "Resource amount must be non-negative.");
        State.ResourceAmount[pair.Key] = pair.Value;
    }
    
    foreach (var pair in input.RegisteredOtherTokenContractAddresses)
        State.CrossChainTransferWhiteList[pair.Key] = pair.Value;
    
    SetSideChainCreator(input.Creator);
    return new Empty();
}
```

Additionally, consider enforcing validation in the CrossChain contract for ALL side chain types, not just exclusive ones.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a non-exclusive side chain with `InitialResourceAmount = {"CPU": -100, "RAM": -100, "DISK": -100, "NET": -100}`
2. Verify the CrossChain validation passes (returns early for non-exclusive chains)
3. Initialize the side chain token contract with this data
4. Trigger `DonateResourceToken` to invoke `PayRental`
5. Assert that the creator's balance increases by `duration × 100 × Rental` for each resource type
6. Assert that the consensus contract's balance decreases by the same amount

The test would confirm that rental payments flow in reverse when ResourceAmount is negative.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L26-26)
```csharp
    public MappedState<string, int> ResourceAmount { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-953)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1019-1097)
```csharp
    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L100-137)
```csharp
    private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
        Address proposer)
    {
        var proposedRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(proposedRequest == null || Context.CurrentBlockTime >= proposedRequest.ExpiredTime,
            "Request side chain creation failed.");

        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = proposer,
            Spender = Context.Self,
            Symbol = Context.Variables.NativeSymbol
        }).Allowance;

        Assert(
            allowance >= sideChainCreationRequest.LockedTokenAmount,
            "Allowance not enough.");

        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");

        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);

        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // assert primary token to create
        AssertValidSideChainTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest);
        Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
               sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
            "Invalid side chain token initial issue list.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L139-145)
```csharp
    private void AssertValidResourceTokenAmount(SideChainCreationRequest sideChainCreationRequest)
    {
        var resourceTokenMap = sideChainCreationRequest.InitialResourceAmount;
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayRentalSymbolListName))
            Assert(resourceTokenMap.ContainsKey(resourceTokenSymbol) && resourceTokenMap[resourceTokenSymbol] > 0,
                "Invalid side chain resource token request.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L516-557)
```csharp
    private ChainInitializationData GetChainInitializationData(SideChainInfo sideChainInfo,
        SideChainCreationRequest sideChainCreationRequest)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var res = new ChainInitializationData
        {
            CreationHeightOnParentChain = sideChainInfo.CreationHeightOnParentChain,
            ChainId = sideChainInfo.SideChainId,
            Creator = sideChainInfo.Proposer,
            CreationTimestamp = sideChainInfo.CreationTimestamp,
            ChainCreatorPrivilegePreserved = sideChainInfo.IsPrivilegePreserved,
            ParentChainTokenContractAddress = State.TokenContract.Value
        };

        var initialConsensusInfo = GetInitialConsensusInformation();
        res.ChainInitializationConsensusInfo = new ChainInitializationConsensusInfo
            { InitialConsensusData = initialConsensusInfo };

        var nativeTokenInformation = GetNativeTokenInfo().ToByteString();
        res.NativeTokenInfoData = nativeTokenInformation;

        var resourceTokenInformation = GetResourceTokenInfo().ToByteString();
        res.ResourceTokenInfo = new ResourceTokenInfo
        {
            ResourceTokenListData = resourceTokenInformation,
            InitialResourceAmount = { sideChainCreationRequest.InitialResourceAmount }
        };

        if (IsPrimaryTokenNeeded(sideChainCreationRequest))
        {
            var sideChainTokenInformation =
                GetTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenSymbol)
                    .ToByteString();
            res.ChainPrimaryTokenInfo = new ChainPrimaryTokenInfo
            {
                ChainPrimaryTokenData = sideChainTokenInformation,
                SideChainTokenInitialIssueList = { sideChainCreationRequest.SideChainTokenInitialIssueList }
            };
        }

        return res;
    }
```

**File:** protobuf/acs7.proto (L202-215)
```text
message SideChainCreationRequest {
    // The cross chain indexing price.
    int64 indexing_price = 1;
    // Initial locked balance for a new side chain.
    int64 locked_token_amount = 2;
    // Creator privilege boolean flag: True if chain creator privilege preserved, otherwise false.
    bool is_privilege_preserved = 3;
    // Side chain token information.
    SideChainTokenCreationRequest side_chain_token_creation_request = 4;
    // A list of accounts and amounts that will be issued when the chain starts.
    repeated SideChainTokenInitialIssue side_chain_token_initial_issue_list = 5;
    // The initial rent resources.
    map<string, int32> initial_resource_amount = 6;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L90-96)
```csharp
    public override Empty RequestSideChainCreation(SideChainCreationRequest input)
    {
        AssertValidSideChainCreationRequest(input, Context.Sender);
        var sideChainCreationRequestState = ProposeNewSideChain(input, Context.Sender);
        State.ProposedSideChainCreationRequestState[Context.Sender] = sideChainCreationRequestState;
        return new Empty();
    }
```
