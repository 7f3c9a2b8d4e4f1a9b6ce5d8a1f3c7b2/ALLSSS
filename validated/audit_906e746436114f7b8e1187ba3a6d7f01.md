# Audit Report

## Title
Incomplete Secret Sharing State Validation Allows Consensus Manipulation via Injected NextRound Data

## Summary
The `ValidationForNextRound()` function only validates that `InValue` is null for miners in the next round, but fails to verify that other secret sharing fields (`OutValue`, `Signature`, `EncryptedPieces`, `DecryptedPieces`, `PreviousInValue`) are also in their initial null/empty state. This allows a malicious extra block producer to inject fake secret sharing data into the next round, compromising consensus randomness and extra block producer selection.

## Finding Description

The vulnerability exists in the round termination validation logic where incomplete field validation allows injection of malicious consensus data.

**Validation Gap:**
The `ValidationForNextRound` method only checks two conditions: round number correctness and that `InValue` is null for all miners [1](#0-0) 

However, the `MinerInRound` protobuf message contains multiple additional secret sharing fields that remain unvalidated [2](#0-1) 

**Unsanitized Data Flow:**
When `NextRound` is called, the malicious `NextRoundInput` is directly converted to `Round` via `ToRound()` which copies ALL fields including secret sharing data without sanitization [3](#0-2) 

The processing flow extracts this unsanitized round and stores it directly to state [4](#0-3) 

The round data is then persisted to state without additional validation [5](#0-4) 

**Legitimate vs. Malicious Data:**
A legitimately generated next round only initializes basic fields (Pubkey, Order, ExpectedMiningTime, ProducedBlocks, MissedTimeSlots) and leaves all secret sharing fields null/empty [6](#0-5) 

**Exploitation Vectors:**

1. **Extra Block Producer Manipulation:** The `CalculateNextExtraBlockProducerOrder` method finds the first miner (by Order) with a non-null Signature to calculate extra block producer selection [7](#0-6) 
   
   By injecting fake Signatures for low-Order miners who didn't mine, an attacker controls which Signature value determines the extra block producer for subsequent rounds.

2. **Randomness Manipulation:** The `RevealSharedInValues` method reads `DecryptedPieces` from the previous round and uses them to reconstruct `PreviousInValue` via secret sharing reconstruction [8](#0-7) 
   
   By injecting coordinated fake `DecryptedPieces`, the attacker controls what `PreviousInValue` gets revealed, compromising the consensus randomness foundation.

## Impact Explanation

This vulnerability directly compromises consensus integrity through two critical attack vectors:

**1. Extra Block Producer Selection Bias:** The attacker can inject specific `Signature` values for miners with low order numbers, causing `CalculateNextExtraBlockProducerOrder()` to use the fake Signature instead of legitimate values. Since the extra block producer order is calculated as `GetAbsModulus(sigNum, blockProducerCount) + 1`, this allows the attacker to influence which miner produces extra blocks in subsequent rounds, enabling potential collusion, MEV extraction, or strategic censorship.

**2. Consensus Randomness Manipulation:** By injecting fake `DecryptedPieces` data, the attacker controls the revealed `PreviousInValue` for miners through `RevealSharedInValues()`. Since `InValue` forms the foundation of consensus randomness via VRF in the secret sharing protocol, this breaks the unpredictability guarantees critical to consensus security.

The severity is **High** because it directly violates consensus integrity - a critical blockchain invariant. While it doesn't immediately steal funds, it enables manipulation of block production ordering, which creates opportunities for secondary attacks including MEV extraction, targeted transaction censorship, and favorable block production scheduling.

## Likelihood Explanation

**Attacker Capabilities:** The attacker must be an active miner in the consensus set who becomes the extra block producer for a round. Since extra block producer selection rotates based on consensus mechanisms, any malicious miner will periodically obtain this role.

**Attack Complexity:** Low to Medium
- The attacker only needs to craft a malicious `NextRoundInput` with fake secret sharing data
- The entry point is the public `NextRound` method called by extra block producers during normal operation
- No complex cryptographic operations or precise timing attacks required

**Feasible Preconditions:**
- Attacker is part of the active miner set (realistic for motivated adversaries)
- Attacker's turn to produce the extra block (happens regularly in rotation)
- No additional permissions or compromised keys needed beyond standard miner status

The likelihood is **High** because the attack is straightforward, requires only standard miner privileges available through normal consensus participation, and has multiple opportunities for execution during the attacker's extra block producer turns.

## Recommendation

Extend `ValidationForNextRound` to validate that ALL secret sharing fields are in their initial null/empty state for the next round:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Validate ALL secret sharing fields are null/empty
    foreach (var miner in extraData.Round.RealTimeMinersInformation.Values)
    {
        if (miner.InValue != null)
            return new ValidationResult { Message = "InValue must be null in next round." };
        if (miner.OutValue != null)
            return new ValidationResult { Message = "OutValue must be null in next round." };
        if (miner.Signature != null)
            return new ValidationResult { Message = "Signature must be null in next round." };
        if (miner.PreviousInValue != null)
            return new ValidationResult { Message = "PreviousInValue must be null in next round." };
        if (miner.EncryptedPieces.Count > 0)
            return new ValidationResult { Message = "EncryptedPieces must be empty in next round." };
        if (miner.DecryptedPieces.Count > 0)
            return new ValidationResult { Message = "DecryptedPieces must be empty in next round." };
    }

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

A proof of concept would involve:
1. Setting up a test consensus environment with multiple miners
2. Making the test miner the extra block producer
3. Crafting a `NextRoundInput` with fake `Signature` values for low-Order miners and fake `DecryptedPieces`
4. Calling `NextRound` with the malicious input
5. Verifying the fake data passes validation and gets stored to state
6. Demonstrating that subsequent calls to `CalculateNextExtraBlockProducerOrder` and `RevealSharedInValues` use the fake data

The test would validate that the malicious data bypasses `ValidationForNextRound` (which only checks `InValue`), gets stored via `AddRoundInformation`, and subsequently affects consensus operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-56)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```
