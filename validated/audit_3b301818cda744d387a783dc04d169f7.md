# Audit Report

## Title
Incorrect Threshold Validation in Secret Sharing Reconstruction Causes Consensus Corruption During Miner List Transitions

## Summary
The `RevealSharedInValues()` function in the AEDPoS consensus contract calculates the decoding threshold for Shamir's secret sharing based on the current round's miner count, but secrets were encoded using the previous round's miner count. When term transitions reduce the validator set size, the function decodes with an insufficient threshold, producing mathematically incorrect in-values that corrupt consensus state.

## Finding Description

The vulnerability exists in the threshold calculation mismatch between secret encoding and decoding in the consensus secret sharing mechanism.

**Secret Encoding Process:**
When miners generate in-values during block production, the off-chain service encodes them using the previous round's miner count to calculate the threshold. [1](#0-0) 

**Secret Decoding Process:**
During round transitions, `RevealSharedInValues()` is called to reconstruct miners' previous in-values. The critical flaw is that it calculates the decoding threshold using the CURRENT round's miner count, not the encoding round's count. [2](#0-1) 

**Insufficient Validation:**
The validation checks on lines 35-36 verify piece availability against the current round's thresholds, not the encoding thresholds. [3](#0-2) 

**Broken Reconstruction:**
The DecodeSecret method is called with the incorrectly calculated threshold, producing a mathematically invalid result. [4](#0-3) 

**Execution Path:**
This is triggered during NEXT_ROUND behavior when transitioning between rounds after a term change. [5](#0-4) 

**Concrete Scenario:**
- Round M (last round of term): 10 miners, secrets encoded with threshold = 6
- Term transition via `ProcessNextTerm` updates miner list [6](#0-5) 
- Round N (first round of new term): 7 miners from election results [7](#0-6) 
- During N→N+1 transition: threshold calculated as 7×2÷3 = 4
- Attempts to decode with 4 pieces when 6 required → incorrect result
- Stores corrupted PreviousInValue in consensus state [8](#0-7) 

**Cryptographic Proof:**
Test cases confirm Shamir's secret sharing requires matching encode/decode thresholds for correct reconstruction. [9](#0-8) 

## Impact Explanation

**HIGH Severity** - This corrupts critical consensus infrastructure:

1. **Consensus State Corruption**: PreviousInValue is stored in round state and used for signature validation and consensus operations throughout subsequent rounds.

2. **Network-Wide Deterministic Failure**: All nodes execute identical (but mathematically incorrect) reconstruction logic, causing network-wide propagation of corrupted state. This is more severe than single-node failures because the entire network accepts invalid data as canonical.

3. **Random Beacon Compromise**: Previous in-values contribute to consensus random number generation. The cryptographic helper's DecodeSecret implementation performs polynomial reconstruction, and using fewer pieces than the encoding threshold mathematically guarantees an incorrect result. [10](#0-9) 

4. **Regular Occurrence**: Term transitions are scheduled protocol events occurring every ~7 days, making this vulnerability triggerable during routine operations.

## Likelihood Explanation

**HIGH Likelihood** - Triggers automatically under normal conditions:

1. **Scheduled Protocol Events**: Term transitions are built into the protocol design and occur regularly based on period configuration.

2. **Natural Validator Set Fluctuations**: Election dynamics cause validator set size changes between terms based on candidate participation and vote distribution—this is expected protocol behavior, not an edge case.

3. **No Attack Required**: The bug triggers deterministically when: (a) term transition occurs, (b) new term has fewer validators, (c) any continuing validator mines blocks. No malicious actions needed.

4. **Both On-chain and Off-chain Affected**: The identical bug exists in the off-chain secret sharing service, ensuring both compute the same incorrect value. [11](#0-10) 

## Recommendation

Modify `RevealSharedInValues()` to use the PREVIOUS round's miner count for threshold calculation, matching the encoding logic:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");
    
    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;
    
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // FIX: Use previousRound miner count for threshold calculation
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;
    
    // Rest of implementation remains the same
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... (existing loop logic)
    }
}
```

Apply the same fix to `RevealPreviousInValues` in `SecretSharingService.cs` to maintain consistency between on-chain and off-chain implementations.

## Proof of Concept

The vulnerability can be demonstrated by verifying that `DecodeSecret` requires exactly the encoding threshold. From the test suite: [12](#0-11) 

This test encodes with threshold T and decodes with threshold T, asserting equality. Using a different threshold (as the vulnerable code does) will produce an incorrect result, proven by the Lagrange interpolation mathematics in the DecodeSecret implementation.

### Citations

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L147-148)
```csharp
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-22)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** test/AElf.Cryptography.Tests/SecretSharingTest.cs (L57-66)
```csharp
    public void SharingTest(string str, int threshold, int totalParts)
    {
        var bytes = Encoding.UTF8.GetBytes(str);
        var parts = SecretSharingHelper.EncodeSecret(bytes, threshold, totalParts);
        Assert.Equal(totalParts, parts.Count);

        var result = SecretSharingHelper.DecodeSecret(parts.Take(threshold).ToList(),
            Enumerable.Range(1, threshold).ToList(), threshold);
        Assert.Equal(bytes, result);
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-64)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
```
