# Audit Report

## Title
User Contract Authorization Bypass via isUserContract Flag Manipulation During Updates

## Summary
User contract authors can permanently downgrade their contract's security model by calling `ProposeUpdateContract` instead of `UpdateUserSmartContract`. This flips the `isUserContract` flag from `true` to `false`, allowing all future updates to bypass the required miner approval and use only Parliament governance.

## Finding Description

User contracts deployed via `DeployUserSmartContract` are designed with a stricter authorization model requiring current miner approval for updates. However, contract authors can bypass this security model by using the wrong update path.

**Root Cause Analysis:**

When a contract author calls `ProposeUpdateContract`, the method only preserves the `IsSystemContract` flag but completely ignores the `isUserContract` flag during proposal creation. [1](#0-0) 

The authorization check only validates that the sender is the contract author, with no validation preventing user contracts from being updated through this path. [2](#0-1) 

The proposal routes to `UpdateSmartContract` as the code check release method. [3](#0-2) 

When the public `UpdateSmartContract` method executes after governance approval, it calls the private helper with `isUserContract` hardcoded to `false`. [4](#0-3) 

The private helper unconditionally overwrites the contract info with this false value, permanently changing the contract from a user contract to a regular contract. [5](#0-4) 

**Bypassed Security Model:**

User contracts are designed to require miner authorization through `ReleaseApprovedUserSmartContract`, which enforces a current miner check. [6](#0-5) 

Once the flag is flipped to false, subsequent updates use `ReleaseCodeCheckedContract` instead, which only validates that the proposer matches with no miner authorization requirement. [7](#0-6) 

In contrast, the correct update path for user contracts through `PerformUpdateUserSmartContract` properly preserves the flag by passing `true` to the helper method. [8](#0-7) 

## Impact Explanation

This is a **High** severity governance vulnerability because:

1. **Authorization Model Bypass**: User contracts were intentionally designed with stricter authorization requiring miner approval. This vulnerability allows authors to unilaterally downgrade this security model to Parliament-only governance, fundamentally altering the trust model.

2. **Permanent State Corruption**: Once the `isUserContract` flag is flipped to `false`, the contract permanently loses its user contract status. All future updates will bypass miner authorization, and there is no standard mechanism to restore the flag.

3. **Protocol Invariant Violation**: Contract types (system, user, regular) should be immutable after deployment. The ACS0 standard defines separate deployment and update paths for user contracts precisely to enforce this distinction. This vulnerability breaks that fundamental invariant.

4. **Trust Violation**: Stakeholders who interact with or depend on a user contract make security decisions based on its governance model. Silent alteration of this model betrays their trust and security assumptions about how the contract can be modified.

5. **Wide Attack Surface**: Any user contract author can execute this attack, affecting all user contracts on the chain. The vulnerability is structural, not configuration-dependent.

## Likelihood Explanation

**High Likelihood** - The attack is trivially executable with minimal prerequisites:

**Attacker Capabilities:**
- Must be the author of a user contract (easily obtainable by deploying one via `DeployUserSmartContract`)
- Requires Parliament approval for the update (same governance process as legitimate updates)

**Attack Complexity:**
- **Low** - The attacker simply calls `ProposeUpdateContract` instead of `UpdateUserSmartContract`
- Both methods are public and accessible to contract authors
- No technical sophistication or special tooling required
- The vulnerability is inherent in the method design, not a race condition or timing issue

**Feasibility:**
1. Deploy a user contract via standard mechanisms
2. Call `ProposeUpdateContract(userContractAddress, newCode)` 
3. Obtain Parliament approval (standard governance)
4. Pass code check review
5. Flag automatically flips during `UpdateSmartContract` execution

**Detection Constraints:**
- The flag change happens silently within state updates with no emitted events
- No logs indicate the contract type has changed
- Users must directly query contract state to detect this has occurred
- The change is only visible through `GetContractInfo` or `GetSmartContractRegistrationByCodeHash` calls

## Recommendation

Add an assertion in `ProposeUpdateContract` to explicitly reject user contracts and force them to use the correct update path:

```csharp
public override Hash ProposeUpdateContract(ContractUpdateInput input)
{
    var proposedContractInputHash = CalculateHashFromInput(input);
    RegisterContractProposingData(proposedContractInputHash);

    var contractAddress = input.Address;
    var info = State.ContractInfos[contractAddress];
    Assert(info != null, "Contract not found.");
    Assert(!info.IsUserContract, "User contracts must use UpdateUserSmartContract.");
    AssertAuthorityByContractInfo(info, Context.Sender);
    // ... rest of method
}
```

Additionally, consider emitting an event when the `isUserContract` flag changes to provide transparency, though this should never occur in normal operation after the fix.

## Proof of Concept

```csharp
[Fact]
public async Task UserContract_AuthorizationBypass_Via_ProposeUpdateContract()
{
    // Setup: Deploy a user contract
    var userContractCode = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value);
    var deployResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract),
        new UserContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory,
            Code = userContractCode
        });
    
    var contractAddress = Address.Parser.ParseFrom(deployResult.ReturnValue);
    
    // Verify isUserContract is initially true
    var initialInfo = await Tester.CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.GetContractInfo),
        contractAddress);
    var initialContractInfo = ContractInfo.Parser.ParseFrom(initialInfo);
    initialContractInfo.IsUserContract.ShouldBeTrue();
    
    // Attack: Use ProposeUpdateContract instead of UpdateUserSmartContract
    var maliciousUpdateCode = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenHolder")).Value);
    var proposeResult = await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ProposeUpdateContract),
        new ContractUpdateInput
        {
            Address = contractAddress,
            Code = maliciousUpdateCode
        });
    
    // Get Parliament approval and release
    var proposalId = ProposalCreated.Parser
        .ParseFrom(proposeResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    
    await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
    await Tester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ReleaseCodeCheckedContract),
        new ReleaseContractInput { ProposalId = proposalId });
    
    // Verify isUserContract has been flipped to false
    var finalInfo = await Tester.CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.GetContractInfo),
        contractAddress);
    var finalContractInfo = ContractInfo.Parser.ParseFrom(finalInfo);
    finalContractInfo.IsUserContract.ShouldBeFalse(); // Authorization model bypassed!
}
```

## Notes

The vulnerability demonstrates a critical flaw in the contract update flow design where the `ProposeUpdateContract` method lacks proper validation to prevent user contracts from using it. The separation of user contract operations (`DeployUserSmartContract`, `UpdateUserSmartContract`, `ReleaseApprovedUserSmartContract`) from regular contract operations was clearly intentional to enforce different security models, but this separation is not enforced at the critical entry points. The fix is straightforward but essential for maintaining the integrity of the user contract authorization model.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L180-184)
```csharp
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L209-216)
```csharp
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L292-299)
```csharp
    public override Empty ReleaseCodeCheckedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L334-334)
```csharp
        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L476-486)
```csharp
    public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");

        AssertCurrentMiner();

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L507-514)
```csharp
    public override Empty PerformUpdateUserSmartContract(UserContractUpdateInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var proposingInput);

        UpdateSmartContract(input.Address, input.Code.ToByteArray(), proposingInput.Author, true);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L109-111)
```csharp
        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;
```
