# Audit Report

## Title
Removed Proposers Retain Proposal Release Authority in Governance Contracts

## Summary
The Association, Parliament, and Referendum contracts allow proposers who have been removed from the ProposerWhiteList to still release previously created proposals after approval. The `Release()` function only verifies the caller matches the original proposer address but does not re-validate current whitelist membership, violating the intended governance security model.

## Finding Description

The vulnerability exists across all three governance contracts where proposal release authorization is insufficient.

**At Proposal Creation**, the system correctly validates proposer authorization against the ProposerWhiteList: [1](#0-0) [2](#0-1) 

The proposer's address is permanently stored in the proposal: [3](#0-2) 

**At Proposal Release**, only the stored proposer address is checked with NO whitelist re-validation: [4](#0-3) 

Organizations can modify the ProposerWhiteList at any time: [5](#0-4) 

**The identical vulnerability pattern exists in Parliament:** [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) 

**And in Referendum:** [10](#0-9) [11](#0-10) [12](#0-11) [13](#0-12) 

This means a proposer removed via `ChangeOrganizationProposerWhiteList` can still release any proposals they created before removal, as long as those proposals have met the approval threshold.

## Impact Explanation

**Governance Authority Bypass:**
- Organizations remove proposers from whitelists to revoke their authority due to security concerns, organizational changes, or loss of trust
- Despite removal, these proposers retain execution authority for all their approved proposals
- This creates a persistent security gap where untrusted actors maintain partial governance control

**Concrete Attack Scenarios:**
1. **Malicious Proposal Release**: A proposer creates multiple proposals. After some get approved but before release, the proposer is removed for suspicious behavior. They can still release the approved proposals to execute malicious actions.
2. **Compromised Account**: If a proposer's account is compromised after proposal approval but before release, the attacker can strategically time proposal execution to maximize damage.
3. **Strategic Timing Exploitation**: Removed proposers can wait for optimal blockchain states (treasury balance peaks, governance transitions) before releasing proposals.

**Severity Justification:**
- **High Impact**: Breaks the fundamental authorization model where whitelist removal should revoke all associated permissions
- **System-Wide Scope**: Affects all three core governance contracts (Association, Parliament, Referendum)
- **Authorization Bypass**: Allows unauthorized proposal execution despite explicit authority revocation

## Likelihood Explanation

**Attacker Requirements:**
- Must initially be an authorized proposer (realistic - organizations have multiple proposers)
- Must create proposals that achieve approval (feasible through normal voting mechanisms)
- Must be subsequently removed from whitelist (common in governance operations)

**Attack Complexity:**
- **Low complexity** - straightforward sequence: create proposal → obtain approval → get removed → call `Release()`
- No complex state manipulation required
- `Release()` is publicly accessible requiring only original proposer identity
- All preconditions occur naturally in normal governance operations

**Feasibility Assessment:**
- All preconditions are realistic and occur in regular governance workflows
- Organizations frequently adjust proposer whitelists as part of member management
- Proposal approval follows standard voting processes
- No special privileges needed beyond initial whitelist membership (which is temporary by design)

**Likelihood Rating: Medium-High**
- Preconditions align with normal governance operations
- Higher probability in organizations with frequent whitelist changes, multiple concurrent proposals, or long proposal expiration periods

## Recommendation

Add whitelist re-validation in the `Release()` function for all three governance contracts. The fix should verify that the proposer is still in the current ProposerWhiteList before allowing proposal execution:

```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add whitelist re-validation
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(organization.ProposerWhiteList.Contains(Context.Sender), 
        "Proposer no longer authorized.");
    
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposalInfo.ToAddress,
        proposalInfo.ContractMethodName, proposalInfo.Params);

    Context.Fire(new ProposalReleased
    {
        ProposalId = input,
        OrganizationAddress = proposalInfo.OrganizationAddress
    });
    State.Proposals.Remove(input);

    return new Empty();
}
```

Apply the same fix to Parliament and Referendum contracts. For Parliament, also check `ParliamentMemberProposingAllowed` conditions if applicable.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_CanStillReleaseApprovedProposal_Test()
{
    // 1. Create organization with proposer in whitelist
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Reviewer1, Reviewer2, Reviewer3 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 2,
            MinimalVoteThreshold = 2,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }  // Reviewer1 is authorized proposer
        }
    };
    var organizationAddress = (await AssociationContractStub.CreateOrganization
        .SendAsync(createOrganizationInput)).Output;

    // 2. Reviewer1 creates a proposal
    var proposalId = (await AssociationContractStubReviewer1.CreateProposal
        .SendAsync(new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractContainer.TokenContractStub.Transfer),
            Params = new TransferInput { To = Reviewer1, Symbol = "ELF", Amount = 100 }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        })).Output;

    // 3. Proposal gets approved by members
    await AssociationContractStubReviewer2.Approve.SendAsync(proposalId);
    await AssociationContractStubReviewer3.Approve.SendAsync(proposalId);

    // 4. Organization removes Reviewer1 from whitelist
    await AssociationContractStub.ChangeOrganizationProposerWhiteList
        .SendAsync(new ProposerWhiteList { Proposers = { } });  // Empty whitelist

    // 5. VULNERABILITY: Removed proposer can still release the approved proposal
    var releaseResult = await AssociationContractStubReviewer1.Release.SendAsync(proposalId);
    
    // This should fail but succeeds
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This test demonstrates that after a proposer is removed from the whitelist, they can still successfully release proposals they created before removal, violating the governance security model.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```
