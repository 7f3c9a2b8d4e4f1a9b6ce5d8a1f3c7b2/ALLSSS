# Audit Report

## Title
Double Removal Vulnerability Allows Profit Share Inflation Through IsWeightRemoved Check Bypass

## Summary
The `RemoveProfitDetails` function contains a critical bypass that allows already-removed profit details to be re-processed, causing `TotalShares` to be incorrectly reduced multiple times for the same beneficiary. This enables direct fund theft where early claimers receive inflated profit shares at the expense of later claimers.

## Finding Description

The vulnerability exists in `RemoveProfitDetails` where a conditional bypass re-adds profit details to the removal list without verifying the `IsWeightRemoved` flag, breaking the intended protection against double-removal. [1](#0-0) 

The code correctly filters out already-removed details using the `IsWeightRemoved` flag. However, a bypass exists that searches all details and re-adds them based solely on their `Id`: [2](#0-1) 

When `LastProfitPeriod < CurrentPeriod` (common after claiming), details are marked `IsWeightRemoved = true` but remain in the list: [3](#0-2) 

The shares are accumulated via `TryAdd`: [4](#0-3) 

Which accumulates values for the same period key: [5](#0-4) 

Finally, `TotalShares` is reduced by the accumulated sum: [6](#0-5) 

**Exploitation Sequence:**

1. **First Call:** Manager calls `RemoveBeneficiary(schemeId, beneficiary, profitDetailId)`
   - Detail added to `detailsCanBeRemoved` (IsWeightRemoved = false)
   - `IsWeightRemoved` set to true, detail may remain in list
   - Shares added to `removedDetails`, `TotalShares` reduced

2. **Second Call:** Manager calls `RemoveBeneficiary` with same parameters
   - Lines 321-324 produce empty list (IsWeightRemoved = true)
   - Line 334-335 conditions satisfied (detail exists, not in empty list)
   - Line 337 **re-adds the already-removed detail** without checking `IsWeightRemoved`
   - Shares accumulated again, `TotalShares` reduced **again** for same shares

## Impact Explanation

This breaks the critical `TotalShares` invariant used as the denominator in profit distribution calculations: [7](#0-6) 

The incorrectly reduced `TotalShares` is stored during distribution: [8](#0-7) 

**Financial Impact Example:**
- Initial: A (1,000), B (1,000), C (8,000), Total = 10,000, Pool = 10,000 tokens
- After double-removal of A: TotalShares = 8,000 (should be 9,000)
- Distribution: Each share worth 1.25 tokens instead of 1.11 tokens
- B receives: 1,250 tokens (expected 1,111) → **+139 tokens stolen**
- C receives: 8,750 tokens (expected 8,889) → **-139 tokens lost**

Early claimers steal from late claimers through artificially inflated share values.

## Likelihood Explanation

The function is accessible to authorized callers: [9](#0-8) 

**Preconditions (all realistic):**

1. Scheme has `CanRemoveBeneficiaryDirectly = true` [10](#0-9) 

2. Beneficiary has ProfitDetail with `Id` set [11](#0-10) 

3. `LastProfitPeriod < CurrentPeriod` (occurs after claiming)

**Exploitation Scenarios:**
- Malicious scheme manager deliberately calls `RemoveBeneficiary` twice to inflate their own profits
- Buggy TokenHolder contract accidentally triggers double-call through retry logic

The exploit is trivial (two identical function calls) and requires only manager authorization. Likelihood: **MEDIUM-HIGH**.

## Recommendation

Add `IsWeightRemoved` check to the bypass condition at lines 334-338:

```csharp
if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId && !d.IsWeightRemoved) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
}
```

This ensures already-removed details (marked with `IsWeightRemoved = true`) cannot be re-added to the removal list.

## Proof of Concept

```csharp
[Fact]
public async Task DoubleRemoval_InflatesProfitShares()
{
    // Setup: Create scheme with CanRemoveBeneficiaryDirectly = true
    var schemeId = await CreateScheme(canRemoveBeneficiaryDirectly: true);
    
    // Add beneficiaries A, B, C
    var beneficiaryA = Accounts[1].Address;
    var beneficiaryB = Accounts[2].Address;
    var beneficiaryC = Accounts[3].Address;
    var detailId = HashHelper.ComputeFrom("detail1");
    
    await AddBeneficiary(schemeId, beneficiaryA, 1000, detailId);
    await AddBeneficiary(schemeId, beneficiaryB, 1000, null);
    await AddBeneficiary(schemeId, beneficiaryC, 8000, null);
    
    var scheme = await GetScheme(schemeId);
    Assert.Equal(10000, scheme.TotalShares); // Initial: 10,000
    
    // Trigger LastProfitPeriod < CurrentPeriod by claiming once
    await DistributeProfits(schemeId, 1, "ELF", 100);
    await ClaimProfits(schemeId, beneficiaryA);
    
    // Double removal exploit
    await RemoveBeneficiary(schemeId, beneficiaryA, detailId); // First removal
    scheme = await GetScheme(schemeId);
    Assert.Equal(9000, scheme.TotalShares); // Should be 9,000
    
    await RemoveBeneficiary(schemeId, beneficiaryA, detailId); // Second removal (EXPLOIT)
    scheme = await GetScheme(schemeId);
    Assert.Equal(8000, scheme.TotalShares); // Incorrectly reduced to 8,000!
    
    // Distribute profits
    await DistributeProfits(schemeId, 2, "ELF", 10000);
    
    // B receives inflated amount
    var balanceBefore = await GetBalance(beneficiaryB, "ELF");
    await ClaimProfits(schemeId, beneficiaryB);
    var balanceAfter = await GetBalance(beneficiaryB, "ELF");
    
    var received = balanceAfter - balanceBefore;
    Assert.Equal(1250, received); // Gets 1,250 instead of 1,111 (139 tokens stolen)
}
```

## Notes

This vulnerability affects any profit scheme where:
- Managers are not fully trusted (third-party dApps)
- Automated contracts (TokenHolder) could have bugs causing duplicate calls
- `CanRemoveBeneficiaryDirectly` flag is enabled

The bypass at lines 334-338 appears to be an attempt to handle a specific edge case but fails to maintain the `IsWeightRemoved` invariant, enabling this critical exploit.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L191-191)
```csharp
            Id = input.ProfitDetailId
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L334-338)
```csharp
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L345-349)
```csharp
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L358-358)
```csharp
                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L567-567)
```csharp
        distributedProfitsInformation.TotalShares = totalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L10-13)
```csharp
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
```
