# Audit Report

## Title
Legitimate Vote Target Changes Blocked by Missing Profit Details Due to Integer Division Rounding

## Summary
Voters cannot change their voting targets with `IsResetVotingTime = true` during a timing gap caused by integer division rounding in profit period calculations. The `GetEndPeriod` method rounds down lock times, creating profit details that expire before the actual vote lock, leading to transaction failures when users attempt legitimate vote changes.

## Finding Description

The vulnerability arises from a mismatch between two time-tracking mechanisms in the Election contract:

**Integer Division Rounds Down the Profit EndPeriod:**

The `GetEndPeriod` method calculates profit eligibility using integer division: [1](#0-0) 

When a 30-day lock (2,592,000 seconds) is divided by the standard 7-day period duration (604,800 seconds), the result is 4.285714, which rounds down to 4 periods (28 days). The profit detail `EndPeriod` thus covers only 28 days, while the actual vote lock stored in `State.LockTimeMap` remains active for the full 30 days.

**Profit Details Are Removed After Claiming:**

When `ClaimProfits` processes periods, it updates `LastProfitPeriod` to the next claimable period: [2](#0-1) 

After claiming through period 4, `LastProfitPeriod` becomes 5. The profit detail is then identified for removal because it satisfies `LastProfitPeriod > EndPeriod`: [3](#0-2) 

The detail is completely removed from storage at line 806.

**Vote Change Operations Fail:**

When attempting to change the voting target, the expiration check uses the full lock time: [4](#0-3) 

This check passes because only 29 days have elapsed (less than the 30-day lock), even though the profit detail expired at 28 days. When `IsResetVotingTime = true`, the code calls `ExtendVoterWelfareProfits`: [5](#0-4) 

The method attempts to retrieve the profit detail: [6](#0-5) 

Since the detail was removed, both ID and Shares lookups return `null`, causing an `AssertionException` at line 158.

## Impact Explanation

**Denial of Service on Core Voting Functionality:**
Users experience transaction failures when attempting to change vote targets with `IsResetVotingTime = true` during the timing gap. This forces users to either:
- Change without resetting time (`IsResetVotingTime = false`), losing extended profit participation benefits
- Wait until full expiration, withdraw, and create a new vote, incurring additional transaction costs

**Affected User Population:**
Any voter whose lock time is not perfectly divisible by 7-day periods experiences this issue:
- 30-day locks create a 2-day gap (172,800 seconds)
- 60-day locks create a 5-day gap
- 90-day locks create a 1-day gap

**No Direct Fund Loss:**
Tokens remain locked and fully recoverable through normal withdrawal after expiration. This is an availability issue, not a fund theft vulnerability.

**Severity: Medium** - Operational disruption to core voting functionality without permanent loss of funds or unauthorized access.

## Likelihood Explanation

**High Probability of Natural Occurrence:**

This issue triggers through routine protocol operations:

1. **Common Lock Periods Create Gaps:** Standard lock times (30, 60, 90, 180 days) often don't divide evenly by 7-day consensus periods (604,800 seconds)

2. **Routine Profit Claiming:** Users and automated systems regularly call `ClaimProfits` to realize rewards, which automatically removes expired profit details

3. **Frequent Vote Changes:** Users commonly adjust voting strategies to optimize rewards or support different candidates

4. **No Attacker Required:** The vulnerability triggers through legitimate public method calls with typical parameters

**Minimal Complexity Trigger Path:**
1. User votes with 30-day lock time
2. 28+ days elapse (past rounded `EndPeriod`)  
3. Anyone calls `ClaimProfits` on welfare scheme
4. User attempts `ChangeVotingOption` with `IsResetVotingTime = true`
5. Transaction reverts with `AssertionException`

## Recommendation

**Option 1: Round Up EndPeriod Calculation**
Modify `GetEndPeriod` to round up instead of down, ensuring profit eligibility covers the entire lock period:

```csharp
private long GetEndPeriod(long lockTime)
{
    var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
    var periods = lockTime.Add(State.TimeEachTerm.Value).Sub(1).Div(State.TimeEachTerm.Value);
    return periods.Add(treasury.CurrentPeriod);
}
```

**Option 2: Check Profit Detail Existence**
Add a null-check in `ExtendVoterWelfareProfits` and handle the missing detail gracefully, either by recreating it or skipping the extension.

**Option 3: Validate Before Removal**
In the Profit contract, prevent removal of profit details for votes that haven't expired according to the Election contract's lock time tracking.

## Proof of Concept

```csharp
[Fact]
public async Task VoteChangeFailsDueToRoundedEndPeriod()
{
    // Setup: Announce candidate and vote with 30-day lock
    var candidate = ValidationDataCenterKeyPairs.First();
    await AnnounceElectionAsync(candidate);
    
    var voter = VoterKeyPairs.First();
    const long lockTime = 30 * 24 * 60 * 60; // 30 days in seconds
    var voteResult = await VoteToCandidateAsync(voter, candidate.PublicKey.ToHex(), 
        lockTime, 1000);
    var voteId = Hash.Parser.ParseFrom(voteResult.ReturnValue);
    
    // Advance time to 29 days (past 28-day rounded EndPeriod, before 30-day expiration)
    BlockTimeProvider.SetBlockTime(StartTimestamp.AddSeconds(29 * 24 * 60 * 60));
    await NextTerm(InitialCoreDataCenterKeyPairs[0]);
    
    // Claim profits - this removes the profit detail
    var profitStub = GetProfitContractTester(voter);
    await profitStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = ProfitItemsIds[ProfitType.CitizenWelfare]
    });
    
    // Attempt to change vote with IsResetVotingTime=true - should fail
    var electionStub = GetElectionContractTester(voter);
    var changeResult = await electionStub.ChangeVotingOption.SendAsync(
        new ChangeVotingOptionInput
        {
            VoteId = voteId,
            CandidatePubkey = ValidationDataCenterKeyPairs.Last().PublicKey.ToHex(),
            IsResetVotingTime = true
        });
    
    // Verify: Transaction fails with AssertionException
    changeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    changeResult.TransactionResult.Error.ShouldContain("Cannot find profit detail");
}
```

## Notes

**Production Configuration:**
The standard `TimeEachTerm` value is 604,800 seconds (7 days), confirmed in production configuration files. This makes the vulnerability immediately applicable to mainnet deployments.

**Workaround Exists But Has Costs:**
Users can work around the issue by using `IsResetVotingTime = false`, but this results in:
- Loss of extended profit participation benefits
- Suboptimal voting strategy outcomes
- Degraded user experience

**No Security Bypass:**
This is not an authentication or authorization bypass - all checks function as designed. The issue is a logic flaw in the interaction between two separate time-tracking mechanisms.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L27-37)
```csharp
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L612-616)
```csharp
    private long GetEndPeriod(long lockTime)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        return lockTime.Div(State.TimeEachTerm.Value).Add(treasury.CurrentPeriod);
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-804)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```
