# Audit Report

## Title
Ineffective FinalOrderOfNextRound Validation Allows Consensus Schedule Corruption

## Summary
The NextRoundMiningOrderValidationProvider fails to properly validate FinalOrderOfNextRound values due to checking the wrong round object and using incorrect distinct logic. Combined with unvalidated TuneOrderInformation in UpdateValue transactions, any malicious miner can inject duplicate mining order assignments, breaking the fundamental consensus invariant that each miner must have a unique Order value in each round.

## Finding Description

**Root Cause 1: Validation Checks Wrong Round**

The NextRoundMiningOrderValidationProvider validates `ProvidedRound` instead of `BaseRound`. [1](#0-0) 

For NextRound behavior, `ProvidedRound` is the newly generated next round (round N+1) contained in the block's extra data. [2](#0-1) 

When NextRound is called, the new round is generated using GenerateNextRoundInformation. [3](#0-2)  In a newly generated round, miners have not yet produced blocks, so their `FinalOrderOfNextRound` values default to 0 (these values determine mining order for round N+2, not N+1). This causes the validation to trivially pass with `distinctCount = 0` and `Count(m => m.OutValue != null) = 0`, checking nothing meaningful.

**Root Cause 2: Incorrect Distinct Logic**

Even if the correct round were checked, the validation calls `Distinct()` on miner objects (MinerInRound instances) rather than their `FinalOrderOfNextRound` integer values. [4](#0-3)  Since each miner is a distinct object instance in C#, this check would pass even with duplicate `FinalOrderOfNextRound` values.

**Attack Vector: Unvalidated TuneOrderInformation**

The ProcessUpdateValue method applies `TuneOrderInformation` directly to state without validation. [5](#0-4) 

The UpdateValueValidationProvider only validates OutValue and PreviousInValue fields, completely ignoring order manipulation. [6](#0-5) 

**Exploitation Flow:**

1. Malicious miner produces a block with UpdateValue behavior during their legitimate mining turn. [7](#0-6) 

2. The miner manipulates FinalOrderOfNextRound values in the block's extra data (via GetUpdateValueRound) to set multiple miners to the same value (e.g., both Miner A and B get FinalOrderOfNextRound = 1). [8](#0-7) 

3. During validation, RecoverFromUpdateValue applies these manipulated FinalOrderOfNextRound values to the base round. [9](#0-8) 

4. Validation passes because UpdateValueValidationProvider doesn't check TuneOrderInformation and no validator checks for duplicate FinalOrderOfNextRound values.

5. During execution, ExtractInformationToUpdateConsensus creates TuneOrderInformation from the manipulated FinalOrderOfNextRound values. [10](#0-9) 

6. State is corrupted with duplicate order assignments through ProcessUpdateValue.

7. When NextRound is triggered, GenerateNextRoundInformation uses these corrupted FinalOrderOfNextRound values to assign mining Order. [11](#0-10) 

8. Multiple miners receive the same Order value in the next round, violating the consensus invariant.

The `occupiedOrders` calculation fails to handle duplicates properly. [12](#0-11)  If `FinalOrderOfNextRound` values contain duplicates like [1, 1, 3], the `Contains` check only excludes order 1 once, not accounting for both miners using it.

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability breaks the critical invariant that each miner must have a unique, sequential Order value for proper round progression. The consequences cascade through multiple consensus mechanisms:

1. **Mining Schedule Corruption**: Multiple miners assigned the same Order believe they should mine at the same time slot, leading to block conflicts and potential chain forks.

2. **Extra Block Producer Logic Failure**: The BreakContinuousMining and CalculateNextExtraBlockProducerOrder functions rely on unique Order values. [13](#0-12)  These functions use `FirstOrDefault(m => m.Order == targetOrder)` which fails unpredictably with duplicate orders.

3. **Time Slot Validation Bypass**: Miners with duplicate Orders could both pass time slot validation simultaneously, undermining the fundamental timing guarantees of the consensus protocol.

4. **LIB Calculation Errors**: Last Irreversible Block height calculation depends on proper miner order sequencing and may produce incorrect results when the ordering is corrupted.

The attack affects all subsequent round transitions until a new term begins with fresh miner list initialization.

## Likelihood Explanation

**MEDIUM Probability**

**Attacker Requirements:**
- Must be an active miner in the consensus set
- No additional special permissions required beyond normal miner status
- Access to public UpdateValue method during legitimate mining turn

**Attack Complexity:**
- Low: Simply manipulate FinalOrderOfNextRound values in block extra data
- No cryptographic complexity or timing precision required
- Validation bypass is automatic due to ineffective NextRoundMiningOrderValidationProvider

**Economic Factors:**
- No economic disincentives beyond normal block production cost
- Potential benefit if attacker can manipulate mining schedule to their advantage
- Detection is delayed until next round manifests corruption

**Preconditions:**
- Attacker is an active miner (realistic for adversarial scenarios where 1-of-N miners is malicious)
- System is in normal consensus operation (always true)

While requiring miner status increases barrier slightly, the reliable exploitation and severe impact justify MEDIUM likelihood.

## Recommendation

**Fix 1: Correct the Validation Target**

NextRoundMiningOrderValidationProvider should validate `BaseRound` (the current round) instead of `ProvidedRound`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound; // Check current round, not new round
    var distinctCount = baseRound.RealTimeMinersInformation.Values
        .Select(m => m.FinalOrderOfNextRound) // Select the integer values
        .Where(order => order > 0)
        .Distinct()
        .Count();
    if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound - duplicates detected.";
        return validationResult;
    }
    validationResult.Success = true;
    return validationResult;
}
```

**Fix 2: Add TuneOrderInformation Validation**

Add validation in UpdateValueValidationProvider to check for duplicate FinalOrderOfNextRound values:

```csharp
private bool ValidateTuneOrderInformation(ConsensusValidationContext validationContext)
{
    var providedRound = validationContext.ProvidedRound;
    var finalOrders = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.FinalOrderOfNextRound)
        .ToList();
    
    // Check for duplicates
    return finalOrders.Count == finalOrders.Distinct().Count();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UpdateValue_WithDuplicateFinalOrderOfNextRound_ShouldCorruptConsensus()
{
    // Setup: Initialize consensus with 3 miners
    await InitializeAEDPoSContract();
    
    // Miner1 produces UpdateValue block with malicious TuneOrderInformation
    var currentRound = await GetCurrentRoundInformation();
    var miner1Pubkey = currentRound.RealTimeMinersInformation.Keys.First();
    var miner2Pubkey = currentRound.RealTimeMinersInformation.Keys.Skip(1).First();
    
    // Maliciously set both miner1 and miner2 to have FinalOrderOfNextRound = 1
    currentRound.RealTimeMinersInformation[miner1Pubkey].FinalOrderOfNextRound = 1;
    currentRound.RealTimeMinersInformation[miner2Pubkey].FinalOrderOfNextRound = 1;
    
    // Create UpdateValueInput with malicious round data
    var updateValueInput = currentRound.ExtractInformationToUpdateConsensus(miner1Pubkey, randomNumber);
    
    // Transaction should pass validation (demonstrating the vulnerability)
    var txResult = await AEDPoSContractStub.UpdateValue.SendAsync(updateValueInput);
    txResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Trigger NextRound
    await ProduceBlocks(100); // Advance to next round trigger
    
    // Get next round and verify corruption: two miners have same Order
    var nextRound = await GetCurrentRoundInformation();
    var orders = nextRound.RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
    
    // Assert: Duplicate Order values exist (vulnerability demonstrated)
    orders.Count.ShouldNotBe(orders.Distinct().Count());
    orders.Where(o => o == 1).Count().ShouldBe(2); // Two miners with Order = 1
}
```

## Notes

This vulnerability exploits a fundamental gap between the validation layer and the execution layer in the AEDPoS consensus protocol. The validation correctly identifies that FinalOrderOfNextRound values need to be unique, but implements the check incorrectly on the wrong round object and with flawed distinct logic. Meanwhile, the execution layer trusts that validation has occurred and directly applies miner-controlled TuneOrderInformation to state. This creates a complete bypass of the Order uniqueness invariant, allowing any malicious miner to corrupt the consensus schedule for subsequent rounds.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-16)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-33)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-90)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```
