# Audit Report

## Title
Zero ResourceAmount Allows Side Chains to Bypass Rental Fees Completely

## Summary
The `UpdateRentedResources` function contains a validation inconsistency that allows ResourceAmount values to be set to zero, completely bypassing the side chain rental fee mechanism. While initial side chain creation strictly enforces positive resource amounts, subsequent updates permit zero values, enabling side chains to eliminate all rental charges and causing direct financial loss to the main chain.

## Finding Description

The vulnerability exists due to a **validation inconsistency** between side chain creation and resource amount updates.

During side chain creation, the CrossChain contract strictly validates that all resource amounts must be strictly positive (> 0). [1](#0-0) 

However, the `UpdateRentedResources` function in the TokenContract uses a weaker validation that permits zero values (>= 0). [2](#0-1) 

When ResourceAmount is set to zero, the rental calculation in `PayRental` becomes: `rental = duration × 0 × Rental[symbol] = 0`, completely eliminating rental charges. [3](#0-2) 

The ResourceAmount state variable represents "amount of resources consumed per minute" (CPU cores, RAM GiB, DISK GiB, NET MB). [4](#0-3) 

Initial resource amounts are set during side chain initialization without additional validation since they were already validated during creation. [5](#0-4) 

The authorization for updates requires approval from the Side Chain Rental Controller, an Association organization with both Parliament and the side chain creator as members. [6](#0-5) [7](#0-6) 

## Impact Explanation

**Direct Financial Impact:**
- Side chains can completely eliminate rental fees for all resources (CPU, RAM, DISK, NET)
- Main chain treasury loses 100% of rental revenue from affected side chains
- The economic model for side chain resource allocation is completely bypassed

**Protocol Invariant Violation:**
The strict validation during creation (> 0) establishes that zero ResourceAmount violates an intended protocol invariant. The validation inconsistency in the update function represents a security weakness that undermines the economic sustainability of the side chain ecosystem.

**Severity: HIGH** - This enables direct, quantifiable financial loss with a clear exploitation path. The validation inconsistency indicates this is an oversight rather than intentional design.

## Likelihood Explanation

**Authorization Requirements:**
Exploitation requires approval from an Association organization that includes both:
- Parliament default organization
- Side chain creator

Both parties must approve any resource amount changes (MinimalApprovalThreshold = 2, MinimalVoteThreshold = 2).

**Economic Incentive:**
Side chains have strong financial motivation to reduce operating costs to zero. The cost of obtaining governance approval is minimal compared to ongoing rental savings over time.

**Detection:**
The change is visible on-chain but the validation explicitly permits zero values, which may not trigger immediate alerts as it appears to be a "valid" state according to the update function logic.

**Likelihood: MEDIUM** - While governance approval creates a barrier, the economic incentive is strong, and the validation weakness suggests the protocol did not intend to prevent this through governance policy alone but rather through code validation.

## Recommendation

Align the validation logic in `UpdateRentedResources` with the stricter validation used during side chain creation:

```csharp
public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
{
    AssertControllerForSideChainRental();
    foreach (var pair in input.ResourceAmount)
    {
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
            "Invalid symbol.");
        Assert(pair.Value > 0, "Invalid amount."); // Changed from >= 0 to > 0
        State.ResourceAmount[pair.Key] = pair.Value;
    }

    return new Empty();
}
```

This ensures that the protocol enforces the economic model invariant at the code level, preventing zero resource amounts regardless of governance decisions.

## Proof of Concept

```csharp
// Test demonstrating zero ResourceAmount bypass
[Fact]
public async Task UpdateRentedResources_ZeroAmount_BypassesRentalFees()
{
    // Setup: Create side chain with initial positive resource amounts
    var initialResourceAmount = new Dictionary<string, int>
    {
        ["CPU"] = 4,
        ["RAM"] = 8,
        ["DISK"] = 512,
        ["NET"] = 1000
    };
    
    // ... side chain creation and initialization ...
    
    // Exploit: Update resource amounts to zero through governance
    var updateInput = new UpdateRentedResourcesInput
    {
        ResourceAmount =
        {
            ["CPU"] = 0,   // Setting to zero passes validation
            ["RAM"] = 0,
            ["DISK"] = 0,
            ["NET"] = 0
        }
    };
    
    // Execute update through rental controller (requires governance approval)
    var result = await RentalControllerStub.UpdateRentedResources.SendAsync(updateInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: PayRental now charges zero fees
    await AdvanceTime(60); // Advance one minute
    await TokenContractStub.DonateResourceToken.SendAsync(new TotalResourceTokensMaps());
    
    // Check that no rental was charged (balance unchanged)
    var balanceAfter = await GetBalance(SideChainCreator, "CPU");
    balanceAfter.ShouldBe(balanceBefore); // No rental deducted!
}
```

**Notes:**
- The validation inconsistency between creation (> 0) and update (>= 0) is the key vulnerability indicator
- The economic model clearly assumes positive resource consumption for operating side chains
- While governance approval is required, this represents a validation weakness rather than intentional design flexibility

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L139-145)
```csharp
    private void AssertValidResourceTokenAmount(SideChainCreationRequest sideChainCreationRequest)
    {
        var resourceTokenMap = sideChainCreationRequest.InitialResourceAmount;
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayRentalSymbolListName))
            Assert(resourceTokenMap.ContainsKey(resourceTokenSymbol) && resourceTokenMap[resourceTokenSymbol] > 0,
                "Invalid side chain resource token request.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1019-1097)
```csharp
    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L19-26)
```csharp
    /// <summary>
    /// Symbol -> Amount (TBD)
    /// (CPU: core)
    /// (RAM: GiB)
    /// (DISK: GiB)
    /// (NET: MB)
    /// </summary>
    public MappedState<string, int> ResourceAmount { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L244-268)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetControllerCreateInputForSideChainRental(
        Address sideChainCreator, Address parliamentAddress)
    {
        var proposers = new List<Address> { parliamentAddress, sideChainCreator };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L407-413)
```csharp
    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```
