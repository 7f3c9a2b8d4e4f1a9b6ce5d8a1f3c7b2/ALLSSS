# Audit Report

## Title
Pending Proposals from Removed Proposers Can Still Be Executed After Whitelist Changes

## Summary
The governance contracts (Parliament, Association, and Referendum) validate proposer authorization only at proposal creation time. When a proposer is removed from the whitelist via `ChangeOrganizationProposerWhiteList()`, their pending proposals remain executable because the `Release()` function does not re-validate authorization status, allowing removed proposers to execute previously created proposals.

## Finding Description

This vulnerability breaks the fundamental security guarantee that whitelist removal revokes all proposal privileges.

**Authorization at Creation Time:**

In Parliament, proposal creation enforces authorization checks through `AssertIsAuthorizedProposer`: [1](#0-0) 

The authorization validation checks whitelist membership or parliament member status: [2](#0-1) 

Association follows the same pattern with whitelist validation: [3](#0-2) [4](#0-3) 

Referendum also validates against its proposer whitelist: [5](#0-4) [6](#0-5) 

**No Re-validation at Release Time:**

When releasing a proposal in Parliament, the function only verifies the caller is the original proposer without re-validating current authorization status: [7](#0-6) 

Association has the same flaw - checking only proposer identity: [8](#0-7) 

Referendum follows the identical pattern: [9](#0-8) 

**Whitelist Updates Don't Invalidate Pending Proposals:**

The `ChangeOrganizationProposerWhiteList` function in Parliament updates the whitelist without validating or cleaning up pending proposals from removed addresses: [10](#0-9) 

Association and Referendum have identical implementations that don't invalidate pending proposals: [11](#0-10) [12](#0-11) 

**Attack Sequence:**
1. Attacker (legitimate proposer) creates proposal with far-future expiration
2. Malicious behavior is detected, governance removes them from whitelist via approved proposal
3. Removed proposer cannot create NEW proposals (correctly blocked by authorization check)
4. However, their OLD proposal continues to collect votes normally
5. Once vote threshold is reached, removed proposer calls `Release()` successfully
6. The proposal executes despite proposer no longer being authorized

## Impact Explanation

**High Severity - Governance Authorization Bypass**

This vulnerability directly undermines the core security model of AElf's governance system. The whitelist mechanism exists specifically to control who can propose and execute governance actions. When an address is removed from the whitelist - typically due to discovered malicious behavior, compromised private keys, or loss of trust - the security expectation is that ALL their governance privileges are immediately revoked.

However, removed proposers retain the ability to execute any proposals they created while authorized. Depending on the proposal's content, this could enable:
- Unauthorized system configuration changes
- Fund transfers or treasury manipulation  
- Contract upgrades or deployments
- Changes to consensus parameters
- Modification of fee structures

The impact extends across all organizations using these three core governance contracts:
- **Parliament**: Controls critical system governance including the default organization that manages protocol-level decisions
- **Association**: Used for multi-signature governance in organizational settings
- **Referendum**: Enables token-weighted voting for community governance

A single compromised or malicious proposer can "time-bomb" the system by creating benign-looking proposals before their removal, then executing them later to bypass whitelist protection.

## Likelihood Explanation

**Medium-High Likelihood**

The attack has low complexity and realistic preconditions:

**Attacker Profile:**
- Must initially be a legitimate authorized proposer (in whitelist or parliament member)
- Could be an insider threat or a compromised authorized address
- No special permissions required beyond normal proposal flow

**Attack Feasibility:**
- Zero cost to maintain pending proposals
- Proposals can have far-future expiration times  
- No blockchain state manipulation required
- Standard transaction flow using public methods

**Economic Rationality:**
Highly rational for a malicious actor. Once they suspect they might be removed (or after committing malicious acts), they can pre-emptively create proposals that will execute after their removal. The attack has zero ongoing cost and cannot be easily detected until execution.

**Detection Difficulty:**
The pending proposal appears completely legitimate in the system. Governance would need to manually track all pending proposals and cross-reference them against whitelist changes to identify this threat proactively.

## Recommendation

Add authorization re-validation in the `Release()` function for all three governance contracts. Before executing a proposal, re-check that the proposer is still authorized:

For Parliament:
```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    
    // Add re-validation of current authorization status
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, proposalInfo.Proposer);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposalInfo.ToAddress, proposalInfo.ContractMethodName, proposalInfo.Params);
    Context.Fire(new ProposalReleased { ProposalId = proposalId });
    State.Proposals.Remove(proposalId);
    return new Empty();
}
```

Apply the same pattern to Association and Referendum contracts by calling `AssertIsAuthorizedProposer()` before executing the proposal.

Alternatively, when `ChangeOrganizationProposerWhiteList()` is called, iterate through all pending proposals and mark as invalid or remove proposals from addresses no longer in the whitelist.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_CanStillReleaseOldProposal_Test()
{
    // 1. Setup: Attacker is initially in whitelist
    var attackerKeyPair = CryptoHelper.GenerateKeyPair();
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    var attackerTester = Tester.CreateNewContractTester(attackerKeyPair);
    
    var organizationAddress = await GetDefaultOrganizationAddressAsync();
    
    // Add attacker to whitelist
    var addToWhitelistInput = new ProposerWhiteList
    {
        Proposers = { Tester.GetCallOwnerAddress(), attackerAddress }
    };
    var addProposalInput = CreateParliamentProposalInput(addToWhitelistInput, organizationAddress);
    var addResult = await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
        nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateProposal), addProposalInput);
    var addProposalId = Hash.Parser.ParseFrom(addResult.ReturnValue);
    await ParliamentMemberApprove(addProposalId);
    await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
        nameof(ParliamentContractImplContainer.ParliamentContractImplStub.Release), addProposalId);
    
    // 2. Attacker creates malicious proposal
    var maliciousTransfer = TransferInput(attackerAddress);
    var maliciousProposalInput = CreateProposalInput(maliciousTransfer, organizationAddress);
    var createResult = await attackerTester.ExecuteContractWithMiningAsync(ParliamentAddress,
        nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateProposal), maliciousProposalInput);
    createResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var maliciousProposalId = Hash.Parser.ParseFrom(createResult.ReturnValue);
    
    // 3. Governance removes attacker from whitelist
    var removeFromWhitelistInput = new ProposerWhiteList
    {
        Proposers = { Tester.GetCallOwnerAddress() } // Only original proposer
    };
    var removeProposalInput = CreateParliamentProposalInput(removeFromWhitelistInput, organizationAddress);
    var removeResult = await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
        nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateProposal), removeProposalInput);
    var removeProposalId = Hash.Parser.ParseFrom(removeResult.ReturnValue);
    await ParliamentMemberApprove(removeProposalId);
    await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
        nameof(ParliamentContractImplContainer.ParliamentContractImplStub.Release), removeProposalId);
    
    // 4. Verify attacker cannot create NEW proposals
    var newProposalAttempt = await attackerTester.ExecuteContractWithMiningAsync(ParliamentAddress,
        nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateProposal), maliciousProposalInput);
    newProposalAttempt.Status.ShouldBe(TransactionResultStatus.Failed);
    newProposalAttempt.Error.Contains("Unauthorized to propose.").ShouldBeTrue();
    
    // 5. Get votes for old proposal
    await ParliamentMemberApprove(maliciousProposalId);
    
    // 6. VULNERABILITY: Removed proposer can still release old proposal
    var releaseResult = await attackerTester.ExecuteContractWithMiningAsync(ParliamentAddress,
        nameof(ParliamentContractImplContainer.ParliamentContractImplStub.Release), maliciousProposalId);
    
    // This should fail but currently succeeds
    releaseResult.Status.ShouldBe(TransactionResultStatus.Mined); // VULNERABILITY DEMONSTRATED
}
```

## Notes

This vulnerability exists because the authorization model treats proposal creation and execution as separate privileges, but only validates authorization at creation time. The security model assumes that once a proposer is authorized to create a proposal, they maintain that privilege through the proposal's lifetime. However, the whitelist mechanism is explicitly designed to revoke privileges, creating a semantic mismatch.

The fix requires either:
1. Re-validating authorization at release time (recommended for immediate security)
2. Invalidating pending proposals when proposers are removed (more comprehensive but requires state cleanup)

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```
