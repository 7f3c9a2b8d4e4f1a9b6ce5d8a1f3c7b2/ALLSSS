# Audit Report

## Title
Missing Signature Verification Allows Miner Order Manipulation in Next Round

## Summary
The AEDPoS consensus mechanism fails to verify that the signature value provided by miners is correctly computed, allowing malicious miners to manipulate their mining order in the next round. The signature is used to deterministically calculate mining positions, but validation only checks for non-null values without recomputing and verifying correctness.

## Finding Description

The vulnerability exists in the consensus data application and validation flow. When a miner produces a block, their signature value should be deterministically calculated using the `CalculateSignature` method, which XORs the miner's previous in-value with all signatures from the previous round to produce a cryptographically secure random value. [1](#0-0) 

The consensus extra data generation correctly calculates this signature by calling `previousRound.CalculateSignature(triggerInformation.PreviousInValue)`: [2](#0-1) 

However, the `ApplyNormalConsensusData` function directly accepts and uses the signature parameter without verification, immediately converting it to calculate the mining order: [3](#0-2) 

The validation flow through `UpdateValueValidationProvider` only performs a non-null check on the signature field: [4](#0-3) 

It validates that `PreviousInValue` hashes correctly to the previous round's `OutValue`: [5](#0-4) 

But critically, there is no validation that recomputes `CalculateSignature(PreviousInValue)` and compares it to the provided signature.

When the `UpdateValue` transaction executes, it directly assigns the unverified signature from the input: [6](#0-5) 

**Attack Vector:**

Since `GetConsensusExtraData` and `GenerateConsensusTransactions` are view methods (part of the ACS4 interface): [7](#0-6) 

A malicious miner can:
1. Call these methods locally to obtain correctly calculated consensus data
2. Modify the signature value before block creation to achieve a desired mining order  
3. Submit the block with the manipulated signature
4. Pass validation since only non-null checks are performed

The manipulated signature becomes part of the round state and directly determines the miner's position in the next round through `FinalOrderOfNextRound`, which is used to schedule mining times in next round generation: [8](#0-7) 

## Impact Explanation

**Critical Consensus Integrity Violation:**
This vulnerability breaks a fundamental invariant of the AEDPoS consensus mechanism - that mining order is determined by cryptographically secure, unpredictable randomness. By allowing miners to choose their position in the next round, the system loses its fairness guarantees.

**Economic Impact:**
- Miners mining earlier in a round collect more transaction fees (processed first)
- Strategic positioning enables MEV (Maximal Extractable Value) opportunities
- Earlier miners have higher influence on the Last Irreversible Block height calculations, affecting chain finality

**Randomness Pollution:**
The manipulated signature becomes part of the round state and is used by `CalculateSignature` in subsequent rounds, affecting randomness calculations for multiple future rounds and potentially compounding the attacker's advantage.

**Undetectable Attack:**
The manipulated signature appears valid in all respects (proper format, non-null) and leaves no trace in validation failures, making the attack impossible to detect without implementing signature recomputation.

## Likelihood Explanation

**High Likelihood:**
- Any miner in the consensus set can execute this attack
- Requires only modification of node software to alter consensus extra data before block submission
- No special privileges beyond normal mining rights required
- Zero additional cost beyond normal block production
- No risk of detection or penalty

**Low Complexity:**
The attacker simply needs to:
1. Intercept the consensus extra data generation
2. Calculate which signature values yield favorable orders via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. Replace the correct signature with the chosen value
4. Submit the block normally

**Economic Rationality:**
With zero cost and risk, rational miners are incentivized to exploit this for competitive advantage in fee collection and strategic block positioning.

## Recommendation

Add signature verification in the `UpdateValueValidationProvider` by recomputing the signature and comparing it to the provided value:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    var providedRound = extraData.Round;
    var previousRound = validationContext.PreviousRound;
    
    if (!providedRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return false;
    
    var minerInRound = providedRound.RealTimeMinersInformation[publicKey];
    var previousInValue = minerInRound.PreviousInValue;
    
    // If no previous in value, signature cannot be validated this way
    if (previousInValue == null || previousInValue == Hash.Empty) 
        return true;
    
    // Recompute expected signature
    var expectedSignature = previousRound.CalculateSignature(previousInValue);
    
    // Compare with provided signature
    return expectedSignature == minerInRound.Signature;
}
```

Then call this method in the `ValidateHeaderInformation` method of `UpdateValueValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };
    
    // Add signature verification
    if (!ValidateSignature(validationContext))
        return new ValidationResult { Message = "Incorrect signature value." };

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

A proof of concept would require:
1. Setting up a test AEDPoS consensus environment with multiple miners
2. Modifying a miner node to intercept `GetConsensusExtraData` output
3. Calculating optimal signature values that yield favorable mining orders (order 1 or 2)
4. Replacing the correct signature with the manipulated value
5. Broadcasting the block and observing it passes validation
6. Verifying the miner receives the manipulated order in the next round
7. Demonstrating repeated exploitation across multiple rounds

The test would verify that:
- The manipulated signature passes validation (non-null check only)
- The `FinalOrderOfNextRound` is set based on the manipulated signature
- The miner's `ExpectedMiningTime` in the next round reflects the chosen order
- No validation failures occur despite the signature being incorrect

**Notes**

The vulnerability is particularly severe because:
1. The `randomNumber` field in `UpdateValueInput` is validated using `ECVrfVerify`, but this is separate from the `signature` field
2. No alternative validation mechanism catches the signature manipulation
3. The manipulated signature pollutes future rounds' randomness calculations
4. The attack is economically rational and has zero detection risk

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-21)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
